Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost,Attack Type
0,,,,,,,
1,"void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}","void NumberFormatTest::verifyFieldPositionIterator(
int rt;
TCGv T00, ttyapp;
gen_load_gpr(ttyapp, rt);
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    int a = 2;
    int b = 2;
    while (a == b) {
        FieldPosition fp;
        b += 1;
    }
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}",0,1,19,0.83,Insert
2,"GF_Box *dac3_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);
	return (GF_Box *)tmp;
}","GF_Box *dac3_box_new()
{
	AVCodecContext *AVcas;
	uint32_t max_level, max_mb, max_width, max_height;
	PutBitContext pb, pb2;
	JLSState *state;
	ls_store_lse(state, &pb);
	av_freep(&state);
	av_freep(&state);
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	int a = 2;
	int b = 3;
	if (a != b) {
    	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);
	}
	return (GF_Box *)tmp;
}",0,1,35,0.44,Insert
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int64_t unit_8;
    unsigned char c_6;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c_6, unit_8);
    int flags = OBJ_NO_FLAGS;
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    int a = 2;
    int b = 2;
    if (a == b) {
        setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
    }
}",0,1,14,0.62,Insert
7,,,,,,,
8,,,,,,,
9,"void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	session->smb2->replay_active = false;
}","void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	attribute=GetXMLTreeAttribute(levels,""width"");
	table->width=StringToUnsignedLong(attribute);
	attribute=GetXMLTreeAttribute(levels,""height"");
	table->height=StringToUnsignedLong(attribute);
	session->smb2->replay_active = false;
}",0,1,3,0.1,Insert
13,,,,,,,
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->commonName;
    case 7:
       return name->serialDev;
#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;
    case 9:
#else
    case 8:
#endif
       return name->email;
    default:
       return 0;
    }
}","const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->commonName;
    case 7:
       return name->serialDev;
#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;
    case 9:
#else
    case 8:
#endif
       return name->email;
    default:
       int a = 2;
       int b = 3;
       const struct dom_sid *alias;
       TALLOC_CTX *mem_stack;
       struct pdb_methods *mut;
       struct ldb_dn *anon;
       TALLOC_CTX *mem_context = talloc_new(mem_stack);
       struct dom_sid_buf buf;
       struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
       		mut->private_data, struct pdb_samba_dsdb_state);
       NT_STATUS_HAVE_NO_MEMORY(mem_context);
       anon = ldb_dn_new_fmt(
       		mem_context,
       		area->ldb,
       		""<SID=%s>"",
       		dom_sid_str_buf(alias, &buf));
       talloc_free(mem_context);
       if (a != b) {
           return 0;
       }
    }
}",0,1,21,0.62,Insert
17,"virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;
    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;
    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;
    if (!data.src)
        return 0;
    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }
    return rc;
}","virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    int a = 82;
    int b = a;
    if(a*b>0){
        struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    }
    int rc;
    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;
    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;
    if (!data.src)
        return 0;
    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid_3, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid_3,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    return rc;
}",0,1,10,0.83,Insert
18,"free_wininfo(wininfo_T *wip)
{
    if (wip->wi_optset)
    {
	clear_winopt(&wip->wi_opt);
#ifdef FEAT_FOLDING
	deleteFoldRecurse(&wip->wi_folds);
#endif
    }
    vim_free(wip);
}","free_wininfo(wininfo_T *wip)
{
    if (wip->wi_optset)
    {
	clear_winopt(&wip->wi_opt);
#ifdef FEAT_FOLDING
	deleteFoldRecurse(&wip->wi_folds);
#endif
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        vim_free(wip);
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
        b += 1;
    }
}",0,1,9,0.36,Insert
19,"static bool tight_can_send_png_rect(VncState *vs, int w, int h)
{
    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {
        return false;
    }
    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||
        vs->client_pf.bytes_per_pixel == 1) {
        return false;
    }
    return true;
}","static bool tight_can_send_png_rect(VncState *vs, int w, int h)
{
    DisasContext *qs;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    handle_fp_compare(qs, order, coll, err, false, p);
    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {
        return false;
    }
    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||
        vs->client_pf.bytes_per_pixel == 1) {
        return false;
    }
    int a = 53;
    int b = a;
    if(a*b>0){
        return true;
    }
}",0,1,8,0.39,Insert
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                    
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);
      init_func(qdatabase);
      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ","static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    int a = 2;
    int b = 2;
    while (a == b) {
        return 1;                    
        b += 1;
    }
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);
      init_func(qdatabase);
      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ",1,0,3,0.17,Replace
23,"SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all saddr;
  socklen_t saddr_len;
  saddr_len = sizeof (saddr);
  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }
  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||
      saddr.sa.sa_family != AF_UNIX)
    return 0;
  if (unlink(saddr.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", saddr.un.sun_path, strerror(errno));
    return 0;
  }
  DEBUG_LOG(""Removed %s"", saddr.un.sun_path);
  return 1;
}","SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all saddr;
  socklen_t saddr_len;
  saddr_len = sizeof (saddr);
  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {
    int a = 2;
    BlockDriverState *bs;
    if (bs->device_name[0] != '\0') {
            QTAILQ_REMOVE(&bdrv_states, bs, list);
            BlockDriverState *bs_2;
            if (bs_2->device_name[0] != '\0') {
                    QTAILQ_REMOVE_1(&bdrv_states_10, bs_2, list_10);
            }
    }
    int b = 3;
    while (a != b) {
        DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
        b = a;
    }
    return 0;
  }
  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||
      saddr.sa.sa_family != AF_UNIX)
    return 0;
  if (unlink(saddr.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", saddr.un.sun_path, strerror(errno));
    return 0;
  }
  DEBUG_LOG(""Removed %s"", saddr.un.sun_path);
  return 1;
}",1,0,68,1.02,Insert
25,,,,,,,
26,"void MonCap::dump(Formatter *f) const
{
  f->dump_string(""text"", text);
}","void MonCap::dump(Formatter *f) const
{
  int a = 2;
  int b = 3;
  if (a != b) {
      H264Context *h;
      MpegEncContext * const s = &h->s;
      int contextslimit;
      if(contextslimit)
              execute_decode_slices(h, contextslimit);
      f->dump_string(""text"", text);
  }
}",0,1,9,0.31,Insert
27,,,,,,,
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *r_str_sep(const char *base, const char *sep) {
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	int a = 2;
	int b = 3;
	while (a != b) {
    	int i;
    	b = a;
	}
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}",0,1,15,0.66,Insert
33,,,,,,,
36,,,,,,,
37,"gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	context->state = GIF_GET_COLORMAP;
}","gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    	table->slot=(char *) NULL;
    	table->description=(char *) NULL;
    	table->levels=(unsigned int *) NULL;
    	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    	context->state = GIF_GET_COLORMAP;
	}
}",0,1,7,0.26,Insert
38,,,,,,,
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;
        if (link->flags & IFF_LOOPBACK)
                return 0;
        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;
        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));
        r = write_string_file(p, v, 0);
        if (r < 0) {
                if (verify_one_line_file(p, v) > 0)
                        return 0;
                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }
        return 0;
}","static int link_set_ipv4_forward(Link *link) {
        struct dir *dir;
        struct proc_mounts *p_10 = dir->private_data;
        if (mnt_had_events(p_10))
        		res |= POLLERR | POLLPRI;
        const char *p = NULL, *v;
        int r;
        if (link->flags & IFF_LOOPBACK)
                return 0;
        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;
        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));
        r = write_string_file(p, v, 0);
        if (r < 0) {
                if (verify_one_line_file(p, v) > 0)
                        return 0;
                char str[] = ""Constant"";
                while (strlen(str) > 5) {
                    log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
                strcpy(str, ""a"");
                }
        }
        return 0;
}",0,1,16,0.77,Insert
43,,,,,,,
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}
	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		cil_destroy_context(nodecon->context);
		strcpy(str, ""a"");
		}
	}
	struct sock *Lister;
	struct vsock_sock *vcatel;
	struct vsock_sock *Vconnection;
	vcatel = vsock_sk(Lister);
	list_add_tail(&Vconnection->accept_queue, &vcatel->accept_queue);
	free(nodecon);
}",0,1,11,0.47,Insert
45,,,,,,,
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}
	cil_list_destroy(&def->class_strs, CIL_TRUE);
	cil_list_destroy(&def->class_datums, CIL_FALSE);
	free(def);
}","void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}
	cil_list_destroy(&def->class_strs, CIL_TRUE);
	cil_list_destroy(&def->class_datums, CIL_FALSE);
	int a = 34;
	int b = a;
	if(a*b>0){
    	free(def);
    	APEContext *ctx;
    	int32_t predictionA, currentA, A, sign;
    	APEPredictor *pb = &ctx->predictor;
    	currentA = pb->lastA[0];
    	pb->lastA[0] = currentA;
	}
}",0,1,10,0.42,Insert
50,,,,,,,
53,,,,,,,
55,,,,,,,
56,,,,,,,
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);
    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    int a = 2;
    int b = 3;
    if (a != b) {
        register int i;
    }
    register int j;
    i = strlen(myword);
    j = strlen(suffix);
    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}",0,1,1,0.12,Replace
60,,,,,,,
61,,,,,,,
62,"static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    av_buffer_unref(&f->seg_map);
    ff_thread_release_buffer(s->avctx, &f->tf);
}","static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    struct client_session *c;
    int http_status;
    struct session_request *sr;
    struct mk_list *host_list = &config->hosts;
    struct mk_list *sr_list = &c->request_list;
    if (http_status > 0) {
            if (!sr->host_conf) {
                sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
            }
            mk_request_error(http_status, c, sr);
            mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                NULL, c, sr);
    }
    av_buffer_unref(&f->seg_map);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ff_thread_release_buffer(s->avctx, &f->tf);
    strcpy(str, ""a"");
    }
}",0,1,9,0.28,Insert
65,,,,,,,
68,"find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;
	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	spin_unlock(&compressor_list_lock);
	return cp;
}","find_compressor(int type)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct compressor_entry *ce;
    	b = a;
	}
	struct compressor *cp = NULL;
	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	AVPacket * pk;
	AVFormatContext *s;
	unsigned char rb[5];
	AVCodecParameters *par = s->streams[stream_index]->codecpar;
	AVIOContext *b_3     = s->b_3;
	const int stream_index =  pk->stream_index;
	avi_stream2fourcc(rb, stream_index, par->codec_type);
	avio_write(b_3, rb, 4);
	spin_unlock(&compressor_list_lock);
	return cp;
}",0,1,15,0.55,Insert
70,"struct anon_vma *page_get_anon_vma(struct page *page)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;
	rcu_read_lock();
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		goto out;
	if (!page_mapped(page))
		goto out;
	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}
	if (!page_mapped(page)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	rcu_read_unlock();
	return anon_vma;
}","struct anon_vma *page_get_anon_vma(struct page *page)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;
	rcu_read_lock();
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		goto out;
	if (!page_mapped(page))
		goto out;
	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}
	if (!page_mapped(page)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	rcu_read_unlock();
	int a = 2;
	int b = 3;
	while (a != b) {
    	return anon_vma;
    	b = a;
	}
}",0,1,24,0.61,Insert
71,,,,,,,
72,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;
	device_links_write_lock();
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;
		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);
	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;
	int a = 2;
	int b = 3;
	while (a < b) {
    	device_links_write_lock();
    	b = a;
    	MachineState *machine;
    	char *filename;
    	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    	long load_limit, fw_size;
    	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    	spapr->rtas_size = get_image_size(filename);
    	g_free(filename);
    	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	}
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;
		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);
	device_links_write_unlock();
}",0,1,25,0.78,Insert
77,"static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    directory_config *dcfg = _dcfg;
    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        else
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);
    return NULL;
}","static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        directory_config *dcfg = _dcfg;
        int size;
        const uint8_t *buf;
        const uint8_t *t, *p_ad;
        p_ad = buf + size;
    }
    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        else
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);
    return NULL;
}",0,1,6,0.41,Insert
78,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;
        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;
        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            uint64_t glms;
            unsigned k, b, err, C;
            unsigned k, b, err, C;
            assert(is_limm(glms));
            k = clz64(glms);
            b = ctz64(glms);
            WRITE32(bm1);
        }
        return 0;
}",0,1,16,0.36,Insert
80,,,,,,,
82,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;
  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);
  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);
  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  int a = 40;
  int b = a;
  if(a*b>0){
      GFileIface *iface;
  }
  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);
  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);
  iface = G_FILE_GET_IFACE (file);
  struct edgeport_serial *serial;
  u8 *data;
  struct device *dev = &serial->serial->dev->dev;
  struct device *dev = &serial->serial->dev->dev;
  int status;
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
  status = -ENODEV;
  return (* iface->poll_mountable_finish) (file, result, error);
}",0,1,10,0.74,Insert
84,"int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)
	{
	return PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());
	}","int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)
	{
	int a = 2;
	int b = 3;
	while (a != b) {
    	return PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());
    	b = a;
	}
	}",0,1,1,0.04,Replace
86,,,,,,,
87,,,,,,,
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;
    if ((ctxt == NULL) || (doc == NULL))
        return (-1);
    ctxt->doc = doc;
    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
    if (ret == -1)
        return (1);
    return (ret);
}","xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        int ret;
        b = a;
    }
    if ((ctxt == NULL) || (doc == NULL))
        return (-1);
    ctxt->doc = doc;
    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
    if (ret == -1)
        return (1);
        DisasContext *qs;
        uint32_t ksns;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        unsigned int coll, order, err, resp, coll, p, nzcv;
        order = extract32(ksns, 22, 2);
        handle_fp_compare(qs, order, coll, err, false, p);
    return (ret);
}",0,1,15,0.48,Insert
94,,,,,,,
95,,,,,,,
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }
    return err;
}","HandleRegisterDNSMessage(void)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        DWORD err;
    strcpy(str, ""a"");
    }
    HANDLE thread = NULL;
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }
    return err;
}",0,1,2,0.09,Replace
98,,,,,,,
100,,,,,,,
102,,,,,,,
104,"msg_scroll_up(void)
{
#ifdef FEAT_GUI
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();
    if (!can_clear((char_u *)"" ""))
    {
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}","msg_scroll_up(void)
{
#ifdef FEAT_GUI
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();
    if (!can_clear((char_u *)"" ""))
    {
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
	}
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}",0,1,1,0.11,Replace
105,"int pmd_huge(pmd_t pmd)
{
	return !pmd_none(pmd) &&
		(pmd_val(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;
}","int pmd_huge(pmd_t pmd)
{
	return !pmd_none(pmd) &&
	register ssize_t
	    i;
	QuantizationTable
	    *table;
	ssize_t
	    j;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	for (j=i; j < 64; j++)
	    table->levels[j]=table->levels[j-1];
		(pmd_val(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;
}",0,1,16,0.26,Insert
107,,,,,,,
108,,,,,,,
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;
  DEBUGASSERT(!data->conn);  
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);
  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      timediff_t elapsed;
  strcpy(str, ""a"");
  }
  DEBUGASSERT(!data->conn);  
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);
  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}",0,1,2,0.15,Replace
111,,,,,,,
114,"static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	zval *str = &EX_T(opline->result.u.var).tmp_var;
	if (IS_TMP_VAR == IS_UNUSED) {
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;
		INIT_PZVAL(str);
	}
	add_string_to_string(str, str, &opline->op2.u.constant);
	ZEND_VM_NEXT_OPCODE();
}","static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	zval *str = &EX_T(opline->result.u.var).tmp_var;
	if (IS_TMP_VAR == IS_UNUSED) {
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;
		INIT_PZVAL(str);
	}
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	status = -ENODEV;
	add_string_to_string(str, str, &opline->op2.u.constant);
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 < b_1) {
    	ZEND_VM_NEXT_OPCODE();
    	b_1 = a_1;
	}
}",0,1,24,0.52,Insert
117,"dataiterator_skip_attribute(Dataiterator *di)
{
  if (di->state == di_nextsolvableattr)
    di->state = di_nextsolvablekey;
  else
    di->state = di_nextkey;
}","dataiterator_skip_attribute(Dataiterator *di)
{
  if (di->state == di_nextsolvableattr)
    di->state = di_nextsolvablekey;
  else
  const char *nptr;
  char *ndpointer;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  int64_t retval;
  double vals, mul, integral, fraction;
  vals = strtod(nptr, &ndpointer);
  fraction = modf(vals, &integral);
  retval = vals * mul;
    di->state = di_nextkey;
}",0,1,5,0.22,Insert
118,"spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;
    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;
	slp->sl_slang = slang;
    }
}","spell_load_cb(char_u *fname, void *cookie)
{
    	int a = 2;
    	int b = 2;
    	if (a == b) {
        spelload_T	*slp = (spelload_T *)cookie;
    	}
    slang_T	*slang;
    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;
	    GF_BitStream *bs;
	    GF_Box *s;
	    FilePartitionBox *inter = (FilePartitionBox *)s;
	    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	    inter->packet_payload_size = gf_bs_read_u16(bs);
	    gf_bs_read_u8(bs);
	    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	    inter->FEC_instance_ID = gf_bs_read_u16(bs);
	slp->sl_slang = slang;
    }
}",0,1,9,0.53,Insert
121,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;
	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int port, i, status, r;
	RTSPHeader reply1, *reply = &reply1;
	if (reply->status_code != RTSP_STATUS_OK) {
	        r = AVERROR_INVALIDDATA;
	        goto fail;
	}
	int ret;
	int a = 2;
	int b = 2;
	if (a == b) {
    	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	}
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}",0,1,12,0.5,Insert
124,,,,,,,
125,,,,,,,
127,,,,,,,
129,,,,,,,
130,"static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)
{
    uint64_t j;
    uint32_t str_j = 0;
    uint32_t index1;
    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_ARRAY;
    data->length = size;
    plist_t node = node_create(NULL, data);
    for (j = 0; j < data->length; j++) {
        str_j = j * bplist->ref_size;
        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);
        if (index1 >= bplist->num_objects) {
            plist_free(node);
            return NULL;
        }
        plist_t val = parse_bin_node_at_index(bplist, index1);
        if (!val) {
            plist_free(node);
            return NULL;
        }
        node_attach(node, val);
    }
    return node;
}","static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)
{
    uint64_t j;
    uint32_t str_j = 0;
    uint32_t index1;
    plist_data_t data = plist_new_plist_data();
    data->type = PLIST_ARRAY;
    data->length = size;
    plist_t node = node_create(NULL, data);
    for (j = 0; j < data->length; j++) {
        str_j = j * bplist->ref_size;
        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);
        if (index1 >= bplist->num_objects) {
            plist_free(node);
            return NULL;
        }
        plist_t val = parse_bin_node_at_index(bplist, index1);
        if (!val) {
            plist_free(node);
            return NULL;
        }
        node_attach(node, val);
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return node;
        b += 1;
    }
}",1,0,5,0.2,Replace
132,"sraSpanCheck(const sraSpan *span, const char *text) {
  if (span->start == span->end) {
    printf(text); 
    printf("":%d-%d\n"", span->start, span->end);
  }
}","sraSpanCheck(const sraSpan *span, const char *text) {
  if (span->start == span->end) {
    int a = 2;
    int b = 3;
    if (a != b) {
        printf(text); 
    }
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    printf("":%d-%d\n"", span->start, span->end);
  }
}",0,1,6,0.34,Insert
134,"com_quit(String *buffer __attribute__((unused)),
	 char *line __attribute__((unused)))
{
  status.exit_status=0;
  return 1;
}","com_quit(String *buffer __attribute__((unused)),
	 char *line __attribute__((unused)))
{
  status.exit_status=0;
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      return 1;
  }
}",0,1,1,0.04,Replace
136,,,,,,,
137,,,,,,,
140,"static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)
{
	const struct auth_passdb *passdb;
	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {
		if (passdb->passdb->iface.lookup_credentials != NULL)
			return TRUE;
	}
	return FALSE;
}","static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)
{
	const struct auth_passdb *passdb;
	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {
		if (passdb->passdb->iface.lookup_credentials != NULL)
			return TRUE;
	}
	int a = 2;
	int b = 2;
	while (a == b) {
    	double f;
    	f = get_float64 (buffer, &error);
    	return FALSE;
    	b += 1;
    	ptrdiff_t src_stride;
    	ptrdiff_t buf_stride;
    	int h;
    	int src_y;
    	int block_h;
    	int w;
    	int block_w;
    	const uint8_t *src;
    	int src_x;
    	uint8_t *buf;
    	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
    	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
    	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	}
}",0,1,35,0.49,Insert
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));
    strcpy(str, ""a"");
    }
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",0,1,1,0.04,Replace
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;
	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}
	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}
	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char str_1[] = ""Constant"";
	if (strlen(str_1) > 0) {
    	char *str;
	}
	ldns_buffer *buf;
	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}
	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}
	ldns_buffer_free(buf);
	return str;
}",0,1,1,0.1,Replace
148,"void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}","void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        req_.upgrade_request = true;
    }
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}",1,0,2,0.18,Replace
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    *timeout = 500;              
    return trig->trigger;
}","crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    *timeout = 500;              
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return trig->trigger;
    }
}",0,1,7,0.28,Insert
151,"int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;
	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;
	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;
	default:
		return -EINVAL;
	}
	return 0;
}","int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;
	case 2:
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		*scancode = *((u16 *)ke->scancode);
		strcpy(str, ""a"");
		}
		break;
	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;
	default:
		return -EINVAL;
	}
	return 0;
}",0,1,15,0.22,Replace
154,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;
    g_return_if_fail (handle != NULL);
    if (base_uri == NULL)
	return;
    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);
    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    int a = 37;
    int b = a;
    if(a*b>0){
        gchar *uri;
    }
    g_return_if_fail (handle != NULL);
    if (base_uri == NULL)
	return;
    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);
    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}",0,1,12,0.64,Insert
157,,,,,,,
158,,,,,,,
159,"_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}","_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&bus_open);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return bus_default(bus_open, busp, ret);
            struct hid_driver *hderver;
            int ret_3;
            ret_3 = driver_register(&hderver->driver);
            ret_3 = driver_create_file(&hderver->driver, &driver_attr_new_id);
        strcpy(str, ""a"");
        }
}",0,1,10,0.34,Insert
163,"void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  SolarizeImage(image(),factor_,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::solarize(const double factor_)
{
  Image *image_3;
  MagickOffsetType
      offset;
  offset=TellBlob(image_3);
  modifyImage();
  GetPPException;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      SolarizeImage(image(),factor_,exceptionInfo);
  strcpy(str, ""a"");
  }
  ThrowImageException;
}",0,1,9,0.31,Insert
165,,,,,,,
169,"static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}
	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}","static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
		AVCodecContext *AVcas;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		VdpBool supported;
		VdpChromaType type;
		VdpStatus status;
		status = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
	}
	if (netifcon->packet_context_str == NULL) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		cil_reset_context(netifcon->packet_context);
		}
	}
}",0,1,8,0.29,Insert
170,"bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}
	if (fsp->fsp_flags.is_directory) {
		return false;
	}
	if (fsp->fake_file_handle == NULL) {
		return false;
	}
	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}
	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}
	return true;
}","bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}
	if (fsp->fsp_flags.is_directory) {
		return false;
	}
	if (fsp->fake_file_handle == NULL) {
		return false;
	}
	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}
	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderCreate *create;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		VdpStatus status;
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	return true;
	}
}",0,1,14,0.41,Insert
172,"static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}","static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	tfm->reqsize = reqsize;
    	AVCodecContext *AVcas;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	VdpBool supported;
    	VdpChromaType type;
    	VdpStatus status;
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	b = a;
	}
}",0,1,4,0.27,Insert
173,,,,,,,
175,"void __idr_remove_all(struct idr *idp)
{
	int n, id, max;
	int bt_mask;
	struct idr_layer *p;
	struct idr_layer *pa[MAX_IDR_LEVEL];
	struct idr_layer **paa = &pa[0];
	n = idp->layers * IDR_BITS;
	p = idp->top;
	rcu_assign_pointer(idp->top, NULL);
	max = 1 << n;
	id = 0;
	while (id < max) {
		while (n > IDR_BITS && p) {
			n -= IDR_BITS;
			*paa++ = p;
			p = p->ary[(id >> n) & IDR_MASK];
		}
		bt_mask = id;
		id += 1 << n;
		while (n < fls(id ^ bt_mask)) {
			if (p)
				free_layer(p);
			n += IDR_BITS;
			p = *--paa;
		}
	}
	idp->layers = 0;
}","void __idr_remove_all(struct idr *idp)
{
	int n, id, max;
	int bt_mask;
	struct idr_layer *p;
	struct idr_layer *pa[MAX_IDR_LEVEL];
	struct idr_layer **paa = &pa[0];
	n = idp->layers * IDR_BITS;
	int a = 2;
	ppc4xx_bd_info_t *bd;
	int i, n_1;
	ram_addr_t bdloc;
	for (i = 0; i < 6; i++)
	        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);
	int b = 3;
	while (a < b) {
    	p = idp->top;
    	b = a;
    	ppc4xx_bd_info_t *bd_3;
    	int i_6, n_3;
    	ram_addr_t bdloc_4;
    	for (i_6 = 0; i_6 < 6; i_6++)
    	        stb_phys_4(bdloc_4 + 0x24 + i_6, bd_3->bi_enetaddr[i_6]);
	}
	rcu_assign_pointer(idp->top, NULL);
	max = 1 << n;
	id = 0;
	while (id < max) {
		while (n > IDR_BITS && p) {
			n -= IDR_BITS;
			*paa++ = p;
			p = p->ary[(id >> n) & IDR_MASK];
		}
		bt_mask = id;
		id += 1 << n;
		while (n < fls(id ^ bt_mask)) {
			if (p)
				free_layer(p);
			n += IDR_BITS;
			p = *--paa;
		}
	}
	idp->layers = 0;
}",1,0,91,1.43,Insert
178,,,,,,,
180,"MONGO_COMPILER_NOINLINE void DocumentSourceUnionWith::logStartingSubPipeline(
    const std::vector<BSONObj>& serializedPipe) {
    LOGV2_DEBUG(23869,
                1,
                ""$unionWith attaching cursor to pipeline {pipeline}"",
                ""pipeline""_attr = serializedPipe);
}","MONGO_COMPILER_NOINLINE void DocumentSourceUnionWith::logStartingSubPipeline(
const char
    *attribute,
    *content;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
QuantizationTable
    *table;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
table->slot=(char *) NULL;
table->description=(char *) NULL;
table->levels=(unsigned int *) NULL;
attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    const std::vector<BSONObj>& serializedPipe) {
    LOGV2_DEBUG(23869,
                1,
                ""$unionWith attaching cursor to pipeline {pipeline}"",
                ""pipeline""_attr = serializedPipe);
}",0,1,6,0.22,Insert
183,,,,,,,
186,,,,,,,
189,"static int queue_get(struct priv_net *pn, void *buf, int len)
{
	struct queue *head = &pn->pn_queue;
	struct queue *q = head->q_next;
	if (q == head)
		return 0;
	assert(q->q_len <= len);
	memcpy(buf, q->q_buf, q->q_len);
	queue_del(q);
	queue_add(&pn->pn_queue_free, q);
	return q->q_len;
}","static int queue_get(struct priv_net *pn, void *buf, int len)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct queue *head = &pn->pn_queue;
	}
	struct queue *q = head->q_next;
	if (q == head)
		return 0;
	assert(q->q_len <= len);
	memcpy(buf, q->q_buf, q->q_len);
	queue_del(q);
	DeviceState *mem = NULL;
	SysBusDevice *busDev;
	qdev_prop_set_uint32(mem, ""num-cpu"", smp_cpus);
	qdev_prop_set_uint32(mem, ""num-irq"", NIRQ_GIC);
	qdev_init_nofail(mem);
	busDev = SYS_BUS_DEVICE(mem);
	mem = qdev_create(NULL, ""sp804"");
	queue_add(&pn->pn_queue_free, q);
	return q->q_len;
}",0,1,22,0.66,Insert
194,"cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,
    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])
{
  return onigenc_get_case_fold_codes_by_str_with_map(
	     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,
	     flag, p, end, items);
}","cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,
    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])
{
  VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
  DisasContext *qs;
  unsigned int coll, order, err, resp, coll, p_4, nzcv;
  unsigned int coll, order, err, resp, coll, p_4, nzcv;
  unsigned int coll, order, err, resp, coll, p_4, nzcv;
  unsigned int coll, order, err, resp, coll, p_4, nzcv;
  handle_fp_compare(qs, order, coll, err, false, p_4);
  uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
  internal_buf->chunk_header.port = VDP_SERVER_PORT;
  internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
  internal_buf->header.protocol = VD_AGENT_PROTOCOL;
  internal_buf->header.type = type;
  internal_buf->header.opaque = 0;
  return onigenc_get_case_fold_codes_by_str_with_map(
	     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,
	     flag, p, end, items);
}",0,1,32,0.46,Insert
195,"static int sja1105_cold_reset(const struct sja1105_private *priv)
{
	struct sja1105_reset_cmd reset = {0};
	reset.cold_rst = 1;
	return priv->info->reset_cmd(priv, &reset);
}","static int sja1105_cold_reset(const struct sja1105_private *priv)
{
	struct sja1105_reset_cmd reset = {0};
	reset.cold_rst = 1;
	int a = 2;
	int b = 3;
	if (a != b) {
    	unsigned char *sha1;
    	uint64_t glms;
    	unsigned k, b_8, err, C;
    	unsigned k, b_8, err, C;
    	assert(is_limm(glms));
    	k = clz64(glms);
    	b_8 = ctz64(glms);
    	void *data;
    	unsigned long size;
    	struct pbase_tree *it;
    	unsigned char tree_sha1[20];
    	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
    	it = xcalloc(1, sizeof(*it));
    	it->pcache.tree_size = size;
    	return priv->info->reset_cmd(priv, &reset);
	}
}",0,1,37,0.48,Insert
197,"bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  if (this == item)
    return 1;					 
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}","bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  if (this == item)
    return 1;					 
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  int a = 56;
  int b = a;
  if(a*b>0){
      Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  }
  return (name.length == other->name.length &&
  AVCodecContext * avnc;
  MP3On4DecodeContext *this = avnc->priv_data;
  MP3On4DecodeContext *this = avnc->priv_data;
  this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
  avnc->channels = mp3Channels[this->chan_cfg];
  avnc->priv_data = this->mp3decctx[0];
  decode_init(avnc);
  avnc->priv_data = this;
	  !memcmp(name.str, other->name.str, name.length));
}",0,1,7,0.5,Insert
198,"int sftp_dir_eof(sftp_dir dir) {
  return dir->eof;
}","int sftp_dir_eof(sftp_dir dir) {
  DisasContext *qs;
  uint32_t ksns;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  order = extract32(ksns, 22, 2);
  handle_fp_compare(qs, order, coll, err, false, p);
  int a = 2;
  int b = 2;
  if (a == b) {
      return dir->eof;
  }
}",0,1,4,0.22,Insert
204,,,,,,,
205,"void appendBSONObjToBSONArrayBuilder(BSONArrayBuilder* array, const BSONObj& obj) {
    array->append(obj);
}","void appendBSONObjToBSONArrayBuilder(BSONArrayBuilder* array, const BSONObj& obj) {
    int a = 2;
    int b = 2;
    while (a == b) {
        array->append(obj);
        uint64_t glms;
        unsigned k, b_10, err, C;
        unsigned k, b_10, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_10 = ctz64(glms);
        b += 1;
    }
}",0,1,4,0.28,Insert
207,,,,,,,
209,,,,,,,
212,"BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,
                                    int LeftOfs, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr previm)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	if (out == NULL) return;
	gdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
	out->gd_free(out);
}","BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,
                                    int LeftOfs, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr previm)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	if (out == NULL) return;
	gdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
	int a = 49;
	int b = a;
	if(a*b>0){
    	unsigned maxpages;
    	size_t *start;
    	struct iov_iter *i;
    	unsigned int iter_head, npages;
    	unsigned int iter_head, npages;
    	size_t capacity;
    	data_start(i, &iter_head, start);
    	capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    	out->gd_free(out);
	}
}",0,1,7,0.57,Insert
213,,,,,,,
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;
    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);
    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));
    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");
        buf_free(&buf);
    }
}","EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;
    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);
    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));
    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        int a = 2;
        int b = 2;
        while (a == b) {
            prot_puts(txn->conn->pout, ""\r\n"");
            b += 1;
        }
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args_2;
        int rules, nb_regs, ini;
        rules = args_2[nb_oargs + nb_iargs + 1];
        buf_free(&buf);
    }
}",0,1,23,0.85,Insert
216,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}","void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	const AVFrame *capt;
	const AVFrame *const p = capt;
	uint8_t *last = NULL;
	uint8_t *zero = NULL;
	zero = last = av_mallocz(p->linesize[0]);
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	int a = 76;
	int b = a;
	if(a*b>0){
    	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	}
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}",0,1,17,0.55,Insert
217,,,,,,,
218,"static void dense_rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}","static void dense_rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      V9fsPath *fs_path;
      FsContext *FS_path;
      int fd, ret;
      struct handle_data *parent = (struct handle_data *)FS_path->private;
      fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
      UNUSED_PARAMETER(apArg);
  }
}",0,1,12,0.35,Insert
219,,,,,,,
220,,,,,,,
221,,,,,,,
222,,,,,,,
223,"lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  return dataPathPtr;
}","lou_setDataPath (char *path)
{
  int a = 2;
  int b = 3;
  while (a != b) {
      dataPathPtr = NULL;
      b = a;
  }
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table;
  size_t
      length;
  content=GetXMLTreeContent(levels);
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  return dataPathPtr;
}",0,1,11,0.39,Insert
224,"evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}","evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		evdns_base_free(b, fail_requests);
		}
	}
	struct tty_struct *reader;
	struct awm *awm = reader->driver_data;
	struct acm_wb *sth;
	struct awm *awm = reader->driver_data;
	if (sth->len == awm->writesize) {
			acm_tty_flush_chars(reader);
			goto overflow;
	}
	evdns_log_fn = NULL;
}",0,1,19,0.35,Insert
227,,,,,,,
228,,,,,,,
229,"RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);
    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}","RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);
    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        struct PCIDevice *pci_dev;
        Error *local_ = NULL;
        AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
        if (assigned_device_pci_cap_init(pci_dev, &local_) < 0) {
                qerror_report_err(local_);
                error_free(local_);
                goto out;
        }
        return makeRoleNameIterator(lower, upper);
    strcpy(str, ""a"");
    }
}",0,1,13,0.43,Insert
235,"__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,
	struct vm_area_struct *prev, struct rb_node **rb_link,
	struct rb_node *rb_parent)
{
	__vma_link_list(mm, vma, prev, rb_parent);
	__vma_link_rb(mm, vma, rb_link, rb_parent);
}","__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,
	struct vm_area_struct *prev, struct rb_node **rb_link,
	struct rb_node *rb_parent)
{
	__vma_link_list(mm, vma, prev, rb_parent);
	int a = 20;
	int b = a;
	if(a*b>0){
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	QuantizationTable
    	    *table;
    	size_t
    	    length;
    	content=GetXMLTreeContent(levels);
    	table->levels=(unsigned int *) AcquireQuantumMemory(length,
    	    sizeof(*table->levels));
    	__vma_link_rb(mm, vma, rb_link, rb_parent);
	}
}",0,1,7,0.45,Insert
236,"  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
    }
    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }","  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      QuantizationTable
          *table;
      size_t
          length;
      length=(size_t) table->width*table->height;
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
    }
    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }",0,1,1,0.2,Insert
237,"int pci_piix3_xen_ide_unplug(DeviceState *dev)
{
    PCIIDEState *pci_ide;
    DriveInfo *di;
    int i;
    IDEDevice *idedev;
    pci_ide = PCI_IDE(dev);
    for (i = 0; i < 4; i++) {
        di = drive_get_by_index(IF_IDE, i);
        if (di != NULL && !di->media_cd) {
            BlockBackend *blk = blk_by_legacy_dinfo(di);
            DeviceState *ds = blk_get_attached_dev(blk);
            if (ds) {
                blk_detach_dev(blk, ds);
            }
            pci_ide->bus[di->bus].ifs[di->unit].blk = NULL;
            if (!(i % 2)) {
                idedev = pci_ide->bus[di->bus].master;
            } else {
                idedev = pci_ide->bus[di->bus].slave;
            }
            idedev->conf.blk = NULL;
            blk_unref(blk);
        }
    }
    qdev_reset_all(DEVICE(dev));
    return 0;
}","int pci_piix3_xen_ide_unplug(DeviceState *dev)
{
    PCIIDEState *pci_ide;
    DriveInfo *di;
    int i;
    IDEDevice *idedev;
    pci_ide = PCI_IDE(dev);
    for (i = 0; i < 4; i++) {
        di = drive_get_by_index(IF_IDE, i);
        if (di != NULL && !di->media_cd) {
            BlockBackend *blk = blk_by_legacy_dinfo(di);
            DeviceState *ds = blk_get_attached_dev(blk);
            if (ds) {
                blk_detach_dev(blk, ds);
            }
            pci_ide->bus[di->bus].ifs[di->unit].blk = NULL;
            if (!(i % 2)) {
                idedev = pci_ide->bus[di->bus].master;
            } else {
                idedev = pci_ide->bus[di->bus].slave;
                int (*compare)(const char *, const char *, size_t);
                const char *name1;
                const char *name2;
                int cmp;
                unsigned char c1, mc7;
                cmp = compare(name1, name2, len);
                c1 = name1[len];
            }
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                idedev->conf.blk = NULL;
            }
            blk_unref(blk);
        }
    }
    qdev_reset_all(DEVICE(dev));
    return 0;
}",0,1,47,0.93,Insert
238,"resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,
                                      const struct lys_node *first_node, int abs_path)
{
    int dep1, dep2;
    const struct lys_node *node;
    if (!op_node) {
        if (local_mod != lys_node_module(first_node)) {
            return 1;
        }
    } else if (lys_parent(op_node)) {
        if (abs_path) {
            return 1;
        } else {
            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));
            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));
            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {
                return 1;
            }
        }
    } else {
        if (op_node != first_node) {
            return 1;
        }
    }
    return 0;
}","resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,
                                      const struct lys_node *first_node, int abs_path)
{
    int dep1, dep2;
    const struct lys_node *node;
    if (!op_node) {
        if (local_mod != lys_node_module(first_node)) {
            return 1;
            struct edgeport_serial *serial;
            u8 *data;
            int status;
            struct device *dev = &serial->serial->dev->dev;
            if (status)
            		dev_dbg(dev, ""%s - read 2 status error = %d
            "", __func__, status);
            	else
            		dev_dbg(dev, ""%s - read 2 data = 0x%x
            "", __func__, *data);
        }
    } else if (lys_parent(op_node)) {
        if (abs_path) {
            return 1;
        } else {
            dep1 = 0, node = op_node; while (lys_parent(node)) {;node = lys_parent(node);
}
            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));
            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {
                return 1;
            }
        }
    } else {
        if (op_node != first_node) {
            return 1;
        }
    }
    return 0;
}",0,1,17,0.67,Insert
240,,,,,,,
242,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;
	if (!response)
		return NULL;
	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);
	if (!s)
		return NULL;
	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	if (!response)
		return NULL;
	int a = 2;
	int b = 3;
	if (a != b) {
    	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);
	}
	if (!s)
		return NULL;
	cliprdr_write_file_contents_response(s, response);
	return s;
}",0,1,9,0.44,Insert
249,"    static CImg<T> get_load_dcraw_external(const char *const filename) {
      return CImg<T>().load_dcraw_external(filename);
    }","    static CImg<T> get_load_dcraw_external(const char *const filename) {
      char str1[] = ""Constant"";
      char str2[] = ""Constant"";
      if (strcmp(str1, str2) == 0) {
          unsigned char *sha1;
          void *data;
          unsigned long size;
          struct pbase_tree *it;
          unsigned char tree_sha1[20];
          data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
          hashcpy(it->pcache.sha1, tree_sha1);
          return CImg<T>().load_dcraw_external(filename);
      }
    }",0,1,9,0.23,Insert
250,,,,,,,
251,,,,,,,
252,"xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    xmlDumpElementDecl(buf, elem);
}","xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        xmlDumpElementDecl(buf, elem);
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_9;
        uint8_t byte_list[1] = {1};
        buf_9 = aml_buffer(1, byte_list);
        byte_list[0] = 0;
        buf_9 = aml_buffer(1, byte_list);
    }
}",0,1,3,0.22,Insert
255,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);
    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
                          uint64_t glms;
                          unsigned k, b_4, err, C;
                          unsigned k, b_4, err, C;
                          assert(is_limm(glms));
                          k = clz64(glms);
                          b_4 = ctz64(glms);
    memory_region_clear_global_locking(&io_mem_notdirty);
    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          int a = 2;
                          int b = 3;
                          while (a != b) {
                              NULL, UINT64_MAX);
                              b = a;
                          }
}",0,1,11,0.47,Insert
257,,,,,,,
258,"hb_buffer_clear( HB_Buffer buffer )
{
  buffer->in_length = 0;
  buffer->out_length = 0;
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}","hb_buffer_clear( HB_Buffer buffer )
{
  buffer->in_length = 0;
  int a = 2;
  int b = 3;
  while (a < b) {
      buffer->out_length = 0;
      b = a;
  }
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}",1,0,1,0.07,Replace
259,"_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)
{
	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);
	COPY_STRING_FIELD(tablespacename);
	COPY_SCALAR_FIELD(missing_ok);
	return newnode;
}","_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)
{
	Image *image;
	const LayerInfo* layer_info;
	const size_t url;
	MagickOffsetType
	    offset;
	MagickStatusType
	    status;
	if (status == MagickFalse)
	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
	int a = 2;
	int b = 3;
	if (a != b) {
    	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);
	}
	COPY_STRING_FIELD(tablespacename);
	COPY_SCALAR_FIELD(missing_ok);
	return newnode;
}",0,1,13,0.29,Insert
261,,,,,,,
263,"static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator i(pattern);
    BSONElement e = i.next();
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}","static bool isIdIndex(const BSONObj& pattern) {
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    BSONObjIterator i(pattern);
    BSONElement e = i.next();
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}",0,1,11,0.28,Insert
264,"use_socks (struct sockaddr_storage *addr)
{
  int mode;
  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;   
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;
      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;    
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1;  
      return 0;  
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0;  
      return 1;
    }
  else
    return 0;
}","use_socks (struct sockaddr_storage *addr)
{
  int mode;
  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;   
  else if (addr->ss_family == AF_INET6)
    {
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      strcpy(str, ""a"");
      }
      const unsigned char *s;
      int i;
      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;    
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1;  
      return 0;  
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0;  
      return 1;
    }
  else
    return 0;
}",0,1,13,0.26,Replace
267,,,,,,,
268,"GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 len;
	u32	i=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 j;
		for (j=0; j<len; j+=2) {
			u32 v;
			char szV[5];
			while (string[j] && !isalnum(string[j]))
				j++;
			if (!string[j])
				break;
			sprintf(szV, ""%c%c"", string[j], string[j+1]);
			sscanf(szV, ""%x"", &v);
			value[i] = v;
			i++;
		}
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}","GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 len;
	u32	i=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 j;
		for (j=0; j<len; j+=2) {
			u32 v;
			char szV[5];
			while (string[j] && !isalnum(string[j]))
				j++;
			if (!string[j])
				break;
			sprintf(szV, ""%c%c"", string[j], string[j+1]);
			char str1[] = ""Constant"";
			char str2[] = ""Constant"";
			if (strcmp(str1, str2) == 0) {
    			sscanf(szV, ""%x"", &v);
			}
			value[i] = v;
			i++;
		}
		AVIOContext *pb;
		int version = duration < INT32_MAX ? 0 : 1;
		(version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92);
		AVIOContext *pb_4;
		int version_2 = duration_6 < INT32_MAX_4 ? 0 : 1;
		(version_2 == 1) ? avio_wb32_7(pb_4, 104) : avio_wb32_7(pb_4, 92);
		avio_w8_4(pb_4, version_2);
		avio_w8(pb, version);
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}",1,0,90,1.43,Insert
275,"static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    return 0;
}","static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    int a = 44;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_8     = s->b_8;
    if (size & 1)
            avio_w8(b_8, 0);
    int b = a;
    if(a*b>0){
        return 0;
    }
}",0,1,4,0.26,Insert
277,,,,,,,
279,"SPL_METHOD(SplDoublyLinkedList, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}","SPL_METHOD(SplDoublyLinkedList, prev)
{
	int a = 2;
	cJSON *b_7 = coll->child;
	cJSON *b_7 = coll->child;
	if ( b_7 == coll->child )
			coll->child = b_7->next;
	int b = 3;
	while (a != b) {
    	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
    	b = a;
	}
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}",1,0,7,0.48,Insert
280,"static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}","static inline char *tok_text_buf(struct Token *t)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        struct delegpt* mp;
        struct delegpt_addr* a_2, *o, *ak;
        a_2 = mp->usable_list;
        return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
        b = a;
    }
}",0,1,3,0.3,Insert
281,"    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {
      return resize(disp.width(),disp.height(),force_redraw);
    }","    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {
      int a = 2;
      char **names;
      char *p;
      char *ea_namelist = smallbuf;
      size_t num_names;
      for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
      		names[num_names++] = p;
      }
      int b = 3;
      while (a != b) {
          return resize(disp.width(),disp.height(),force_redraw);
          b = a;
      }
    }",0,1,8,0.34,Insert
282,"static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (length < 12)
    return(MagickFalse);
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (length < 12)
    return(MagickFalse);
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return(MagickFalse);
  strcpy(str, ""a"");
  }
}",0,1,1,0.08,Replace
283,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;
	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}","ia64_patch_vtop (unsigned long start, unsigned long end)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	s32 *offp = (s32 *) start;
	}
	u64 ip;
	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_III
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
			goto out;
	}
	ia64_srlz_i();
}",0,1,18,0.52,Insert
285,"ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    OutgoingDataQueue::putData(stamp, data, len);
}","ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        OutgoingDataQueue::putData(stamp, data, len);
    strcpy(str, ""a"");
    }
}",0,1,1,0.03,Replace
287,,,,,,,
289,,,,,,,
292,,,,,,,
294,"dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
}","dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        void *frame;
        union tpacket_uhdr hash;
        hash.raw = frame;
        flush_dcache_page(pgv_to_page(&hash.h1->tp_sec));
        dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
    strcpy(str, ""a"");
    }
}",0,1,4,0.26,Insert
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31;  
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31;  
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	int a = 89;
	int b = a;
	if(a*b>0){
    	AVCodecContext *AVcas;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	VdpBool supported;
    	VdpChromaType type;
    	VdpStatus status;
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
	}
done:
	*pprog = prog;
}",0,1,57,1.0,Insert
297,,,,,,,
300,"ignore_dot_names (name)
     char *name;
{
  return (name[0] != '.');
}","ignore_dot_names (name)
     char *name;
{
  struct sock *Lister;
  struct vsock_sock *vcatel;
  struct vsock_sock *Vconnection;
  vcatel = vsock_sk(Lister);
  list_add_tail(&Vconnection->accept_queue, &vcatel->accept_queue);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      return (name[0] != '.');
  }
}",0,1,5,0.21,Insert
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);
    if (std::next(itr) == container->end()) {
        return container->end();
    }
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        invariant(*itr == this);
    }
    if (std::next(itr) == container->end()) {
        return container->end();
    }
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}",0,1,1,0.09,Replace
302,"TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";
  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}","TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  aml_append(coll,
          aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
  aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                  aml_name(""CTRL"")));
  ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";
  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}",0,1,2,0.35,Insert
306,,,,,,,
307,"static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);
	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);   
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}","static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	int a = 14;
	int b = a;
	if(a*b>0){
    	struct thread_info *thread = task_thread_info(tsk);
	}
	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	table->description=(char *) NULL;
	content=GetXMLTreeContent(description);   
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}",0,1,6,0.43,Insert
308,"void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block)
{
	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
	trace_api_sta_block_awake(sta->local, pubsta, block);
	if (block)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(hw, &sta->drv_unblock_wk);
}","void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block)
{
	int a = 2;
	int *got_frame;
	void *data;
	AVPacket *avpkt;
	AVCodecContext *avctx;
	const uint8_t *buf = avpkt->data;
	int buf_index      = 0;
	AVFrame *pict      = data;
	int buf_size       = avpkt->size;
	H264Context *hy     = avctx->priv_data;
	buf_index = decode_nal_units(hy, buf, buf_size);
	assert(pict->buf[0] || !*got_frame);
	int b = 3;
	while (a < b) {
    	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
    	b = a;
	}
	trace_api_sta_block_awake(sta->local, pubsta, block);
	if (block)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(hw, &sta->drv_unblock_wk);
}",0,1,20,0.57,Insert
309,,,,,,,
310,,,,,,,
315,,,,,,,
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;
	assert(string);
	assert(substring);
	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;
	assert(string);
	assert(substring);
	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				char str[] = ""Constant"";
				while (strlen(str) > 5) {
    				break;
				strcpy(str, ""a"");
				}
			}
		}
	}
	return result;
}",0,1,4,0.18,Replace
318,"rsvg_new_clip_path (void)
{
    RsvgClipPath *clip_path;
    clip_path = g_new (RsvgClipPath, 1);
    _rsvg_node_init (&clip_path->super);
    clip_path->units = userSpaceOnUse;
    clip_path->super.set_atts = rsvg_clip_path_set_atts;
    clip_path->super.free = _rsvg_node_free;
    return &clip_path->super;
}","rsvg_new_clip_path (void)
{
    RsvgClipPath *clip_path;
    int a = 2;
    int b = 3;
    if (a != b) {
        clip_path = g_new (RsvgClipPath, 1);
    }
    _rsvg_node_init (&clip_path->super);
    clip_path->units = userSpaceOnUse;
    clip_path->super.set_atts = rsvg_clip_path_set_atts;
    clip_path->super.free = _rsvg_node_free;
    return &clip_path->super;
}",1,0,2,0.08,Replace
321,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}","int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    const struct dom_sid *alias;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct ldb_dn *anon;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct dom_sid_buf buf;
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    NT_STATUS_HAVE_NO_MEMORY(mem_context);
    anon = ldb_dn_new_fmt(
    		mem_context,
    		area->ldb,
    		""<SID=%s>"",
    		dom_sid_str_buf(alias, &buf));
    talloc_free(mem_context);
    else return -1;
}",0,1,3,0.27,Insert
323,,,,,,,
325,,,,,,,
326,,,,,,,
328,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;
	if (event != NETDEV_DOWN)
		goto out;
	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}
out:
	return NOTIFY_DONE;
}","static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;
	if (event != NETDEV_DOWN)
		goto out;
	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		int a = 2;
		int b = 3;
		while (a < b) {
    		struct client_session *c;
    		int http_status;
    		struct session_request *sr;
    		struct mk_list *host_list = &config->hosts;
    		struct mk_list *sr_list = &c->request_list;
    		if (http_status > 0) {
    		        if (!sr->host_conf) {
    		            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
    		        }
    		        mk_request_error(http_status, c, sr);
    		        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
    		                            NULL, c, sr);
    		}
    		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
    		b = a;
		}
	}
out:
	return NOTIFY_DONE;
}",0,1,25,0.83,Insert
329,"static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }
    return NULL;
}","static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
    int fd;
    if (lseek(fd, 512, SEEK_SET) < 0) {
            goto fail;
    }
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                return &jp2_img_header[i];
            }
        }
    }
    return NULL;
}",0,1,15,0.44,Insert
330,"static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;
	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);
	return NOTIFY_OK;
}","static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct ldb_context *ydm;
	const char *attr;
	const struct ldb_schema_attribute *a_4;
	a_4 = ldb_schema_attribute_by_name(ydm, attr);
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct blk_mq_hw_ctx *hctx = data;
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    	table->slot=(char *) NULL;
    	table->description=(char *) NULL;
    	table->levels=(unsigned int *) NULL;
    	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    	b = a;
	}
	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);
	return NOTIFY_OK;
}",0,1,36,0.63,Insert
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	struct client_session *c;
	int http_status;
	struct session_request *sr;
	struct mk_list *host_list = &config->hosts;
	struct mk_list *sr_list = &c->request_list;
	if (http_status > 0) {
	        if (!sr->host_conf) {
	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
	        }
	        mk_request_error(http_status, c, sr);
	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
	                            NULL, c, sr);
	}
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return 0;
    	b = a;
	}
}",0,1,11,0.41,Insert
334,,,,,,,
335,,,,,,,
338,,,,,,,
340,"static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;
  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}","static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
  const char
      *attribute,
      *content;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  description=GetXMLTreeChild(table_iterator,""description"");
  table->description=(char *) NULL;
  content=GetXMLTreeContent(description);
    *stroke_color;
  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  int a = 2;
  int b = 3;
  while (a != b) {
      DrawSetStrokeColor(WmfDrawingWand,stroke_color);
      b = a;
  }
  files_struct *lsp;
  const struct dom_sid *group_sid = NULL;
  TALLOC_CTX *frame = talloc_stackframe();
  struct security_descriptor *psd = NULL;
  const struct dom_sid *owner_sid = NULL;
  struct security_descriptor *parent_desc = NULL;
  struct security_token *token = lsp->conn->session_info->security_token;
  status = se_create_child_secdesc(frame,
  			&psd,
  			&size,
  			parent_desc,
  			owner_sid,
  			group_sid,
  			lsp->is_directory);
  stroke_color=DestroyPixelWand(stroke_color);
}",0,1,46,0.6,Insert
341,"int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }
    return ctx->backend->set_slave(ctx, slave);
}","int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
        AVCodecContext * avnc;
        MP3On4DecodeContext *this = avnc->priv_data;
        MP3On4DecodeContext *this = avnc->priv_data;
        this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
        avnc->channels = mp3Channels[this->chan_cfg];
        avnc->priv_data = this->mp3decctx[0];
        decode_init(avnc);
        avnc->priv_data = this;
    }
    int a = 54;
    int b = a;
    if(a*b>0){
        return ctx->backend->set_slave(ctx, slave);
    }
}",0,1,7,0.28,Insert
342,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	int a = 2;
	int b = 3;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	while (a != b) {
    	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;
    	b = a;
	}
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}",0,1,18,0.46,Insert
343,,,,,,,
344,"tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}","tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  char *filename;
  long load_limit, fw_size;
  if (fw_size <= 0) {
          error_report(""Could not load LPAR firmware '%s'"", filename);
          exit(1);
  }
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}",0,1,12,0.26,Insert
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	struct tty_struct *reader;
	struct awm *awm = reader->driver_data;
	struct acm_wb *sth;
	struct awm *awm = reader->driver_data;
	if (sth->len == awm->writesize) {
			acm_tty_flush_chars(reader);
			goto overflow;
	}
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};
	uint64_t glms;
	unsigned k, b_2, err_3, C;
	unsigned k, b_2, err_3, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_2 = ctz64(glms);
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	int a = 2;
	int b = 3;
	while (a < b) {
    	*mrt = res.mrt;
    	b = a;
	}
	return 0;
}",0,1,39,0.68,Insert
351,,,,,,,
352,"int warn(const char *fmt, ...) {
    static char buf[1024];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    return(message(LOG_WARNING, buf));
}","int warn(const char *fmt, ...) {
    Rocker *r;
    DescInfo *info;
    char *buf_3 = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf_3 = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf_3, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    static char buf[1024];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return(message(LOG_WARNING, buf));
    }
}",0,1,13,0.38,Insert
353,"static int send_solid_rect(VncState *vs)
{
    size_t bytes;
    vnc_write_u8(vs, VNC_TIGHT_FILL << 4);  
    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = vs->clientds.pf.bytes_per_pixel;
    }
    vnc_write(vs, vs->tight.tight.buffer, bytes);
    return 1;
}","static int send_solid_rect(VncState *vs)
{
    size_t bytes;
    vnc_write_u8(vs, VNC_TIGHT_FILL << 4);  
    if (vs->tight.pixel24) {
        int a = 2;
        int b = 3;
        if (a != b) {
            tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        }
        bytes = 3;
    } else {
        bytes = vs->clientds.pf.bytes_per_pixel;
    }
    vnc_write(vs, vs->tight.tight.buffer, bytes);
    return 1;
}",1,0,4,0.11,Replace
354,"void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);
}","void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	ptrdiff_t src_stride;
    	ptrdiff_t buf_stride;
    	int h;
    	int src_y;
    	int block_h;
    	int w;
    	int block_w;
    	const uint8_t *src;
    	int src_x;
    	uint8_t *buf;
    	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
    	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
    	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);
	}
}",0,1,3,0.3,Insert
357,"PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr im;
	int * stylearr;
	int index;
	HashPosition pos;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		return;
	}
	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);
	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);
	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
		zval ** item;
		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
			break;
		}
		convert_to_long_ex(item);
		stylearr[index++] = Z_LVAL_PP(item);
	}
	gdImageSetStyle(im, stylearr, index);
	efree(stylearr);
	RETURN_TRUE;
}","PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr im;
	int * stylearr;
	int index;
	HashPosition pos;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		int a = 2;
		int b = 3;
		struct perf_event *pb_9;
		struct perf_event_attr attr_7;
		attr_7 = pb_9->attr_7;
		attr_7.disabled = true;
		modify_user_hw_breakpoint_7(pb_9, &attr_7);
		while (a < b) {
    		return;
    		struct perf_event *pb;
    		struct perf_event_attr attr;
    		attr = pb->attr;
    		attr.disabled = true;
    		modify_user_hw_breakpoint(pb, &attr);
    		b = a;
		}
	}
	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);
	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);
	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
		zval ** item;
		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
			break;
		}
		convert_to_long_ex(item);
		stylearr[index++] = Z_LVAL_PP(item);
	}
	gdImageSetStyle(im, stylearr, index);
	efree(stylearr);
	RETURN_TRUE;
}",1,0,155,1.86,Insert
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;
	cachep->num = 0;
	if (flags & SLAB_NOLEAKTRACE)
		return false;
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;
	cachep->colour = left / cachep->colour_off;
	return true;
}","static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	size_t left;
	cachep->num = 0;
	if (flags & SLAB_NOLEAKTRACE)
		return false;
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;
	cachep->colour = left / cachep->colour_off;
	int a = 2;
	int b = 2;
	while (a == b) {
    	return true;
    	b += 1;
	}
}",0,1,11,0.49,Insert
364,"static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }
  if (bucket.name.empty()) {
    return 0;
  }
  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }
  return ret;
}","static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }
  if (bucket.name.empty()) {
    return 0;
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_4 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_4->linade, linade, datalen);
  }
  int a = 48;
  int b = a;
  if(a*b>0){
      int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  }
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }
  return ret;
}",0,1,13,0.68,Insert
367,"static ssize_t runtime_active_kids_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return sprintf(buf, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}","static ssize_t runtime_active_kids_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	const char *filt_name;
	const char *filt_name_8;
	const char *args_9;
	AVFilterGraph *ctx_9;
	char tmp_args_5[256];
	if (!strcmp_2(filt_name_8, ""scale"") && !strstr_9(args_9, ""flags"")) {
	        snprintf_6(tmp_args_5, sizeof(tmp_args_5), ""%s:%s"",
	                 args_9, ctx_9->scale_sws_opts);
	        args_9 = tmp_args_5;
	}
	const char *args;
	AVFilterGraph *ctx;
	char tmp_args[256];
	if (!strcmp(filt_name, ""scale"") && !strstr(args, ""flags"")) {
	        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",
	                 args, ctx->scale_sws_opts);
	        args = tmp_args;
	}
	return sprintf(buf, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}",1,0,36,0.44,Insert
368,,,,,,,
370,,,,,,,
371,"CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;
  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;
  return wait_server_banner();
}","CtPtr ProtocolV1::handle_client_banner_write(int r) {
  uint64_t glms;
  unsigned k, b_5, err, C;
  unsigned k, b_5, err, C;
  assert(is_limm(glms));
  k = clz64(glms);
  b_5 = ctz64(glms);
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;
  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;
  int a = 2;
  int b = 2;
  if (a == b) {
      return wait_server_banner();
  }
}",0,1,11,0.47,Insert
373,,,,,,,
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
	domain = find_domain(dev);
	if (!domain)
		return 0;
	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);
	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	struct device *dev = data;
	}
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
	domain = find_domain(dev);
	if (!domain)
		return 0;
	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);
		int data_6, buf;
		if (data_6 < 0) {
		        error_report(""failed to read new inode info. %s"", strerror(errno));
		        goto cleanup;
		}
	return 0;
}",0,1,14,0.6,Insert
381,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			struct req_batch *rb;
			struct io_ring_ctx *ctx;
			if (rb->to_free)
					__io_req_free_batch_flush(ctx, rb);
			char str1[] = ""Constant"";
			char str2[] = ""Constant"";
			if (strcmp(str1, str2) == 0) {
    			return segments;
			}
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}",1,0,35,1.07,Insert
382,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;
	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;
	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;
	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;
	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	attr->mq_msgsize = v.mq_msgsize;
	strcpy(str, ""a"");
	}
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}",0,1,5,0.12,Replace
383,"glue(glue(cirrus_bitblt_rop_bkwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,
							 uint8_t *dst,const uint8_t *src,
							 int dstpitch,int srcpitch,
							 int bltwidth,int bltheight)
{
    int x,y;
    uint8_t p1, p2;
    dstpitch += bltwidth;
    srcpitch += bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x+=2) {
	    p1 = *(dst-1);
	    p2 = *dst;
            ROP_OP(&p1, *(src - 1));
            ROP_OP(&p2, *src);
	    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {
		*(dst-1) = p1;
		*dst = p2;
	    }
            dst-=2;
            src-=2;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}","glue(glue(cirrus_bitblt_rop_bkwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,
							 uint8_t *dst,const uint8_t *src,
							 int dstpitch,int srcpitch,
							 int bltwidth,int bltheight)
{
    int x,y;
    uint8_t p1, p2;
    dstpitch += bltwidth;
    srcpitch += bltwidth;
    for (y = 0; y < bltheight; y++) {
        struct sta_info *sta_2;
        struct timespec uptime_10;
        do_posix_clock_monotonic_gettime_6(&uptime_10);
        sta_2->last_connected = uptime_10.tv_sec;
        for (x = 0; x < bltwidth; x+=2) {
	    p1 = *(dst-1);
	    p2 = *dst;
            ROP_OP(&p1, *(src - 1));
            ROP_OP(&p2, *src);
	    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {
		*(dst-1) = p1;
		*dst = p2;
	    }
            dst-=2;
            src-=2;
        }
        const int index[4];
        double vec[4];
        double vec_freq[13];
        double mat_freq[13];
        for (int i = 0; i < 4; ++i)
                vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];
        dst += dstpitch;
        src += srcpitch;
        struct sta_info *sta;
        struct timespec uptime;
        do_posix_clock_monotonic_gettime(&uptime);
        sta->last_connected = uptime.tv_sec;
    }
}",1,0,297,2.56,Insert
384,,,,,,,
385,"void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}","void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	void *pack;
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	int a = 2;
	int b = 3;
	while (a < b) {
    	MSG_WriteBits( msg, newV ^ key, bits );
    	b = a;
	}
}",0,1,10,0.47,Insert
388,,,,,,,
390,"void ip4_datagram_release_cb(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}","void ip4_datagram_release_cb(struct sock *sk)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	const struct inet_sock *inet = inet_sk(sk);
    	b = a;
	}
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}",1,0,7,0.18,Replace
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	iter->index = 0;
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;
	if (!iter->pg)
		return NULL;
	return iter;
}","struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	int a = 2;
	int b = 3;
	while (a < b) {
    	iter->index = 0;
    	b = a;
	}
	unsigned char *sha1;
	void *data;
	unsigned long size;
	struct pbase_tree *it;
	unsigned char tree_sha1[20];
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	it = xcalloc(1, sizeof(*it));
	it->pcache.tree_size = size;
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;
	if (!iter->pg)
		return NULL;
	return iter;
}",0,1,15,0.5,Insert
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);
	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;
#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;
		rcu_read_lock();
		cpu = get_rps_cpu(skb->dev, skb, &rflow);
		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}
		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);
	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;
#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;
		rcu_read_lock();
		cpu = get_rps_cpu(skb->dev, skb, &rflow);
		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}
		int a = 2;
		int b = 3;
		while (a < b) {
    		return ret;
    		b = a;
		}
	}
#else
	return __netif_receive_skb(skb);
	AVCodecContext *AVcas;
	VdpStatus status;
	uint32_t input;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	if (status == VDP_STATUS_OK) {
	        hdtx->width  = AVcas->coded_width;
	        hdtx->input = AVcas->coded_height;
	}
#endif
}",0,1,25,0.78,Insert
395,"static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}","static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      free(u->user);
  }
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}",0,1,4,0.12,Replace
398,"TfLiteRegistration* Register_UNIQUE() {
  static TfLiteRegistration r = {unique::Init, unique::Free, unique::Prepare,
                                 unique::Eval};
  return &r;
}","TfLiteRegistration* Register_UNIQUE() {
  static TfLiteRegistration r = {unique::Init, unique::Free, unique::Prepare,
                                 unique::Eval};
  int a = 2;
  int b = 3;
  while (a != b) {
      return &r;
      Rocker *r_6;
      DescInfo *info;
      char *buf = desc_get_buf(info, true);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      char *buf = desc_get_buf(info, true);
      PCIDevice *dev = PCI_DEVICE(r_6);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      uint32_t pport;
      rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
      pport = rocker_get_pport_by_tx_ring(r_6, desc_get_ring(info));
      b = a;
  }
}",0,1,5,0.36,Insert
399,,,,,,,
401,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}","void lpFree(unsigned char *lp) {
    int a = 79;
    int b = a;
    if(a*b>0){
        struct sk_buff *skb;
        struct sock *sk;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
        "",
        		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
        length = TCP_SKB_CB(skb)->length;
        lp_free(lp);
    }
}",0,1,4,0.23,Insert
403,"static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	return true;
}","static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	char str1[] = ""Constant"";
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return true;
	}
}",0,1,8,0.22,Insert
406,,,,,,,
407,,,,,,,
408,"static void schedule_bh(void (*handler)(void))
{
	WARN_ON(work_pending(&floppy_work));
	floppy_work_fn = handler;
	queue_work(floppy_wq, &floppy_work);
}","static void schedule_bh(void (*handler)(void))
{
	int64_t unit;
	unsigned char c;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	int a = 2;
	int b = 2;
	while (a == b) {
    	WARN_ON(work_pending(&floppy_work));
    	b += 1;
	}
	floppy_work_fn = handler;
	VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
	uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
	internal_buf->chunk_header.port = VDP_SERVER_PORT;
	internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
	internal_buf->header.protocol = VD_AGENT_PROTOCOL;
	internal_buf->header.type = type;
	internal_buf->header.opaque = 0;
	queue_work(floppy_wq, &floppy_work);
}",0,1,37,0.5,Insert
409,"void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {
  if (!connection_.enableTrailers()) {
    return endEncode();
  }
  if (chunk_encoding_) {
    connection_.buffer().add(LAST_CHUNK);
    trailers.iterate(
        [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {
          static_cast<StreamEncoderImpl*>(context)->encodeFormattedHeader(
              header.key().getStringView(), header.value().getStringView());
          return HeaderMap::Iterate::Continue;
        },
        this);
    connection_.flushOutput();
    connection_.buffer().add(CRLF);
  }
  connection_.flushOutput();
  connection_.onEncodeComplete();
}","void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {
  if (!connection_.enableTrailers()) {
    return endEncode();
  }
  if (chunk_encoding_) {
    connection_.buffer().add(LAST_CHUNK);
    trailers.iterate(
        [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {
          static_cast<StreamEncoderImpl*>(context)->encodeFormattedHeader(
              header.key().getStringView(), header.value().getStringView());
          return HeaderMap::Iterate::Continue;
        },
        this);
    connection_.flushOutput();
    connection_.buffer().add(CRLF);
  }
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  connection_.flushOutput();
  connection_.onEncodeComplete();
}",0,1,18,0.51,Insert
411,"evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	size_t to_alloc;
	size += EVBUFFER_CHAIN_SIZE;
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	chain->refcnt = 1;
	return (chain);
}","evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	int a = 2;
	int b = 2;
	while (a == b) {
    	size_t to_alloc;
    	double r2_8;
    	int n_10 = 6;
    	double vec_freq_8[13];
    	calc_gauss_2(vec_freq_8, n_10, r2_8);
    	b += 1;
	}
	cJSON *b_2 = coll->child;
	GstDateTime *dt, *dt2;
	fail_unless (gst_date_time_get_hour (dt) == 15);
	fail_unless (gst_date_time_get_minute (dt) == 50);
	fail_unless (gst_date_time_get_second (dt) == 33);
	double r2;
	int n = 6;
	double vec_freq[13];
	calc_gauss(vec_freq, n, r2);
	gst_date_time_unref (dt);
	dt = gst_date_time_new_from_iso8601_string (""15:50:33Z"");
	if ( b_2->next ) b_2->next->prev = b_2->prev;
	size += EVBUFFER_CHAIN_SIZE;
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	chain->refcnt = 1;
	return (chain);
}",1,0,131,1.18,Insert
416,"int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}","int sysctl_is_seen(struct ctl_table_header *p)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct ctl_table_set *set = p->set;
    	b += 1;
	}
	int res;
	uint64_t glms;
	unsigned k, b_2, err, C;
	unsigned k, b_2, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_2 = ctz64(glms);
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}",0,1,11,0.46,Insert
418,,,,,,,
420,,,,,,,
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				char str[] = ""Constant"";
				if (strlen(str) > 0) {
    				       int browser;
    				       dictt.SetInteger(""windex"", browserpath);
    				       NULL);
				}
}",0,1,7,0.47,Insert
422,"TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;
    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));
    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}","TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    int a = 2;
    int b = 3;
    while (a < b) {
        params.options = QueryPlannerParams::NO_TABLE_SCAN;
        b = a;
    }
    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));
    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        ""b: [[2, 2, true, true]]}}}}}"");
}",0,1,14,0.38,Insert
424,,,,,,,
425,,,,,,,
427,"void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;
  mutt_account_tourl (&mx->account, &url);
  url.path = path;
  url_ciss_tobuffer (&url, dest, 0);
}","void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;
  mutt_account_tourl (&mx->account, &url);
  url.path = path;
  int a = 2;
  int b = 3;
  while (a != b) {
      url_ciss_tobuffer (&url, dest, 0);
      Rocker *r;
      DescInfo *info;
      char *buf = desc_get_buf(info, true);
      PCIDevice *dev = PCI_DEVICE(r);
      uint32_t pport;
      pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
      b = a;
  }
}",0,1,11,0.43,Insert
428,,,,,,,
430,"EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
{
    return &vq->guest_notifier;
}","EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        return &vq->guest_notifier;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        gf_bs_read_u8(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        b = a;
    }
}",0,1,7,0.26,Insert
432,"bool Item_equal::count_sargable_conds(void *arg)
{
  SELECT_LEX *sel= (SELECT_LEX *) arg;
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}","bool Item_equal::count_sargable_conds(void *arg)
{
  unsigned maxpages;
  size_t *start;
  struct iov_iter *i;
  unsigned int iter_head, npages;
  unsigned int iter_head, npages;
  size_t capacity;
  data_start(i, &iter_head, start);
  capacity = min(npages, maxpages) * PAGE_SIZE - *start;
  int a = 2;
  int b = 3;
  if (a != b) {
      SELECT_LEX *sel= (SELECT_LEX *) arg;
  }
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}",0,1,24,0.42,Insert
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	char str_1[] = ""Constant"";
	if (strlen(str_1) > 0) {
    	a = ldb_schema_attribute_by_name(ldb, attr);
    	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    	aml_append(coll,
    	        aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
    	aml_append(ifconfig,
    	        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    	aml_append(ifconfig,
    	        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    	aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
    	                                aml_name(""CTRL"")));
    	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	}
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",0,1,15,0.44,Insert
437,,,,,,,
438,"static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)
{
	return __htab_lru_map_lookup_elem(map, key, false);
}","static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    	table->slot=(char *) NULL;
    	table->description=(char *) NULL;
    	table->levels=(unsigned int *) NULL;
    	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    	return __htab_lru_map_lookup_elem(map, key, false);
	}
}",0,1,5,0.24,Insert
439,"static void ext3_handle_error(struct super_block *sb)
{
	struct ext3_super_block *es = EXT3_SB(sb)->s_es;
	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);
	if (sb->s_flags & MS_RDONLY)
		return;
	if (!test_opt (sb, ERRORS_CONT)) {
		journal_t *journal = EXT3_SB(sb)->s_journal;
		set_opt(EXT3_SB(sb)->s_mount_opt, ABORT);
		if (journal)
			journal_abort(journal, -EIO);
	}
	if (test_opt (sb, ERRORS_RO)) {
		ext3_msg(sb, KERN_CRIT,
			""error: remounting filesystem read-only"");
		sb->s_flags |= MS_RDONLY;
	}
	ext3_commit_super(sb, es, 1);
	if (test_opt(sb, ERRORS_PANIC))
		panic(""EXT3-fs (%s): panic forced after error\n"",
			sb->s_id);
}","static void ext3_handle_error(struct super_block *sb)
{
	int a = 71;
	int b = a;
	if(a*b>0){
    	struct ext3_super_block *es = EXT3_SB(sb)->s_es;
	}
	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);
	if (sb->s_flags & MS_RDONLY)
		return;
	if (!test_opt (sb, ERRORS_CONT)) {
		journal_t *journal = EXT3_SB(sb)->s_journal;
		set_opt(EXT3_SB(sb)->s_mount_opt, ABORT);
		if (journal)
			journal_abort(journal, -EIO);
	}
	if (test_opt (sb, ERRORS_RO)) {
		ext3_msg(sb, KERN_CRIT,
			""error: remounting filesystem read-only"");
		sb->s_flags |= MS_RDONLY;
	}
	ext3_commit_super(sb, es, 1);
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	if (test_opt(sb, ERRORS_PANIC))
		panic(""EXT3-fs (%s): panic forced after error\n"",
			sb->s_id);
}",0,1,16,0.84,Insert
443,"static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;
	get_task_struct(p);
	plist_del(&q->list, &q->list.plist);
	smp_wmb();
	q->lock_ptr = NULL;
	wake_up_state(p, TASK_NORMAL);
	put_task_struct(p);
}","static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;
	get_task_struct(p);
	plist_del(&q->list, &q->list.plist);
	smp_wmb();
	q->lock_ptr = NULL;
	wake_up_state(p, TASK_NORMAL);
	int a = 2;
	int b = 2;
	if (a == b) {
    	put_task_struct(p);
    	char **names;
    	char *p_6;
    	char *ea_namelist = smallbuf;
    	size_t num_names;
    	for (p_6 = ea_namelist; p_6 - ea_namelist < sizeret; p_6 += strlen(p_6)+1) {
    			names[num_names++] = p_6;
    	}
	}
}",0,1,15,0.45,Insert
445,"static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->nested.nested_run_pending)
		return -EBUSY;
	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))
		return -EBUSY;
	return !svm_smi_blocked(vcpu);
}","static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->nested.nested_run_pending)
		return -EBUSY;
	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))
		return -EBUSY;
	int a = 2;
	int b = 3;
	while (a != b) {
    	return !svm_smi_blocked(vcpu);
    	struct edgeport_serial *serial;
    	u8 *data;
    	struct device *dev = &serial->serial->dev->dev;
    	struct device *dev = &serial->serial->dev->dev;
    	int status;
    	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
    			dev_dbg(dev, ""%s - ROM_TYPE_II
    	"", __func__);
    			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
    			goto out;
    	}
    	b = a;
	}
}",0,1,21,0.5,Insert
446,,,,,,,
453,"static CURLcode file_setup_connection(struct connectdata *conn)
{
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;
  return CURLE_OK;
}","static CURLcode file_setup_connection(struct connectdata *conn)
{
  AVPacket * pk;
  AVFormatContext *s;
  int size               =  pk->size;
  AVIOContext *b_1     = s->b_1;
  if (size & 1)
          avio_w8(b_1, 0);
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;
  int a = 2;
  int b = 3;
  if (a != b) {
      return CURLE_OK;
  }
}",0,1,5,0.29,Insert
456,,,,,,,
458,"has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;
	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);
	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}","has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;
	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);
	int a = 2;
	int b = 2;
	if (a == b) {
    	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	const char
    	    *attribute,
    	    *content;
    	size_t
    	    length;
    	table->width=StringToUnsignedLong(attribute);
    	table->height=StringToUnsignedLong(attribute);
    	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    	length=(size_t) table->width*table->height;
    	table->levels=(unsigned int *) AcquireQuantumMemory(length,
    	    sizeof(*table->levels));
	}
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}",0,1,28,0.51,Insert
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;
	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;
	local64_set(&hwc->prev_count, (u64)-left);
	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);
	perf_event_update_userpage(event);
	return ret;
}","armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;
	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;
		struct delegpt* mp;
		struct delegpt_addr* a_1, *o, *ak;
		a_1 = mp->usable_list;
	local64_set(&hwc->prev_count, (u64)-left);
	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);
	int a = 2;
	int b = 3;
	while (a < b) {
    	perf_event_update_userpage(event);
    	b = a;
	}
	return ret;
}",0,1,34,1.01,Insert
462,,,,,,,
465,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM;  
  p = conn->handler;
  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);
    if(result)
      return result;
    p = conn->handler;               
  }
  if(conn->port < 0)
    conn->port = p->defport;
  return CURLE_OK;
}","static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM;  
  p = conn->handler;
  if(p->setup_connection) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        result = (*p->setup_connection)(conn);
    strcpy(str, ""a"");
    }
    if(result)
      return result;
    p = conn->handler;               
  }
  if(conn->port < 0)
    conn->port = p->defport;
  return CURLE_OK;
}",0,1,12,0.17,Replace
467,,,,,,,
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;
	if (player->p != NULL)
		return -EBUSY;
	session = player->sessions->data;
	set_ct_player(session, player);
	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;
	avrcp_list_items(session, start, end);
	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;
	return 0;
}","static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct pending_list_items *p;
	}
	if (player->p != NULL)
		return -EBUSY;
	session = player->sessions->data;
	set_ct_player(session, player);
	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;
	avrcp_list_items(session, start, end);
	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;
	return 0;
}",0,1,1,0.16,Replace
473,"static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)
{
	return fsetxattr(fsp->fh->fd, name, value, size, flags);
}","static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	WS_SFTP_BUFFER* buffer;
    	word32 value_8;
    	if (buffer != NULL) {
    	        c32toa(value_8, buffer->data + buffer->idx);
    	        buffer->idx += UINT32_SZ;
    	}
    	return fsetxattr(fsp->fh->fd, name, value, size, flags);
	}
}",0,1,3,0.36,Insert
474,,,,,,,
477,,,,,,,
479,"Item *Item_decimal::neg(THD *thd)
{
  my_decimal_neg(&decimal_value);
  unsigned_flag= 0;
  name= 0;
  max_length= my_decimal_precision_to_length_no_truncation(
                      decimal_value.intg + decimals, decimals, unsigned_flag);
  return this;
}","Item *Item_decimal::neg(THD *thd)
{
  struct sk_buff *skb;
  struct sock *sk;
  struct tcp_sock *tp = tcp_sk(sk);
  u32 length, end64seq;
  struct tcp_sock *tp = tcp_sk(sk);
  u32 length, end64seq;
  SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
  "",
  		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
  length = TCP_SKB_CB(skb)->length;
  int a = 2;
  int b = 3;
  while (a < b) {
      my_decimal_neg(&decimal_value);
      b = a;
  }
  unsigned_flag= 0;
  name= 0;
  max_length= my_decimal_precision_to_length_no_truncation(
                      decimal_value.intg + decimals, decimals, unsigned_flag);
  return this;
}",0,1,10,0.38,Insert
481,,,,,,,
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;
	p->signal->group_stop_count = 0;
	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}
	return count;
}","int zap_other_threads(struct task_struct *p)
{
	VirtIODevice *vrdevice;
	struct virtio_blk_config blkcfg;
	VirtIOBlock *s = VIRTIO_BLK(vrdevice);
	uint64_t capacity;
	VirtIOBlock *s = VIRTIO_BLK(vrdevice);
	bdrv_get_geometry(s->bs, &capacity);
	virtio_stq_p(vrdevice, &blkcfg.capacity, capacity);
	struct task_struct *t = p;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int count = 0;
	strcpy(str, ""a"");
	}
	p->signal->group_stop_count = 0;
	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}
	return count;
}",0,1,18,0.43,Insert
483,"static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)
{
	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
		fuse_link_write_file(file);
	file_accessed(file);
	vma->vm_ops = &fuse_file_vm_ops;
	return 0;
}","static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)
{
	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
		fuse_link_write_file(file);
	file_accessed(file);
	int a = 2;
	int b = 3;
	while (a < b) {
    	MachineState *machine;
    	char *filename;
    	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    	long load_limit, fw_size;
    	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    	spapr->rtas_size = get_image_size(filename);
    	g_free(filename);
    	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    	vma->vm_ops = &fuse_file_vm_ops;
    	b = a;
	}
	return 0;
}",0,1,7,0.32,Insert
487,,,,,,,
488,,,,,,,
491,"static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}","static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
    	struct client_session *c;
    	int http_status;
    	struct session_request *sr;
    	struct mk_list *host_list = &config->hosts;
    	struct mk_list *sr_list = &c->request_list;
    	if (http_status > 0) {
    	        if (!sr->host_conf) {
    	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
    	        }
    	        mk_request_error(http_status, c, sr);
    	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
    	                            NULL, c, sr);
    	}
    	b = a;
	}
}",0,1,5,0.39,Insert
492,"void setupSigSegvAction(void) {
    struct sigaction act;
    sigemptyset (&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void setupSigSegvAction(void) {
    struct sigaction act;
    sigemptyset (&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    int a = 2;
    int b = 2;
    while (a == b) {
        sigaction (SIGTERM, &act, NULL);
        b += 1;
        const char *filename;
        int64_t parent;
        int ecd;
        ecd = open(filename, O_RDONLY | O_BINARY);
        parent = lseek(ecd, 0, SEEK_END);
        close(ecd);
    }
    return;
}",0,1,36,0.76,Insert
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;
    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;
    if (s == NULL)
        return (NULL);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        sk = SSL_get_ciphers(s);
    strcpy(str, ""a"");
    }
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}",0,1,5,0.12,Replace
498,,,,,,,
501,"Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {
    return authorizationManagerPinnedUsers.setFromString(str);
}","Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {
    int a_1 = 31;
    int b_1 = a_1;
    if(a_1*b_1>0){
        return authorizationManagerPinnedUsers.setFromString(str);
        mmu_ctx_t *exec;
        int target_width_bytes;
        if (target_width_bytes != TARGET_PAGE_BITS) {
                exec->raddr |= (exec->eaddr & ((1 << target_width_bytes) - 1))
                              & TARGET_PAGE_MASK;
        }
    }
}",0,1,4,0.19,Insert
503,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    int a = 2;
    int b = 3;
    while (a < b) {
        char *reason;
        TabContents* continents_7;
        int event_2;
        StartRemoveTabAnimation_3(event_2, continents_7->web_contents());
        GetTabAt_10(event_2)->set_closing(true);
        b = a;
    }
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    TabContents* continents;
    int event;
    StartRemoveTabAnimation(event, continents->web_contents());
    GetTabAt(event)->set_closing(true);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}",1,0,50,0.85,Insert
505,,,,,,,
508,,,,,,,
510,,,,,,,
514,"static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	return 0;
}","static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	int a = 2;
	int b = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	void *pack;
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	while (a == b) {
    	return 0;
    	b += 1;
	}
}",0,1,9,0.32,Insert
516,"lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,
                 LYS_NODE type, const struct lys_node **ret)
{
    const struct lys_node *node;
    assert((mod || parent) && name);
    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));
    if (!mod) {
        mod = lys_node_module(parent);
    }
    node = NULL;
    while ((node = lys_getnext(node, parent, mod, 0))) {
        if (!type || (node->nodetype & type)) {
            if (lys_node_module(node) != lys_main_module(mod)) {
                continue;
            }
            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {
                if (ret) {
                    *ret = node;
                }
                return EXIT_SUCCESS;
            }
        }
    }
    return EXIT_FAILURE;
}","lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,
                 LYS_NODE type, const struct lys_node **ret)
{
    const struct lys_node *node;
    assert((mod || parent) && name);
    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));
    struct db *db;
    if (atomic_long_dec_and_test(&db->f_count)) {
    		struct task_struct *link = current;
    		file_sb_list_del(db);
    		struct db_10 *db_10;
    		if (atomic_long_dec_and_test_3(&db_10->f_count)) {
    				struct task_struct *link_1 = current_3;
    				file_sb_list_del_1(db_10);
    				BUG_ON_6(!(link_1->flags & PF_KTHREAD_5));
    				__fput_6(db_10);
    		}
    		BUG_ON(!(link->flags & PF_KTHREAD));
    		__fput(db);
    }
    if (!mod) {
        mod = lys_node_module(parent);
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        node = NULL;
    }
    while ((node = lys_getnext(node, parent, mod, 0))) {
        if (!type || (node->nodetype & type)) {
            if (lys_node_module(node) != lys_main_module(mod)) {
                continue;
            }
            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {
                if (ret) {
                    *ret = node;
                }
                return EXIT_SUCCESS;
            }
        }
    }
    return EXIT_FAILURE;
}",1,0,842,6.28,Insert
517,"TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}","TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    int a = 2;
    int b = 3;
    while (a != b) {
        addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
        b = a;
    }
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        files_struct *lsp;
        const struct dom_sid *group_sid = NULL;
        TALLOC_CTX *frame = talloc_stackframe();
        struct security_descriptor *psd = NULL;
        const struct dom_sid *owner_sid = NULL;
        struct security_descriptor *parent_desc = NULL;
        struct security_token *token = lsp->conn->session_info->security_token;
        status = se_create_child_secdesc(frame,
        			&psd,
        			&size,
        			parent_desc,
        			owner_sid,
        			group_sid,
        			lsp->is_directory);
        status = SMB_VFS_FSET_NT_ACL(lsp,
        			security_info_sent,
        			psd);
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}",0,1,27,0.4,Insert
518,"int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
{
    cmsStage* Anterior = NULL, *pt;
    if (lut == NULL || mpe == NULL)
        return FALSE;
    switch (loc) {
        case cmsAT_BEGIN:
            mpe ->Next = lut ->Elements;
            lut ->Elements = mpe;
            break;
        case cmsAT_END:
            if (lut ->Elements == NULL)
                lut ->Elements = mpe;
            else {
                for (pt = lut ->Elements;
                     pt != NULL;
                     pt = pt -> Next) Anterior = pt;
                Anterior ->Next = mpe;
                mpe ->Next = NULL;
            }
            break;
        default:;
            return FALSE;
    }
    BlessLUT(lut);
    return TRUE;
}","int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
{
    cmsStage* Anterior = NULL, *pt;
    if (lut == NULL || mpe == NULL)
        return FALSE;
    switch (loc) {
        case cmsAT_BEGIN:
            mpe ->Next = lut ->Elements;
            lut ->Elements = mpe;
            break;
        case cmsAT_END:
            if (lut ->Elements == NULL)
                lut ->Elements = mpe;
            else {
                for (pt = lut ->Elements;
                     pt != NULL;
                     pt = pt -> Next) Anterior = pt;
                Anterior ->Next = mpe;
                mpe ->Next = NULL;
            }
            break;
        default:;
            return FALSE;
    }
    int a = 2;
    int b = a;
    TCGMemOp ox;
    DisasContext *ks;
    gen_op_ld_v(ks, ox, cpu_T[0], cpu_A0);
    gen_helper_out_func(ox, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ox);
    if(a*b>0){
        BlessLUT(lut);
    }
    return TRUE;
}",0,1,23,0.59,Insert
519,"static bool is_physical_fs(const struct statfs *sfs) {
        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);
}","static bool is_physical_fs(const struct statfs *sfs) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            MachineState *process;
            MemoryRegion *dram;
            MemoryRegion *SysMem;
            ram_addr_t ram_size = process->ram_size;
            MemoryRegion *sysram;
            SysMem = get_system_memory();
            memory_region_allocate_system_memory(dram, NULL, ""highbank.dram"", ram_size);
            memory_region_add_subregion(SysMem, 0, dram);
            memory_region_init_ram(sysram, NULL, ""highbank.sysram"", 0x8000,
                                       &error_fatal);
            memory_region_add_subregion(SysMem, 0xfff88000, sysram);
            return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);
        strcpy(str, ""a"");
        }
}",0,1,8,0.19,Insert
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                unref_picture(h, &h->DPB[i]);
                struct super_block *sb;
                unsigned long qf_incum[EXT4_MAXQUOTAS] = {
                		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
                		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
                		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
                	};
                sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
            }
        }
    }
}",0,1,6,0.48,Insert
522,,,,,,,
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;
	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;
	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
	T_BEGIN {
		string_t *str;
		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));
		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;
	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;
	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
	T_BEGIN {
		int a_1 = 2;
		int b_1 = 2;
		while (a_1 == b_1) {
    		string_t *str;
    		b_1 += 1;
		}
		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));
		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}",0,1,8,0.19,Replace
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}
	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}
	*client = NULL;
	return false;
}","static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}
	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		*client = list->data;
    		b += 1;
		}
		return false;
	}
	*client = NULL;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	void *pack;
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	return false;
}",0,1,13,0.56,Insert
528,"static BOOL rdp_print_input_capability_set(wStream* s, UINT16 length)
{
	UINT16 inputFlags;
	UINT16 pad2OctetsA;
	UINT32 keyboardLayout;
	UINT32 keyboardType;
	UINT32 keyboardSubType;
	UINT32 keyboardFunctionKey;
	WLog_INFO(TAG, ""InputCapabilitySet (length %"" PRIu16 "")"", length);
	if (length < 88)
		return FALSE;
	Stream_Read_UINT16(s, inputFlags);           
	Stream_Read_UINT16(s, pad2OctetsA);          
	Stream_Read_UINT32(s, keyboardLayout);       
	Stream_Read_UINT32(s, keyboardType);         
	Stream_Read_UINT32(s, keyboardSubType);      
	Stream_Read_UINT32(s, keyboardFunctionKey);  
	Stream_Seek(s, 64);                          
	WLog_INFO(TAG, ""\tinputFlags: 0x%04"" PRIX16 """", inputFlags);
	WLog_INFO(TAG, ""\tpad2OctetsA: 0x%04"" PRIX16 """", pad2OctetsA);
	WLog_INFO(TAG, ""\tkeyboardLayout: 0x%08"" PRIX32 """", keyboardLayout);
	WLog_INFO(TAG, ""\tkeyboardType: 0x%08"" PRIX32 """", keyboardType);
	WLog_INFO(TAG, ""\tkeyboardSubType: 0x%08"" PRIX32 """", keyboardSubType);
	WLog_INFO(TAG, ""\tkeyboardFunctionKey: 0x%08"" PRIX32 """", keyboardFunctionKey);
	return TRUE;
}","static BOOL rdp_print_input_capability_set(wStream* s, UINT16 length)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	UINT16 inputFlags;
    	b += 1;
	}
	UINT16 pad2OctetsA;
	UINT32 keyboardLayout;
	UINT32 keyboardType;
	UINT32 keyboardSubType;
	UINT32 keyboardFunctionKey;
	WLog_INFO(TAG, ""InputCapabilitySet (length %"" PRIu16 "")"", length);
	if (length < 88)
		return FALSE;
	Stream_Read_UINT16(s, inputFlags);           
	Stream_Read_UINT16(s, pad2OctetsA);          
	Stream_Read_UINT32(s, keyboardLayout);       
	Stream_Read_UINT32(s, keyboardType);         
	Stream_Read_UINT32(s, keyboardSubType);      
	Stream_Read_UINT32(s, keyboardFunctionKey);  
	Stream_Seek(s, 64);                          
	WLog_INFO(TAG, ""\tinputFlags: 0x%04"" PRIX16 """", inputFlags);
	WLog_INFO(TAG, ""\tpad2OctetsA: 0x%04"" PRIX16 """", pad2OctetsA);
	WLog_INFO(TAG, ""\tkeyboardLayout: 0x%08"" PRIX32 """", keyboardLayout);
	WLog_INFO(TAG, ""\tkeyboardType: 0x%08"" PRIX32 """", keyboardType);
	WLog_INFO(TAG, ""\tkeyboardSubType: 0x%08"" PRIX32 """", keyboardSubType);
	WLog_INFO(TAG, ""\tkeyboardFunctionKey: 0x%08"" PRIX32 """", keyboardFunctionKey);
	return TRUE;
}",0,1,1,0.17,Replace
530,"struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	refcount_inc(&fc->count);
	return fc;
}","struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	const char *name1;
	unsigned char c1, mc7;
	c1 = name1[len];
	refcount_inc(&fc->count);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return fc;
	strcpy(str, ""a"");
	}
}",0,1,7,0.23,Insert
531,"static void stub_disconnect(struct usb_device *udev)
{
	struct stub_device *sdev;
	const char *udev_busid = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int rc;
	dev_dbg(&udev->dev, ""Enter disconnect\n"");
	busid_priv = get_busid_priv(udev_busid);
	if (!busid_priv) {
		BUG();
		return;
	}
	sdev = dev_get_drvdata(&udev->dev);
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		return;
	}
	dev_set_drvdata(&udev->dev, NULL);
	stub_remove_files(&udev->dev);
	rc = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct usb_dev_state *) udev);
	if (rc) {
		dev_dbg(&udev->dev, ""unable to release port\n"");
		return;
	}
	if (usbip_in_eh(current))
		return;
	shutdown_busid(busid_priv);
	usb_put_dev(sdev->udev);
	busid_priv->sdev = NULL;
	stub_device_free(sdev);
	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;
}","static void stub_disconnect(struct usb_device *udev)
{
	struct stub_device *sdev;
	const char *udev_busid = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int rc;
	dev_dbg(&udev->dev, ""Enter disconnect\n"");
	busid_priv = get_busid_priv(udev_busid);
	if (!busid_priv) {
		BUG();
		int a = 2;
		int b = 3;
		while (a != b) {
    		return;
    		b = a;
		}
	}
	sdev = dev_get_drvdata(&udev->dev);
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		return;
	}
	dev_set_drvdata(&udev->dev, NULL);
	stub_remove_files(&udev->dev);
	rc = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct usb_dev_state *) udev);
	if (rc) {
		dev_dbg(&udev->dev, ""unable to release port\n"");
		return;
	}
	if (usbip_in_eh(current))
		return;
	shutdown_busid(busid_priv);
	usb_put_dev(sdev->udev);
	busid_priv->sdev = NULL;
	stub_device_free(sdev);
	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;
}",1,0,4,0.2,Replace
532,,,,,,,
533,,,,,,,
534,"static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	return (fe == NULL) ? -EIO : 0;
}","static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return (fe == NULL) ? -EIO : 0;
    	V9fsPath *fs_path;
    	FsContext *FS_path;
    	int fd, ret;
    	struct handle_data *parent = (struct handle_data *)FS_path->private;
    	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    	b = a;
	}
}",0,1,7,0.33,Insert
535,"i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;
#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif
    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);
    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}","i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;
    int i;
    struct sta_info *sta;
    for (i = 0; i < IEEE80211_NUM_ACS; i++) {
    		skb_queue_head_init(&sta->ps_tx_buf[i]);
    		skb_queue_head_init(&sta->tx_filtered[i]);
    }
#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
        int i_9;
        struct sta_info *sta_1;
        for (i_9 = 0; i_9 < IEEE80211_NUM_ACS_4; i_9++) {
        		skb_queue_head_init_8(&sta_1->ps_tx_buf[i_9]);
        		skb_queue_head_init_8(&sta_1->tx_filtered[i_9]);
        }
#endif
    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);
    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}",1,0,46,0.75,Insert
538,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	tp->ptp_info = tg3_ptp_caps;
	strcpy(str, ""a"");
	}
}",0,1,3,0.07,Replace
539,,,,,,,
543,"static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    return rc4_hmac_md5_set_ctx_params(ctx, params);
}","static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    int a = 2;
    int b = 2;
    while (a == b) {
        return rc4_hmac_md5_set_ctx_params(ctx, params);
        b += 1;
    }
}",0,1,1,0.06,Replace
544,,,,,,,
545,"ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;
	ax88179_phy_mmd_indirect(dev, prtad, devad);
	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;
	return tmp16;
}","ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ax88179_phy_mmd_indirect(dev, prtad, devad);
	strcpy(str, ""a"");
	}
	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;
		int ret_6;
		char data[1024];
		if (ret_6 < 0 || ret_6 > PROM_SIZE_MAX) {
		        fprintf(stderr, ""qemu: could not load prom '%s'
		"",
		                data);
		        exit(1);
		}
	return tmp16;
}",0,1,10,0.47,Insert
546,,,,,,,
547,"DEFUN (no_neighbor_nexthop_local_unchanged,
       no_neighbor_nexthop_local_unchanged_cmd,
       NO_NEIGHBOR_CMD2 ""nexthop-local unchanged"",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
       ""Configure treatment of outgoing link-local-nexthop attribute\n""
       ""Leave link-local nexthop unchanged for this peer\n"")
{
  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),
				 bgp_node_safi (vty),
                                PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED );
}","DEFUN (no_neighbor_nexthop_local_unchanged,
       no_neighbor_nexthop_local_unchanged_cmd,
       NO_NEIGHBOR_CMD2 ""nexthop-local unchanged"",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
       ""Configure treatment of outgoing link-local-nexthop attribute\n""
       ""Leave link-local nexthop unchanged for this peer\n"")
{
  int wb;
  void *data;
  AVPacket *avpkt;
  AVCodecContext *avctx;
  int buf_index      = 0;
  const uint8_t *buf = avpkt->data;
  int buf_size       = avpkt->size;
  H264Context *hy     = avctx->priv_data;
  buf_index = decode_nal_units(hy, buf, buf_size);
  uint32_t lvcall;
  CPUState *env;
  unsigned int valpages;
  uint32_t r_cause;
  int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t pid, lo, hi;
  int set, match = 0;
  r_cause = env->sregs[SFR_R_MM_CAUSE];
  D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
  		  "" %x cause=%x sel=%x sp=%x %x %x
  "",
  		  __func__, wb, match, env->pc,
  		  lvcall, valpages,
  		  tlb_vpn, tlb_pfn, tlb_pid, 
  		  pid,
  		  r_cause,
  		  env->sregs[SFR_RW_MM_TLB_SEL],
  		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),
				 bgp_node_safi (vty),
                                PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED );
}",0,1,32,0.45,Insert
549,"static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;
	if (driver->probe == NULL)
		return;
	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}
	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}","static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct btd_adapter_driver *driver = user_data;
	}
	int err;
	if (driver->probe == NULL)
		return;
	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}
	QuantizationTable
	    *table;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	table->slot=(char *) NULL;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}",0,1,16,0.52,Insert
550,"PERL_STATIC_INLINE IV
S_invlist_previous_index(SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;
    return *get_invlist_previous_index_addr(invlist);","PERL_STATIC_INLINE IV
S_invlist_previous_index(SV* const invlist)
{
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    int a = 2;
    int b = 3;
    while (a < b) {
        PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;
        b = a;
    }
    return *get_invlist_previous_index_addr(invlist);",0,1,3,0.29,Insert
552,,,,,,,
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;
	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;
	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);
	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct fsck_gitmodules_data *data = vdata;
    	b = a;
	}
	const char *subsection, *key;
	int subsection_len;
	char *name;
	drdynvcPlugin* drdynvc_8;
	int cbChId_10;
	int Sp_1;
	int value_4;
	int Cmd_10;
	Cmd_10 = (value_4 & 0xf0) >> 4;
	WLog_Print_7(drdynvc_8->log, WLOG_DEBUG_3, ""order_recv: Cmd=0x%x, Sp=%d cbChId=%d"", Cmd_10, Sp_1, cbChId_10);
	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;
	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
				    drdynvcPlugin* drdynvc;
				    int cbChId;
				    int Sp;
				    int value_10;
				    int Cmd;
				    Cmd = (value_10 & 0xf0) >> 4;
				    WLog_Print(drdynvc->log, WLOG_DEBUG, ""order_recv: Cmd=0x%x, Sp=%d cbChId=%d"", Cmd, Sp, cbChId);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);
	return 0;
}",1,0,54,1.22,Insert
558,"xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;
    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}","xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    dev_dbg(dev, ""%s - Unknown
    "", __func__);
    int a = 2;
    int b = 3;
    while (a != b) {
        xmlNodePtr cur;
        b = a;
    }
    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}",0,1,14,0.78,Insert
559,"lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }
    return lyd_insert_nextto(sibling, node, 1, 1);
}","lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
        AVCodecContext *AVcas;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        VdpBool supported;
        VdpChromaType type;
        VdpStatus status;
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
    }
    int a = 29;
    int b = a;
    if(a*b>0){
        return lyd_insert_nextto(sibling, node, 1, 1);
    }
}",0,1,7,0.37,Insert
560,"S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;
  ScriptInformation.InformationLength = InformationLength;
  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}","S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);
  struct bt_att_chan *con;
  uint8_t opcode;
  uint8_t ecode;
  struct async_write_op *cmp = NULL;
  cmp->con = con;
  bt_att_chan_send_error_rsp(con, opcode, handle, ecode);
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;
  ScriptInformation.InformationLength = InformationLength;
  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}
",1,0,54,0.64,Insert
562,"int process_open(ProcessHandle process, const char *fname) {
	int rv = process_open_nofail(process, fname);
	if (rv < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s\n"", process->pid, fname, strerror(errno));
		exit(1);
	}
	return rv;
}","int process_open(ProcessHandle process, const char *fname) {
	int a = 2;
	int b = 2;
	if (a == b) {
    	int rv = process_open_nofail(process, fname);
	}
	if (rv < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s\n"", process->pid, fname, strerror(errno));
		exit(1);
	}
	return rv;
}",1,0,5,0.08,Replace
563,"static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)
{
	smart_str nstype = {0};
	get_type_str(node, ns, type, &nstype);
	set_xsi_type(node, nstype.c);
	smart_str_free(&nstype);
}","static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)
{
	smart_str nstype = {0};
	get_type_str(node, ns, type, &nstype);
	int a = 2;
	int b = 3;
	while (a != b) {
    	set_xsi_type(node, nstype.c);
    	b = a;
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type_10;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type_10, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	smart_str_free(&nstype);
}",0,1,10,0.42,Insert
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);
	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	strcpy(str, ""a"");
	}
	int ret_9, linux67boot;
	if (ret_9 < 0) {
	        fprintf(stderr, ""qemu: could not load prom '%s'
	"",
	                bios_name);
	        exit(1);
	}
	if (ret == 0)
		dev_set_cma_area(dev, cma);
	return ret;
}",0,1,9,0.5,Insert
568,"void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
{
	kvm_mmu_unload(vcpu);
	kvm_init_mmu(vcpu);
}","void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
{
	kvm_mmu_unload(vcpu);
	int a = 2;
	int b = 3;
	while (a < b) {
    	kvm_init_mmu(vcpu);
    	struct ldb_context *ydm;
    	const char *attr;
    	const struct ldb_schema_attribute *a_5;
    	a_5 = ldb_schema_attribute_by_name(ydm, attr);
    	b = a;
	}
}",0,1,5,0.27,Insert
569,,,,,,,
570,"static int display_open(void *handle, void *device)
{
    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));
    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }
    if (first_image)
        img->next = first_image;
    first_image = img;
    img->handle = handle;
    img->device = device;
    window_create(img);
    gtk_main_iteration_do(FALSE);
    return 0;
}","static int display_open(void *handle, void *device)
{
    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));
    if (first_image == NULL) {
        gdk_rgb_init();
        target_ulong rets_8;
        struct tm_8 tm_8;
        rtas_st_5(rets_8, 5, tm_8.tm_min);
        rtas_st_5(rets_8, 6, tm_8.tm_sec);
        rtas_st_5(rets_8, 7, 0);
        int a = 2;
        target_ulong rets;
        struct tm tm;
        rtas_st(rets, 5, tm.tm_min);
        rtas_st(rets, 6, tm.tm_sec);
        rtas_st(rets, 7, 0);
        int b = 3;
        if (a != b) {
            gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        }
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }
    if (first_image)
        img->next = first_image;
    first_image = img;
    img->handle = handle;
    img->device = device;
    window_create(img);
    gtk_main_iteration_do(FALSE);
    return 0;
}",1,0,687,4.78,Insert
575,"similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;
	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}","similar_sgr(char *a, char *b)
{
    struct delegpt* mp;
    struct delegpt_addr* a_3, *o, *ak;
    a_3 = mp->usable_list;
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	int a = 2;
	int b = 2;
	if (a == b) {
    	size_t len_a;
	}
	size_t len_b;
	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}",0,1,25,1.25,Insert
576,"rsvg_dpi_percentage (RsvgHandle * ctx)
{
    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
}","rsvg_dpi_percentage (RsvgHandle * ctx)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        uint64_t glms;
        unsigned k, b, err, C;
        unsigned k, b, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b = ctz64(glms);
        return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
    strcpy(str, ""a"");
    }
}",0,1,4,0.23,Insert
580,"int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                             EC_POINT *point, const BIGNUM *x,
                                             const BIGNUM *y, const BIGNUM *z,
                                             BN_CTX *ctx)
{
    if (group->meth->point_set_Jprojective_coordinates_GFp == 0) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    if (!ec_point_is_compat(point, group)) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              EC_R_INCOMPATIBLE_OBJECTS);
        return 0;
    }
    return group->meth->point_set_Jprojective_coordinates_GFp(group, point, x,
                                                              y, z, ctx);
}","int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                             EC_POINT *point, const BIGNUM *x,
                                             const BIGNUM *y, const BIGNUM *z,
                                             BN_CTX *ctx)
{
    if (group->meth->point_set_Jprojective_coordinates_GFp == 0) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    if (!ec_point_is_compat(point, group)) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              EC_R_INCOMPATIBLE_OBJECTS);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return 0;
        }
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        PutBitContext pb, pb2;
        JLSState *state;
        int i, size, ure;
        PutBitContext pb, pb2;
        ls_store_lse(state, &pb);
        put_bits(&pb2, 7, 0);
        size = put_bits_count(&pb2);
        flush_put_bits(&pb2);
        avpriv_align_put_bits(&pb);
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
        aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                         aml_name(""CDW1"")));
        aml_append(ifconfig, ifconfig0);
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
        aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                         aml_name(""CDW1"")));
    }
    return group->meth->point_set_Jprojective_coordinates_GFp(group, point, x,
                                                              y, z, ctx);
}",0,1,36,0.73,Insert
582,,,,,,,
583,,,,,,,
584,"dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
unsigned long time_msec;
if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);
time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}","dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int a = 2;
int b = 2;
if (a == b) {
    int retval;
}
unsigned long time_msec;
if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);
time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
const struct dom_sid *alias;
TALLOC_CTX *mem_stack;
struct pdb_methods *mut;
struct ldb_dn *anon;
TALLOC_CTX *mem_context = talloc_new(mem_stack);
struct dom_sid_buf buf;
struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
		mut->private_data, struct pdb_samba_dsdb_state);
NT_STATUS_HAVE_NO_MEMORY(mem_context);
anon = ldb_dn_new_fmt(
		mem_context,
		area->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
talloc_free(mem_context);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}",0,1,13,0.67,Insert
586,,,,,,,
587,,,,,,,
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    int a = 2;
    int b = 2;
    if (a == b) {
        V9fsState *s_6;
        int i_5, len_8;
        for (i_5 = 0; i_5 < (MAX_REQ_8 - 1); i_5++) {
                QLIST_INSERT_HEAD_3(&s_6->free_list, &s_6->pdus[i_5], next_2);
                s_6->pdus[i_5].s_6 = s_6;
                s_6->pdus[i_5].idx = i_5;
        }
        char *reason;
    }
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    V9fsState *s;
    int i, len;
    for (i = 0; i < (MAX_REQ - 1); i++) {
            QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);
            s->pdus[i].s = s;
            s->pdus[i].idx = i;
    }
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}",1,0,70,0.95,Insert
596,"static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int i;
    av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);
    for (i = 0; i < 4; i++) {
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            return AVERROR(ENOMEM);
        }
    }
    return 0;
}","static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int i;
    av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);
    for (i = 0; i < 4; i++) {
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            int a = 2;
            int b = 2;
            DisplayState *ds;
            const struct sun4d_hwdef *hawdecl;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            ram_addr_t gram_size, prom_reset, tcx64off;
            tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                         hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
            escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
                          serial_hds[0], ESCC_CLOCK, 1);
            if (a == b) {
                return AVERROR(ENOMEM);
            }
        }
    }
    return 0;
}",0,1,16,0.5,Insert
599,,,,,,,
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;
    qemu_mutex_lock(&iscsilun->mutex);
    iscsi_service(iscsilun->iscsi, 0);
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }
    iscsi_set_events(iscsilun);
    qemu_mutex_unlock(&iscsilun->mutex);
    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;
    qemu_mutex_lock(&iscsilun->mutex);
    iscsi_service(iscsilun->iscsi, 0);
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }
    iscsi_set_events(iscsilun);
    int a = 59;
    int b = a;
    if(a*b>0){
        qemu_mutex_unlock(&iscsilun->mutex);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
        ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
        GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    }
    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}",0,1,17,0.4,Insert
602,"static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;
	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);
	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}","static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);
	}
	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}",0,1,4,0.08,Replace
606,"static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;
	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}","static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;
	if (ws->active) {
		struct perf_event *pb;
		struct perf_event *pb_7;
		struct perf_event_attr attr_6;
		attr_6 = pb_7->attr_6;
		attr_6.disabled = true;
		modify_user_hw_breakpoint_6(pb_7, &attr_6);
		struct perf_event_attr attr_10;
		attr_10 = pb->attr_10;
		attr_10.disabled = true;
		modify_user_hw_breakpoint(pb, &attr_10);
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		active_time = ktime_sub(ktime_get(), ws->last_time);
		}
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}",1,0,42,0.58,Insert
608,,,,,,,
610,,,,,,,
613,,,,,,,
614,,,,,,,
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      struct peer *const peer = args->peer; 
  strcpy(str, ""a"");
  }
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}",0,1,1,0.1,Replace
617,,,,,,,
620,"  const char *type_name()
  {
    return type == COLUMN ? ""COLUMN"" :
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }","  const char *type_name()
  {
    return type == COLUMN ? ""COLUMN"" :
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           const char
               *attribute,
               *content;
           XMLTreeInfo
               *description,
               *levels,
               *quantization_tables,
               *table_iterator;
           QuantizationTable
               *table;
           XMLTreeInfo
               *description,
               *levels,
               *quantization_tables,
               *table_iterator;
           XMLTreeInfo
               *description,
               *levels,
               *quantization_tables,
               *table_iterator;
           table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
           table->slot=(char *) NULL;
           table->description=(char *) NULL;
           table->levels=(unsigned int *) NULL;
           attribute=GetXMLTreeAttribute(table_iterator,""slot"");
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }",0,1,1,0.16,Insert
622,"xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		 
	xfs_agblock_t	foundbno,	 
	xfs_extlen_t	foundlen,	 
	xfs_agblock_t	*resbno,	 
	xfs_extlen_t	*reslen,	 
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}
	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);
		diff = aligned_bno - bno;
		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}
	return busy;
}","xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		 
	xfs_agblock_t	foundbno,	 
	xfs_extlen_t	foundlen,	 
	xfs_agblock_t	*resbno,	 
	xfs_extlen_t	*reslen,	 
	unsigned	*busy_gen)
{
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    	xfs_agblock_t	bno = foundbno;
    	void *data;
    	AVPacket *avpkt;
    	AVCodecContext *avctx;
    	int buf_index      = 0;
    	const uint8_t *buf = avpkt->data;
    	int buf_size       = avpkt->size;
    	H264Context *hy     = avctx->priv_data;
    	buf_index = decode_nal_units(hy, buf, buf_size);
		}
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}
	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);
		diff = aligned_bno - bno;
		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}
	return busy;
}",0,1,31,0.98,Insert
623,,,,,,,
625,,,,,,,
626,"Status AuthorizationManager::getRolesDescription(OperationContext* txn,
                                                 const std::vector<RoleName>& roleName,
                                                 PrivilegeFormat privileges,
                                                 BSONObj* result) {
    return _externalState->getRolesDescription(txn, roleName, privileges, result);
}","Status AuthorizationManager::getRolesDescription(OperationContext* txn,
                                                 const std::vector<RoleName>& roleName,
                                                 PrivilegeFormat privileges,
                                                 BSONObj* result) {
    int a = 2;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    int b = 2;
    if (a == b) {
        return _externalState->getRolesDescription(txn, roleName, privileges, result);
    }
}",0,1,4,0.32,Insert
627,,,,,,,
629,,,,,,,
630,,,,,,,
631,"rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'c');
}","rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    int a_1 = 2;
    int b_1 = 2;
    if (a_1 == b_1) {
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        int rules, nb_regs, ini;
        rules = args[nb_oargs + nb_iargs + 1];
        return rb_str_justify(argc, argv, str, 'c');
    }
}",0,1,4,0.34,Insert
632,"static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	return (busnum << 16) | devnum;
}","static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return (busnum << 16) | devnum;
	}
}",0,1,9,0.18,Insert
633,"static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
}","static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct sk_buff *skb;
    	struct sock *sk;
    	struct tcp_sock *tp = tcp_sk(sk);
    	u32 length, end64seq;
    	struct tcp_sock *tp = tcp_sk(sk);
    	u32 length, end64seq;
    	SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    	"",
    			   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    	length = TCP_SKB_CB(skb)->length;
    	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
	strcpy(str, ""a"");
	}
}",0,1,12,0.26,Insert
634,"void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;
    hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;
    return &pair->list;
}","void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;
    hash = hash_str(key);
    int a = 2;
    unsigned long val;
    void *ptr = NULL;
    if (val) {
    		unsigned long val_7;
    		void *ptr_3 = NULL;
    		if (val_7) {
    				phys_addr_t phys_2 = gen_pool_virt_to_phys_10(atomic_pool_8, val_7);
    		 		*ret_pages_1 = phys_to_page_7(phys_2);
    		 		ptr_3 = (void *)val_7;
    				if (flags_9 & __GFP_ZERO_9)
    					memset_5(ptr_3, 0, size_6);
    		}
    		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
     		*ret_pages = phys_to_page(phys);
     		ptr = (void *)val;
    		if (flags & __GFP_ZERO)
    			memset(ptr, 0, size);
    }
    int b = 3;
    while (a != b) {
        bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
        b = a;
    }
    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;
    return &pair->list;
}",1,0,100,0.93,Insert
637,"test_bson_concat (void)
{
   bson_t a = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   bson_t c = BSON_INITIALIZER;
   bson_append_int32 (&a, ""abc"", 3, 1);
   bson_append_int32 (&b, ""def"", 3, 1);
   bson_concat (&a, &b);
   bson_append_int32 (&c, ""abc"", 3, 1);
   bson_append_int32 (&c, ""def"", 3, 1);
   BSON_ASSERT (0 == bson_compare (&c, &a));
   bson_destroy (&a);
   bson_destroy (&b);
   bson_destroy (&c);
}","test_bson_concat (void)
{
   bson_t a = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   bson_t c = BSON_INITIALIZER;
   bson_append_int32 (&a, ""abc"", 3, 1);
   bson_append_int32 (&b, ""def"", 3, 1);
   bson_concat (&a, &b);
   bson_append_int32 (&c, ""abc"", 3, 1);
   int a = 2;
   int b = 2;
   while (a == b) {
       bson_append_int32 (&c, ""def"", 3, 1);
       b += 1;
   }
   BSON_ASSERT (0 == bson_compare (&c, &a));
   bson_destroy (&a);
   ptrdiff_t src_stride;
   ptrdiff_t buf_stride;
   int h;
   int src_y;
   int block_h;
   int w;
   int block_w;
   const uint8_t *src;
   int src_x;
   uint8_t *buf;
   emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                        src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                        hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
   bson_destroy (&b);
   bson_destroy (&c);
}",0,1,26,0.48,Insert
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return 0;
    }
}",0,1,3,0.05,Replace
642,,,,,,,
643,,,,,,,
649,,,,,,,
650,,,,,,,
652,,,,,,,
653,"png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   double r = floor(100000 * fp + .5);
   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(png_ptr, text);
#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif
   return (png_fixed_point)r;
}","png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   DisasContext *qs;
   uint32_t ksns;
   unsigned int coll, order, err, resp, coll, p, nzcv;
   unsigned int coll, order, err, resp, coll, p, nzcv;
   unsigned int coll, order, err, resp, coll, p, nzcv;
   unsigned int coll, order, err, resp, coll, p, nzcv;
   err = extract32(ksns, 16, 5);
   handle_fp_compare(qs, order, coll, err, false, p);
   double r = floor(100000 * fp + .5);
   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(png_ptr, text);
#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif
   int a = 20;
   int b = a;
   if(a*b>0){
       return (png_fixed_point)r;
   }
}",0,1,3,0.41,Insert
654,,,,,,,
655,"NAN_MODULE_INIT(init) {
  ChaChaPolyCipher::Init(target);
  AESGCMCipher::Init(target);
  GenericCipher::Init(target);
  ChaChaPolyDecipher::Init(target);
  AESGCMDecipher::Init(target);
  GenericDecipher::Init(target);
}","NAN_MODULE_INIT(init) {
  ChaChaPolyCipher::Init(target);
  AESGCMCipher::Init(target);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      GenericCipher::Init(target);
  strcpy(str, ""a"");
  }
  ChaChaPolyDecipher::Init(target);
  AESGCMDecipher::Init(target);
  GenericDecipher::Init(target);
}",0,1,9,0.12,Replace
662,,,,,,,
663,,,,,,,
665,"set_unused_field_bp(unsigned char *bp, int from, int to)
{
	memset(bp + from, 0, to - from + 1);
}","set_unused_field_bp(unsigned char *bp, int from, int to)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	memset(bp + from, 0, to - from + 1);
}",0,1,2,0.19,Insert
666,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();
  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);
  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);
  return(CONST_LUA_OK);
}","static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();
  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);
  int a = 34;
  int b = a;
  if(a*b>0){
      lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);
  }
  return(CONST_LUA_OK);
}",0,1,15,0.5,Insert
667,,,,,,,
670,,,,,,,
672,"static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;
	nb = rcu_dereference(*nl);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		ret = nb->notifier_call(nb, val, v);
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
	}
	return ret;
}","static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;
	nb = rcu_dereference(*nl);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		int a = 2;
		int b = 3;
		while (a < b) {
    		VdpDecoderProfile profile;
    		AVCodecContext *AVcas;
    		uint32_t input;
    		VdpDecoderCreate *create;
    		VdpStatus status;
    		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    		void *pack;
    		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    		                                     &pack);
    		status = create(hdtx->device, profile, width, input, AVcas->refs,
    		                    &hdtx->decoder);
    		ret = nb->notifier_call(nb, val, v);
    		b = a;
		}
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
	}
	return ret;
}",0,1,36,0.7,Insert
675,,,,,,,
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","free_key_ctx (struct key_ctx *ctx)
{
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          free(ctx->hmac);
      strcpy(str, ""a"");
      }
      ctx->hmac = NULL;
    }
}",0,1,13,0.32,Insert
679,"u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);
    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    return ul->ul_line == NULL ? FAIL : OK;
}","u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);
    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	ul->ul_len = curbuf->b_ml.ml_line_len;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ul->ul_line = vim_memsave(line, ul->ul_len);
	strcpy(str, ""a"");
	}
    }
    ParseContext *comp;
    uint32_t state= comp->state;
    uint32_t state= comp->state;
    comp->state= state;
    return ul->ul_line == NULL ? FAIL : OK;
}",0,1,18,0.45,Insert
681,"void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *sp_re_str =ps_re_str;
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *sp_re_str =ps_re_str;
  AVPacket * pk;
  AVFormatContext *s;
  int size               =  pk->size;
  AVIOContext *b_1     = s->b_1;
  if (size & 1)
          avio_w8(b_1, 0);
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  int a = 2;
  int b = 2;
  if (a == b) {
      init_re_comp(&view_re, view_re_str);
  }
}",0,1,9,0.36,Insert
682,,,,,,,
684,,,,,,,
686,,,,,,,
687,"static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}","static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	AVFrame *p;
    	AVDictionary *metadata  = NULL;
    	av_frame_set_metadata(p, metadata);
    	metadata   = NULL;
    	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
    	b = a;
	}
	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}",1,0,12,0.35,Insert
688,,,,,,,
692,"CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)
{
    return pthread_self();
}","CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        return pthread_self();
        uint64_t glms;
        unsigned k, b_8, err, C;
        unsigned k, b_8, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_8 = ctz64(glms);
        b = a;
    }
}",0,1,3,0.22,Insert
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void __wait_on_freeing_inode(struct inode *inode)
{
	QEMUMachineInitArgs *args;
	char *filename;
	ram_addr_t ram_size = args->ram_size;
	long load_limit, rtas_limit, fw_size;
	spapr->next_irq = XICS_IRQ_BASE;
	spapr->ram_limit = ram_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	spapr_events_init(spapr);
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	spin_lock(&inode_hash_lock);
	strcpy(str, ""a"");
	}
}",0,1,19,0.47,Insert
695,,,,,,,
697,"static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,
				  struct hfi1_user_sdma_comp_q *cq,
				  u16 idx, enum hfi1_sdma_comp_state state,
				  int ret)
{
	if (state == ERROR)
		cq->comps[idx].errcode = -ret;
	smp_wmb();  
	cq->comps[idx].status = state;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
					idx, state, ret);
}","static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,
				  struct hfi1_user_sdma_comp_q *cq,
				  u16 idx, enum hfi1_sdma_comp_state state,
				  int ret)
{
	AVFormatContext *your;
	int port, i, status, r;
	RTSPState *rt = your->priv_data;
	if (ff_rtsp_callback) {
	        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
	                             NULL, 0, rt->last_reply) < 0) {
	            r = AVERROR_INVALIDDATA;
	            goto fail;
	        }
	}
	if (state == ERROR)
		cq->comps[idx].errcode = -ret;
	smp_wmb();  
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	cq->comps[idx].status = state;
	}
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
					idx, state, ret);
}",0,1,8,0.5,Insert
702,"int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;
	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}","int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;
	tx_ctl = HTC_SKB_CB(skb);
	int a = 2;
	struct delegpt* mp;
	struct delegpt_addr* a_2, *o, *ak;
	a_2 = mp->usable_list;
	int b = 3;
	if (a != b) {
    	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
    	void *opaque;
    	int32_t fid;
    	V9fsPDU *dru = opaque;
    	V9fsStat f9stats;
    	ssize_t err = 0;
    	size_t offset = 7;
    	pdu_unmarshal(dru, offset, ""d"", &fid);
    	offset += pdu_marshal(dru, offset, ""wS"", 0, &f9stats);
    	err = offset;
	}
}",0,1,37,0.41,Insert
703,,,,,,,
704,"BrokenSyncWithServer(XIC xic)
{
    CARD32 dummy;
    XGetICValues(xic, XNFilterEvents, &dummy, NULL);
}","BrokenSyncWithServer(XIC xic)
{
    CARD32 dummy;
    int a = 100;
    int b = a;
    if(a*b>0){
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                             &pack);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
        XGetICValues(xic, XNFilterEvents, &dummy, NULL);
    }
}",0,1,8,0.26,Insert
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;
	cpunum = cpu->dev.id;
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}","static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct target_signal_frame *frame_2;
    	abi_ulong frame_addr_9;
    	if (!lock_user_struct_1(VERIFY_WRITE_3, frame_2, frame_addr_9, 1))
    			goto badframe;
    	cpunum = cpu->dev.id;
    	struct target_signal_frame *frame;
    	abi_ulong frame_addr;
    	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))
    			goto badframe;
    	b = a;
	}
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}",1,0,69,0.78,Insert
707,"  bool IsSupported(const NodeDef* node) const override {
    return IsAnySparseSegmentReduction(*node);
  }","  bool IsSupported(const NodeDef* node) const override {
    int a = 2;
    int b = 3;
    while (a < b) {
        return IsAnySparseSegmentReduction(*node);
        uint64_t glms;
        unsigned k, b_10, err, C;
        unsigned k, b_10, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_10 = ctz64(glms);
        b = a;
    }
  }",0,1,4,0.2,Insert
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		int a = 2;
		int b = 2;
		while (a == b) {
    		return -1;
    		b += 1;
		}
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}",1,0,10,0.19,Replace
709,,,,,,,
711,"void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
	ssl_clear_cipher_ctx(s);
	}","void SSL_set_accept_state(SSL *s)
	{
	MpegEncContext *s_5;
	int mb_x, mb_y;
	mb_y = s_5->mb_y;
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
	int a = 2;
	int b = 2;
	while (a == b) {
    	ssl_clear_cipher_ctx(s);
    	b += 1;
	}
	}",0,1,12,0.34,Insert
713,,,,,,,
714,,,,,,,
716,"void sha1_final(unsigned char *md, SHACTX c) {
  SHA1_Final(md, c);
  SAFE_FREE(c);
}","void sha1_final(unsigned char *md, SHACTX c) {
  struct ldb_dn *dn;
  dn->ext_comp_num = 0;
  int a = 2;
  int b = 2;
  while (a == b) {
      SHA1_Final(md, c);
      b += 1;
  }
  SAFE_FREE(c);
}",0,1,6,0.24,Insert
717,,,,,,,
718,"const char *crypto_default_geniv(const struct crypto_alg *alg)
{
	if (((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==
	     CRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :
					 alg->cra_ablkcipher.ivsize) !=
	    alg->cra_blocksize)
		return ""chainiv"";
	return alg->cra_flags & CRYPTO_ALG_ASYNC ?
	       ""eseqiv"" : skcipher_default_geniv;
}","const char *crypto_default_geniv(const struct crypto_alg *alg)
{
	if (((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==
	     CRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :
					 alg->cra_ablkcipher.ivsize) !=
	    alg->cra_blocksize)
		int a = 2;
		int b = 2;
		if (a == b) {
    		return ""chainiv"";
		}
	return alg->cra_flags & CRYPTO_ALG_ASYNC ?
	struct sk_buff *skb;
	struct sock *sk;
	struct tcp_sock *tp = tcp_sk(sk);
	u32 length, end64seq;
	struct tcp_sock *tp = tcp_sk(sk);
	u32 length, end64seq;
	SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
	"",
			   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
	length = TCP_SKB_CB(skb)->length;
	       ""eseqiv"" : skcipher_default_geniv;
}",0,1,6,0.3,Insert
719,,,,,,,
720,"void ass_flush_events(ASS_Track *track)
{
    if (track->events) {
        int eid;
        for (eid = 0; eid < track->n_events; eid++)
            ass_free_event(track, eid);
        track->n_events = 0;
    }
    free(track->parser_priv->read_order_bitmap);
    track->parser_priv->read_order_bitmap = NULL;
    track->parser_priv->read_order_elems = 0;
}","void ass_flush_events(ASS_Track *track)
{
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    struct net_bridge *bridge = this->bridge;
    if (!netif_running(bridge->dev) || timer_pending(&this->timer))
    		goto out;
    if (track->events) {
        int eid;
        for (eid = 0; eid < track->n_events; eid++)
            ass_free_event(track, eid);
        track->n_events = 0;
    }
    free(track->parser_priv->read_order_bitmap);
    track->parser_priv->read_order_bitmap = NULL;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        track->parser_priv->read_order_elems = 0;
    strcpy(str, ""a"");
    }
}",0,1,12,0.44,Insert
723,"static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}","static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	kvm_queue_exception(vcpu, UD_VECTOR);
    	int (*compare)(const char *, const char *, size_t);
    	const char *name1;
    	const char *name2;
    	int cmp;
    	unsigned char c1, mc7;
    	cmp = compare(name1, name2, len);
    	c1 = name1[len];
	}
	return 1;
}",0,1,12,0.24,Insert
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    return _data->numYTiles[ly];
}","TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
			    int fd;
			    if (lseek(fd, 512, SEEK_SET) < 0) {
			            goto fail;
			    }
    }
    int a = 5;
    int b = a;
    if(a*b>0){
        return _data->numYTiles[ly];
    }
}",0,1,4,0.33,Insert
726,"inline bool add_gorder_to_list(THD *thd, Item *item, bool asc)
{
  return thd->lex->current_select->add_gorder_to_list(thd, item, asc);
}","inline bool add_gorder_to_list(THD *thd, Item *item, bool asc)
{
  VdpDecoderProfile profile;
  struct hfi1_user_sdma_comp_q *cq;
  u16 idx;
  struct hfi1_user_sdma_pkt_q *pq;
  int ret;
  enum hfi1_sdma_comp_state state;
  cq->comps[idx].status = state;
  trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
  					idx, state, ret);
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderCreate *create;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  void *pack;
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  int a = 2;
  int b = 2;
  while (a == b) {
      return thd->lex->current_select->add_gorder_to_list(thd, item, asc);
      b += 1;
  }
}",0,1,33,0.47,Insert
727,"slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
}","slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    int a = 2;
    uint64_t glms;
    unsigned k, b_8, err, C;
    unsigned k, b_8, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_8 = ctz64(glms);
    int b = 2;
    while (a == b) {
        return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
        b += 1;
    }
}",0,1,3,0.42,Insert
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    int a = 2;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    int b = 2;
    while (a == b) {
        return FALSE;
        b += 1;
    }
}",0,1,14,0.68,Insert
730,,,,,,,
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char str_1[] = ""Constant"";
	if (strlen(str_1) > 0) {
    	char *str = strvec_slot(strvec, 1);
	}
	const struct sun4d_hwdef *hawdecl;
	int ret;
	char data[1024];
	snprintf(data, sizeof(data), ""%s/%s"", bios_dir, bios_name);
	ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",0,1,10,0.44,Insert
732,"static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){
  int rc = sqlite3_reset(pStmt);
  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;
}","static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){
  const char *nptr;
  double vals, mul, integral, fraction;
  char *ndpointer;
  unsigned char c;
  vals = strtod(nptr, &ndpointer);
  c = *ndpointer;
  int a = 2;
  int b = 3;
  while (a < b) {
      int rc = sqlite3_reset(pStmt);
      b = a;
  }
  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;
}",0,1,6,0.31,Insert
735,,,,,,,
738,,,,,,,
739,,,,,,,
741,"bool is_valid_log_name(const char *name, size_t len)
{
  if (len > 3)
  {
    const char *tail= name + len - 4;
    if (my_strcasecmp(system_charset_info, tail, "".ini"") == 0 ||
        my_strcasecmp(system_charset_info, tail, "".cnf"") == 0)
    {
      return false;
    }
  }
  return true;
}","bool is_valid_log_name(const char *name, size_t len)
{
  if (len > 3)
  {
    const char *tail= name + len - 4;
    if (my_strcasecmp(system_charset_info, tail, "".ini"") == 0 ||
        my_strcasecmp(system_charset_info, tail, "".cnf"") == 0)
    {
      char str[] = ""Constant"";
      if (strlen(str) > 0) {
          return false;
      }
    }
  }
  return true;
}",0,1,1,0.09,Replace
742,,,,,,,
746,,,,,,,
749,"	switch (yych) {
		case 'a': goto yy35;
		default: goto yy33;
	}","	switch (yych) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		case 'a': goto yy35;
		}
		default: goto yy33;
	}",1,0,1,0.04,Replace
751,"int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)
{
	return 64;
}","int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)
{
	int a = 2;
	AVCodecContext * avnc;
	MP3On4DecodeContext *this = avnc->priv_data;
	MP3On4DecodeContext *this = avnc->priv_data;
	this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
	avnc->channels = mp3Channels[this->chan_cfg];
	avnc->priv_data = this->mp3decctx[0];
	decode_init(avnc);
	avnc->priv_data = this;
	int b = 3;
	while (a != b) {
    	return 64;
    	b = a;
	}
}",0,1,3,0.25,Insert
753,"static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}","static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      H264Context *h_1;
      MpegEncContext * const s = &h_1->s;
      int contextslimit;
      if(contextslimit)
              execute_decode_slices(h_1, contextslimit);
      return h * ((w * lodepng_get_bpp(color) + 7) / 8);
  }
}",0,1,3,0.27,Insert
754,,,,,,,
759,"TfLiteRegistration* Register_WHILE() {
  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,
                                 while_kernel::Prepare, while_kernel::Eval};
  return &r;
}","TfLiteRegistration* Register_WHILE() {
  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,
                                 while_kernel::Prepare, while_kernel::Eval};
                                 char **names;
                                 char *p;
                                 char *ea_namelist = smallbuf;
                                 size_t num_names;
                                 for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
                                 		names[num_names++] = p;
                                 }
  return &r;
}",0,1,6,0.2,Insert
760,"static int __init pppol2tp_init(void)
{
	int err;
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;
	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int __init pppol2tp_init(void)
{
	QIOChannelSocket *ioc;
	SocketAddressLegacy *localAddr;
	SocketAddressLegacy *remoteAddr;
	Error **err_9;
	int reader;
	trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
	reader = socket_dgram(remoteAddr, localAddr, err_9);
	int err;
	int a = 2;
	int b = 2;
	if (a == b) {
    	err = register_pernet_device(&pppol2tp_net_ops);
	}
	if (err)
		goto out;
	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}",0,1,23,0.65,Insert
762,,,,,,,
763,"uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
}","uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	MachineState *process;
    	MemoryRegion *dram;
    	ram_addr_t ram_size = process->ram_size;
    	memory_region_allocate_system_memory(dram, NULL, ""highbank.dram"", ram_size);
    	highbank_binfo.ram_size = ram_size;
    	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
	strcpy(str, ""a"");
	}
}",0,1,8,0.22,Insert
765,,,,,,,
766,,,,,,,
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	int a = 10;
	int b = a;
	if(a*b>0){
    	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	}
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	AVCodecContext *AVcas;
	VdpStatus status;
	uint32_t input;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	if (status == VDP_STATUS_OK) {
	        hdtx->width  = AVcas->coded_width;
	        hdtx->input = AVcas->coded_height;
	}
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}",0,1,12,0.39,Insert
771,"int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);
	tcp_rate_check_app_limited(sk);   
	return do_tcp_sendpages(sk, page, offset, size, flags);
}","int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);
	tcp_rate_check_app_limited(sk);   
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return do_tcp_sendpages(sk, page, offset, size, flags);
	strcpy(str, ""a"");
	}
}",0,1,1,0.06,Replace
774,,,,,,,
775,"TEST_F(ExpressionFloorTest, IntArg) {
    assertEvaluates(Value(0), Value(0));
    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}","TEST_F(ExpressionFloorTest, IntArg) {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    int a = 43;
    int b = a;
    if(a*b>0){
        assertEvaluates(Value(0), Value(0));
    }
    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}",0,1,11,0.41,Insert
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	int a = 39;
	int b = a;
	if(a*b>0){
    	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	}
	void *memory;
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}",0,1,2,0.08,Replace
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *add(char *label, char *server, char *username, char *secret) {
	struct delegpt* mp;
	struct delegpt_addr* a_1, *o, *ak;
	a_1 = mp->usable_list;
	int a = 2;
	int b = 3;
	while (a < b) {
    	GError *err = NULL;
    	b = a;
	}
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}",0,1,6,0.44,Insert
782,"TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);
  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter,  42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);
  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}","TEST(BasicFlatBufferModel, TestWithNumThreads) {
  int a = 2;
  int b = 3;
  while (a < b) {
      TestErrorReporter reporter;
      b = a;
  }
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);
  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter,  42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);
  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}",0,1,1,0.17,Replace
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		return 0;
		}
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",0,1,4,0.17,Replace
784,"_gdata_service_query (GDataService *self, GDataAuthorizationDomain *domain, const gchar *feed_uri, GDataQuery *query,
                      GCancellable *cancellable, GError **error)
{
	SoupMessage *message;
	guint status;
	const gchar *etag = NULL;
	if (query != NULL)
		etag = gdata_query_get_etag (query);
	if (query != NULL) {
		gchar *query_uri = gdata_query_get_query_uri (query, feed_uri);
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, query_uri, etag, FALSE);
		g_free (query_uri);
	} else {
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, feed_uri, etag, FALSE);
	}
	status = _gdata_service_send_message (self, message, cancellable, error);
	if (status == SOUP_STATUS_NOT_MODIFIED || status == SOUP_STATUS_CANCELLED) {
		g_object_unref (message);
		return NULL;
	} else if (status != SOUP_STATUS_OK) {
		GDataServiceClass *klass = GDATA_SERVICE_GET_CLASS (self);
		g_assert (klass->parse_error_response != NULL);
		klass->parse_error_response (self, GDATA_OPERATION_QUERY, status, message->reason_phrase, message->response_body->data,
		                             message->response_body->length, error);
		g_object_unref (message);
		return NULL;
	}
	return message;
}","_gdata_service_query (GDataService *self, GDataAuthorizationDomain *domain, const gchar *feed_uri, GDataQuery *query,
                      GCancellable *cancellable, GError **error)
{
	SoupMessage *message;
	guint status;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	const gchar *etag = NULL;
	strcpy(str, ""a"");
	}
	if (query != NULL)
		etag = gdata_query_get_etag (query);
	if (query != NULL) {
		gchar *query_uri = gdata_query_get_query_uri (query, feed_uri);
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, query_uri, etag, FALSE);
		g_free (query_uri);
	} else {
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, feed_uri, etag, FALSE);
	}
	status = _gdata_service_send_message (self, message, cancellable, error);
	if (status == SOUP_STATUS_NOT_MODIFIED || status == SOUP_STATUS_CANCELLED) {
		g_object_unref (message);
		return NULL;
	} else if (status != SOUP_STATUS_OK) {
		GDataServiceClass *klass = GDATA_SERVICE_GET_CLASS (self);
		g_assert (klass->parse_error_response != NULL);
		klass->parse_error_response (self, GDATA_OPERATION_QUERY, status, message->reason_phrase, message->response_body->data,
		                             message->response_body->length, error);
		g_object_unref (message);
		return NULL;
	}
	return message;
}",0,1,13,0.26,Replace
786,"MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;
  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);
  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}","MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;
  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);
  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  int a = 4;
  int b = a;
  if(a*b>0){
      return stmt;
      struct delegpt* mp;
      struct delegpt_addr* a_4, *o, *ak;
      a_4 = mp->usable_list;
  }
}",0,1,15,0.43,Insert
788,"static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)
{
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	       sizeof(struct RESTART_TABLE);
}","static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)
{
	struct PCIDevice *pci_dev;
	int r;
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	r = assign_device(Dev);
	r = assign_intx(Dev);
	assigned_dev_load_option_rom(Dev);
	add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	       sizeof(struct RESTART_TABLE);
}",0,1,2,0.15,Insert
789,"DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;
    DefragInit();
    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}","DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;
    DefragInit();
    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
        SCSIDiskState *s;
        SCSIDiskReq *r;
        while (!QTAILQ_EMPTY(&s->qdev.requests)) {
                r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));
                if (r->req.aiocb) {
                    bdrv_aio_cancel(r->req.aiocb);
                }
                scsi_remove_request(r);
        }
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
    ret = 1;
    gchar *str, *str2;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    gst_date_time_unref (dt2);
    dt2 = gst_date_time_new_from_iso8601_string (str);
    fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
    fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
    fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}",1,0,64,0.78,Insert
790,,,,,,,
792,"bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;
	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}
	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;
		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}
	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}","bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;
	if (bucket->elem) {
		if (feature->debug != MagickFalse)
		    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",feature->filename);
		int a = 2;
		int b = 3;
		while (a != b) {
    		VirtIOSerialPort *port;
    		bool discard;
    		assert(port || discard);
    		VirtIOSerialPort *port_8;
    		bool discard_10;
    		assert_4(port_8 || discard_10);
    		do_flush_queued_data_3(port_8, port_8->ovq, &port_8->vser->vdev, discard_10);
    		do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);
    		at = binary_search (bucket->elem, 0, bucket->num, handle);
    		b = a;
		}
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}
	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;
		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}
	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}",1,0,873,5.85,Insert
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  struct f *f;
  int rt;
  if (rt == 1) {
  		ClearPagePrivate(f);
  		set_page_private(f, 0);
  		page_cache_release(f);
  }
  int a = 2;
  int b = 2;
  while (a == b) {
      char *p = (char *)bits;
      b += 1;
  }
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}",0,1,7,0.4,Insert
796,"std::string Box_pitm::dump(Indent& indent) const
{
  std::ostringstream sstr;
  sstr << Box::dump(indent);
  sstr << indent << ""item_ID: "" << m_item_ID << ""\n"";
  return sstr.str();
}","std::string Box_pitm::dump(Indent& indent) const
{
  const char *nptr;
  double vals, mul, integral, fraction;
  char *ndpointer;
  unsigned char c;
  vals = strtod(nptr, &ndpointer);
  c = *ndpointer;
  std::ostringstream sstr;
  sstr << Box::dump(indent);
  sstr << indent << ""item_ID: "" << m_item_ID << ""\n"";
  int a = 2;
  int b = 3;
  while (a < b) {
      return sstr.str();
      b = a;
  }
}",0,1,8,0.32,Insert
798,,,,,,,
800,,,,,,,
801,"void Mounter::umount(const QString &mountPoint, int pid)
{
    if (calledFromDBus()) {
        registerPid(pid);
    }
    if (mpOk(mountPoint)) {
        QProcess *proc=new QProcess(this);
        connect(proc, SIGNAL(finished(int)), SLOT(umountResult(int)));
        proc->start(""umount"", QStringList() << mountPoint);
        proc->setProperty(""mp"", mountPoint);
        proc->setProperty(""pid"", pid);
        procCount++;
    } else {
        emit umountStatus(mountPoint, pid, -1);
    }
}","void Mounter::umount(const QString &mountPoint, int pid)
{
    if (calledFromDBus()) {
        registerPid(pid);
    }
    if (mpOk(mountPoint)) {
        int a = 2;
        TCGv_i64 expr;
        TCGv_i64 tmp;
        tcg_gen_add_i64(expr, expr, tmp);
        int b = 3;
        TCGv_i64 expr_8;
        TCGv_i64 tmp_5;
        tcg_gen_add_i64_6(expr_8, expr_8, tmp_5);
        while (a != b) {
            QProcess *proc=new QProcess(this);
            b = a;
        }
        connect(proc, SIGNAL(finished(int)), SLOT(umountResult(int)));
        proc->start(""umount"", QStringList() << mountPoint);
        proc->setProperty(""mp"", mountPoint);
        proc->setProperty(""pid"", pid);
        procCount++;
    } else {
        emit umountStatus(mountPoint, pid, -1);
    }
}",1,0,51,0.78,Insert
802,"GF_Box *trgt_New()
{
	ISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);
	return (GF_Box *)tmp;
}","GF_Box *trgt_New()
{
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	int a = 48;
	int b = a;
	if(a*b>0){
    	ISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);
	}
	return (GF_Box *)tmp;
}",0,1,6,0.21,Insert
803,,,,,,,
805,"flatpak_context_shared_to_args (FlatpakContextShares shares,
                                FlatpakContextShares valid,
                                GPtrArray           *args)
{
  return flatpak_context_bitmask_to_args (shares, valid, flatpak_context_shares, ""--share"", ""--unshare"", args);
}","flatpak_context_shared_to_args (FlatpakContextShares shares,
                                FlatpakContextShares valid,
                                GPtrArray           *args)
{
  int a = 6;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderCreate *create;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  void *pack;
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  int b = a;
  if(a*b>0){
      return flatpak_context_bitmask_to_args (shares, valid, flatpak_context_shares, ""--share"", ""--unshare"", args);
  }
}",0,1,4,0.33,Insert
808,"static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 old_spte;
	u64 *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		*spte = old_spte;
	}
	return sptep;
}","static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 old_spte;
	u64 *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		int a = 2;
		int b = 3;
		while (a != b) {
    		*spte = old_spte;
    		VdpDecoderProfile profile;
    		AVCodecContext *AVcas;
    		uint32_t input;
    		VdpDecoderQueryCapabilities *decoder_query_caps;
    		uint32_t max_level, max_mb, max_width, max_height;
    		VdpDecoderCreate *create;
    		uint32_t max_level, max_mb, max_width, max_height;
    		VdpStatus status;
    		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    		uint32_t max_level, max_mb, max_width, max_height;
    		uint32_t max_level, max_mb, max_width, max_height;
    		void *pack;
    		VdpBool supported;
    		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    		                                &max_mb, &max_width, &max_height);
    		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    		                                     &pack);
    		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    		                                     &pack);
    		status = create(hdtx->device, profile, width, input, AVcas->refs,
    		                    &hdtx->decoder);
    		b = a;
		}
	}
	return sptep;
}",0,1,14,0.36,Insert
809,,,,,,,
812,,,,,,,
814,,,,,,,
818,,,,,,,
820,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	const char
    	    *attribute,
    	    *content;
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	if (content != (char *) NULL)
    	    table->description=ConstantString(content);
    	encoder->protected_->bits_per_sample = value;
	}
	return true;
}",0,1,12,0.4,Insert
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;
	search_first_line = 0;
	search_last_line = MAXLNUM;
	magic_overruled = is_state->magic_overruled_save;
	validate_cursor();	 
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;
	search_first_line = 0;
	int a = 2;
	int b = 2;
	while (a == b) {
    	search_last_line = MAXLNUM;
    	b += 1;
	}
	magic_overruled = is_state->magic_overruled_save;
	validate_cursor();	 
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
	    sqlite3_context *phpCorptrl;
	    struct CallCount *pb;
	    pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    }
}",0,1,25,0.62,Insert
822,,,,,,,
824,"std::string dump_time_to_str(const real_time& t)
{
  char timestr[TIME_BUF_SIZE];
  dump_time_header_impl(timestr, t);
  return timestr;
}","std::string dump_time_to_str(const real_time& t)
{
  register ssize_t
      i;
  QuantizationTable
      *table;
  ssize_t
      j;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  for (j=i; j < 64; j++)
      table->levels[j]=table->levels[j-1];
  char timestr[TIME_BUF_SIZE];
  int a = 2;
  int b = 3;
  while (a != b) {
      dump_time_header_impl(timestr, t);
      b = a;
  }
  return timestr;
}",0,1,14,0.31,Insert
827,"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
                        int index) {
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->GetTensor(context, node->outputs->data[index]);
  }
}","TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
                        int index) {
  sPAPREnvironment *spapr;
  target_ulong rets;
  struct tm tm;
  qemu_get_timedate(&tm, spapr->rtc_offset);
  sPAPREnvironment *spapr_9;
  target_ulong rets_4;
  struct tm_9 tm_9;
  qemu_get_timedate_5(&tm_9, spapr_9->rtc_offset);
  rtas_st_7(rets_4, 1, tm_9.tm_year + 1900);
  rtas_st_7(rets_4, 2, tm_9.tm_mon + 1);
  rtas_st_7(rets_4, 3, tm_9.tm_mday);
  rtas_st_7(rets_4, 4, tm_9.tm_hour);
  rtas_st(rets, 1, tm.tm_year + 1900);
  rtas_st(rets, 2, tm.tm_mon + 1);
  rtas_st(rets, 3, tm.tm_mday);
  rtas_st(rets, 4, tm.tm_hour);
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    int a = 2;
    int b = 3;
    while (a != b) {
        return context->GetTensor(context, node->outputs->data[index]);
        b = a;
    }
  }
}",1,0,56,0.71,Insert
828,"new_label(codegen_scope *s)
{
  return s->lastlabel = s->pc;
}","new_label(codegen_scope *s)
{
  const char *list_name;
  const struct device_node *np;
  const __be32 **list;
  int *cells_size;
  int size;
  *list = of_get_property(np, list_name, &size);
  *cells_size = pinctrl_find_cells_size(np);
  int a = 2;
  int b = 2;
  while (a == b) {
      return s->lastlabel = s->pc;
      b += 1;
  }
}",0,1,13,0.3,Insert
829,"static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
{
	struct uvesafb_pal_entry *entries;
	int shift = 16 - dac_width;
	int i, err = 0;
	if (info->var.bits_per_pixel == 8) {
		if (cmap->start + cmap->len > info->cmap.start +
		    info->cmap.len || cmap->start < info->cmap.start)
			return -EINVAL;
		entries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);
		if (!entries)
			return -ENOMEM;
		for (i = 0; i < cmap->len; i++) {
			entries[i].red   = cmap->red[i]   >> shift;
			entries[i].green = cmap->green[i] >> shift;
			entries[i].blue  = cmap->blue[i]  >> shift;
			entries[i].pad   = 0;
		}
		err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);
		kfree(entries);
	} else {
		for (i = 0; i < cmap->len; i++) {
			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
						cmap->green[i], cmap->blue[i],
						0, info);
		}
	}
	return err;
}","static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
{
	struct uvesafb_pal_entry *entries;
	int shift = 16 - dac_width;
	int i, err = 0;
	if (info->var.bits_per_pixel == 8) {
		if (cmap->start + cmap->len > info->cmap.start +
		    info->cmap.len || cmap->start < info->cmap.start)
			return -EINVAL;
		entries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);
		if (!entries)
			return -ENOMEM;
		for (i = 0; i < cmap->len; i++) {
			entries[i].red   = cmap->red[i]   >> shift;
			entries[i].green = cmap->green[i] >> shift;
			entries[i].blue  = cmap->blue[i]  >> shift;
			GstDateTime *dt, *dt2;
			dt = gst_date_time_new_now_utc ();
			fail_unless (gst_date_time_has_year (dt));
			fail_unless (gst_date_time_has_month (dt));
			fail_unless (gst_date_time_has_day (dt));
			fail_unless (gst_date_time_has_time (dt));
			entries[i].pad   = 0;
		}
		err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);
		kfree(entries);
	} else {
		for (i = 0; i < cmap->len; i++) {
			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
						cmap->green[i], cmap->blue[i],
						0, info);
		}
	}
	return err;
}",1,0,36,1.22,Insert
830,"  virtual ~Item()
  {
#ifdef EXTRA_DEBUG
    name=0;
#endif
  }		 ","  virtual ~Item()
  {
char **names;
char *p;
char *ea_namelist = smallbuf;
size_t num_names;
for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
		names[num_names++] = p;
}
#ifdef EXTRA_DEBUG
    int a = 47;
    int b = a;
    if(a*b>0){
        name=0;
    }
#endif
  }		 ",0,1,6,0.27,Insert
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	 
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else  
    {
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","frame_add_vsep(frame_T *frp)
{
    	char str[] = ""Constant"";
    	while (strlen(str) > 5) {
        win_T	*wp;
    	strcpy(str, ""a"");
    	}
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	 
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else  
    {
	frp = frp->fr_child;
	int wb;
	uint32_t lvcall;
	CPUState *env;
	unsigned int valpages;
	uint32_t r_cause;
	int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t pid, lo, hi;
	int set, match = 0;
	r_cause = env->sregs[SFR_R_MM_CAUSE];
	D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
			  "" %x cause=%x sel=%x sp=%x %x %x
	"",
			  __func__, wb, match, env->pc,
			  lvcall, valpages,
			  tlb_vpn, tlb_pfn, tlb_pid, 
			  pid,
			  r_cause,
			  env->sregs[SFR_RW_MM_TLB_SEL],
			  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}",0,1,14,0.64,Insert
834,"static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);
	if (!phy)
		return;
	pn533_unregister_device(phy->priv);
	usb_set_intfdata(interface, NULL);
	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);
	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);
	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}","static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);
	if (!phy)
		return;
	pn533_unregister_device(phy->priv);
	usb_set_intfdata(interface, NULL);
	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);
	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	DisasContext *qs;
	uint32_t ksns;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	err = extract32(ksns, 16, 5);
	handle_fp_compare(qs, order, coll, err, false, p);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);
	int a = 2;
	int b = 3;
	while (a < b) {
    	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
    	b = a;
	}
}",0,1,26,0.67,Insert
835,"static void ms_adpcm_reset2 (_AFmoduleinst *i)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) i->modspec;
	int		framesPerBlock;
	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;
	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;
	assert(d->track->nextfframe % framesPerBlock == 0);
}","static void ms_adpcm_reset2 (_AFmoduleinst *i)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) i->modspec;
	int		framesPerBlock;
	int a = 2;
	int b = 3;
	while (a < b) {
    	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;
    	b = a;
	}
	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;
	assert(d->track->nextfframe % framesPerBlock == 0);
}",1,0,2,0.08,Replace
836,"    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {
        WLOG(WS_LOG_SFTP, ""Error with file handle size"");
        res  = err;
        type = WOLFSSH_FTP_FAILURE;
        ret  = WS_BAD_FILE_E;
    }","    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {
        int a = 85;
        gchar *str, *str2;
        GstDateTime *dt, *dt2;
        GstDateTime *dt, *dt2;
        str = gst_date_time_to_iso8601_string (dt);
        dt2 = gst_date_time_new_from_iso8601_string (str);
        fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
        fail_unless (gst_date_time_get_month (dt) == gst_date_time_get_month (dt2));
        fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
        int b = a;
        if(a*b>0){
            WLOG(WS_LOG_SFTP, ""Error with file handle size"");
        }
        res  = err;
        type = WOLFSSH_FTP_FAILURE;
        ret  = WS_BAD_FILE_E;
    }",1,0,13,0.4,Insert
841,,,,,,,
843,,,,,,,
844,,,,,,,
845,,,,,,,
846,,,,,,,
847,"static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;
	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}
	WARN_ON(len & (ISCSI_PAD_LEN - 1));  
	task->hdr_len = exp_len;
	return 0;
}","static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;
	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}
	WARN_ON(len & (ISCSI_PAD_LEN - 1));  
	task->hdr_len = exp_len;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,2,0.1,Replace
849,,,,,,,
851,,,,,,,
852,"const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	return fs ? fs->user_optstr : NULL;
}","const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	Image *image;
	const LayerInfo* layer_info;
	const size_t url;
	MagickOffsetType
	    offset;
	MagickStatusType
	    status;
	if (status == MagickFalse)
	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
	int a = 2;
	int b = 3;
	while (a != b) {
    	return fs ? fs->user_optstr : NULL;
    	b = a;
	}
}",0,1,12,0.3,Insert
853,"onig_set_callout_data_by_callout_args_self(OnigCalloutArgs* args,
                                           int slot, OnigType type, OnigValue* val)
{
  return onig_set_callout_data(args->regex, args->msa->mp, args->num, slot,
                               type, val);
}","onig_set_callout_data_by_callout_args_self(OnigCalloutArgs* args,
                                           int slot, OnigType type, OnigValue* val)
{
  DisplayState *ds;
  const struct sun4d_hwdef *hawdecl;
  ram_addr_t gram_size, prom_reset, tcx64off;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  tcx64off = qemu_ram_alloc(hawdecl->vram_size);
  tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
               hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
  vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                          hawdecl->nvram_size, 8);
  slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                            sbi_cpu_arq, smp_cpus);
  slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                nographic, ESCC_CLOCK, 1);
  return onig_set_callout_data(args->regex, args->msa->mp, args->num, slot,
                               type, val);
}",0,1,13,0.34,Insert
854,"bool con_is_visible(const struct vc_data *vc)
{
	WARN_CONSOLE_UNLOCKED();
	return *vc->vc_display_fg == vc;
}","bool con_is_visible(const struct vc_data *vc)
{
	files_struct *lsp;
	const struct dom_sid *group_sid = NULL;
	TALLOC_CTX *frame = talloc_stackframe();
	struct security_descriptor *psd = NULL;
	const struct dom_sid *owner_sid = NULL;
	struct security_descriptor *parent_desc = NULL;
	struct security_token *token = lsp->conn->session_info->security_token;
	status = se_create_child_secdesc(frame,
				&psd,
				&size,
				parent_desc,
				owner_sid,
				group_sid,
				lsp->is_directory);
	WARN_CONSOLE_UNLOCKED();
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return *vc->vc_display_fg == vc;
	}
}",0,1,30,0.39,Insert
857,"static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}","static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	int nb_iargs;
	TCGContext *service;
	size_t call_stack_size;
	TCGRegSet allocated_regs;
	int rules, nb_regs, ini;
	nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);
	call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);
	tcg_regset_set(allocated_regs, service->reserved_regs);
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}",0,1,8,0.27,Insert
860,"proto_register_kafka(void)
{
    int protocol_handle;
    compute_kafka_api_names();
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);
    proto_kafka = protocol_handle;
}","proto_register_kafka(void)
{
    int protocol_handle;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_2     = s->b_2;
    if (size & 1)
            avio_w8(b_2, 0);
    compute_kafka_api_names();
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);
    int a = 2;
    int b = 2;
    while (a == b) {
        proto_kafka = protocol_handle;
        b += 1;
    }
}",0,1,17,0.37,Insert
863,"_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
{
    Py_ssize_t i;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;
    for (i = 0; i < self->unpickler->memo_size; i++) {
        int status;
        PyObject *key, *value;
        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;
        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (status < 0)
            goto error;
    }
    return new_memo;
error:
    Py_DECREF(new_memo);
    return NULL;
}","_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
{
    Py_ssize_t i;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;
    for (i = 0; i < self->unpickler->memo_size; i++) {
        int status;
        target_ulong rets;
        struct tm tm;
        rtas_st(rets, 5, tm.tm_min);
        rtas_st(rets, 6, tm.tm_sec);
        rtas_st(rets, 7, 0);
        PyObject *key, *value;
        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;
        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (status < 0)
            goto error;
    }
    return new_memo;
error:
    int a = 2;
    int b = 3;
    if (a != b) {
        Py_DECREF(new_memo);
    }
    return NULL;
}",1,0,29,0.8,Insert
864,"stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;
    return make_tok_qstr(NULL, src_get_fname());
}","stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        (void)nparams;
    }
    return make_tok_qstr(NULL, src_get_fname());
}",0,1,3,0.07,Replace
865,"  bool val_native(THD *thd, Native *to)
  {
    return has_value() ? Time(thd, this).to_native(to, decimals) : true;
  }","  bool val_native(THD *thd, Native *to)
  {
    AVCodecContext *AVcas;
    VdpStatus status;
    uint32_t input;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    if (status == VDP_STATUS_OK) {
            hdtx->width  = AVcas->coded_width;
            hdtx->input = AVcas->coded_height;
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        return has_value() ? Time(thd, this).to_native(to, decimals) : true;
        b = a;
    }
  }",0,1,6,0.31,Insert
866,"static void svm_enable_lbrv(struct vcpu_svm *svm)
{
	u32 *msrpm = svm->msrpm;
	svm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);
}","static void svm_enable_lbrv(struct vcpu_svm *svm)
{
	u32 *msrpm = svm->msrpm;
	svm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);
	int a = 2;
	int b = 2;
	while (a == b) {
    	set_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);
    	const char *nptr;
    	double vals, mul, integral, fraction;
    	char *ndpointer;
    	unsigned char c;
    	vals = strtod(nptr, &ndpointer);
    	c = *ndpointer;
    	b += 1;
	}
}",0,1,13,0.33,Insert
868,"file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;
		async_job_end (directory, ""file info"");
	}
}","file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;
		int a = 2;
		int b = 2;
		if (a == b) {
    		async_job_end (directory, ""file info"");
    		const char
    		    *attribute,
    		    *content;
    		QuantizationTable
    		    *table;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		description=GetXMLTreeChild(table_iterator,""description"");
    		table->description=(char *) NULL;
    		content=GetXMLTreeContent(description);
		}
	}
}",0,1,11,0.31,Insert
869,"QPDF::removePage(QPDFObjectHandle page)
{
    int pos = findPage(page);  
    QTC::TC(""qpdf"", ""QPDF remove page"",
            (pos == 0) ? 0 :                             
            (pos == static_cast<int>(
                this->m->all_pages.size() - 1)) ? 1 :    
            2);                                          
    QPDFObjectHandle pages = getRoot().getKey(""/Pages"");
    QPDFObjectHandle kids = pages.getKey(""/Kids"");
    kids.eraseItem(pos);
    int npages = kids.getArrayNItems();
    pages.replaceKey(""/Count"", QPDFObjectHandle::newInteger(npages));
    this->m->all_pages.erase(this->m->all_pages.begin() + pos);
    assert(this->m->all_pages.size() == static_cast<size_t>(npages));
    this->m->pageobj_to_pages_pos.erase(page.getObjGen());
    assert(this->m->pageobj_to_pages_pos.size() == static_cast<size_t>(npages));
    for (int i = pos; i < npages; ++i)
    {
        insertPageobjToPage(this->m->all_pages.at(i), i, false);
    }
}","QPDF::removePage(QPDFObjectHandle page)
{
    int pos = findPage(page);  
    QTC::TC(""qpdf"", ""QPDF remove page"",
            (pos == 0) ? 0 :
            unsigned tsoops_8;
            struct oabi_sembuf __user_4 *tsops_7;
            int i_9;
            struct sembuf *sops_9;
            long or_10;
            for (i_9 = 0; i_9 < tsoops_8; i_9++) {
            		__get_user_error_1(sops_9[i_9].sem_num, &tsops_7->sem_num, or_10);
            		__get_user_error_1(sops_9[i_9].sem_op,  &tsops_7->sem_op,  or_10);
            		__get_user_error_1(sops_9[i_9].sem_flg, &tsops_7->sem_flg, or_10);
            		tsops_7++;
            }                             
            (pos == static_cast<int>(
                this->m->all_pages.size() - 1)) ? 1 :    
            2);                                          
    QPDFObjectHandle pages = getRoot().getKey(""/Pages"");
    QPDFObjectHandle kids = pages.getKey(""/Kids"");
    kids.eraseItem(pos);
    int npages = kids.getArrayNItems();
    int a = 2;
    unsigned tsoops;
    struct oabi_sembuf __user *tsops;
    int i_5;
    struct sembuf *sops;
    long or;
    for (i_5 = 0; i_5 < tsoops; i_5++) {
    		__get_user_error(sops[i_5].sem_num, &tsops->sem_num, or);
    		__get_user_error(sops[i_5].sem_op,  &tsops->sem_op,  or);
    		__get_user_error(sops[i_5].sem_flg, &tsops->sem_flg, or);
    		tsops++;
    }
    int b = 2;
    if (a == b) {
        pages.replaceKey(""/Count"", QPDFObjectHandle::newInteger(npages));
    }
    this->m->all_pages.erase(this->m->all_pages.begin() + pos);
    assert(this->m->all_pages.size() == static_cast<size_t>(npages));
    this->m->pageobj_to_pages_pos.erase(page.getObjGen());
    assert(this->m->pageobj_to_pages_pos.size() == static_cast<size_t>(npages));
    for (int i = pos; i < npages; ++i)
    {
        insertPageobjToPage(this->m->all_pages.at(i), i, false);
    }
}",1,0,269,2.25,Insert
872,"static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;
    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}","static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;
    int a = 2;
    int b = 3;
    if (a != b) {
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
        qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
    }
}",0,1,15,0.36,Insert
873,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;
	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}
	return err;
}","int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	Rocker *r;
	DescInfo *info;
	uint32_t port;
	int err_4 = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err_4 = fp_port_eg(r->fp_port[port], iov, iovcnt);
	int a = 2;
	int b = 3;
	if (a != b) {
    	enum rtrs_clt_state old_state;
	}
	int err = -EBUSY;
	bool changed;
	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}
	return err;
}",0,1,17,0.6,Insert
874,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;
	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));
	border = 2 << sb->s_blocksize_bits;
	while (len > 0) {
		max = ffs(first | border) - 1;
		min = fls(len) - 1;
		if (max < min)
			min = max;
		chunk = 1 << min;
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);
		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct ext4_sb_info *sbi = EXT4_SB(sb);
	strcpy(str, ""a"");
	}
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;
	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));
	border = 2 << sb->s_blocksize_bits;
	while (len > 0) {
		max = ffs(first | border) - 1;
		min = fls(len) - 1;
		if (max < min)
			min = max;
		chunk = 1 << min;
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);
		len -= chunk;
		first += chunk;
	}
}",0,1,2,0.18,Replace
875,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}","int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
	strcpy(str, ""a"");
	}
}",0,1,1,0.06,Replace
878,,,,,,,
879,,,,,,,
881,"inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}","inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	rr->type = (QueryType)((input[0] << 8) + input[1]);
	strcpy(str, ""a"");
	}
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}",0,1,1,0.06,Replace
883,,,,,,,
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}
	return 0;	 
}","static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return be32toh(((uint32_t *)rcblock)[index]);
		strcpy(str, ""a"");
		}
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}
	return 0;	 
}",0,1,10,0.22,Replace
889,,,,,,,
890,"add_update_var_type(regex_t* reg, enum UpdateVarType type)
{
  UpdateVarType t = (UpdateVarType )type;
  BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);
  return 0;
}","add_update_var_type(regex_t* reg, enum UpdateVarType type)
{
  int a = 2;
  PutBitContext pb, pb2;
  JLSState *state;
  int i, size, ure;
  PutBitContext pb, pb2;
  ls_store_lse(state, &pb);
  put_bits(&pb2, 7, 0);
  size = put_bits_count(&pb2);
  flush_put_bits(&pb2);
  avpriv_align_put_bits(&pb);
  int b = 3;
  while (a != b) {
      UpdateVarType t = (UpdateVarType )type;
      b = a;
      DisplayState *ds;
      const struct sun4d_hwdef *hawdecl;
      qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
              *espdma_iraque, *ledma_arquest;
      ram_addr_t gram_size, prom_reset, tcx64off;
      tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                   hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
      escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
                    serial_hds[0], ESCC_CLOCK, 1);
  }
  BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);
  return 0;
}",0,1,37,0.56,Insert
892,,,,,,,
893,"void dev_disable_lro(struct net_device *dev)
{
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);
	dev->wanted_features &= ~NETIF_F_LRO;
	netdev_update_features(dev);
	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}","void dev_disable_lro(struct net_device *dev)
{
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);
	dev->wanted_features &= ~NETIF_F_LRO;
	int a = 81;
	int b = a;
	if(a*b>0){
    	netdev_update_features(dev);
	}
	GetBitContext *db;
	int profile_lengtho, level_idc, constraint_set_flags = 0;
	SPS * spr;
	profile_lengtho           = get_bits(db, 8);
	spr->profile_lengtho          = profile_lengtho;
	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}",0,1,11,0.57,Insert
894,"CopySendString(CopyState cstate, const char *str)
{
	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
}","CopySendString(CopyState cstate, const char *str)
{
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	int a = 2;
	int b = 2;
	while (a == b) {
    	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
    	b += 1;
	}
}",0,1,3,0.3,Insert
897,"        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);
            return 0;
        }","        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            int a = 2;
            int b = 3;
            while (a != b) {
                self->req.method = static_cast<HTTPMethod>(self->method);
                AVCodecContext * avnc;
                MP3On4DecodeContext *this = avnc->priv_data;
                MP3On4DecodeContext *this = avnc->priv_data;
                this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
                avnc->channels = mp3Channels[this->chan_cfg];
                avnc->priv_data = this->mp3decctx[0];
                decode_init(avnc);
                avnc->priv_data = this;
                b = a;
            }
            return 0;
        }",0,1,8,0.36,Insert
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;
    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        int i;
    }
    callbacks++;
    BlockDriverState *btrvt;
    uint8_t cookie[6];
    uint8_t buffer[12];
    sg_io_hdr_t iloappdirector;
    int mem;
    memset(cookie, 0, sizeof(cookie));
    memset(buffer, 0, sizeof(buffer));
    memset(&iloappdirector, 0, sizeof(iloappdirector));
    mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}",0,1,15,0.63,Insert
902,"static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data\n"");
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}","static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		GstDateTime *dt_2, *dt2_2;
		fail_unless_3 (gst_date_time_get_year_6 (dt_2) == 2010);
		fail_unless_3 (!gst_date_time_has_month_7 (dt_2));
		fail_unless_3 (!gst_date_time_has_day_3 (dt_2));
		fail_unless_3 (!gst_date_time_has_time_2 (dt_2));
		gst_date_time_unref_5 (dt_2);
		int a = 2;
		GstDateTime *dt, *dt2;
		fail_unless (gst_date_time_get_year (dt) == 2010);
		fail_unless (!gst_date_time_has_month (dt));
		fail_unless (!gst_date_time_has_day (dt));
		fail_unless (!gst_date_time_has_time (dt));
		gst_date_time_unref (dt);
		int b = 3;
		while (a != b) {
    		return sprintf(buf, ""Data\n"");
    		b = a;
		}
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}",1,0,50,0.66,Insert
904,,,,,,,
906,,,,,,,
907,,,,,,,
908,"static void virtio_serial_register_types(void)
{
    type_register_static(&virtser_bus_info);
    type_register_static(&virtio_serial_port_type_info);
    type_register_static(&virtio_device_info);
}","static void virtio_serial_register_types(void)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        type_register_static(&virtser_bus_info);
        b = a;
    }
    type_register_static(&virtio_serial_port_type_info);
    AVCodecContext *AVcas;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    type_register_static(&virtio_device_info);
}",0,1,9,0.31,Insert
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;
	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;
	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;
	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
		AVCodecContext *AVcas;
		VdpStatus status;
		uint32_t input;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		if (status == VDP_STATUS_OK) {
		        hdtx->width  = AVcas->coded_width;
		        hdtx->input = AVcas->coded_height;
		}
	}
	if (port->type != node_dst->AddrB_port)
		return;
	int a = 2;
	int b = 2;
	if (a == b) {
    	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
	}
}",0,1,15,0.53,Insert
910,"uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            return i;
        }
    }
    return 0xFF;
}","uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                return i;
                unsigned int i_3;
                void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
                int  driver_cache;
                for (i_3 = 0; i_3 < ESP_MAX_DEVS; i_3++) {
                         driver_cache = drive_get_index(IF_SCSI, 0, i_3);
                        if ( driver_cache == -1)
                            continue;
                        esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i_3);
                }
            }
        }
    }
    return 0xFF;
}",0,1,9,0.3,Insert
911,,,,,,,
912,,,,,,,
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;
		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		void *opaques;
    		V9fsPDU *pdf = opaques;
    		V9fsString part;
    		int32_t fpaid, newcids;
    		size_t offset = 7;
    		int32_t fpaid, newcids;
    		pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
    		perf_event_enable_on_exec(ctx);
		}
	}
	rcu_read_unlock();
}",0,1,18,0.33,Insert
915,"  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );
    exit( 1 );
  }","  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    strcpy(str, ""a"");
    }
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );
    exit( 1 );
  }",0,1,11,0.17,Replace
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;
	if (footnotes->count == 0)
		return;
	work = rndr_newbuf(rndr, BUFFER_BLOCK);
	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}
	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct footnote_item *item;
    	b += 1;
	}
	struct footnote_ref *ref;
	if (footnotes->count == 0)
		return;
	work = rndr_newbuf(rndr, BUFFER_BLOCK);
	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}
	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}",0,1,3,0.14,Replace
921,"static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;
	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;
	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}","static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;
	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;
	int a = 2;
	int b = 2;
	if (a == b) {
    	sigandnsets(&s->signal, &s->signal, mask);
	}
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			AVCodecContext *avctx;
			int sample_scale, c, n_2, i;
			int sample_scale, c, n_2, i;
			PCMDecode *s_1 = avctx->priv_data;
			sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
			n_2 = avctx->channels * sample_scale;
			__sigqueue_free(q);
		}
	}
}",0,1,21,0.71,Insert
922,,,,,,,
923,"detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}
	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}
	return(true);
}","detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}
	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return(true);
	}
}",0,1,3,0.18,Replace
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  RCore *model;
  RAnalEsil *esil = model->anal->esil;
  RAnalEsil *esil = model->anal->esil;
  RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
  eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
  "");
  r_anal_esil_session_set (esil, before);
  r_core_esil_step (model, end_5, NULL, &prev, false);
  r_anal_esil_session_set (esil, before);
  r_core_esil_step (model, prev, NULL, NULL, false);
  assert(end_ptr != NULL, ""just checking"");
  int a = 4;
  int b = a;
  if(a*b>0){
      int start = quick_search(methods, name);
  }
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}",0,1,13,0.58,Insert
926,"static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}","static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  BlockdevOnError on_source_bug;
  BlockdevOnError on_source_complete;
  const char *dev;
  enum MirrorSyncMode stage;
  int64_t peed;
  const char *data;
  int data;
  Error *localxer = NULL;
  BlockDriverState *source_vs;
  int64_t store;
  BlockDriverState *bes;
  bes = bdrv_find(dev);
  data = bes->open_flags | BDRV_O_RDWR;
  store = bdrv_getlength(bes);
  backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                   block_job_cb, bes, &localxer);
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}",0,1,8,0.31,Insert
927,"struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	skb_release_all(dst);
	return __skb_clone(dst, src);
}","struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	skb_release_all(dst);
	strcpy(str, ""a"");
	}
	return __skb_clone(dst, src);
}",0,1,3,0.06,Replace
928,"unsigned int ldb_get_flags(struct ldb_context *ldb)
{
	return ldb->flags;
}","unsigned int ldb_get_flags(struct ldb_context *ldb)
{
	int a = 2;
	const char *nptr;
	char *ndpointer;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	int64_t retval;
	double vals, mul, integral, fraction;
	vals = strtod(nptr, &ndpointer);
	fraction = modf(vals, &integral);
	retval = vals * mul;
	int b = 3;
	while (a < b) {
    	return ldb->flags;
    	b = a;
	}
}",0,1,4,0.25,Insert
931,"States& SSL::useStates()
{
    return states_;
}","States& SSL::useStates()
{
    int a = 2;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    int b = 3;
    if (a != b) {
        return states_;
    }
}",0,1,3,0.19,Insert
932,"get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  return get_char_length_tree1(node, reg, len, 0);
}","get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      struct inode *inode;
      wait_queue_head_t *wriq;
      DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
      wriq = bit_waitqueue(&inode->i_state, __I_NEW);
      spin_unlock(&inode->i_lock);
      spin_unlock(&inode_hash_lock);
      spin_lock(&inode_hash_lock);
      return get_char_length_tree1(node, reg, len, 0);
  }
}",0,1,6,0.29,Insert
934,,,,,,,
935,"SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	if (timer_event_spec) {
		sigevent_t event;
		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		return do_timer_create(which_clock, &event, created_timer_id);
	}
	return do_timer_create(which_clock, NULL, created_timer_id);
}","SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	if (timer_event_spec) {
		sigevent_t event;
		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		return do_timer_create(which_clock, &event, created_timer_id);
	}
	int a = 2;
	int b = 3;
	while (a < b) {
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderCreate *create;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	void *pack;
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    	                                     &pack);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
    	return do_timer_create(which_clock, NULL, created_timer_id);
    	b = a;
	}
}",0,1,9,0.62,Insert
937,,,,,,,
941,,,,,,,
944,"static int get_rdrand_seed()
{
    DEBUG_SEED(""get_rdrand_seed"");
    int r;
    while (_rdrand32_step(&r) == 0);
    return r;
}","static int get_rdrand_seed()
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        DEBUG_SEED(""get_rdrand_seed"");
        const char *name1;
        unsigned char c1, mc7;
        c1 = name1[len];
    }
    int r;
    while (_rdrand32_step(&r) == 0);
    return r;
}",0,1,10,0.29,Insert
945,"xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,
				   xmlSchemaTypePtr type)
{
    if (! WXS_IS_UNION(type))
	return(0);
    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,
	type->memberTypes));
}","xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,
				   xmlSchemaTypePtr type)
{
    VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
    uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
    internal_buf->chunk_header.port = VDP_SERVER_PORT;
    internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
    internal_buf->header.protocol = VD_AGENT_PROTOCOL;
    internal_buf->header.type_7 = type_7;
    internal_buf->header.opaque = 0;
    if (! WXS_IS_UNION(type))
	return(0);
    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,
	type->memberTypes));
}",0,1,3,0.22,Insert
950,"static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}","static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct delegpt* mp;
    	struct delegpt_addr* a_4, *o, *ak;
    	a_4 = mp->usable_list;
    	dump_stack();
    	b = a;
	}
}",0,1,4,0.37,Insert
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}
	list_del(&bond->bond_list);
	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
		const EC_POINT *parent;
		const EC_POINT *points[1];
		points[0] = parent;
	}
	AnimationChannel &context;
	json &o;
	SerializeNumberProperty(""sampler"", context.sampler, o);
	SerializeExtensionMap(context.extensions, o);
	list_del(&bond->bond_list);
	int a = 2;
	int b = 2;
	if (a == b) {
    	bond_debug_unregister(bond);
	}
}",0,1,65,1.08,Insert
952,"QString BootDoctor::errorString()
{
    return m_lastErrorString;
}","QString BootDoctor::errorString()
{
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    int a = 2;
    int b = 2;
    while (a == b) {
        return m_lastErrorString;
        b += 1;
    }
}",0,1,4,0.2,Insert
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  double
      value;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  content=GetXMLTreeContent(description);
  content=GetXMLTreeContent(levels);
  value=InterpretLocaleValue(content,&p);
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  int a = 2;
  int b = 3;
  while (a < b) {
      return false;
      b = a;
  }
}",0,1,13,0.46,Insert
958,,,,,,,
959,"uint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {
  return connection_manager_.config_.tracingConfig()->max_path_tag_length_;
}","uint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  int a = 2;
  int b = 3;
  while (a != b) {
      return connection_manager_.config_.tracingConfig()->max_path_tag_length_;
      b = a;
  }
}",0,1,9,0.27,Insert
961,,,,,,,
962,"static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	unsigned int start;
	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
	stats->tx_packets += packets;
	stats->tx_bytes   += bytes;
}","static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	u64 bytes, packets;
	unsigned int start;
	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	stats->tx_packets += packets;
	}
	stats->tx_bytes   += bytes;
}",0,1,15,0.5,Insert
963,,,,,,,
964,"static void __init of_unittest_overlay_0(void)
{
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;
	unittest(1, ""overlay test %d passed\n"", 0);
}","static void __init of_unittest_overlay_0(void)
{
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;
	int a = 2;
	int b = 3;
	while (a < b) {
    	unittest(1, ""overlay test %d passed\n"", 0);
    	b = a;
	}
}",0,1,4,0.22,Insert
970,"is_match_charset(
    FontData	font_data,
    char	*font_name)
{
    char *last;
    int length, name_len;
    name_len = strlen(font_name);
    last = font_name + name_len;
    length = strlen(font_data->name);
    if (length > name_len)
	return False;
    if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)
	return True;
    return False;
}","is_match_charset(
    FontData	font_data,
    char	*font_name)
{
    struct delegpt* mp;
    struct delegpt_addr* a_5, *o, *ak;
    a_5 = mp->usable_list;
    char *last;
    int a = 54;
    int b = a;
    if(a*b>0){
        int length, name_len;
    }
    name_len = strlen(font_name);
    last = font_name + name_len;
    length = strlen(font_data->name);
    if (length > name_len)
	return False;
    if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)
	return True;
    return False;
}",0,1,11,0.55,Insert
971,,,,,,,
973,"my_decimal *Field_temporal::val_decimal(my_decimal *d)
{
  MYSQL_TIME ltime;
  if (get_date(&ltime, 0))
  {
    bzero(&ltime, sizeof(ltime));
    ltime.time_type= mysql_type_to_time_type(type());
  }
  return TIME_to_my_decimal(&ltime, d);
}","my_decimal *Field_temporal::val_decimal(my_decimal *d)
{
  MYSQL_TIME ltime;
  if (get_date(&ltime, 0))
  {
    bzero(&ltime, sizeof(ltime));
    ltime.time_type= mysql_type_to_time_type(type());
  }
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      return TIME_to_my_decimal(&ltime, d);
      CPUState *env;
      const sigset_t *sigset;
      struct kvm_signal_mask * sigmak;
      int r;
      sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
      sigmak->len = 8;
      memcpy( sigmak->sigset, sigset, sizeof(*sigset));
      r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
      free( sigmak);
  }
}",0,1,14,0.34,Insert
974,"oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);
    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}","oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);
    int a = 2;
    int b = 2;
    while (a == b) {
        const char
            *attribute,
            *content;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        if (content != (char *) NULL)
            table->description=ConstantString(content);
        return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
        b += 1;
    }
}",0,1,9,0.49,Insert
975,,,,,,,
977,"    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,
                     CImgDisplay& disp10) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)
        wait_all();","    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,
                     CImgDisplay& disp10) {
      struct super_block *sb;
      unsigned long qf_incum[EXT4_MAXQUOTAS] = {
      		blink::WebURLRequest& quest;
      		ResourceType resource_type = WebURLRequestToResourceType(quest);
      		if (!render_view_->renderer_preferences_.enable_referrers)
      		    quest.SetHTTPReferrer(WebString(),
      		                            network::mojom::ReferrerPolicy::kDefault);
      		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
      		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
      		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
      	};
      sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)
        wait_all();",0,1,32,0.55,Insert
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}
	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
	return 0;
}","static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}
	size_t num_names;
	char *p;
	char *ea_namelist = smallbuf;
	for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen_6(p)+1) {
			num_names += 1;
	}
	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		log_error(""setreuid() didn't work: %s"", strerror(rv));
		}
		return rv;
	}
	return 0;
}",0,1,21,0.53,Insert
982,"static apr_status_t session_identity_encode(request_rec * r, session_rec * z)
{
    char *buffer = NULL;
    int length = 0;
    if (z->expiry) {
        char *expiry = apr_psprintf(z->pool, ""%"" APR_INT64_T_FMT, z->expiry);
        apr_table_setn(z->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do(identity_count, &length, z->entries, NULL);
    buffer = apr_pcalloc(r->pool, length + 1);
    apr_table_do(identity_concat, buffer, z->entries, NULL);
    z->encoded = buffer;
    return OK;
}","static apr_status_t session_identity_encode(request_rec * r, session_rec * z)
{
    char *buffer = NULL;
    int length = 0;
    if (z->expiry) {
        int a = 2;
        int b = 2;
        while (a == b) {
            char *expiry = apr_psprintf(z->pool, ""%"" APR_INT64_T_FMT, z->expiry);
            b += 1;
        }
        apr_table_setn(z->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do(identity_count, &length, z->entries, NULL);
    buffer = apr_pcalloc(r->pool, length + 1);
    apr_table_do(identity_concat, buffer, z->entries, NULL);
    z->encoded = buffer;
    return OK;
}",1,0,1,0.08,Replace
983,,,,,,,
985,,,,,,,
986,,,,,,,
987,"static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;
	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;
	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}","static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;
	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;
		int r;
		while (_rdrand32_step(&r) == 0);
	int a = 2;
	int b = 2;
	while (a == b) {
    	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
    	b += 1;
	}
}",0,1,5,0.37,Insert
988,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;
	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
	if (status)
		return;
	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;
	setting = get_unaligned_le16(sent);
	if (hdev->voice_setting == setting)
		return;
	hdev->voice_setting = setting;
	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;
	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
	if (status)
		return;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	strcpy(str, ""a"");
	}
	if (!sent)
		return;
	setting = get_unaligned_le16(sent);
	if (hdev->voice_setting == setting)
		return;
	hdev->voice_setting = setting;
	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status_9;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status_9 = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status_9 = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status_9 = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status_9 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status_9 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}",0,1,18,0.64,Insert
993,"leave_sysex(int dev)
{
	int             orig_dev = synth_devs[dev]->midi_dev;
	int             timeout = 0;
	if (!sysex_state[dev])
		return;
	sysex_state[dev] = 0;
	while (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&
	       timeout < 1000)
		timeout++;
	sysex_state[dev] = 0;
}","leave_sysex(int dev)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int             orig_dev = synth_devs[dev]->midi_dev;
	strcpy(str, ""a"");
	}
	int             timeout = 0;
	if (!sysex_state[dev])
		return;
		struct domain_device *dev_5;
		struct asd_sas_port *port;
		struct sas_ha_struct *ha = port->ha;
		if (!dev_5->parent)
				dev_5->port->port_dev = NULL;
			else
				list_del_init(&dev_5->siblings);
	sysex_state[dev] = 0;
	while (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&
	       timeout < 1000)
		timeout++;
	sysex_state[dev] = 0;
}",0,1,12,0.38,Insert
994,"static Token *make_tok_qstr(Token *next, const char *str)
{
    return make_tok_qstr_len(next, str, strlen(str));
}","static Token *make_tok_qstr(Token *next, const char *str)
{
    int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;
    long SX, SY, SW, SH, DX, DY, DW, DH;
    dstH = DH;
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        return make_tok_qstr_len(next, str, strlen(str));
        b_1 = a_1;
    }
}",0,1,13,0.31,Insert
997,"mainloop_get_child_userdata(mainloop_child_t *child)
{
    return child->privatedata;
}","mainloop_get_child_userdata(mainloop_child_t *child)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        return child->privatedata;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
    }
}",0,1,7,0.23,Insert
998,,,,,,,
1001,"static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN;  
		goto out;
	}
	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}
	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}
	rds_send_drop_to(rs, &sin);
out:
	return ret;
}","static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct sockaddr_in sin;
	strcpy(str, ""a"");
	}
	int ret = 0;
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN;  
		goto out;
	}
	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}
	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}
	rds_send_drop_to(rs, &sin);
out:
	return ret;
}",0,1,1,0.14,Replace
1007,,,,,,,
1009,"to_hash(mrb_state *mrb, mrb_value val)
{
  return check_type(mrb, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
}","to_hash(mrb_state *mrb, mrb_value val)
{
  int a = 2;
  int b = 2;
  if (a == b) {
      V9fsPath *fs_path;
      FsContext *FS_path;
      int fd, ret;
      struct handle_data *parent = (struct handle_data *)FS_path->private;
      fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
      return check_type(mrb, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
  }
}",0,1,3,0.22,Insert
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;
	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);
		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;
	spin_lock_bh(&nr_list_lock);
	FDCharDriver *s_7;
	s_7->fd_out = io_channel_from_fd(fd_out);
	fcntl(fd_out, F_SETFL, O_NONBLOCK);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);
		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			goto found;
			strcpy(str, ""a"");
			}
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}",0,1,17,0.54,Insert
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;
	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}
		free(MsInterfaces);
	}
}","static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	UINT32 inum = 0;
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpDecoderCreate *create;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	void *pack;
    	VdpBool supported;
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    	                                     &pack);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    	                                     &pack);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
	}
	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}
		free(MsInterfaces);
	}
}",0,1,7,0.33,Insert
1015,,,,,,,
1016,"static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,
        word32 value)
{
    if (buffer != NULL) {
        c32toa(value, buffer->data + buffer->idx);
        buffer->idx += UINT32_SZ;
    }
}","static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,
        word32 value)
{
    if (buffer != NULL) {
        int a = 2;
        int b = 2;
        while (a == b) {
            c32toa(value, buffer->data + buffer->idx);
            b += 1;
        }
        uint64_t glms;
        unsigned k, b_5, err, C;
        unsigned k, b_5, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_5 = ctz64(glms);
        buffer->idx += UINT32_SZ;
    }
}",0,1,5,0.32,Insert
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(HttpStatusChecker, InvalidExpectedRange) {
  int modifiers;
  DictionaryValue dict;
  dict.SetInteger(""modifiers"", modifiers);
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      auto conf = parseHealthCheckFromV3Yaml(yaml);
  strcpy(str, ""a"");
  }
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",0,1,5,0.67,Insert
1019,"int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;
	dma_resv_assert_held(bo->base.resv);
	if (bo->ttm)
		return 0;
	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;
	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;
	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}
	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;
	return 0;
}","int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;
	dma_resv_assert_held(bo->base.resv);
	if (bo->ttm)
		return 0;
	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;
	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;
	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
    	void *rma = NULL;
    	hwaddr rma_alloc_size;
    	MemoryRegion *sysmem = get_system_memory();
    	MemoryRegion *rma_region;
    	if (rma_alloc_size && rma) {
    	        rma_region = g_new(MemoryRegion, 1);
    	        memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",
    	                                   rma_alloc_size, rma);
    	        vmstate_register_ram_global(rma_region);
    	        memory_region_add_subregion(sysmem, 0, rma_region);
    	}
	}
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;
	return 0;
}",0,1,24,0.62,Insert
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            OPJ_UINT32 l_temp;
        strcpy(str, ""a"");
        }
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",0,1,4,0.11,Replace
1026,"static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;
	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);
	wake_up_interruptible(&vrp->sendq);
}","static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;
	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct edgeport_serial *serial;
    	u8 *data;
    	struct device *dev = &serial->serial->dev->dev;
    	struct device *dev = &serial->serial->dev->dev;
    	int status;
    	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    	dev_dbg_4(dev, ""%s - Unknown
    	"", __func___4);
    	wake_up_interruptible(&vrp->sendq);
	}
}",0,1,7,0.19,Insert
1027,"SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *intern;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	intern = Z_SPLDLLIST_P(getThis());
	RETURN_LONG(intern->flags);
}","SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *intern;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	intern = Z_SPLDLLIST_P(getThis());
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	RETURN_LONG(intern->flags);
	}
}",0,1,5,0.1,Replace
1029,,,,,,,
1030,"  bool isCounterMetricId(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
  }","  bool isCounterMetricId(uint32_t metric_id) {
    const struct dom_sid *alias;
    TALLOC_CTX *mem_stack;
    struct pdb_methods *mut;
    struct dom_sid ** pmemrooms;
    struct ldb_dn *anon;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    unsigned int num_members;
    NTSTATUS obj;
    TALLOC_CTX *mem_context = talloc_new(mem_stack);
    struct dom_sid_buf buf;
    struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    		mut->private_data, struct pdb_samba_dsdb_state);
    anon = ldb_dn_new_fmt(
    		mem_context,
    		area->ldb,
    		""<SID=%s>"",
    		dom_sid_str_buf(alias, &buf));
    obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
    }
  }",0,1,8,0.2,Insert
1031,"int smb_vfs_call_chdir(struct vfs_handle_struct *handle, const char *path)
{
	VFS_FIND(chdir);
	return handle->fns->chdir_fn(handle, path);
}","int smb_vfs_call_chdir(struct vfs_handle_struct *handle, const char *path)
{
	VFS_FIND(chdir);
	int a = 22;
	int b = a;
	if(a*b>0){
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderCreate *create;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	VdpStatus status;
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
    	return handle->fns->chdir_fn(handle, path);
	}
}",0,1,5,0.23,Insert
1035,"void stdp_del(GF_Box *s)
{
	GF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;
	if (ptr == NULL ) return;
	if (ptr->priorities) gf_free(ptr->priorities);
	gf_free(ptr);
}","void stdp_del(GF_Box *s)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	GF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;
	}
	files_struct *lsp;
	const struct dom_sid *group_sid = NULL;
	TALLOC_CTX *frame = talloc_stackframe();
	struct security_descriptor *psd = NULL;
	const struct dom_sid *owner_sid = NULL;
	struct security_descriptor *parent_desc = NULL;
	struct security_token *token = lsp->conn->session_info->security_token;
	status = se_create_child_secdesc(frame,
				&psd,
				&size,
				parent_desc,
				owner_sid,
				group_sid,
				lsp->is_directory);
	if (ptr == NULL ) return;
	if (ptr->priorities) gf_free(ptr->priorities);
	gf_free(ptr);
}",0,1,27,0.5,Insert
1036,"static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);
	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}","static void kvm_cpu_vmxon(u64 addr)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	cr4_set_bits(X86_CR4_VMXE);
    	b = a;
	}
	DisasContext *qs;
	uint32_t ksns;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	order = extract32(ksns, 22, 2);
	handle_fp_compare(qs, order, coll, err, false, p);
	intel_pt_handle_vmx(1);
	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}",0,1,6,0.35,Insert
1037,,,,,,,
1038,"static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI;  
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI;  
  } while (c == 0xff);
  return c;
}","static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  const char *nptr;
  double vals, mul, integral, fraction;
  char *ndpointer;
  unsigned char c_5;
  vals = strtod(nptr, &ndpointer);
  c_5 = *ndpointer;
  int c;
  do
  {
    int a = 2;
    int b = 2;
    while (a == b) {
        c = ReadBlobByte(ifile);
        b += 1;
    }
    if (c == EOF)
      return M_EOI;  
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI;  
  } while (c == 0xff);
  return c;
}",0,1,9,0.6,Insert
1039,"void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}","void xenvif_notify_tx_completion(struct xenvif *vif)
{
	int *got_frame;
	void *data;
	AVPacket *avpkt;
	AVCodecContext *avctx;
	const uint8_t *buf = avpkt->data;
	int buf_index      = 0;
	AVFrame *pict      = data;
	int buf_size       = avpkt->size;
	H264Context *hy     = avctx->priv_data;
	buf_index = decode_nal_units(hy, buf, buf_size);
	assert(pict->buf[0] || !*got_frame);
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}",0,1,9,0.23,Insert
1040,"static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
{
	nfs_delegation_mark_reclaim(clp);
	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
}","static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
{
	nfs_delegation_mark_reclaim(clp);
	int a = 2;
	int b = 2;
	while (a == b) {
    	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
    	OPJ_UINT32 l_extra;
    	OPJ_UINT32 phi;
    	for (i=0;iphip_nphi2pelements;++phi) {
    	                opj_read_bytes(l_source_buffer,&l_extra,2);
    	                l_source_buffer+=sizeof(OPJ_INT16);
    	                *(l_src_pad++) = (OPJ_FLOAT32) l_extra;
    	}
    	b += 1;
	}
}",0,1,16,0.27,Insert
1043,"uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)
{
	return map_id_up(&targ->uid_map, __kuid_val(kuid));
}","uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)
{
	int a = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	int b = 2;
	if (a == b) {
    	return map_id_up(&targ->uid_map, __kuid_val(kuid));
	}
}",0,1,5,0.27,Insert
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct iowarrior *dev = file->private_data;
	strcpy(str, ""a"");
	}
	__poll_t mask = 0;
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",0,1,1,0.11,Replace
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;
  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void free_certs(cert_object_t **certs, int cert_count)
{
  int a = 2;
  int b = 3;
  while (a < b) {
      int i;
      b = a;
      const char *data;
      int data;
      BlockDriver *yrf = NULL;
      Error *localxer = NULL;
      BlockDriverState *source_vs;
      BlockDriverState *bes;
      int  rows;
      data = bes->open_flags | BDRV_O_RDWR;
      rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
  }
  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}",0,1,27,0.74,Insert
1048,"struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	struct hlist_node *h;
	int bkt;
	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));
	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	}
	return add;
}","struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	struct hlist_node *h;
	int bkt;
	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));
	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
		AVPacket *mctx;
		uint8_t *uf8 = NULL;
		GetBitContext gb;
		PutBitContext pb, pb2;
		PutBitContext pb, pb2;
		int i, size, ure;
		size = put_bits_count(&pb2);
		init_get_bits(&gb, uf8, size);
		PutBitContext pb_1, pb2_6;
		int comps;
		put_bits(&pb_1, 16, 8 + comps * 3);
		put_bits(&pb_1, 8, comps);
		put_bits(&pb_1, 16, 6 + comps * 2);
		put_bits(&pb_1, 8, comps);
		put_bits(&pb_1, 8, (comps > 1) ? 1 : 0);
		size -= 7;
		mctx->size   = put_bits_count(&pb) >> 3;
	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		int a = 2;
		int b = 3;
		while (a < b) {
    		add = i40e_add_filter(vsi, macaddr, f->vlan);
    		b = a;
		}
		if (!add)
			return NULL;
	}
	return add;
}",0,1,42,0.88,Insert
1053,"int switch_user(uid_t user, gid_t group) {
    save_egid = getegid();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    return 0;
}","int switch_user(uid_t user, gid_t group) {
    NPIdentifier *Pinc;
    NPIdentifierFindArgs *init;
    if (Pinc)
    	*Pinc = init->ident;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        save_egid = getegid();
    strcpy(str, ""a"");
    }
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    return 0;
}",0,1,10,0.62,Insert
1064,,,,,,,
1065,"void __fastcall TCustomDialog::AddWinControl(TWinControl * Control)
{
  Control->TabOrder = FCount;
  FCount++;
}","void __fastcall TCustomDialog::AddWinControl(TWinControl * Control)
{
  int a = 2;
  int b = 3;
  while (a < b) {
      Control->TabOrder = FCount;
      GF_BitStream *bs;
      GF_Box *s;
      FilePartitionBox *inter = (FilePartitionBox *)s;
      ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
      inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
      inter->packet_payload_size = gf_bs_read_u16(bs);
      inter->FEC_encoding_ID = gf_bs_read_u8(bs);
      inter->FEC_instance_ID = gf_bs_read_u16(bs);
      b = a;
  }
  FCount++;
}",0,1,9,0.27,Insert
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	MACH0_(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	MACH0_(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
		TALLOC_CTX *mem_stack;
		struct pdb_methods *mut;
		struct dom_sid ** pmemrooms;
		struct ldb_dn *anon;
		unsigned int num_members;
		NTSTATUS obj_6;
		TALLOC_CTX *mem_context = talloc_new(mem_stack);
		struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
				mut->private_data, struct pdb_samba_dsdb_state);
		obj_6 = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
	return ret;
}",0,1,11,0.48,Insert
1068,"uint32_t TProtocol::skip_virt(TType type) {
  return ::apache::thrift::protocol::skip(*this, type);
}","uint32_t TProtocol::skip_virt(TType type) {
  const char
      *attribute,
      *content;
  char
      *p,
      *xml;
  double
      value;
  value=InterpretLocaleValue(content,&p);
  (void) value;
  int a = 2;
  int b = 3;
  if (a != b) {
      return ::apache::thrift::protocol::skip(*this, type);
  }
}",0,1,3,0.24,Insert
1069,,,,,,,
1072,"void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;
  my_decimal2decimal(dv, &value.m_decimal);
  decimals= (uint8) value.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}","void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;
  my_decimal2decimal(dv, &value.m_decimal);
  decimals= (uint8) value.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      null_value= 0;
      PutBitContext pb, pb2;
      JLSState *state_7;
      int i, size, ure;
      PutBitContext pb, pb2;
      ls_store_lse(state_7, &pb);
      put_bits(&pb2, 7, 0);
      size = put_bits_count(&pb2);
      flush_put_bits(&pb2);
      avpriv_align_put_bits(&pb);
  }
  fix_type(Item::DECIMAL_ITEM);
}",0,1,17,0.45,Insert
1073,"NOEXPORT int parse_socket_error(CLI *c, const char *text) {
    switch(get_last_socket_error()) {
    case 0:  
#ifndef USE_WIN32
    case EPIPE:  
#endif
    case S_ECONNABORTED:
        s_log(LOG_INFO, ""%s: Socket is closed"", text);
        return 0;
    case S_EINTR:
        s_log(LOG_DEBUG, ""%s: Interrupted by a signal: retrying"", text);
        return 1;
    case S_EWOULDBLOCK:
        s_log(LOG_NOTICE, ""%s: Would block: retrying"", text);
        s_poll_sleep(1, 0);  
        return 1;
#if S_EAGAIN!=S_EWOULDBLOCK
    case S_EAGAIN:
        s_log(LOG_DEBUG,
            ""%s: Temporary lack of resources: retrying"", text);
        return 1;
#endif
#ifdef USE_WIN32
    case S_ECONNRESET:
        if(c->opt->exec_name) {
            s_log(LOG_INFO, ""%s: Socket is closed (exec)"", text);
            return 0;
        }
#endif
    default:
        sockerror(text);
        throw_exception(c, 1);
        return -1;  
    }
}","NOEXPORT int parse_socket_error(CLI *c, const char *text) {
    switch(get_last_socket_error()) {
    case 0:  
#ifndef USE_WIN32
    case EPIPE:  
#endif
    case S_ECONNABORTED:
        s_log(LOG_INFO, ""%s: Socket is closed"", text);
        return 0;
    case S_EINTR:
        int a = 2;
        int b = 3;
        struct list_head *pages_10;
        BUG_ON_2(pages_10 && !list_empty_10(pages_10));
        if (a != b) {
            struct list_head *pages;
            BUG_ON(pages && !list_empty(pages));
            s_log(LOG_DEBUG, ""%s: Interrupted by a signal: retrying"", text);
        }
        return 1;
    case S_EWOULDBLOCK:
        s_log(LOG_NOTICE, ""%s: Would block: retrying"", text);
        s_poll_sleep(1, 0);  
        return 1;
#if S_EAGAIN!=S_EWOULDBLOCK
    case S_EAGAIN:
        s_log(LOG_DEBUG,
            ""%s: Temporary lack of resources: retrying"", text);
        return 1;
#endif
#ifdef USE_WIN32
    case S_ECONNRESET:
        if(c->opt->exec_name) {
            s_log(LOG_INFO, ""%s: Socket is closed (exec)"", text);
            return 0;
        }
#endif
    default:
        sockerror(text);
        throw_exception(c, 1);
        return -1;  
    }
}",1,0,1069,7.47,Insert
1076,,,,,,,
1077,,,,,,,
1078,"header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
	{	psf->header [psf->headindex++] = x ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 32) ;
		psf->header [psf->headindex++] = (x >> 40) ;
		psf->header [psf->headindex++] = (x >> 48) ;
		psf->header [psf->headindex++] = (x >> 56) ;
		} ;
}  ","header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
	{	psf->header [psf->headindex++] = x ;
		psf->header [psf->headindex++] = (x >> 8) ;
		int nr_10;
		VFIOPCIDevice *vdev_1;
		VFIOQuirk *quirk_7;
		QLIST_INSERT_HEAD_6(&vdev_1->bars[nr_10].quirks, quirk_7, next_6);
		trace_vfio_quirk_nvidia_bar0_probe_4(vdev_1->vbasedev.name);
		psf->header [psf->headindex++] = (x >> 16) ;
		int nr;
		VFIOPCIDevice *vdev;
		VFIOQuirk *quirk;
		QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);
		trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);
		psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 32) ;
		psf->header [psf->headindex++] = (x >> 40) ;
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		psf->header [psf->headindex++] = (x >> 48) ;
		}
		psf->header [psf->headindex++] = (x >> 56) ;
		} ;
}  ",1,0,65,1.0,Insert
1081,"bool Smb4KGlobal::onlyForeignMountedShares()
{
  return p->onlyForeignShares;
}","bool Smb4KGlobal::onlyForeignMountedShares()
{
  CPUState *env;
  const sigset_t *sigset;
  struct kvm_signal_mask * sigmak;
  int r;
  sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
  sigmak->len = 8;
  memcpy( sigmak->sigset, sigset, sizeof(*sigset));
  r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
  free( sigmak);
  int a = 2;
  int b = 2;
  if (a == b) {
      return p->onlyForeignShares;
  }
}",0,1,10,0.25,Insert
1082,"lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;
    while (!type->info.uni.count) {
        assert(type->der);  
        type = &type->der->type;
    }
    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }
        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }
        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }
    return ret;
}","lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    unsigned maxpages;
    size_t *start;
    struct iov_iter *i_9;
    unsigned int iter_head, npages;
    unsigned int iter_head, npages;
    size_t capacity;
    data_start(i_9, &iter_head, start);
    capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    struct lys_type *ret = NULL;
    while (!type->info.uni.count) {
        assert(type->der);  
        type = &type->der->type;
    }
    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            }
            if (ret) {
                break;
            }
            continue;
        }
        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }
        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }
    return ret;
}",0,1,24,0.75,Insert
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
    return NULL;","STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        int a = 2;
        int b = 2;
        while (a == b) {
            APEContext *ctx;
            int32_t predictionA, currentA, A, sign;
            APEPredictor *pb = &ctx->predictor;
            currentA = pb->lastA[0];
            pb->lastA[0] = currentA;
            case '\t':       return ""\\t"";
            b += 1;
        }
    }
    return NULL;",0,1,17,0.28,Insert
1086,"R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}","R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	int a = 2;
	int b = 3;
	while (a != b) {
    	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
    	GF_BitStream *bs;
    	GF_Box *s;
    	FilePartitionBox *inter = (FilePartitionBox *)s;
    	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    	inter->packet_payload_size = gf_bs_read_u16(bs);
    	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    	inter->FEC_instance_ID = gf_bs_read_u16(bs);
    	b = a;
	}
}",0,1,11,0.46,Insert
1087,"ses_handle(struct waited *wp, enum wait_event ev, vtim_real now)
{
	struct sess *sp;
	struct pool *pp;
	struct pool_task *tp;
	const struct transport *xp;
	CHECK_OBJ_NOTNULL(wp, WAITED_MAGIC);
	CAST_OBJ_NOTNULL(sp, wp->priv1, SESS_MAGIC);
	CAST_OBJ_NOTNULL(xp, (const void*)wp->priv2, TRANSPORT_MAGIC);
	AN(wp->priv2);
	assert((void *)sp->ws->f == wp);
	wp->magic = 0;
	wp = NULL;
	WS_Release(sp->ws, 0);
	switch (ev) {
	case WAITER_TIMEOUT:
		SES_Delete(sp, SC_RX_TIMEOUT, now);
		break;
	case WAITER_REMCLOSE:
		SES_Delete(sp, SC_REM_CLOSE, now);
		break;
	case WAITER_ACTION:
		pp = sp->pool;
		CHECK_OBJ_NOTNULL(pp, POOL_MAGIC);
		assert(sizeof *tp <= WS_ReserveSize(sp->ws, sizeof *tp));
		tp = (void*)sp->ws->f;
		tp->func = xp->unwait;
		tp->priv = sp;
		if (Pool_Task(pp, tp, TASK_QUEUE_REQ))
			SES_Delete(sp, SC_OVERLOAD, now);
		break;
	case WAITER_CLOSE:
		WRONG(""Should not see WAITER_CLOSE on client side"");
		break;
	default:
		WRONG(""Wrong event in ses_handle"");
	}
}","ses_handle(struct waited *wp, enum wait_event ev, vtim_real now)
{
	struct sess *sp;
	struct pool *pp;
	struct pool_task *tp;
	const struct transport *xp;
	CHECK_OBJ_NOTNULL(wp, WAITED_MAGIC);
	CAST_OBJ_NOTNULL(sp, wp->priv1, SESS_MAGIC);
	CAST_OBJ_NOTNULL(xp, (const void*)wp->priv2, TRANSPORT_MAGIC);
	AN(wp->priv2);
	assert((void *)sp->ws->f == wp);
	wp->magic = 0;
	wp = NULL;
	WS_Release(sp->ws, 0);
	switch (ev) {
	case WAITER_TIMEOUT:
		SES_Delete(sp, SC_RX_TIMEOUT, now);
		break;
	case WAITER_REMCLOSE:
		SES_Delete(sp, SC_REM_CLOSE, now);
		break;
	case WAITER_ACTION:
		pp = sp->pool;
		CHECK_OBJ_NOTNULL(pp, POOL_MAGIC);
		assert(sizeof *tp <= WS_ReserveSize(sp->ws, sizeof *tp));
		tp = (void*)sp->ws->f;
		tp->func = xp->unwait;
		tp->priv = sp;
		if (Pool_Task(pp, tp, TASK_QUEUE_REQ))
			SES_Delete(sp, SC_OVERLOAD, now);
		break;
	case WAITER_CLOSE:
		WRONG(""Should not see WAITER_CLOSE on client side"");
		int a = 2;
		int b = 3;
		while (a < b) {
    		break;
    		b = a;
		}
	default:
		WRONG(""Wrong event in ses_handle"");
	}
}",1,0,14,0.36,Replace
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);
        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            stroke(path, state()->pen);
        strcpy(str, ""a"");
        }
        elementCount -= 32;
        lines += 16;
    }
}",0,1,4,0.1,Replace
1095,"QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    return result;
}","QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        return result;
    }
}",1,0,8,0.19,Replace
1096,,,,,,,
1097,,,,,,,
1098,"static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  signal_connection_thd(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  pthread_mutex_destroy(&cn->query_mutex);
  pthread_cond_destroy(&cn->query_cond);
  pthread_mutex_destroy(&cn->result_mutex);
  pthread_cond_destroy(&cn->result_cond);
}","static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  signal_connection_thd(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  pthread_mutex_destroy(&cn->query_mutex);
  pthread_cond_destroy(&cn->query_cond);
  AVPacket * pk;
  AVFormatContext *s;
  unsigned char rb[5];
  AVCodecParameters *par = s->streams[stream_index]->codecpar;
  AVIOContext *b_8     = s->b_8;
  const int stream_index =  pk->stream_index;
  avi_stream2fourcc(rb, stream_index, par->codec_type);
  avio_write(b_8, rb, 4);
  pthread_mutex_destroy(&cn->result_mutex);
  int a = 2;
  int b = 3;
  while (a != b) {
      pthread_cond_destroy(&cn->result_cond);
      b = a;
  }
}",0,1,18,0.51,Insert
1099,"static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;
	return 0;
}","static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	sock->state = SS_FREE;
	strcpy(str, ""a"");
	}
	return 0;
}",0,1,3,0.08,Replace
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;
    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }
    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;
    return HTP_OK;
}","htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;
    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }
    int a = 98;
    int b = a;
    if(a*b>0){
        tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    }
    struct f2fs_sb_info *sbi;
    int type;
    struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
    if (test_opt(sbi, NOHEAP))
    		dir = ALLOC_RIGHT;
    if (tx->response_message == NULL) return HTP_ERROR;
    return HTP_OK;
}",0,1,7,0.48,Insert
1105,,,,,,,
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
    }
}",0,1,14,0.66,Insert
1107,"PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,
						   const char *name)
{
    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);
}","PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,
						   const char *name)
{
    char str1[] = ""Constant"";
    unsigned maxpages;
    size_t *start;
    struct iov_iter *i;
    unsigned int iter_head, npages;
    unsigned int iter_head, npages;
    size_t capacity;
    npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
    capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);
    }
}",0,1,4,0.28,Insert
1108,"TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  s.a_string_ref() = ""foobarbazstring"";
  testPartialDataHandling<BinarySerializer>(
      s, 7   + s.a_string_ref()->size());
}","TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      TestStruct s;
  }
  s.a_string_ref() = ""foobarbazstring"";
  testPartialDataHandling<BinarySerializer>(
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  uint32_t pport;
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
      s, 7   + s.a_string_ref()->size());
}",0,1,8,0.28,Insert
1110,,,,,,,
1112,,,,,,,
1113,"uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}","uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
#else
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uECC_vli_mmod(result, product, curve->p, curve->num_words);
    }
#endif
}",0,1,9,0.46,Insert
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;
  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;
  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
    strcpy(str, ""a"");
    }
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}",0,1,2,0.13,Replace
1120,"static void nested_svm_nmi(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;
	nested_svm_vmexit(svm);
}","static void nested_svm_nmi(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;
	int a = 2;
	int b = 2;
	if (a == b) {
    	Rocker *r;
    	DescInfo *info;
    	char *buf = desc_get_buf(info, true);
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	char *buf = desc_get_buf(info, true);
    	PCIDevice *dev = PCI_DEVICE(r);
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	uint32_t pport;
    	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    	nested_svm_vmexit(svm);
	}
}",0,1,17,0.32,Insert
1123,,,,,,,
1124,,,,,,,
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
    	struct edgeport_serial *serial;
    	u8 *data;
    	struct device *dev = &serial->serial->dev->dev;
    	struct device *dev = &serial->serial->dev->dev;
    	int status;
    	data = kmalloc(1, GFP_KERNEL);
    	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	}
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}",0,1,15,0.33,Insert
1133,"void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  if( p ) sqlite3ExprDeleteNN(db, p);
}","void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  size_t num_names;
  char *p_7;
  char *ea_namelist = smallbuf;
  for (p_7 = ea_namelist; p_7 - ea_namelist < sizeret; p_7 += strlen(p_7)+1) {
  		num_names += 1;
  }
  bool bool_var = ( p );
  const char *nptr;
  double vals, mul, integral, fraction;
  char *ndpointer;
  unsigned char c;
  vals = strtod(nptr, &ndpointer);
  c = *ndpointer;
  if(bool_var) sqlite3ExprDeleteNN(db, p);
}",0,1,33,0.41,Insert
1135,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;
	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}
	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *vmx)
{
	struct sock *Lister;
	struct vsock_sock *vcatel;
	vcatel = vsock_sk(Lister);
	sock_hold(Lister);
	if (!vmx->nested.vmxon)
		return;
	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
		MpegEncContext *ses;
		MotionEstContext * const k= &ses->me;
		MotionEstContext * const k= &ses->me;
		if(ses->linesize){
		        k->stride  = ses->linesize; 
		        k->uvstride= ses->uvlinesize;
		    }else{
		        k->stride  = 16*ses->mb_width + 32;
		        k->uvstride=  8*ses->mb_width + 16;
		}
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	nested_free_all_saved_vmcss(vmx);
	strcpy(str, ""a"");
	}
}",0,1,46,0.59,Insert
1136,,,,,,,
1137,,,,,,,
1138,,,,,,,
1139,"CURLcode Curl_dupset(struct SessionHandle *dst, struct SessionHandle *src)
{
  CURLcode result = CURLE_OK;
  enum dupstring i;
  dst->set = src->set;
  memset(dst->set.str, 0, STRING_LAST * sizeof(char *));
  for(i=(enum dupstring)0; i< STRING_LAST; i++) {
    result = setstropt(&dst->set.str[i], src->set.str[i]);
    if(result)
      break;
  }
  return result;
}","CURLcode Curl_dupset(struct SessionHandle *dst, struct SessionHandle *src)
{
  CURLcode result = CURLE_OK;
  enum dupstring i;
  dst->set = src->set;
  memset(dst->set.str, 0, STRING_LAST * sizeof(char *));
  for(i=(enum dupstring)0; i< STRING_LAST; i++) {
    result = setstropt(&dst->set.str[i], src->set.str[i]);
    if(result)
      break;
  }
  int a = 2;
  int b = 2;
  if (a == b) {
      return result;
  }
}",1,0,5,0.12,Replace
1140,"ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
	ut64 addr = 0LL;
	struct symbol_t *symbols;
	int i;
	if (!(symbols = MACH0_(get_symbols) (bin))) {
		return 0;
	}
	for (i = 0; !symbols[i].last; i++) {
		if (!strcmp (symbols[i].name, ""_main"")) {
			addr = symbols[i].addr;
			break;
		}
	}
	free (symbols);
	if (!addr && bin->main_cmd.cmd == LC_MAIN) {
		addr = bin->entry + bin->baddr;
	}
	if (!addr) {
		ut8 b[128];
		ut64 entry = addr_to_offset(bin, bin->entry);
		if (entry > bin->size || entry + sizeof (b) > bin->size)
			return 0;
		i = r_buf_read_at (bin->b, entry, b, sizeof (b));
		if (i < 1) {
			return 0;
		}
		for (i = 0; i < 64; i++) {
			if (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {
				int delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);
				return bin->entry + i + 5 + delta;
			}
		}
	}
	return addr;
}","ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
	ut64 addr = 0LL;
	struct symbol_t *symbols;
	int i;
	if (!(symbols = MACH0_(get_symbols) (bin))) {
		return 0;
	}
	for (i = 0; !symbols[i].last; i++) {
		if (!strcmp (symbols[i].name, ""_main"")) {
			addr = symbols[i].addr;
			SelectDest *pDest;
			Select *p;
			assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );
			assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );
			assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );
			assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );
			break;
		}
	}
	free (symbols);
	if (!addr && bin->main_cmd.cmd == LC_MAIN) {
		addr = bin->entry + bin->baddr;
	}
	if (!addr) {
		ut8 b[128];
		ut64 entry = addr_to_offset(bin, bin->entry);
		if (entry > bin->size || entry + sizeof (b) > bin->size)
			return 0;
		i = r_buf_read_at (bin->b, entry, b, sizeof (b));
		if (i < 1) {
			return 0;
		}
		for (i = 0; i < 64; i++) {
			if (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {
				int delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);
				return bin->entry + i + 5 + delta;
			}
		}
	}
	return addr;
}",1,0,52,1.62,Insert
1142,"static void __exit alsa_pcm_oss_exit(void)
{
	snd_pcm_notify(&snd_pcm_oss_notify, 1);
}","static void __exit alsa_pcm_oss_exit(void)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct PCIDevice *pci_dev;
    	Error *local_ = NULL;
    	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    	if (assigned_device_pci_cap_init(pci_dev, &local_) < 0) {
    	        qerror_report_err(local_);
    	        error_free(local_);
    	        goto out;
    	}
    	snd_pcm_notify(&snd_pcm_oss_notify, 1);
	strcpy(str, ""a"");
	}
}",0,1,4,0.22,Insert
1145,"int is_inside_work_tree(void)
{
	if (inside_work_tree < 0)
		inside_work_tree = is_inside_dir(get_git_work_tree());
	return inside_work_tree;
}","int is_inside_work_tree(void)
{
	enum hfi1_sdma_comp_state state;
	struct hfi1_user_sdma_comp_q *cq;
	u16 idx;
	int ret;
	if (state == ERROR)
			cq->comps[idx].errcode = -ret;
	if (inside_work_tree < 0)
		inside_work_tree = is_inside_dir(get_git_work_tree());
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return inside_work_tree;
	strcpy(str, ""a"");
	}
}",0,1,4,0.19,Insert
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::getPageObjectNum(int page)
{
    char *filename;
    long load_limit, rtas_limit, fw_size;
    if (fw_size < 0) {
            hw_error(""qemu: could not load LPAR rtas '%s'
    "", filename);
            exit(1);
    }
    if ((page < 1) || (page > nPages)) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return 0;
        strcpy(str, ""a"");
        }
    }
    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}",0,1,9,0.35,Insert
1148,"DEFUN (clear_ip_bgp_as_soft_out,
       clear_ip_bgp_as_soft_out_cmd,
       ""clear ip bgp <1-65535> soft out"",
       CLEAR_STR
       IP_STR
       BGP_STR
       ""Clear peers with the AS number\n""
       ""Soft reconfig\n""
       ""Soft reconfig outbound update\n"")
{
  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,
			BGP_CLEAR_SOFT_OUT, argv[0]);
}","DEFUN (clear_ip_bgp_as_soft_out,
       clear_ip_bgp_as_soft_out_cmd,
       ""clear ip bgp <1-65535> soft out"",
       CLEAR_STR
       IP_STR
       BGP_STR
       ""Clear peers with the AS number\n""
       ""Soft reconfig\n""
       ""Soft reconfig outbound update\n"")
{
  int *got_frame;
  void *data;
  AVPacket *avpkt;
  AVCodecContext *avctx;
  const uint8_t *buf = avpkt->data;
  int buf_index      = 0;
  AVFrame *pict      = data;
  int buf_size       = avpkt->size;
  H264Context *hy     = avctx->priv_data;
  buf_index = decode_nal_units(hy, buf, buf_size);
  assert(pict->buf[0] || !*got_frame);
  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,
			BGP_CLEAR_SOFT_OUT, argv[0]);
}",0,1,2,0.25,Insert
1150,,,,,,,
1153,,,,,,,
1160,"ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    if (p != m.grants.begin())
      out << "", "";
    out << *p;
  }
  return out;
}","ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    if (p != m.grants.begin())
      out << "", "";
    int a = 2;
    int b = 2;
    while (a == b) {
        out << *p;
        b += 1;
    }
  }
  return out;
}",0,1,14,0.54,Insert
1161,"current_fixup(struct archive_write_disk *a, const char *pathname)
{
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	return (a->current_fixup);
}","current_fixup(struct archive_write_disk *a, const char *pathname)
{
	AVCodecContext * avnc;
	MP3On4DecodeContext *this = avnc->priv_data;
	MP3On4DecodeContext *this = avnc->priv_data;
	avnc->priv_data = this;
	this->mp3decctx[0]->adu_mode = 1;
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	int a_1 = 94;
	int b_1 = a_1;
	if(a_1*b_1>0){
    	return (a->current_fixup);
	}
}",0,1,3,0.3,Insert
1163,"static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)opaque;
    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
}","static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)opaque;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
    strcpy(str, ""a"");
    }
}",0,1,4,0.07,Replace
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  int a = 2;
  int b = 2;
  while (a == b) {
      _param_3 = align;
      b += 1;
  }
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}",0,1,5,0.08,Replace
1171,,,,,,,
1174,"static int rpmsg_char_init(void)
{
	int ret;
	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}
	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}
	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}
	return ret;
}","static int rpmsg_char_init(void)
{
	int ret;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	}
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}
	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}
	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}
	return ret;
}",0,1,15,0.25,Replace
1175,,,,,,,
1177,"u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;
	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");
	return rc;
}","u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	u8 rc = 0;
	}
	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
	hwaddr array;
	PowerPCCPU *cpu;
	uint64_t request;
	target_ulong pte_index;
	CPUPPCState *viron = &cpu->viron;
	CPUPPCState *viron = &cpu->viron;
	pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
	request = ppc_hash64_start_access(cpu, pte_index);
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");
	return rc;
}",0,1,13,0.4,Insert
1178,,,,,,,
1179,"TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}","TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    target_phys_addr_t base_1;
    SysBusDevice *s_5;
    if (base_1) {
            sysbus_mmio_map_6(s_5, 0, base_1 + MISC_CFG_8);
            sysbus_mmio_map_6(s_5, 1, base_1 + MISC_DIAG_5);
            sysbus_mmio_map_6(s_5, 2, base_1 + MISC_MDM_1);
            sysbus_mmio_map_6(s_5, 3, base_1 + MISC_LEDS_3);
            sysbus_mmio_map_6(s_5, 4, base_1 + MISC_SYS_2);
    }
    written += TPM2B_Marshal(&source->b, buffer, size);
    target_phys_addr_t base;
    SysBusDevice *s;
    if (base) {
            sysbus_mmio_map(s, 0, base + MISC_CFG);
            sysbus_mmio_map(s, 1, base + MISC_DIAG);
            sysbus_mmio_map(s, 2, base + MISC_MDM);
            sysbus_mmio_map(s, 3, base + MISC_LEDS);
            sysbus_mmio_map(s, 4, base + MISC_SYS);
    }
    return written;
}",1,0,64,0.61,Insert
1181,"void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);
        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}","void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        DisplayState *ds;
        const struct sun4d_hwdef *hawdecl;
        ram_addr_t gram_size, prom_reset, tcx64off;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        tcx64off = qemu_ram_alloc(hawdecl->vram_size);
        tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                     hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
        vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                                hawdecl->nvram_size, 8);
        slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                                  sbi_cpu_arq, smp_cpus);
        slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                      nographic, ESCC_CLOCK, 1);
        assert(name);
        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        int a = 2;
        int b = 3;
        while (a != b) {
            u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
            b = a;
        }
}",0,1,13,0.47,Insert
1182,"static void insert_hash(struct audit_chunk *chunk)
{
	struct list_head *list = chunk_hash(chunk->watch.inode);
	list_add_rcu(&chunk->hash, list);
}","static void insert_hash(struct audit_chunk *chunk)
{
	const char
	    *attribute,
	    *content;
	char
	    *p,
	    *xml;
	double
	    value;
	value=InterpretLocaleValue(content,&p);
	(void) value;
	struct list_head *list = chunk_hash(chunk->watch.inode);
	int a = 2;
	int b = 2;
	if (a == b) {
    	list_add_rcu(&chunk->hash, list);
	}
}",0,1,5,0.3,Insert
1183,,,,,,,
1186,"ossl_cipher_block_size(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
}","ossl_cipher_block_size(VALUE self)
{
    struct work_struct *work;
    struct rtrs_clt_path *clt_path;
    clt_path = container_of(to_delayed_work(work), struct rtrs_clt_path,
    				reconnect_dwork);
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
    strcpy(str, ""a"");
    }
}",0,1,7,0.28,Insert
1187,"valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;
    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    return FALSE;
}","valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    int a = 2;
    int b = 2;
    while (a == b) {
        return FALSE;
        b += 1;
    }
}",0,1,14,0.35,Insert
1191,,,,,,,
1193,,,,,,,
1196,"intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;
	FreeBulkInsertState(myState->bistate);
	table_finish_bulk_insert(myState->rel, myState->ti_options);
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}","intorel_shutdown(DestReceiver *self)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	DR_intorel *myState = (DR_intorel *) self;
	}
	FreeBulkInsertState(myState->bistate);
	table_finish_bulk_insert(myState->rel, myState->ti_options);
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpStatus status;
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}",0,1,12,0.24,Insert
1197,,,,,,,
1198,,,,,,,
1203,"ArgParser::argShowEncryptionKey()
{
    o.show_encryption_key = true;
}","ArgParser::argShowEncryptionKey()
{
    int port, is_output, ttl, remote_host;
    char val[1024];
    int port, is_output, ttl, remote_host;
    int port, is_output, ttl, remote_host;
    char hostname[256];
    build_udp_url(val, sizeof(val),
                      hostname, port, remote_host, ttl);
    build_udp_url(val, sizeof(val),
                      hostname, port + 1, remote_host + 1, ttl);
    int a = 2;
    int b = 3;
    while (a != b) {
        o.show_encryption_key = true;
        b = a;
    }
}",0,1,7,0.21,Insert
1204,"int blkid_probe_enable_partitions(blkid_probe pr, int enable)
{
	pr->chains[BLKID_CHAIN_PARTS].enabled = enable;
	return 0;
}","int blkid_probe_enable_partitions(blkid_probe pr, int enable)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	pr->chains[BLKID_CHAIN_PARTS].enabled = enable;
    	const char *fil;
    	AVIOContext *pb;
    	unsigned int base;
    	unsigned char *result = NULL;
    	int ret = 0, probe_size;
    	AVProbeData pd = { fil ? fil : """", NULL, -base };
    	ret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
	}
	return 0;
}",0,1,8,0.24,Insert
1205,"static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}","static int dev_new_index(struct net *net)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	static int ifindex;
	}
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
			const char *nptr;
			double vals, mul, integral, fraction;
			char *ndpointer;
			unsigned char c;
			vals = strtod(nptr, &ndpointer);
			c = *ndpointer;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}",0,1,4,0.33,Insert
1206,,,,,,,
1209,"static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);
                l_src_data+=sizeof(OPJ_INT16);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        const struct hldefinition *hldefinition;
        unsigned int i_1;
        if (hldefinition->console_serial_base) {
                serial_mm_init(hldefinition->console_serial_base, 0, NULL, 115200,
                               serial_hds[i_1], 1);
                i_1++;
        }
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);
                l_src_data+=sizeof(OPJ_INT16);
                char str[] = ""Constant"";
                if (strlen(str) > 0) {
                    *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
                }
        }
}",0,1,16,0.43,Insert
1211,,,,,,,
1212,"static BROTLI_INLINE uint32_t BrotliGetAvailableBits(
    const BrotliBitReader* br) {
  return (BROTLI_64_BITS ? 64 : 32) - br->bit_pos_;
}","static BROTLI_INLINE uint32_t BrotliGetAvailableBits(
struct client_session *c;
int http_status;
struct session_request *sr;
struct mk_list *host_list = &config->hosts;
struct mk_list *sr_list = &c->request_list;
if (http_status > 0) {
        if (!sr->host_conf) {
            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
        }
        mk_request_error(http_status, c, sr);
        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                            NULL, c, sr);
}
    const BrotliBitReader* br) {
  int a = 2;
  int b = 2;
  while (a == b) {
      return (BROTLI_64_BITS ? 64 : 32) - br->bit_pos_;
      b += 1;
  }
}",0,1,3,0.26,Insert
1215,"R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {
	r_return_val_if_fail (cmd && parent && name, NULL);
	return argv_new (cmd, parent, name, cb, help, true);
}","R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	r_return_val_if_fail (cmd && parent && name, NULL);
	int a = 2;
	int b = 3;
	while (a != b) {
    	return argv_new (cmd, parent, name, cb, help, true);
    	b = a;
	}
}",0,1,5,0.51,Insert
1216,,,,,,,
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;
	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;
	return false;
}","static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct sched_dl_entity *dl_se = &p->dl;
	}
	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;
	return false;
}",0,1,17,0.44,Insert
1222,,,,,,,
1224,"void warnf(struct GlobalConfig *config, const char *fmt, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];
    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    va_end(ap);
    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, config->errors);
      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;
        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          cut = WARN_TEXTWIDTH-1;
        (void)fwrite(ptr, cut + 1, 1, config->errors);
        fputs(""\n"", config->errors);
        ptr += cut+1;  
        len -= cut;
      }
      else {
        fputs(ptr, config->errors);
        len = 0;
      }
    }
  }
}","void warnf(struct GlobalConfig *config, const char *fmt, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];
    va_start(ap, fmt);
    char str1[] = ""Constant"";
    struct net_bridge *br_10;
    struct net_bridge_mdb_htable *mdb_10;
    if (mdb_10->old) {
    		spin_unlock_bh_3(&br_10->multicast_lock);
    		rcu_barrier_bh_8();
    		spin_lock_bh_7(&br_10->multicast_lock);
    		WARN_ON_5(mdb_10->old);
    }
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    }
    va_end(ap);
    struct net_bridge *br;
    struct net_bridge_mdb_htable *mdb;
    if (mdb->old) {
    		spin_unlock_bh(&br->multicast_lock);
    		rcu_barrier_bh();
    		spin_lock_bh(&br->multicast_lock);
    		WARN_ON(mdb->old);
    }
    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, config->errors);
      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;
        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          cut = WARN_TEXTWIDTH-1;
        (void)fwrite(ptr, cut + 1, 1, config->errors);
        fputs(""\n"", config->errors);
        ptr += cut+1;  
        len -= cut;
      }
      else {
        fputs(ptr, config->errors);
        len = 0;
      }
    }
  }
}",1,0,114,1.55,Insert
1226,"static void __meminit __init_single_page(struct page *page, unsigned long pfn,
				unsigned long zone, int nid)
{
	mm_zero_struct_page(page);
	set_page_links(page, zone, nid, pfn);
	init_page_count(page);
	page_mapcount_reset(page);
	page_cpupid_reset_last(page);
	INIT_LIST_HEAD(&page->lru);
#ifdef WANT_PAGE_VIRTUAL
	if (!is_highmem_idx(zone))
		set_page_address(page, __va(pfn << PAGE_SHIFT));
#endif
}","static void __meminit __init_single_page(struct page *page, unsigned long pfn,
				unsigned long zone, int nid)
{
	mm_zero_struct_page(page);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	set_page_links(page, zone, nid, pfn);
	strcpy(str, ""a"");
	}
	init_page_count(page);
	page_mapcount_reset(page);
	page_cpupid_reset_last(page);
	INIT_LIST_HEAD(&page->lru);
#ifdef WANT_PAGE_VIRTUAL
	if (!is_highmem_idx(zone))
		set_page_address(page, __va(pfn << PAGE_SHIFT));
		char *filename;
		long load_limit, rtas_limit, fw_size;
		rtas_limit = MIN(spapr->rma_size, 0x80000000);
		spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
		spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
		                                           rtas_limit - spapr->rtas_addr);
#endif
}",0,1,14,0.62,Insert
1227,,,,,,,
1230,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;
	if (!hrtimer_hres_active())
		return;
	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));
	base = &__get_cpu_var(hrtimer_bases);
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);
	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void retrigger_next_event(void *arg)
{
	char str[] = ""Constant"";
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	status = -ENODEV;
	while (strlen(str) > 5) {
    	struct hrtimer_cpu_base *base;
	strcpy(str, ""a"");
	}
	struct timespec realtime_offset;
	unsigned long seq;
	if (!hrtimer_hres_active())
		return;
	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));
	base = &__get_cpu_var(hrtimer_bases);
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);
	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}",0,1,17,0.61,Insert
1235,"static inline void shmem_dir_free(struct page *page)
{
	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
}","static inline void shmem_dir_free(struct page *page)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
    	char *filename;
    	long load_limit, fw_size;
    	if (fw_size <= 0) {
    	        error_report(""Could not load LPAR firmware '%s'"", filename);
    	        exit(1);
    	}
	}
}",0,1,3,0.2,Insert
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	int a = 2;
	int b = 2;
	if (a == b) {
    	return(NULL);
	}
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",1,0,13,0.23,Replace
1239,"get_config_dir_location (void)
{
  static gsize path = 0;
  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
  return (const char *) path;
}","get_config_dir_location (void)
{
  Visitor *inv;
  QObject **output;
  const char *path_7;
  QmpOutputVisitor *quoo = to_qov(inv);
  qmp_output_add_obj(quoo, path_7, *output);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      static gsize path = 0;
  }
  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
  return (const char *) path;
}",0,1,11,0.36,Insert
1241,"void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];
  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);
  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  description=GetXMLTreeChild(table_iterator,""description"");
  levels=GetXMLTreeChild(table_iterator,""levels"");
  attribute=GetXMLTreeAttribute(table_iterator,""slot"");
  char
    modulate[MagickPathExtent + 1];
  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);
  modifyImage();
  GetPPException;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      ModulateImage(image(),modulate,exceptionInfo);
  strcpy(str, ""a"");
  }
  ThrowImageException;
}",0,1,9,0.41,Insert
1242,"int subselect_union_engine::exec()
{
  char const *save_where= thd->where;
  int res= unit->exec();
  thd->where= save_where;
  return res;
}","int subselect_union_engine::exec()
{
  char const *save_where= thd->where;
  int res= unit->exec();
  thd->where= save_where;
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      return res;
      AVCodecContext *avctx;
      int sample_scale, c, n, i;
      int sample_scale, c, n, i;
      PCMDecode *s = avctx->priv_data;
      sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
      n = avctx->channels * sample_scale;
  }
}",0,1,28,0.41,Insert
1244,"static void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)
{
	memset(info, 0, sizeof(*info));
	info->key.tp_dst = htons(dst_port);
}","static void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)
{
	Rocker *r;
	DescInfo *info_4;
	char *buf = desc_get_buf(info_4, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info_4, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info_4));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info_4));
	memset(info, 0, sizeof(*info));
	int a = 2;
	int b = 3;
	while (a != b) {
    	info->key.tp_dst = htons(dst_port);
    	b = a;
	}
}",0,1,5,0.3,Insert
1245,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    SQInteger i=0;while (i<nparams){v->Push(aparams->_values[i]);i++;
}
unsigned char  unch;
struct acm_wb *sth;
sth->buf[sth->len++] =  unch;
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}",0,1,9,0.46,Insert
1247,"double Magick::Image::xResolution(void) const
{
  return(constImage()->resolution.x);
}","double Magick::Image::xResolution(void) const
{
  int a = 2;
  int b = 2;
  ptrdiff_t src_stride;
  ptrdiff_t buf_stride;
  int h;
  int src_y;
  int block_h;
  int w;
  int block_w;
  const uint8_t *src;
  int src_x;
  uint8_t *buf;
  emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                       src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                       hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
  while (a == b) {
      return(constImage()->resolution.x);
      b += 1;
  }
}",0,1,4,0.18,Insert
1248,"ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;
  if (IS_NULL(reg->ops)) return 0;
  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;
    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif
    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;
    default:
      break;
    }
  }
  return total;
}","ops_calc_size_of_string_pool(regex_t* reg)
{
  int a = 2;
  int b = 3;
  while (a < b) {
      int i;
      b = a;
      GF_BitStream *bs;
      GF_Box *s;
      FilePartitionBox *inter = (FilePartitionBox *)s;
      inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
      inter->packet_payload_size = gf_bs_read_u16(bs);
      gf_bs_read_u8(bs);
      inter->FEC_encoding_ID = gf_bs_read_u8(bs);
      inter->FEC_instance_ID = gf_bs_read_u16(bs);
  }
  int total;
  if (IS_NULL(reg->ops)) return 0;
  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;
    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif
    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;
    default:
      break;
    }
  }
  return total;
}",0,1,31,0.9,Insert
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;
	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	fsec = file->f_security;
	strcpy(str, ""a"");
	}
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}",0,1,20,0.3,Replace
1250,"option_was_set(char_u *name)
{
    int idx;
    idx = findoption(name);
    if (idx < 0)	 
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","option_was_set(char_u *name)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int idx;
    }
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    idx = findoption(name);
    if (idx < 0)	 
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}",0,1,8,0.26,Insert
1251,,,,,,,
1252,"static bool hugetlb_cma_page(struct page *page, unsigned int order)
{
	return false;
}","static bool hugetlb_cma_page(struct page *page, unsigned int order)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	int a = 2;
	int b = 3;
	if (a != b) {
    	return false;
	}
}",0,1,6,0.24,Insert
1254,"void Curl_mbedtls_session_free(void *ptr)
{
  mbedtls_ssl_session_free(ptr);
  free(ptr);
}","void Curl_mbedtls_session_free(void *ptr)
{
  int a = 2;
  int b = 3;
  while (a != b) {
      mbedtls_ssl_session_free(ptr);
      b = a;
  }
  int wb;
  uint32_t lvcall;
  CPUState *env;
  unsigned int valpages;
  uint32_t r_cause;
  int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t pid, lo, hi;
  int set, match = 0;
  r_cause = env->sregs[SFR_R_MM_CAUSE];
  D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
  		  "" %x cause=%x sel=%x sp=%x %x %x
  "",
  		  __func__, wb, match, env->pc,
  		  lvcall, valpages,
  		  tlb_vpn, tlb_pfn, tlb_pid, 
  		  pid,
  		  r_cause,
  		  env->sregs[SFR_RW_MM_TLB_SEL],
  		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
  free(ptr);
}",0,1,8,0.3,Insert
1256,"static rsRetVal qqueueChkPersist(qqueue_t *pThis, int nUpdates)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, qqueue);
	assert(nUpdates >= 0);
	if(nUpdates == 0)
		FINALIZE;
	pThis->iUpdsSincePersist += nUpdates;
	if(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {
		qqueuePersist(pThis, QUEUE_CHECKPOINT);
		pThis->iUpdsSincePersist = 0;
	}
finalize_it:
	RETiRet;
}","static rsRetVal qqueueChkPersist(qqueue_t *pThis, int nUpdates)
{
	DEFiRet;
	int a = 2;
	int b = 3;
	while (a != b) {
    	ISOBJ_TYPE_assert(pThis, qqueue);
    	b = a;
	}
	assert(nUpdates >= 0);
	if(nUpdates == 0)
		FINALIZE;
	pThis->iUpdsSincePersist += nUpdates;
	if(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {
		qqueuePersist(pThis, QUEUE_CHECKPOINT);
		pThis->iUpdsSincePersist = 0;
	}
finalize_it:
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	RETiRet;
}",0,1,18,0.37,Insert
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;
    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }
    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        unsigned i, match = 0;
    strcpy(str, ""a"");
    }
    tok_t tok;
    char *token;
    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }
    return match;
}",0,1,1,0.09,Replace
1258,"int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	}","int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	AVPacket * pk;
	AVFormatContext *s;
	int size               =  pk->size;
	AVIOContext *b     = s->b;
	if (size & 1)
	        avio_w8(b, 0);
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 != b_1) {
    	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
    	b_1 = a_1;
	}
	}",0,1,5,0.29,Insert
1259,"HInstruction* HGraphBuilder::BuildLoadKeyedGeneric(HValue* object,
                                                   HValue* key) {
  HValue* context = environment()->LookupContext();
  return new(zone()) HLoadKeyedGeneric(context, object, key);
}","HInstruction* HGraphBuilder::BuildLoadKeyedGeneric(HValue* object,
                                                   HValue* key) {
  int a = 2;
  int b = 3;
  while (a != b) {
      HValue* context = environment()->LookupContext();
      b = a;
  }
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  VdpChromaType type;
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                       &pack);
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                       &pack);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  return new(zone()) HLoadKeyedGeneric(context, object, key);
}",0,1,4,0.29,Insert
1261,"static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    u64 id;
    int st;
    unsigned short op;
    struct blkif_response *resp;
    resp->id        = id;
    resp->operation = op;
    resp->status    = st;
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    int a = 2;
    int b = 3;
    while (a != b) {
        set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
        b = a;
    }
}",0,1,14,0.41,Insert
1262,,,,,,,
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	TEE_Result res;
	strcpy(str, ""a"");
	}
	struct tee_ta_session *sess;
	struct tee_obj *o;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}",0,1,2,0.1,Replace
1264,"static int mem_cgroup_do_precharge(unsigned long count)
{
	int ret = 0;
	int batch_count = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *memcg = mc.to;
	if (mem_cgroup_is_root(memcg)) {
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&memcg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&memcg->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mc.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!batch_count--) {
			batch_count = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &memcg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}","static int mem_cgroup_do_precharge(unsigned long count)
{
	const struct sun4d_hwdef *hawdecl;
	int ret_3;
	char data[1024];
	snprintf(data, sizeof(data), ""%s/%s"", bios_dir, bios_name);
	ret_3 = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
	int ret = 0;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int batch_count = PRECHARGE_COUNT_AT_ONCE;
	strcpy(str, ""a"");
	}
	struct mem_cgroup *memcg = mc.to;
	if (mem_cgroup_is_root(memcg)) {
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&memcg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&memcg->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mc.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!batch_count--) {
			batch_count = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &memcg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}",0,1,27,0.99,Insert
1265,,,,,,,
1266,"void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	qWarning()<<""Bonjour reported browser error ""<< err;
}","void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	RAMBlock *news_work;
    	news_work = g_malloc0(sizeof(*news_work));
    	news_work->err_4 = err_4;
    	news_work->realized = realized;
    	news_work->used_length = size;
    	news_work->max_length = maxlennumber;
    	qWarning()<<""Bonjour reported browser error ""<< err;
	}
}",0,1,4,0.19,Insert
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
		int a_1 = 2;
		int b_1 = 2;
		while (a_1 == b_1) {
    	unsigned char	 *b = skb->tail;
    		b_1 += 1;
		}
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}",1,0,9,0.15,Replace
1276,,,,,,,
1277,"parse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,
               enum ofputil_protocol *usable_protocols OVS_UNUSED)
{
    ofpact_put_CT_CLEAR(ofpacts);
    return NULL;
}","parse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,
               enum ofputil_protocol *usable_protocols OVS_UNUSED)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        ofpact_put_CT_CLEAR(ofpacts);
    }
    return NULL;
}",0,1,8,0.33,Insert
1278,,,,,,,
1280,"sys_var *find_sys_var(THD *thd, const char *str, size_t length)
{
  return find_sys_var_ex(thd, str, length, false, false);
}","sys_var *find_sys_var(THD *thd, const char *str, size_t length)
{
  int a_1 = 2;
  RAMBlock *news_work;
  size = HOST_PAGE_ALIGN(size);
  news_work = g_malloc0(sizeof(*news_work));
  news_work->used_length = size;
  assert(maxlennumber >= size);
  int b_1 = 3;
  if (a_1 != b_1) {
      return find_sys_var_ex(thd, str, length, false, false);
  }
}",0,1,3,0.24,Insert
1281,"S3BootScriptLabelInternal (
  IN        BOOLEAN                        BeforeOrAfter,
  IN OUT    VOID                         **Position OPTIONAL,
  IN        UINT32                         InformationLength,
  IN CONST  CHAR8                          *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptInformation.OpCode     = S3_BOOT_SCRIPT_LIB_LABEL_OPCODE;
  ScriptInformation.Length     = Length;
  ScriptInformation.InformationLength = InformationLength;
  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);
  SyncBootScript (Script);
  return S3BootScriptMoveLastOpcode (BeforeOrAfter, Position);
}","S3BootScriptLabelInternal (
  IN        BOOLEAN                        BeforeOrAfter,
  IN OUT    VOID                         **Position OPTIONAL,
  IN        UINT32                         InformationLength,
  IN CONST  CHAR8                          *Information
  )
{
  UINT8                 Length;
  struct vm_fault *vmf;
  struct vm_area_struct *vma = vmf->vma;
  struct page *page;
  lru_cache_add_active_or_unevictable(page, vma);
  put_page(page);
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptInformation.OpCode     = S3_BOOT_SCRIPT_LIB_LABEL_OPCODE;
  ScriptInformation.Length     = Length;
  ScriptInformation.InformationLength = InformationLength;
  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);
  SyncBootScript (Script);
  return S3BootScriptMoveLastOpcode (BeforeOrAfter, Position);
}",1,0,60,0.8,Insert
1282,,,,,,,
1283,,,,,,,
1285,,,,,,,
1286,,,,,,,
1287,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  }
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}",0,1,1,0.08,Replace
1289,"rsvg_start_metadata (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);
    handler->super.start_element = rsvg_metadata_handler_start;
    handler->super.end_element = rsvg_metadata_handler_end;
}","rsvg_start_metadata (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);
    handler->super.start_element = rsvg_metadata_handler_start;
    int a = 2;
    int b = 2;
    if (a == b) {
        AVPacket * pk;
        AVFormatContext *s;
        const int stream_index =  pk->stream_index;
        int size               =  pk->size;
        AVIOContext *b_10     = s->b_10;
        avio_write(b_10,  pk->data, size);
        handler->super.end_element = rsvg_metadata_handler_end;
    }
}",0,1,14,0.36,Insert
1291,"    static CImg<T> get_load_bmp(std::FILE *const file) {
      return CImg<T>().load_bmp(file);
    }","    static CImg<T> get_load_bmp(std::FILE *const file) {
      int a = 2;
      int b = 3;
      if (a != b) {
          char *filename;
          long load_limit, fw_size;
          if (fw_size <= 0) {
                  error_report(""Could not load LPAR firmware '%s'"", filename);
                  exit(1);
          }
          return CImg<T>().load_bmp(file);
      }
    }",0,1,5,0.23,Insert
1292,,,,,,,
1293,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      int a = 2;
      int b = 3;
      while (a < b) {
          return result_field->val_real() != 0.0;
          b = a;
      }
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
    H264Context *h;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    order = extract32(ksns, 22, 2);
    handle_fp_compare(qs, order, coll, err, false, p);
    MpegEncContext * const s = &h->s;
    int contextslimit;
    if(contextslimit)
            execute_decode_slices(h, contextslimit);
  }
  return val_bool();
}",0,1,45,0.7,Insert
1296,,,,,,,
1297,"  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }","  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                             &pack);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
        set_repertoire_from_charset(collation_arg);
    }
  }",0,1,7,0.28,Insert
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;
		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;
		int a = 53;
		int b = a;
		if(a*b>0){
    		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		}
		return (res) ? false : true;
	}
#endif
	else
	{
		MachineState *machine;
		char *filename;
		MemoryRegion *ram = g_new(MemoryRegion, 1);
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		spapr->icp = xics_system_init(machine,
		                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
		                                               smp_threads),
		                                  XICS_IRQS, &error_fatal);
		memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
		                                         machine->ram_size);
		filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
		spapr->rtas_size = get_image_size(filename);
		spapr->rtas_blob = g_malloc(spapr->rtas_size);
		uint32		i;
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}",0,1,27,0.81,Insert
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *r_str_closer_chr(const char *b, const char *s) {
	int a_1 = 26;
	int b_1 = a_1;
	if(a_1*b_1>0){
    	const char *a;
    	APEContext *ctx;
    	int32_t predictionA, currentA, A, sign;
    	APEPredictor *pb = &ctx->predictor;
    	currentA = pb->lastA[0];
    	pb->lastA[0] = currentA;
	}
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}",0,1,10,0.33,Insert
1300,,,,,,,
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	p = skb_put(skb, 4 + 14);
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0);  
	*(__be32 *)(p + 12) = cpu_to_be32(0);  
	*(__be16 *)(p + 16) = cpu_to_be16(0);  
	p += 18;
	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct sk_buff *skb;
    	b += 1;
	}
	unsigned char *p;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	p = skb_put(skb, 4 + 14);
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0);  
	*(__be32 *)(p + 12) = cpu_to_be32(0);  
	*(__be16 *)(p + 16) = cpu_to_be16(0);  
	p += 18;
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	isdn_net_write_super(lp, skb);
}",0,1,30,0.74,Insert
1304,"bool WebContents::CanOverscrollContent() {
  return false;
}","bool WebContents::CanOverscrollContent() {
  const char
      *attribute,
      *content;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  description=GetXMLTreeChild(table_iterator,""description"");
  table->description=(char *) NULL;
  content=GetXMLTreeContent(description);
  int a = 93;
  int b = a;
  if(a*b>0){
      return false;
  }
}",0,1,5,0.21,Insert
1307,"rsvg_new_node_component_transfer_function (char channel)
{
    RsvgNodeComponentTransferFunc *filter;
    filter = g_new0 (RsvgNodeComponentTransferFunc, 1);
    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION);
    filter->super.free = rsvg_component_transfer_function_free;
    filter->super.set_atts = rsvg_node_component_transfer_function_set_atts;
    filter->function = identity_component_transfer_func;
    filter->nbTableValues = 0;
    filter->channel = channel;
    return (RsvgNode *) filter;
}","rsvg_new_node_component_transfer_function (char channel)
{
    void *frame;
    union tpacket_uhdr hash;
    hash.raw = frame;
    int a = 2;
    int b = 3;
    while (a < b) {
        RsvgNodeComponentTransferFunc *filter;
        b = a;
    }
    filter = g_new0 (RsvgNodeComponentTransferFunc, 1);
    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION);
    filter->super.free = rsvg_component_transfer_function_free;
    filter->super.set_atts = rsvg_node_component_transfer_function_set_atts;
    filter->function = identity_component_transfer_func;
    filter->nbTableValues = 0;
    filter->channel = channel;
    return (RsvgNode *) filter;
}",0,1,19,0.56,Insert
1308,"    inline void getri(int &N, float *lapA, int *IPIV, float* WORK, int &LWORK, int &INFO) {
      sgetri_(&N,lapA,&N,IPIV,WORK,&LWORK,&INFO);
    }","    inline void getri(int &N, float *lapA, int *IPIV, float* WORK, int &LWORK, int &INFO) {
      char str1[] = ""Constant"";
      char str2[] = ""Constant"";
      if (strcmp(str1, str2) == 0) {
          AVCodecContext *avctx;
          int sample_scale, c, n, i;
          int sample_scale, c, n, i;
          PCMDecode *s = avctx->priv_data;
          sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
          n = avctx->channels * sample_scale;
          sgetri_(&N,lapA,&N,IPIV,WORK,&LWORK,&INFO);
      }
    }",0,1,4,0.35,Insert
1311,"ScanLineInputFile::ScanLineInputFile(InputPartData* part)
{
    if (part->header.type() != SCANLINEIMAGE)
        throw IEX_NAMESPACE::ArgExc(""Can't build a ScanLineInputFile from a type-mismatched part."");
    _data = new Data(part->numThreads);
    _streamData = part->mutex;
    _data->memoryMapped = _streamData->is->isMemoryMapped();
    _data->version = part->version;
    initialize(part->header);
    _data->lineOffsets = part->chunkOffsets;
    _data->partNumber = part->partNumber;
    _data->fileIsComplete = true;
}","ScanLineInputFile::ScanLineInputFile(InputPartData* part)
{
    if (part->header.type() != SCANLINEIMAGE)
        throw IEX_NAMESPACE::ArgExc(""Can't build a ScanLineInputFile from a type-mismatched part."");
    _data = new Data(part->numThreads);
    _streamData = part->mutex;
    int a = 2;
    PICTRectangle
        class;
        PICTRectangle
            class_2;
        if ((class_2.left < 0) || (class_2.right < 0) || (class_2.top < 0) ||
              (class_2.bottom < 0) || (class_2.left >= class_2.right) ||
              (class_2.top >= class_2.bottom))
            ThrowPICTException_1(CorruptImageError_2,""ImproperImageHeader"");
    if ((class.left < 0) || (class.right < 0) || (class.top < 0) ||
          (class.bottom < 0) || (class.left >= class.right) ||
          (class.top >= class.bottom))
        ThrowPICTException(CorruptImageError,""ImproperImageHeader"");
    int b = 2;
    if (a == b) {
        _data->memoryMapped = _streamData->is->isMemoryMapped();
    }
    _data->version = part->version;
    initialize(part->header);
    _data->lineOffsets = part->chunkOffsets;
    _data->partNumber = part->partNumber;
    _data->fileIsComplete = true;
}",1,0,92,0.95,Insert
1314,"static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;
#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif
	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}","static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	register unsigned porth = ntohs(port);
    	b = a;
	}
	__be32 addr_fold = addr->ip;
#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
			    VdpDecoderProfile profile;
			    AVCodecContext *AVcas;
			    uint32_t input;
			    VdpDecoderQueryCapabilities *decoder_query_caps;
			    uint32_t max_level, max_mb, max_width, max_height;
			    VdpDecoderCreate *create;
			    uint32_t max_level, max_mb, max_width, max_height;
			    VdpStatus status;
			    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
			    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
			    uint32_t max_level, max_mb, max_width, max_height;
			    uint32_t max_level, max_mb, max_width, max_height;
			    void *pack;
			    VdpBool supported;
			    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
			                                    &max_mb, &max_width, &max_height);
			    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
			                                         &pack);
			    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
			                                         &pack);
			    status = create(hdtx->device, profile, width, input, AVcas->refs,
			                        &hdtx->decoder);
#endif
	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}",0,1,6,0.54,Insert
1316,"int ldb_msg_append_value(struct ldb_message *msg,
			 const char *attr_name,
			 const struct ldb_val *val,
			 int flags)
{
	return ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);
}","int ldb_msg_append_value(struct ldb_message *msg,
			 const char *attr_name,
			 const struct ldb_val *val,
			 int flags)
{
	int a = 2;
	const char *nptr;
	char *ndpointer;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	int64_t retval;
	double vals, mul, integral, fraction;
	vals = strtod(nptr, &ndpointer);
	fraction = modf(vals, &integral);
	retval = vals * mul;
	int b = 3;
	if (a != b) {
    	return ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);
	}
}",0,1,5,0.29,Insert
1319,"HttpTransact::handle_websocket_upgrade_post_remap(State *s) {
  DebugTxn(""http_trans_websocket_upgrade_post_remap"", ""Remap is complete, start websocket upgrade"");
  TRANSACT_RETURN(SM_ACTION_API_POST_REMAP, HttpTransact::handle_websocket_connection);
}","HttpTransact::handle_websocket_upgrade_post_remap(State *s) {
  DebugTxn(""http_trans_websocket_upgrade_post_remap"", ""Remap is complete, start websocket upgrade"");
  int a = 2;
  int b = 3;
  while (a != b) {
      ptrdiff_t src_stride;
      ptrdiff_t buf_stride;
      int h;
      int src_y;
      int block_h;
      int w;
      int block_w;
      const uint8_t *src;
      int src_x;
      uint8_t *buf;
      emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                           src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                           hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
      TRANSACT_RETURN(SM_ACTION_API_POST_REMAP, HttpTransact::handle_websocket_connection);
      b = a;
  }
}",0,1,5,0.27,Insert
1320,,,,,,,
1321,"strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}","strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	int64_t unit;
	unsigned char c;
	double vals, mul, integral, fraction;
	int64_t retval;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	retval = vals * mul;
	int a = 2;
	int b = 2;
	if (a == b) {
    	return J9PORT_SIG_EXCEPTION_RETURN;
	}
}",0,1,3,0.19,Insert
1322,"statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    return;
  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    my_free(ptr, MYF(0));
  }
}","statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  int nb_oargs;
  int nb_iargs;
  const TCGArg * const args;
  TCGContext *service;
  tcg_insn_unit *func_addr;
  func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
  tcg_out_call(service, func_addr);
  if (!stmt)
    return;
  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    int a = 2;
    int b = 2;
    while (a == b) {
        my_free(ptr, MYF(0));
        b += 1;
    }
  }
}",0,1,7,0.42,Insert
1323,"static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;
	return TEE_SUCCESS;
}","static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	o->have_attrs = (1 << type_props->num_type_attrs) - 1;
	strcpy(str, ""a"");
	}
	return TEE_SUCCESS;
}",0,1,2,0.13,Replace
1324,"f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;
    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;
    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}","f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    	int a = 2;
    	int b = 2;
    	while (a == b) {
        buf_T	*buf = curbuf;
        	b += 1;
    	}
    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;
    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    uint64_t glms;
    unsigned k, b_9, err, C;
    unsigned k, b_9, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_9 = ctz64(glms);
    invoke_listeners(buf);
}",0,1,7,0.44,Insert
1325,,,,,,,
1328,"  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.Host();
  }","  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    quantization_tables=NewXMLTree(xml,exception);
    quantization_tables=DestroyXMLTree(quantization_tables);
    headers_.setHost(host_value);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return *headers_.Host();
    }
  }",0,1,5,0.2,Insert
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int a = 2;
	int b = 2;
	if (a == b) {
    	int replen, status;
	}
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}",0,1,1,0.16,Replace
1332,,,,,,,
1333,"xmlBufAddLen(xmlBufPtr buf, size_t len) {
    if ((buf == NULL) || (buf->error))
        return(-1);
    CHECK_COMPAT(buf)
    if (len > (buf->size - buf->use))
        return(-1);
    buf->use += len;
    UPDATE_COMPAT(buf)
    if (buf->size > buf->use)
        buf->content[buf->use] = 0;
    else
        return(-1);
    return(0);
}","xmlBufAddLen(xmlBufPtr buf, size_t len) {
    if ((buf == NULL) || (buf->error))
        return(-1);
    CHECK_COMPAT(buf)
    if (len > (buf->size - buf->use))
        return(-1);
    buf->use += len;
    UPDATE_COMPAT(buf)
    if (buf->size > buf->use)
        buf->content[buf->use] = 0;
    else
        return(-1);
    int a = 2;
    int b = 3;
    while (a < b) {
        return(0);
        b = a;
    }
}",0,1,1,0.1,Replace
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	register ssize_t
	    i_9;
	QuantizationTable
	    *table;
	ssize_t
	    j;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	for (j=i_9; j < 64; j++)
	    table->levels[j]=table->levels[j-1];
	int i;
	for (i=0; i < length; i++) {
		int a = 2;
		int b = 3;
		while (a < b) {
    		out[i] = in[i] ^ xor_with[i];
    		b = a;
		}
	}
}",0,1,6,0.45,Insert
1335,"static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}","static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	int a = 96;
	int b = a;
	struct b43_dmaring *ring_4;
	struct sk_buff *skb_8;
	const struct b43_dma_ops *ops_2 = ring_4->ops_2;
	struct b43_rxhdr_fw4 *rxhdr_9;
	dma_addr_t dmaaddr_1;
	skb_pull_3(skb_8, ring_4->frameoffset);
	b43_rx_4(ring_4->dev, skb_8, rxhdr_9);
	sync_descbuffer_for_device_2(ring_4, dmaaddr_1, ring_4->rx_buffersize);
	if(a*b>0){
    	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
	}
	object->u.dir.index++;
	struct b43_dmaring *ring;
	struct sk_buff *skb;
	const struct b43_dma_ops *ops = ring->ops;
	struct b43_rxhdr_fw4 *rxhdr;
	dma_addr_t dmaaddr;
	skb_pull(skb, ring->frameoffset);
	b43_rx(ring->dev, skb, rxhdr);
	sync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}",1,0,118,1.3,Insert
1337,,,,,,,
1340,,,,,,,
1342,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		abort();
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	val &= (1 << prec) - 1;
	}
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",0,1,7,0.16,Replace
1344,,,,,,,
1345,"GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(ga_state)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }
    return GUEST_FSFREEZE_STATUS_THAWED;
}","GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(ga_state)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
        int (*compare)(const char *, const char *, size_t);
        const char *name1;
        const char *name2;
        int cmp;
        unsigned char c1, mc7;
        cmp = compare(name1, name2, len);
        c1 = name1[len];
    }
    int a = 24;
    int b = a;
    if(a*b>0){
        return GUEST_FSFREEZE_STATUS_THAWED;
    }
}",0,1,9,0.32,Insert
1346,,,,,,,
1349,,,,,,,
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;
	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int port_number = port->port_number;
    	const struct dom_sid *alias;
    	TALLOC_CTX *mem_stack;
    	struct pdb_methods *mut;
    	struct ldb_dn *anon;
    	TALLOC_CTX *mem_context = talloc_new(mem_stack);
    	struct dom_sid_buf buf;
    	struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    			mut->private_data, struct pdb_samba_dsdb_state);
    	NT_STATUS_HAVE_NO_MEMORY(mem_context);
    	anon = ldb_dn_new_fmt(
    			mem_context,
    			area->ldb,
    			""<SID=%s>"",
    			dom_sid_str_buf(alias, &buf));
    	talloc_free(mem_context);
	strcpy(str, ""a"");
	}
	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}",0,1,10,0.51,Insert
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;
	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);
	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;
	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}
	return 0;
}","static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;
	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);
	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;
	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
				    ptrdiff_t src_stride;
				    ptrdiff_t buf_stride;
				    int h;
				    int src_y;
				    int block_h;
				    int w;
				    int block_w;
				    const uint8_t *src;
				    int src_x;
				    uint8_t *buf;
				    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
				                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
				                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
		if (ret)
			return ret;
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	return 0;
	}
}",0,1,17,0.8,Insert
1353,,,,,,,
1357,,,,,,,
1358,,,,,,,
1360,,,,,,,
1361,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}","static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        CPUState *env;
        const sigset_t *sigset;
        struct kvm_signal_mask * sigmak;
        int r;
        sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
        sigmak->len = 8;
        memcpy( sigmak->sigset, sigset, sizeof(*sigset));
        r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
        free( sigmak);
        return s->interrupt_states[lidx].is_asserted;
        b += 1;
    }
}",0,1,8,0.3,Insert
1362,"int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
{
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}","int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
{
	char *filename;
	if (!filename) {
	        error_report(""Could not find LPAR firmware '%s'"", bios_name);
	        exit(1);
	}
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}",0,1,4,0.33,Insert
1363,"EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}","EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  AVCodecContext *AVcas;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  VdpBool supported;
  VdpChromaType type;
  VdpStatus status;
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}",0,1,4,0.24,Insert
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    int a = 2;
    int b = 3;
    while (a < b) {
        int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;
        long SX, SY, SW, SH, DX, DY, DW, DH;
        srcH = SH;
        pp->content_transfer_encoding = NULL;
        b = a;
    }
  }
}",0,1,17,0.77,Insert
1365,"static int count(struct cstate *g, Renode *node)
{
	int min, max, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(g, node->x) * min;
		else if (max < REPINF) n = count(g, node->x) * max + (max - min);
		else n = count(g, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case P_NLA: return count(g, node->x) + 2;
	}
}","static int count(struct cstate *g, Renode *node)
{
	int min, max, n;
	if (!node) return 0;
	switch (node->type) {
	int a = 2;
	int b = 3;
	while (a != b) {
    	default: return 1;
    	b = a;
	}
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(g, node->x) * min;
		else if (max < REPINF) n = count(g, node->x) * max + (max - min);
		else n = count(g, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case P_NLA: return count(g, node->x) + 2;
	}
}",1,0,9,0.21,Replace
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	void *pack;
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		nname = r_str_newf (""%s.%s"", fcnpfx, name);
    		b += 1;
		}
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}",0,1,33,1.11,Insert
1368,"single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}","single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  char str_1[] = ""Constant"";
  while (strlen(str_1) > 5) {
      CMP_FIELD(maskbits);
  strcpy(str_1, ""a"");
  }
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}",0,1,5,0.15,Replace
1369,"gst_date_time_new_now_local_time (void)
{
  return gst_date_time_new_from_g_date_time (g_date_time_new_now_local ());
}","gst_date_time_new_now_local_time (void)
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      unsigned int files;
      struct cgroup_subsys_state *wcs;
      struct css_task_iter *tag;
      memset(tag, 0, sizeof(*tag));
      tag->ss = wcs->ss;
      tag->files = files;
      tag->cset_head = tag->cset_pos;
      css_task_iter_advance(tag);
      return gst_date_time_new_from_g_date_time (g_date_time_new_now_local ());
  strcpy(str, ""a"");
  }
}",0,1,11,0.22,Insert
1371,"static bool StrictUtf8Check(const FieldDescriptor* field) {
  return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
}","static bool StrictUtf8Check(const FieldDescriptor* field) {
  int a = 2;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  VdpChromaType type;
  VdpStatus status;
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  int b = 3;
  while (a != b) {
      return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
      b = a;
  }
}",0,1,5,0.24,Insert
1372,"runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	if (feedbackFdAvailable()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}","runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	int a = 2;
	int b = 3;
	while (a != b) {
    	ev::sig sigquitWatcher(eventLoop);
    	b = a;
	}
	if (feedbackFdAvailable()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}",1,0,10,0.19,Replace
1373,"int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;
	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];
	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);
	cb->args[0] = t;
	return skb->len;
}","int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct neigh_table *tbl;
    	b = a;
	}
	int t, family, s_t;
	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];
	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
						struct tty_struct *reader;
						struct awm *awm = reader->driver_data;
						struct acm_wb *sth;
						struct awm *awm = reader->driver_data;
						if (sth->len == awm->writesize) {
								acm_tty_flush_chars(reader);
								goto overflow;
						}
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);
	cb->args[0] = t;
	return skb->len;
}",0,1,30,0.85,Insert
1374,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;
  if (js.j_jobslots == 0)
    return;
  BLOCK_CHILD (set, oset);
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }
  UNBLOCK_CHILD (oset);
}","mark_all_jobs_as_dead ()
{
  int a = 2;
  int b = 3;
  while (a != b) {
      register int i;
      b = a;
  }
  sigset_t set, oset;
  if (js.j_jobslots == 0)
    return;
  BLOCK_CHILD (set, oset);
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }
      int *got_frame;
      void *data;
      AVPacket *avpkt;
      AVCodecContext *avctx;
      const uint8_t *buf = avpkt->data;
      int buf_index      = 0;
      AVFrame *pict      = data;
      int buf_size       = avpkt->size;
      H264Context *hy     = avctx->priv_data;
      buf_index = decode_nal_units(hy, buf, buf_size);
      assert(pict->buf[0] || !*got_frame);
  UNBLOCK_CHILD (oset);
}",0,1,35,0.68,Insert
1376,"static void jpeg_init_destination(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    Buffer *buffer = &vs->tight.jpeg;
    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}","static void jpeg_init_destination(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    int a = 2;
    vorbis_floor_data *vfu;
    vorbis_floor_data *vfu_1;
    float *func_6;
    vorbis_floor1 *vf_9 = &vfu_1->t1;
    uint16_t floor1_Y_final_9[258];
    int floor1_flag_8[258];
    floor1_flag_8[0] = 1;
    floor1_flag_8[1] = 1;
    ff_vorbis_floor1_render_list_5(vf_9->list, vf_9->x_list_dim, floor1_Y_final_9, floor1_flag_8, vf_9->multiplier, func_6, vf_9->list[1].x);
    float *func;
    vorbis_floor1 *vf = &vfu->t1;
    uint16_t floor1_Y_final[258];
    int floor1_flag[258];
    floor1_flag[0] = 1;
    floor1_flag[1] = 1;
    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, func, vf->list[1].x);
    int b = 3;
    while (a < b) {
        Buffer *buffer = &vs->tight.jpeg;
        b = a;
    }
    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}",1,0,56,0.7,Insert
1377,,,,,,,
1379,"TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();
  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);
  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}","TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      initialize();
  }
  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);
  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}",0,1,1,0.08,Replace
1380,"static void napi_skb_free_stolen_head(struct sk_buff *skb)
{
	skb_dst_drop(skb);
	secpath_reset(skb);
	kmem_cache_free(skbuff_head_cache, skb);","static void napi_skb_free_stolen_head(struct sk_buff *skb)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	skb_dst_drop(skb);
	}
	int ret, linux67boot;
	if (ret < 0) {
	        fprintf(stderr, ""qemu: could not load prom '%s'
	"",
	                bios_name);
	        exit(1);
	}
	secpath_reset(skb);
	kmem_cache_free(skbuff_head_cache, skb);",0,1,5,0.22,Insert
1383,"void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}","void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		return NULL;
		}
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}",0,1,2,0.18,Replace
1386,,,,,,,
1387,"static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}
	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);
	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}","static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}
	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	kvm_rip_write(vcpu, svm->next_rip);
	strcpy(str, ""a"");
	}
	svm_set_interrupt_shadow(vcpu, 0);
}",0,1,2,0.13,Replace
1389,"sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;
	pr_debug(""%s: timer T5 expired\n"", __func__);
	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);
	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;
	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));
	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);
	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}","sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;
	pr_debug(""%s: timer T5 expired\n"", __func__);
	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);
	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;
	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));
			VdpDecoderProfile profile;
			AVCodecContext *AVcas;
			uint32_t input;
			VdpDecoderQueryCapabilities *decoder_query_caps;
			uint32_t max_level, max_mb, max_width, max_height;
			VdpDecoderCreate *create;
			uint32_t max_level, max_mb, max_width, max_height;
			VdpStatus status;
			VDPAUHWContext *hwctx = AVcas->hwaccel_context;
			VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
			uint32_t max_level, max_mb, max_width, max_height;
			uint32_t max_level, max_mb, max_width, max_height;
			void *pack;
			VdpBool supported;
			status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
			                                &max_mb, &max_width, &max_height);
			status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
			                                     &pack);
			status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
			                                     &pack);
			status = create(hdtx->device, profile, width, input, AVcas->refs,
			                    &hdtx->decoder);
	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	int a = 2;
	int b = 2;
	if (a == b) {
    	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);
	}
	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}",0,1,19,0.76,Insert
1391,"bool ldb_dn_replace_components(struct ldb_dn *dn, struct ldb_dn *new_dn)
{
	int i;
	if ( ! ldb_dn_validate(dn) || ! ldb_dn_validate(new_dn)) {
		return false;
	}
	for (i = 0; i < dn->comp_num; i++) {
		LDB_FREE(dn->components[i].name);
		LDB_FREE(dn->components[i].value.data);
		LDB_FREE(dn->components[i].cf_name);
		LDB_FREE(dn->components[i].cf_value.data);
	}
	dn->components = talloc_realloc(dn,
					dn->components,
					struct ldb_dn_component,
					new_dn->comp_num);
	if (dn->components == NULL) {
		ldb_dn_mark_invalid(dn);
		return false;
	}
	dn->comp_num = new_dn->comp_num;
	dn->valid_case = new_dn->valid_case;
	for (i = 0; i < dn->comp_num; i++) {
		dn->components[i] = ldb_dn_copy_component(dn->components, &new_dn->components[i]);
		if (dn->components[i].name == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}
	if (new_dn->linearized == NULL) {
		dn->linearized = NULL;
	} else {
		dn->linearized = talloc_strdup(dn, new_dn->linearized);
		if (dn->linearized == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}
	return true;
}","bool ldb_dn_replace_components(struct ldb_dn *dn, struct ldb_dn *new_dn)
{
	BlockDriverState *fd[MAX_FD];
	floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd);
	int i;
	if ( ! ldb_dn_validate(dn) || ! ldb_dn_validate(new_dn)) {
		return false;
	}
	for (i = 0; i < dn->comp_num; i++) {
		LDB_FREE(dn->components[i].name);
		LDB_FREE(dn->components[i].value.data);
		LDB_FREE(dn->components[i].cf_name);
		LDB_FREE(dn->components[i].cf_value.data);
	}
	dn->components = talloc_realloc(dn,
					dn->components,
					struct ldb_dn_component,
					new_dn->comp_num);
	if (dn->components == NULL) {
		ldb_dn_mark_invalid(dn);
		return false;
	}
	dn->comp_num = new_dn->comp_num;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	dn->valid_case = new_dn->valid_case;
	}
	for (i = 0; i < dn->comp_num; i++) {
		dn->components[i] = ldb_dn_copy_component(dn->components, &new_dn->components[i]);
		if (dn->components[i].name == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}
	if (new_dn->linearized == NULL) {
		dn->linearized = NULL;
	} else {
		dn->linearized = talloc_strdup(dn, new_dn->linearized);
		if (dn->linearized == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}
	return true;
}",0,1,33,1.11,Insert
1394,"GF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;
	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->trackID = gf_bs_read_u32(bs);
	return gf_isom_box_array_read(s, bs);
}","GF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)
{
	int a = 53;
	int b = a;
	if(a*b>0){
    	GF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;
	}
	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->trackID = gf_bs_read_u32(bs);
	BlockDriverState *btrvt;
	uint8_t cookie[6];
	uint8_t buffer[12];
	sg_io_hdr_t iloappdirector;
	int mem;
	memset(cookie, 0, sizeof(cookie));
	memset(buffer, 0, sizeof(buffer));
	memset(&iloappdirector, 0, sizeof(iloappdirector));
	mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
	return gf_isom_box_array_read(s, bs);
}",0,1,15,0.39,Insert
1395,"string to_string(const MaskedIP& m) {
  stringstream ss;
  ss << m;
  return ss.str();
}","string to_string(const MaskedIP& m) {
  bool value;
  Object *src;
  PCMachineState *cms = PC_MACHINE(src);
  cms->vmport = value;
  stringstream ss;
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      ss << m;
  }
  return ss.str();
}",0,1,9,0.25,Insert
1400,"axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}","axfr_rrstream_first(rrstream_t *rs) {
	int a = 94;
	int b = a;
	if(a*b>0){
    	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderCreate *create;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	VdpStatus status;
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
	}
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}",0,1,21,0.7,Insert
1401,,,,,,,
1402,"void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}","void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value_10;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value_10=InterpretLocaleValue(content,&p);
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}",0,1,6,0.33,Insert
1403,"nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}
	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	can_rename = TRUE;
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;
		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));
		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}
	if (!can_rename) {
		return FALSE;
	}
	return file->details->can_rename;
}","nautilus_file_can_rename (NautilusFile *file)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	gboolean can_rename;
    	b = a;
	}
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}
	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
		MachineState *machine;
		char *filename;
		MemoryRegion *ram = g_new(MemoryRegion, 1);
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		spapr->icp = xics_system_init(machine,
		                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
		                                               smp_threads),
		                                  XICS_IRQS, &error_fatal);
		memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
		                                         machine->ram_size);
		filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
		spapr->rtas_size = get_image_size(filename);
		spapr->rtas_blob = g_malloc(spapr->rtas_size);
	}
	can_rename = TRUE;
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;
		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));
		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}
	if (!can_rename) {
		return FALSE;
	}
	return file->details->can_rename;
}",0,1,27,0.83,Insert
1404,,,,,,,
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	file_transfer_t *ft = data;
    	AVPacket *mctx;
    	uint8_t *uf8 = NULL;
    	GetBitContext gb;
    	PutBitContext pb, pb2;
    	PutBitContext pb, pb2;
    	int i, size, ure;
    	size = put_bits_count(&pb2);
    	init_get_bits(&gb, uf8, size);
    	size -= 7;
    	mctx->size   = put_bits_count(&pb) >> 3;
	}
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}",0,1,15,0.48,Insert
1411,"void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;
	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;
	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}
	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);
	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}
	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;
 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);","void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
	                                 aml_name(""CDW1"")));
	aml_append(ifconfig, ifconfig0);
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
	                                 aml_name(""CDW1"")));
	void *hdr;
	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;
	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}
	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	int a = 2;
	int b = 2;
	if (a == b) {
    	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	}
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);
	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}
	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;
 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);",0,1,24,1.13,Insert
1412,,,,,,,
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long lval;
	AUpvgetval(list, i, &lval);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	int a = 2;
	int b = 2;
	while (a == b) {
    	long lval;
    	b += 1;
	}
	BlockDriverState *btrvt;
	uint8_t cookie[6];
	uint8_t buffer[12];
	sg_io_hdr_t iloappdirector;
	int mem;
	memset(cookie, 0, sizeof(cookie));
	memset(buffer, 0, sizeof(buffer));
	memset(&iloappdirector, 0, sizeof(iloappdirector));
	mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
	AUpvgetval(list, i, &lval);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}",0,1,33,0.9,Insert
1416,,,,,,,
1417,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
    struct delegpt* mp;
    struct delegpt_addr* a_4, *o, *ak;
    a_4 = mp->usable_list;
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    int a = 2;
    int b = 2;
    while (a == b) {
        ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
        b += 1;
    }
}",0,1,10,0.41,Insert
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	char *filename;
	long load_limit, rtas_limit, fw_size;
	if (fw_size < 0) {
	        hw_error(""qemu: could not load LPAR rtas '%s'
	"", filename);
	        exit(1);
	}
	u32 ID;
	NodeIDedItem *reg_node;
	bool bool_var = (!sg->id_node);
	if (bool_var) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}",0,1,14,0.32,Insert
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	PutBitContext pb, pb2;
	JLSState *state;
	int i, size, ure;
	PutBitContext pb, pb2;
	ls_store_lse(state, &pb);
	put_bits(&pb2, 7, 0);
	size = put_bits_count(&pb2);
	flush_put_bits(&pb2);
	avpriv_align_put_bits(&pb);
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	int a = 2;
	int b = 3;
	while (a < b) {
    	spin_unlock_irqrestore(&pstr->lock, flags);
    	b = a;
	}
}",0,1,22,0.6,Insert
1426,,,,,,,
1429,,,,,,,
1430,"static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	return;
}","static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return;
    	CPUX86State *session;
    	session = malloc(sizeof(CPUX86State));
    	memset(session, 0, sizeof(CPUX86State));
    	session->fpuc = 0x37f;
    	session->eflags = 0;
	}
}",0,1,6,0.17,Insert
1432,,,,,,,
1433,,,,,,,
1434,,,,,,,
1436,"rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }
  if (BUG(!rend_service_list)) {
    return NULL;
  }
  return rend_service_list;
}","rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
    MachineState *process;
    MemoryRegion *dram;
    MemoryRegion *SysMem;
    ram_addr_t ram_size = process->ram_size;
    MemoryRegion *sysram;
    SysMem = get_system_memory();
    memory_region_allocate_system_memory(dram, NULL, ""highbank.dram"", ram_size);
    memory_region_add_subregion(SysMem, 0, dram);
    memory_region_init_ram(sysram, NULL, ""highbank.sysram"", 0x8000,
                               &error_fatal);
    memory_region_add_subregion(SysMem, 0xfff88000, sysram);
  }
  if (BUG(!rend_service_list)) {
    return NULL;
  }
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return rend_service_list;
  strcpy(str, ""a"");
  }
}",0,1,10,0.26,Insert
1439,"static JSValue js_bs_put_s16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
	return js_bs_put_val(ctx, this_val, argc, argv, 4);
}","static JSValue js_bs_put_s16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	AVPacket *mctx;
    	uint8_t *uf8 = NULL;
    	GetBitContext gb;
    	PutBitContext pb, pb2;
    	PutBitContext pb, pb2;
    	int i, size, ure;
    	size = put_bits_count(&pb2);
    	init_get_bits(&gb, uf8, size);
    	size -= 7;
    	mctx->size   = put_bits_count(&pb) >> 3;
    	return js_bs_put_val(ctx, this_val, argc, argv, 4);
    	b = a;
	}
}",0,1,18,0.41,Insert
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}
	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	const v8::PropertyCallbackInfo<v8::Value>& py;
	from(py.Holder()->CreationContext());
	v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	strcpy(str, ""a"");
	}
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}",0,1,23,0.73,Insert
1442,,,,,,,
1444,"static void cirrus_linear_bitblt_writew(void *opaque, target_phys_addr_t addr,
				 uint32_t val)
{
#ifdef TARGET_WORDS_BIGENDIAN
    cirrus_linear_bitblt_writeb(opaque, addr, (val >> 8) & 0xff);
    cirrus_linear_bitblt_writeb(opaque, addr + 1, val & 0xff);
#else
    cirrus_linear_bitblt_writeb(opaque, addr, val & 0xff);
    cirrus_linear_bitblt_writeb(opaque, addr + 1, (val >> 8) & 0xff);
#endif
}","static void cirrus_linear_bitblt_writew(void *opaque, target_phys_addr_t addr,
				 uint32_t val)
{
#ifdef TARGET_WORDS_BIGENDIAN
    cirrus_linear_bitblt_writeb(opaque, addr, (val >> 8) & 0xff);
    cirrus_linear_bitblt_writeb(opaque, addr + 1, val & 0xff);
#else
    cirrus_linear_bitblt_writeb(opaque, addr, val & 0xff);
    int a = 2;
    int b = 2;
    if (a == b) {
        cirrus_linear_bitblt_writeb(opaque, addr + 1, (val >> 8) & 0xff);
        unsigned maxpages;
        size_t *start;
        struct iov_iter *i;
        unsigned int iter_head, npages;
        unsigned int iter_head, npages;
        size_t capacity;
        data_start(i, &iter_head, start);
        capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    }
#endif
}",0,1,27,0.51,Insert
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    int a = 2;
    RenderViewHost* render_view_host;
    const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params;
    GURL validated_url(params.url);
    RenderProcessHost* render_process_host =
          render_view_host->GetProcess();
    FOR_EACH_OBSERVER(WebContentsObserver,
                         observers_,
                         DidFailProvisionalLoad(params.frame_id,
                                               params.is_main_frame,
                                               validated_url,
                                               params.error_code,
                                               params.error_description,
                                               render_view_host));
    int b = 3;
    if (a != b) {
        *xlat = addr + section->offset_within_region;
    }
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}",1,0,23,0.6,Insert
1446,,,,,,,
1448,"static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	f2fs_mark_inode_dirty_sync(inode, true);
}","static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	int a = 2;
	int b = 3;
	while (a < b) {
    	f2fs_mark_inode_dirty_sync(inode, true);
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpBool supported;
    	VdpChromaType type_9;
    	VdpStatus status;
    	status = surface_query_caps(hdtx->device, type_9, &supported,
    	                                &max_width, &max_height);
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	b = a;
	}
}",0,1,5,0.27,Insert
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	int a = 2;
	int b = 2;
	if (a == b) {
    	return 0;
	}
}",0,1,6,0.14,Replace
1451,"plperl_spi_query(char *query)
{
	SV		   *cursor;
	MemoryContext oldcontext = CurrentMemoryContext;
	ResourceOwner oldowner = CurrentResourceOwner;
	check_spi_usage_allowed();
	BeginInternalSubTransaction(NULL);
	MemoryContextSwitchTo(oldcontext);
	PG_TRY();
	{
		SPIPlanPtr	plan;
		Portal		portal;
		pg_verifymbstr(query, strlen(query), false);
		plan = SPI_prepare(query, 0, NULL);
		if (plan == NULL)
			elog(ERROR, ""SPI_prepare() failed:%s"",
				 SPI_result_code_string(SPI_result));
		portal = SPI_cursor_open(NULL, plan, NULL, NULL, false);
		SPI_freeplan(plan);
		if (portal == NULL)
			elog(ERROR, ""SPI_cursor_open() failed:%s"",
				 SPI_result_code_string(SPI_result));
		cursor = cstr2sv(portal->name);
		ReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
	}
	PG_CATCH();
	{
		ErrorData  *edata;
		MemoryContextSwitchTo(oldcontext);
		edata = CopyErrorData();
		FlushErrorState();
		RollbackAndReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
		croak(""%s"", edata->message);
		return NULL;
	}
	PG_END_TRY();
	return cursor;
}","plperl_spi_query(char *query)
{
	SV		   *cursor;
	MemoryContext oldcontext = CurrentMemoryContext;
	ResourceOwner oldowner = CurrentResourceOwner;
	check_spi_usage_allowed();
	BeginInternalSubTransaction(NULL);
	MemoryContextSwitchTo(oldcontext);
	PG_TRY();
	{
		SPIPlanPtr	plan;
		Portal		portal;
		pg_verifymbstr(query, strlen(query), false);
		plan = SPI_prepare(query, 0, NULL);
		if (plan == NULL)
			elog(ERROR, ""SPI_prepare() failed:%s"",
				 SPI_result_code_string(SPI_result));
		portal = SPI_cursor_open(NULL, plan, NULL, NULL, false);
		SPI_freeplan(plan);
		if (portal == NULL)
			elog(ERROR, ""SPI_cursor_open() failed:%s"",
				 SPI_result_code_string(SPI_result));
		cursor = cstr2sv(portal->name);
		ReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	PG_CATCH();
	}
	{
		ErrorData  *edata;
		MemoryContextSwitchTo(oldcontext);
		edata = CopyErrorData();
		FlushErrorState();
		RollbackAndReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
		croak(""%s"", edata->message);
		return NULL;
	}
	PG_END_TRY();
	return cursor;
}",0,1,10,0.37,Replace
1456,,,,,,,
1458,,,,,,,
1459,"localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    return tmp;
}","localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    int a = 2;
    BlockDriverState *btrvt;
    uint8_t cookie[6];
    uint8_t buffer[12];
    sg_io_hdr_t iloappdirector;
    int mem;
    memset(cookie, 0, sizeof(cookie));
    memset(buffer, 0, sizeof(buffer));
    memset(&iloappdirector, 0, sizeof(iloappdirector));
    mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
    int b = 3;
    while (a < b) {
        return tmp;
        b = a;
    }
}",0,1,11,0.39,Insert
1462,"static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3,  
		.flags = X86_EFLAGS_IF,
	};
	do_machine_check(&regs, 0);
#endif
}","static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3,  
		.flags = X86_EFLAGS_IF,
	};
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	do_machine_check(&regs, 0);
	}
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args;
	int rules, nb_regs, ini;
	tcg_insn_unit *func_addr;
	func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
	rules = args[nb_oargs + nb_iargs + 1];
#endif
}",0,1,3,0.24,Insert
1464,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		levels=GetXMLTreeChild(table_iterator,""levels"");
		table->levels=(unsigned int *) NULL;
		attribute=GetXMLTreeAttribute(levels,""width"");
		attribute=GetXMLTreeAttribute(levels,""height"");
		attribute=GetXMLTreeAttribute(levels,""divisor"");
	}
	int a = 2;
	int b = 3;
	while (a < b) {
    	return NT_STATUS_OK;
    	b = a;
	}
}",0,1,18,0.43,Insert
1466,,,,,,,
1467,,,,,,,
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";
    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";
    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        pval->size = strlen((const char *)pval->data);
    strcpy(str, ""a"");
    }
}",0,1,2,0.1,Replace
1469,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			char str[] = ""Constant"";
			if (strlen(str) > 0) {
    			rc = audit_gid_comparator(gid, f->op, n->gid);
			}
			int (*compare)(const char *, const char *, size_t);
			const char *name1;
			const char *name2;
			int cmp;
			unsigned char c1, mc7;
			cmp = compare(name1, name2, len);
			c1 = name1[len];
			if (rc)
				return rc;
		}
	}
	return 0;
}",0,1,12,0.63,Insert
1470,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }
  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}","Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }
  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       int a = 2;
       int b = 2;
       while (a == b) {
           DBUG_ASSERT(0);
           b += 1;
           struct client_session *c;
           int http_status;
           struct session_request *sr;
           struct mk_list *host_list = &config->hosts;
           struct mk_list *sr_list = &c->request_list;
           if (http_status > 0) {
                   if (!sr->host_conf) {
                       sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
                   }
                   mk_request_error(http_status, c, sr);
                   mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                       NULL, c, sr);
           }
       }
       ;
     }
  } 
}",0,1,36,0.79,Insert
1475,"static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;
	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}","static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;
	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	int a = 10;
	int b = a;
	if(a*b>0){
    	struct videobuf_buffer *vb;
    	struct videbuf_vmalloc_memory *mem=vb->priv;
    	int pages;
    	struct videbuf_vmalloc_memory *mem=vb->priv;
    	pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
    	dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
    	"",
    					(unsigned long)mem->vmalloc,
    					pages << PAGE_SHIFT);
    	ucontrol->value.enumerated.item[0] = val;
	}
	return 0;
}",0,1,31,0.54,Insert
1476,"static int ntop_has_geoip(lua_State* vm) {
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);
  return(CONST_LUA_OK);
}","static int ntop_has_geoip(lua_State* vm) {
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  int a = 2;
  int b = 3;
  if (a != b) {
      lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);
  }
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderCreate *create;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  VdpStatus status;
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  return(CONST_LUA_OK);
}",0,1,9,0.25,Insert
1477,,,,,,,
1479,,,,,,,
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    int a = 84;
    int b = a;
    if(a*b>0){
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        _rsvg_node_free (self);
    }
}",0,1,10,0.34,Insert
1484,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data[0]);
}","static void rxrpc_destroy(struct key *key)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	DisasContext *qs;
    	uint32_t ksns;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	err = extract32(ksns, 16, 5);
    	handle_fp_compare(qs, order, coll, err, false, p);
    	rxrpc_free_token_list(key->payload.data[0]);
    	b = a;
	}
}",0,1,5,0.25,Insert
1487,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;
	if (!conn)
		return;
	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);
	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}
	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	int a = 46;
	int b = a;
	if(a*b>0){
    	struct sock *sk;
	}
	if (!conn)
		return;
	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);
	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}
	hcon->sco_data = NULL;
	kfree(conn);
}",0,1,1,0.15,Replace
1488,"static void aead_sock_destruct(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	struct af_alg_ctx *ctx = ask->private;
	struct sock *psk = ask->parent;
	struct alg_sock *pask = alg_sk(psk);
	struct aead_tfm *aeadc = pask->private;
	struct crypto_aead *tfm = aeadc->aead;
	unsigned int ivlen = crypto_aead_ivsize(tfm);
	af_alg_pull_tsgl(sk, ctx->used, NULL, 0);
	crypto_put_default_null_skcipher2();
	sock_kzfree_s(sk, ctx->iv, ivlen);
	sock_kfree_s(sk, ctx, ctx->len);
	af_alg_release_parent(sk);
}","static void aead_sock_destruct(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	const char *statename_4;
	struct pinctrl *n_9;
	struct pinctrl_map *map_7;
	struct pinctrl_dev *pctldev_3;
	unsigned num_maps_6;
	int i_1;
	for (i_1 = 0; i_1 < num_maps_6; i_1++) {
			map_7[i_1].dev_name_9 = dev_name_9(n_9->dev);
			map_7[i_1].name = statename_4;
			if (pctldev_3)
				map_7[i_1].ctrl_dev_name = dev_name_9(pctldev_3->dev);
	}
	struct af_alg_ctx *ctx = ask->private;
	struct sock *psk = ask->parent;
	struct alg_sock *pask = alg_sk(psk);
	const char *statename;
	struct pinctrl *n;
	struct pinctrl_map *map;
	struct pinctrl_dev *pctldev;
	unsigned num_maps;
	int i;
	for (i = 0; i < num_maps; i++) {
			map[i].dev_name = dev_name(n->dev);
			Select *p;
			SortCtx esCompare;
			Vdbe *w;
			if( p->iLimit==0 && esCompare.addrSortIndex>=0 ){
			    sqlite3VdbeChangeOpcode(w, esCompare.addrSortIndex, OP_SorterOpen);
			    esCompare.sortFlags |= SORTFLAG_UseSorter;
			}
			map[i].name = statename;
			if (pctldev)
				map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct aead_tfm *aeadc = pask->private;
	}
	struct crypto_aead *tfm = aeadc->aead;
	unsigned int ivlen = crypto_aead_ivsize(tfm);
	af_alg_pull_tsgl(sk, ctx->used, NULL, 0);
	crypto_put_default_null_skcipher2();
	sock_kzfree_s(sk, ctx->iv, ivlen);
	sock_kfree_s(sk, ctx, ctx->len);
	af_alg_release_parent(sk);
}",1,0,335,2.52,Insert
1490,"void Field_iterator_table_ref::set(TABLE_LIST *table)
{
  DBUG_ASSERT(table);
  first_leaf= table->first_leaf_for_name_resolution();
  last_leaf=  table->last_leaf_for_name_resolution();
  DBUG_ASSERT(first_leaf && last_leaf);
  table_ref= first_leaf;
  set_field_iterator();
}","void Field_iterator_table_ref::set(TABLE_LIST *table)
{
  DBUG_ASSERT(table);
  first_leaf= table->first_leaf_for_name_resolution();
  last_leaf=  table->last_leaf_for_name_resolution();
  DBUG_ASSERT(first_leaf && last_leaf);
  table_ref= first_leaf;
  int a = 80;
  int b = a;
  if(a*b>0){
      set_field_iterator();
      ChardevCommon *complex = backend->u.null;
      CharDriverState *charrb;
      charrb = qemu_chr_alloc(complex, erfp);
  }
}",0,1,16,0.34,Insert
1491,,,,,,,
1492,"includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}","includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	int a = 92;
	int b = a;
	if(a*b>0){
    	Select *p;
    	SortCtx esCompare;
    	memset(&esCompare, 0, sizeof(esCompare));
    	esCompare.pOrderBy = p->pOrderBy;
    	char includeThis[MAXSTRING];
    	Select *p_2;
    	SortCtx esCompare_3;
    	memset_10(&esCompare_3, 0, sizeof(esCompare_3));
    	esCompare_3.pOrderBy = p_2->pOrderBy;
	}
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}",1,0,154,1.62,Insert
1495,"static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);
  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;
  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;
  case KOI8_R:
    if (c == 0x9a) return 1;
    break;
  default:
    exit(-1);
  }
  return 0;
}","static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);
  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;
  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;
  case KOI8_R:
    bool bool_var = (c == 0x9a);
    if (bool_var) return 1;
    break;
    int64_t unit;
    unsigned char c_1;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c_1, unit);
  default:
    exit(-1);
  }
  return 0;
}",0,1,8,0.68,Insert
1496,,,,,,,
1498,"megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)
{
	return readl(&instance->reg_set->outbound_msg_0);
}","megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return readl(&instance->reg_set->outbound_msg_0);
    	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    	ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    	aml_append(ifconfig,
    	        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    	aml_append(ifconfig,
    	        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    	aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
    	aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
	strcpy(str, ""a"");
	}
}",0,1,7,0.23,Insert
1499,"int HttpFile::save() const
{
    return implPtr_->save();
}","int HttpFile::save() const
{
    Image *image;
    const LayerInfo* layer_info;
    const size_t url;
    MagickOffsetType
        offset;
    MagickStatusType
        status;
    if (status == MagickFalse)
        SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    int a = 2;
    int b = 2;
    if (a == b) {
        return implPtr_->save();
    }
}",0,1,4,0.19,Insert
1500,"void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    banOrUnban(bufferInfo, msg, true);
}","void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    int a = 42;
    int b = a;
    if(a*b>0){
        banOrUnban(bufferInfo, msg, true);
        const char *nptr;
        double vals, mul, integral, fraction;
        char *ndpointer;
        unsigned char c;
        vals = strtod(nptr, &ndpointer);
        c = *ndpointer;
    }
}",0,1,3,0.23,Insert
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	int a = 2;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	int b = 2;
	if (a == b) {
    	return 0;
	}
}",0,1,11,0.28,Insert
1503,"static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;
	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}
	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}","static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;
	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		int a = 2;
		int b = 2;
		if (a == b) {
    		jas_free(tcmpt->rlvls);
		}
	}
	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}",1,0,1,0.11,Replace
1504,"static unsigned get_mmio_spte_access(u64 spte)
{
	return spte & shadow_mmio_access_mask;
}","static unsigned get_mmio_spte_access(u64 spte)
{
	const char *nptr;
	char *ndpointer;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	int64_t retval;
	double vals, mul, integral, fraction;
	vals = strtod(nptr, &ndpointer);
	fraction = modf(vals, &integral);
	retval = vals * mul;
	int a = 2;
	int b = 3;
	while (a != b) {
    	return spte & shadow_mmio_access_mask;
    	b = a;
	}
}",0,1,6,0.22,Insert
1506,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;
	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}
	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;
	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
		MachineState *machine;
		MemoryRegion *sysmem = get_system_memory();
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		MemoryRegion *ram = g_new(MemoryRegion, 1);
		memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
		                                         machine->ram_size);
		memory_region_add_subregion(sysmem, 0, ram);
		spapr_create_nvram(spapr);
	}
	int a = 2;
	int b = 2;
	if (a == b) {
    	return IRQ_HANDLED;
	}
}",0,1,24,0.6,Insert
1507,"ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);
  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
  }
}","ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);
  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int data_8, r;
        data_8 = -1;
        gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
    }
  }
}",0,1,5,0.32,Insert
1508,"static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    uint init_alloc, uint alloc_increment)
{
  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))
    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);
}","static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    uint init_alloc, uint alloc_increment)
{
  uint32_t out_length;
  uint32_t out_len;
  int tpm_fd;
  const uint8_t *diff;
  uint8_t *out;
  int let;
  let = tpm_passthrough_unix_write(tpm_fd, diff, out_length);
  let = tpm_passthrough_unix_read(tpm_fd, out, out_len);
  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))
    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);
}",0,1,6,0.26,Insert
1510,"void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  (*route_config_updated_cb)(false);
}","void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return;
    strcpy(str, ""a"");
    }
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  (*route_config_updated_cb)(false);
}",0,1,5,0.18,Replace
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;
	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);
	return TRUE;
}","e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	GSimpleAsyncResult *simple;
	}
	EwsAsyncData *async_data;
	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	levels=GetXMLTreeChild(table_iterator,""levels"");
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);
	return TRUE;
}",0,1,22,0.58,Insert
1513,"static void __net_exit sctp_defaults_exit(struct net *net)
{
	sctp_free_addr_wq(net);
	sctp_free_local_addr_list(net);
	sctp_dbg_objcnt_exit(net);
	sctp_proc_exit(net);
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}","static void __net_exit sctp_defaults_exit(struct net *net)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	sctp_free_addr_wq(net);
	}
	sctp_free_local_addr_list(net);
	sctp_dbg_objcnt_exit(net);
	sctp_proc_exit(net);
	cleanup_sctp_mibs(net);
	i_ctx_t * i_ctx_p;
	ref altscale;
	PS_colour_space_t *pspace;
	int i, limit, data;
	int i, limit, data;
	data = pspace->numcomponents(i_ctx_p, &altscale, &limit);
	sctp_sysctl_net_unregister(net);
}",0,1,14,0.33,Insert
1515,"zzip_mem_entry_free(ZZIP_MEM_ENTRY * _zzip_restrict item)
{
    if (item)
    {
	if (item->zz_ext[0]) free (item->zz_ext[0]);
	if (item->zz_ext[1]) free (item->zz_ext[1]);
	if (item->zz_ext[2]) free (item->zz_ext[2]);
	if (item->zz_comment) free (item->zz_comment);
	if (item->zz_name) free (item->zz_name);
	free (item);
    }
}","zzip_mem_entry_free(ZZIP_MEM_ENTRY * _zzip_restrict item)
{
    if (item)
    {
	if (item->zz_ext[0]) free (item->zz_ext[0]);
	if (item->zz_ext[1]) free (item->zz_ext[1]);
	if (item->zz_ext[2]) free (item->zz_ext[2]);
	if (item->zz_comment) free (item->zz_comment);
	if (item->zz_name) free (item->zz_name);
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	free (item);
    }
}",0,1,4,0.47,Insert
1516,"static int __init sched_domain_debug_setup(char *str)
{
	sched_domain_debug_enabled = 1;
	return 0;
}","static int __init sched_domain_debug_setup(char *str)
{
	char str_1[] = ""Constant"";
	if (strlen(str_1) > 0) {
    	sched_domain_debug_enabled = 1;
    	char *filename;
    	long load_limit, rtas_limit, fw_size;
    	rtas_limit = MIN(spapr->rma_size, 0x80000000);
    	spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
    	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
    	                                           rtas_limit - spapr->rtas_addr);
	}
	return 0;
}",0,1,10,0.19,Insert
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct snd_pcm_hw_params *params;
	}
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}",0,1,2,0.12,Replace
1523,"static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}","static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	struct sk_buff *skb;
	struct sock *sk;
	struct tcp_sock *tp = tcp_sk(sk);
	u32 length, end64seq;
	struct tcp_sock *tp = tcp_sk(sk);
	u32 length, end64seq;
	SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
	"",
			   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
	length = TCP_SKB_CB(skb)->length;
	int a = 2;
	int b = 2;
	while (a == b) {
    	unsigned int i;
    	b += 1;
	}
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}",0,1,17,0.64,Insert
1524,,,,,,,
1525,,,,,,,
1526,"void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {
  new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));
}","void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {
  int a = 2;
  int b = 3;
  while (a < b) {
      new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));
      b = a;
  }
}",1,0,1,0.05,Replace
1527,,,,,,,
1528,"void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }
  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}","void svhandler_flash_pgm_word(void) {
  int a = 2;
  int b = 3;
  while (a != b) {
      uint32_t dst = _param_1;
      b = a;
  }
  uint32_t src = _param_2;
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }
  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}",1,0,1,0.15,Replace
1531,,,,,,,
1535,"int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);
	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;
	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}
	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;
	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);
	if (!res)
		goto out;
	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);
 out:
	kfree(resp);
	return res;
}","int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);
	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;
	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		struct hfs_find_data *fd_3;
		u32 cnid_5;
		struct super_block *sb_9;
		hfsplus_cat_build_key_6(sb_9, fd_3->search_key, cnid_5, NULL);
		int a = 2;
		int b = 2;
		struct hfs_find_data *fd;
		u32 cnid;
		struct super_block *sb;
		hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);
		if (a == b) {
    		return -ENOMEM;
		}
	}
	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;
	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);
	if (!res)
		goto out;
	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);
 out:
	kfree(resp);
	return res;
}",1,0,106,1.37,Insert
1538,,,,,,,
1539,"cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}","cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		AVPacket *afpud;
		DisasContext *qs;
		uint32_t ksns;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		err = extract32(ksns, 16, 5);
		handle_fp_compare(qs, order, coll, err, false, p);
		AVCodecContext *avctx;
		int sample_scale, c, n, i;
		int sample_scale, c, n, i;
		int buf_size = afpud->size;
		PCMDecode *s = avctx->priv_data;
		sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
		n = avctx->channels * sample_scale;
		n = buf_size/sample_scale;
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		int a = 2;
		int b = 3;
		if (a != b) {
    		return FILE_BEFLOAT;
		}
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}",0,1,57,0.9,Insert
1541,"static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;
	if (_gnutls_global_init_skip() != 0)
		return;
	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}
	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}","static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;
	if (_gnutls_global_init_skip() != 0)
		return;
	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		int a = 2;
		int b = 2;
		if (a == b) {
    		ret = atoi(e);
		}
		if (ret == 1)
			return;
	}
	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}",1,0,5,0.16,Replace
1542,,,,,,,
1544,"static void vmx_slot_enable_log_dirty(struct kvm *kvm,
				     struct kvm_memory_slot *slot)
{
	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
}","static void vmx_slot_enable_log_dirty(struct kvm *kvm,
				     struct kvm_memory_slot *slot)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
	}
	MachineState *machine;
	char *filename;
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	register_savevm_live(NULL, ""spapr/htab"", -1, 1,
	                         &savevm_htab_handlers, spapr);
	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
}",0,1,8,0.27,Insert
1545,"tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	int ret;
	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					MOD_LOG_KEY_REPLACE,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	BUG_ON(ret < 0);
}","tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	int ret;
	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					MOD_LOG_KEY_REPLACE,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	int a = 2;
	int b = 3;
	while (a < b) {
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	const char
    	    *attribute,
    	    *content;
    	size_t
    	    length;
    	table->width=StringToUnsignedLong(attribute);
    	table->height=StringToUnsignedLong(attribute);
    	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    	length=(size_t) table->width*table->height;
    	table->levels=(unsigned int *) AcquireQuantumMemory(length,
    	    sizeof(*table->levels));
    	BUG_ON(ret < 0);
    	b = a;
	}
}",0,1,15,0.53,Insert
1546,"void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;
	if (!xs->tx)
		return;
	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}","void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;
	if (!xs->tx)
		return;
	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	int a = 2;
	int b = 3;
	if (a != b) {
    	Image *image;
    	const LayerInfo* layer_info;
    	const size_t url;
    	MagickOffsetType
    	    offset;
    	MagickStatusType
    	    status;
    	if (status == MagickFalse)
    	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
    	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
	}
}",0,1,10,0.31,Insert
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct sctp_hmac_algo_param *hmacs;
	strcpy(str, ""a"");
	}
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}",0,1,1,0.15,Replace
1550,"static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);
	return ret;
}","static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	mutex_lock(&aac_mutex);
	strcpy(str, ""a"");
	}
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);
	return ret;
}",0,1,4,0.1,Replace
1551,,,,,,,
1552,,,,,,,
1553,,,,,,,
1554,"void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& output_dims) {
  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       output_data);
}","void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& output_dims) {
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  uint8_t byte_list[1] = {1};
  buf = aml_buffer(1, byte_list);
  byte_list[0] = 0;
  buf = aml_buffer(1, byte_list);
  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       output_data);
}",0,1,4,0.19,Insert
1556,"static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;
		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}","static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		void *rma = NULL;
		BlockDriverState *bos;
		if (Pbes) {
		        *Pbes = bos;
		}
		hwaddr rma_alloc_size;
		MemoryRegion *sysmem = get_system_memory();
		MemoryRegion *rma_region;
		if (rma_alloc_size && rma) {
		        rma_region = g_new(MemoryRegion, 1);
		        memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",
		                                   rma_alloc_size, rma);
		        vmstate_register_ram_global(rma_region);
		        memory_region_add_subregion(sysmem, 0, rma_region);
		}
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;
		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	int a = 2;
	int b = 2;
	while (a == b) {
    	gf_list_add(pa->nalus, sl);
    	b += 1;
	}
}",0,1,51,0.87,Insert
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	dhcp_server->started = FALSE;
}","void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	MachineState *machine;
    	sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);
    	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    	if (smc->dr_lmb_enabled) {
    	        spapr_create_lmb_dr_connectors(spapr);
    	}
    	dhcp_server->started = FALSE;
	strcpy(str, ""a"");
	}
}",0,1,11,0.27,Insert
1562,,,,,,,
1563,"virDomainNetGetActualBridgeName(const virDomainNetDef *iface)
{
    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)
        return iface->data.bridge.brname;
    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&
        iface->data.network.actual &&
        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||
         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))
        return iface->data.network.actual->data.bridge.brname;
    return NULL;
}","virDomainNetGetActualBridgeName(const virDomainNetDef *iface)
{
    AIOReq *ao_grab;
    SheepdogObjReq hdr;
    unsigned int datalen = ao_grab->data_len;
    hdr.data_length = datalen;
    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)
        return iface->data.bridge.brname;
    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&
        iface->data.network.actual &&
        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||
         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))
        return iface->data.network.actual->data.bridge.brname;
    char str[] = ""Constant"";
    const struct smb_filename *smb_fhandle;
    QDict *rss, *lst, *resource, *vne, *acl, *diffen;
    QObject *row, *reader;
    reader = qdict_crumple(rss, &error_abort);
    QDECREF(rss);
    struct security_descriptor *sd = NULL;
    NTSTATUS success;
    if (!NT_STATUS_IS_OK(success)) {
    		if (DEBUGLEVEL >= 10) {
    			DEBUG(10,(""smbd_check_access_rights: acl for %s is:
    "",
    				smb_fname_str_dbg(smb_fhandle) ));
    			NDR_PRINT_DEBUG(security_descriptor, sd);
    		}
    }
    if (strlen(str) > 0) {
        return NULL;
    }
}",0,1,64,0.7,Insert
1565,"inline WordCount SegmentReader::getOffsetTo(const word* ptr) {
  return intervalLength(this->ptr.begin(), ptr);
}","inline WordCount SegmentReader::getOffsetTo(const word* ptr) {
  int a = 2;
  int b = 2;
  while (a == b) {
      return intervalLength(this->ptr.begin(), ptr);
      QEMUBH *phi;
      phi = g_malloc0(sizeof(QEMUBH));
      phi->ctx = ctx;
      phi->cb = cb;
      phi->opaque = opaque;
      phi->next = ctx->first_bh;
      b += 1;
  }
}",0,1,10,0.26,Insert
1571,,,,,,,
1572,"static void transport_flags_from_domain(AvahiServer *s, AvahiLookupFlags *flags, const char *domain) {
    assert(flags);
    assert(domain);
    assert(!((*flags & AVAHI_LOOKUP_USE_MULTICAST) && (*flags & AVAHI_LOOKUP_USE_WIDE_AREA)));
    if (*flags & (AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_WIDE_AREA))
        return;
    if (!s->wide_area_lookup_engine ||
        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
        *flags |= AVAHI_LOOKUP_USE_MULTICAST;
    else
        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
}","static void transport_flags_from_domain(AvahiServer *s, AvahiLookupFlags *flags, const char *domain) {
    assert(flags);
    assert(domain);
    assert(!((*flags & AVAHI_LOOKUP_USE_MULTICAST) && (*flags & AVAHI_LOOKUP_USE_WIDE_AREA)));
    if (*flags & (AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_WIDE_AREA))
        return;
    if (!s->wide_area_lookup_engine ||
        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
        char str1[] = ""Constant"";
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        aml_append(coll,
                aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
        aml_append(ifconfig,
                aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
        aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                        aml_name(""CTRL"")));
        ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        }
    else
        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
}",0,1,13,0.62,Insert
1575,"void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)
{
	struct rb_node *n;
	struct gfs2_rgrpd *rgd;
	struct gfs2_glock *gl;
	while ((n = rb_first(&sdp->sd_rindex_tree))) {
		rgd = rb_entry(n, struct gfs2_rgrpd, rd_node);
		gl = rgd->rd_gl;
		rb_erase(n, &sdp->sd_rindex_tree);
		if (gl) {
			spin_lock(&gl->gl_lockref.lock);
			gl->gl_object = NULL;
			spin_unlock(&gl->gl_lockref.lock);
			gfs2_glock_add_to_lru(gl);
			gfs2_glock_put(gl);
		}
		gfs2_free_clones(rgd);
		kfree(rgd->rd_bits);
		return_all_reservations(rgd);
		kmem_cache_free(gfs2_rgrpd_cachep, rgd);
	}
}","void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)
{
	struct rb_node *n;
	struct gfs2_rgrpd *rgd;
	struct gfs2_glock *gl;
	while ((n = rb_first(&sdp->sd_rindex_tree))) {
		rgd = rb_entry(n, struct gfs2_rgrpd, rd_node);
		gl = rgd->rd_gl;
		int a = 2;
		int b = 2;
		while (a == b) {
    		rb_erase(n, &sdp->sd_rindex_tree);
    		b += 1;
		}
		if (gl) {
			spin_lock(&gl->gl_lockref.lock);
			gl->gl_object = NULL;
			spin_unlock(&gl->gl_lockref.lock);
			gfs2_glock_add_to_lru(gl);
			gfs2_glock_put(gl);
		}
		gfs2_free_clones(rgd);
		kfree(rgd->rd_bits);
		return_all_reservations(rgd);
		kmem_cache_free(gfs2_rgrpd_cachep, rgd);
	}
}",1,0,1,0.16,Replace
1576,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                 
  sqlite3_stmt **ppStmt            
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                 
  sqlite3_stmt **ppStmt
  int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;
  long SX, SY, SW, SH, DX, DY, DW, DH;
  dstW = DW;            
){
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      sqlite3_stmt *pStmt = 0;
  strcpy(str, ""a"");
  }
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}",0,1,16,0.56,Insert
1577,"virDomainResume(virDomainPtr domain)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    conn = domain->conn;
    virCheckReadOnlyGoto(conn->flags, error);
    if (conn->driver->domainResume) {
        int ret;
        ret = conn->driver->domainResume(domain);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainResume(virDomainPtr domain)
{
    int a = 99;
    int b = a;
    if(a*b>0){
        virConnectPtr conn;
    }
    VIR_DOMAIN_DEBUG(domain);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    conn = domain->conn;
    virCheckReadOnlyGoto(conn->flags, error);
    if (conn->driver->domainResume) {
        int ret;
        ret = conn->driver->domainResume(domain);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    AVCodecContext *AVcas;
    VdpDecoderProfile profile;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpStatus status;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    return -1;
}",0,1,26,0.57,Insert
1578,"MODRET auth_pre_user(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }
  if (logged_in) {
    return PR_DECLINED(cmd);
  }
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }
  if (logged_in) {
    return PR_DECLINED(cmd);
  }
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        pr_cmd_set_errno(cmd, EPERM);
    strcpy(str, ""a"");
    }
    errno = EPERM;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}",0,1,2,0.19,Replace
1579,"_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int ret = 0;
  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  return ret;
}","_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int wb;
  uint32_t lvcall;
  CPUState *env;
  unsigned int valpages;
  uint32_t r_cause;
  int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t pid, lo, hi;
  int set, match = 0;
  r_cause = env->sregs[SFR_R_MM_CAUSE];
  D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
  		  "" %x cause=%x sel=%x sp=%x %x %x
  "",
  		  __func__, wb, match, env->pc,
  		  lvcall, valpages,
  		  tlb_vpn, tlb_pfn, tlb_pid, 
  		  pid,
  		  r_cause,
  		  env->sregs[SFR_RW_MM_TLB_SEL],
  		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
  int ret = 0;
  int a = 2;
  int b = 3;
  if (a != b) {
      GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  }
  return ret;
}",0,1,18,0.32,Insert
1580,,,,,,,
1582,"  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {
    F(std::forward<Args>(args)...);
  }","  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        const struct dom_sid *alias;
        TALLOC_CTX *mem_stack;
        struct pdb_methods *mut;
        struct dom_sid ** pmemrooms;
        struct ldb_dn *anon;
        TALLOC_CTX *mem_context = talloc_new(mem_stack);
        unsigned int num_members;
        NTSTATUS obj;
        TALLOC_CTX *mem_context = talloc_new(mem_stack);
        struct dom_sid_buf buf;
        struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
        		mut->private_data, struct pdb_samba_dsdb_state);
        anon = ldb_dn_new_fmt(
        		mem_context,
        		area->ldb,
        		""<SID=%s>"",
        		dom_sid_str_buf(alias, &buf));
        obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
        F(std::forward<Args>(args)...);
    }
  }",0,1,4,0.17,Insert
1588,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}","int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    AVCodecContext *AVcas;
    VdpDecoderProfile profile;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpStatus status;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    int a = 2;
    int b = 3;
    while (a != b) {
        quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
        b = a;
    }
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}",0,1,13,0.34,Insert
1592,"static js_Ast *memberexp(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}","static js_Ast *memberexp(js_State *J)
{
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 != b_1) {
    	js_Ast *a;
    	b_1 = a_1;
	}
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}",1,0,2,0.09,Replace
1595,,,,,,,
1597,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;
        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }
        ++l_max_poc;
        return 4 + 9 * l_max_poc;
}","OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        Rocker *r;
        DescInfo *info;
        uint32_t port;
        int err = ROCKER_OK;
        char *buf = desc_get_buf(info, true);
        struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
        PCIDevice *dev = PCI_DEVICE(r);
        int iovcnt = 0;
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        err = fp_port_eg(r->fp_port[port], iov, iovcnt);
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;
        l_tcp = p_j2k->m_cp.tcps;
        int a = 2;
        int b = 3;
        if (a != b) {
            l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        }
        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }
        ++l_max_poc;
        return 4 + 9 * l_max_poc;
}",0,1,27,0.49,Insert
1601,"static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {
    mongo_md5_state_t st;
    mongo_md5_byte_t digest[16];
    mongo_md5_init( &st );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )"":mongo:"", 7 );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );
    mongo_md5_finish( &st, digest );
    digest2hex( digest, hex_digest );
}","static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {
    mongo_md5_state_t st;
    mongo_md5_byte_t digest[16];
    mongo_md5_init( &st );
    ppc4xx_bd_info_t *bd;
    int i, n;
    ram_addr_t bdloc;
    for (i = 0; i < 6; i++)
            stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )"":mongo:"", 7 );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );
    mongo_md5_finish( &st, digest );
    digest2hex( digest, hex_digest );
}",1,0,20,0.44,Insert
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    int a = 2;
    int b = 2;
    if (a == b) {
        msg = sprint_message(message);
    }
    V9fsPath *fs_path;
    FsContext *FS_path;
    int fd_10, ret;
    struct handle_data *parent = (struct handle_data *)FS_path->private;
    fd_10 = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}",0,1,10,0.38,Insert
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return (0);
            FDCharDriver *s_2;
            s_2->fd_out = io_channel_from_fd(fd_out);
            fcntl(fd_out, F_SETFL, O_NONBLOCK);
        }
}",0,1,8,0.3,Insert
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
        conversation = find_conversation_by_name (self, service_name);
        if (conversation == NULL) {
                return NULL;
        }
        return conversation->session_id;
}","gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        size_t
            length;
        table->width=StringToUnsignedLong(attribute);
        table->height=StringToUnsignedLong(attribute);
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
        int a = 2;
        int b = 3;
        while (a != b) {
            conversation = find_conversation_by_name (self, service_name);
            b = a;
        }
        if (conversation == NULL) {
                return NULL;
        }
        return conversation->session_id;
}",0,1,14,0.35,Insert
1608,,,,,,,
1609,"iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t a;
  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  a->d.len = length;
  return a;
}","iobuf_temp_with_content (const char *buffer, size_t length)
{
  int a_1 = 2;
  FILE * trace;
  GF_Box *a_8;
  GF_HandlerBox *p = (GF_HandlerBox *)a_8;
  GF_HandlerBox *p = (GF_HandlerBox *)a_8;
  gf_isom_box_dump_start(a_8, ""HandlerBox"", trace);
  fprintf(trace, ""reserved1=\""%d\"" reserved2=\"""", p->reserved1);
  dump_data(trace, (char *) p->reserved2, 12);
  fprintf(trace, ""\"""");
  fprintf(trace, "">
  "");
  int b_1 = 2;
  while (a_1 == b_1) {
      iobuf_t a;
      b_1 += 1;
  }
  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  a->d.len = length;
  return a;
}",1,0,11,0.33,Insert
1611,"static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {
        const char *v;
        assert(handle);
        assert(key);
        v = pam_getenv(handle, key);
        if (!isempty(v))
                return v;
        v = secure_getenv(key);
        if (!isempty(v))
                return v;
        return fallback;
}","static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {
        const char *v;
        assert(handle);
        assert(key);
        v = pam_getenv(handle, key);
        if (!isempty(v))
                return v;
        v = secure_getenv(key);
        if (!isempty(v))
                return v;
        int a = 96;
        int b = a;
        if(a*b>0){
            return fallback;
        }
}",0,1,3,0.11,Replace
1612,"    bool _empty() override {
      return peering_queue.empty();
    }","    bool _empty() override {
      int a = 2;
      int b = 2;
      while (a == b) {
          const char *nptr;
          double vals, mul, integral, fraction;
          char *ndpointer;
          unsigned char c;
          vals = strtod(nptr, &ndpointer);
          c = *ndpointer;
          return peering_queue.empty();
          b += 1;
      }
    }",0,1,3,0.18,Insert
1616,,,,,,,
1617,,,,,,,
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;
	pr_debug(""dequeue_general()\n"");
	ret =  *queue;
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}","static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	S390CPU *console;
	Error *order = NULL;
	object_property_set_int(OBJECT(console), core_id, ""core-id"", &order);
	irda_queue_t *ret;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	pr_debug(""dequeue_general()\n"");
	strcpy(str, ""a"");
	}
	ret =  *queue;
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}",0,1,16,0.53,Insert
1620,"gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	context->state = GIF_GET_COLORMAP2;
}","gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpDecoderCreate *create;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	void *pack;
    	VdpBool supported;
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    	                                     &pack);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    	                                     &pack);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
    	context->state = GIF_GET_COLORMAP2;
	}
}",0,1,7,0.19,Insert
1621,"int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;
	if (!addr)
		return -ENODEV;
	io->io_cleanup = port_cleanup;
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
			return -EIO;
		}
	}
	return 0;
}","int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;
	if (!addr)
		return -ENODEV;
	io->io_cleanup = port_cleanup;
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
		Error **errp_1;
		const char *fmt_2;
		va_list ap_2;
		va_start_4(ap_2, fmt_2);
		error_setv_1(errp_1, ERROR_CLASS_GENERIC_ERROR_1, fmt_2, ap_2);
	case 2:
		char str1[] = ""Constant"";
		Error **errp;
		const char *fmt;
		va_list ap;
		va_start(ap, fmt);
		error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		io->inputb = port_inw;
		}
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
			return -EIO;
		}
	}
	return 0;
}",1,0,61,1.01,Insert
1622,"win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	 
	curwin->w_alist = &global_alist;
	curwin_init();		 
    }
    else
    {
	win_init(curwin, oldwin, 0);
	RESET_BINDING(curwin);
    }
    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;
    return OK;
}","win_alloc_firstwin(win_T *oldwin)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        curwin = win_alloc(NULL, FALSE);
    }
    if (oldwin == NULL)
    {
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	 
	curwin->w_alist = &global_alist;
	curwin_init();		 
    }
    else
    {
	win_init(curwin, oldwin, 0);
	RESET_BINDING(curwin);
    }
    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;
    return OK;
}",0,1,1,0.17,Replace
1624,"TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  resultMustBe(""hello \""world\"""");
}","TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  int a = 2;
  int b = 3;
  while (a < b) {
      whenInputIs(""\""hello \\\""world\\\""\"""");
      b = a;
  }
  ptrdiff_t src_stride;
  ptrdiff_t buf_stride;
  int h;
  int src_y;
  int block_h;
  int w;
  int block_w;
  const uint8_t *src;
  int src_x;
  uint8_t *buf;
  emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                       src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                       hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
  resultMustBe(""hello \""world\"""");
}",0,1,9,0.22,Insert
1625,,,,,,,
1626,,,,,,,
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;		 
	if (interval <= 0)
		interval = 1;			 
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct tcp_keepalive ka;
    	b = a;
	}
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;		 
	if (interval <= 0)
		interval = 1;			 
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",0,1,1,0.2,Replace
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;
	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;
	_metadata_locking = enable ? 1 : 0;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return 0;
	}
}",0,1,1,0.05,Replace
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);
		mutex_unlock(&wq->mutex);
		goto reflush;
	}
	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);
		int a = 27;
		int b = a;
		if(a*b>0){
    		V9fsPath *fs_path;
    		FsContext *FS_path;
    		int fd, ret;
    		struct handle_data *parent = (struct handle_data *)FS_path->private;
    		fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    		mutex_unlock(&wq->mutex);
		}
		goto reflush;
	}
	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}",0,1,30,0.61,Insert
1633,,,,,,,
1634,,,,,,,
1635,,,,,,,
1636,,,,,,,
1640,,,,,,,
1643,"cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };
    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);
    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}","cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };
    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);
    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    int a = 2;
    int b = 3;
    while (a != b) {
        return mpe;
        b = a;
    }
}",0,1,2,0.13,Replace
1644,"static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}","static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		spin_unlock(&sbinfo->stat_lock);
    		struct edgeport_serial *serial;
    		u8 *data;
    		struct device *dev = &serial->serial->dev->dev;
    		struct device *dev = &serial->serial->dev->dev;
    		int status;
    		if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
    				dev_dbg(dev, ""%s - ROM_TYPE_II
    		"", __func__);
    				serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
    				goto out;
    		}
		}
	}
}",0,1,12,0.33,Insert
1645,"void ptrace_notify(int exit_code)
{
	siginfo_t info;
	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}","void ptrace_notify(int exit_code)
{
	siginfo_t info;
	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
	memset(&info, 0, sizeof info);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	info.si_signo = SIGTRAP;
	strcpy(str, ""a"");
	}
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}",0,1,4,0.12,Replace
1646,,,,,,,
1647,"static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}","static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	return ((src->ssid_len == dst->ssid_len) &&
	uint8_t url;
	struct _mdi *midi;
	uint8_t pool;
	MIDI_EVENT_DEBUG(__FUNCTION__,url, pool);
	midi->events[mi event_count].event_data.data.value = pool;
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}",0,1,3,0.31,Insert
1648,"int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}
	if (!dtls1_is_timer_expired(s))
		{
		return code;
		}
	if ( ! SSL_in_init(s))   
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}
#if 0  
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		}
	else
#endif
#if 0   
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif
	return dtls1_handle_timeout(s);
	}","int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
		int a = 2;
		int b = 2;
		if (a == b) {
    		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		}
		return 1;
		}
	if (!dtls1_is_timer_expired(s))
		{
		int i;
		struct net_bridge_mdb_entry *mp;
		struct net_bridge_mdb_htable *mdb;
		struct hlist_node *n;
		u32 ver;
		for (i = 0; i < mdb->max; i++) {
				hlist_for_each_entry_safe(mp, n, &mdb->mhash[i],
							  hlist[ver]) {
					del_timer(&mp->timer);
					call_rcu_bh(&mp->rcu, br_multicast_free_group);
				}
		}
		return code;
		}
	if ( ! SSL_in_init(s))   
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}
#if 0  
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		}
	else
#endif
#if 0   
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif
	return dtls1_handle_timeout(s);
	}",1,0,37,0.86,Insert
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;
		minor ^= low | high;	 
		low <<= distance;	 
		high >>= distance;
		minor |= low | high;	 
	}
#endif
	return minor;
}","static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;
		minor ^= low | high;	 
		low <<= distance;	 
		high >>= distance;
			int a = 2;
			int b = 2;
			while (a == b) {
    		minor |= low | high;
    		const char
    		    *attribute,
    		    *content;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		char
    		    *p,
    		    *xml;
    		double
    		    value;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		content=GetXMLTreeContent(description);
    		content=GetXMLTreeContent(levels);
    		value=InterpretLocaleValue(content,&p);	 
    			b += 1;
			}
	}
#endif
	return minor;
}",0,1,27,0.75,Insert
1652,"  void fix_from_value(Derivation dv, const Metadata metadata)
  {
    fix_charset_and_length(str_value.charset(), dv, metadata);
  }","  void fix_from_value(Derivation dv, const Metadata metadata)
  {
    char str[] = ""Constant"";
    struct sk_buff *skb;
    struct sock *sk;
    struct tcp_sock *tp = tcp_sk(sk);
    struct sk_buff *skn4;
    if (!skn4)
    		__skb_queue_head(&tp->out_of_order_queue, skb);
    	else
    		__skb_queue_after(&tp->out_of_order_queue, skn4, skb);
    while (strlen(str) > 5) {
        fix_charset_and_length(str_value.charset(), dv, metadata);
    strcpy(str, ""a"");
    }
  }",0,1,3,0.24,Insert
1653,"static int mount_rootfs_block(const char *rootfs, const char *target,
			                  const char *options)
{
	return mount_unknown_fs(rootfs, target, options);
}","static int mount_rootfs_block(const char *rootfs, const char *target,
			                  const char *options)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	char
    	    *p,
    	    *xml;
    	double
    	    value;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	content=GetXMLTreeContent(description);
    	content=GetXMLTreeContent(levels);
    	value=InterpretLocaleValue(content,&p);
    	return mount_unknown_fs(rootfs, target, options);
    	b += 1;
	}
}",0,1,5,0.29,Insert
1654,"void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  dump_start(s);
  ReplicationConfiguration conf;
  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;
    auto iter = policy->groups.find(enabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
  }
  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}","void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  dump_start(s);
  ReplicationConfiguration conf;
  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;
    auto iter = policy->groups.find(enabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
  }
  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  int a = 63;
  int b = a;
  if(a*b>0){
      rgw_flush_formatter_and_reset(s, s->formatter);
  }
  }
}",0,1,28,0.83,Insert
1655,"static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;
	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;
	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}","static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;
	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		int a = 2;
		int b = 2;
		if (a == b) {
    		return;
		}
	in_dev->mr_gq_running = 1;
	struct tty_struct *reader;
	struct awm *awm = reader->driver_data;
	struct acm_wb *sth;
	struct awm *awm = reader->driver_data;
	if (sth->len == awm->writesize) {
			acm_tty_flush_chars(reader);
			goto overflow;
	}
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}",0,1,11,0.35,Insert
1660,,,,,,,
1661,,,,,,,
1662,,,,,,,
1663,"void sdtp_box_del(GF_Box *s)
{
	GF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;
	if (ptr == NULL) return;
	if (ptr->sample_info) gf_free(ptr->sample_info);
	gf_free(ptr);
}","void sdtp_box_del(GF_Box *s)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	GF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;
    	ptrdiff_t src_stride;
    	ptrdiff_t buf_stride;
    	int h;
    	int src_y;
    	int block_h;
    	int w;
    	int block_w;
    	const uint8_t *src;
    	int src_x;
    	uint8_t *buf;
    	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
    	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
    	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	}
	if (ptr == NULL) return;
	if (ptr->sample_info) gf_free(ptr->sample_info);
	gf_free(ptr);
}",0,1,4,0.3,Insert
1666,,,,,,,
1667,"void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}","void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
ptrdiff_t src_stride;
ptrdiff_t buf_stride;
int h;
int src_y;
int block_h;
int w;
int block_w;
const uint8_t *src;
int src_x;
uint8_t *buf;
emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
#ifdef NET_TX_PKT_DEBUG
    int a = 74;
    int b = a;
    if(a*b>0){
        assert(pkt);
    }
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}",0,1,3,0.35,Insert
1670,"      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        const unsigned int
          k = (unsigned int)mp.opcode[3],
          l = (unsigned int)mp.opcode[4];
        const bool use_LU = (bool)_mp_arg(5);
        CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);
        return cimg::type<double>::nan();
      }","      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        const unsigned int
          k = (unsigned int)mp.opcode[3],
          l = (unsigned int)mp.opcode[4];
        const bool use_LU = (bool)_mp_arg(5);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);
        }
        return cimg::type<double>::nan();
      }",0,1,12,0.46,Insert
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
	spin_lock_irq(&css_set_lock);
	it->ss = css->ss;
	it->flags = flags;
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;
	it->cset_head = it->cset_pos;
	css_task_iter_advance(it);
	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	unsigned char *sha1;
	void *data;
	unsigned long size;
	struct pbase_tree *it_2;
	unsigned char tree_sha1[20];
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	hashcpy(it_2->pcache.sha1, tree_sha1);
	memset(it, 0, sizeof(*it));
	spin_lock_irq(&css_set_lock);
	it->ss = css->ss;
	it->flags = flags;
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;
	it->cset_head = it->cset_pos;
	css_task_iter_advance(it);
	int a = 2;
	int b = 2;
	if (a == b) {
    	spin_unlock_irq(&css_set_lock);
	}
}",0,1,15,0.56,Insert
1672,"static void hardware_disable(void)
{
	vmclear_local_loaded_vmcss();
	if (cpu_vmxoff())
		kvm_spurious_fault();
	intel_pt_handle_vmx(0);
}","static void hardware_disable(void)
{
	vmclear_local_loaded_vmcss();
	if (cpu_vmxoff())
		kvm_spurious_fault();
	int a = 2;
	int b = 3;
	while (a < b) {
    	intel_pt_handle_vmx(0);
    	AVPacket * pk;
    	AVFormatContext *s;
    	unsigned char rb[5];
    	AVCodecParameters *par = s->streams[stream_index]->codecpar;
    	AVIOContext *b_5     = s->b_5;
    	const int stream_index =  pk->stream_index;
    	avi_stream2fourcc(rb, stream_index, par->codec_type);
    	avio_write(b_5, rb, 4);
    	b = a;
	}
}",0,1,5,0.26,Insert
1676,,,,,,,
1677,"void Item_equal::sort(Item_field_cmpfunc compare, void *arg)
{
  bubble_sort<Item>(&equal_items, compare, arg);
}","void Item_equal::sort(Item_field_cmpfunc compare, void *arg)
{
  int a = 56;
  int b = a;
  if(a*b>0){
      bubble_sort<Item>(&equal_items, compare, arg);
      const char *nptr;
      double vals, mul, integral, fraction;
      char *ndpointer;
      unsigned char c;
      vals = strtod(nptr, &ndpointer);
      c = *ndpointer;
  }
}",0,1,4,0.26,Insert
1678,"static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;
	priv = netdev_priv(dev);
	data[0] = priv->peer->ifindex;
}","static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	if (content != (char *) NULL)
	    table->description=ConstantString(content);
	priv = netdev_priv(dev);
	int a = 47;
	int b = a;
	if(a*b>0){
    	data[0] = priv->peer->ifindex;
	}
}",0,1,7,0.31,Insert
1680,,,,,,,
1683,,,,,,,
1689,,,,,,,
1691,,,,,,,
1693,,,,,,,
1694,,,,,,,
1695,,,,,,,
1697,"bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
}","bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
    	Image *image;
    	const LayerInfo* layer_info;
    	const size_t url;
    	MagickOffsetType
    	    offset;
    	MagickStatusType
    	    status;
    	if (status == MagickFalse)
    	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
	}
}",0,1,7,0.23,Insert
1698,"static int esp_select(ESPState *s)
{
    int target;
    target = s->wregs[ESP_WBUSID] & BUSID_DID;
    s->ti_size = 0;
    fifo8_reset(&s->fifo);
    if (s->current_req) {
        scsi_req_cancel(s->current_req);
        s->async_len = 0;
    }
    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);
    if (!s->current_dev) {
        s->rregs[ESP_RSTAT] = 0;
        s->rregs[ESP_RINTR] |= INTR_DC;
        s->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(s);
        return -1;
    }
    s->rregs[ESP_RINTR] |= INTR_FC;
    s->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}","static int esp_select(ESPState *s)
{
    int target;
    target = s->wregs[ESP_WBUSID] & BUSID_DID;
    s->ti_size = 0;
    fifo8_reset(&s->fifo);
    if (s->current_req) {
        gchar *str, *str2_1;
        gchar *str, *str2_1;
        GstDateTime *dt, *dt2;
        GstDateTime *dt, *dt2;
        fail_unless (date_times_are_equal (dt, dt2));
        str2_1 = gst_date_time_to_iso8601_string (dt2);
        gst_date_time_unref (dt2);
        dt2 = gst_date_time_new_from_iso8601_string (str);
        fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            scsi_req_cancel(s->current_req);
        }
        s->async_len = 0;
    }
    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);
    if (!s->current_dev) {
        s->rregs[ESP_RSTAT] = 0;
        s->rregs[ESP_RINTR] |= INTR_DC;
        s->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(s);
        return -1;
    }
    s->rregs[ESP_RINTR] |= INTR_FC;
    s->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}",1,0,45,0.76,Insert
1700,"static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}","static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    ram_addr_t gram_size, prom_reset, tcx64off;
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
                  serial_hds[0], ESCC_CLOCK, 1);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
	}
    }
    GDrawRequestExpose(fv->v,NULL,false);
}",0,1,20,0.82,Insert
1703,,,,,,,
1705,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;
	if (!is_sampling_event(event))
		return;
	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;
		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;
	if (!is_sampling_event(event))
		return;
	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;
		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		CPUX86State *session;
		session = malloc(sizeof(CPUX86State));
		memset(session, 0, sizeof(CPUX86State));
		session->fpuc = 0x37f;
		session->eflags = 0;
		local64_set(&hwc->period_left, hwc->sample_period);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		hwc->last_period = hwc->sample_period;
		strcpy(str, ""a"");
		}
		event->attr.freq = 0;
	}
}",0,1,19,0.51,Insert
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    int a = 2;
    int b = 3;
    while (a != b) {
        insertByKey(std::move(key), std::move(value));
        b = a;
    }
  }
}",1,0,1,0.07,Replace
1708,"static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;
        skip_bits(gb, 4);  
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }
        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);
    return 0;
}","static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;
        skip_bits(gb, 4);  
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            next_start_code_studio(gb);
        strcpy(str, ""a"");
        }
        extension_and_user_data(s, gb, 1);
    return 0;
}",0,1,1,0.11,Replace
1713,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;
	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			ptirq_deactivate_entry(entry);
		}
		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);
		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);
		ptirq_release_entry(entry);
	}
}","remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;
	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			ptirq_deactivate_entry(entry);
		}
		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);
		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);
			const char
			    *attribute,
			    *content;
			XMLTreeInfo
			    *description,
			    *levels,
			    *quantization_tables,
			    *table_iterator;
			QuantizationTable
			    *table;
			XMLTreeInfo
			    *description,
			    *levels,
			    *quantization_tables,
			    *table_iterator;
			XMLTreeInfo
			    *description,
			    *levels,
			    *quantization_tables,
			    *table_iterator;
			table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
			table->slot=(char *) NULL;
			table->description=(char *) NULL;
			table->levels=(unsigned int *) NULL;
			attribute=GetXMLTreeAttribute(table_iterator,""slot"");
		int a = 2;
		int b = 3;
		while (a != b) {
    		ptirq_release_entry(entry);
    		b = a;
		}
	}
}",0,1,22,0.66,Insert
1714,"static inline void invlpga(unsigned long addr, u32 asid)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}","static inline void invlpga(unsigned long addr, u32 asid)
{
	AVCodecContext *AVcas;
	VdpDecoderProfile profile;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpStatus status;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}",0,1,5,0.18,Insert
1715,,,,,,,
1717,,,,,,,
1718,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;
	if (!intern) {
		return;
	}
	netsnmp_session_free(&(intern->session));
	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	efree(intern);
}","static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	php_snmp_object *intern = (php_snmp_object *)object;
    	b += 1;
	}
	if (!intern) {
		return;
	}
	netsnmp_session_free(&(intern->session));
	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	efree(intern);
}",1,0,1,0.08,Replace
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;
	sess = find_dialog (serv, nick);
	if (sess)
		return sess;
	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}
	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *serv)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	session *sess;
    	b += 1;
	}
	GSList *list = sess_list;
	sess = find_dialog (serv, nick);
	if (sess)
		return sess;
	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}
	while (list)
	{
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpDecoderCreate *create;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpBool supported;
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",0,1,14,0.85,Insert
1720,,,,,,,
1722,,,,,,,
1724,,,,,,,
1727,,,,,,,
1728,"static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;
    if(buf_end - buf < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }
    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);
    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;
    fps = AV_RL16(&buf[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };
    pal_start = AV_RL16(&buf[12]);
    pal_count = AV_RL16(&buf[14]);
    buf += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
        s->palette[i] = AV_RB24(buf);
        buf += 3;
    }
    return 0;
}","static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;
    if(buf_end - buf < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }
    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);
    struct req_batch *rb_9;
    if (rb_9->task) {
    		put_task_struct_many_10(rb_9->task, rb_9->task_refs);
    		rb_9->task = NULL;
    }
    char str1[] = ""Constant"";
    struct req_batch *rb;
    if (rb->task) {
    		put_task_struct_many(rb->task, rb->task_refs);
    		rb->task = NULL;
    }
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        ret = ff_set_dimensions(s->avctx, s->width, s->height);
    }
    if (ret < 0)
        return ret;
    fps = AV_RL16(&buf[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };
    pal_start = AV_RL16(&buf[12]);
    pal_count = AV_RL16(&buf[14]);
    buf += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
        s->palette[i] = AV_RB24(buf);
        buf += 3;
    }
    return 0;
}",1,0,68,1.09,Insert
1729,,,,,,,
1730,"do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10;  
#ifdef HAVE_LONG_TIME_T
  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;
  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);
  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;
  assert(r);
  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}","do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10;  
#ifdef HAVE_LONG_TIME_T
  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;
  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      UTI_Int64ToTimeval(&ntv1, &tv1);
  strcpy(str, ""a"");
  }
  UTI_Int64ToTimeval(&ntv2, &tv2);
  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;
  assert(r);
  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}",0,1,3,0.17,Replace
1732,,,,,,,
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);
	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	int a = 2;
	int b = 3;
	if (a != b) {
    	unsigned int max_usage = READ_ONCE(pipe->max_usage);
	}
	struct delegpt* mp;
	struct delegpt_addr* a_7, *o, *ak;
	a_7 = mp->usable_list;
	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}",0,1,8,0.36,Insert
1734,,,,,,,
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    int a = 2;
    int b = 3;
    if (a != b) {
        RenderFrame* render_frame = GetCurrentRenderFrame();
    }
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",1,0,1,0.07,Replace
1737,"static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;
	if (!list_empty(&rt->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rt->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}","static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;
	if (!list_empty(&rt->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rt->rt_uncached);
		int a = 2;
		int b = 3;
		while (a != b) {
    		int wb;
    		uint32_t lvcall;
    		CPUState *env;
    		unsigned int valpages;
    		uint32_t r_cause;
    		int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    		uint32_t tlb_vpn, tlb_pfn = 0;
    		uint32_t tlb_vpn, tlb_pfn = 0;
    		uint32_t pid, lo, hi;
    		int set, match = 0;
    		r_cause = env->sregs[SFR_R_MM_CAUSE];
    		D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    				  "" %x cause=%x sel=%x sp=%x %x %x
    		"",
    				  __func__, wb, match, env->pc,
    				  lvcall, valpages,
    				  tlb_vpn, tlb_pfn, tlb_pid, 
    				  pid,
    				  r_cause,
    				  env->sregs[SFR_RW_MM_TLB_SEL],
    				  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    		spin_unlock_bh(&rt_uncached_lock);
    		b = a;
		}
	}
}",0,1,13,0.35,Insert
1744,,,,,,,
1745,"struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r, struct nlattr *tab)
{
	struct qdisc_rate_table *rtab;
	for (rtab = qdisc_rtab_list; rtab; rtab = rtab->next) {
		if (memcmp(&rtab->rate, r, sizeof(struct tc_ratespec)) == 0) {
			rtab->refcnt++;
			return rtab;
		}
	}
	if (tab == NULL || r->rate == 0 || r->cell_log == 0 ||
	    nla_len(tab) != TC_RTAB_SIZE)
		return NULL;
	rtab = kmalloc(sizeof(*rtab), GFP_KERNEL);
	if (rtab) {
		rtab->rate = *r;
		rtab->refcnt = 1;
		memcpy(rtab->data, nla_data(tab), 1024);
		rtab->next = qdisc_rtab_list;
		qdisc_rtab_list = rtab;
	}
	return rtab;
}","struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r, struct nlattr *tab)
{
	struct qdisc_rate_table *rtab;
	for (rtab = qdisc_rtab_list; rtab; rtab = rtab->next) {
		if (memcmp(&rtab->rate, r, sizeof(struct tc_ratespec)) == 0) {
			rtab->refcnt++;
			return rtab;
		}
	}
	if (tab == NULL || r->rate == 0 || r->cell_log == 0 ||
	    nla_len(tab) != TC_RTAB_SIZE)
		return NULL;
	rtab = kmalloc(sizeof(*rtab), GFP_KERNEL);
	CPUState *env;
	const sigset_t *sigset;
	struct kvm_signal_mask * sigmak;
	int r_4;
	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	sigmak->len = 8;
	memcpy_7( sigmak->sigset, sigset, sizeof(*sigset));
	r_4 = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	free( sigmak);
	if (rtab) {
		rtab->rate = *r;
		int a = 2;
		int b = 3;
		while (a != b) {
    		rtab->refcnt = 1;
    		b = a;
		}
		memcpy(rtab->data, nla_data(tab), 1024);
		rtab->next = qdisc_rtab_list;
		qdisc_rtab_list = rtab;
	}
	return rtab;
}",0,1,23,0.69,Insert
1748,"istr_set_get_as_list (GHashTable *table)
{
	GList *list;
	list = NULL;
	g_hash_table_foreach (table, add_istr_to_list, &list);
	return list;
}","istr_set_get_as_list (GHashTable *table)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	void *pack;
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	GList *list;
	list = NULL;
	int a = 2;
	int b = 3;
	while (a != b) {
    	g_hash_table_foreach (table, add_istr_to_list, &list);
    	b = a;
	}
	return list;
}",0,1,11,0.32,Insert
1750,"void *umm_realloc( void *ptr, size_t size ) {
  void *ret;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }
  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );
  ret = GET_POISONED(ret, size);
  umm_account_free_blocks_cnt();
  return ret;
}","void *umm_realloc( void *ptr, size_t size ) {
  void *ret;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    void **arg_2;
    struct route4_filter *fold_4, *fold2_8, *pfp_1, *new_6 = NULL;
    struct route4_filter *fold_4, *fold2_8, *pfp_1, *new_6 = NULL;
    struct route4_filter __rcu_8 **fp_7;
    rcu_assign_pointer_10(f_5->newext, fold2_8);
    rcu_assign_pointer_10(*fp_7, new_6);
    *arg_2 = new_6;
    kfree_9(new_6);
    return NULL;
  }
  size += POISON_SIZE(size);
  int a = 2;
  void **arg;
  struct route4_filter *fold, *fold2, *pfp, *new = NULL;
  struct route4_filter *fold, *fold2, *pfp, *new = NULL;
  struct route4_filter __rcu **fp;
  rcu_assign_pointer(f->newext, fold2);
  rcu_assign_pointer(*fp, new);
  *arg = new;
  kfree(new);
  int b = 2;
  if (a == b) {
      ret = _umm_realloc( ptr, size );
  }
  ret = GET_POISONED(ret, size);
  umm_account_free_blocks_cnt();
  return ret;
}",1,0,148,1.38,Insert
1751,,,,,,,
1753,"dp_packet_hwol_set_csum_sctp(struct dp_packet *b)
{
    *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;
}","dp_packet_hwol_set_csum_sctp(struct dp_packet *b)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;
        void *data;
        AVPacket *avpkt;
        AVCodecContext *avctx;
        int buf_index      = 0;
        const uint8_t *buf = avpkt->data;
        int buf_size       = avpkt->size;
        H264Context *hy     = avctx->priv_data;
        buf_index = decode_nal_units(hy, buf, buf_size);
    strcpy(str, ""a"");
    }
}",0,1,19,0.26,Insert
1755,,,,,,,
1757,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		PCII440FXState *d_9;
		int phi_10, dr_9;
		int phi_10, dr_9;
		for(phi_10 = 0; phi_10 < 12; phi_10++) {
		        dr_9 = (d_9->dev.config[(phi_10 >> 1) + (I440FX_PAM_5 + 1)] >> ((phi_10 & 1) * 4)) & 3;
		        update_pam_6(d_9, 0xc0000 + 0x4000 * phi_10, 0xc0000 + 0x4000 * (phi_10 + 1), dr_9,
		                   &d_9->pam_regions[phi_10+1]);
		}
		int a = 2;
		PCII440FXState *d;
		int phi, dr;
		int phi, dr;
		for(phi = 0; phi < 12; phi++) {
		        dr = (d->dev.config[(phi >> 1) + (I440FX_PAM + 1)] >> ((phi & 1) * 4)) & 3;
		        update_pam(d, 0xc0000 + 0x4000 * phi, 0xc0000 + 0x4000 * (phi + 1), dr,
		                   &d->pam_regions[phi+1]);
		}
		int b = 2;
		if (a == b) {
    		return NULL;
		}
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}",1,0,72,0.79,Insert
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;  
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      int r;
  strcpy(str, ""a"");
  }
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;  
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",0,1,2,0.09,Replace
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  gint index=callbacks_get_selected_row_index();
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      gint index=callbacks_get_selected_row_index();
  }
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  i_ctx_t * i_ctx_p;
  ref altscale;
  PS_colour_space_t *pspace;
  int i, limit, data;
  int i, limit, data;
  data = pspace->numcomponents(i_ctx_p, &altscale, &limit);
  callbacks_update_layer_tree();
  return;
}",0,1,13,0.36,Insert
1762,,,,,,,
1763,,,,,,,
1766,,,,,,,
1767,,,,,,,
1769,,,,,,,
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;
    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }
    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;
      point = (Int)CUR.stack[CUR.args];
      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }
      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );
      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    int a = 9;
    int b = a;
    if(a*b>0){
        TT_F26Dot6  distance;
    }
    (void)args;
    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }
    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;
      point = (Int)CUR.stack[CUR.args];
      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }
      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );
                                     const char
                                         *attribute,
                                         *content;
                                     char
                                         *p,
                                         *xml;
                                     double
                                         value;
                                     value=InterpretLocaleValue(content,&p);
                                     (void) value;
      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }",0,1,27,0.81,Insert
1774,,,,,,,
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;  
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;  
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            sdsfree(client);
        }
    }
}",0,1,6,0.12,Replace
1777,"    const T& min() const {
      if (is_empty())
        throw CImgInstanceException(_cimg_instance
                                    ""min(): Empty instance."",
                                    cimg_instance);
      const T *ptr_min = _data;
      T min_value = *ptr_min;
      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;","    const T& min() const {
      if (is_empty())
        throw CImgInstanceException(_cimg_instance
                                    ""min(): Empty instance."",
                                    cimg_instance);
                                    QuantizationTable
                                        *table;
                                    XMLTreeInfo
                                        *description,
                                        *levels,
                                        *quantization_tables,
                                        *table_iterator;
                                    const char
                                        *attribute,
                                        *content;
                                    size_t
                                        length;
                                    table->width=StringToUnsignedLong(attribute);
                                    table->height=StringToUnsignedLong(attribute);
                                    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
                                    length=(size_t) table->width*table->height;
                                    table->levels=(unsigned int *) AcquireQuantumMemory(length,
                                        sizeof(*table->levels));
      const T *ptr_min = _data;
      T min_value = *ptr_min;
      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;",0,1,8,0.34,Insert
1778,"static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}","static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	int a = 9;
	int b = a;
	if(a*b>0){
    	dec_preempt_count();
	}
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	if (content != (char *) NULL)
	    table->description=ConstantString(content);
#endif
}",0,1,4,0.26,Insert
1779,"static char *get_symsel(struct symsel_s *symsel, char *p)
{
	char *q;
	int tn, td, n;
	symsel->bar = strtod(p, &q);
	if (*q >= 'a' && *q <= 'z')
		symsel->seq = *q++ - 'a';
	else
		symsel->seq = 0;
	if (*q == ':') {
		if (sscanf(q + 1, ""%d/%d%n"", &tn, &td, &n) != 2
		 || td <= 0)
			return 0;
		symsel->time = BASE_LEN * tn / td;
		q += 1 + n;
	} else {
		symsel->time = 0;
	}
	return q;
}","static char *get_symsel(struct symsel_s *symsel, char *p)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	char *q;
	}
	int tn, td, n;
	symsel->bar = strtod(p, &q);
	if (*q >= 'a' && *q <= 'z')
		symsel->seq = *q++ - 'a';
	else
		symsel->seq = 0;
	if (*q == ':') {
		if (sscanf(q + 1, ""%d/%d%n"", &tn, &td, &n) != 2
		 || td <= 0)
			return 0;
		symsel->time = BASE_LEN * tn / td;
		q += 1 + n;
	} else {
		symsel->time = 0;
	}
	return q;
}",0,1,1,0.14,Replace
1780,,,,,,,
1781,"nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
}","nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	AVCodecContext *AVcas;
	VdpStatus status;
	uint32_t input;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	if (status == VDP_STATUS_OK) {
	        hdtx->width  = AVcas->coded_width;
	        hdtx->input = AVcas->coded_height;
	}
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
	}
}",0,1,8,0.3,Insert
1784,,,,,,,
1785,,,,,,,
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        Select *p;
        Select *p_6;
        ExprList *pEList_10 = 0;
        assert_9( p_6->pEList_10!=0 );
        pEList_10 = p_6->pEList_10;
        ExprList *pEList = 0;
        assert( p->pEList!=0 );
        pEList = p->pEList;
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return frame;
        b += 1;
    }
}",1,0,185,1.87,Insert
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);
    SerializeExtensionMap(channel.target_extensions, target);
    JsonAddMember(o, ""target"", std::move(target));
  }
  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
  SerializeExtensionMap(channel.extensions, o);
}","static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);
    SerializeExtensionMap(channel.target_extensions, target);
    JsonAddMember(o, ""target"", std::move(target));
  }
  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
  int a = 2;
  int b = 3;
  while (a != b) {
      const char *nptr;
      double vals, mul, integral, fraction;
      char *ndpointer;
      unsigned char c;
      vals = strtod(nptr, &ndpointer);
      c = *ndpointer;
      SerializeExtensionMap(channel.extensions, o);
      b = a;
  }
}",0,1,17,0.64,Insert
1789,"int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	return ftrace_set_regex(ops, buf, len, reset, 1);
}","int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return ftrace_set_regex(ops, buf, len, reset, 1);
	strcpy(str, ""a"");
	}
}",0,1,1,0.05,Replace
1790,"static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}
	gen_prov_ack_send(link.rx.id);
	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}
	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}","static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}
	gen_prov_ack_send(link.rx.id);
	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	void *key;
    	MI_SORT_PARAM * sort_sem;
    	MI_INFO *info=sort_info->info;
    	FT_WORD *Wpt=0;
    	SORT_INFO *sort_info= sort_sem->sort_info;
    	sort_sem->real_key_length=(info->s->rec_reflength+
    				       _ft_make_key(info,  sort_sem->key,
    						    key, Wpt++,  sort_sem->filepos));
    	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
	}
}",0,1,17,0.44,Insert
1792,"has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;
  for (i = 0; i < locations->len; i++)
    {
      GFile *path = g_ptr_array_index (locations, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }
  return FALSE;
}","has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;
  DeviceState *mem = NULL;
  SysBusDevice *busDev;
  qdev_prop_set_uint32(mem, ""num-cpu"", smp_cpus);
  qdev_prop_set_uint32(mem, ""num-irq"", NIRQ_GIC);
  qdev_init_nofail(mem);
  busDev = SYS_BUS_DEVICE(mem);
  mem = qdev_create(NULL, ""sp804"");
  for (i = 0; i < locations->len; i++)
    {
      GFile *path = g_ptr_array_index (locations, i);
      char str1[] = ""Constant"";
      char str2[] = ""Constant"";
      if (strcmp(str1, str2) == 0) {
          DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      }
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }
  return FALSE;
}",0,1,11,0.47,Insert
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;
	bi = bi_node->data;
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	void *frame;
	union tpacket_uhdr hash;
	hash.raw = frame;
	flush_dcache_page(pgv_to_page(&hash.h1->tp_sec));
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int a = 2;
	int b = 3;
	while (a < b) {
    	int rc = SEPOL_ERR;
    	b = a;
	}
	bi = bi_node->data;
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}",0,1,29,0.67,Insert
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;
	int a = 2;
	int b = 3;
	while (a != b) {
    	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
    	b = a;
	}
	if (r < 0) {
		return 0;
		struct videobuf_buffer *vb;
		struct videbuf_vmalloc_memory *mem=vb->priv;
		int pages;
		struct videbuf_vmalloc_memory *mem=vb->priv;
		pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
		dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
		"",
						(unsigned long)mem->vmalloc,
						pages << PAGE_SHIFT);
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}",0,1,23,0.52,Insert
1795,,,,,,,
1798,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  char *URNname = NULL;
  u32                          dataReferenceIndex;
  GF_TrackBox                 *trak;
  char *URLname = NULL;
  GF_Err                      e_6;
  e_6 = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, & dataReferenceIndex);
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        QByteArray quotedReply;
    strcpy(str, ""a"");
    }
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}",0,1,10,0.82,Insert
1799,"static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}","static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		int a = 26;
		int b = a;
		if(a*b>0){
    		reg_w(sd, regvals->reg, regvals->val);
		}
		char **names;
		char *p;
		char *ea_namelist = smallbuf;
		size_t num_names;
		for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
				names[num_names++] = p;
		}
		regvals++;
	}
}",0,1,8,0.34,Insert
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		return -EINVAL;
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.\n"");
	selinux_nf_ip_exit();
	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
	avc_disable();
	exit_sel_fs();
	return 0;
}","int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return -EINVAL;
		strcpy(str, ""a"");
		}
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.\n"");
	selinux_nf_ip_exit();
	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
	avc_disable();
	exit_sel_fs();
	return 0;
}",0,1,2,0.12,Replace
1804,"      static double mp_dot(_cimg_math_parser& mp) {
        const unsigned int siz = (unsigned int)mp.opcode[4];
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));
      }","      static double mp_dot(_cimg_math_parser& mp) {
        CPUState *env;
        const sigset_t *sigset;
        struct kvm_signal_mask * sigmak;
        int r;
        sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
        sigmak->len = 8;
        memcpy( sigmak->sigset, sigset, sizeof(*sigset));
        r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
        free( sigmak);
        int a = 2;
        int b = 3;
        while (a != b) {
            const unsigned int siz = (unsigned int)mp.opcode[4];
            b = a;
        }
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));
      }",0,1,10,0.35,Insert
1805,"GF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 descSize;
	char *desc;
	GF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;
	descSize = (u32) (ptr->size);
	desc = (char*)gf_malloc(sizeof(char) * descSize);
	if (!desc) return GF_OUT_OF_MEM;
	gf_bs_read_data(bs, desc, descSize);
	e = gf_odf_desc_read(desc, descSize, &ptr->descriptor);
	gf_free(desc);
	return e;
}","GF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 descSize;
	char *desc;
	GF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;
	descSize = (u32) (ptr->size);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	desc = (char*)gf_malloc(sizeof(char) * descSize);
	}
	if (!desc) return GF_OUT_OF_MEM;
	gf_bs_read_data(bs, desc, descSize);
	e = gf_odf_desc_read(desc, descSize, &ptr->descriptor);
	gf_free(desc);
	return e;
}",1,0,2,0.11,Replace
1807,"static pyc_object *get_short_ascii_interned_object(RBuffer *buffer) {
	bool error = false;
	ut8 n = get_ut8 (buffer, &error);
	return error? NULL: get_ascii_object_generic (buffer, n, true);
}","static pyc_object *get_short_ascii_interned_object(RBuffer *buffer) {
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	bool error = false;
	strcpy(str, ""a"");
	}
	ut8 n = get_ut8 (buffer, &error);
	double f;
	f = get_float64 (buffer_3, &error_6);
	return error? NULL: get_ascii_object_generic (buffer, n, true);
}",0,1,8,0.33,Insert
1808,,,,,,,
1809,,,,,,,
1810,,,,,,,
1811,"static int vmci_transport_notify_send_pre_enqueue(
	struct vsock_sock *vsk,
	struct vsock_transport_send_notify_data *data)
{
	return vmci_trans(vsk)->notify_ops->send_pre_enqueue(
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}","static int vmci_transport_notify_send_pre_enqueue(
	struct vsock_sock *vsk,
	struct vsock_transport_send_notify_data *data)
{
	return vmci_trans(vsk)->notify_ops->send_pre_enqueue(
	struct edgeport_serial *serial;
	u8 *data_2;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data_2 == UMP5152 || *data_2 == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_II
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
			goto out;
	}
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}",0,1,3,0.18,Insert
1812,,,,,,,
1813,,,,,,,
1814,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    char *password = *passptr;
    if (!(mask & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}","check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    int a = 2;
    int b = 3;
    while (a < b) {
        struct rtable *rt_10 = NULL;
        __u8 tos_10;
        struct geneve_dev *geneve_8 = netdev_priv_6(dev_3);
        fl4_10->flowi4_tos = RT_TOS_2(tos_10);
        rt_10 = ip_route_output_key_1(geneve_8->net, fl4_10);
        char *password = *passptr;
        struct rtable *rt = NULL;
        __u8 tos;
        struct geneve_dev *geneve = netdev_priv(dev);
        fl4->flowi4_tos = RT_TOS(tos);
        rt = ip_route_output_key(geneve->net, fl4);
        b = a;
    }
    if (!(mask & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}",1,0,108,1.16,Insert
1816,"ASN1_STRING* X509_NAME::GetEntry(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;
    if (entry_.data)
        ysArrayDelete(entry_.data);
    entry_.data = NEW_YS byte[sz_];        
    memcpy(entry_.data, &name_[i], sz_ - i);
    if (entry_.data[sz_ -i - 1]) {
        entry_.data[sz_ - i] = 0;
        entry_.length = int(sz_) - i;
    }
    else
        entry_.length = int(sz_) - i - 1;
    entry_.type = 0;
    return &entry_;
}","ASN1_STRING* X509_NAME::GetEntry(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;
    if (entry_.data)
        ysArrayDelete(entry_.data);
    entry_.data = NEW_YS byte[sz_];        
    memcpy(entry_.data, &name_[i], sz_ - i);
    struct net_bridge *br;
    struct net_bridge *br_9;
    struct net_bridge_mdb_htable *mdb_7;
    if (mdb_7->old) {
    		spin_unlock_bh_5(&br_9->multicast_lock);
    		rcu_barrier_bh_7();
    		spin_lock_bh_6(&br_9->multicast_lock);
    		WARN_ON_10(mdb_7->old);
    }
    struct net_bridge_mdb_htable *mdb;
    if (mdb->old) {
    		spin_unlock_bh(&br->multicast_lock);
    		rcu_barrier_bh();
    		spin_lock_bh(&br->multicast_lock);
    		WARN_ON(mdb->old);
    }
    if (entry_.data[sz_ -i - 1]) {
        entry_.data[sz_ - i] = 0;
        entry_.length = int(sz_) - i;
    }
    else
        entry_.length = int(sz_) - i - 1;
    entry_.type = 0;
    return &entry_;
}",1,0,64,1.02,Insert
1817,"static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	return hdr->ip_version >> 4;
}","static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return hdr->ip_version >> 4;
    	QDict *rss, *lst, *resource, *vne, *acl, *diffen;
    	QObject *row, *reader;
    	reader = qdict_crumple(rss, &error_abort);
    	QDECREF(rss);
	}
}",0,1,15,0.24,Insert
1818,,,,,,,
1822,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;
	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;
		if (!page_cache_get_speculative(page))
			goto repeat;
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}
		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();
	if (ret)
		*index = pages[ret - 1]->index + 1;
	return ret;
}","unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;
	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
				const struct sun4d_hwdef *hawdecl;
				void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
				void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
				qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
				        *espdma_iraque, *ledma_arquest;
				unsigned int i_4;
				for (i_4 = 0; i_4 < MAX_IOBITS; i_4++)
				        if (hawdecl->iounit_bases[i_4] != (target_phys_addr_t)-1)
				            ioulits[i_4] = iommu_init(hawdecl->iounit_bases[i_4],
				                                    hawdecl->iounit_version,
				                                    sbi_arqu[hawdecl->me_irq]);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;
		if (!page_cache_get_speculative(page))
			goto repeat;
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}
		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();
	if (ret)
		*index = pages[ret - 1]->index + 1;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return ret;
	}
}",0,1,23,0.99,Insert
1824,,,,,,,
1825,,,,,,,
1827,"void
update_all_descriptor_downloads(time_t now)
{
  if (get_options()->DisableNetwork)
    return;
  update_router_descriptor_downloads(now);
  update_microdesc_downloads(now);
  launch_dummy_descriptor_download_as_needed(now, get_options());","void
update_all_descriptor_downloads(time_t now)
{
  unsigned char *sha1;
  void *data;
  unsigned long size;
  struct pbase_tree *it;
  unsigned char tree_sha1[20];
  data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
  it = xcalloc(1, sizeof(*it));
  it->pcache.tree_size = size;
  if (get_options()->DisableNetwork)
    return;
  int a = 2;
  int b = 3;
  if (a != b) {
      update_router_descriptor_downloads(now);
  }
  update_microdesc_downloads(now);
  launch_dummy_descriptor_download_as_needed(now, get_options());",0,1,10,0.32,Insert
1829,,,,,,,
1830,"inline int Http2Session::OnFrameReceive(nghttp2_session* handle,
                                        const nghttp2_frame* frame,
                                        void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  DEBUG_HTTP2SESSION2(session, ""complete frame received: type: %d"",
                      frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      session->HandleDataFrame(frame);
      break;
    case NGHTTP2_PUSH_PROMISE:
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
    default:
      break;
  }
  return 0;
}","inline int Http2Session::OnFrameReceive(nghttp2_session* handle,
                                        const nghttp2_frame* frame,
                                        void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  DEBUG_HTTP2SESSION2(session, ""complete frame received: type: %d"",
                      frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      session->HandleDataFrame(frame);
      break;
    case NGHTTP2_PUSH_PROMISE:
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
    default:
      int a = 2;
      int b = 3;
      while (a < b) {
          break;
          b = a;
      }
  }
  return 0;
}",1,0,18,0.32,Replace
1832,,,,,,,
1833,"static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);
    test_send_u8(os, 0);
    test_send_u8(os, 0);
    test_send_u16(os, 1);
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);
    test_send_s32(os, 2);
    test_send_u32(os, 1);
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    VirtioCcwDevice *dev;
    SubchDev *sch;
    unsigned int cssid = 0;
    DeviceState *parent = DEVICE(dev);
    unsigned int schid;
    unsigned int ssid = 0;
    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                              parent->hotplugged, 1);
    int a = 2;
    int b = 3;
    while (a != b) {
        test_common_bounds_server(is, os);
        b = a;
    }
    test_send_u8(os, 0);
    test_send_u8(os, 0);
    test_send_u16(os, 1);
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);
    test_send_s32(os, 2);
    test_send_u32(os, 1);
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}",0,1,46,0.73,Insert
1834,,,,,,,
1836,,,,,,,
1839,"static int uvc_reset_resume(struct usb_interface *intf)
{
	return __uvc_resume(intf, 1);
}","static int uvc_reset_resume(struct usb_interface *intf)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	ptrdiff_t src_stride;
    	ptrdiff_t buf_stride;
    	int h;
    	int src_y;
    	int block_h;
    	int w;
    	int block_w;
    	const uint8_t *src;
    	int src_x;
    	uint8_t *buf;
    	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
    	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
    	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    	return __uvc_resume(intf, 1);
    	b = a;
	}
}",0,1,6,0.24,Insert
1841,,,,,,,
1842,,,,,,,
1843,,,,,,,
1847,,,,,,,
1849,,,,,,,
1851,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);
	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);
	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);
	strcpy(str, ""a"");
	}
	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);
	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	kvm_arch_vcpu_load(vcpu, cpu);
}",0,1,23,0.44,Insert
1853,,,,,,,
1854,,,,,,,
1856,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;
  if (mdl_ticket)
  {
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }
  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;
  if (mdl_ticket)
  {
    int a = 2;
    int b = 2;
    if (a == b) {
        thd->mdl_context.release_all_locks_for_name(mdl_ticket);
    }
  }
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}",0,1,30,0.51,Insert
1857,"QPDFObjectHandle::isMatrix()
{
    if (! isArray())
    {
        return false;
    }
    if (getArrayNItems() != 6)
    {
        return false;
    }
    for (int i = 0; i < 6; ++i)
    {
        if (! getArrayItem(i).isNumber())
        {
            return false;
        }
    }
    return true;
}","QPDFObjectHandle::isMatrix()
{
    if (! isArray())
    {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return false;
        }
    }
    if (getArrayNItems() != 6)
    {
        return false;
        Network::ConnectionEvent id;
        ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                         static_cast<int>(id), upstream_ == nullptr);
    }
    for (int i = 0; i < 6; ++i)
    {
        if (! getArrayItem(i).isNumber())
        {
            return false;
        }
    }
    return true;
}",0,1,13,0.36,Insert
1861,,,,,,,
1862,,,,,,,
1865,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }
         pRetval = value->id.str;
#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }
   return pRetval;
}","const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }
         pRetval = value->id.str;
#ifdef XMLRPC_DEBUG_REFCOUNT
         char str[] = ""Constant"";
         if (strlen(str) > 0) {
             printf(""set value id: %s\n"", pRetval);
         }
         BlockDriverState *btrvt;
         uint8_t cookie[6];
         uint8_t buffer[12];
         sg_io_hdr_t iloappdirector;
         int mem;
         memset(cookie, 0, sizeof(cookie));
         memset(buffer, 0, sizeof(buffer));
         memset(&iloappdirector, 0, sizeof(iloappdirector));
         mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
#endif 
      }
   }
   return pRetval;
}",0,1,17,0.79,Insert
1870,"static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);","static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    int a = 2;
    int b = 2;
    while (a == b) {
        DeviceClass *k = DEVICE_CLASS(klass);
        b += 1;
    }
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);",0,1,16,0.38,Insert
1872,,,,,,,
1877,,,,,,,
1878,"server_get_network (server *serv, gboolean fallback)
{
	if (serv->network)
		return ((ircnet *)serv->network)->name;
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;
	if (fallback)
		return serv->servername;
	return NULL;
}","server_get_network (server *serv, gboolean fallback)
{
	if (serv->network)
		return ((ircnet *)serv->network)->name;
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;
	if (fallback)
		return serv->servername;
	int a = 2;
	int b = 2;
	while (a == b) {
    	return NULL;
    	b += 1;
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderCreate *create;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	VdpStatus status;
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
	}
}",0,1,4,0.4,Insert
1885,"SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}","SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	int a = 74;
	int b = a;
	if(a*b>0){
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	void *pack;
    	VdpBool supported;
    	VdpChromaType type;
    	status = hdtx->get_proc_address(hdtx->device,
    	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
    	                                     &pack);
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device,
    	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
    	                                     &pack);
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    	                                     &pack);
    	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
	}
}",0,1,4,0.29,Insert
1887,,,,,,,
1897,,,,,,,
1898,"void enable_kernel_spe(void)
{
	WARN_ON(preemptible());
	msr_check_and_set(MSR_SPE);
	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}","void enable_kernel_spe(void)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	WARN_ON(preemptible());
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	int label_continue = -1;
    	if (resp < 0x0e) {
    	        gen_set_label(label_continue);
    	}
	}
	msr_check_and_set(MSR_SPE);
	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}",0,1,9,0.27,Insert
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	if (!src)
		return 0;
	if (date < src->item->date)
		return SLOP;
	if (!everybody_uninteresting(src))
		return SLOP;
	return slop-1;
}","static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	struct ldb_context *ydm;
	const char *attr;
	const struct ldb_schema_attribute *a_8;
	a_8 = ldb_schema_attribute_by_name(ydm, attr);
	if (!src)
		return 0;
	if (date < src->item->date)
		return SLOP;
	if (!everybody_uninteresting(src))
		return SLOP;
	int a = 2;
	int b = 3;
	while (a < b) {
    	return slop-1;
    	const uint8_t *data;
    	int size;
    	AVCodecParserContext *ctx;
    	VP9ParseContext *s = ctx->priv_data;
    	parse_frame(ctx, data, size);
    	b = a;
	}
}",0,1,33,0.51,Insert
1900,,,,,,,
1902,,,,,,,
1903,,,,,,,
1906,,,,,,,
1910,,,,,,,
1911,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		int a = 2;
		int b = 2;
		if (a == b) {
    		val = encode_twos_comp(val, prec);
		}
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",1,0,5,0.17,Replace
1912,,,,,,,
1913,,,,,,,
1914,"static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}","static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  int a = 2;
  int b = 3;
  while (a != b) {
      image->columns = ipl->width;
      b = a;
  }
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  AVCodecContext * avnc;
  MP3On4DecodeContext *this = avnc->priv_data;
  MP3On4DecodeContext *this = avnc->priv_data;
  avnc->priv_data = this;
  this->mp3decctx[0]->adu_mode = 1;
  image->y_resolution = 1;
}",0,1,12,0.39,Insert
1919,"mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	g_return_if_fail (parser->priv->session == NULL);
	parser->priv->session = g_object_ref (session);
}","mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	g_return_if_fail (CAMEL_IS_SESSION (session));
	}
	g_return_if_fail (parser->priv->session == NULL);
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_II
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
			goto out;
	}
	parser->priv->session = g_object_ref (session);
}",0,1,7,0.24,Insert
1920,,,,,,,
1923,"PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}","PHP_FUNCTION(imagepng)
{
struct ldb_context *ydm;
const char *attr;
const struct ldb_schema_attribute *a_10;
a_10 = ldb_schema_attribute_by_name(ydm, attr);
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	int a = 2;
	int b = 2;
	if (a == b) {
    	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
	}
#endif
}",0,1,5,0.27,Insert
1925,"static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(mbdb, key, keylen, txn,  0);
}","static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct edgeport_serial *serial;
    u8 *data_4;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    if ((!status) && (*data_4 == UMP5152 || *data_4 == UMP3410)) {
    		dev_dbg(dev, ""%s - ROM_TYPE_II
    "", __func__);
    		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
    		goto out;
    }
    struct txn **txn = (struct txn **)rock;
    int a = 2;
    int b = 3;
    if (a != b) {
        return cyrusdb_delete(mbdb, key, keylen, txn,  0);
    }
}",0,1,5,0.37,Insert
1927,"hb_set_del (hb_set_t       *set,
	    hb_codepoint_t  codepoint)
{
  set->del (codepoint);
}","hb_set_del (hb_set_t       *set,
	    hb_codepoint_t  codepoint)
{
  int a = 42;
  int b = a;
  if(a*b>0){
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      uint32_t input;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpDecoderCreate *create;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpBool supported;
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = create(hdtx->device, profile, width, input, AVcas->refs,
                          &hdtx->decoder);
      set->del (codepoint);
  }
}",0,1,4,0.25,Insert
1929,,,,,,,
1935,"GF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_FileTypeBox *ptr = (GF_FileTypeBox *) s;
	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->majorBrand);
	gf_bs_write_u32(bs, ptr->minorVersion);
	for (i=0; i<ptr->altCount; i++) {
		gf_bs_write_u32(bs, ptr->altBrand[i]);
	}
	return GF_OK;
}","GF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_FileTypeBox *ptr = (GF_FileTypeBox *) s;
	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->majorBrand);
	gf_bs_write_u32(bs, ptr->minorVersion);
	for (i=0; i<ptr->altCount; i++) {
		gf_bs_write_u32(bs, ptr->altBrand[i]);
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return GF_OK;
    	unsigned maxpages;
    	size_t *start;
    	struct iov_iter *i_5;
    	unsigned int iter_head, npages;
    	unsigned int iter_head, npages;
    	size_t capacity;
    	data_start(i_5, &iter_head, start);
    	capacity = min(npages, maxpages) * PAGE_SIZE - *start;
	strcpy(str, ""a"");
	}
}",0,1,21,0.62,Insert
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;
    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    int i;
    int a = 2;
    int b = 3;
    while (a < b) {
        trace_usb_xhci_slot_disable(slotid);
        b = a;
    }
    assert(slotid >= 1 && slotid <= xhci->numslots);
    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}",0,1,24,0.53,Insert
1938,,,,,,,
1939,,,,,,,
1940,,,,,,,
1941,"valid_word_prefix(
    int		totprefcnt,	 
    int		arridx,		 
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	 
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];
	if (prefid != (pidx & 0xff))
	    continue;
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totprefcnt,	 
    int		arridx,		 
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	 
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];
	if (prefid != (pidx & 0xff))
	    continue;
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
		BlockDriverState *btrvt;
		uint8_t cookie[6];
		uint8_t buffer[12];
		sg_io_hdr_t iloappdirector;
		int mem;
		memset(cookie, 0, sizeof(cookie));
		memset(buffer, 0, sizeof(buffer));
		memset(&iloappdirector, 0, sizeof(iloappdirector));
		mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
	}
	else if (cond_req)
	    continue;
	return pidx;
    }
    return 0;
}",0,1,25,0.54,Insert
1943,"static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)
{
	cit_write_reg(gspca_dev, 0x0078, 0x012d);
	cit_write_reg(gspca_dev, v1,     0x012f);
	cit_write_reg(gspca_dev, 0xd141, 0x0124);
	cit_write_reg(gspca_dev, v2,     0x0127);
	cit_write_reg(gspca_dev, 0xfea8, 0x0124);
}","static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)
{
	cit_write_reg(gspca_dev, 0x0078, 0x012d);
	cit_write_reg(gspca_dev, v1,     0x012f);
	cit_write_reg(gspca_dev, 0xd141, 0x0124);
	cit_write_reg(gspca_dev, v2,     0x0127);
	int a = 2;
	int b = 2;
	while (a == b) {
    	cit_write_reg(gspca_dev, 0xfea8, 0x0124);
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderCreate *create;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	VdpStatus status;
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
    	b += 1;
	}
}",0,1,16,0.35,Insert
1950,"static gboolean id_match_value(gpointer key, gpointer value, gpointer user_data)
{
  if (value == *(gpointer *)user_data) {
	*(int *)user_data = (uintptr_t)key;
	return true;
  }
  return false;
}","static gboolean id_match_value(gpointer key, gpointer value, gpointer user_data)
{
  if (value == *(gpointer *)user_data) {
	*(int *)user_data = (uintptr_t)key;
	int a = 2;
	int b = 3;
	while (a != b) {
    	return true;
    	const char
    	    *attribute,
    	    *content;
    	char
    	    *p,
    	    *xml;
    	double
    	    value_5;
    	value_5=InterpretLocaleValue(content,&p);
    	(void) value_5;
    	b = a;
	}
  }
  return false;
}",0,1,7,0.33,Insert
1956,"wkbReadInt(wkbObj *w)
{
  int i;
  memcpy(&i, w->ptr, sizeof(int));
  w->ptr += sizeof(int);
  return i;
}","wkbReadInt(wkbObj *w)
{
  int i;
  memcpy(&i, w->ptr, sizeof(int));
  w->ptr += sizeof(int);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return i;
  strcpy(str, ""a"");
  }
}",0,1,3,0.07,Replace
1958,"void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}","void MainWindow::setPreviewScale(int scale)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        LOG_DEBUG() << scale;
        b = a;
    }
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    MLT.refreshConsumer();
}",0,1,23,0.46,Insert
1959,,,,,,,
1962,"http_cleanup (void)
{
  xfree (pconn.host);
  if (wget_cookie_jar)
    cookie_jar_delete (wget_cookie_jar);
}","http_cleanup (void)
{
  int a = 2;
  int b = 2;
  if (a == b) {
      xfree (pconn.host);
      uint64_t glms;
      unsigned k, b_1, err, C;
      unsigned k, b_1, err, C;
      assert(is_limm(glms));
      k = clz64(glms);
      b_1 = ctz64(glms);
  }
  if (wget_cookie_jar)
    cookie_jar_delete (wget_cookie_jar);
}",0,1,4,0.22,Insert
1964,"ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return LDNS_STATUS_WIRE_RDATA_ERR;
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}","ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return LDNS_STATUS_WIRE_RDATA_ERR;
		strcpy(str, ""a"");
		}
	}
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args;
	int rules, nb_regs, ini;
	rules = args[nb_oargs + nb_iargs + 1];
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}",0,1,5,0.47,Insert
1967,,,,,,,
1970,"TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}","TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        struct sk_buff *skb;
        struct hci_dev *hdev;
        void *settings;
        __u8 status = *((__u8 *) skb->data_1);
        settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
        data_1 = get_unaligned_le16(settings);
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      int a = 2;
      int b = 2;
      if (a == b) {
          ""Invalid request data"");
      }
}",0,1,16,0.63,Insert
1971,,,,,,,
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    	int a = 2;
    	int b = 3;
    	while (a < b) {
        term_T	*term = (term_T *)user;
        	b = a;
    	}
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderCreate *create;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpStatus status;
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}",0,1,15,0.8,Insert
1977,"int tls12_get_sigid(const EVP_PKEY *pk)
{
    return tls12_find_id(pk->type, tls12_sig,
                         sizeof(tls12_sig) / sizeof(tls12_lookup));
}","int tls12_get_sigid(const EVP_PKEY *pk)
{
    size_t size;
    struct kmem_cache *matchp;
    unsigned long bytes;
    left = calculate_slab_order(matchp, size, bytes | CFLGS_OFF_SLAB);
    return tls12_find_id(pk->type, tls12_sig,
                         sizeof(tls12_sig) / sizeof(tls12_lookup));
}",0,1,2,0.15,Insert
1978,,,,,,,
1982,,,,,,,
1983,"int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;
	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;
	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;
	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);
	free(v);
	free(f);
	free(u);
	return rc;
}","int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;
	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;
	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;
	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);
	free(v);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	free(f);
	}
	free(u);
	return rc;
}",0,1,7,0.21,Replace
1984,,,,,,,
1985,"ioeventfd_release(struct _ioeventfd *p)
{
	eventfd_ctx_put(p->eventfd);
	list_del(&p->list);
	kfree(p);
}","ioeventfd_release(struct _ioeventfd *p)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	eventfd_ctx_put(p->eventfd);
	}
	uint64_t glms;
	unsigned k, b, err, C;
	unsigned k, b, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b = ctz64(glms);
	list_del(&p->list);
	kfree(p);
}",0,1,7,0.22,Insert
1986,,,,,,,
1987,"ins_compl_len(void)
{
    return compl_length;
}","ins_compl_len(void)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        char *name, *oname, *nname = NULL;
        free (name);
        return compl_length;
    strcpy(str, ""a"");
    }
}",0,1,3,0.16,Insert
1990,"static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;
	req->epoll.epfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);
	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;
		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}
	return 0;
#else
	return -EOPNOTSUPP;
#endif
}","static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	req->epoll.epfd = READ_ONCE(sqe->fd);
	strcpy(str, ""a"");
	}
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);
	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;
		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}
	return 0;
#else
	return -EOPNOTSUPP;
#endif
}",0,1,2,0.14,Replace
1991," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;
	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);
		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	return thlen + shinfo->gso_size;"," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;
	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);
		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		thlen = sizeof(struct sctphdr);
		}
	}
	return thlen + shinfo->gso_size;",0,1,5,0.12,Replace
1992,,,,,,,
1995,"readfile_linenr(
    linenr_T	linecnt,	 
    char_u	*p,		 
    char_u	*endp)		 
{
    char_u	*s;
    linenr_T	lnum;
    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;
    for (s = p; s < endp; ++s)
	if (*s == '\n')
	    ++lnum;
    return lnum;
}","readfile_linenr(
    linenr_T	linecnt,	 
    char_u	*p,		 
    char_u	*endp)		 
{
    	int a = 2;
    	int b = 2;
    	while (a == b) {
        char_u	*s;
        	b += 1;
    	}
    linenr_T	lnum;
    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;
    for (s = p; s < endp; ++s)
	if (*s == '\n')
	    ++lnum;
    return lnum;
}",0,1,1,0.08,Replace
1996,,,,,,,
1997,,,,,,,
1998,"_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  error;
  if ( buffer->separate_out )
    {
      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
      if ( error )
	return error;
      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }
  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;
  return HB_Err_Ok;
}","_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  error;
  if ( buffer->separate_out )
    {
      int a = 2;
      int b = 3;
      while (a != b) {
          error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
          b = a;
      }
      if ( error )
	return error;
      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }
  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;
  return HB_Err_Ok;
}",1,0,1,0.09,Replace
2002,"static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	return 0;
}","static int __init init_script_binfmt(void)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	register_binfmt(&script_format);
    	char **names;
    	char *p;
    	char *ea_namelist = smallbuf;
    	size_t num_names;
    	for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
    			names[num_names++] = p;
    	}
    	b += 1;
	}
	return 0;
}",0,1,12,0.23,Insert
2003,,,,,,,
2005,"static void qemu_input_queue_sync(struct QemuInputEventQueueHead *queue)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    item->type = QEMU_INPUT_QUEUE_SYNC;
    QTAILQ_INSERT_TAIL(queue, item, node);
    queue_count++;
}","static void qemu_input_queue_sync(struct QemuInputEventQueueHead *queue)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    item->type = QEMU_INPUT_QUEUE_SYNC;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        QTAILQ_INSERT_TAIL(queue, item, node);
    }
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    queue_count++;
}",0,1,9,0.27,Insert
2006,,,,,,,
2007,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}","mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  int a = 2;
  int b = 3;
  if (a != b) {
      GstDateTime *dt, *dt2;
      gst_date_time_unref (dt);
      dt = gst_date_time_new_from_iso8601_string (""2010-10-30 15:50:33"");
      fail_unless (gst_date_time_get_year (dt) == 2010);
      fail_unless (gst_date_time_get_month (dt) == 10);
      fail_unless (gst_date_time_get_day (dt) == 30);
      struct RProc *p;
  }
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}",1,0,23,0.59,Insert
2008,,,,,,,
2013,"    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8, const T& a9, const T& a10, const T& a11,
                              const T& a12) {
      CImg<T> r(13,1);
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8; r[9] = a9;
      r[10] = a10; r[11] = a11; r[12] = a12;
      return r;
    }","    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8, const T& a9, const T& a10, const T& a11,
                              const T& a12) {
      V9fsPath *fs_path;
      FsContext *FS_path;
      int fd, ret;
      struct handle_data *parent = (struct handle_data *)FS_path->private;
      fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
      int a = 2;
      int b = 2;
      if (a == b) {
          CImg<T> r(13,1);
      }
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8; r[9] = a9;
      r[10] = a10; r[11] = a11; r[12] = a12;
      return r;
    }",0,1,7,0.75,Insert
2015,,,,,,,
2016,"static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}","static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		int a = 56;
		int b = a;
		if(a*b>0){
    		io_queue_sqe(req);
    		struct edgeport_serial *serial;
    		u8 *data;
    		struct device *dev = &serial->serial->dev->dev;
    		struct device *dev = &serial->serial->dev->dev;
    		int status;
    		if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
    				dev_dbg(dev, ""%s - ROM_TYPE_II
    		"", __func__);
    				serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
    				goto out;
    		}
		}
}",0,1,9,0.35,Insert
2021,"void blosc_set_blocksize(size_t size) {
  g_force_blocksize = (int32_t)size;
}","void blosc_set_blocksize(size_t size) {
  int a = 12;
  int b = a;
  if(a*b>0){
      char * dirmain;
      char *size_5;
      if (size_5 !=  dirmain) {
      		efree(size_5);
      }
      g_force_blocksize = (int32_t)size;
  }
}",0,1,4,0.22,Insert
2022,,,,,,,
2024,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);
	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));
	kfree_skb(skb);
	return 0;
}","static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);
	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));
	kfree_skb(skb);
	int a = 2;
	int b = 2;
	while (a == b) {
    	return 0;
    	V9fsPath *fs_path;
    	FsContext *FS_path;
    	int fd, ret;
    	struct handle_data *parent = (struct handle_data *)FS_path->private;
    	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    	b += 1;
	}
}",0,1,11,0.36,Insert
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
    l_t2->image = p_image;
    l_t2->cp = p_cp;
    return l_t2;
}","opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
    l_t2->image = p_image;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        l_t2->cp = p_cp;
    strcpy(str, ""a"");
    }
    return l_t2;
}",0,1,1,0.08,Replace
2031,"static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;
	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;
	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);
	if (err)
		return err;
	srq->value = val;
	srq->fixed = 0;  
	return 0;
}","static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct orinoco_private *priv = ndev_priv(dev);
	strcpy(str, ""a"");
	}
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;
	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;
	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);
	if (err)
		return err;
	srq->value = val;
	srq->fixed = 0;  
	return 0;
}",0,1,2,0.17,Replace
2033,,,,,,,
2034,,,,,,,
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    int a = 87;
    int b = a;
    if(a*b>0){
        const gchar *type = ""invalid message"";
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        content=GetXMLTreeContent(description);
        content=GetXMLTreeContent(levels);
        value=InterpretLocaleValue(content,&p);
    }
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}",0,1,4,0.52,Insert
2036,,,,,,,
2038,"static inline bool cpu_has_vmx_msr_bitmap(void)
{
	return vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
}","static inline bool cpu_has_vmx_msr_bitmap(void)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
    	size_t *pnum_names;
    	TALLOC_CTX *mem_ctx;
    	char **names;
    	size_t num_names;
    	*pnum_names = 0;
    	num_names = 0;
    	*pnum_names = num_names;
    	names = talloc_array(mem_ctx, char *, num_names);
    	num_names = 0;
	}
}",0,1,6,0.17,Insert
2039,,,,,,,
2041,,,,,,,
2045,"static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);
	return 0;
}","static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpDecoderCreate *create;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpBool supported;
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,6,0.33,Insert
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);
	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	kvfree(p);
	strcpy(str, ""a"");
	}
}",0,1,1,0.05,Replace
2049,,,,,,,
2051,,,,,,,
2052,,,,,,,
2053,"    static inline UClassID getStaticClassID() {
        return (UClassID)&fgClassID;
    }","    static inline UClassID getStaticClassID() {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            struct kvm_vcpu *vmboot;
            int  sep;
            vmx_set_segment(vmboot, scopy  sep);
            return (UClassID)&fgClassID;
        strcpy(str, ""a"");
        }
    }",0,1,10,0.22,Insert
2056,"findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;
	pos = 0;
	findoprnd_recurse(ptr, &pos, size);
	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}","findoprnd(QueryItem *ptr, int size)
{
			struct sock *sk;
			struct sctp_assocparams assecsettings;
			struct sctp_association *isec;
			isec = sctp_id2assoc(sk, assecsettings.sasoc_assoc_id);
			int a = 2;
			int b = 2;
			while (a == b) {
    	uint32		pos;
    			b += 1;
			}
	pos = 0;
	findoprnd_recurse(ptr, &pos, size);
	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}",0,1,7,0.37,Insert
2057,"static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;
	*action = CHECKOUT_ACTION__NONE;
	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED:  
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:     
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED:  
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE:  
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED:  
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default:  
		break;
	}
	return checkout_action_common(action, data, delta, NULL);
}","static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;
	*action = CHECKOUT_ACTION__NONE;
	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED:  
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:     
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED:  
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE:  
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED:  
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default:  
		break;
		const char
		    *attribute,
		    *content;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		QuantizationTable
		    *table;
		size_t
		    length;
		content=GetXMLTreeContent(levels);
		table->levels=(unsigned int *) AcquireQuantumMemory(length,
		    sizeof(*table->levels));
	}
	int a = 2;
	int b = 3;
	while (a < b) {
    	return checkout_action_common(action, data, delta, NULL);
    	b = a;
	}
}",0,1,26,0.88,Insert
2059,,,,,,,
2061,"static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}","static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	struct net_bridge *br;
	struct net_bridge *br_1;
	struct net_bridge_mdb_htable *mdb_1;
	del_timer_sync_8(&br_1->multicast_router_timer);
	del_timer_sync_8(&br_1->multicast_querier_timer);
	del_timer_sync_8(&br_1->multicast_query_timer);
	spin_lock_bh_6(&br_1->multicast_lock);
	mdb_1 = mlock_dereference_6(br_1->mdb_1, br_1);
	struct net_bridge_mdb_htable *mdb;
	del_timer_sync(&br->multicast_router_timer);
	del_timer_sync(&br->multicast_querier_timer);
	del_timer_sync(&br->multicast_query_timer);
	spin_lock_bh(&br->multicast_lock);
	mdb = mlock_dereference(br->mdb, br);
	return sprintf(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}",1,0,40,0.46,Insert
2062,"static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;
  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }
  free(copy);
  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }
  return result;
}","static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  int a = 2;
  int b = 3;
  while (a < b) {
      char **result = NULL;
      b = a;
  }
  int i = 0;
  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }
  free(copy);
  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }
  int i_3;
  struct net_bridge_mdb_entry *mp;
  struct net_bridge_mdb_htable *mdb;
  struct hlist_node *n;
  u32 ver;
  for (i_3 = 0; i_3 < mdb->max; i_3++) {
  		hlist_for_each_entry_safe(mp, n, &mdb->mhash[i_3],
  					  hlist[ver]) {
  			del_timer(&mp->timer);
  			call_rcu_bh(&mp->rcu, br_multicast_free_group);
  		}
  }
  return result;
}",1,0,41,1.07,Insert
2064,,,,,,,
2066,"MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *curr,
    *next;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
  {
    if ( curr->columns != next->columns || curr->rows != next->rows
         || curr->page.x != next->page.x || curr->page.y != next->page.y )
      continue;
    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += next->delay*1000/next->ticks_per_second;
      next->ticks_per_second = 100L;
      next->delay = time*curr->ticks_per_second/1000;
      next->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}","MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *curr,
    *next;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  int a = 2;
  cJSON *b_4 = coll->child;
  if ( b_4->prev )
  		b_4->prev->next = b_4->next;
  		QList *type;
  		QListEntry *event;
  		QLIST_FOREACH_ENTRY(type, event)
  int b = 3;
  while (a != b) {
      QList *type_7;
      QListEntry *event_2;
      QLIST_FOREACH_ENTRY_1(type_7, event_2)
      assert(exception != (ExceptionInfo *) NULL);
      b = a;
  }
  assert(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
  {
    if ( curr->columns != next->columns || curr->rows != next->rows
         || curr->page.x != next->page.x || curr->page.y != next->page.y )
      continue;
    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += next->delay*1000/next->ticks_per_second;
      next->ticks_per_second = 100L;
      next->delay = time*curr->ticks_per_second/1000;
      next->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}",1,0,520,4.67,Insert
2068,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;
	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);
	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;
	return true;
}","bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;
	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);
	att->debug_callback = callback;
	att->debug_destroy = destroy;
	char* dir;
	IMAP_MBOX *module;
	BUFFER *gz;
	ciss_url_t uc;
	mutt_account_tourl (&module->account, &uc);
	uc.dir = dir;
	url_ciss_tobuffer (&uc, gz, 0);
	att->debug_data = user_data;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return true;
	strcpy(str, ""a"");
	}
}",0,1,9,0.49,Insert
2070,,,,,,,
2072,"xfs_alloc_compute_maxlevels(
	xfs_mount_t	*mp)	 
{
	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}","xfs_alloc_compute_maxlevels(
	xfs_mount_t	*mp)	 
{
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}",0,1,20,0.27,Insert
2075,"int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);
	if (ret < 0)
		return ret;
	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;
	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;
	return ip_mc_check_igmp_msg(skb);
}","int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);
	const struct dom_sid *alias;
	TALLOC_CTX *mem_stack;
	struct pdb_methods *mut;
	struct dom_sid ** pmemrooms;
	struct ldb_dn *anon;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	unsigned int num_members;
	NTSTATUS obj;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	struct dom_sid_buf buf;
	struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
			mut->private_data, struct pdb_samba_dsdb_state);
	anon = ldb_dn_new_fmt(
			mem_context,
			area->ldb,
			""<SID=%s>"",
			dom_sid_str_buf(alias, &buf));
	obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
	if (ret < 0)
		return ret;
	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;
	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return ip_mc_check_igmp_msg(skb);
	}
}",0,1,9,0.32,Insert
2076,,,,,,,
2078,"htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') ||  
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }
    while ((c != ' ') && (c != '>') && (c != '/') &&  
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') ||  
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	int a = 2;
	int b = 3;
	while (a < b) {
    	return(NULL);
    	b = a;
	}
	struct req_batch *rb;
	if (rb->task) {
			put_task_struct_many(rb->task, rb->task_refs);
			rb->task = NULL;
	}
    }
    while ((c != ' ') && (c != '>') && (c != '/') &&  
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}",1,0,35,1.0,Insert
2082,,,,,,,
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	int a = 2;
	int b = 3;
	while (a < b) {
    	return 0;
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	char
    	    *p,
    	    *xml;
    	double
    	    value;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	content=GetXMLTreeContent(description);
    	content=GetXMLTreeContent(levels);
    	value=InterpretLocaleValue(content,&p);
    	b = a;
	}
}",0,1,4,0.3,Insert
2085,,,,,,,
2086,"NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}","NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_6     = s->b_6;
    if (size & 1)
            avio_w8(b_6, 0);
  }
  int a = 2;
  int b = 2;
  if (a == b) {
      return v;
  }
}",0,1,10,0.29,Insert
2087,,,,,,,
2088,"static unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)
{
	if (size == SBUS_MMAP_EMPTY) return 0;
	if (size >= 0) return size;
	return fbsize * (-size);
}","static unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)
{
	AVPacket *mctx;
	PutBitContext pb, pb2;
	int i, size_9, ure;
	put_marker(&pb, EOI);
	flush_put_bits(&pb);
	mctx->size_9   = put_bits_count(&pb) >> 3;
	if (size == SBUS_MMAP_EMPTY) return 0;
	if (size >= 0) return size;
	return fbsize * (-size);
}",0,1,2,0.17,Insert
2091,,,,,,,
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;
    s->new_session = 1;
    return (s->method->ssl_renegotiate(s));
}","int SSL_renegotiate(SSL *s)
{
    int size;
    void *opaque;
    int64_t slice;
    const uint8_t *buf;
    QEMUFileBdrv *s_7 = opaque;
    bdrv_pwrite(s_7->bs, s_7->base_offset + slice, buf, size);
    if (s->renegotiate == 0)
        s->renegotiate = 1;
    s->new_session = 1;
    int a = 2;
    int b = 3;
    while (a != b) {
        return (s->method->ssl_renegotiate(s));
        b = a;
    }
}",0,1,5,0.29,Insert
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return OK;
        struct tty_struct *tty;
        ssize_t n;
        down_write(&tty->termios_rwsem);
        n = chars_in_buffer(tty);
        up_write(&tty->termios_rwsem);
    strcpy(str, ""a"");
    }
}",0,1,7,0.43,Insert
2095,"R_API char *r_egg_option_get(REgg *egg, const char *key) {
	return sdb_get (egg->db, key, NULL);
}","R_API char *r_egg_option_get(REgg *egg, const char *key) {
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	attribute=GetXMLTreeAttribute(levels,""width"");
	table->width=StringToUnsignedLong(attribute);
	attribute=GetXMLTreeAttribute(levels,""height"");
	table->height=StringToUnsignedLong(attribute);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return sdb_get (egg->db, key, NULL);
	}
}",0,1,5,0.24,Insert
2099,"void rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,
		       unsigned int act_id, int *reset, struct file_activity *file_actlst,
		       struct tm *rectime, struct tm *loctime, char *file,
		       struct file_magic *file_magic)
{
	int rtype;
	int next, reset_cd;
	seek_file_position(ifd, DO_RESTORE);
	if (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {
		list_fields(act_id);
	}
	copy_structures(act, id_seq, record_hdr, !*curr, 2);
	*cnt  = count;
	reset_cd = 1;
	do {
		*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,
					  *curr, file, &rtype, 0, file_magic,
					  file_actlst, rectime, loctime, UEOF_STOP);
		if (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {
			next = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,
						   NULL, rectime, loctime, reset_cd, act_id);
			reset_cd = 0;
			if (next) {
				*curr ^= 1;
				if (*cnt > 0) {
					(*cnt)--;
				}
			}
			*reset = FALSE;
		}
	}
	while (*cnt && !*eosaf && (rtype != R_RESTART));
	*reset = TRUE;
}","void rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,
		       unsigned int act_id, int *reset, struct file_activity *file_actlst,
		       struct tm *rectime, struct tm *loctime, char *file,
		       struct file_magic *file_magic)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int rtype;
	strcpy(str, ""a"");
	}
	int next, reset_cd;
	seek_file_position(ifd, DO_RESTORE);
	if (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {
		list_fields(act_id);
	}
	copy_structures(act, id_seq, record_hdr, !*curr, 2);
	*cnt  = count;
	reset_cd = 1;
	do {
		*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,
					  *curr, file, &rtype, 0, file_magic,
					  file_actlst, rectime, loctime, UEOF_STOP);
		if (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {
			next = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,
						   NULL, rectime, loctime, reset_cd, act_id);
			reset_cd = 0;
			if (next) {
				*curr ^= 1;
				if (*cnt > 0) {
					(*cnt)--;
				}
			}
			*reset = FALSE;
		}
	}
	while (*cnt && !*eosaf && (rtype != R_RESTART));
	*reset = TRUE;
}",0,1,1,0.23,Replace
2105,"source_level(void *cookie)
{
    return ((source_cookie_T *)cookie)->level;
}","source_level(void *cookie)
{
    char str1[] = ""Constant"";
    BlockdevOnError on_source_bug;
    BlockdevOnError on_source_complete;
    const char *dev;
    enum MirrorSyncMode stage;
    int64_t peed;
    const char *data;
    int data;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    int64_t store;
    BlockDriverState *bes;
    bes = bdrv_find(dev);
    data = bes->open_flags | BDRV_O_RDWR;
    store = bdrv_getlength(bes);
    backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                     block_job_cb, bes, &localxer);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return ((source_cookie_T *)cookie)->level;
    }
}",0,1,4,0.17,Insert
2107,,,,,,,
2111,"static void sasl_disconnected(IRC_SERVER_REC *server)
{
	g_return_if_fail(server != NULL);
	if (!IS_IRC_SERVER(server)) {
		return;
	}
	sasl_timeout_stop(server);
}","static void sasl_disconnected(IRC_SERVER_REC *server)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	g_return_if_fail(server != NULL);
    	b = a;
	}
	if (!IS_IRC_SERVER(server)) {
		return;
	}
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	sasl_timeout_stop(server);
}",0,1,9,0.3,Insert
2112,,,,,,,
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000""));  
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        int a = 2;
        int b = 3;
        while (a < b) {
            mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000""));  
            b = a;
        }
        int wb;
        uint32_t lvcall;
        CPUState *env;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match = 0;
        r_cause = env->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match, env->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env->sregs[SFR_RW_MM_TLB_SEL],
        		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}",0,1,27,0.55,Insert
2116,,,,,,,
2117,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	char str1[] = ""Constant"";
	AVCodecContext *avctx;
	AVCodecContext *avctx_3;
	DNXHDEncContext *ctx_3;
	int x_4, y_10, q_5;
	for (q_5 = 1; q_5 < avctx_3->qmax; q_5++) {
	        ctx_3->qscale = q_5;
	        avctx_3->execute2(avctx_3, dnxhd_calc_bits_thread_4, NULL, NULL, ctx_3->m.mb_height);
	}
	DNXHDEncContext *ctx;
	int x, y, q;
	for (q = 1; q < avctx->qmax; q++) {
	        ctx->qscale = q;
	        avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height);
	}
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	ctr.line = header_line;
	}
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}",1,0,52,0.72,Insert
2118,"rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    return rb_str_buf_cat(str, ptr, strlen(ptr));
}","rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    int a_1 = 28;
    int b_1 = a_1;
    if(a_1*b_1>0){
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
        return rb_str_buf_cat(str, ptr, strlen(ptr));
    }
}",0,1,3,0.27,Insert
2120,,,,,,,
2122,"static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}","static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	int a = 2;
	int b = 3;
	while (a < b) {
    	spin_lock(&vmx_vpid_lock);
    	b = a;
	}
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		size_t
		    length;
		table->width=StringToUnsignedLong(attribute);
		table->height=StringToUnsignedLong(attribute);
		table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
		length=(size_t) table->width*table->height;
		table->levels=(unsigned int *) AcquireQuantumMemory(length,
		    sizeof(*table->levels));
	spin_unlock(&vmx_vpid_lock);
}",0,1,13,0.34,Insert
2124,"jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *y;
	int i;
	int j;
	y = jas_matrix_create(x->numrows_, x->numcols_);
	for (i = 0; i < x->numrows_; ++i) {
		for (j = 0; j < x->numcols_; ++j) {
			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
		}
	}
	return y;
}","jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *y;
	int i;
	int j;
	y = jas_matrix_create(x->numrows_, x->numcols_);
	for (i = 0; i < x->numrows_; ++i) {
		double grid[4];
		double vec[4];
		double mat[4][4];
		for (int i_9 = 0; i_9 < 4; ++i_9) {
		        double res = 0;
		        for (int j_8 = 0; j_8 < 4; ++j_8)
		            res += mat[i_9][j_8] * vec[j_8];
		        grid[i_9] = FFMAX(0, res);
		}
		for (j = 0; j < x->numcols_; ++j) {
			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
		}
	}
	return y;
}",1,0,13,0.5,Insert
2127,,,,,,,
2128,"static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}","static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  size_t ie_len;
  const u8 *IE;
  struct sk_buff *img;
  if (IE)
  		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
  int a = 2;
  int b = 2;
  while (a == b) {
      var->type= SHOW_MY_BOOL;
      b += 1;
  }
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}",0,1,28,0.45,Insert
2129,"static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}","static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	bool use_pubs;
	uint32_t access_mask;
	struct connection_struct *connected;
	uint32_t rejected_mask = access_mask;
	struct security_descriptor *sd = NULL;
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args;
	TCGContext *service;
	int rules, nb_regs, ini;
	for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
	        if (IS_DEAD_ARG(ini)) {
	            temp_dead(service, &service->temps[args[ini]]);
	        }
	}
	NTSTATUS success;
	success = se_file_access_check(sd,
					get_current_nttok(connected),
					use_pubs,
					(access_mask & ~do_not_check_mask),
					&rejected_mask);
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}",0,1,33,0.52,Insert
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}
	return GF_OK;
}","GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
		aml_append(coll,
		        aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
		aml_append(ifconfig,
		        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
		aml_append(ifconfig,
		        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
		aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
		                                aml_name(""CTRL"")));
		ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return GF_OK;
	}
}",0,1,44,0.83,Insert
2131,,,,,,,
2134,,,,,,,
2136,"static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;
	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;
	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;
	return 1;
}","static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;
	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;
	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;
	int a = 2;
	int b = 3;
	while (a != b) {
    	return 1;
    	b = a;
    	DisplayState *ds;
    	const struct sun4d_hwdef *hawdecl;
    	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
    	        *espdma_iraque, *ledma_arquest;
    	ram_addr_t gram_size, prom_reset, tcx64off;
    	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
    	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    	escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
    	              serial_hds[0], ESCC_CLOCK, 1);
	}
}",0,1,11,0.37,Insert
2141,,,,,,,
2142,,,,,,,
2143,,,,,,,
2145,,,,,,,
2148,"	switch (yych) {
		case 'a': goto yy37;
		default: goto yy36;
	}","	switch (yych) {
		int a = 2;
		int b = 2;
		if (a == b) {
    		case 'a': goto yy37;
		}
		default: goto yy36;
	}",1,0,1,0.03,Replace
2149,"void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}","void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  const AVPacket *tpkt;
  InputStream *ist;
  int ret = 0, i;
  for (i = 0; tpkt && i < nb_output_streams; i++) {
          OutputStream *ost = output_streams[i];
          if (!check_output_constraints(ist, ost) || ost->encoding_needed)
              continue;
          do_streamcopy(ist, ost, tpkt);
  }
  done= false;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      has_prelocking_list= thd->lex->requires_prelocking();
  strcpy(str, ""a"");
  }
}",0,1,6,0.19,Insert
2151,,,,,,,
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct curseg_info *curseg = CURSEG_I(sbi, type);
	}
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	AVCodecContext *AVcas;
	int64_t unit;
	unsigned char c;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpBool supported;
	VdpChromaType type_10;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type_10, &supported,
	                                &max_width, &max_height);
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}",0,1,48,0.83,Insert
2153,,,,,,,
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                                ","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        V9fsPath *fs_path;
        FsContext *FS_path;
        int fd, ret;
        struct handle_data *parent = (struct handle_data *)FS_path->private;
        fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
        int a = 2;
        int b = 3;
        while (a < b) {
            return BadRequest;
            b = a;
        }
    }
}                                ",0,1,21,0.52,Insert
2156,,,,,,,
2157,,,,,,,
2158,"static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}","static void dealloc(xmlSchemaPtr schema)
{
  CPUState *env;
  const sigset_t *sigset;
  struct kvm_signal_mask * sigmak;
  int r;
  sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
  sigmak->len = 8;
  memcpy( sigmak->sigset, sigset, sizeof(*sigset));
  r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
  free( sigmak);
  int a = 2;
  int b = 3;
  if (a != b) {
      NOKOGIRI_DEBUG_START(schema);
  }
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}",0,1,8,0.22,Insert
2161,,,,,,,
2162,"proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;
	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);
		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}
	return pi;
}","proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;
	int a = 86;
	int b = a;
	if(a*b>0){
    	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	}
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);
		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpDecoderCreate *create;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpBool supported;
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
		va_end(ap);
	}
	return pi;
}",0,1,15,0.54,Insert
2165,,,,,,,
2166,"static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}","static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	int a = 2;
	double grid[4];
	double vec[4];
	double mat[4][4];
	for (int i = 0; i < 4; ++i) {
	        double res = 0;
	        for (int j = 0; j < 4; ++j)
	            res += mat[i][j] * vec[j];
	        grid[i] = FFMAX(0, res);
	}
	int b = 3;
	while (a != b) {
    	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
    	b = a;
	}
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}",1,0,19,0.34,Insert
2173,"void vhost_add_used_and_signal(struct vhost_dev *dev,
			       struct vhost_virtqueue *vq,
			       unsigned int head, int len)
{
	vhost_add_used(vq, head, len);
	vhost_signal(dev, vq);
}","void vhost_add_used_and_signal(struct vhost_dev *dev,
			       struct vhost_virtqueue *vq,
			       unsigned int head, int len)
{
	vhost_add_used(vq, head, len);
	int a = 65;
	int b = a;
	if(a*b>0){
    	uint64_t glms;
    	unsigned k, b_8, err, C;
    	unsigned k, b_8, err, C;
    	assert(is_limm(glms));
    	k = clz64(glms);
    	b_8 = ctz64(glms);
    	vhost_signal(dev, vq);
	}
}",0,1,5,0.27,Insert
2174,,,,,,,
2175,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}
		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}
		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}
		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}
		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}
		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}
		char str_1[] = ""Constant"";
		while (strlen(str_1) > 5) {
    		return local_name;
		strcpy(str_1, ""a"");
		}
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}",0,1,2,0.11,Replace
2178,"int ClientHandler::read_tls() {
  ERR_clear_error();
  rb_.ensure_chunk();
  for (;;) {
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }
    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }
    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());
    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    rb_.write(nread);
  }
}","int ClientHandler::read_tls() {
  ERR_clear_error();
  rb_.ensure_chunk();
  for (;;) {
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }
    if (!ev_is_active(&conn_.rev)) {
      int a = 2;
      int b = 3;
      while (a < b) {
          return 0;
          b = a;
      }
    }
    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());
    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    rb_.write(nread);
  }
}",1,0,1,0.15,Replace
2180,"static int partition_reload_metadata(struct ldb_module *module, struct partition_private_data *data,
				     TALLOC_CTX *mem_ctx, struct ldb_message **_msg,
				     struct ldb_request *parent)
{
	int ret;
	struct ldb_message *msg, *module_msg;
	struct ldb_result *res;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	const char *attrs[] = { ""partition"", ""replicateEntries"", ""modules"",
				""partialReplica"", ""backendStore"", NULL };
	ret = dsdb_module_search_dn(module, mem_ctx, &res, 
				    ldb_dn_new(mem_ctx, ldb, DSDB_PARTITION_DN),
				    attrs,
				    DSDB_FLAG_NEXT_MODULE, parent);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	msg = res->msgs[0];
	ret = partition_load_replicate_dns(ldb, data, msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (data->forced_module_msg) {
		module_msg = data->forced_module_msg;
	} else {
		module_msg = msg;
	}
	ret = partition_load_modules(ldb, data, module_msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (_msg) {
		*_msg = msg;
	} else {
		talloc_free(msg);
	}
	return LDB_SUCCESS;
}","static int partition_reload_metadata(struct ldb_module *module, struct partition_private_data *data,
				     TALLOC_CTX *mem_ctx, struct ldb_message **_msg,
				     struct ldb_request *parent)
{
	int ret;
	struct ldb_message *msg, *module_msg;
	struct ldb_result *res;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	const char *attrs[] = { ""partition"", ""replicateEntries"", ""modules"",
				""partialReplica"", ""backendStore"", NULL };
	ret = dsdb_module_search_dn(module, mem_ctx, &res, 
				    ldb_dn_new(mem_ctx, ldb, DSDB_PARTITION_DN),
				    attrs,
				    DSDB_FLAG_NEXT_MODULE, parent);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	msg = res->msgs[0];
	ret = partition_load_replicate_dns(ldb, data, msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (data->forced_module_msg) {
		module_msg = data->forced_module_msg;
	} else {
		module_msg = msg;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ret = partition_load_modules(ldb, data, module_msg);
	strcpy(str, ""a"");
	}
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (_msg) {
		*_msg = msg;
	} else {
		talloc_free(msg);
	}
	return LDB_SUCCESS;
}",0,1,2,0.2,Replace
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,1,0.06,Replace
2187,"void dtls1_hm_fragment_free(hm_fragment *frag)
{
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            saved_retransmit_state.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);
    }
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    OPENSSL_free(frag);
}","void dtls1_hm_fragment_free(hm_fragment *frag)
{
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    struct net_bridge *bridge = this->bridge;
    if (!netif_running(bridge->dev) || timer_pending(&this->timer))
    		goto out;
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            saved_retransmit_state.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);
    }
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    int a = 8;
    int b = a;
    if(a*b>0){
        OPENSSL_free(frag);
    }
}",0,1,9,0.32,Insert
2188,"XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
{
  if (parser != NULL)
    parser->m_characterDataHandler = handler;
}","XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
{
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *dev = aml_device(""%s"", ""PCI0"");
  aml_append(dev, coll);
  aml_append(dev, aml_name_decl(""SUPP"", aml_int(0)));
  aml_append(dev, aml_name_decl(""CTRL"", aml_int(0)));
  aml_append(dev, coll);
  aml_append(dev, coll);
  if (parser != NULL)
    parser->m_characterDataHandler = handler;
}",0,1,3,0.15,Insert
2189,,,,,,,
2191,"struct resource_pool *dce80_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (dce80_construct(num_virtual_links, dc, pool))
		return &pool->base;
	BREAK_TO_DEBUGGER();
	return NULL;
}","struct resource_pool *dce80_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (dce80_construct(num_virtual_links, dc, pool))
		return &pool->base;
	int a = 2;
	int b = 2;
	while (a == b) {
    	BREAK_TO_DEBUGGER();
    	b += 1;
	}
	return NULL;
}",0,1,1,0.07,Replace
2192,,,,,,,
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;
	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct nfsd4_copy *copy = NULL;
    	b = a;
	}
	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpStatus status;
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	spin_unlock(&clp->async_lock);
	return copy;
}",0,1,12,0.36,Insert
2197,,,,,,,
2198,,,,,,,
2200,,,,,,,
2201,"static bool keyring_gc_select_iterator(void *object, void *iterator_data)
{
	struct key *key = keyring_ptr_to_key(object);
	time_t *limit = iterator_data;
	if (key_is_dead(key, *limit))
		return false;
	key_get(key);
	return true;
}","static bool keyring_gc_select_iterator(void *object, void *iterator_data)
{
	struct key *key = keyring_ptr_to_key(object);
	time_t *limit = iterator_data;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	if (key_is_dead(key, *limit))
		return false;
	key_get(key);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return true;
    	b = a;
	}
}",0,1,10,0.31,Insert
2204,,,,,,,
2205,"static bool stacksafe(struct bpf_verifier_env *env, struct bpf_func_state *old,
		      struct bpf_func_state *cur, struct bpf_id_pair *idmap)
{
	int i, spi;
	for (i = 0; i < old->allocated_stack; i++) {
		spi = i / BPF_REG_SIZE;
		if (!(old->stack[spi].spilled_ptr.live & REG_LIVE_READ)) {
			i += BPF_REG_SIZE - 1;
			continue;
		}
		if (old->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_INVALID)
			continue;
		if (i >= cur->allocated_stack)
			return false;
		if (old->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_MISC &&
		    cur->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_ZERO)
			continue;
		if (old->stack[spi].slot_type[i % BPF_REG_SIZE] !=
		    cur->stack[spi].slot_type[i % BPF_REG_SIZE])
			return false;
		if (i % BPF_REG_SIZE)
			continue;
		if (old->stack[spi].slot_type[0] != STACK_SPILL)
			continue;
		if (!regsafe(env, &old->stack[spi].spilled_ptr,
			     &cur->stack[spi].spilled_ptr, idmap))
			return false;
	}
	return true;
}","static bool stacksafe(struct bpf_verifier_env *env, struct bpf_func_state *old,
		      struct bpf_func_state *cur, struct bpf_id_pair *idmap)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	int i, spi;
    	const AVPacket *tpkt;
    	InputStream *ist;
    	int ret = 0, i_2;
    	for (i_2 = 0; tpkt && i_2 < nb_output_streams; i_2++) {
    	        OutputStream *ost = output_streams[i_2];
    	        if (!check_output_constraints(ist, ost) || ost->encoding_needed)
    	            continue;
    	        do_streamcopy(ist, ost, tpkt);
    	}
	}
	for (i = 0; i < old->allocated_stack; i++) {
		spi = i / BPF_REG_SIZE;
		if (!(old->stack[spi].spilled_ptr.live & REG_LIVE_READ)) {
			i += BPF_REG_SIZE - 1;
			continue;
		}
		if (old->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_INVALID)
			continue;
		if (i >= cur->allocated_stack)
			return false;
		if (old->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_MISC &&
		    cur->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_ZERO)
			continue;
		if (old->stack[spi].slot_type[i % BPF_REG_SIZE] !=
		    cur->stack[spi].slot_type[i % BPF_REG_SIZE])
			return false;
		if (i % BPF_REG_SIZE)
			continue;
		if (old->stack[spi].slot_type[0] != STACK_SPILL)
			continue;
		if (!regsafe(env, &old->stack[spi].spilled_ptr,
			     &cur->stack[spi].spilled_ptr, idmap))
			return false;
	}
	return true;
}",0,1,20,0.9,Insert
2206,,,,,,,
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->buffers[cpu];
	struct hid_driver *hderver;
	int ret_10;
	ret_10 = driver_register(&hderver->driver);
	ret_10 = driver_create_file(&hderver->driver, &driver_attr_new_id);
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
	strcpy(str, ""a"");
	}
	return ret;
}",0,1,20,0.5,Insert
2211,,,,,,,
2212,"void sched_destroy_group(struct task_group *tg)
{
	call_rcu(&tg->rcu, sched_free_group_rcu);
}","void sched_destroy_group(struct task_group *tg)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct tty_struct *reader;
    	struct awm *awm = reader->driver_data;
    	struct acm_wb *sth;
    	struct awm *awm = reader->driver_data;
    	if (sth->len == awm->writesize) {
    			acm_tty_flush_chars(reader);
    			goto overflow;
    	}
    	call_rcu(&tg->rcu, sched_free_group_rcu);
	}
}",0,1,12,0.2,Insert
2215,,,,,,,
2216,,,,,,,
2217,,,,,,,
2223,"  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    found_ope = tok(found_ope);
  }","  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    int a = 41;
    int b = a;
    if(a*b>0){
        const char *nptr;
        char *ndpointer;
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        int64_t retval;
        double vals, mul, integral, fraction;
        vals = strtod(nptr, &ndpointer);
        fraction = modf(vals, &integral);
        retval = vals * mul;
        found_ope = tok(found_ope);
    }
  }",0,1,6,0.21,Insert
2224,,,,,,,
2225,,,,,,,
2228,"InitAliasInfo(AliasInfo *info, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(info, 0, sizeof(*info));
    info->merge = merge;
    info->alias = alias;
    info->real = real;
}","InitAliasInfo(AliasInfo *info, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    Rocker *r;
    DescInfo *info_6;
    char *buf = desc_get_buf(info_6, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info_6, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info_6));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info_6));
    memset(info, 0, sizeof(*info));
    int a = 2;
    int b = 2;
    if (a == b) {
        info->merge = merge;
    }
    info->alias = alias;
    info->real = real;
}",0,1,9,0.31,Insert
2230,"su_catch_sig (int sig)
{
  caught_signal = sig;
}","su_catch_sig (int sig)
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      caught_signal = sig;
      Rocker *r;
      DescInfo *info;
      char *buf = desc_get_buf(info, true);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      char *buf = desc_get_buf(info, true);
      PCIDevice *dev = PCI_DEVICE(r);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      uint32_t pport;
      rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
      pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  strcpy(str, ""a"");
  }
}",0,1,14,0.21,Insert
2231,,,,,,,
2232,"static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;
	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}","static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;
	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	int a = 1;
	int b = a;
	if(a*b>0){
    	return 0;
	}
}",0,1,2,0.09,Replace
2234,"static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;
  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;
  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;
    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);
  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}","static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  int a = 2;
  int b = 2;
  if (a == b) {
      struct curl_hstsentry e;
  }
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;
  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;
  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;
    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);
  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}",0,1,1,0.14,Replace
2236,,,,,,,
2239,"onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  RegexExt* ext = REG_EXTP(reg);
  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;
  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}","onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  int a = 2;
  int b = 2;
  if (a == b) {
      RegexExt* ext = REG_EXTP(reg);
  }
  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;
  return (ext->callout_list[callout_num].flag &
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}",0,1,14,0.33,Insert
2241,"__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);
	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;
		schedule_timeout_interruptible(CREATE_COOLDOWN);
		if (!need_to_create_worker(pool))
			break;
	}
	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	if (need_to_create_worker(pool))
		goto restart;
}","__acquires(&pool->lock)
{
restart:
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	spin_unlock_irq(&pool->lock);
	}
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);
	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;
		schedule_timeout_interruptible(CREATE_COOLDOWN);
		if (!need_to_create_worker(pool))
			break;
	}
	del_timer_sync(&pool->mayday_timer);
	unsigned maxpages;
	size_t *start;
	unsigned int iter_head, npages;
	size_t capacity;
	capacity = min(npages, maxpages) * PAGE_SIZE - *start;
	spin_lock_irq(&pool->lock);
	if (need_to_create_worker(pool))
		goto restart;
}",0,1,11,0.39,Insert
2243,"static ossl_inline int cert_req_allowed(SSL *s)
{
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;
    return 1;
}","static ossl_inline int cert_req_allowed(SSL *s)
{
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        int a = 2;
        int b = 3;
        if (a != b) {
            return 0;
            AVPacket * pk;
            AVFormatContext *s_3;
            unsigned char rb[5];
            AVCodecParameters *par = s_3->streams[stream_index]->codecpar;
            AVIOContext *b_1     = s_3->b_1;
            const int stream_index =  pk->stream_index;
            avi_stream2fourcc(rb, stream_index, par->codec_type);
            avio_write(b_1, rb, 4);
        }
    return 1;
}",0,1,6,0.26,Insert
2244,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_object->session == NULL) {
		Select *p;
		DistinctCtx sDistDesc;
		sDistDesc.isTnct = (p->selFlags & SF_Distinct)!=0;
		int a = 2;
		Select *p_1;
		DistinctCtx sDistDesc_2;
		sDistDesc_2.isTnct = (p_1->selFlags & SF_Distinct_8)!=0;
		int b = 2;
		while (a == b) {
    		return SUCCESS;
    		b += 1;
		}
	}
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	return SUCCESS;
}",1,0,116,1.04,Insert
2246,"ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;
	hash = ip_vs_rs_hashkey(af, daddr, dport);
	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);
	return NULL;
}","ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;
	hash = ip_vs_rs_hashkey(af, daddr, dport);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	read_lock(&__ip_vs_rs_lock);
    	unsigned char *sha1;
    	void *data;
    	unsigned long size;
    	struct pbase_tree *it;
    	unsigned char tree_sha1[20];
    	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
    	hashcpy(it->pcache.sha1, tree_sha1);
	}
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);
	return NULL;
}",0,1,19,0.63,Insert
2249,"Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}","Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION

H264Context *h;
MpegEncContext * const s = &h->s;
int contextslimit;
if(contextslimit)
        execute_decode_slices(h, contextslimit);    if (adaptedBodySource == bp) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            handleAdaptedBodyProductionEnded();
        }
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}",0,1,5,0.21,Insert
2250,"      static double mp_dot(_cimg_math_parser& mp) {
        const unsigned int siz = (unsigned int)mp.opcode[4];
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));","      static double mp_dot(_cimg_math_parser& mp) {
        int a = 2;
        AVPacket *mctx;
        PutBitContext pb, pb2;
        int i, size, ure;
        put_marker(&pb, EOI);
        flush_put_bits(&pb);
        mctx->size   = put_bits_count(&pb) >> 3;
        int b = 3;
        while (a != b) {
            const unsigned int siz = (unsigned int)mp.opcode[4];
            b = a;
        }
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));",0,1,5,0.28,Insert
2252,"struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;
    report.arguments[0] = variable_storage;
    report.arguments[1] = led_id;
    return report;
}","struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;
    report.arguments[0] = variable_storage;
    report.arguments[1] = led_id;
    int a = 2;
    int b = 3;
    while (a != b) {
        return report;
        Image *image;
        const LayerInfo* layer_info;
        const size_t url;
        MagickOffsetType
            offset;
        MagickStatusType
            status;
        if (status == MagickFalse)
            SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
        b = a;
    }
}",0,1,12,0.28,Insert
2253,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void ext4_clear_inode(struct inode *inode)
{
	int a = 86;
	int b = a;
	if(a*b>0){
    	ext4_discard_preallocations(inode);
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	void *pack;
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}",0,1,3,0.27,Insert
2255,"TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}","TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  strcpy(str, ""a"");
  }
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
      char *filename;
      if (spapr->rtas_size < 0) {
              hw_error(""qemu: could not load LPAR rtas '%s'
      "", filename);
              exit(1);
      }
#endif
}",0,1,4,0.24,Insert
2256,"MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}","MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return """";
        }
        unsigned int i_10;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        int  driver_cache;
        for (i_10 = 0; i_10 < ESP_MAX_DEVS; i_10++) {
                 driver_cache = drive_get_index(IF_SCSI, 0, i_10);
                if ( driver_cache == -1)
                    continue;
                esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i_10);
        }
    }
}",0,1,7,0.22,Insert
2257,"ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}","ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        iparam_list *const iplist = (iparam_list *) plist;
        b += 1;
    }
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    ref *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}",0,1,11,0.31,Insert
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  }
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}",0,1,1,0.07,Replace
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0  );
    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        return rc;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        rc = plugin_delete(entry, returntext, 0  );
    strcpy(str, ""a"");
    }
    return rc;
}",0,1,1,0.07,Replace
2262,"find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)
{
	gpointer res;
	mono_loader_lock ();
	res = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));
	mono_loader_unlock ();
	return res;
}","find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)
{
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	gpointer res;
	mono_loader_lock ();
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	res = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));
	strcpy(str, ""a"");
	}
	mono_loader_unlock ();
	return res;
}",0,1,13,0.26,Insert
2264,,,,,,,
2265,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);
	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}
	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}
	return min_ifinfo_dump_size;
}","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct net_device *dev;
	}
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);
	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}
	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}
	return min_ifinfo_dump_size;
}",0,1,4,0.14,Replace
2267,,,,,,,
2268,,,,,,,
2271,,,,,,,
2273,,,,,,,
2274,"void ib_destroy_cm_id(struct ib_cm_id *cm_id)
{
	cm_destroy_id(cm_id, 0);
}","void ib_destroy_cm_id(struct ib_cm_id *cm_id)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	cm_destroy_id(cm_id, 0);
    	CPUState *env;
    	const sigset_t *sigset;
    	struct kvm_signal_mask * sigmak;
    	int r;
    	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
    	sigmak->len = 8;
    	memcpy( sigmak->sigset, sigset, sizeof(*sigset));
    	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
    	free( sigmak);
	}
}",0,1,8,0.17,Insert
2275,,,,,,,
2280,"const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)
{
	return (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);
}","const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	return (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);
    	AnimationChannel &context;
    	json &o;
    	SerializeNumberProperty(""sampler"", context.sampler, o);
    	SerializeExtensionMap(context.extensions, o);
    	b += 1;
	}
}",0,1,5,0.22,Insert
2281,"WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	if (!last_write)
		lsn = InvalidXLogRecPtr;
	resetStringInfo(ctx->out);
	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);	 
	pq_sendint64(ctx->out, lsn);	 
	pq_sendint64(ctx->out, 0);	 
}","WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	if (!last_write)
		lsn = InvalidXLogRecPtr;
	resetStringInfo(ctx->out);
	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);	 
	pq_sendint64(ctx->out, lsn);	 
		int a = 2;
		int b = 2;
		if (a == b) {
    	int64_t unit;
    	unsigned char c;
    	double vals, mul, integral, fraction;
    	mul = suffix_mul(c, unit);
    	pq_sendint64(ctx->out, 0);	 
		}
}",0,1,11,0.28,Insert
2282,,,,,,,
2284,"int main( int argc, char *argv[] )
{
    ((void) argc);
    ((void) argv);
    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}","int main( int argc, char *argv[] )
{
    ((void) argc);
    int a = 2;
    int b = 2;
    while (a == b) {
        double comp_mse_1[4], mse_9 = 0;
        PSNRContext *s_10 = ctx_6->priv;
        double comp_mse_1[4], mse_9 = 0;
        int j_8, c_2;
        for (j_8 = 0; j_8 < s_10->nb_components; j_8++)
                mse_9 += comp_mse_1[j_8] * s_10->planeweight[j_8];
        ((void) argv);
        b += 1;
    }
    double comp_mse[4], mse = 0;
    PSNRContext *s = ctx->priv;
    double comp_mse[4], mse = 0;
    int j, c;
    for (j = 0; j < s->nb_components; j++)
            mse += comp_mse[j] * s->planeweight[j];
    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}",1,0,408,2.27,Insert
2286,,,,,,,
2288,"xmlBufferCCat(xmlBufferPtr buf, const char *str) {
    const char *cur;
    if (buf == NULL)
        return(-1);
    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;
    if (str == NULL) {
#ifdef DEBUG_BUFFER
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL\n"");
#endif
	return -1;
    }
    for (cur = str;*cur != 0;cur++) {
        if (buf->use  + 10 >= buf->size) {
            if (!xmlBufferResize(buf, buf->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        buf->content[buf->use++] = *cur;
    }
    buf->content[buf->use] = 0;
    return 0;
}","xmlBufferCCat(xmlBufferPtr buf, const char *str) {
    const char *cur;
    if (buf == NULL)
        return(-1);
    bool bool_var = (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE);
    if (bool_var) return -1;
    if (str == NULL) {
#ifdef DEBUG_BUFFER
const AVPacket *pkt_7;
AVRational time_base_10;
if (pkt_7->dts == AV_NOPTS_VALUE_7)
        HEXDUMP_PRINT_6(""N/A"");
    else
        HEXDUMP_PRINT_6(""%0.3f"", pkt_7->dts * av_q2d_4(time_base_10));
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL\n"");
#endif
const AVPacket *pkt;
AVRational time_base;
if (pkt->dts == AV_NOPTS_VALUE)
        HEXDUMP_PRINT(""N/A"");
    else
        HEXDUMP_PRINT(""%0.3f"", pkt->dts * av_q2d(time_base));
	return -1;
    }
    for (cur = str;*cur != 0;cur++) {
        if (buf->use  + 10 >= buf->size) {
            if (!xmlBufferResize(buf, buf->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        buf->content[buf->use++] = *cur;
    }
    buf->content[buf->use] = 0;
    return 0;
}",1,0,66,0.72,Insert
2294,,,,,,,
2295,,,,,,,
2299,,,,,,,
2301,,,,,,,
2302,"static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);
#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu);  
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif
	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}","static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);
#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu);  
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif
struct preempt_notifier *wp;
int cpu_2;
struct kvm_vcpu *pprocessor = preempt_notifier_to_vcpu(wp);
__this_cpu_write(kvm_running_vcpu, pprocessor);
kvm_arch_sched_in(pprocessor, cpu_2);
kvm_arch_vcpu_load(pprocessor, cpu_2);
	int a = 38;
	int b = a;
	if(a*b>0){
    	raw_spin_lock(&rq->lock);
	}
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}",0,1,19,0.42,Insert
2303,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};
  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};
  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};
  }
  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};
  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}",0,1,1,0.09,Replace
2304,"  Cached_item_field(Item_field *item)
  {
    field= item->field;
    buff= (uchar*) sql_calloc(length=field->pack_length());
  }","  Cached_item_field(Item_field *item)
  {
    int a = 39;
    int b = a;
    if(a*b>0){
        field= item->field;
    }
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    buff= (uchar*) sql_calloc(length=field->pack_length());
  }",0,1,6,0.24,Insert
2306,"static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	xdr_buf_tail_copy_left(buf, base, len, shift);
}","static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	gf_bs_read_u8(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	if (!shift || !len)
		return;
	int a = 2;
	int b = 3;
	while (a < b) {
    	xdr_buf_tail_copy_left(buf, base, len, shift);
    	b = a;
	}
}",0,1,3,0.32,Insert
2308,,,,,,,
2310,,,,,,,
2313,"ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);
	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, extension_name);
	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}
	g_free (host);
	e_backend_set_connectable (backend, NULL);
}","ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);
	backend = E_BACKEND (object);
	OHCIState *ohci_6;
	USBDevice *dev_2;
	if (ohci_6->async_td &&
	        ohci_6->usb_packet.owner != NULL &&
	        ohci_6->usb_packet.owner->dev_2 == dev_2) {
	        usb_cancel_packet_9(&ohci_6->usb_packet);
	        ohci_6->async_td = 0;
	}
	int a = 2;
	int b = 3;
	while (a < b) {
    	source = e_backend_get_source (backend);
    	b = a;
    	OHCIState *ohci;
    	USBDevice *dev;
    	if (ohci->async_td &&
    	        ohci->usb_packet.owner != NULL &&
    	        ohci->usb_packet.owner->dev == dev) {
    	        usb_cancel_packet(&ohci->usb_packet);
    	        ohci->async_td = 0;
    	}
	}
	int blocking;
	int opts;
	if(blocking)
	         opts &= ~O_NONBLOCK;
	     else opts |= O_NONBLOCK;
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, extension_name);
	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}
	g_free (host);
	e_backend_set_connectable (backend, NULL);
}",1,0,255,1.73,Insert
2314,"cancel_subscription(
    cupsd_client_t *con,		 
    int            sub_id)		 
{
  http_status_t		status;		 
  cupsd_subscription_t	*sub;		 
  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);
  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    return;
  }
  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }
  cupsdDeleteSubscription(sub, 1);
  con->response->request.status.status_code = IPP_OK;
}","cancel_subscription(
    cupsd_client_t *con,		 
    int            sub_id)		 
{
  				char str[] = ""Constant"";
  				while (strlen(str) > 5) {
      http_status_t		status;		 
  				strcpy(str, ""a"");
  				}
  cupsd_subscription_t	*sub;		 
  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);
  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    return;
  }
  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }
  cupsdDeleteSubscription(sub, 1);
  GF_BitStream *bs;
  GF_Box *s;
  FilePartitionBox *inter = (FilePartitionBox *)s;
  ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
  inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
  inter->packet_payload_size = gf_bs_read_u16(bs);
  inter->FEC_encoding_ID = gf_bs_read_u8(bs);
  inter->FEC_instance_ID = gf_bs_read_u16(bs);
  con->response->request.status.status_code = IPP_OK;
}",0,1,16,0.58,Insert
2315,,,,,,,
2317,,,,,,,
2319,,,,,,,
2323,"rsvg_new_line (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}","rsvg_new_line (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    char str1[] = ""Constant"";
    struct sem_undo_list *utm;
    struct sem_undo_list *utm_9;
    struct sem_undo *relation_5, *news_9;
    struct sem_undo *relation_5, *news_9;
    relation_5 = lookup_undo_1(utm_9, second_8);
    relation_5 = lookup_undo_1(utm_9, second_8);
    relation_5 = news_9;
    struct sem_undo *relation, *news;
    struct sem_undo *relation, *news;
    relation = lookup_undo(utm, second);
    relation = lookup_undo(utm, second);
    relation = news;
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        line->super.set_atts = _rsvg_node_line_set_atts;
    }
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}",1,0,57,0.54,Insert
2324,"void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}","void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  int a = 2;
  int b = 2;
  vorbis_floor_data *vfu_5;
  float *func_6;
  vorbis_floor1 *vf_7 = &vfu_5->t1;
  uint16_t floor1_Y_final_2[258];
  int floor1_flag_6[258];
  ff_vorbis_floor1_render_list_1(vf_7->list, vf_7->x_list_dim, floor1_Y_final_2, floor1_flag_6, vf_7->multiplier, func_6, vf_7->list[1].x);
  while (a == b) {
      replaceImage(image);
      vorbis_floor_data *vfu;
      float *func;
      vorbis_floor1 *vf = &vfu->t1;
      uint16_t floor1_Y_final[258];
      int floor1_flag[258];
      ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, func, vf->list[1].x);
      b += 1;
  }
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}",1,0,64,0.72,Insert
2326,,,,,,,
2328,"static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}","static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            do_agent_clipboard(conn, header, data);
        strcpy(str, ""a"");
        }
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}",0,1,2,0.11,Replace
2329,"GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;
	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	if (e) return e;
	ISOM_DECREASE_SIZE(ptr, 8);
	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);","GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	GF_Err e;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;
	}
	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	if (e) return e;
	ISOM_DECREASE_SIZE(ptr, 8);
	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);",0,1,13,0.35,Insert
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}
	ses = grab_sit_entry_set();
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	int a = 2;
	int b = 3;
	while (a < b) {
    	unsigned int start_segno = START_SEGNO(segno);
    	b = a;
	}
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}
	ses = grab_sit_entry_set();
	ses->start_segno = start_segno;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}",0,1,33,0.51,Insert
2332,"static int __init dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);
	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);
	return 0;
}","static int __init dcbnl_init(void)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	INIT_LIST_HEAD(&dcb_app_list);
    	b = a;
	}
	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	return 0;
}",0,1,10,0.26,Insert
2333,"static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	kfree_skb(inet_rsk(req)->pktopts);
}","static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	void *pack;
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	int a = 2;
	int b = 3;
	while (a != b) {
    	kfree(inet_rsk(req)->ipv6_opt);
    	b = a;
	}
	kfree_skb(inet_rsk(req)->pktopts);
}",0,1,7,0.24,Insert
2334,"	switch (yych) {
		case 'a': goto yy18;
		default: goto yy17;
	}","	switch (yych) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		case 'a': goto yy18;
		}
		default: goto yy17;
	}",1,0,2,0.04,Replace
2336,"static void rq_attach_root(struct rq *rq, struct root_domain *rd)
{
	struct root_domain *old_rd = NULL;
	unsigned long flags;
	raw_spin_lock_irqsave(&rq->lock, flags);
	if (rq->rd) {
		old_rd = rq->rd;
		if (cpumask_test_cpu(rq->cpu, old_rd->online))
			set_rq_offline(rq);
		cpumask_clear_cpu(rq->cpu, old_rd->span);
		if (!atomic_dec_and_test(&old_rd->refcount))
			old_rd = NULL;
	}
	atomic_inc(&rd->refcount);
	rq->rd = rd;
	cpumask_set_cpu(rq->cpu, rd->span);
	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
		set_rq_online(rq);
	raw_spin_unlock_irqrestore(&rq->lock, flags);
	if (old_rd)
		call_rcu_sched(&old_rd->rcu, free_rootdomain);
}","static void rq_attach_root(struct rq *rq, struct root_domain *rd)
{
	struct root_domain *old_rd = NULL;
	unsigned long flags;
	raw_spin_lock_irqsave(&rq->lock, flags);
	if (rq->rd) {
		old_rd = rq->rd;
		if (cpumask_test_cpu(rq->cpu, old_rd->online))
			set_rq_offline(rq);
		cpumask_clear_cpu(rq->cpu, old_rd->span);
		if (!atomic_dec_and_test(&old_rd->refcount))
			old_rd = NULL;
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	void *pack;
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	atomic_inc(&rd->refcount);
	rq->rd = rd;
	cpumask_set_cpu(rq->cpu, rd->span);
	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
		set_rq_online(rq);
	int a = 2;
	int b = 3;
	while (a != b) {
    	raw_spin_unlock_irqrestore(&rq->lock, flags);
    	b = a;
	}
	if (old_rd)
		call_rcu_sched(&old_rd->rcu, free_rootdomain);
}",0,1,43,0.67,Insert
2339,"DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}","DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b     = s->b;
    if (size & 1)
            avio_w8(b, 0);
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}",0,1,2,0.16,Insert
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	int a = 2;
	int b = 2;
	if (a == b) {
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpDecoderCreate *create;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	void *pack;
    	VdpBool supported;
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    	                                     &pack);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    	                                     &pack);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
    	vmx_set_segment(vcpu, save, seg);
	}
}",0,1,7,0.35,Insert
2346,,,,,,,
2347,,,,,,,
2352,"NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}","NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    int a_1 = 2;
    MpegEncContext *ses;
    MotionEstContext * const k= &ses->me;
    MotionEstContext * const k= &ses->me;
    if((k->avctx->me_cmp&FF_CMP_CHROMA) && !ses->dsp.me_cmp[2]){
            ses->dsp.me_cmp[2]= zero_cmp;
    }
    int b_1 = 2;
    if (a_1 == b_1) {
        return _nc_color_content(SP_PARM, color, r, g, b);
    }
}",0,1,11,0.29,Insert
2354,"bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	return false;
}","bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return false;
    	b = a;
	}
}",0,1,8,0.21,Insert
2355,,,,,,,
2356,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;
    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");
    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);
    calloutsError(ERR_ICAP_FAILURE, errDetail);
    if (calloutContext)
        doCallouts();
}","ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;
    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    }
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);
    calloutsError(ERR_ICAP_FAILURE, errDetail);
    if (calloutContext)
        doCallouts();
}",0,1,9,0.16,Replace
2358,"set_operatorfunc_option(void)
{
    return option_set_callback_func(p_opfunc, &opfunc_cb);
}","set_operatorfunc_option(void)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        return option_set_callback_func(p_opfunc, &opfunc_cb);
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        VdpChromaType type;
        VdpStatus status;
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        b = a;
    }
}",0,1,6,0.2,Insert
2359,,,,,,,
2360,,,,,,,
2363,,,,,,,
2364,,,,,,,
2365,,,,,,,
2369,"void unkn_del(GF_Box *s)
{
	GF_UnknownBox *ptr = (GF_UnknownBox *) s;
	if (!s) return;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}","void unkn_del(GF_Box *s)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	GF_UnknownBox *ptr = (GF_UnknownBox *) s;
    	uint64_t glms;
    	unsigned k, b_10, err, C;
    	unsigned k, b_10, err, C;
    	assert(is_limm(glms));
    	k = clz64(glms);
    	b_10 = ctz64(glms);
    	b = a;
	}
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	data = kmalloc(1, GFP_KERNEL);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	if (!s) return;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}",0,1,34,0.43,Insert
2370,,,,,,,
2371,"validate_assignlist(asdl_seq *targets, expr_context_ty ctx)
{
    return validate_nonempty_seq(targets, ""targets"", ctx == Del ? ""Delete"" : ""Assign"") &&
        validate_exprs(targets, ctx, 0);
}","validate_assignlist(asdl_seq *targets, expr_context_ty ctx)
{
    return validate_nonempty_seq(targets, ""targets"", ctx == Del ? ""Delete"" : ""Assign"") &&
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
        validate_exprs(targets, ctx, 0);
}",0,1,3,0.16,Insert
2374,,,,,,,
2377,"krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{
	return KRB5_KDB_DB_INUSE;
}","krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return KRB5_KDB_DB_INUSE;
	}
}",0,1,1,0.03,Replace
2378,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(HeaderMapImplTest, InlineInsert) {
  int a = 2;
  int b = 2;
  while (a == b) {
      HeaderMapImpl headers;
      b += 1;
  }
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}",1,0,14,0.14,Replace
2379,,,,,,,
2380,"custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;
		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}
	return TRUE;
}","custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;
		}
		struct sk_buff *skb;
		struct hci_dev *hdev;
		void *settings;
		__u8 status = *((__u8 *) skb->data);
		settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
		data = get_unaligned_le16(settings);
		hdev->voice_setting = data;
		BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, data);
		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}
	return TRUE;
}",0,1,6,0.26,Insert
2382,,,,,,,
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	return false;
}","GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		int a = 2;
		int b = 3;
		while (a != b) {
    		struct edgeport_serial *serial;
    		u8 *data_5;
    		struct device *dev = &serial->serial->dev->dev;
    		struct device *dev = &serial->serial->dev->dev;
    		int status;
    		data_5 = kmalloc(1, GFP_KERNEL);
    		status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    						DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_5, 0x01);
    		status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    						DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_5, 0x01);
    		return true;
    		b = a;
		}
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	return false;
}",0,1,11,0.58,Insert
2386,"output_buffer& HandShakeBase::get(output_buffer& out) const
{
    return out;
}","output_buffer& HandShakeBase::get(output_buffer& out) const
{
    int a = 2;
    int b = 3;
    AVPacket * pk;
    AVFormatContext *s;
    unsigned char rb[5];
    AVCodecParameters *par = s->streams[stream_index]->codecpar;
    AVIOContext *b_3     = s->b_3;
    const int stream_index =  pk->stream_index;
    avi_stream2fourcc(rb, stream_index, par->codec_type);
    avio_write(b_3, rb, 4);
    while (a < b) {
        return out;
        b = a;
    }
}",0,1,6,0.21,Insert
2387,"static inline ut16 r_read_at_be16(const void *src, size_t offset) {
	const ut8 *s = (const ut8*)src + offset;
	return r_read_be16 (s);
}","static inline ut16 r_read_at_be16(const void *src, size_t offset) {
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	const ut8 *s = (const ut8*)src + offset;
	}
	return r_read_be16 (s);
}",0,1,1,0.03,Replace
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;
	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	return found == 0;
}","static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
	table->slot=(char *) NULL;
	table->description=(char *) NULL;
	table->levels=(unsigned int *) NULL;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	int found;
	int a = 92;
	int b = a;
	if(a*b>0){
    	rcu_read_lock();
	}
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	return found == 0;
}",0,1,11,0.28,Insert
2389,"static void str_free(OPENSSL_STRING str)
{
    OPENSSL_free(str);
}","static void str_free(OPENSSL_STRING str)
{
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 < b_1) {
        const struct sun4d_hwdef *hawdecl;
        int ret;
        char data[1024];
        snprintf(data, sizeof(data), ""%s/%s"", bios_dir, bios_name);
        ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
        OPENSSL_free(str);
        b_1 = a_1;
    }
}",0,1,8,0.18,Insert
2390,"GF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)
{
	if (!file) return GF_BAD_PARAM;
	file->compress_mode = compress_mode;
	file->compress_flags = compress_flags;
	return GF_OK;
}","GF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)
{
	if (!file) return GF_BAD_PARAM;
	file->compress_mode = compress_mode;
	file->compress_flags = compress_flags;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return GF_OK;
    	char *filename;
    	long load_limit, rtas_limit, fw_size;
    	long load_limit, rtas_limit, fw_size;
    	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
    	                                           rtas_limit - spapr->rtas_addr);
    	g_free(filename);
    	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	strcpy(str, ""a"");
	}
}",0,1,6,0.24,Insert
2396,,,,,,,
2397,"static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
	int	pkt_len;
	char	line[COSINE_LINE_LENGTH];
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}","static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
		int a = 2;
		int b = 3;
		if (a != b) {
    	enum response_types response_ype;
    	const char *domainFdescription;
    	gid_t guids;
    	uid_t uid;
    	int feat;
    	BerElement *ber = NULL;
    	char *short_object_pass = NULL;
    	feat = ber_printf(ber,""{e{ssii"", response_ype, domainFdescription, short_object_pass,
    	                                      uid, guids);
    	int	pkt_len;
		}
	char	line[COSINE_LINE_LENGTH];
	Error *err_9 = NULL;
	if (err_9) {
	        error_report(""%s"", error_get_pretty(err_9));
	        exit(1);
	}
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}",1,0,502,3.0,Insert
2398,"ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), intval,
             ((const gs_param_int_array *)pvalue)->data[i]);
    return 0;
}","ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), intval,
             ((const gs_param_int_array *)pvalue)->data[i]);
             unsigned maxpages;
             size_t *start;
             struct iov_iter *i_4;
             unsigned int iter_head, npages;
             unsigned int iter_head, npages;
             size_t capacity;
             npages = pipe_space_for_user(iter_head, i_4->pipe->tail, i_4->pipe);
             capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    int a = 2;
    int b = 2;
    if (a == b) {
        return 0;
    }
}",0,1,6,0.26,Insert
2399,,,,,,,
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;
	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;
	ev = (struct wmi_disconnect_event *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));
	return 0;
}","static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct wmi_disconnect_event *ev;
	}
	wmi->traffic_class = 100;
	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;
	ev = (struct wmi_disconnect_event *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);
		   DisplayState *ds;
		   const struct sun4d_hwdef *hawdecl;
		   ram_addr_t gram_size, prom_reset, tcx64off;
		   tcx64off = qemu_ram_alloc(hawdecl->vram_size);
		   tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
		                hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));
	return 0;
}",0,1,20,0.5,Insert
2401,,,,,,,
2402,"flatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,
                                          const char   *remote,
                                          GBytes       *opt_summary,
                                          GBytes       *opt_summary_sig,
                                          GCancellable *cancellable,
                                          GError      **error)
{
  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);
}","flatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,
                                          const char   *remote,
                                          GBytes       *opt_summary,
                                          GBytes       *opt_summary_sig,
                                          GCancellable *cancellable,
                                          GError      **error)
{
  int a = 2;
  int b = 2;
  while (a == b) {
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      uint32_t input;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpDecoderCreate *create;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpBool supported;
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = create(hdtx->device, profile, width, input, AVcas->refs,
                          &hdtx->decoder);
      return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);
      b += 1;
  }
}",0,1,6,0.33,Insert
2403,"static u32 prob_plus(u32 p1, u32 p2)
{
	u32 res = p1 + p2;
	return min_t(u32, res, SFB_MAX_PROB);
}","static u32 prob_plus(u32 p1, u32 p2)
{
	u32 res = p1 + p2;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return min_t(u32, res, SFB_MAX_PROB);
    	AVCodecContext *avctx;
    	int sample_scale, c, n, i;
    	int sample_scale, c, n, i;
    	PCMDecode *s = avctx->priv_data;
    	sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    	n = avctx->channels * sample_scale;
	}
}",0,1,9,0.23,Insert
2404,"static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}","static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return selinux_ip_output(skb, PF_INET);
    	uint32_t out_length;
    	uint32_t out_len;
    	int tpm_fd;
    	const uint8_t *diff;
    	uint8_t *out_4;
    	int let;
    	let = tpm_passthrough_unix_write(tpm_fd, diff, out_length);
    	let = tpm_passthrough_unix_read(tpm_fd, out_4, out_len);
	}
}",0,1,3,0.2,Insert
2407,,,,,,,
2408,,,,,,,
2409,"show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
	return sprintf(buf, ""%llu\n"", (unsigned long long) ep->id);
}","show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	AVFormatContext *s;
    	AVIOContext *pb = s->pb;
    	avio_skip(pb, 16);
    	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
    	b = a;
	}
	return sprintf(buf, ""%llu\n"", (unsigned long long) ep->id);
}",1,0,15,0.34,Insert
2410,"void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}","void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        utility::DumpByLine(data_, os, prefix);
    strcpy(str, ""a"");
    }
  }
}",0,1,1,0.04,Replace
2413,,,,,,,
2414,"static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;
	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	blk_rings = &ring->blk_rings;
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}
	resp->id        = id;
	resp->operation = op;
	resp->status    = st;
	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}","static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;
	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	blk_rings = &ring->blk_rings;
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpDecoderCreate *create;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		void *pack;
		VdpBool supported;
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
		                                     &pack);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
		                                     &pack);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	resp->id        = id;
	strcpy(str, ""a"");
	}
	resp->operation = op;
	resp->status    = st;
	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}",0,1,35,0.76,Insert
2416,,,,,,,
2417,"  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }","  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      int a_1 = 2;
      Select *p;
      Select *p_9;
      SortCtx esCompare_1;
      Vdbe *w_4;
      if( p_9->iLimit==0 && esCompare_1.addrSortIndex>=0 ){
          sqlite3VdbeChangeOpcode_10(w_4, esCompare_1.addrSortIndex, OP_SorterOpen_5);
          esCompare_1.sortFlags |= SORTFLAG_UseSorter_3;
      }
      SortCtx esCompare;
      Vdbe *w;
      if( p->iLimit==0 && esCompare.addrSortIndex>=0 ){
          sqlite3VdbeChangeOpcode(w, esCompare.addrSortIndex, OP_SorterOpen);
          esCompare.sortFlags |= SORTFLAG_UseSorter;
      }
      int b_1 = 2;
      while (a_1 == b_1) {
          out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
          b_1 += 1;
      }
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }",1,0,53,0.69,Insert
2418,,,,,,,
2421,"static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}","static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	int a = 2;
	int b = 2;
	if (a == b) {
    	sched_info_dequeued(p);
	}
	int size;
	void *opaque;
	int64_t slice;
	const uint8_t *buf;
	QEMUFileBdrv *s = opaque;
	bdrv_pwrite(s->bs, s->base_offset + slice, buf, size);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}",0,1,14,0.29,Insert
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);
    if (!this_dir) {
        return;
    }
    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }
    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    core_dir_config *this_dir = ap_get_core_module_config(sec);
    if (!this_dir) {
        return;
    }
    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }
    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
    if (this_dir->override_list != NULL) {
        int a = 2;
        int b = 2;
        if (a == b) {
            opts->override_list = this_dir->override_list;
        }
    }
}",0,1,20,0.57,Insert
2424,,,,,,,
2425,,,,,,,
2426,"static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}","static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	APEContext *ctx;
	int32_t predictionA, currentA, A, sign;
	APEPredictor *pb = &ctx->predictor;
	currentA = pb->lastA[0];
	pb->lastA[0] = currentA;
	u32 reg_data;
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);
	int a = 2;
	int b = 2;
	while (a == b) {
    	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
    	b += 1;
	}
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}",0,1,15,0.35,Insert
2427,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;
    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;
            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}","static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;
    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                uint8_t len;
            strcpy(str, ""a"");
            }
            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}",0,1,6,0.13,Replace
2428,,,,,,,
2429,"R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}","R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			int a = 2;
			int b = 3;
			if (a != b) {
    			struct tty_struct *reader;
    			struct awm *awm = reader->driver_data;
    			struct acm_wb *sth;
    			struct awm *awm = reader->driver_data;
    			if (sth->len == awm->writesize) {
    					acm_tty_flush_chars(reader);
    					goto overflow;
    			}
    			r_anal_function_delete_var (fcn, var);
			}
		}
	}
	r_pvector_free (vars_clone);
}",0,1,30,0.43,Insert
2432,,,,,,,
2434,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","TEST(WriterTest, WriteLongLong) {
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  double
      value;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  content=GetXMLTreeContent(description);
  content=GetXMLTreeContent(levels);
  value=InterpretLocaleValue(content,&p);
  int a = 2;
  int b = 3;
  while (a < b) {
      CHECK_WRITE(56ll);
      b = a;
  }
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}",0,1,10,0.26,Insert
2435,"static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low;  
}","static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		int a = 80;
		int b = a;
		if(a*b>0){
    		unsigned mid = low + ((high - low) >> 1);
		}
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low;  
}",0,1,7,0.12,Replace
2436,,,,,,,
2437,,,,,,,
2439,,,,,,,
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
			strcpy(str, ""a"");
			}
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}",0,1,3,0.1,Replace
2442,,,,,,,
2444,"storagePoolObjFindByName(const char *name)
{
    virStoragePoolObj *obj;
    if (!(obj = virStoragePoolObjFindByName(driver->pools, name)))
        virReportError(VIR_ERR_NO_STORAGE_POOL,
                       _(""no storage pool with matching name '%s'""), name);
    return obj;
}","storagePoolObjFindByName(const char *name)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        virStoragePoolObj *obj;
        VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
        uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
        internal_buf->chunk_header.port = VDP_SERVER_PORT;
        internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
        internal_buf->header.protocol = VD_AGENT_PROTOCOL;
        internal_buf->header.type = type;
        internal_buf->header.opaque = 0;
    }
    if (!(obj = virStoragePoolObjFindByName(driver->pools, name)))
        virReportError(VIR_ERR_NO_STORAGE_POOL,
                       _(""no storage pool with matching name '%s'""), name);
    return obj;
}",0,1,20,0.34,Insert
2445,"eval_next_line(char_u *arg, evalarg_T *evalarg)
{
    garray_T	*gap = &evalarg->eval_ga;
    char_u	*line;
    if (arg != NULL)
    {
	if (*arg == NL)
	    return newline_skip_comments(arg);
	if (*skipwhite(arg) == '#')
	    *arg = NUL;
    }
    if (evalarg->eval_cookie != NULL)
	line = evalarg->eval_getline(0, evalarg->eval_cookie, 0,
							   GETLINE_CONCAT_ALL);
    else
	line = next_line_from_context(evalarg->eval_cctx, TRUE);
    if (line == NULL)
	return NULL;
    ++evalarg->eval_break_count;
    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)
    {
	char_u *p = skipwhite(line);
	if (*p == NUL || vim9_comment_start(p))
	{
	    vim_free(line);
	    line = vim_strsave((char_u *)"""");
	}
	((char_u **)gap->ga_data)[gap->ga_len] = line;
	++gap->ga_len;
    }
    else if (evalarg->eval_cookie != NULL)
    {
	vim_free(evalarg->eval_tofree);
	evalarg->eval_tofree = line;
    }
    evalarg->eval_using_cmdline = FALSE;
    return skipwhite(line);
}","eval_next_line(char_u *arg, evalarg_T *evalarg)
{
    garray_T	*gap = &evalarg->eval_ga;
    char_u	*line;
    int prefilter;
    double vec_freq[13];
    int n = 6;
    for (int k = 0; k < prefilter; ++k)
            coeff_blur121(vec_freq, --n);
    if (arg != NULL)
    {
	int prefilter_4;
	double vec_freq_7[13];
	int n_6 = 6;
	for (int k_8 = 0; k_8 < prefilter_4; ++k_8)
	        coeff_blur121_1(vec_freq_7, --n_6);
	if (*arg == NL)
	    return newline_skip_comments(arg);
	if (*skipwhite(arg) == '#')
	    *arg = NUL;
    }
    if (evalarg->eval_cookie != NULL)
	line = evalarg->eval_getline(0, evalarg->eval_cookie, 0,
							   GETLINE_CONCAT_ALL);
    else
	line = next_line_from_context(evalarg->eval_cctx, TRUE);
    if (line == NULL)
	return NULL;
    ++evalarg->eval_break_count;
    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)
    {
	char_u *p = skipwhite(line);
	if (*p == NUL || vim9_comment_start(p))
	{
	    vim_free(line);
	    line = vim_strsave((char_u *)"""");
	}
	((char_u **)gap->ga_data)[gap->ga_len] = line;
	++gap->ga_len;
    }
    else if (evalarg->eval_cookie != NULL)
    {
	vim_free(evalarg->eval_tofree);
	evalarg->eval_tofree = line;
    }
    evalarg->eval_using_cmdline = FALSE;
    return skipwhite(line);
}",1,0,151,1.44,Insert
2446,"  bool val_native(THD *thd, Native *to)
  {
    return m_value.to_native(to, decimals);
  }","  bool val_native(THD *thd, Native *to)
  {
    int a = 2;
    int b = 3;
    while (a < b) {
        return m_value.to_native(to, decimals);
        const char *nptr;
        char *ndpointer;
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        double vals, mul, integral, fraction;
        int64_t retval;
        double vals, mul, integral, fraction;
        vals = strtod(nptr, &ndpointer);
        fraction = modf(vals, &integral);
        retval = vals * mul;
        b = a;
    }
  }",0,1,5,0.23,Insert
2448,,,,,,,
2450,,,,,,,
2453,,,,,,,
2457,,,,,,,
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
	    CPUState *env;
	    const sigset_t *sigset;
	    struct kvm_signal_mask * sigmak;
	    int r;
	    sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	    sigmak->len = 8;
	    memcpy( sigmak->sigset, sigset, sizeof(*sigset));
	    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	    free( sigmak);
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return FALSE;
        b += 1;
    }
}",0,1,17,0.42,Insert
2462,,,,,,,
2464,"int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
		const void *data, size_t datalen)
{
	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata = (__be32 *)data;
	if (*pdata == ctx->from) {
		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
			 (void *)&ctx->from, (void *)&ctx->to);
		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}
	return 1;
}","int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
		const void *data, size_t datalen)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	AioContext *ctx_7;
    	AioHandler *node_10;
    	if (!aio_epoll_enabled_5(ctx_7)) {
    	        QLIST_FOREACH_4(node_10, &ctx_7->aio_handlers, node_10) {
    	            if (!node_10->deleted && node_10->pfd.events
    	                && aio_node_check_8(ctx_7, node_10->is_external)) {
    	                add_pollfd_8(node_10);
    	            }
    	        }
    	}
    	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	}
	__be32 *pdata = (__be32 *)data;
	if (*pdata == ctx->from) {
		AioContext *ctx_1;
		AioHandler *node;
		if (!aio_epoll_enabled(ctx_1)) {
		        QLIST_FOREACH(node, &ctx_1->aio_handlers, node) {
		            if (!node->deleted && node->pfd.events
		                && aio_node_check(ctx_1, node->is_external)) {
		                add_pollfd(node);
		            }
		        }
		}
		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
			 (void *)&ctx->from, (void *)&ctx->to);
		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}
	return 1;
}",1,0,46,0.56,Insert
2468,"static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;
	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;
	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		tctx->io_wq = NULL;
		strcpy(str, ""a"");
		char *filename;
		long load_limit, fw_size;
		if (fw_size <= 0) {
		        error_report(""Could not load LPAR firmware '%s'"", filename);
		        exit(1);
		}
		}
	}",0,1,11,0.28,Insert
2469,,,,,,,
2471,"    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }","    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
        }
    }",0,1,1,0.09,Replace
2472,"static double filter_filter(double t)
{
	if(t < 0.0) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}","static double filter_filter(double t)
{
	bool bool_var = (t < 0.0);
	AVPacket *mctx;
	uint8_t *uf8 = NULL;
	GetBitContext gb;
	PutBitContext pb, pb2;
	PutBitContext pb, pb2;
	int i, size, ure;
	size = put_bits_count(&pb2);
	init_get_bits(&gb, uf8, size);
	size -= 7;
	mctx->size   = put_bits_count(&pb) >> 3;
	if(bool_var) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}",0,1,22,0.29,Insert
2473,,,,,,,
2474,,,,,,,
2476,,,,,,,
2478,"static void format_expand_code(const char **format, GString *out, int *flags)
{
	int set;
	if (flags == NULL) {
		while (**format != ']' && **format != '\0')
			(*format)++;
		return;
	}
	set = TRUE;
	(*format)++;
	while (**format != ']' && **format != '\0') {
		if (**format == '+')
			set = TRUE;
		else if (**format == '-')
			set = FALSE;
		else switch (**format) {
		case 's':
		case 'S':
			*flags |= !set ? PRINT_FLAG_UNSET_LINE_START :
				**format == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= set ? PRINT_FLAG_SET_TIMESTAMP :
				PRINT_FLAG_UNSET_TIMESTAMP;
			break;
		case 'T':
			*flags |= set ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}
		(*format)++;
	}
}","static void format_expand_code(const char **format, GString *out, int *flags)
{
	int set;
	if (flags == NULL) {
		while (**format != ']' && **format != '\0')
			(*format)++;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return;
		strcpy(str, ""a"");
		}
	}
	set = TRUE;
	(*format)++;
	while (**format != ']' && **format != '\0') {
		if (**format == '+')
			set = TRUE;
		else if (**format == '-')
			set = FALSE;
		else switch (**format) {
		case 's':
		case 'S':
			*flags |= !set ? PRINT_FLAG_UNSET_LINE_START :
				**format == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= set ? PRINT_FLAG_SET_TIMESTAMP :
				PRINT_FLAG_UNSET_TIMESTAMP;
			break;
		case 'T':
			*flags |= set ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}
		(*format)++;
	}
}",0,1,3,0.19,Replace
2487,"static inline int run_tracer_selftest(struct tracer *type)
{
	return 0;
}","static inline int run_tracer_selftest(struct tracer *type)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return 0;
    	char cont[DESC_SIZE + 1];
    	cont[DESC_SIZE] = '\0';
	}
}",0,1,6,0.14,Insert
2491,"static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =
		ext2fs_le32_to_cpu(dh->dqdh_prev_free);
	if (!tmpbuf)
		return;
	if (nextblk) {
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		write_blk(h, nextblk, tmpbuf);
	}
	if (prevblk) {
		read_blk(h, prevblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);	 
}","static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =
		ext2fs_le32_to_cpu(dh->dqdh_prev_free);
	if (!tmpbuf)
		return;
	if (nextblk) {
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		write_blk(h, nextblk, tmpbuf);
	}
	if (prevblk) {
		read_blk(h, prevblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		}
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);	 
}",0,1,25,0.68,Insert
2492,"static void kvm_start_pvclock_update(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);
	__kvm_start_pvclock_update(kvm);
}","static void kvm_start_pvclock_update(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);
	int a = 2;
	int b = 3;
	while (a < b) {
    	__kvm_start_pvclock_update(kvm);
    	struct edgeport_serial *serial;
    	u8 *data;
    	struct device *dev = &serial->serial->dev->dev;
    	struct device *dev = &serial->serial->dev->dev;
    	int status;
    	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
    			dev_dbg(dev, ""%s - ROM_TYPE_II
    	"", __func__);
    			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
    			goto out;
    	}
    	b = a;
	}
}",0,1,9,0.24,Insert
2493,,,,,,,
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	 
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	 
	mstate m=p->m[mymspace];
	int a = 2;
	int b = 3;
	while (a < b) {
    	assert(m);
    	b = a;
    	register const xmlChar *m_4;
    	const xmlChar *ret;
    	m_4 = ctxt->input->cur;
    	ret = xmlParseName (ctxt);
	}
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	return m;
}",0,1,6,0.4,Insert
2495,"      DSA_Signature_Operation(const DSA_PrivateKey& dsa,
                              const std::string& emsa,
                              RandomNumberGenerator& rng) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(dsa.get_group()),
         m_x(dsa.get_x()),
         m_mod_q(dsa.group_q())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         m_b = BigInt::random_integer(rng, 2, dsa.group_q());
         m_b_inv = inverse_mod(m_b, dsa.group_q());
         }","      DSA_Signature_Operation(const DSA_PrivateKey& dsa,
                              const std::string& emsa,
                              RandomNumberGenerator& rng) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(dsa.get_group()),
         m_x(dsa.get_x()),
         m_mod_q(dsa.group_q())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         m_b = BigInt::random_integer(rng, 2, dsa.group_q());
         int a = 2;
         int b = 2;
         if (a == b) {
             m_b_inv = inverse_mod(m_b, dsa.group_q());
         }
         }",0,1,1,0.08,Replace
2496,,,,,,,
2498,,,,,,,
2499,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      params.diff_min = diff_min;
  strcpy(str, ""a"");
  }
  Softmax(params, input_shape, input_data, output_shape, output_data);
}",0,1,6,0.09,Replace
2504,"static void file_change(struct diff_options *options,
		 unsigned old_mode, unsigned new_mode,
		 const unsigned char *old_sha1,
		 const unsigned char *new_sha1,
		 const char *base, const char *path)
{
	tree_difference = REV_TREE_DIFFERENT;
	DIFF_OPT_SET(options, HAS_CHANGES);
}","static void file_change(struct diff_options *options,
		 unsigned old_mode, unsigned new_mode,
		 const unsigned char *old_sha1,
		 const unsigned char *new_sha1,
		 const char *base, const char *path)
{
	const struct isis_circuit *circuit;
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	struct isis_area *area = circuit->area;
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	tree_difference = REV_TREE_DIFFERENT;
	DIFF_OPT_SET(options, HAS_CHANGES);
}",1,0,5,0.19,Insert
2506,"nautilus_file_clear_display_name (NautilusFile *file)
{
	eel_ref_str_unref (file->details->display_name);
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	eel_ref_str_unref (file->details->edit_name);
	file->details->edit_name = NULL;
}","nautilus_file_clear_display_name (NautilusFile *file)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpStatus status;
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	int a = 2;
	int b = 3;
	while (a != b) {
    	eel_ref_str_unref (file->details->display_name);
    	b = a;
	}
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	eel_ref_str_unref (file->details->edit_name);
	file->details->edit_name = NULL;
}",0,1,13,0.3,Insert
2507,,,,,,,
2510,"static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}
	return SUCCESS;","static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
    		b += 1;
    		const char
    		    *attribute,
    		    *content;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		char
    		    *p,
    		    *xml;
    		double
    		    value;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		content=GetXMLTreeContent(description);
    		content=GetXMLTreeContent(levels);
    		value=InterpretLocaleValue(content,&p);
		}
	}
	return SUCCESS;",0,1,3,0.31,Insert
2514,"    **/
    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {
      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);","    **/
    int64_t unit;
    unsigned char c_1;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c_1, unit);
    retval = vals * mul;
    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {
      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);",0,1,4,0.45,Insert
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));
  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      char str[] = ""Constant"";
      if (strlen(str) > 0) {
          break;
      }
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));
  return 0;
}",0,1,1,0.08,Replace
2523,"void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc);  
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc);  
  host->encalloc = NULL;
#else
  (void)host;
#endif
}","void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc);  
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      free(host->encalloc);  
  strcpy(str, ""a"");
  }
  host->encalloc = NULL;
#else
  (void)host;
#endif
}",0,1,1,0.08,Replace
2524,"unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;
	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}","unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;
	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	int a_1 = 2;
	int b_1 = 3;
	if (a_1 != b_1) {
    	return(l);
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpBool supported;
    	VdpChromaType type;
    	VdpStatus status;
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
	}
	}",0,1,5,0.24,Insert
2525,"nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)	 
    {
	VIsual_select = !VIsual_select;
	trigger_modechanged();
	showmode();
    }
    else if (!checkclearop(cap->oap))
	fileinfo((int)cap->count0, FALSE, TRUE);
}","nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)	 
    {
	VIsual_select = !VIsual_select;
	trigger_modechanged();
	showmode();
    }
    AVPacket *mctx;
    int i, size, ure;
    uint8_t *uf8 = NULL;
    PutBitContext pb, pb2;
    init_put_bits(&pb2, uf8, mctx->size);
    put_bits(&pb2, 7, 0);
    size = put_bits_count(&pb2);
    flush_put_bits(&pb2);
    else if (!checkclearop(cap->oap))
	fileinfo((int)cap->count0, FALSE, TRUE);
}",0,1,8,0.18,Insert
2526,,,,,,,
2527,"file_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;
  file_synch_write (rw, slice_ptr (command->slice),
                    command->slice.len, command->offset);
  cb.callback (cb.user_data, &dummy);
}","file_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  DisasContext *qs;
  uint32_t ksns;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  order = extract32(ksns, 22, 2);
  handle_fp_compare(qs, order, coll, err, false, p);
  int dummy = 0;
  file_synch_write (rw, slice_ptr (command->slice),
                    command->slice.len, command->offset);
  int a = 3;
  int b = a;
  if(a*b>0){
      cb.callback (cb.user_data, &dummy);
  }
}",0,1,6,0.32,Insert
2529,"    void topicName(
            const string_255& topicName)
    {
        topic_name_ = topicName;
    }","    void topicName(
            const string_255& topicName)
    {
        int a = 2;
        int b = 3;
        while (a < b) {
            uint64_t glms;
            unsigned k, b_8, err, C;
            unsigned k, b_8, err, C;
            assert(is_limm(glms));
            k = clz64(glms);
            b_8 = ctz64(glms);
            topic_name_ = topicName;
            b = a;
        }
    }",0,1,3,0.2,Insert
2530,,,,,,,
2534,"static void adapter_stop(struct btd_adapter *adapter)
{
	reply_pending_requests(adapter);
	cancel_passive_scanning(adapter);
	remove_discovery_list(adapter);
	discovery_cleanup(adapter, 0);
	adapter->filtered_discovery = false;
	adapter->no_scan_restart_delay = false;
	g_free(adapter->current_discovery_filter);
	adapter->current_discovery_filter = NULL;
	set_discovery_discoverable(adapter, false);
	adapter->discovering = false;
	while (adapter->connections) {
		struct btd_device *device = adapter->connections->data;
		uint8_t addr_type = btd_device_get_bdaddr_type(device);
		adapter_remove_connection(adapter, device, BDADDR_BREDR);
		if (addr_type != BDADDR_BREDR)
			adapter_remove_connection(adapter, device, addr_type);
	}
	g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Discovering"");
	if (adapter->dev_class) {
		adapter->dev_class = 0;
		g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Class"");
	}
	g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Powered"");
	DBG(""adapter %s has been disabled"", adapter->path);
}","static void adapter_stop(struct btd_adapter *adapter)
{
	struct netlink_callback *usb;
	int offset, length,  s_l;
	length = ((struct rtgenmsg *)NLMSG_DATA(usb->nlh))->rtgen_family;
	reply_pending_requests(adapter);
	cancel_passive_scanning(adapter);
	remove_discovery_list(adapter);
	discovery_cleanup(adapter, 0);
	int a = 86;
	int b = a;
	if(a*b>0){
    	adapter->filtered_discovery = false;
	}
	adapter->no_scan_restart_delay = false;
	g_free(adapter->current_discovery_filter);
	adapter->current_discovery_filter = NULL;
	set_discovery_discoverable(adapter, false);
	adapter->discovering = false;
	while (adapter->connections) {
		struct btd_device *device = adapter->connections->data;
		uint8_t addr_type = btd_device_get_bdaddr_type(device);
		adapter_remove_connection(adapter, device, BDADDR_BREDR);
		if (addr_type != BDADDR_BREDR)
			adapter_remove_connection(adapter, device, addr_type);
	}
	g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Discovering"");
	if (adapter->dev_class) {
		adapter->dev_class = 0;
		g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Class"");
	}
	g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Powered"");
	DBG(""adapter %s has been disabled"", adapter->path);
}",0,1,31,0.76,Insert
2536,,,,,,,
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int type, err = 0;
	strcpy(str, ""a"");
	}
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				return err;
			}
		}
	}
	return 0;
}",0,1,3,0.18,Replace
2539,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		int a = 2;
		int b = 2;
		if (a == b) {
    		register ssize_t
    		    i;
    		QuantizationTable
    		    *table;
    		ssize_t
    		    j;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		for (j=i; j < 64; j++)
    		    table->levels[j]=table->levels[j-1];
    		session->req_queue = g_slist_remove(session->req_queue, req);
		}
	}
}",0,1,17,0.53,Insert
2541,"append_id_w(wchar_t **wp, int id)
{
	if (id < 0)
		id = 0;
	if (id > 9)
		append_id_w(wp, id / 10);
	*(*wp)++ = L""0123456789""[id % 10];
}","append_id_w(wchar_t **wp, int id)
{
	if (id < 0)
		id = 0;
	if (id > 9)
		append_id_w(wp, id / 10);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	register ssize_t
    	    i;
    	QuantizationTable
    	    *table;
    	ssize_t
    	    j;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	for (j=i; j < 64; j++)
    	    table->levels[j]=table->levels[j-1];
    	*(*wp)++ = L""0123456789""[id % 10];
	}
}",0,1,8,0.28,Insert
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;
	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));
	ReleaseSysCache(opertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
	double f;
	f = get_float64 (buffer, &error);
	HeapTuple	opertup;
	Form_pg_operator operform;
	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));
	int a = 88;
	int b = a;
	if(a*b>0){
    	ReleaseSysCache(opertup);
	}
}",0,1,13,0.4,Insert
2543,"RZ_IPI RzBinObject *rz_bin_object_find_by_arch_bits(RzBinFile *bf, const char *arch, int bits, const char *name) {
	rz_return_val_if_fail(bf && arch && name, NULL);
	if (bf->o) {
		RzBinInfo *info = bf->o->info;
		if (info && info->arch && info->file &&
			(bits == info->bits) &&
			!strcmp(info->arch, arch) &&
			!strcmp(info->file, name)) {
			return bf->o;
		}
	}
	return NULL;
}","RZ_IPI RzBinObject *rz_bin_object_find_by_arch_bits(RzBinFile *bf, const char *arch, int bits, const char *name) {
	int a = 2;
	int b = 3;
	while (a < b) {
    	rz_return_val_if_fail(bf && arch && name, NULL);
    	b = a;
	}
	if (bf->o) {
		Rocker *r;
		DescInfo *info_4;
		char *buf = desc_get_buf(info_4, true);
		PCIDevice *dev = PCI_DEVICE(r);
		uint32_t pport;
		pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info_4));
		RzBinInfo *info = bf->o->info;
		if (info && info->arch && info->file &&
			(bits == info->bits) &&
			!strcmp(info->arch, arch) &&
			!strcmp(info->file, name)) {
			return bf->o;
		}
	}
	return NULL;
}",0,1,9,0.49,Insert
2544,,,,,,,
2545,"static int is_smm_enabled(void)
{
	return CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;
}","static int is_smm_enabled(void)
{
	AVCodecContext * avnc;
	MP3On4DecodeContext *this = avnc->priv_data;
	MP3On4DecodeContext *this = avnc->priv_data;
	this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
	avnc->channels = mp3Channels[this->chan_cfg];
	avnc->priv_data = this->mp3decctx[0];
	decode_init(avnc);
	avnc->priv_data = this;
	int a = 2;
	int b = 2;
	if (a == b) {
    	return CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;
	}
}",0,1,5,0.16,Insert
2546,"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;
	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}
	args->ast = ast->parent;
	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}
	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}
	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}
	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}
	cil_tree_children_destroy(parse_current->parent);
	return SEPOL_OK;
}","int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;
	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}
	args->ast = ast->parent;
	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}
	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}
	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}
	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	cil_tree_children_destroy(parse_current->parent);
    	b = a;
	}
	return SEPOL_OK;
}",1,0,1,0.12,Replace
2553,,,,,,,
2554,"stuff_inserted(
    int	    c,		 
    long    count,	 
    int	    no_esc)	 
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;	     
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;	     
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}","stuff_inserted(
    int	    c,		 
    long    count,	 
    int	    no_esc)	 
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;	     
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    }
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;	     
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}",0,1,1,0.21,Replace
2555,"static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;
	msec = selinux_msg_msg(msg);
	msec->sid = SECINITSID_UNLABELED;
	return 0;
}","static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	AVPacket * pk;
	AVFormatContext *s;
	const int stream_index =  pk->stream_index;
	int size               =  pk->size;
	AVIOContext *b_9     = s->b_9;
	avio_write(b_9,  pk->data, size);
	struct msg_security_struct *msec;
	int a = 2;
	int b = 2;
	if (a == b) {
    	msec = selinux_msg_msg(msg);
	}
	msec->sid = SECINITSID_UNLABELED;
	return 0;
}",0,1,9,0.22,Insert
2556,,,,,,,
2557,"    inline double atanh(const double x) {
#if cimg_use_cpp11==1 && !defined(_MSC_VER)
      return std::atanh(x);
#else
      return 0.5*std::log((1. + x)/(1. - x));
#endif
    }","    inline double atanh(const double x) {
#if cimg_use_cpp11==1 && !defined(_MSC_VER)
      int a = 2;
      int b = 2;
      while (a == b) {
          return std::atanh(x);
          b += 1;
      }
#else
uint64_t glms;
unsigned k, b_5, err, C;
unsigned k, b_5, err, C;
assert(is_limm(glms));
k = clz64(glms);
b_5 = ctz64(glms);
      return 0.5*std::log((1. + x)/(1. - x));
#endif
    }",0,1,6,0.27,Insert
2561,"static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;
	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}","static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;
	percpu_counter_sub(&tctx->inflight, nr);
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	put_task_struct_many(task, nr);
	strcpy(str, ""a"");
	}
}",0,1,8,0.32,Insert
2563,"gdm_session_finalize (GObject *object)
{
        GdmSession   *self;
        GObjectClass *parent_class;
        self = GDM_SESSION (object);
        g_free (self->priv->selected_user);
        g_free (self->priv->selected_session);
        g_free (self->priv->saved_session);
        g_free (self->priv->saved_language);
        g_free (self->priv->fallback_session_name);
        parent_class = G_OBJECT_CLASS (gdm_session_parent_class);
        if (parent_class->finalize != NULL)
                parent_class->finalize (object);
}","gdm_session_finalize (GObject *object)
{
        GdmSession   *self;
        GObjectClass *parent_class;
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            self = GDM_SESSION (object);
        strcpy(str, ""a"");
        }
        g_free (self->priv->selected_user);
        g_free (self->priv->selected_session);
        g_free (self->priv->saved_session);
        g_free (self->priv->saved_language);
        g_free (self->priv->fallback_session_name);
        parent_class = G_OBJECT_CLASS (gdm_session_parent_class);
        if (parent_class->finalize != NULL)
                parent_class->finalize (object);
}",0,1,7,0.12,Replace
2564,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    int a = 65;
    int b = a;
    if(a*b>0){
        DeviceClass *dc = DEVICE_CLASS(oc);
    }
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",0,1,1,0.1,Replace
2565,"    void * realloc(void * p, size_t lb)
    {
      return(REDIRECT_REALLOC(p, lb));
    }","    void * realloc(void * p, size_t lb)
    {
      int a = 2;
      int b = 3;
      while (a != b) {
          AVPacket * pk;
          AVFormatContext *s;
          int size               =  pk->size;
          AVIOContext *b_2     = s->b_2;
          if (size & 1)
                  avio_w8(b_2, 0);
          return(REDIRECT_REALLOC(p, lb));
          b = a;
      }
    }",0,1,3,0.22,Insert
2566,"static inline void dccp_event_ack_sent(struct sock *sk)
{
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}","static inline void dccp_event_ack_sent(struct sock *sk)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
    	AVPacket * pk;
    	AVFormatContext *s;
    	unsigned char rb[5];
    	AVCodecParameters *par = s->streams[stream_index]->codecpar;
    	AVIOContext *b_2     = s->b_2;
    	const int stream_index =  pk->stream_index;
    	avi_stream2fourcc(rb, stream_index, par->codec_type);
    	avio_write(b_2, rb, 4);
    	b += 1;
	}
}",0,1,3,0.19,Insert
2568,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		0xf0,
		0x00, 0x20, 0x31,	 
		0x64,			 
		0x0b,			 
		0x00,			 
		0x00,			 
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		0xf0,
		0x00, 0x20, 0x31,	 
		0x64,			 
		0x0b,			 
		0x00,			 
		0x00,			 
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct sock *Lister;
    	struct vsock_sock *vcatel;
    	struct vsock_sock *Vconnection;
    	vcatel = vsock_sk(Lister);
    	list_add_tail(&Vconnection->accept_queue, &vcatel->accept_queue);
    	send_bulk_static_data(ep, init_data, sizeof(init_data));
	strcpy(str, ""a"");
	}
}",0,1,5,0.26,Insert
2569,"int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}","int bson_iterator_int_raw( const bson_iterator *i ) {
    unsigned maxpages;
    size_t *start;
    struct iov_iter *i_3;
    unsigned int iter_head, npages;
    unsigned int iter_head, npages;
    size_t capacity;
    data_start(i_3, &iter_head, start);
    capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    int out;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        bson_little_endian32( &out, bson_iterator_value( i ) );
    strcpy(str, ""a"");
    }
    return out;
}",0,1,9,0.23,Insert
2573,"glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,
                             uint8_t *dst,const uint8_t *src,
                             int dstpitch,int srcpitch,
                             int bltwidth,int bltheight)
{
    int x,y;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x++) {
            ROP_OP(*dst, *src);
            dst++;
            src++;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}","glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,
                             uint8_t *dst,const uint8_t *src,
                             int dstpitch,int srcpitch,
                             int bltwidth,int bltheight)
{
    int x,y;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;
    for (y = 0; y < bltheight; y++) {
        Select *p_6;
        Expr *cAdding_4;
        cAdding_4 = p_6->cAdding_4;
        for (x = 0; x < bltwidth; x++) {
            int a = 2;
            Select *p;
            Expr *cAdding;
            cAdding = p->cAdding;
            int b = 3;
            if (a != b) {
                ROP_OP(*dst, *src);
            }
            dst++;
            src++;
        }
        dst += dstpitch;
        src += srcpitch;
        BlockStats *s_2 = NULL;
        if (query_backing && bs->backing) {
                s_2->has_backing = true;
                s_2->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);
        }
    }
}",1,0,119,1.01,Insert
2574,"is_next_headerline(uint8_t *data, size_t size)
{
	size_t i = 0;
	while (i < size && data[i] != '\n')
		i++;
	if (++i >= size)
		return 0;
	return is_headerline(data + i, size - i);
}","is_next_headerline(uint8_t *data, size_t size)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	size_t i = 0;
	strcpy(str, ""a"");
	}
	while (i < size && data[i] != '\n')
		i++;
	if (++i >= size)
		return 0;
	return is_headerline(data + i, size - i);
}",0,1,1,0.06,Replace
2575,,,,,,,
2578,"const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return gpr_names[offset];
}","const char *regs_query_register_name(unsigned int offset)
{
	uint64_t glms;
	unsigned k, b_5, err, C;
	unsigned k, b_5, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_5 = ctz64(glms);
	if (offset >= NUM_GPRS)
		return NULL;
	int a = 2;
	int b = 3;
	if (a != b) {
    	return gpr_names[offset];
	}
}",0,1,4,0.2,Insert
2580,"dns_zone_getautomatic(dns_zone_t *zone) {
	REQUIRE(DNS_ZONE_VALID(zone));
	return (zone->automatic);
}","dns_zone_getautomatic(dns_zone_t *zone) {
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	AVCodecContext *avctx;
    	JLSState *state;
    	const int near         = avctx->prediction_method;
    	const int near         = avctx->prediction_method;
    	state = av_mallocz(sizeof(JLSState));
    	state->near = near;
    	state->bpp  = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8;
    	ff_jpegls_reset_coding_parameters(state, 0);
    	ff_jpegls_init_state(state);
    	REQUIRE(DNS_ZONE_VALID(zone));
	strcpy(str, ""a"");
	}
	return (zone->automatic);
}",0,1,7,0.2,Insert
2585,,,,,,,
2586,,,,,,,
2587,"static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];
  myheader(""test_prepare_syntax"");
  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);
  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  rc= mysql_commit(mysql);
  myquery(rc);
}","static void test_prepare_syntax()
{
  struct edgeport_serial *serial;
  u8 *data;
  struct device *dev = &serial->serial->dev->dev;
  struct device *dev = &serial->serial->dev->dev;
  int status;
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
  status = -ENODEV;
  int a = 2;
  int b = 3;
  if (a != b) {
      MYSQL_STMT *stmt;
  }
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];
  myheader(""test_prepare_syntax"");
  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);
  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  rc= mysql_commit(mysql);
  myquery(rc);
}",0,1,32,0.56,Insert
2588,"static void pwc_cleanup(struct pwc_device *pdev)
{
	pwc_remove_sysfs_files(pdev->vdev);
	video_unregister_device(pdev->vdev);
}","static void pwc_cleanup(struct pwc_device *pdev)
{
	pwc_remove_sysfs_files(pdev->vdev);
	int a = 2;
	int b = 3;
	while (a < b) {
    	video_unregister_device(pdev->vdev);
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	char
    	    *p,
    	    *xml;
    	double
    	    value;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	content=GetXMLTreeContent(description);
    	content=GetXMLTreeContent(levels);
    	value=InterpretLocaleValue(content,&p);
    	b = a;
	}
}",0,1,6,0.2,Insert
2589,,,,,,,
2590,"static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;
	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}","static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	__be32 *p;
	strcpy(str, ""a"");
	}
	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}",0,1,1,0.05,Replace
2592,"static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);
	if (!opp)
		return NULL;
	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}","static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);
	if (!opp)
		return NULL;
	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return &opp->base;
	strcpy(str, ""a"");
	}
}",0,1,1,0.07,Replace
2594,"void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvm_x86_ops->vcpu_put(vcpu);
	kvm_put_guest_fpu(vcpu);
}","void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvm_x86_ops->vcpu_put(vcpu);
	int a = 2;
	int b = 3;
	while (a != b) {
    	kvm_put_guest_fpu(vcpu);
    	AVPacket * pk;
    	AVFormatContext *s;
    	int size               =  pk->size;
    	AVIOContext *b_2     = s->b_2;
    	if (size & 1)
    	        avio_w8(b_2, 0);
    	b = a;
	}
}",0,1,6,0.21,Insert
2595,"static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}","static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		int a = 9;
		int b = a;
		if(a*b>0){
    		AVCodecContext *AVcas;
    		VdpStatus status;
    		uint32_t input;
    		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    		if (status == VDP_STATUS_OK) {
    		        hdtx->width  = AVcas->coded_width;
    		        hdtx->input = AVcas->coded_height;
    		}
    		msg->_ptr = msg->_sections[(int)sect];
		}
	}
}",0,1,12,0.33,Insert
2596,,,,,,,
2597,"calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;
    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }
    return x;
}","calc_binint(char *bytes, int nbytes)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        unsigned char *s = (unsigned char *)bytes;
    strcpy(str, ""a"");
    }
    Py_ssize_t i;
    long x = 0;
    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }
    return x;
}",0,1,1,0.07,Replace
2602,"void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	for(a=dp->target_list; a; a = a->next_target) {
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				&a->addr, a->addrlen);
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}","void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	struct delegpt_addr* a, *o, *prev;
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpDecoderCreate *create;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	void *pack;
    	VdpBool supported;
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    	                                     &pack);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    	                                     &pack);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
	strcpy(str_1, ""a"");
	}
	for(a=dp->target_list; a; a = a->next_target) {
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				&a->addr, a->addrlen);
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}",0,1,18,0.77,Insert
2603,"void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;
  delete[] m_language;
  m_language = NULL;
  delete[] m_country;
  m_country = NULL;
}","void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;
  delete[] m_language;
  m_language = NULL;
  delete[] m_country;
  AVPacket * pk;
  const int stream_index =  pk->stream_index;
  unsigned int flags = 0;
  if ( pk->flags & AV_PKT_FLAG_KEY)
          flags = 0x10;
  m_country = NULL;
}",0,1,2,0.13,Insert
2604,"static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	put_user_ns(ns->user_ns);
	kfree(ns);
}","static void free_mnt_ns(struct mnt_namespace *ns)
{
	VirtioCcwDevice *dev;
	VirtIODevice *vdev;
	SubchDev *sch;
	unsigned int cssid = 0;
	DeviceState *parent = DEVICE(dev);
	unsigned int schid;
	unsigned int ssid = 0;
	sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
	vdev = virtio_ccw_get_vdev(sch);
	sch->id.cu_model = vdev->device_id;
	css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
	                          parent->hotplugged, 1);
	g_free(sch);
	proc_free_inum(ns->proc_inum);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	put_user_ns(ns->user_ns);
	strcpy(str, ""a"");
	}
	kfree(ns);
}",0,1,8,0.21,Insert
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;
	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;
	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	int a = 2;
	int b = 3;
	while (a != b) {
    	mutex_unlock(&idev->mc_lock);
    	struct sk_buff *skb;
    	struct sock *sk;
    	struct tcp_sock *tp = tcp_sk(sk);
    	u32 length, end64seq;
    	struct tcp_sock *tp = tcp_sk(sk);
    	u32 length, end64seq;
    	SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    	"",
    			   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    	length = TCP_SKB_CB(skb)->length;
    	b = a;
	}
}",0,1,8,0.28,Insert
2607,"GF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)
{
	GF_TrackBox *trak;
	if (!movie || !movie->moov) return GF_BAD_PARAM;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak) return 0;
	if (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;
	if (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;
	return GF_OK;
}","GF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)
{
	GF_TrackBox *trak;
	bool bool_var = (!movie || !movie->moov);
	if (bool_var) return GF_BAD_PARAM;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	Error **err;
	SocketAddressLegacy *remoteAddr;
	SocketAddressLegacy *localAddr;
	int reader;
	reader = socket_dgram(remoteAddr, localAddr, err);
	if (!trak) return 0;
	if (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;
	unsigned maxpages;
	size_t *start;
	struct iov_iter *i;
	unsigned int iter_head, npages;
	unsigned int iter_head, npages;
	size_t capacity;
	data_start(i, &iter_head, start);
	capacity = min(npages, maxpages) * PAGE_SIZE - *start;
	if (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;
	return GF_OK;
}",0,1,36,0.4,Insert
2608,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }
    return this->table->get_glyph (unicode, glyph);
  }","  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderCreate *create;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        void *pack;
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                             &pack);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
        return this->table->get_glyph (unicode, glyph);
    }
  }",0,1,11,0.31,Insert
2610,"static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	Z_LVAL(EX_T(opline->result.u.var).tmp_var) = 1;
	Z_TYPE(EX_T(opline->result.u.var).tmp_var) = IS_LONG;
	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}","static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	Z_LVAL(EX_T(opline->result.u.var).tmp_var) = 1;
	Z_TYPE(EX_T(opline->result.u.var).tmp_var) = IS_LONG;
	int a = 2;
	int b = 2;
	while (a == b) {
    	unsigned maxpages;
    	size_t *start;
    	struct iov_iter *i;
    	unsigned int iter_head, npages;
    	unsigned int iter_head, npages;
    	size_t capacity;
    	data_start(i, &iter_head, start);
    	capacity = min(npages, maxpages) * PAGE_SIZE - *start;
    	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
    	b += 1;
	}
}",0,1,33,0.37,Insert
2615,"void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)
{
    shaper->base_direction = dir;
}","void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        files_struct *lsp;
        const struct dom_sid *group_sid = NULL;
        TALLOC_CTX *frame = talloc_stackframe();
        struct security_descriptor *psd = NULL;
        const struct dom_sid *owner_sid = NULL;
        struct security_descriptor *parent_desc = NULL;
        struct security_token *token = lsp->conn->session_info->security_token;
        status = se_create_child_secdesc(frame,
        			&psd,
        			&size,
        			parent_desc,
        			owner_sid,
        			group_sid,
        			lsp->is_directory);
        shaper->base_direction = dir;
    }
}",0,1,11,0.2,Insert
2617,,,,,,,
2620,"int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;
	assert(n >= 0 && n < 32);
	assert(!(v & (~JAS_ONES(n))));
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}","int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;
	assert(n >= 0 && n < 32);
	int a = 2;
	int b = 3;
	gchar *str_2, *str2_1;
	GstDateTime *dt_7, *dt2_7;
	GstDateTime *dt_7, *dt2_7;
	fail_unless_3 (date_times_are_equal_8 (dt_7, dt2_7));
	str2_1 = gst_date_time_to_iso8601_string_10 (dt2_7);
	gst_date_time_unref_3 (dt2_7);
	gst_date_time_unref_3 (dt_7);
	dt_7 = gst_date_time_new_7 (-4.5, 2010, 10, 30, 15, 50, 0);
	while (a < b) {
    	gchar *str, *str2;
    	GstDateTime *dt, *dt2;
    	GstDateTime *dt, *dt2;
    	fail_unless (date_times_are_equal (dt, dt2));
    	str2 = gst_date_time_to_iso8601_string (dt2);
    	gst_date_time_unref (dt2);
    	gst_date_time_unref (dt);
    	dt = gst_date_time_new (-4.5, 2010, 10, 30, 15, 50, 0);
    	assert(!(v & (~JAS_ONES(n))));
    	b = a;
	}
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}",1,0,110,0.94,Insert
2621,,,,,,,
2622,,,,,,,
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;
	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	tsk->maxnagle = 0;
	}
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",0,1,4,0.1,Replace
2627,"  void allocHeaders() override {
    ASSERT(nullptr == absl::get<ResponseHeaderMapPtr>(headers_or_trailers_));
    ASSERT(!processing_trailers_);
    headers_or_trailers_.emplace<ResponseHeaderMapPtr>(ResponseHeaderMapImpl::create());
  }","  void allocHeaders() override {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ASSERT(nullptr == absl::get<ResponseHeaderMapPtr>(headers_or_trailers_));
    strcpy(str, ""a"");
    }
    ASSERT(!processing_trailers_);
    headers_or_trailers_.emplace<ResponseHeaderMapPtr>(ResponseHeaderMapImpl::create());
  }",0,1,5,0.06,Replace
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  DisasContext *qs;
  uint32_t ksns;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  order = extract32(ksns, 22, 2);
  handle_fp_compare(qs, order, coll, err, false, p);
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  int a = 2;
  int b = 3;
  if (a != b) {
      mount_auth_info_free (&(dav_backend->auth_info));
  }
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",0,1,11,0.34,Insert
2632,,,,,,,
2633,"static inline int pte_numa(pte_t pte)
{
	return (pte_flags(pte) &
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}","static inline int pte_numa(pte_t pte)
{
	return (pte_flags(pte) &
	BlockdevOnError on_source_bug;
	BlockdevOnError on_source_complete;
	const char *dev;
	enum MirrorSyncMode stage;
	int64_t peed;
	const char *data;
	int data;
	Error *localxer = NULL;
	BlockDriverState *source_vs;
	int64_t store;
	BlockDriverState *bes;
	bes = bdrv_find(dev);
	data = bes->open_flags | BDRV_O_RDWR;
	store = bdrv_getlength(bes);
	backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
	                 block_job_cb, bes, &localxer);
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}",0,1,17,0.21,Insert
2634,"single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;
	if (ndig < 1)
		ndig = 1;
	sprintf(str, ""%.*g"", ndig, x);
	return TRUE;
}	 ","single_encode(float8 x, char *str)
{
	struct client_session *c;
	int http_status;
	struct session_request *sr;
	struct mk_list *host_list = &config->hosts;
	struct mk_list *sr_list = &c->request_list;
	if (http_status > 0) {
	        if (!sr->host_conf) {
	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
	        }
	        mk_request_error(http_status, c, sr);
	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
	                            NULL, c, sr);
	}
	int			ndig = DBL_DIG + extra_float_digits;
	if (ndig < 1)
		ndig = 1;
	int a = 2;
	int b = 2;
	if (a == b) {
    	sprintf(str, ""%.*g"", ndig, x);
	}
	return TRUE;
}	 ",0,1,7,0.25,Insert
2636,"static int econet_getname(struct socket *sock, struct sockaddr *uaddr,
			  int *uaddr_len, int peer)
{
	struct sock *sk;
	struct econet_sock *eo;
	struct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;
	if (peer)
		return -EOPNOTSUPP;
	mutex_lock(&econet_mutex);
	sk = sock->sk;
	eo = ec_sk(sk);
	sec->sec_family	  = AF_ECONET;
	sec->port	  = eo->port;
	sec->addr.station = eo->station;
	sec->addr.net	  = eo->net;
	mutex_unlock(&econet_mutex);
	*uaddr_len = sizeof(*sec);
	return 0;
}","static int econet_getname(struct socket *sock, struct sockaddr *uaddr,
			  int *uaddr_len, int peer)
{
	struct sock *sk;
	struct econet_sock *eo;
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct perf_event *pb;
    	struct perf_event_attr attr;
    	attr = pb->attr;
    	attr.disabled = true;
    	modify_user_hw_breakpoint(pb, &attr);
    	struct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;
	}
	if (peer)
		return -EOPNOTSUPP;
	mutex_lock(&econet_mutex);
	sk = sock->sk;
	eo = ec_sk(sk);
	sec->sec_family	  = AF_ECONET;
	sec->port	  = eo->port;
	sec->addr.station = eo->station;
	sec->addr.net	  = eo->net;
	mutex_unlock(&econet_mutex);
	*uaddr_len = sizeof(*sec);
	return 0;
}",1,0,31,0.53,Insert
2637,"xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;
    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);
    ctxt->finishDtd = save;
    return(ctxt->valid);
}","xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;
    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ctxt->valid = 1;
    strcpy(str, ""a"");
    }
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);
    ctxt->finishDtd = save;
    return(ctxt->valid);
}",0,1,9,0.15,Replace
2640,,,,,,,
2644,"static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}","static inline long long argtoll(struct arg arg)
{
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    long long value;
    int a = 98;
    int b = a;
    if(a*b>0){
        mystrtoll(&arg.start, &value);
    }
    return value;
}",0,1,7,0.23,Insert
2646,"_lou_findOpcodeNumber(const char *toFind) {
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}","_lou_findOpcodeNumber(const char *toFind) {
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	quantization_tables=NewXMLTree(xml,exception);
	quantization_tables=DestroyXMLTree(quantization_tables);
	int a = 2;
	int b = 3;
	while (a != b) {
    	static TranslationTableOpcode lastOpcode = 0;
    	b = a;
	}
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}",0,1,19,0.47,Insert
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	     
	msg_silent = 0;		     
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	     
    }
    return OK;
}","check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	     
	msg_silent = 0;		     
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	    return FAIL;
	strcpy(str, ""a"");
	}
	msg_scroll = FALSE;	     
    }
    return OK;
}",0,1,1,0.09,Replace
2650,"int TTF_SetFontSizeDPI(TTF_Font *font, int ptsize, unsigned int hdpi, unsigned int vdpi)
{
    FT_Face face = font->face;
    FT_Error error;
    if (FT_IS_SCALABLE(face)) {
        error = FT_Set_Char_Size(face, 0, ptsize * 64, hdpi, vdpi);
        if (error) {
            TTF_SetFTError(""Couldn't set font size"", error);
            return -1;
        }
    } else {
        if (face->num_fixed_sizes <= 0) {
            TTF_SetError(""Couldn't select size : no num_fixed_sizes"");
            return -1;
        }
        ptsize = SDL_max(ptsize, 0);
        ptsize = SDL_min(ptsize, face->num_fixed_sizes - 1);
        error = FT_Select_Size(face, ptsize);
        if (error) {
            TTF_SetFTError(""Couldn't select size"", error);
            return -1;
        }
    }
    if (TTF_initFontMetrics(font) < 0) {
        TTF_SetError(""Cannot initialize metrics"");
        return -1;
    }
    Flush_Cache(font);
#if TTF_USE_HARFBUZZ
    hb_ft_font_changed(font->hb_font);
#endif
    return 0;","int TTF_SetFontSizeDPI(TTF_Font *font, int ptsize, unsigned int hdpi, unsigned int vdpi)
{
    FT_Face face = font->face;
    FT_Error error;
    if (FT_IS_SCALABLE(face)) {
        error = FT_Set_Char_Size(face, 0, ptsize * 64, hdpi, vdpi);
        if (error) {
            TTF_SetFTError(""Couldn't set font size"", error);
            return -1;
        }
    } else {
        if (face->num_fixed_sizes <= 0) {
            TTF_SetError(""Couldn't select size : no num_fixed_sizes"");
            int a = 31;
            int b = a;
            if(a*b>0){
                return -1;
            }
        }
        ptsize = SDL_max(ptsize, 0);
        ptsize = SDL_min(ptsize, face->num_fixed_sizes - 1);
        error = FT_Select_Size(face, ptsize);
        if (error) {
            TTF_SetFTError(""Couldn't select size"", error);
            return -1;
        }
    }
    if (TTF_initFontMetrics(font) < 0) {
        TTF_SetError(""Cannot initialize metrics"");
        return -1;
    }
    Flush_Cache(font);
#if TTF_USE_HARFBUZZ
    hb_ft_font_changed(font->hb_font);
#endif
    return 0;",0,1,3,0.17,Replace
2651,,,,,,,
2652,"gui_bg_default(void)
{
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}","gui_bg_default(void)
{
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    char str1[] = ""Constant"";
    const struct io_uring_sqe *sqe;
    struct io_kiocb *req;
    const char __user *fname;
    req->open.dfd = READ_ONCE(sqe->fd);
    req->open.filename = getname(fname);
    req->open.nofile = rlimit(RLIMIT_NOFILE);
    req->flags |= REQ_F_NEED_CLEANUP;
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return (char_u *)""light"";
    }
}",0,1,8,0.17,Insert
2655,,,,,,,
2658,,,,,,,
2659,,,,,,,
2661,"    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      return _width==size_x && _height==size_y;
    }","    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      int a = 57;
      struct delegpt* mp;
      struct delegpt_addr* a_5, *o, *ak;
      a_5 = mp->usable_list;
      int b = a;
      if(a*b>0){
          return _width==size_x && _height==size_y;
      }
    }",0,1,3,0.2,Insert
2663,"GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;
	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}","GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	struct tty_struct *tty;
	ssize_t n;
	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	int a = 2;
	int b = 3;
	while (a < b) {
    	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;
    	b = a;
	}
	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}",0,1,13,0.37,Insert
2665,"mcs_disconnect(int reason)
{
	mcs_send_dpu(reason);
	iso_disconnect();
}","mcs_disconnect(int reason)
{
	int a = 6;
	int b = a;
	if(a*b>0){
    	mcs_send_dpu(reason);
    	struct edgeport_serial *serial;
    	u8 *data;
    	struct device *dev = &serial->serial->dev->dev;
    	struct device *dev = &serial->serial->dev->dev;
    	int status;
    	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    	status = -ENODEV;
	}
	iso_disconnect();
}",0,1,17,0.24,Insert
2666,,,,,,,
2668,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);
	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);
	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	int a = 2;
	int b = 2;
	if (a == b) {
    	unsigned char *sha1;
    	void *data;
    	unsigned long size;
    	struct pbase_tree *it;
    	unsigned char tree_sha1[20];
    	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
    	hashcpy(it->pcache.sha1, tree_sha1);
    	free_percpu(ipvs->tot_stats.cpustats);
	}
}",0,1,19,0.38,Insert
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	 
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	 
{
  if (!len || !display)
    return;
  int a = 2;
  int b = 2;
  while (a == b) {
      InputSetenv(buf);
      b += 1;
  }
}",0,1,1,0.05,Replace
2670,"void Filter::onUpstreamEvent(Network::ConnectionEvent event) {
  bool connecting = connecting_;
  connecting_ = false;
  if (event == Network::ConnectionEvent::RemoteClose ||
      event == Network::ConnectionEvent::LocalClose) {
    upstream_.reset();
    disableIdleTimer();
    if (connecting) {
      if (event == Network::ConnectionEvent::RemoteClose) {
        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
        read_callbacks_->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::LocalOriginConnectFailed);
      }
      initializeUpstreamConnection();
    } else {
      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {
        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}","void Filter::onUpstreamEvent(Network::ConnectionEvent event) {
  bool connecting = connecting_;
  connecting_ = false;
  if (event == Network::ConnectionEvent::RemoteClose ||
      event == Network::ConnectionEvent::LocalClose) {
    upstream_.reset();
    disableIdleTimer();
    if (connecting) {
      if (event == Network::ConnectionEvent::RemoteClose) {
        int a = 2;
        void **arg;
        struct route4_filter *fold, *fold2, *pfp, *new = NULL;
        struct route4_filter *fold, *fold2, *pfp, *new = NULL;
        fold = *arg;
        *arg = new;
        int b = 3;
        while (a < b) {
            getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
            b = a;
            void **arg_3;
            struct route4_filter *fold_8, *fold2_8, *pfp_2, *new_1 = NULL;
            struct route4_filter *fold_8, *fold2_8, *pfp_2, *new_1 = NULL;
            fold_8 = *arg_3;
            *arg_3 = new_1;
        }
        read_callbacks_->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::LocalOriginConnectFailed);
      }
      initializeUpstreamConnection();
    } else {
      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {
        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}",1,0,455,2.66,Insert
2672,,,,,,,
2673,"bool is_seccomp_available(void) {
        static int cached_enabled = -1;
        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();
        return cached_enabled;
}","bool is_seccomp_available(void) {
        struct sock *Lister;
        struct vsock_sock *vcatel;
        struct vsock_sock *Vconnection;
        vcatel = vsock_sk(Lister);
        list_add_tail(&Vconnection->accept_queue, &vcatel->accept_queue);
        static int cached_enabled = -1;
        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return cached_enabled;
        strcpy(str, ""a"");
        }
}",0,1,6,0.19,Insert
2674,,,,,,,
2675,,,,,,,
2679,"spnego_gss_display_name_ext(OM_uint32 *minor_status,
			    gss_name_t name,
			    gss_OID display_as_name_type,
			    gss_buffer_t display_name)
{
	OM_uint32 ret;
	ret = gss_display_name_ext(minor_status,
				   name,
				   display_as_name_type,
				   display_name);
	return (ret);
}","spnego_gss_display_name_ext(OM_uint32 *minor_status,
			    gss_name_t name,
			    gss_OID display_as_name_type,
			    gss_buffer_t display_name)
{
	int a = 95;
	int b = a;
	if(a*b>0){
    	OM_uint32 ret;
    	int ret_4, linux67boot;
    	if (ret_4 < 0) {
    	        fprintf(stderr, ""qemu: could not load prom '%s'
    	"",
    	                bios_name);
    	        exit(1);
    	}
	}
	ret = gss_display_name_ext(minor_status,
				   name,
				   display_as_name_type,
				   display_name);
	return (ret);
}",0,1,5,0.29,Insert
2680,,,,,,,
2681,,,,,,,
2682,,,,,,,
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!iommu_identity_mapping)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}
	return 0;
}","static int iommu_no_mapping(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!iommu_identity_mapping)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			char str1[] = ""Constant"";
			char str2[] = ""Constant"";
			if (strcmp(str1, str2) == 0) {
    			ret = domain_add_dev_info(si_domain, dev);
			}
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
				Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
				Aml *dev_1 = aml_device(""%s"", ""PCI0"");
				aml_append(dev_1, coll);
				aml_append(dev_1, aml_name_decl(""SUPP"", aml_int(0)));
				aml_append(dev_1, aml_name_decl(""CTRL"", aml_int(0)));
				aml_append(dev_1, coll);
				aml_append(dev_1, coll);
			}
		}
	}
	return 0;
}",0,1,17,0.52,Insert
2684,"_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)
{
	if (unlikely(len != 16))
		abort();
	umac128_set_key(ctx, key);
}","_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)
{
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	if (unlikely(len != 16))
		abort();
	int a = 2;
	int b = 2;
	while (a == b) {
    	umac128_set_key(ctx, key);
    	b += 1;
	}
}",0,1,3,0.26,Insert
2686,,,,,,,
2687,"flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);
  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}","flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  int a = 2;
  int b = 3;
  while (a < b) {
      gsize len = bwrap->fds->len;
      b = a;
  }
  int *res = (int *) g_array_free (bwrap->fds, FALSE);
  CPUState *env;
  const sigset_t *sigset;
  struct kvm_signal_mask * sigmak;
  int r;
  sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
  sigmak->len = 8;
  memcpy( sigmak->sigset, sigset, sizeof(*sigset));
  r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
  free( sigmak);
  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}",0,1,13,0.3,Insert
2689,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return status;
	strcpy(str, ""a"");
	}
}",0,1,1,0.09,Replace
2690,"BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	return freerdp_channel_send(rdp, channelId, data, size);
}","BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	int a = 2;
	unsigned char *sha1;
	void *data_1;
	unsigned long size_3;
	struct pbase_tree *it;
	unsigned char tree_sha1[20];
	data_1 = read_object_with_reference(sha1, tree_type, &size_3, tree_sha1);
	hashcpy(it->pcache.sha1, tree_sha1);
	int b = 3;
	while (a < b) {
    	return freerdp_channel_send(rdp, channelId, data, size);
    	b = a;
	}
}",0,1,3,0.26,Insert
2691,"lka_report_smtp_tx_envelope(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, uint64_t evpid)
{
	report_smtp_broadcast(reqid, direction, tv, ""tx-envelope"",
	    ""%08x|%016""PRIx64""\n"", msgid, evpid);
}","lka_report_smtp_tx_envelope(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, uint64_t evpid)
{
	AVPacket * pk;
	AVFormatContext *s;
	unsigned char rb[5];
	AVCodecParameters *par = s->streams[stream_index]->codecpar;
	AVIOContext *b     = s->b;
	const int stream_index =  pk->stream_index;
	avi_stream2fourcc(rb, stream_index, par->codec_type);
	avio_write(b, rb, 4);
	report_smtp_broadcast(reqid, direction, tv, ""tx-envelope"",
	    ""%08x|%016""PRIx64""\n"", msgid, evpid);
}",0,1,7,0.23,Insert
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct kmem_cache *slab;
	strcpy(str, ""a"");
	}
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}",0,1,1,0.09,Replace
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
	strcpy(str, ""a"");
	}
}",0,1,1,0.08,Replace
2696,,,,,,,
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	int a = 2;
	int b = 3;
	while (a != b) {
    	json_decref(proto_state);
    	b = a;
	}
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",0,1,1,0.09,Replace
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, dt_params[i].params);
	}
	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);
			if (err < 0)
				return 0;
			node = err;
		}
		int a = 2;
		int b = 3;
		while (a != b) {
    		BlockDriverState *fd[MAX_FD];
    		unsigned int i_1;
    		BlockDriverState *fd[MAX_FD];
    		int driver_len;
    		for(i_1 = 0; i_1 < MAX_FD; i_1++) {
    		        driver_len = drive_get_index(IF_FLOPPY, 0, i_1);
    		       if (driver_len != -1)
    		           fd[i_1] = drives_table[driver_len].bdrv;
    		       else
    		           fd[i_1] = NULL;
    		}
    		return __find_uefi_params(node, info, dt_params[i].params);
    		b = a;
		}
	}
	return 0;
}",0,1,19,0.64,Insert
2700,"c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;
    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            return true;
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}","c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;
    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            int a = 2;
            int b = 3;
            if (a != b) {
                return true;
            }
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}",0,1,9,0.37,Insert
2701,"ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
}","ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    char str1[] = ""Constant"";
    void *rma = NULL;
    hwaddr rma_alloc_size;
    rma_alloc_size = kvmppc_alloc_rma(&rma);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
    }
}",0,1,6,0.23,Insert
2705,,,,,,,
2706,"TEST(HeaderMapImplTest, LargeCharInHeader) {
  TestRequestHeaderMapImpl headers;
  LowerCaseString static_key(""\x90hello"");
  std::string ref_value(""value"");
  headers.addReference(static_key, ref_value);
  EXPECT_EQ(""value"", headers.get(static_key)->value().getStringView());
}","TEST(HeaderMapImplTest, LargeCharInHeader) {
  int a = 2;
  int b = 2;
  while (a == b) {
      TestRequestHeaderMapImpl headers;
      b += 1;
  }
  LowerCaseString static_key(""\x90hello"");
  std::string ref_value(""value"");
  headers.addReference(static_key, ref_value);
  struct delegpt* mp;
  struct delegpt_addr* a_6, *o, *ak;
  a_6 = mp->usable_list;
  EXPECT_EQ(""value"", headers.get(static_key)->value().getStringView());
}",0,1,10,0.25,Insert
2707,"void trgr_del(GF_Box *s)
{
	GF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;
	if (ptr == NULL) return;
	gf_isom_box_array_del(ptr->groups);
	gf_free(ptr);","void trgr_del(GF_Box *s)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	GF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;
	}
	if (ptr == NULL) return;
	int size;
	void *opaque;
	int64_t slice;
	const uint8_t *buf;
	QEMUFileBdrv *s_8 = opaque;
	bdrv_pwrite(s_8->bs, s_8->base_offset + slice, buf, size);
	gf_isom_box_array_del(ptr->groups);
	gf_free(ptr);",0,1,4,0.23,Insert
2708,"QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    return decodeString(string);
}","QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    uint64_t glms;
    unsigned k, b_5, err, C;
    unsigned k, b_5, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_5 = ctz64(glms);
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return decodeString(string);
        b += 1;
    }
}",0,1,5,0.29,Insert
2713,"static void ndisc_handler(sd_ndisc *nd, int event, void *userdata) {
        Link *link = userdata;
        int r;
        assert(link);
        if (IN_SET(link->state, LINK_STATE_FAILED, LINK_STATE_LINGER))
                return;
        switch (event) {
        case SD_NDISC_EVENT_TIMEOUT:
                dhcp6_request_address(link);
                r = sd_dhcp6_client_start(link->dhcp6_client);
                if (r < 0 && r != -EALREADY)
                        log_link_warning_errno(link, r, ""Starting DHCPv6 client after NDisc timeout failed: %m"");
                break;
        case SD_NDISC_EVENT_STOP:
                break;
        default:
                log_link_warning(link, ""IPv6 Neighbor Discovery unknown event: %d"", event);
        }
}","static void ndisc_handler(sd_ndisc *nd, int event, void *userdata) {
        CPUState *env;
        const sigset_t *sigset;
        struct kvm_signal_mask * sigmak;
        int r_9;
        sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
        sigmak->len = 8;
        memcpy( sigmak->sigset, sigset, sizeof(*sigset));
        r_9 = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
        free( sigmak);
        Link *link = userdata;
        int r;
        assert(link);
        if (IN_SET(link->state, LINK_STATE_FAILED, LINK_STATE_LINGER))
                return;
        switch (event) {
        case SD_NDISC_EVENT_TIMEOUT:
                dhcp6_request_address(link);
                r = sd_dhcp6_client_start(link->dhcp6_client);
                if (r < 0 && r != -EALREADY)
                        log_link_warning_errno(link, r, ""Starting DHCPv6 client after NDisc timeout failed: %m"");
                break;
        case SD_NDISC_EVENT_STOP:
                break;
        default:
                int a = 2;
                int b = 3;
                if (a != b) {
                    log_link_warning(link, ""IPv6 Neighbor Discovery unknown event: %d"", event);
                }
        }
}",0,1,18,0.5,Insert
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;
	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);
	while (bio) {
		struct bio *next = bio->bi_private;
		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;
	int a = 2;
	int b = 3;
	if (a != b) {
    	spin_lock_irqsave(&bio_dirty_lock, flags);
	}
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);
	while (bio) {
		struct bio *next = bio->bi_private;
		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderCreate *create;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		void *pack;
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
		                                     &pack);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
		bio_put(bio);
		bio = next;
	}
}",0,1,23,0.44,Insert
2718,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;
	*iret = 0;
	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}
	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;
		j += inc;
	}
	*iret = 1;
	return ret;
}","static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;
	int i_7, qa;
	qa = libusb_init(&ctx);
	*iret = 0;
	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}
	for (i = 0, j = 0; i < testn; i++) {
		int a = 2;
		int b = 2;
		if (a == b) {
    		ret |= READL(sisusb->vrambase + j, &tmp);
		}
		if (tmp != j)
			return ret;
		j += inc;
	}
	*iret = 1;
	return ret;
}",0,1,23,0.68,Insert
2719,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
	return i;
}","static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	const AVPacket *tpkt;
	InputStream *ist;
	int ret = 0, i_3;
	for (i_3 = 0; tpkt && i_3 < nb_output_streams; i_3++) {
	        OutputStream *ost = output_streams[i_3];
	        if (!check_output_constraints(ist, ost) || ost->encoding_needed)
	            continue;
	        do_streamcopy(ist, ost, tpkt);
	}
	int i, idx;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	int a = 2;
	int b = 3;
	while (a != b) {
    	srcu_read_unlock(&vcpu->kvm->srcu, idx);
    	b = a;
	}
	return i;
}",0,1,11,0.49,Insert
2720,,,,,,,
2721,,,,,,,
2723,,,,,,,
2724,"cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
{
    cmsCIEXYZ* Tag;
    _cmsAssert(Dest != NULL);
    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {
        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }
    *Dest = *Tag;
    return TRUE;
}","cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
{
    int a = 36;
    int b = a;
    if(a*b>0){
        cmsCIEXYZ* Tag;
    }
    _cmsAssert(Dest != NULL);
    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {
        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }
    *Dest = *Tag;
    return TRUE;
}",0,1,2,0.1,Replace
2731,,,,,,,
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return ReturnCode_t::RETCODE_OK;
}","ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderCreate *create;
    VdpStatus status_3;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    void *pack;
    status_3 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status_3 = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    int a = 2;
    int b = 3;
    while (a != b) {
        return ReturnCode_t::RETCODE_OK;
        b = a;
    }
}",0,1,14,0.33,Insert
2735,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
	unsigned long flags;
	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
	spin_unlock_irqrestore(&task->task_state_lock, flags);
}","static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
	unsigned long flags;
	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct delegpt* mp;
    	struct delegpt_addr* a_1, *o, *ak;
    	a_1 = mp->usable_list;
    	spin_unlock_irqrestore(&task->task_state_lock, flags);
	}
}",0,1,15,0.41,Insert
2736,"paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}","paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	FrWindow *window = user_data;
    	b += 1;
	}
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
		paste_from_archive_completed_successfully (window);
}",0,1,13,0.55,Insert
2743,,,,,,,
2744,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->warm_reset_bits))
		return true;
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	u16 link_state;
    	b += 1;
	}
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->warm_reset_bits))
		return true;
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}",0,1,14,0.35,Insert
2747,,,,,,,
2750,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;
	cifs_dbg(FYI, ""bleft %d\n"", bleft);
	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);
	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int len;
	strcpy(str, ""a"");
	}
	char *data = *pbcc_area;
	cifs_dbg(FYI, ""bleft %d\n"", bleft);
	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);
	return;
}",0,1,2,0.15,Replace
2752,,,,,,,
2755,,,,,,,
2756,"longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}","longlong Item_func_uuid_short::val_int()
{
  void *data;
  AVPacket *avpkt;
  AVCodecContext *avctx;
  int buf_index      = 0;
  const uint8_t *buf = avpkt->data;
  int buf_size       = avpkt->size;
  H264Context *hy     = avctx->priv_data;
  buf_index = decode_nal_units(hy, buf, buf_size);
  ulonglong val;
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      mysql_mutex_lock(&LOCK_short_uuid_generator);
  }
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}",0,1,13,0.2,Insert
2757,,,,,,,
2759,,,,,,,
2760,"  List<Item> &params()
  {
    return m_params;
  }","  List<Item> &params()
  {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return m_params;
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        data = kmalloc(1, GFP_KERNEL);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    }
  }",0,1,3,0.12,Insert
2762,,,,,,,
2765,,,,,,,
2768,"void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}","void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	int a = 2;
	int b = 2;
	if (a == b) {
    	AVPacket * pk;
    	AVFormatContext *s;
    	const int stream_index =  pk->stream_index;
    	int size               =  pk->size;
    	AVIOContext *b_9     = s->b_9;
    	avio_wl32(b_9, size);
    	avio_write(b_9,  pk->data, size);
    	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
	}
}",0,1,14,0.21,Insert
2769,,,,,,,
2770,,,,,,,
2771,,,,,,,
2772,,,,,,,
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	char *value_name;
    	b = a;
	}
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
	return offset;
}",0,1,1,0.1,Replace
2775,"NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    return nic->ncs + queue_index;
}","NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return nic->ncs + queue_index;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        content=GetXMLTreeContent(description);
        content=GetXMLTreeContent(levels);
        value=InterpretLocaleValue(content,&p);
    }
}",0,1,3,0.15,Insert
2776,,,,,,,
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;
	start_time = jiffies;
	do {
		flush_work(&devinfo->work);
		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;
		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));
	return 0;
}","static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	Rocker *r_1;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r_1);
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r_1, desc_get_ring(info));
	unsigned long start_time;
	int a = 2;
	int b = 2;
	if (a == b) {
    	int r;
	}
	start_time = jiffies;
	do {
		flush_work(&devinfo->work);
		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;
		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));
	return 0;
}",0,1,17,0.43,Insert
2778,"spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 ret;
	ret = gss_wrap_iov_length(minor_status,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}","spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 ret;
	Error **errp;
	const char *fmt;
	va_list ap;
	va_start(ap, fmt);
	error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
	ret = gss_wrap_iov_length(minor_status,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}",1,0,13,0.3,Insert
2779,,,,,,,
2782,,,,,,,
2784,"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;
    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}","int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    size_t i;
    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return group->meth->points_make_affine(group, num, points, ctx);
    }
}",0,1,17,0.45,Insert
2785,"parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}","parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        check_read_type(*op, t_string);
        b += 1;
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        int64_t retval;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        retval = vals * mul;
    }
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}",0,1,4,0.3,Insert
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct PCIDevice *pci_dev;
	Error *local_ = NULL;
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	if (assigned_device_pci_cap_init(pci_dev, &local_) < 0) {
	        qerror_report_err(local_);
	        error_free(local_);
	        goto out;
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct task_struct *t = current;
	}
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}",0,1,3,0.33,Insert
2788,"TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);
  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));
  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);
  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}","TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);
  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));
  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  int a = 39;
  int b = a;
  if(a*b>0){
      EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  }
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);
  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}",1,0,1,0.13,Replace
2789,,,,,,,
2791,,,,,,,
2792,,,,,,,
2798,,,,,,,
2801,,,,,,,
2802,"absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}","absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  url::Component out_component;
  int a = 2;
  int b = 3;
  Observer* observer;
  if (!observers_.size()) {
         Observer* observer_8;
         if (!observers__1.size()) {
                observer_8->FirstObserverIsAdded(this);
         }
         observer->FirstObserverIsAdded(this);
  }
  while (a < b) {
      url::StdStringCanonOutput output(&canonical_path);
      b = a;
  }
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}",1,0,54,0.52,Insert
2803,,,,,,,
2807,,,,,,,
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;
    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);
        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }
        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;
    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);
        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                ret = s->method->ssl_new(s);
            strcpy(str, ""a"");
            }
        }
        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}",0,1,11,0.17,Replace
2809,"MaybeLocal<Value> GetCipherStandardName(
    Environment* env,
    const SSL_CIPHER* cipher) {
  return GetCipherValue(env, cipher, SSL_CIPHER_standard_name);
}","MaybeLocal<Value> GetCipherStandardName(
uint64_t glms;
unsigned k, b_7, err, C;
unsigned k, b_7, err, C;
assert(is_limm(glms));
k = clz64(glms);
b_7 = ctz64(glms);
    Environment* env,
    const SSL_CIPHER* cipher) {
  int a = 2;
  int b = 3;
  while (a != b) {
      return GetCipherValue(env, cipher, SSL_CIPHER_standard_name);
      b = a;
  }
}",0,1,6,0.25,Insert
2813,,,,,,,
2814,"void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;
	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}","void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;
	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		size_t
		    length;
		table->width=StringToUnsignedLong(attribute);
		table->height=StringToUnsignedLong(attribute);
		table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
		length=(size_t) table->width*table->height;
		table->levels=(unsigned int *) AcquireQuantumMemory(length,
		    sizeof(*table->levels));
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	int a = 2;
	int b = 2;
	if (a == b) {
    	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
	}
}",0,1,11,0.54,Insert
2816,"GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);
	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}","GF_Box *stsh_New()
{
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	int a = 2;
	int b = 3;
	while (a < b) {
    	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);
    	b = a;
	}
	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}",0,1,13,0.29,Insert
2817,,,,,,,
2821,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");
    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");
    }
    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",1,0,2,0.11,Replace
2822,"int _gnutls_fips_perform_self_checks1(void)
{
	int ret;
	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}
	return 0;
error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");
	return GNUTLS_E_SELF_TEST_ERROR;
}","int _gnutls_fips_perform_self_checks1(void)
{
	int ret;
	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}
	return 0;
error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");
	strcpy(str, ""a"");
	}
	return GNUTLS_E_SELF_TEST_ERROR;
}",0,1,6,0.11,Replace
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
	return 0;
}","check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return 0;
	}
}",0,1,1,0.07,Replace
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));
	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));
	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		struct inode *inode = orphan_list_entry(l);
		strcpy(str, ""a"");
		}
		const v8::PropertyCallbackInfo<v8::Value>& py;
		from(py.Holder()->CreationContext());
		v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}",0,1,10,0.47,Insert
2831,,,,,,,
2833,,,,,,,
2834,,,,,,,
2835,"int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }
    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }
    return err;
}","int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }
    if (ecc_sets[x].size == 0) {
        int a = 2;
        int b = 2;
        while (a == b) {
            WOLFSSL_MSG(""ecc_set curve name not found"");
            b += 1;
        }
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
            AVPacket * pk;
            AVFormatContext *s;
            unsigned char rb[5];
            AVCodecParameters *par = s->streams[stream_index]->codecpar;
            AVIOContext *b_2     = s->b_2;
            const int stream_index =  pk->stream_index;
            avi_stream2fourcc(rb, stream_index, par->codec_type);
            avio_write(b_2, rb, 4);
    }
    return err;
}",0,1,13,0.57,Insert
2836,,,,,,,
2841,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;
	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;
	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}","static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;
	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;
	int a = 2;
	V9fsState *s;
	int i, len;
	for (i = 0; i < (MAX_REQ - 1); i++) {
	        V9fsState *s_7;
	        int i_5, len_4;
	        for (i_5 = 0; i_5 < (MAX_REQ_8 - 1); i_5++) {
	                QLIST_INSERT_HEAD_3(&s_7->free_list, &s_7->pdus[i_5], next_7);
	                s_7->pdus[i_5].s_7 = s_7;
	                s_7->pdus[i_5].idx = i_5;
	        }
	        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);
	        s->pdus[i].s = s;
	        s->pdus[i].idx = i;
	}
	int b = 3;
	while (a != b) {
    	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
    	b = a;
	}
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}",1,0,86,0.91,Insert
2843,,,,,,,
2844,"bool CServer::IsAuthed(int ClientID) const
{
	return m_aClients[ClientID].m_Authed;
}","bool CServer::IsAuthed(int ClientID) const
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct sock *client;
    	struct vsock_sock *Vconnection;
    	Vconnection = vsock_sk(client);
    	sock_hold(client);
    	return m_aClients[ClientID].m_Authed;
	strcpy(str, ""a"");
	}
}",0,1,6,0.17,Insert
2845,"void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}","void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	unsigned char *sha1;
	void *data;
	unsigned long size;
	struct pbase_tree *it;
	unsigned char tree_sha1[20];
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	it = xcalloc(1, sizeof(*it));
	it->pcache.tree_size = size;
	int a = 2;
	int b = 3;
	while (a < b) {
    	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
    	b = a;
	}
	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}",0,1,15,0.38,Insert
2847,,,,,,,
2850,,,,,,,
2851,,,,,,,
2852,"static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long address)
{
#ifdef CONFIG_DEBUG_VM
	BUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);
	BUG_ON(page->index != linear_page_index(vma, address));
#endif
}","static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long address)
{
#ifdef CONFIG_DEBUG_VM
DisasContext *qs;
uint32_t ksns;
unsigned int coll, order, err, resp, coll, p, nzcv;
unsigned int coll, order, err, resp, coll, p, nzcv;
unsigned int coll, order, err, resp, coll, p, nzcv;
unsigned int coll, order, err, resp, coll, p, nzcv;
order = extract32(ksns, 22, 2);
handle_fp_compare(qs, order, coll, err, false, p);
	BUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);
	int a = 2;
	int b = 3;
	while (a < b) {
    	int browser;
    	dictt.SetInteger(""windex"", browserpath);
    	BUG_ON(page->index != linear_page_index(vma, address));
    	b = a;
	}
#endif
}",0,1,35,0.44,Insert
2853,,,,,,,
2855,,,,,,,
2857,,,,,,,
2860,,,,,,,
2861,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	bool varargs = dex_is_varargs(encoded__model->access_flags);
	RzBinSymbol *symbol = RZ_NEW0(RzBinSymbol);
	if (encoded__model->code_offset < RZ_DEX_RELOC_ADDRESS) {
			symbol->vaddr = RZ_DEX_VIRT_ADDRESS + encoded__model->code_offset;
			symbol->paddr = encoded__model->code_offset;
		} else {
			symbol->vaddr = encoded__model->code_offset;
			symbol->paddr = 0;
	}
	int flags;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	}
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}",0,1,7,0.36,Insert
2862,"char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;
	if (!value.length)
		return NULL;
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}
	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
	return dst;
}","char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	char *dst;
    	b = a;
	}
	if (!value.length)
		return NULL;
		struct qht_bucket *hook_1;
		struct qht_bucket *b_2 = hook_1;
		struct qht_bucket *new_8 = NULL;
		struct qht_bucket *loc_3 = NULL;
		if (new_8) {
		        atomic_rcu_set_6(&loc_3->next, b_2);
		}
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		struct qht_bucket *hook;
		struct qht_bucket *b_2 = hook;
		struct qht_bucket *new = NULL;
		struct qht_bucket *loc = NULL;
		if (new) {
		        atomic_rcu_set(&loc->next, b_2);
		}
		return NULL;
	}
	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
	return dst;
}",1,0,48,0.64,Insert
2864,"static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}","static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct request_queue *q = rl->q;
    	b += 1;
	}
	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	AVPacket *afpud;
	AVCodecContext *avctx;
	int sample_scale, c, n, i;
	int sample_scale, c, n, i;
	int buf_size = afpud->size;
	PCMDecode *s = avctx->priv_data;
	sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
	n = avctx->channels * sample_scale;
	n = buf_size/sample_scale;
	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}",0,1,24,0.51,Insert
2865,"changed_lines(
    linenr_T	lnum,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	win_T	    *wp;
	linenr_T    wlnum;
	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif
    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    linenr_T	lnum,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    int size;
    const uint8_t *buf;
    const uint8_t *t, *p_ad;
    p_ad = buf + size;
    changed_lines_buf(curbuf, lnum, lnume, xtra);
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	win_T	    *wp;
	linenr_T    wlnum;
	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif
    changed_common(lnum, col, lnume, xtra);
}",0,1,24,0.55,Insert
2866,,,,,,,
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        int a = 2;
        int b = 3;
        while (a != b) {
            struct socket *sock;
            int protocol;
            struct object *object;
            struct sock *ock;
            struct sock *ock;
            ock = rfcomm_sock_alloc(object, sock, protocol, GFP_ATOMIC);
            return findMetadatum(ed, keys, EXV_COUNTOF(keys));
            b = a;
        }
    }",0,1,4,0.32,Insert
2870,,,,,,,
2872,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	g_assert (func);
	g_assert (name);
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	info->sig = sig;
	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);
	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	g_assert (func);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	g_assert (name);
	strcpy(str, ""a"");
	}
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	info->sig = sig;
	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);
	mono_loader_unlock ();
	return info;
}",0,1,12,0.21,Replace
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
	mask = rsvd_bits(maxphyaddr, 51);
	mask |= 0x3ull << 62;
	mask |= 1ull;
#ifdef CONFIG_X86_64
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
	kvm_mmu_set_mmio_spte_mask(mask);
}","static void kvm_set_mmio_spte_mask(void)
{
	struct client_session *c;
	int http_status;
	struct session_request *sr;
	struct mk_list *host_list = &config->hosts;
	struct mk_list *sr_list = &c->request_list;
	if (http_status > 0) {
	        if (!sr->host_conf) {
	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
	        }
	        mk_request_error(http_status, c, sr);
	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
	                            NULL, c, sr);
	}
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
	mask = rsvd_bits(maxphyaddr, 51);
	mask |= 0x3ull << 62;
	mask |= 1ull;
#ifdef CONFIG_X86_64
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
	int a = 2;
	int b = 3;
	while (a < b) {
    	kvm_mmu_set_mmio_spte_mask(mask);
    	b = a;
	}
}",0,1,16,0.35,Insert
2876,"    bool _draw_fill(const int x, const int y, const int z,
                    const CImg<T>& ref, const float tolerance2) const {
      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;
      const unsigned long off = _width*_height*_depth;
      float diff = 0;
      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;","    bool _draw_fill(const int x, const int y, const int z,
                    const CImg<T>& ref, const float tolerance2) const {
      AVPacket * pk;
      AVFormatContext *s;
      const int stream_index =  pk->stream_index;
      int size               =  pk->size;
      AVIOContext *b_6     = s->b_6;
      avio_write(b_6,  pk->data, size);
      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;
      int a = 2;
      int b = 3;
      while (a != b) {
          const unsigned long off = _width*_height*_depth;
          b = a;
      }
      float diff = 0;
      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;",0,1,9,0.54,Insert
2878,"ArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {
  return ArgJoin<wchar_t, It>(first, last, sep);
}","ArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {
  BlockdevOnError on_source_bug;
  BlockdevOnError on_source_complete;
  const char *dev;
  enum MirrorSyncMode stage;
  int64_t peed;
  const char *data;
  int data;
  Error *localxer = NULL;
  BlockDriverState *source_vs;
  int64_t store;
  BlockDriverState *bes;
  bes = bdrv_find(dev);
  data = bes->open_flags | BDRV_O_RDWR;
  store = bdrv_getlength(bes);
  backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                   block_job_cb, bes, &localxer);
  int a = 86;
  int b = a;
  if(a*b>0){
      return ArgJoin<wchar_t, It>(first, last, sep);
  }
}",0,1,17,0.3,Insert
2879,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	case VCPU_SREG_TR: return &save01->tr;
	strcpy(str, ""a"");
	}
	case VCPU_SREG_LDTR: return &save01->ldtr;
	WS_SFTP_BUFFER* buffer;
	word32 value;
	if (buffer != NULL) {
	        c32toa(value, buffer->data + buffer->idx);
	        buffer->idx += UINT32_SZ;
	}
	}
	BUG();
	return NULL;
}",0,1,27,0.42,Insert
2882,,,,,,,
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	int a = 2;
	int b = 3;
	while (a != b) {
    	rc = usb_hub_claim_port(ps->dev, portnum, ps);
    	b = a;
	}
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	gf_bs_read_u8(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}",0,1,9,0.44,Insert
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;
    vars_clear(&fc->l_vars.dv_hashtab);
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);
    free_funccal(fc);
}","free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;
    vars_clear(&fc->l_vars.dv_hashtab);
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);
	int wb;
	uint32_t lvcall;
	CPUState *env;
	unsigned int valpages;
	uint32_t r_cause;
	int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t pid, lo, hi;
	int set, match = 0;
	r_cause = env->sregs[SFR_R_MM_CAUSE];
	D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
			  "" %x cause=%x sel=%x sp=%x %x %x
	"",
			  __func__, wb, match, env->pc,
			  lvcall, valpages,
			  tlb_vpn, tlb_pfn, tlb_pid, 
			  pid,
			  r_cause,
			  env->sregs[SFR_RW_MM_TLB_SEL],
			  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    free_funccal(fc);
}",0,1,31,0.32,Insert
2887,"static void register_if_needed(h2_mplx *m) 
{
    if (!m->aborted && !m->is_registered && !h2_iq_empty(m->q)) {
        apr_status_t status = h2_workers_register(m->workers, m); 
        if (status == APR_SUCCESS) {
            m->is_registered = 1;
        }
        else {
            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, m->c, APLOGNO(10021)
                          ""h2_mplx(%ld): register at workers"", m->id);
        }
    }
}","static void register_if_needed(h2_mplx *m) 
{
    if (!m->aborted && !m->is_registered && !h2_iq_empty(m->q)) {
        apr_status_t status = h2_workers_register(m->workers, m); 
        if (status == APR_SUCCESS) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                m->is_registered = 1;
            }
        }
        else {
            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, m->c, APLOGNO(10021)
                          ""h2_mplx(%ld): register at workers"", m->id);
                          H264Context *h;
                          MpegEncContext * const s = &h->s;
                          int contextslimit;
                          if(contextslimit)
                                  execute_decode_slices(h, contextslimit);
        }
    }
}",0,1,6,0.35,Insert
2888,"onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)
{
#ifdef USE_CALLOUT
  param->callout_user_data = user_data;
  return ONIG_NORMAL;
#else
  return ONIG_NO_SUPPORT_CONFIG;
#endif
}","onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)
{
#ifdef USE_CALLOUT
  param->callout_user_data = user_data;
  return ONIG_NORMAL;
#else
  int a = 45;
  int b = a;
  if(a*b>0){
      return ONIG_NO_SUPPORT_CONFIG;
      OPJ_UINT32 l_extra;
      AVCodecContext * avnc;
      MP3On4DecodeContext *this = avnc->priv_data;
      MP3On4DecodeContext *this = avnc->priv_data;
      this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
      avnc->channels = mp3Channels[this->chan_cfg];
      avnc->priv_data = this->mp3decctx[0];
      decode_init(avnc);
      avnc->priv_data = this;
      OPJ_UINT32 phi;
      for (i=0;iphip_nphi2pelements;++phi) {
                      opj_read_bytes(l_source_buffer,&l_extra,2);
                      l_source_buffer+=sizeof(OPJ_INT16);
                      *(l_src_pad++) = (OPJ_FLOAT32) l_extra;
      }
  }
#endif
}",0,1,37,0.36,Insert
2889,"static int qxl_destroy_primary(PCIQXLDevice *d, qxl_async_io async)
{
    if (d->mode == QXL_MODE_UNDEFINED) {
        return 0;
    }
    trace_qxl_destroy_primary(d->id);
    d->mode = QXL_MODE_UNDEFINED;
    qemu_spice_destroy_primary_surface(&d->ssd, 0, async);
    qxl_spice_reset_cursor(d);
    return 1;
}","static int qxl_destroy_primary(PCIQXLDevice *d, qxl_async_io async)
{
    if (d->mode == QXL_MODE_UNDEFINED) {
        return 0;
    }
    trace_qxl_destroy_primary(d->id);
    d->mode = QXL_MODE_UNDEFINED;
    qemu_spice_destroy_primary_surface(&d->ssd, 0, async);
    struct sk_buff *skb;
    struct sock *sk;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    "",
    		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    length = TCP_SKB_CB(skb)->length;
    qxl_spice_reset_cursor(d);
    int a = 53;
    int b = a;
    if(a*b>0){
        return 1;
    }
}",0,1,15,0.32,Insert
2892,"rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;
    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">\n"");
}","rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;
    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    int a = 2;
    int b = 2;
    if (a == b) {
        AVPacket *mctx;
        PutBitContext pb, pb2;
        int i, size, ure;
        put_marker(&pb, EOI);
        flush_put_bits(&pb);
        mctx->size   = put_bits_count(&pb) >> 3;
        g_string_append (ctx->priv->metadata, "">\n"");
    }
}",0,1,11,0.29,Insert
2894,,,,,,,
2895,,,,,,,
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;
    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        LPTSTR c;
    }
    TCHAR s;
    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}",0,1,1,0.1,Replace
2898,,,,,,,
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
	bgp_packet_set_size(s);
	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	bgp_writes_on(peer);
}","void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
	bgp_packet_set_size(s);
	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	VirtioCcwDevice *dev;
    	SubchDev *sch;
    	unsigned int cssid = 0;
    	DeviceState *parent = DEVICE(dev);
    	unsigned int schid;
    	unsigned int ssid = 0;
    	css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
    	                          parent->hotplugged, 1);
    	bgp_writes_on(peer);
	}
}",0,1,14,0.33,Insert
2900,"void blk_start_request(struct request *req)
{
	lockdep_assert_held(req->q->queue_lock);
	WARN_ON_ONCE(req->q->mq_ops);
	blk_dequeue_request(req);
	if (test_bit(QUEUE_FLAG_STATS, &req->q->queue_flags)) {
		req->io_start_time_ns = ktime_get_ns();
#ifdef CONFIG_BLK_DEV_THROTTLING_LOW
		req->throtl_size = blk_rq_sectors(req);
#endif
		req->rq_flags |= RQF_STATS;
		rq_qos_issue(req->q, req);
	}
	BUG_ON(blk_rq_is_complete(req));
	blk_add_timer(req);
}","void blk_start_request(struct request *req)
{
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	xml=DestroyString(xml);
	int a = 2;
	int b = 2;
	while (a == b) {
    	lockdep_assert_held(req->q->queue_lock);
    	b += 1;
	}
	WARN_ON_ONCE(req->q->mq_ops);
	blk_dequeue_request(req);
	if (test_bit(QUEUE_FLAG_STATS, &req->q->queue_flags)) {
		req->io_start_time_ns = ktime_get_ns();
#ifdef CONFIG_BLK_DEV_THROTTLING_LOW
		req->throtl_size = blk_rq_sectors(req);
#endif
		req->rq_flags |= RQF_STATS;
		rq_qos_issue(req->q, req);
	}
	BUG_ON(blk_rq_is_complete(req));
	blk_add_timer(req);
}",0,1,23,0.48,Insert
2901,"static unsigned long nfs_read_attr_generation_counter(void)
{
	return atomic_long_read(&nfs_attr_generation_counter);
}","static unsigned long nfs_read_attr_generation_counter(void)
{
	int a = 30;
	int b = a;
	if(a*b>0){
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	void *pack;
    	VdpBool supported;
    	VdpChromaType type;
    	status = hdtx->get_proc_address(hdtx->device,
    	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
    	                                     &pack);
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device,
    	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
    	                                     &pack);
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    	                                     &pack);
    	return atomic_long_read(&nfs_attr_generation_counter);
	}
}",0,1,6,0.17,Insert
2904,"static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;","static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
		AnimationChannel &context;
		json &o;
		SerializeNumberProperty(""sampler"", context.sampler, o);
		SerializeExtensionMap(context.extensions, o);
#endif
	return slab_kset;",0,1,4,0.15,Insert
2907,"static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);
	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;
	return git_index_add(data->index, conflict);
}","static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	int error = git_index_remove(data->index, conflict->path, 0);
	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;
	int a = 70;
	int b = a;
	if(a*b>0){
    	return git_index_add(data->index, conflict);
	}
}",0,1,5,0.33,Insert
2908,"SPL_METHOD(SplObjectStorage, getHash)
{
	zval *obj;
	char *hash;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""o"", &obj) == FAILURE) {
		return;
	}
	hash = emalloc(33);
	php_spl_object_hash(obj, hash TSRMLS_CC);
	RETVAL_STRING(hash, 0);
}  ","SPL_METHOD(SplObjectStorage, getHash)
{
	zval *obj;
	char *hash;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""o"", &obj) == FAILURE) {
		int a = 2;
		int b = 3;
		while (a != b) {
    		return;
    		void *calldata_2;
    		struct nfs4_opendata *data_9 = calldata_2;
    		struct nfs4_state *state_7 = NULL;
    		if (!IS_ERR_6(state_7))
    				nfs4_close_state_2(&data_9->path, state_7, data_9->o_arg.open_flags);
    		b = a;
    		void *calldata;
    		struct nfs4_opendata *data = calldata;
    		struct nfs4_state *state = NULL;
    		if (!IS_ERR(state))
    				nfs4_close_state(&data->path, state, data->o_arg.open_flags);
		}
	}
	hash = emalloc(33);
	php_spl_object_hash(obj, hash TSRMLS_CC);
	RETVAL_STRING(hash, 0);
}  ",1,0,1112,6.2,Insert
2909,"check_WRITE_METADATA(const struct ofpact_metadata *a OVS_UNUSED,
                     const struct ofpact_check_params *cp OVS_UNUSED)
{
    return 0;
}","check_WRITE_METADATA(const struct ofpact_metadata *a OVS_UNUSED,
                     const struct ofpact_check_params *cp OVS_UNUSED)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
        APEContext *ctx;
        int32_t predictionA, currentA, A, sign;
        APEPredictor *pb = &ctx->predictor;
        currentA = pb->lastA[0];
        pb->lastA[0] = currentA;
    strcpy(str, ""a"");
    }
}",0,1,5,0.18,Insert
2912,,,,,,,
2914,"static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	return rxq->tail == rxq->head;
}","static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	uint64_t glms;
	unsigned k, b_1, err, C;
	unsigned k, b_1, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_1 = ctz64(glms);
	int a = 2;
	int b = 3;
	if (a != b) {
    	return rxq->tail == rxq->head;
	}
}",0,1,4,0.16,Insert
2916,,,,,,,
2917,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  int a = 2;
  int b = 3;
  if (a != b) {
      NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  }
  CPUState *env;
  const sigset_t *sigset;
  struct kvm_signal_mask * sigmak;
  int r;
  sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
  sigmak->len = 8;
  memcpy( sigmak->sigset, sigset, sizeof(*sigset));
  r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
  free( sigmak);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}",0,1,20,0.53,Insert
2918,,,,,,,
2920,"static int ext4_inode_blocks_set(handle_t *handle,
				struct ext4_inode *raw_inode,
				struct ext4_inode_info *ei)
{
	struct inode *inode = &(ei->vfs_inode);
	u64 i_blocks = inode->i_blocks;
	struct super_block *sb = inode->i_sb;
	if (i_blocks <= ~0U) {
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = 0;
		ei->i_flags &= ~EXT4_HUGE_FILE_FL;
		return 0;
	}
	if (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE))
		return -EFBIG;
	if (i_blocks <= 0xffffffffffffULL) {
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);
		ei->i_flags &= ~EXT4_HUGE_FILE_FL;
	} else {
		ei->i_flags |= EXT4_HUGE_FILE_FL;
		i_blocks = i_blocks >> (inode->i_blkbits - 9);
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);
	}
	return 0;
}","static int ext4_inode_blocks_set(handle_t *handle,
				struct ext4_inode *raw_inode,
				struct ext4_inode_info *ei)
{
	struct inode *inode = &(ei->vfs_inode);
	u64 i_blocks = inode->i_blocks;
	struct super_block *sb = inode->i_sb;
	if (i_blocks <= ~0U) {
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = 0;
		ei->i_flags &= ~EXT4_HUGE_FILE_FL;
		return 0;
	}
	if (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE))
		return -EFBIG;
	if (i_blocks <= 0xffffffffffffULL) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		strcpy(str, ""a"");
		}
		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);
		ei->i_flags &= ~EXT4_HUGE_FILE_FL;
	} else {
		ei->i_flags |= EXT4_HUGE_FILE_FL;
		i_blocks = i_blocks >> (inode->i_blkbits - 9);
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);
	}
	return 0;
}",0,1,22,0.26,Replace
2921,,,,,,,
2922,"ModuleExport void UnregisterCALSImage(void)
{
  (void) UnregisterMagickInfo(""CAL"");
  (void) UnregisterMagickInfo(""CALS"");
}","ModuleExport void UnregisterCALSImage(void)
{
  int a = 2;
  int b = 3;
  while (a != b) {
      (void) UnregisterMagickInfo(""CAL"");
      b = a;
  }
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  VdpChromaType type;
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                       &pack);
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                       &pack);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  (void) UnregisterMagickInfo(""CALS"");
}",0,1,8,0.21,Insert
2924,,,,,,,
2925,"cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;
	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));
	ENTER;
	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}","cancel_refresh(dns_zone_t *zone) {
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	int a = 2;
	int b = 3;
	while (a < b) {
    	const char me[] = ""cancel_refresh"";
    	b = a;
	}
	isc_time_t now;
	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));
	ENTER;
	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}",0,1,18,0.39,Insert
2926,"lou_logFile (const char *fileName)
{
  if (fileName == NULL || fileName[0] == 0)
    return;
  if (initialLogFileName[0] == 0)
    strcpy (initialLogFileName, fileName);
  logFile = fopen (fileName, ""wb"");
  if (logFile == NULL && initialLogFileName[0] != 0)
    logFile = fopen (initialLogFileName, ""wb"");
  if (logFile == NULL)
    {
      fprintf (stderr, ""Cannot open log file %s\n"", fileName);
      logFile = stderr;
    }
}","lou_logFile (const char *fileName)
{
  if (fileName == NULL || fileName[0] == 0)
    return;
  if (initialLogFileName[0] == 0)
    strcpy (initialLogFileName, fileName);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      logFile = fopen (fileName, ""wb"");
  }
  if (logFile == NULL && initialLogFileName[0] != 0)
    logFile = fopen (initialLogFileName, ""wb"");
  if (logFile == NULL)
    {
      fprintf (stderr, ""Cannot open log file %s\n"", fileName);
      logFile = stderr;
    }
}",0,1,2,0.09,Replace
2929,"GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}","GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	NodeIDedItem *reg_node = sg->id_node;
    	b = a;
	}
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	files_struct *lsp;
	const struct dom_sid *group_sid = NULL;
	TALLOC_CTX *frame = talloc_stackframe();
	struct security_descriptor *psd = NULL;
	const struct dom_sid *owner_sid = NULL;
	struct security_descriptor *parent_desc = NULL;
	struct security_token *token = lsp->conn->session_info->security_token;
	status = se_create_child_secdesc(frame,
				&psd,
				&size,
				parent_desc,
				owner_sid,
				group_sid,
				lsp->is_directory);
	status = SMB_VFS_FSET_NT_ACL(lsp,
				security_info_sent,
				psd);
	return NULL;
}",0,1,29,0.37,Insert
2931,"draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);
    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);
    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);
    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }
    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);
    cairo_pattern_destroy(p);
    return CAIRO_TEST_SUCCESS;
}","draw (cairo_t *cr, int width, int height)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        cairo_set_source_rgb (cr, 0., 0., 0.);
        b += 1;
    }
    cairo_paint (cr);
    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);
    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);
    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }
    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);
    VirtioCcwDevice *dev;
    SubchDev *sch;
    unsigned int cssid = 0;
    DeviceState *parent = DEVICE(dev);
    unsigned int schid;
    unsigned int ssid = 0;
    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                              parent->hotplugged, 1);
    cairo_pattern_destroy(p);
    return CAIRO_TEST_SUCCESS;
}",0,1,38,0.69,Insert
2932,"void print_version(void)
{
  printf(""%s  Ver %s Distrib %s, for %s (%s)\n"",my_progname,MTEST_VERSION,
	 MYSQL_SERVER_VERSION,SYSTEM_TYPE,MACHINE_TYPE);
}","void print_version(void)
{
  MachineState *machine;
  char *filename;
  MemoryRegion *ram = g_new(MemoryRegion, 1);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  spapr->icp = xics_system_init(machine,
                                    DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                 smp_threads),
                                    XICS_IRQS, &error_fatal);
  memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                           machine->ram_size);
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
  spapr->rtas_size = get_image_size(filename);
  spapr->rtas_blob = g_malloc(spapr->rtas_size);
  printf(""%s  Ver %s Distrib %s, for %s (%s)\n"",my_progname,MTEST_VERSION,
	 MYSQL_SERVER_VERSION,SYSTEM_TYPE,MACHINE_TYPE);
}",0,1,3,0.12,Insert
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
				AVCodecContext *AVcas;
				VdpStatus status;
				uint32_t input;
				VDPAUHWContext *hwctx = AVcas->hwaccel_context;
				VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
				if (status == VDP_STATUS_OK) {
				        hdtx->width  = AVcas->coded_width;
				        hdtx->input = AVcas->coded_height;
				}
			btrfs_add_raid_kobjects(fs_info);
			int a = 2;
			int b = 3;
			while (a != b) {
    			return 1;
    			b = a;
			}
		}
	}
	return 0;
}",0,1,34,0.66,Insert
2934,"static int raw6_seq_open(struct inode *inode, struct file *file)
{
	return raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);
}","static int raw6_seq_open(struct inode *inode, struct file *file)
{
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	xml=DestroyString(xml);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);
	}
}",0,1,3,0.2,Insert
2936,"void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)
{
	raw_spin_lock_init(&cfs_b->lock);
	cfs_b->runtime = 0;
	cfs_b->quota = RUNTIME_INF;
	cfs_b->period = ns_to_ktime(default_cfs_period());
	INIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);
	hrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	cfs_b->period_timer.function = sched_cfs_period_timer;
	hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	cfs_b->slack_timer.function = sched_cfs_slack_timer;
	cfs_b->distribute_running = 0;
}","void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)
{
	struct kvm_vcpu *vmboot;
	int  sep;
	vmx_set_segment(vmboot, scopy  sep);
	raw_spin_lock_init(&cfs_b->lock);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	cfs_b->runtime = 0;
	strcpy(str, ""a"");
	}
	cfs_b->quota = RUNTIME_INF;
	cfs_b->period = ns_to_ktime(default_cfs_period());
	INIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);
	hrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	cfs_b->period_timer.function = sched_cfs_period_timer;
	hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	cfs_b->slack_timer.function = sched_cfs_slack_timer;
	cfs_b->distribute_running = 0;
}",0,1,30,0.37,Insert
2938,"int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;
    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);
    usb_detach(port);
    dev->attached--;
    return 0;
}","int usb_device_detach(USBDevice *dev)
{
    char str[] = ""Constant"";
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev_2 = &serial->serial->dev_2->dev_2;
    struct device *dev_2 = &serial->serial->dev_2->dev_2;
    int status;
    data = kmalloc(1, GFP_KERNEL);
    status = ti_vread_sync(serial->serial->dev_2, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev_2, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    while (strlen(str) > 5) {
        USBBus *bus = usb_bus_from_device(dev);
    strcpy(str, ""a"");
    }
    USBPort *port = dev->port;
    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);
    usb_detach(port);
    dev->attached--;
    return 0;
}",0,1,19,0.37,Insert
2940,"print_arrays_for(char *set)
{
  FILE *f;
  sprintf(buf, ""%s.conf"", set);
  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }
  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");
  fclose(f);
  return;
}","print_arrays_for(char *set)
{
  FILE *f;
  int a = 2;
  GstDateTime *dt_2, *dt2_8;
  dt_2 = gst_date_time_new_now_utc ();
  fail_unless (gst_date_time_has_year (dt_2));
  fail_unless (gst_date_time_has_month (dt_2));
  fail_unless (gst_date_time_has_day (dt_2));
  fail_unless (gst_date_time_has_time (dt_2));
  int b = 3;
  while (a != b) {
      sprintf(buf, ""%s.conf"", set);
      b = a;
  }
  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }
  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\

GDateTime *gdt, *gdt2;
GstDateTime *dt, *dt2;
gst_date_time_unref (dt);
g_date_time_unref (gdt2); */\n\n"",
	 set, prog);
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");
  fclose(f);
  return;
}",1,0,63,0.85,Insert
2942,,,,,,,
2943,"static int wait_for_discard(void *word)
{
	schedule();
	return 0;
}","static int wait_for_discard(void *word)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	schedule();
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	QuantizationTable
    	    *table;
    	size_t
    	    length;
    	content=GetXMLTreeContent(levels);
    	table->levels=(unsigned int *) AcquireQuantumMemory(length,
    	    sizeof(*table->levels));
	}
	return 0;
}",0,1,10,0.18,Insert
2945,,,,,,,
2948,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		int a = 2;
		int b = 2;
		while (a == b) {
    		btrfs_mark_buffer_dirty(path->nodes[i]);
    		b += 1;
    		unsigned int i_6;
    		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    		int  driver_cache;
    		for (i_6 = 0; i_6 < ESP_MAX_DEVS; i_6++) {
    		         driver_cache = drive_get_index(IF_SCSI, 0, i_6);
    		        if ( driver_cache == -1)
    		            continue;
    		        esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i_6);
    		}
		}
		if (tslot != 0)
			break;
	}
}",0,1,18,0.57,Insert
2949,,,,,,,
2951,"static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,
                              int nb_sectors)
{
    if (nb_sectors > INT_MAX / BDRV_SECTOR_SIZE) {
        return -EIO;
    }
    return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,
                                   nb_sectors * BDRV_SECTOR_SIZE);
}","static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,
                              int nb_sectors)
{
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    if (nb_sectors > INT_MAX / BDRV_SECTOR_SIZE) {
        int a = 2;
        int b = 3;
        while (a < b) {
            return -EIO;
            b = a;
        }
    }
    return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,
                                   nb_sectors * BDRV_SECTOR_SIZE);
}",0,1,12,0.33,Insert
2952,"rb_push_glob(VALUE str, int flags)  
{
    long offset = 0;
    VALUE ary;
    GlobPathValue(str, TRUE);
    ary = rb_ary_new();
    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }
    return ary;
}","rb_push_glob(VALUE str, int flags)  
{
    long offset = 0;
    VALUE ary;
    GlobPathValue(str, TRUE);
    ary = rb_ary_new();
    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	gchar *str_1, *str2;
	GstDateTime *dt, *dt2;
	GstDateTime *dt, *dt2;
	fail_unless (!gst_date_time_has_time (dt));
	fail_unless (!gst_date_time_has_second (dt));
	str_1 = gst_date_time_to_iso8601_string (dt);
	dt2 = gst_date_time_new_from_iso8601_string (str_1);
	fail_unless (gst_date_time_get_year (dt) == gst_date_time_get_year (dt2));
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	bool bool_var = (status);
	if (bool_var) GLOB_JUMP_TAG(bool_var);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }
    return ary;
}",1,0,23,0.73,Insert
2955,,,,,,,
2956,"TEST(SnappyMessageCompressor, Overflow) {
    checkOverflow(stdx::make_unique<SnappyMessageCompressor>());
}","TEST(SnappyMessageCompressor, Overflow) {
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    int a = 2;
    int b = 2;
    while (a == b) {
        checkOverflow(stdx::make_unique<SnappyMessageCompressor>());
        b += 1;
    }
}",0,1,9,0.19,Insert
2959,,,,,,,
2960,"systemd_unit_name_escape (const gchar *in)
{
  GString * const str = g_string_sized_new (strlen (in));
  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  return g_string_free (str, FALSE);
}","systemd_unit_name_escape (const gchar *in)
{
  GString * const str = g_string_sized_new (strlen (in));
  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  int a_1 = 2;
  int b_1 = 2;
  while (a_1 == b_1) {
      return g_string_free (str, FALSE);
      b_1 += 1;
      uint32_t access_mask;
      struct connection_struct *connected;
      uint32_t rejected_mask = access_mask;
      uint32_t rejected_share_error;
      rejected_share_error = access_mask & ~(connected->share_access);
  }
}",0,1,6,0.38,Insert
2962,"static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}
	pt->error = 0;
	poll->head = head;
	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);","static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		*poll_ptr = poll;
		strcpy(str, ""a"");
		}
	}
	pt->error = 0;
	poll->head = head;
	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);",0,1,7,0.18,Replace
2963,"bool CModules::OnUserTextMessage(CTextMessage& Message) {
    MODHALTCHK(OnUserTextMessage(Message));
}","bool CModules::OnUserTextMessage(CTextMessage& Message) {
    int a = 2;
    int b = 3;
    if (a != b) {
        MODHALTCHK(OnUserTextMessage(Message));
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        gf_bs_read_u8(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
    }
}",0,1,5,0.18,Insert
2964,,,,,,,
2965,"TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);
    conn_manager_->newStream(response_encoder_);
    return Http::okStatus();
  }));
  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false);  
  EXPECT_CALL(*duration_timer, disableTimer());
  duration_timer->invokeCallback();
  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
}","TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);
    conn_manager_->newStream(response_encoder_);
    return Http::okStatus();
  }));
  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false);  
  EXPECT_CALL(*duration_timer, disableTimer());
  duration_timer->invokeCallback();
  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
      struct edgeport_serial *serial;
      u8 *data;
      struct device *dev = &serial->serial->dev->dev;
      struct device *dev = &serial->serial->dev->dev;
      int status;
      if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
      		dev_dbg(dev, ""%s - ROM_TYPE_III
      "", __func__);
      		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
      		goto out;
      }
  }
}",0,1,21,0.48,Insert
2969,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;
    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    return MK_PLUGIN_RET_NOT_ME;
}","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;
    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        int a = 2;
        int b = 3;
        if (a != b) {
            PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        }
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    return MK_PLUGIN_RET_NOT_ME;
}",1,0,2,0.13,Replace
2970,,,,,,,
2971,,,,,,,
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;
  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  unsigned maxpages;
  size_t *start;
  struct iov_iter *i_8;
  unsigned int iter_head, npages;
  unsigned int iter_head, npages;
  size_t capacity;
  data_start(i_8, &iter_head, start);
  capacity = min(npages, maxpages) * PAGE_SIZE - *start;
  if (!array)
    return;
  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            int a = 2;
            int b = 3;
            if (a != b) {
                break;
            }
          }
    }
}",0,1,8,0.6,Insert
2975,"    CImg<Tfloat> get_resize_object3d() const {
      return CImg<Tfloat>(*this,false).resize_object3d();
    }","    CImg<Tfloat> get_resize_object3d() const {
      int a = 2;
      int b = 3;
      while (a != b) {
          unsigned char *sha1;
          void *data;
          unsigned long size;
          struct pbase_tree *it;
          unsigned char tree_sha1[20];
          data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
          it = xcalloc(1, sizeof(*it));
          it->pcache.tree_size = size;
          return CImg<Tfloat>(*this,false).resize_object3d();
          b = a;
      }
    }",0,1,21,0.25,Insert
2976,"Value ExpressionDivide::evaluate(const Document& root, Variables* variables) const {
    Value lhs = _children[0]->evaluate(root, variables);
    Value rhs = _children[1]->evaluate(root, variables);
    auto assertNonZero = [](bool nonZero) { uassert(16608, ""can't $divide by zero"", nonZero); };
    if (lhs.numeric() && rhs.numeric()) {
        if (lhs.getType() == NumberDecimal || rhs.getType() == NumberDecimal) {
            Decimal128 numer = lhs.coerceToDecimal();
            Decimal128 denom = rhs.coerceToDecimal();
            assertNonZero(!denom.isZero());
            return Value(numer.divide(denom));
        }
        double numer = lhs.coerceToDouble();
        double denom = rhs.coerceToDouble();
        assertNonZero(denom != 0.0);
        return Value(numer / denom);
    } else if (lhs.nullish() || rhs.nullish()) {
        return Value(BSONNULL);
    } else {
        uasserted(16609,
                  str::stream() << ""$divide only supports numeric types, not ""
                                << typeName(lhs.getType()) << "" and "" << typeName(rhs.getType()));
    }
}","Value ExpressionDivide::evaluate(const Document& root, Variables* variables) const {
    Value lhs = _children[0]->evaluate(root, variables);
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    int rules, nb_regs, ini;
    rules = args[nb_oargs + nb_iargs + 1];
    Value rhs = _children[1]->evaluate(root, variables);
    auto assertNonZero = [](bool nonZero) { uassert(16608, ""can't $divide by zero"", nonZero); };
    if (lhs.numeric() && rhs.numeric()) {
        if (lhs.getType() == NumberDecimal || rhs.getType() == NumberDecimal) {
            Decimal128 numer = lhs.coerceToDecimal();
            Decimal128 denom = rhs.coerceToDecimal();
            assertNonZero(!denom.isZero());
            return Value(numer.divide(denom));
        }
        double numer = lhs.coerceToDouble();
        double denom = rhs.coerceToDouble();
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            assertNonZero(denom != 0.0);
        }
        return Value(numer / denom);
    } else if (lhs.nullish() || rhs.nullish()) {
        return Value(BSONNULL);
    } else {
        uasserted(16609,
                  str::stream() << ""$divide only supports numeric types, not ""
                                << typeName(lhs.getType()) << "" and "" << typeName(rhs.getType()));
    }
}",0,1,24,0.67,Insert
2978,"relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif  
finalize_it:
	LEAVE_RELPFUNC;
}","relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	const uint16_t min_mesh[17];
	int16_t nrsc[16];
	int err;
	int path, i_2;
	for (i_2 = 1; i_2 < err; i_2++)
	        if (nrsc[i_2] < nrsc[i_2 - 1] + min_mesh[i_2])
	            nrsc[i_2] = nrsc[i_2 - 1] + min_mesh[i_2];
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif  
finalize_it:
	int a = 42;
	int b = a;
	if(a*b>0){
    	LEAVE_RELPFUNC;
	}
}",0,1,21,0.62,Insert
2981,,,,,,,
2983,,,,,,,
2984,,,,,,,
2986,,,,,,,
2988,"      static double mp_log10(_cimg_math_parser& mp) {
        return std::log10(_mp_arg(2));
      }","      static double mp_log10(_cimg_math_parser& mp) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            const AVFrame *capt;
            const AVFrame *const p = capt;
            uint8_t *last = NULL;
            uint8_t *zero = NULL;
            zero = last = av_mallocz(p->linesize[0]);
            return std::log10(_mp_arg(2));
        strcpy(str, ""a"");
        }
      }",0,1,4,0.17,Insert
2991,,,,,,,
2992,,,,,,,
2993,"        inline void process_url()
        {
            handler_->handle_url();
        }","        inline void process_url()
        {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                struct edgeport_serial *serial;
                u8 *data;
                struct device *dev = &serial->serial->dev->dev;
                struct device *dev = &serial->serial->dev->dev;
                int status;
                if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
                		dev_dbg(dev, ""%s - ROM_TYPE_II
                "", __func__);
                		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
                		goto out;
                }
                handler_->handle_url();
            }
        }",0,1,5,0.13,Insert
2998,,,,,,,
2999,"bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}","bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	int a = 2;
	int b = 3;
	while (a != b) {
    	return true;
    	b = a;
	}
}",1,0,1,0.08,Replace
3000,"int rtnl_talk_extack(struct rtnl_handle *rtnl, struct nlmsghdr *n,
		     struct nlmsghdr **answer,
		     nl_ext_ack_fn_t errfn)
{
	return __rtnl_talk(rtnl, n, answer, true, errfn);
}","int rtnl_talk_extack(struct rtnl_handle *rtnl, struct nlmsghdr *n,
		     struct nlmsghdr **answer,
		     nl_ext_ack_fn_t errfn)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	return __rtnl_talk(rtnl, n, answer, true, errfn);
    	CPUState *env;
    	const sigset_t *sigset;
    	struct kvm_signal_mask * sigmak;
    	int r;
    	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
    	sigmak->len = 8;
    	memcpy( sigmak->sigset, sigset, sizeof(*sigset));
    	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
    	free( sigmak);
    	b = a;
	}
}",0,1,6,0.28,Insert
3002,,,,,,,
3004,,,,,,,
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;
  va_end(args);
  if (string_obj == NULL)
    return NULL;
  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);
  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  uint32_t pport;
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  YR_OBJECT* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;
  va_end(args);
  if (string_obj == NULL)
    return NULL;
  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);
  int a = 2;
  int b = 2;
  if (a == b) {
      return ((YR_OBJECT_STRING*) string_obj)->value;
  }
}",0,1,12,0.44,Insert
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
V9fsPath *fs_path;
FsContext *FS_path;
int fd, ret;
struct handle_data *parent = (struct handle_data *)FS_path->private;
fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	int a = 2;
	int b = 3;
	while (a != b) {
    	return sp;
    	b = a;
	}
}",0,1,7,0.28,Insert
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	int a = 2;
	int b = 2;
	if (a == b) {
    	mutex_unlock(&dlci_ioctl_mutex);
	}
}",0,1,3,0.05,Replace
3009,,,,,,,
3011,,,,,,,
3016,,,,,,,
3017,,,,,,,
3020,"static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int entries;
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    return ff_mov_read_stsd_entries(c, pb, entries);
}","static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int entries;
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    int a = 2;
    int b = 3;
    while (a < b) {
        return ff_mov_read_stsd_entries(c, pb, entries);
        struct sk_buff *skb;
        struct sock *sk;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        struct tcp_sock *tp = tcp_sk(sk);
        u32 length, end64seq;
        SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
        "",
        		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
        length = TCP_SKB_CB(skb)->length;
        b = a;
    }
}",0,1,13,0.37,Insert
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		data->cpu_entry.reserved = 0;
		strcpy(str, ""a"");
		}
	}
}",0,1,5,0.14,Replace
3022,"update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	curwin->w_set_curswant = FALSE;
    }
}","update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	int a = 2;
	int b = 2;
	if (a == b) {
    	ptrdiff_t src_stride;
    	ptrdiff_t buf_stride;
    	int h;
    	int src_y;
    	int block_h;
    	int w;
    	int block_w;
    	const uint8_t *src;
    	int src_x;
    	uint8_t *buf;
    	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
    	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
    	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    	curwin->w_set_curswant = FALSE;
	}
    }
}",0,1,11,0.21,Insert
3024,"Http::Context& PerListenerFactoryContextImpl::httpContext() {
  return listener_factory_context_base_->httpContext();
}","Http::Context& PerListenerFactoryContextImpl::httpContext() {
  ptrdiff_t src_stride;
  ptrdiff_t buf_stride;
  int h;
  int src_y;
  int block_h;
  int w;
  int block_w;
  const uint8_t *src;
  int src_x;
  uint8_t *buf;
  emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                       src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                       hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
  int a = 2;
  int b = 3;
  while (a < b) {
      return listener_factory_context_base_->httpContext();
      b = a;
  }
}",0,1,6,0.19,Insert
3029,"srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->separator = value;
	return SRS_SUCCESS;
}","srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->separator = value;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	int fd;
    	if (lseek(fd, 512, SEEK_SET) < 0) {
    	        goto fail;
    	}
    	return SRS_SUCCESS;
	}
}",0,1,8,0.22,Insert
3030,"	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
		#endif
		string path = dir;
		path.append(""/"");
		path.append(entry->d_name);
		return getFileType(path) == FT_DIRECTORY;
	}","	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
		#endif
		string path = dir;
		path.append(""/"");
		path.append(entry->d_name);
		int a = 2;
		int b = 3;
		while (a != b) {
    		return getFileType(path) == FT_DIRECTORY;
    		V9fsPath *fs_path;
    		FsContext *FS_path;
    		int fd, ret;
    		struct handle_data *parent = (struct handle_data *)FS_path->private;
    		fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    		b = a;
		}
	}",0,1,14,0.37,Insert
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int x;
    strcpy(str, ""a"");
    }
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",0,1,2,0.06,Replace
3032,"m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}","m_sg(union DateData *x)
{
    int *got_frame;
    void *data;
    AVPacket *avpkt;
    AVCodecContext *avctx;
    const uint8_t *buf = avpkt->data;
    int buf_index      = 0;
    AVFrame *pict      = data;
    int buf_size       = avpkt->size;
    H264Context *hy     = avctx->priv_data;
    buf_index = decode_nal_units(hy, buf, buf_size);
    assert(pict->buf[0] || !*got_frame);
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	get_c_jd(x);
	}
	return x->c.sg;
    }
}",0,1,20,0.28,Insert
3033,"GF_Err gen_sample_entry_box_size(GF_Box *s)
{
	GF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;
	ptr->size += 8;
	return GF_OK;
}","GF_Err gen_sample_entry_box_size(GF_Box *s)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	GF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpDecoderCreate *create;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	void *pack;
    	VdpBool supported;
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    	                                     &pack);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    	                                     &pack);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
	}
	ptr->size += 8;
	return GF_OK;
}",0,1,19,0.25,Insert
3034,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;
	lc = (struct tipc_link_config *)TLV_DATA(msg->req);
	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;
	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;
	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;
	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);
	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;
	lc = (struct tipc_link_config *)TLV_DATA(msg->req);
	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;
	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;
	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;
	int a = 2;
	int b = 3;
	while (a != b) {
    	__tipc_add_link_prop(skb, msg, lc);
    	b = a;
	}
	nla_nest_end(skb, prop);
	AVCodecContext *AVcas;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	nla_nest_end(skb, bearer);
	return 0;
}",0,1,22,0.57,Insert
3035,"calc_crc32( u32  crc,  u8  *p,  u32  len )
{
	while( len-- )
		crc = CRC32( *p++, crc );
	return  crc;
}","calc_crc32( u32  crc,  u8  *p,  u32  len )
{
	uint64_t glms;
	unsigned k, b_8, err, C;
	unsigned k, b_8, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_8 = ctz64(glms);
	while( len-- )
		crc = CRC32( *p++, crc );
	int a = 2;
	int b = 2;
	while (a == b) {
    	return  crc;
    	b += 1;
	}
}",0,1,3,0.28,Insert
3039,,,,,,,
3045,"static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;
	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;
	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);
	return ret;
}","static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;
	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;
	int a = 2;
	int b = 2;
	if (a == b) {
    	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);
    	const char *nptr;
    	double vals, mul, integral, fraction;
    	char *ndpointer;
    	unsigned char c;
    	vals = strtod(nptr, &ndpointer);
    	c = *ndpointer;
	}
	return ret;
}",0,1,12,0.3,Insert
3046,,,,,,,
3047,"static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    DBUG_ASSERT(table->db && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  return 0;
}","static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        DBUG_ASSERT(table->db && table->table_name);
    }
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  return 0;
}",0,1,6,0.3,Insert
3048,"  void setWriteFlags(folly::WriteFlags flags) {
    writeFlags = flags;
  }","  void setWriteFlags(folly::WriteFlags flags) {
    AVPacket * pk;
    AVFormatContext *s;
    unsigned char rb[5];
    AVCodecParameters *par = s->streams[stream_index]->codecpar;
    AVIOContext *b_7     = s->b_7;
    const int stream_index =  pk->stream_index;
    avi_stream2fourcc(rb, stream_index, par->codec_type);
    avio_write(b_7, rb, 4);
    int a = 2;
    int b = 2;
    while (a == b) {
        writeFlags = flags;
        b += 1;
    }
  }",0,1,4,0.18,Insert
3049,,,,,,,
3053,"void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}","void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        BSONObj tmp = result.asTempObj();
    strcpy(str, ""a"");
    }
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}",0,1,4,0.08,Replace
3054,,,,,,,
3055,,,,,,,
3056,,,,,,,
3057,,,,,,,
3058,"static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;
	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}","static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	char str[] = ""Constant"";
	size_t *pnum_names;
	TALLOC_CTX *mem_ctx;
	char **names;
	size_t num_names;
	*pnum_names = 0;
	num_names = 0;
	MachineState *machine;
	sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	if (smc->dr_lmb_enabled) {
	        spapr_validate_node_memory(machine, &error_fatal);
	}
	*pnum_names = num_names;
	names = talloc_array(mem_ctx, char *, num_names);
	num_names = 0;
	if (strlen(str) > 0) {
    	u8 enable_bitmap = 0;
	}
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;
	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}",0,1,34,0.35,Insert
3059,"static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
}","static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpStatus status;
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	int a = 80;
	int b = a;
	if(a*b>0){
    	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
	}
}",0,1,6,0.18,Insert
3062,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };
    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);
    return p;
}","static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };
    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            p->nlookup++;
        strcpy(str, ""a"");
        }
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);
    return p;
}",0,1,7,0.14,Replace
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	AVCodecContext *AVcas;
	VdpDecoderProfile profile;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpStatus status;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	int a = 2;
	int b = 2;
	if (a == b) {
    	timer_event = NULL;
	}
	timer_thread = NULL;
}",0,1,14,0.39,Insert
3068,,,,,,,
3069,,,,,,,
3070,"bool jswrap_graphics_idle() {
  graphicsIdle();
  return false;
}","bool jswrap_graphics_idle() {
  struct sock *Lister;
  struct vsock_sock *vcatel;
  vcatel = vsock_sk(Lister);
  sock_hold(Lister);
  graphicsIdle();
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return false;
  strcpy(str, ""a"");
  }
}",0,1,5,0.14,Insert
3071,,,,,,,
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		*salt = TC_H_MIN(res.classid);
		strcpy(str, ""a"");
		}
		return true;
	}
	return false;
}",0,1,2,0.12,Replace
3074,,,,,,,
3075,,,,,,,
3076,,,,,,,
3077,,,,,,,
3078,,,,,,,
3079,"static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}","static int usb_device_init(USBDevice *dev)
{
    int a = 2;
    int b = 3;
    AVPacket * pk;
    AVFormatContext *s;
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    AVIOContext *b_9     = s->b_9;
    avio_write(b_9,  pk->data, size);
    while (a < b) {
        USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
        b = a;
    }
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}",0,1,11,0.28,Insert
3080,,,,,,,
3081,"static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)
{
	glue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));
}","static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	glue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));
	strcpy(str, ""a"");
	}
}",0,1,1,0.03,Replace
3084,"XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  assert(status != NULL);
  *status = parser->m_parsingStatus;
}","XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  struct edgeport_serial *serial;
  u8 *data;
  struct device *dev = &serial->serial->dev->dev;
  struct device *dev = &serial->serial->dev->dev;
  int status_1;
  if ((!status_1) && (*data == UMP5152 || *data == UMP3410)) {
  		dev_dbg(dev, ""%s - ROM_TYPE_III
  "", __func__);
  		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
  		goto out;
  }
  assert(status != NULL);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      *status = parser->m_parsingStatus;
  }
}",0,1,5,0.2,Insert
3086,,,,,,,
3087,"nautilus_file_list_free (GList *list)
{
	nautilus_file_list_unref (list);
	g_list_free (list);
}","nautilus_file_list_free (GList *list)
{
	PutBitContext pb, pb2;
	JLSState *state;
	int i, size, ure;
	PutBitContext pb, pb2;
	ls_store_lse(state, &pb);
	put_bits(&pb2, 7, 0);
	size = put_bits_count(&pb2);
	flush_put_bits(&pb2);
	avpriv_align_put_bits(&pb);
	int a = 2;
	int b = 3;
	while (a < b) {
    	nautilus_file_list_unref (list);
    	b = a;
	}
	struct client_session *c;
	int http_status;
	struct session_request *sr;
	struct mk_list *host_list = &config->hosts;
	struct mk_list *sr_list = &c->request_list;
	if (http_status > 0) {
	        if (!sr->host_conf) {
	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
	        }
	        mk_request_error(http_status, c, sr);
	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
	                            NULL, c, sr);
	}
	g_list_free (list);
}",0,1,36,0.37,Insert
3089,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
struct vm_fault *vmf;
struct vm_area_struct *vma = vmf->vma;
struct page *page;
pte_t entry;
entry = mk_pte(page, vma->vm_page_prot);
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    int a = 2;
    GKeyFile *config;
    GKeyFile *config_9;
    if (config_9)
    		g_key_file_free_3(config_9);
    if (config)
    		g_key_file_free(config);
    int b = 3;
    while (a < b) {
        response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
        b = a;
    }
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}",1,0,841,4.65,Insert
3093,"mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;
	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;
	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}","mono_class_has_default_constructor (MonoClass *klass)
{
	int a = 1;
	int b = a;
	if(a*b>0){
    	MonoMethod *method;
	}
	const char *nptr;
	char *ndpointer;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	int64_t retval;
	double vals, mul, integral, fraction;
	vals = strtod(nptr, &ndpointer);
	fraction = modf(vals, &integral);
	retval = vals * mul;
	int i;
	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;
	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}",0,1,23,0.5,Insert
3095,"static SQInteger base_collectgarbage(HSQUIRRELVM v)
{
    sq_pushinteger(v, sq_collectgarbage(v));
    return 1;
}","static SQInteger base_collectgarbage(HSQUIRRELVM v)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        struct tty_struct *reader;
        struct awm *awm = reader->driver_data;
        struct acm_wb *sth;
        struct awm *awm = reader->driver_data;
        if (sth->len == awm->writesize) {
        		acm_tty_flush_chars(reader);
        		goto overflow;
        }
        sq_pushinteger(v, sq_collectgarbage(v));
        b = a;
    }
    return 1;
}",0,1,17,0.27,Insert
3098,"typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    int	    val;
    if (type == EXPR_IS || type == EXPR_ISNOT)
    {
	val = (tv1->v_type == tv2->v_type
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	    val = !val;
    }
    else if (tv1->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    {
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    else
    {
	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == EXPR_NEQUAL)
	    val = !val;
    }
    *res = val;
    return OK;
}","typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    int	    val;
    if (type == EXPR_IS || type == EXPR_ISNOT)
    {
	val = (tv1->v_type == tv2->v_type
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	    val = !val;
    }
    else if (tv1->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    {
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    else
    {
	int a = 2;
	int b = 2;
	while (a == b) {
    	DisplayState *ds;
    	const struct sun4d_hwdef *hawdecl;
    	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
    	        *espdma_iraque, *ledma_arquest;
    	ram_addr_t gram_size, prom_reset, tcx64off;
    	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
    	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    	escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
    	              serial_hds[0], ESCC_CLOCK, 1);
    	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
    	b += 1;
	}
	if (type == EXPR_NEQUAL)
	    val = !val;
    }
    *res = val;
    return OK;
}",0,1,19,0.79,Insert
3104,"poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}","poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  int size;
  void *opaque;
  int64_t slice;
  const uint8_t *buf;
  QEMUFileBdrv *s_6 = opaque;
  bdrv_pwrite(s_6->bs, s_6->base_offset + slice, buf, size);
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return s;
  strcpy(str, ""a"");
  }
}",0,1,8,0.29,Insert
3108,"static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
#else
	return(exp(x) - 1);
#endif
}","static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
	AVPacket * pk;
	AVFormatContext *s;
	const int stream_index =  pk->stream_index;
	int size               =  pk->size;
	AVIOContext *b     = s->b;
	avio_wl32(b, size);
	avio_write(b,  pk->data, size);
#else
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return(exp(x) - 1);
	strcpy(str, ""a"");
	}
#endif
}",0,1,6,0.22,Insert
3110,"static int acp_early_init(void *handle)
{
	return 0;
}","static int acp_early_init(void *handle)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	return 0;
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpBool supported;
    	VdpChromaType type;
    	VdpStatus status;
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	b = a;
	}
}",0,1,4,0.18,Insert
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void ecryptfs_free_kmem_caches(void)
{
	char str[] = ""Constant"";
	unsigned maxpages;
	size_t *start;
	struct iov_iter *i_5;
	unsigned int iter_head, npages;
	unsigned int iter_head, npages;
	size_t capacity;
	data_start(i_5, &iter_head, start);
	capacity = min(npages, maxpages) * PAGE_SIZE - *start;
	while (strlen(str) > 5) {
    	int i;
	strcpy(str, ""a"");
	}
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}",0,1,12,0.33,Insert
3116,,,,,,,
3117,,,,,,,
3119,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline ulong encode_twos_comp(long n, int prec)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	ulong result;
	}
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}",1,0,1,0.08,Replace
3120,,,,,,,
3121,"uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    adts_error_check(adts, ld);
    return 0;
}","uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    APEContext *ctx;
    int32_t predictionA, currentA, A, sign;
    APEPredictor *pb = &ctx->predictor;
    currentA = pb->lastA[0];
    pb->lastA[0] = currentA;
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        adts_error_check(adts, ld);
    strcpy(str, ""a"");
    }
    return 0;
}",0,1,7,0.25,Insert
3126,"hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}","hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        callbacks++;
        MachineState *machine;
        char *filename;
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                                 &savevm_htab_handlers, spapr);
    }
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}",0,1,7,0.19,Insert
3127,"    static const CImg<T>& const_empty() {
      static const CImg<T> _empty;
      return _empty;","    static const CImg<T>& const_empty() {
      int size;
      void *opaque;
      int64_t slice;
      const uint8_t *buf;
      QEMUFileBdrv *s = opaque;
      bdrv_pwrite(s->bs, s->base_offset + slice, buf, size);
      static const CImg<T> _empty;
      return _empty;",0,1,9,0.14,Insert
3132,"    virtual Status checkAuthForCommand(Client* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        return auth::checkAuthForAuthSchemaUpgradeCommand(client);
    }","    virtual Status checkAuthForCommand(Client* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return auth::checkAuthForAuthSchemaUpgradeCommand(client);
            struct sock *client_6;
            struct vsock_sock *Vconnection;
            Vconnection = vsock_sk(client_6);
            sock_hold(client_6);
        }
    }",0,1,4,0.16,Insert
3138,"static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	sk_del_node_init(sk);
	write_unlock_bh(&l->lock);
}","static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	int a = 2;
	int b = 3;
	while (a < b) {
    	sk_del_node_init(sk);
    	b = a;
	}
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	levels=GetXMLTreeChild(table_iterator,""levels"");
	table->levels=(unsigned int *) NULL;
	attribute=GetXMLTreeAttribute(levels,""width"");
	attribute=GetXMLTreeAttribute(levels,""height"");
	attribute=GetXMLTreeAttribute(levels,""divisor"");
	write_unlock_bh(&l->lock);
}",0,1,31,0.38,Insert
3139,,,,,,,
3142,"ippAddSeparator(ipp_t *ipp)		 
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));
  if (!ipp)
    return (NULL);
  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}","ippAddSeparator(ipp_t *ipp)		 
{
  int a = 2;
  int b = 3;
  while (a != b) {
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      QuantizationTable
          *table;
      size_t
          length;
      length=(size_t) table->width*table->height;
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));
      b = a;
  }
  if (!ipp)
    return (NULL);
  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}",0,1,17,0.28,Insert
3144,,,,,,,
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int a = 58;
	int b = a;
	if(a*b>0){
    	int size;
	}
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	return 0;
}",0,1,1,0.1,Replace
3147,"static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);
	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}
	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}","static int assign_proto_idx(struct proto *prot)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);
	}
	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	void *pack;
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}",0,1,15,0.27,Insert
3151,"static void csi_X(struct vc_data *vc, unsigned int vpar)
{					   
	unsigned int count;
	if (!vpar)
		vpar++;
	count = min(vpar, vc->vc_cols - vc->state.x);
	vc_uniscr_clear_line(vc, vc->state.x, count);
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}","static void csi_X(struct vc_data *vc, unsigned int vpar)
{					   
	unsigned int count;
	if (!vpar)
		vpar++;
	count = min(vpar, vc->vc_cols - vc->state.x);
	vc_uniscr_clear_line(vc, vc->state.x, count);
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	int a = 2;
	int b = 3;
	while (a < b) {
    	GOutputStream *os;
    	GInputStream *isa;
    	test_common_bounds_server(isa, os);
    	vc->vc_need_wrap = 0;
    	b = a;
	}
}",0,1,11,0.49,Insert
3153,,,,,,,
3154,"void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle pool, int index, TRAPS) {
  assert(EnableInvokeDynamic, """");
  KlassHandle  resolved_klass;
  Symbol* method_name = NULL;
  Symbol* method_signature = NULL;
  KlassHandle  current_klass;
  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
  if (TraceMethodHandles) {
    ResourceMark rm(THREAD);
    tty->print_cr(""resolve_invokehandle %s %s"", method_name->as_C_string(), method_signature->as_C_string());
  }
  resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);
}","void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle pool, int index, TRAPS) {
  assert(EnableInvokeDynamic, """");
  KlassHandle  resolved_klass;
  Symbol* method_name = NULL;
  Symbol* method_signature = NULL;
  KlassHandle  current_klass;
  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
  if (TraceMethodHandles) {
    ResourceMark rm(THREAD);
    tty->print_cr(""resolve_invokehandle %s %s"", method_name->as_C_string(), method_signature->as_C_string());
  }
  int a = 2;
  int b = 3;
  if (a != b) {
      resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);
  }
}",1,0,1,0.07,Replace
3155,,,,,,,
3156,"static unsigned long mmap_rnd(void)
{
	unsigned long rnd = 0UL;
	if (current->flags & PF_RANDOMIZE) {
		unsigned long val = get_random_int();
		if (test_thread_flag(TIF_32BIT))
			rnd = (val % (1UL << (23UL-PAGE_SHIFT)));
		else
			rnd = (val % (1UL << (30UL-PAGE_SHIFT)));
	}
	return rnd << PAGE_SHIFT;
}","static unsigned long mmap_rnd(void)
{
	unsigned long rnd = 0UL;
	if (current->flags & PF_RANDOMIZE) {
		unsigned long val = get_random_int();
		if (test_thread_flag(TIF_32BIT))
			rnd = (val % (1UL << (23UL-PAGE_SHIFT)));
		else
			rnd = (val % (1UL << (30UL-PAGE_SHIFT)));
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return rnd << PAGE_SHIFT;
    	SDRequest *err;
    	SDState *esi;
    	uint32_t last_status = esi->card_status;
    	sd_rsp_type_t srowner;
    	uint32_t last_status = esi->card_status;
    	if (last_status & APP_CMD) {
    	        srowner = sd_app_command(esi, *err);
    	        esi->card_status &= ~APP_CMD;
    	    } else
    	        srowner = sd_normal_command(esi, *err);
	}
}",0,1,8,0.29,Insert
3157,,,,,,,
3160,,,,,,,
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        check_string_option(&wop->wo_stl);
    strcpy(str, ""a"");
    }
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}",0,1,10,0.21,Replace
3163,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  int a = 2;
  int b = 2;
  while (a == b) {
      struct client_session *c;
      int http_status;
      struct session_request *sr;
      struct mk_list *host_list = &config->hosts;
      struct mk_list *sr_list = &c->request_list;
      if (http_status > 0) {
              if (!sr->host_conf) {
                  sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
              }
              mk_request_error(http_status, c, sr);
              mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                  NULL, c, sr);
      }
      part_info->linear_hash_mask= mask - 1;
      b += 1;
  }
}",0,1,5,0.25,Insert
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        prog = ttype->get_program()->get_name();
    }
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",0,1,1,0.14,Replace
3165,"eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;
    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}","eval_includeexpr(char_u *ptr, int len)
{
    	int a = 2;
    	int b = 3;
    	while (a < b) {
        char_u	*res;
        	b = a;
    	}
    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
		      uint64_t glms;
		      unsigned k, b_9, err, C;
		      unsigned k, b_9, err, C;
		      assert(is_limm(glms));
		      k = clz64(glms);
		      b_9 = ctz64(glms);
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}",0,1,9,0.33,Insert
3167,,,,,,,
3170,,,,,,,
3172,"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}","TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  int a = 2;
  int b = 3;
  while (a != b) {
      EXPECT_EQ(SQLITE_OK, rc);
      b = a;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      QuantizationTable
          *table;
      size_t
          length;
      length=(size_t) table->width*table->height;
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
  }
}",0,1,27,0.44,Insert
3177,,,,,,,
3178,"ff_layout_need_layoutcommit(struct pnfs_layout_segment *lseg)
{
	return !(FF_LAYOUT_LSEG(lseg)->flags & FF_FLAGS_NO_LAYOUTCOMMIT);
}","ff_layout_need_layoutcommit(struct pnfs_layout_segment *lseg)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpStatus status;
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	int a = 2;
	int b = 2;
	while (a == b) {
    	return !(FF_LAYOUT_LSEG(lseg)->flags & FF_FLAGS_NO_LAYOUTCOMMIT);
    	b += 1;
	}
}",0,1,19,0.25,Insert
3179,,,,,,,
3180,"ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    return get_attribute(si->unauth_attr, nid);
}","ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return get_attribute(si->unauth_attr, nid);
    }
}",0,1,2,0.04,Replace
3185,,,,,,,
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
struct sock *Lister;
struct vsock_sock *vcatel;
vcatel = vsock_sk(Lister);
sock_hold(Lister);
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        async_inited = 1;
    strcpy(str, ""a"");
    }
    return 1;
}",0,1,7,0.2,Insert
3190,,,,,,,
3193,"virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);
    conn = domain->conn;
    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);
    conn = domain->conn;
    if (conn->driver->domainAddIOThread) {
        int ret;
        int a = 2;
        int b = 3;
        if (a != b) {
            ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        }
        if (ret < 0)
            goto error;
        return ret;
    }
    AVCodecContext *AVcas;
    VdpStatus status;
    uint32_t input;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    if (status == VDP_STATUS_OK) {
            hdtx->width  = AVcas->coded_width;
            hdtx->input = AVcas->coded_height;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}",0,1,25,0.53,Insert
3194,"static void put_fc_log(struct fs_context *fc)
{
	struct fc_log *log = fc->log.log;
	int i;
	if (log) {
		if (refcount_dec_and_test(&log->usage)) {
			fc->log.log = NULL;
			for (i = 0; i <= 7; i++)
				if (log->need_free & (1 << i))
					kfree(log->buffer[i]);
			kfree(log);
		}
	}
}","static void put_fc_log(struct fs_context *fc)
{
	char str[] = ""Constant"";
	unsigned char  unch;
	struct acm_wb *sth;
	sth->buf[sth->len++] =  unch;
	while (strlen(str) > 5) {
    	struct fc_log *log = fc->log.log;
	strcpy(str, ""a"");
	}
	int i;
	if (log) {
		if (refcount_dec_and_test(&log->usage)) {
			fc->log.log = NULL;
			for (i = 0; i <= 7; i++)
				if (log->need_free & (1 << i))
					kfree(log->buffer[i]);
			kfree(log);
		}
	}
}",0,1,13,0.42,Insert
3198,"static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;
	sock_unregister(PF_INET6);
	rtnl_unregister_all(PF_INET6);
	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();
	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);
	rcu_barrier();  
}","static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;
	sock_unregister(PF_INET6);
	rtnl_unregister_all(PF_INET6);
	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();
	ipv6_packet_cleanup();
	AVRational osari;
	unsigned int h;
	unsigned int w;
	int64_t scaled_dim;
	if (osari.num < osari.den)
	        scaled_dim = av_rescale_rnd(w, osari.num, osari.den, AV_ROUND_ZERO);
	    else
	        scaled_dim = av_rescale_rnd(h, osari.den, osari.num, AV_ROUND_ZERO);
	int a = 2;
	int b = 2;
	if (a == b) {
    	ipv6_frag_exit();
	}
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();
	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);
	rcu_barrier();  
}",1,0,63,0.6,Insert
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct file *file = iocb->ki_filp;
	strcpy(str, ""a"");
	}
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, from);
}",0,1,5,0.07,Replace
3201,,,,,,,
3207,"node_new_anychar(void)
{
  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);
  return node;
}","node_new_anychar(void)
{
  int a = 2;
  int b = 2;
  AVCodecContext *AVcas;
  VdpStatus status;
  uint32_t input;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  if (status == VDP_STATUS_OK) {
          hdtx->width  = AVcas->coded_width;
          hdtx->input = AVcas->coded_height;
  }
  while (a == b) {
      Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);
      b += 1;
  }
  return node;
}",0,1,10,0.22,Insert
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  int a = 61;
  unsigned long array;
  struct net_bridge_mdb_entry *this = (void *)array;
  if (this->ports)
  		goto out;
  int b = a;
  if(a*b>0){
      return(MagickFalse);
  }
}",0,1,4,0.37,Insert
3209,"static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,
					      struct userfaultfd_wait_queue *ewq)
{
	if (WARN_ON_ONCE(current->flags & PF_EXITING))
		goto out;
	ewq->ctx = ctx;
	init_waitqueue_entry(&ewq->wq, current);
	spin_lock(&ctx->event_wqh.lock);
	__add_wait_queue(&ctx->event_wqh, &ewq->wq);
	for (;;) {
		set_current_state(TASK_KILLABLE);
		if (ewq->msg.event == 0)
			break;
		if (ACCESS_ONCE(ctx->released) ||
		    fatal_signal_pending(current)) {
			__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
			if (ewq->msg.event == UFFD_EVENT_FORK) {
				struct userfaultfd_ctx *new;
				new = (struct userfaultfd_ctx *)
					(unsigned long)
					ewq->msg.arg.reserved.reserved1;
				userfaultfd_ctx_put(new);
			}
			break;
		}
		spin_unlock(&ctx->event_wqh.lock);
		wake_up_poll(&ctx->fd_wqh, POLLIN);
		schedule();
		spin_lock(&ctx->event_wqh.lock);
	}
	__set_current_state(TASK_RUNNING);
	spin_unlock(&ctx->event_wqh.lock);
out:
	userfaultfd_ctx_put(ctx);
}","static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,
					      struct userfaultfd_wait_queue *ewq)
{
	if (WARN_ON_ONCE(current->flags & PF_EXITING))
		goto out;
	ewq->ctx = ctx;
	init_waitqueue_entry(&ewq->wq, current);
	spin_lock(&ctx->event_wqh.lock);
	__add_wait_queue(&ctx->event_wqh, &ewq->wq);
	for (;;) {
		set_current_state(TASK_KILLABLE);
		if (ewq->msg.event == 0)
			break;
		if (ACCESS_ONCE(ctx->released) ||
		    fatal_signal_pending(current)) {
			__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
			if (ewq->msg.event == UFFD_EVENT_FORK) {
				struct userfaultfd_ctx *new;
				new = (struct userfaultfd_ctx *)
					(unsigned long)
					ewq->msg.arg.reserved.reserved1;
				userfaultfd_ctx_put(new);
			}
			break;
		}
		spin_unlock(&ctx->event_wqh.lock);
		wake_up_poll(&ctx->fd_wqh, POLLIN);
		schedule();
		spin_lock(&ctx->event_wqh.lock);
	}
	DisasContext *qs;
	uint32_t ksns;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	order = extract32(ksns, 22, 2);
	handle_fp_compare(qs, order, coll, err, false, p);
	int a = 2;
	int b = 2;
	while (a == b) {
    	__set_current_state(TASK_RUNNING);
    	b += 1;
	}
	spin_unlock(&ctx->event_wqh.lock);
out:
	userfaultfd_ctx_put(ctx);
}",0,1,32,0.67,Insert
3212,,,,,,,
3213,"ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""Not affected\n"");
}","ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	GstDateTime *dt, *dt2;
	gst_date_time_unref (dt);
	dt = gst_date_time_new (0, 2010, 10, 30, 15, 50, 0);
	GstDateTime *dt_4, *dt2_2;
	gst_date_time_unref_1 (dt_4);
	dt_4 = gst_date_time_new_8 (0, 2010, 10, 30, 15, 50, 0);
	fail_unless_7 (gst_date_time_has_year_8 (dt_4));
	fail_unless_7 (gst_date_time_has_month_3 (dt_4));
	fail_unless_7 (gst_date_time_has_day_5 (dt_4));
	fail_unless (gst_date_time_has_year (dt));
	fail_unless (gst_date_time_has_month (dt));
	fail_unless (gst_date_time_has_day (dt));
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return sprintf(buf, ""Not affected\n"");
	}
}",1,0,86,0.59,Insert
3214,"static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;
    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;   
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);
    if (nids_out) *nids_out = nids;
    return n_lvls;
}","static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;
    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;   
    max_len += 256;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        s = 1LL << (min_shift + starting_n_lvls * 3);
    strcpy(str, ""a"");
    }
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);
    const AVPacket *tpkt;
    InputStream *ist;
    int ret = 0, i_10;
    for (i_10 = 0; tpkt && i_10 < nb_output_streams; i_10++) {
            OutputStream *ost = output_streams[i_10];
            if (!check_output_constraints(ist, ost) || ost->encoding_needed)
                continue;
            do_streamcopy(ist, ost, tpkt);
    }
    if (nids_out) *nids_out = nids;
    return n_lvls;
}",0,1,15,0.59,Insert
3215,"_nc_find_user_entry(const char *string)
{
    const HashData *data = _nc_get_hash_user();
    int hashvalue;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *real_table;
    hashvalue = data->hash_of(string);
    if (data->table_data[hashvalue] >= 0) {
	real_table = _nc_get_userdefs_table();
	ptr = real_table + data->table_data[hashvalue];
	while (!data->compare_names(ptr->ute_name, string)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = real_table + (ptr->ute_link
				+ data->table_data[data->table_size]);
	}
    }
    return (ptr);
}","_nc_find_user_entry(const char *string)
{
    const HashData *data = _nc_get_hash_user();
    int hashvalue;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *real_table;
    int a = 2;
    int b = 3;
    StyleDifference diff;
    StyleDifference diff_2;
    const RenderStyle* oldStyle_1;
    if (diff_2 == StyleDifferenceLayout_8 || !oldStyle_1)
             createOrDestroyMultiColumnFlowThreadIfNeeded_9();
    const RenderStyle* oldStyle;
    if (diff == StyleDifferenceLayout || !oldStyle)
             createOrDestroyMultiColumnFlowThreadIfNeeded();
    if (a != b) {
        hashvalue = data->hash_of(string);
    }
    if (data->table_data[hashvalue] >= 0) {
	real_table = _nc_get_userdefs_table();
	ptr = real_table + data->table_data[hashvalue];
	while (!data->compare_names(ptr->ute_name, string)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = real_table + (ptr->ute_link
				+ data->table_data[data->table_size]);
	}
    }
    return (ptr);
}",1,0,58,0.72,Insert
3217,,,,,,,
3219,"int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut\n"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d\n"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}","int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	int a = 31;
	int b = a;
	if(a*b>0){
    	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	}
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut\n"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d\n"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}",0,1,1,0.14,Replace
3220,,,,,,,
3222,,,,,,,
3224,,,,,,,
3226,,,,,,,
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	int a = 2;
	int b = 2;
	const AVFrame *capt;
	const AVFrame *const p_9 = capt;
	uint8_t *last = NULL;
	uint8_t *zero = NULL;
	zero = last = av_mallocz(p_9->linesize[0]);
	while (a == b) {
    	struct tty_driver *p;
    	b += 1;
	}
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}",0,1,13,0.43,Insert
3232,,,,,,,
3234,,,,,,,
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;
	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	int noblock = file->f_flags & O_NONBLOCK;
	}
	return vhost_chr_read_iter(dev, to, noblock);
}",0,1,3,0.06,Replace
3238,"GF_Box *ftab_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);
	return (GF_Box *) tmp;
}","GF_Box *ftab_box_new()
{
	struct videobuf_buffer *vb;
	struct videbuf_vmalloc_memory *mem=vb->priv;
	int pages;
	struct videbuf_vmalloc_memory *mem=vb->priv;
	pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
	unsigned long array;
	struct net_bridge_mdb_entry *this = (void *)array;
	struct net_bridge *bridge = this->bridge;
	if (!netif_running(bridge->dev) || timer_pending(&this->timer))
			goto out;
	dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
	"",
					(unsigned long)mem->vmalloc,
					pages << PAGE_SHIFT);
	int a = 20;
	int b = a;
	if(a*b>0){
    	ISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);
	}
	return (GF_Box *) tmp;
}",0,1,36,0.32,Insert
3239,"void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  int loop;   
  const TValue *tm;   
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    if (slot == NULL) {   
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (unlikely(notm(tm)))
        luaG_typeerror(L, t, ""index"");   
    }
    else {   
      lua_assert(isempty(slot));
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);   
      if (tm == NULL) {   
        setnilvalue(s2v(val));   
        return;
      }
    }
    if (ttisfunction(tm)) {   
      luaT_callTMres(L, tm, t, key, val);   
      return;
    }
    t = tm;   
    if (luaV_fastget(L, t, key, slot, luaH_get)) {   
      setobj2s(L, val, slot);   
      return;
    }
  }
  luaG_runerror(L, ""'__index' chain too long; possible loop"");
}","void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      int loop;   
  strcpy(str, ""a"");
  }
  const TValue *tm;   
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    if (slot == NULL) {   
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (unlikely(notm(tm)))
        luaG_typeerror(L, t, ""index"");   
    }
    else {   
      lua_assert(isempty(slot));
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);   
      if (tm == NULL) {   
        setnilvalue(s2v(val));   
        return;
      }
    }
    if (ttisfunction(tm)) {   
      luaT_callTMres(L, tm, t, key, val);   
      return;
    }
    t = tm;   
    if (luaV_fastget(L, t, key, slot, luaH_get)) {   
      setobj2s(L, val, slot);   
      return;
    }
  }
  luaG_runerror(L, ""'__index' chain too long; possible loop"");
}",0,1,2,0.17,Replace
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;
	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;
	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		int a_1 = 2;
		int b_1 = 3;
		while (a_1 != b_1) {
    		Rocker *r_3;
    		DescInfo *info;
    		uint32_t port;
    		int err = ROCKER_OK;
    		char *buf = desc_get_buf(info, true);
    		struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    		PCIDevice *dev = PCI_DEVICE(r_3);
    		int iovcnt = 0;
    		uint32_t pport;
    		pport = rocker_get_pport_by_tx_ring(r_3, desc_get_ring(info));
    		err = fp_port_eg(r_3->fp_port[port], iov, iovcnt);
    		r = ARCHIVE_FATAL;
    		b_1 = a_1;
		}
	}
	return (r);
}",0,1,17,0.68,Insert
3247,"napi_status napi_is_date(napi_env env,
                         napi_value value,
                         bool* is_date) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);
  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();
  return napi_clear_last_error(env);
}","napi_status napi_is_date(napi_env env,
                         napi_value value,
                         bool* is_date) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);
  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();
  int a = 2;
  int b = 3;
  while (a < b) {
      return napi_clear_last_error(env);
      CPUState *env_5;
      uint32_t p_cf;
      p_cf = env_5->sregs[SFR_RW_MM_CFG];
      b = a;
  }
}",0,1,9,0.34,Insert
3248,"void ConnectionImpl::StreamImpl::encodeTrailersBase(const HeaderMap& trailers) {
  ASSERT(!local_end_stream_);
  local_end_stream_ = true;
  if (pending_send_data_.length() > 0) {
    ASSERT(!pending_trailers_to_encode_);
    pending_trailers_to_encode_ = cloneTrailers(trailers);
  } else {
    submitTrailers(trailers);
    parent_.sendPendingFrames();
  }
}","void ConnectionImpl::StreamImpl::encodeTrailersBase(const HeaderMap& trailers) {
  int a = 2;
  int b = 3;
  if (a != b) {
      ASSERT(!local_end_stream_);
  }
  local_end_stream_ = true;
  if (pending_send_data_.length() > 0) {
    ASSERT(!pending_trailers_to_encode_);
    pending_trailers_to_encode_ = cloneTrailers(trailers);
  } else {
    submitTrailers(trailers);
    parent_.sendPendingFrames();
  }
}",1,0,1,0.06,Replace
3250,,,,,,,
3252,"static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, xstate_size);
	fx->cwd = 0x37f;
	fx->mxcsr = MXCSR_DEFAULT;
}","static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, xstate_size);
	fx->cwd = 0x37f;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	fx->mxcsr = MXCSR_DEFAULT;
	strcpy(str, ""a"");
	}
}",0,1,5,0.06,Replace
3255,,,,,,,
3257,"static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *devt = data;
	return dev->devt == *devt;
}","static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *devt = data;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct edgeport_serial *serial;
    	u8 *data_5;
    	struct device *dev_5 = &serial->serial->dev_5->dev_5;
    	struct device *dev_5 = &serial->serial->dev_5->dev_5;
    	int status;
    	data_5 = kmalloc(1, GFP_KERNEL);
    	status = ti_vread_sync(serial->serial->dev_5, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_5, 0x01);
    	status = ti_vread_sync(serial->serial->dev_5, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_5, 0x01);
    	return dev->devt == *devt;
	strcpy(str, ""a"");
	}
}",0,1,5,0.2,Insert
3259,"struct file *get_task_exe_file(struct task_struct *task)
{
	struct file *exe_file = NULL;
	struct mm_struct *mm;
	task_lock(task);
	mm = task->mm;
	if (mm) {
		if (!(task->flags & PF_KTHREAD))
			exe_file = get_mm_exe_file(mm);
	}
	task_unlock(task);
	return exe_file;
}","struct file *get_task_exe_file(struct task_struct *task)
{
	struct file *exe_file = NULL;
	struct mm_struct *mm;
	task_lock(task);
	mm = task->mm;
	if (mm) {
		if (!(task->flags & PF_KTHREAD))
			exe_file = get_mm_exe_file(mm);
	}
	task_unlock(task);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return exe_file;
	strcpy(str, ""a"");
	}
}",0,1,1,0.07,Replace
3260,"static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;
	if (dmar_unit == NULL) {
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else if (dmar_unit->drhd->ignore) {
		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else {
		valid = true;
	}
	return valid;
}","static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;
	if (dmar_unit == NULL) {
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else if (dmar_unit->drhd->ignore) {
		int a = 4;
		int b = a;
		if(a*b>0){
    		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
    		const char *fil;
    		AVIOContext *pb;
    		unsigned int base;
    		unsigned char *result = NULL;
    		int ret = 0, probe_size;
    		AVProbeData pd = { fil ? fil : """", NULL, -base };
    		ret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
		}
	} else {
		valid = true;
	}
	return valid;
}",0,1,12,0.37,Insert
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	int a = 2;
	AVCodecContext *AVcas;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	int b = 3;
	if (a != b) {
    	return 0;
	}
}",0,1,10,0.32,Insert
3264,"char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t off = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);
	if (off == 0 || len == 0) {
		return NULL;
	}
	return ad->ad_data + off;
}","char *ad_get_entry(const struct adouble *ad, int eid)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	off_t off = ad_getentryoff(ad, eid);
	}
	size_t len = ad_getentrylen(ad, eid);
	if (off == 0 || len == 0) {
		return NULL;
	}
	return ad->ad_data + off;
}",1,0,7,0.09,Replace
3265,"static void audit_log_execve_info(struct audit_context *context,
				  struct audit_buffer **ab)
{
	int i, len;
	size_t len_sent = 0;
	const char __user *p;
	char *buf;
	p = (const char __user *)current->mm->arg_start;
	audit_log_format(*ab, ""argc=%d"", context->execve.argc);
	buf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);
	if (!buf) {
		audit_panic(""out of memory for argv string"");
		return;
	}
	for (i = 0; i < context->execve.argc; i++) {
		len = audit_log_single_execve_arg(context, ab, i,
						  &len_sent, p, buf);
		if (len <= 0)
			break;
		p += len;
	}
	kfree(buf);
}","static void audit_log_execve_info(struct audit_context *context,
				  struct audit_buffer **ab)
{
	int i, len;
	size_t len_sent = 0;
	const char __user *p;
	char *buf;
	int a = 2;
	int b = 3;
	while (a < b) {
    	int64_t speed;
    	const BlockJobDriver *driver;
    	Error **errp;
    	void *opaque;
    	BlockDriverState *bs;
    	BlockCompletionFunc *cb;
    	MirrorBlockJob *s;
    	s = block_job_create(driver, bs, speed, cb, opaque, errp);
    	trace_mirror_start(bs, s, s->common.co, opaque);
    	p = (const char __user *)current->mm->arg_start;
    	int64_t speed_8;
    	const BlockJobDriver *driver_4;
    	Error **errp_10;
    	void *opaque_10;
    	BlockDriverState *bs_5;
    	BlockCompletionFunc *cb_2;
    	MirrorBlockJob *s_3;
    	s_3 = block_job_create_2(driver_4, bs_5, speed_8, cb_2, opaque_10, errp_10);
    	trace_mirror_start_7(bs_5, s_3, s_3->common.co, opaque_10);
    	b = a;
	}
	audit_log_format(*ab, ""argc=%d"", context->execve.argc);
	buf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);
	if (!buf) {
		audit_panic(""out of memory for argv string"");
		return;
	}
	for (i = 0; i < context->execve.argc; i++) {
		len = audit_log_single_execve_arg(context, ab, i,
						  &len_sent, p, buf);
		if (len <= 0)
			break;
		p += len;
	}
	kfree(buf);
}",1,0,749,5.43,Insert
3266,"smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}","smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	    DisasContext *qs;
	    uint32_t ksns;
	    unsigned int coll, order, err, resp, coll, p, nzcv;
	    unsigned int coll, order, err, resp, coll, p, nzcv;
	    unsigned int coll, order, err, resp, coll, p, nzcv;
	    unsigned int coll, order, err, resp, coll, p, nzcv;
	    err = extract32(ksns, 16, 5);
	    handle_fp_compare(qs, order, coll, err, false, p);
	int a = 2;
	int b = 3;
	while (a != b) {
    	smtp_enter_state(s, STATE_QUIT);
    	b = a;
	}
}",0,1,4,0.29,Insert
3267,,,,,,,
3271,"dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;
    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    return offset-offset_start;
}","dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;
    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    int a = 2;
    int b = 2;
    while (a == b) {
        proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        b += 1;
    }
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    return offset-offset_start;
}",0,1,1,0.1,Replace
3273,"static int _hostsock_getpeername(
    oe_fd_t* sock_,
    struct oe_sockaddr* addr,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);
    oe_socklen_t addrlen_in = 0;
    oe_errno = 0;
    if (!sock)
        OE_RAISE_ERRNO(OE_EINVAL);
    if (addrlen)
        addrlen_in = *addrlen;
    if (oe_syscall_getpeername_ocall(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            addrlen) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }
done:
    return ret;
}","static int _hostsock_getpeername(
    oe_fd_t* sock_,
    struct oe_sockaddr* addr,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);
    int a = 2;
    int b = 2;
    drdynvcPlugin* drdynvc;
    int cbChId;
    int Sp;
    int value;
    int Cmd;
    Cmd = (value & 0xf0) >> 4;
    WLog_Print(drdynvc->log, WLOG_DEBUG, ""order_recv: Cmd=0x%x, Sp=%d cbChId=%d"", Cmd, Sp, cbChId);
    while (a == b) {
        drdynvcPlugin* drdynvc_9;
        int cbChId_7;
        int Sp_9;
        int value_6;
        int Cmd_1;
        Cmd_1 = (value_6 & 0xf0) >> 4;
        WLog_Print_4(drdynvc_9->log, WLOG_DEBUG_2, ""order_recv: Cmd=0x%x, Sp=%d cbChId=%d"", Cmd_1, Sp_9, cbChId_7);
        oe_socklen_t addrlen_in = 0;
        b += 1;
    }
    oe_errno = 0;
    if (!sock)
        OE_RAISE_ERRNO(OE_EINVAL);
    if (addrlen)
        addrlen_in = *addrlen;
    if (oe_syscall_getpeername_ocall(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            addrlen) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }
done:
    return ret;
}",1,0,659,4.79,Insert
3274,"void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L;  
#endif
    bi_flush(s);
}","void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES * (2**1), 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L;  
#endif
    bi_flush(s);
}",0,1,1,0.08,Replace
3278,"static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;
	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
	return kobj;
}","static struct kobject *device_to_dev_kobj(struct device *dev)
{
	char *filename;
	if (!filename) {
	        error_report(""Could not find LPAR firmware '%s'"", bios_name);
	        exit(1);
	}
	struct kobject *kobj;
	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return kobj;
	}
}",0,1,8,0.34,Insert
3279,"static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;
	for (i = 0; i < maxdev; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;
		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}","static void slc_sync(void)
{
	const struct hldefinition *hldefinition;
	unsigned int i_5;
	if (hldefinition->console_serial_base) {
	        serial_mm_init(hldefinition->console_serial_base, 0, NULL, 115200,
	                       serial_hds[i_5], 1);
	        i_5++;
	}
	int i;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct net_device *dev;
	strcpy(str, ""a"");
	}
	struct slcan	  *sl;
	for (i = 0; i < maxdev; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;
		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}",0,1,11,0.43,Insert
3280,"CAMLprim value caml_string_get(value str, value index)
{
  intnat idx = Long_val(index);
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}","CAMLprim value caml_string_get(value str, value index)
{
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  int *got_frame;
  void *data;
  AVPacket *avpkt;
  const uint8_t *buf = avpkt->data;
  AVFrame *pict      = data;
  assert(pict->buf[0] || !*got_frame);
  if (strcmp(str1, str2) == 0) {
      intnat idx = Long_val(index);
  }
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}",0,1,4,0.28,Insert
3281,"static void setup_min_unmapped_ratio(void)
{
	pg_data_t *pgdat;
	struct zone *zone;
	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;
	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}","static void setup_min_unmapped_ratio(void)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	pg_data_t *pgdat;
	}
	struct zone *zone;
	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;
	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
		const struct dom_sid *alias;
		TALLOC_CTX *mem_stack;
		struct pdb_methods *mut;
		struct ldb_dn *anon;
		TALLOC_CTX *mem_context = talloc_new(mem_stack);
		struct dom_sid_buf buf;
		struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
				mut->private_data, struct pdb_samba_dsdb_state);
		NT_STATUS_HAVE_NO_MEMORY(mem_context);
		anon = ldb_dn_new_fmt(
				mem_context,
				area->ldb,
				""<SID=%s>"",
				dom_sid_str_buf(alias, &buf));
		talloc_free(mem_context);
				sysctl_min_unmapped_ratio) / 100;
}",0,1,5,0.23,Insert
3284,,,,,,,
3285,,,,,,,
3289,"static uint16_t nvme_changed_nslist(NvmeCtrl *n, uint8_t rae, uint32_t buf_len,
                                    uint64_t off, NvmeRequest *req)
{
    uint32_t nslist[1024];
    uint32_t trans_len;
    int i = 0;
    uint32_t nsid;
    memset(nslist, 0x0, sizeof(nslist));
    trans_len = MIN(sizeof(nslist) - off, buf_len);
    while ((nsid = find_first_bit(n->changed_nsids, NVME_CHANGED_NSID_SIZE)) !=
            NVME_CHANGED_NSID_SIZE) {
        if (i == ARRAY_SIZE(nslist)) {
            memset(nslist, 0x0, sizeof(nslist));
            nslist[0] = 0xffffffff;
            break;
        }
        nslist[i++] = nsid;
        clear_bit(nsid, n->changed_nsids);
    }
    if (nslist[0] == 0xffffffff) {
        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);
    }
    if (!rae) {
        nvme_clear_events(n, NVME_AER_TYPE_NOTICE);
    }
    return nvme_c2h(n, ((uint8_t *)nslist) + off, trans_len, req);
}","static uint16_t nvme_changed_nslist(NvmeCtrl *n, uint8_t rae, uint32_t buf_len,
                                    uint64_t off, NvmeRequest *req)
{
    uint32_t nslist[1024];
    uint32_t trans_len;
    int i = 0;
    uint32_t nsid;
    memset(nslist, 0x0, sizeof(nslist));
    int a = 2;
    int b = 2;
    if (a == b) {
        trans_len = MIN(sizeof(nslist) - off, buf_len);
    }
    while ((nsid = find_first_bit(n->changed_nsids, NVME_CHANGED_NSID_SIZE)) !=
            NVME_CHANGED_NSID_SIZE) {
        if (i == ARRAY_SIZE(nslist)) {
            memset(nslist, 0x0, sizeof(nslist));
            nslist[0] = 0xffffffff;
            break;
        }
        nslist[i++] = nsid;
        clear_bit(nsid, n->changed_nsids);
    }
    if (nslist[0] == 0xffffffff) {
        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);
    }
    if (!rae) {
        nvme_clear_events(n, NVME_AER_TYPE_NOTICE);
    }
    return nvme_c2h(n, ((uint8_t *)nslist) + off, trans_len, req);
}",1,0,1,0.14,Replace
3293,,,,,,,
3294,,,,,,,
3295,"int ipv6_setsockopt(struct sock *sk, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	int err;
	if (level == SOL_IP && sk->sk_type != SOCK_RAW)
		return udp_prot.setsockopt(sk, level, optname, optval, optlen);
	if (level != SOL_IPV6)
		return -ENOPROTOOPT;
	err = do_ipv6_setsockopt(sk, level, optname, optval, optlen);
#ifdef CONFIG_NETFILTER
	if (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&
			optname != IPV6_XFRM_POLICY)
		err = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);
#endif
	return err;
}","int ipv6_setsockopt(struct sock *sk, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	int err;
	if (level == SOL_IP && sk->sk_type != SOCK_RAW)
		return udp_prot.setsockopt(sk, level, optname, optval, optlen);
	if (level != SOL_IPV6)
		return -ENOPROTOOPT;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	err = do_ipv6_setsockopt(sk, level, optname, optval, optlen);
	}
#ifdef CONFIG_NETFILTER
	if (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&
			optname != IPV6_XFRM_POLICY)
		err = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);
#endif
	return err;
}",0,1,1,0.09,Replace
3297,,,,,,,
3299,,,,,,,
3302," */
void php_info_print_style(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");"," */
void php_info_print_style(TSRMLS_D)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	php_info_printf(""<style type=\""text/css\"">\n"");
	strcpy(str, ""a"");
	}
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");",0,1,4,0.06,Replace
3303,,,,,,,
3306,"enum Item_result Item_func_get_system_var::result_type() const
{
  switch (var->show_type())
  {
    case SHOW_BOOL:
    case SHOW_MY_BOOL:
    case SHOW_SINT:
    case SHOW_SLONG:
    case SHOW_SLONGLONG:
    case SHOW_UINT:
    case SHOW_ULONG:
    case SHOW_ULONGLONG:
    case SHOW_HA_ROWS:
      return INT_RESULT;
    case SHOW_CHAR: 
    case SHOW_CHAR_PTR: 
    case SHOW_LEX_STRING:
      return STRING_RESULT;
    case SHOW_DOUBLE:
      return REAL_RESULT;
    default:
      my_error(ER_VAR_CANT_BE_READ, MYF(0), var->name.str);
      return STRING_RESULT;                    
  }
}","enum Item_result Item_func_get_system_var::result_type() const
{
  switch (var->show_type())
  {
    case SHOW_BOOL:
    case SHOW_MY_BOOL:
    case SHOW_SINT:
    case SHOW_SLONG:
    case SHOW_SLONGLONG:
    case SHOW_UINT:
    case SHOW_ULONG:
    case SHOW_ULONGLONG:
    case SHOW_HA_ROWS:
      return INT_RESULT;
    case SHOW_CHAR: 
    case SHOW_CHAR_PTR: 
    case SHOW_LEX_STRING:
      return STRING_RESULT;
    case SHOW_DOUBLE:
      return REAL_RESULT;
    default:
      Rocker *r;
      DescInfo *info;
      char *buf = desc_get_buf(info, true);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      char *buf = desc_get_buf(info, true);
      PCIDevice *dev = PCI_DEVICE(r);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      uint32_t pport;
      rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
      pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
      my_error(ER_VAR_CANT_BE_READ, MYF(0), var->name.str);
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          return STRING_RESULT;                    
      strcpy(str, ""a"");
      }
  }
}",0,1,11,0.39,Insert
3307,"copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  to->min = from->min;
  to->max = from->max;
}","copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      to->min = from->min;
  }
  const char
      *attribute,
      *content;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  if (content != (char *) NULL)
      table->description=ConstantString(content);
  to->max = from->max;
}",0,1,5,0.19,Insert
3311,,,,,,,
3312,"R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	if (bbaddr != UT64_MAX) {
		r_core_seek (core, bbaddr, false);
		return true;
	}
	return false;
}","R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	}
	if (bbaddr != UT64_MAX) {
		r_core_seek (core, bbaddr, false);
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderCreate *create;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		void *pack;
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
		                                     &pack);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
		return true;
	}
	return false;
}",0,1,10,0.26,Insert
3314,"int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}","int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	return gid_index * hr_dev->caps.num_ports + port;
    	int port_5, is_output, ttl, remote_host;
    	char val[1024];
    	int port_5, is_output, ttl, remote_host;
    	int port_5, is_output, ttl, remote_host;
    	char hostname[256];
    	build_udp_url(val, sizeof(val),
    	                  hostname, port_5, remote_host, ttl);
    	build_udp_url(val, sizeof(val),
    	                  hostname, port_5 + 1, remote_host + 1, ttl);
    	b = a;
	}
}",0,1,4,0.23,Insert
3319,"    void CiffEntry::doAddComponent(UniquePtr  )
    {
        throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
    }","    void CiffEntry::doAddComponent(UniquePtr  )
    {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
        }
    }",0,1,2,0.04,Replace
3321,"ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;
    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
    qemu_net_queue_flush(queue);
    return ret;
}","ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;
    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
        const char *fil;
        AVIOContext *pb;
        unsigned int base;
        unsigned char *result = NULL;
        int ret_3 = 0, probe_size;
        AVProbeData pd = { fil ? fil : """", NULL, -base };
        ret_3 = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);
    }
    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        int a = 2;
        int b = 2;
        while (a == b) {
            qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
            b += 1;
        }
        return 0;
    }
    qemu_net_queue_flush(queue);
    return ret;
}",0,1,18,0.58,Insert
3323,"  void merge_unsafe_rollback_flags()
  {
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
    transaction.all.m_unsafe_rollback_flags|=
      (transaction.stmt.m_unsafe_rollback_flags &
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }","  void merge_unsafe_rollback_flags()
  {
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
    transaction.all.m_unsafe_rollback_flags|=
      (transaction.stmt.m_unsafe_rollback_flags &
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }",0,1,3,0.19,Insert
3324,"    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,8,1,3,(T)0);
        colormap[1] = colormap[3] = colormap[5] = colormap[7] =
          colormap[10] = colormap[11] = colormap[12] = colormap[13] =
          colormap[20] = colormap[21] = colormap[22] = colormap[23] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return colormap;
    }","    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> colormap;
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          cimg::mutex(8);
      strcpy(str, ""a"");
      }
      if (!colormap) {
        colormap.assign(1,8,1,3,(T)0);
        colormap[1] = colormap[3] = colormap[5] = colormap[7] =
          colormap[10] = colormap[11] = colormap[12] = colormap[13] =
          colormap[20] = colormap[21] = colormap[22] = colormap[23] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return colormap;
    }",0,1,1,0.08,Replace
3327,"static inline struct list_head *get_event_list(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	return event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
}","static inline struct list_head *get_event_list(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	int a = 2;
	int b = 3;
	while (a < b) {
    	return event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
    	AVCodecContext *AVcas;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	VdpBool supported;
    	VdpChromaType type;
    	VdpStatus status;
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	b = a;
	}
}",0,1,7,0.23,Insert
3328,"ldbm_config_internal_set(struct ldbminfo *li, char *attrname, char *value)
{
    char err_buf[SLAPI_DSE_RETURNTEXT_SIZE];
    struct berval bval;
    bval.bv_val = value;
    bval.bv_len = strlen(value);
    if (ldbm_config_set((void *)li, attrname, ldbm_config, &bval,
                        err_buf, CONFIG_PHASE_INTERNAL, 1  ,
                        LDAP_MOD_REPLACE) != LDAP_SUCCESS) {
        slapi_log_err(SLAPI_LOG_ERR,
                      ""ldbm_config_internal_set"", ""Error setting instance config attr %s to %s: %s\n"",
                      attrname, value, err_buf);
        exit(1);
    }
}","ldbm_config_internal_set(struct ldbminfo *li, char *attrname, char *value)
{
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value_8;
    value_8=InterpretLocaleValue(content,&p);
    (void) value_8;
    char err_buf[SLAPI_DSE_RETURNTEXT_SIZE];
    struct berval bval;
    bval.bv_val = value;
    bval.bv_len = strlen(value);
    if (ldbm_config_set((void *)li, attrname, ldbm_config, &bval,
                        err_buf, CONFIG_PHASE_INTERNAL, 1  ,
                        LDAP_MOD_REPLACE) != LDAP_SUCCESS) {
        slapi_log_err(SLAPI_LOG_ERR,
                      ""ldbm_config_internal_set"", ""Error setting instance config attr %s to %s: %s\n"",
                      attrname, value, err_buf);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            exit(1);
        }
    }
}",0,1,11,0.38,Insert
3331,"void adkm_box_del(GF_Box *s)
{
	GF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;
	if (!ptr) return;
	gf_free(s);
}","void adkm_box_del(GF_Box *s)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	GF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;
    	b = a;
	}
	AVPacket * pk;
	AVFormatContext *s_3;
	int size               =  pk->size;
	AVIOContext *b_1     = s_3->b_1;
	if (size & 1)
	        avio_w8(b_1, 0);
	if (!ptr) return;
	BlockdevOnError on_source_bug;
	BlockdevOnError on_source_complete;
	const char *dev;
	enum MirrorSyncMode stage;
	int64_t peed;
	const char *data;
	int data;
	Error *localxer = NULL;
	BlockDriverState *source_vs;
	int64_t store;
	BlockDriverState *bes;
	bes = bdrv_find(dev);
	data = bes->open_flags | BDRV_O_RDWR;
	store = bdrv_getlength(bes);
	backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
	                 block_job_cb, bes, &localxer);
	gf_free(s);
}",0,1,34,0.39,Insert
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  bool has_mode;
  const char *data_5;
  int data_5;
  if (!has_mode) {
          data_5 = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
  }
  struct display *olddisplay;
  display = (struct display *)data;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      debug(""idle timeout\n"");
  strcpy(str, ""a"");
  }
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}",0,1,13,0.51,Insert
3344,,,,,,,
3345,,,,,,,
3346,,,,,,,
3349,,,,,,,
3350,"static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;
	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);
	return 0;
}","static int binder_transactions_show(struct seq_file *m, void *unused)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct binder_proc *proc;
	}
	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		size_t
		    length;
		table->width=StringToUnsignedLong(attribute);
		table->height=StringToUnsignedLong(attribute);
		table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
		length=(size_t) table->width*table->height;
		table->levels=(unsigned int *) AcquireQuantumMemory(length,
		    sizeof(*table->levels));
	mutex_unlock(&binder_procs_lock);
	return 0;
}",0,1,15,0.29,Insert
3351,,,,,,,
3352,"   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		int a = 34;
		StyleDifference diff;
		const RenderStyle* oldStyle;
		if (diff == StyleDifferenceLayout || !oldStyle)
		         createOrDestroyMultiColumnFlowThreadIfNeeded();
		int b = a;
		if(a*b>0){
    		RETURN_TRUE;
		}
	} else {
		RETURN_FALSE;
	}",1,0,4,0.31,Insert
3353,"_rsvg_node_poly_free (RsvgNode * self)
{
    RsvgNodePoly *poly = (RsvgNodePoly *) self;
    if (poly->path)
        rsvg_cairo_path_destroy (poly->path);
    _rsvg_node_finalize (&poly->super);
    g_free (poly);
}","_rsvg_node_poly_free (RsvgNode * self)
{
    RsvgNodePoly *poly = (RsvgNodePoly *) self;
    if (poly->path)
        rsvg_cairo_path_destroy (poly->path);
    _rsvg_node_finalize (&poly->super);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                             &pack);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
        g_free (poly);
    }
}",0,1,7,0.26,Insert
3354,,,,,,,
3356,"static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;
	return strcasecmp(key, reuc->path);
}","static int reuc_isrch(const void *key, const void *array_member)
{
	int a = 88;
	bool varargs = dex_is_varargs(encoded__model->access_flags);
	RzBinSymbol *symbol = RZ_NEW0(RzBinSymbol);
	symbol->bind = dex_is_static(encoded__model->access_flags) ? RZ_BIN_BIND_GLOBAL_STR : RZ_BIN_BIND_LOCAL_STR;
	symbol->visibility = encoded__model->access_flags & UT32_MAX;
	symbol->size = encoded__model->code_size;
	symbol->ordinal = encoded__model->method_idx;
	symbol->method_flags = dex_access_flags_to_bin_flags(encoded__model->access_flags);
	int b = a;
	if(a*b>0){
    	const git_index_reuc_entry *reuc = array_member;
	}
	return strcasecmp(key, reuc->path);
}",0,1,20,0.28,Insert
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				int a = 56;
				int b = a;
				if(a*b>0){
    				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
    				unsigned char *sha1;
    				void *data;
    				unsigned long size;
    				struct pbase_tree *it;
    				unsigned char tree_sha1[20];
    				data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
    				hashcpy(it->pcache.sha1, tree_sha1);
				}
				break;
			}
		}
	}
	return value;
}",0,1,20,0.65,Insert
3367,"	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		PushParam(mask);
		PushParam(flags);
	}","	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		DisasContext *qs;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		unsigned int coll, order, err, resp, coll, p, nzcv;
		handle_fp_compare(qs, order, coll, err, false, p);
		int a = 2;
		int b = 3;
		while (a < b) {
    		PushParam(mask);
    		b = a;
		}
		PushParam(flags);
	}",0,1,5,0.24,Insert
3368,"add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;
	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}","add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;
	list = callback_data;
	int a = 2;
	int b = 3;
	if (a != b) {
    	*list = g_list_prepend (*list, g_strdup (key));
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    	attribute=GetXMLTreeAttribute(levels,""width"");
    	table->width=StringToUnsignedLong(attribute);
    	attribute=GetXMLTreeAttribute(levels,""height"");
    	table->height=StringToUnsignedLong(attribute);
	}
}",0,1,6,0.27,Insert
3369,,,,,,,
3370,"SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
	return offset;
}","SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	int a = 2;
	int b = 3;
	if (a != b) {
    	PROTO_ITEM_SET_HIDDEN(hidden_item);
	}
	offset = dissect_doserror(
	DisasContext *qs;
	uint32_t ksns;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	err = extract32(ksns, 16, 5);
	handle_fp_compare(qs, order, coll, err, false, p);
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
	return offset;
}",0,1,7,0.48,Insert
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;
    output_file = G_FILE (extract_job->output_files->data);
    nautilus_file_changes_queue_file_added (output_file);
}","extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;
    output_file = G_FILE (extract_job->output_files->data);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        nautilus_file_changes_queue_file_added (output_file);
        ChardevCommon *complex = backend->u.null;
        CharDriverState *charrb;
        charrb = qemu_chr_alloc(complex, erfp);
        charrb->chr_write = null_chr_write;
        charrb->explicit_be_open = true;
    }
}",0,1,9,0.2,Insert
3375,,,,,,,
3379,"service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;
	ccc_cb = new0(struct ccc_cb_data, 1);
	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}
	gatt_db_attribute_set_fixed_length(ccc, 2);
	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;
	queue_push_tail(database->ccc_callbacks, ccc_cb);
	return ccc;
}","service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;
	ccc_cb = new0(struct ccc_cb_data, 1);
	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}
	gatt_db_attribute_set_fixed_length(ccc, 2);
	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_II
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
			goto out;
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	ccc_cb->destroy = destroy;
    	b = a;
	}
	ccc_cb->user_data = user_data;
	queue_push_tail(database->ccc_callbacks, ccc_cb);
	return ccc;
}",0,1,32,0.72,Insert
3380,"rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, STR_TMPLOCK);
    return str;
}","rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
    }
    int a = 59;
    int b = a;
    if(a*b>0){
        FL_SET(str, STR_TMPLOCK);
    }
    return str;
}",0,1,9,0.28,Insert
3383,,,,,,,
3384,"int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    Expr *pExprA = pA->a[i].pExpr;
    Expr *pExprB = pB->a[i].pExpr;
    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
  }
  return 0;
}","int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    Expr *pExprA = pA->a[i].pExpr;
    Expr *pExprB = pB->a[i].pExpr;
    bool bool_var = ( pA->a[i].sortFlags!=pB->a[i].sortFlags );
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    if(bool_var) return 1;
    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
  }
  return 0;
}",0,1,12,0.41,Insert
3385,"reallocarray (void *ptr,
	      size_t nmemb,
	      size_t size)
{
	assert (nmemb > 0 && size > 0);
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, nmemb * size);
}","reallocarray (void *ptr,
	      size_t nmemb,
	      size_t size)
{
	GF_BitStream *bs_10;
	u8 sps_num_extra_ph_bits_4 = 8 * gf_bs_read_int_log_8(bs_10, 2, ""sps_num_extra_ph_bytes"");
	u32 is_2, CtbSizeY_4;
	VVC_SPS *sps_3;
	for (is_2=0; is_2<sps_num_extra_sh_bits_8; is_2++) {
			if (gf_bs_read_int_log_idx_6(bs_10, 1, ""extra_sh_bit_present_flag"", is_2))
				sps_3->sh_num_extra_bits++;
	}
	assert (nmemb > 0 && size > 0);
	GF_BitStream *bs;
	u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
	u32 is, CtbSizeY;
	VVC_SPS *sps;
	for (is=0; is<sps_num_extra_sh_bits; is++) {
			if (gf_bs_read_int_log_idx(bs, 1, ""extra_sh_bit_present_flag"", is))
				sps->sh_num_extra_bits++;
	}
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, nmemb * size);
}",1,0,180,1.07,Insert
3388,"void mce_disable_bank(int bank)
{
	if (bank >= mca_cfg.banks) {
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		return;
	}
	set_bit(bank, mce_banks_ce_disabled);
	on_each_cpu(__mce_disable_bank, &bank, 1);
}","void mce_disable_bank(int bank)
{
	if (bank >= mca_cfg.banks) {
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		return;
	}
	set_bit(bank, mce_banks_ce_disabled);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	AVCodecContext *AVcas;
    	VdpStatus status;
    	uint32_t input;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	if (status == VDP_STATUS_OK) {
    	        hdtx->width  = AVcas->coded_width;
    	        hdtx->input = AVcas->coded_height;
    	}
    	on_each_cpu(__mce_disable_bank, &bank, 1);
	}
}",0,1,11,0.28,Insert
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;
	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;
		if (ret != -EAGAIN)
			break;
		cond_resched();
	}
	return ret;
}","task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;
	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
					       const struct sun4d_hwdef *hawdecl;
					       int ret_9;
					       char data_8[1024];
					       snprintf(data_8, sizeof(data_8), ""%s/%s"", bios_dir, bios_name);
					       ret_9 = load_elf(data_8, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
		if (!ret)
			ret = data.ret;
		if (ret != -EAGAIN)
			break;
		cond_resched();
	}
	int a = 2;
	int b = 2;
	if (a == b) {
    	return ret;
	}
}",0,1,8,0.47,Insert
3391,,,,,,,
3393,"do_intthrow(cstack_T *cstack)
{
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;
#ifdef THROW_TEST	 
    if (!THROW_ON_INTERRUPT)
    {
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }
    return TRUE;
}","do_intthrow(cstack_T *cstack)
{
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;
#ifdef THROW_TEST	 
    if (!THROW_ON_INTERRUPT)
    {
	if (did_throw)
	    discard_current_exception();
	    CPUState *env;
	    const sigset_t *sigset;
	    struct kvm_signal_mask * sigmak;
	    int r;
	    sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	    sigmak->len = 8;
	    memcpy( sigmak->sigset, sigset, sizeof(*sigset));
	    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	    free( sigmak);
    }
    else
#endif
    {
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }
    return TRUE;
}",0,1,13,0.32,Insert
3394,"rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    g_free (pixels);
}","rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        content=GetXMLTreeContent(description);
        content=GetXMLTreeContent(levels);
        value=InterpretLocaleValue(content,&p);
        g_free (pixels);
    }
}",0,1,3,0.18,Insert
3395,"dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    return false;
}","dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    int a = 2;
    const AVFrame *capt;
    const AVFrame *const p_1 = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p_1->linesize[0]);
    int b = 2;
    if (a == b) {
        return false;
    }
}",0,1,5,0.16,Insert
3398,"void plist_bin_init(void)
{
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}","void plist_bin_init(void)
{
enum hfi1_sdma_comp_state state;
struct hfi1_user_sdma_comp_q *cq;
u16 idx;
int ret;
if (state == ERROR)
		cq->comps[idx].errcode = -ret;
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            plist_bin_debug = 1;
        strcpy(str, ""a"");
        }
    }
#endif
}",0,1,5,0.21,Insert
3399,,,,,,,
3400,"size_t estimate_size(const std::vector<RE*> &res)
{
    std::vector<StackItem> stack;
    const size_t nre = res.size();
    DASSERT(nre > 0);
    size_t size = nre - 1;
    for (size_t i = 0; i < nre; ++i) {
        size += estimate_re_size(res[i], stack) + 1;
    }
    return size;
}","size_t estimate_size(const std::vector<RE*> &res)
{
    std::vector<StackItem> stack;
    const size_t nre = res.size();
    DASSERT(nre > 0);
    size_t size = nre - 1;
    for (size_t i = 0; i < nre; ++i) {
        ppc4xx_bd_info_t *bd_8;
        int i_7, n_4;
        ram_addr_t bdloc_9;
        for (i_7 = 0; i_7 < 6; i_7++)
                stb_phys_8(bdloc_9 + 0x64 + i_7, bd_8->bi_pci_enetaddr[i_7]);
        int a = 35;
        ppc4xx_bd_info_t *bd;
        int i_8, n;
        ram_addr_t bdloc;
        for (i_8 = 0; i_8 < 6; i_8++)
                stb_phys(bdloc + 0x64 + i_8, bd->bi_pci_enetaddr[i_8]);
        int b = a;
        if(a*b>0){
            size += estimate_re_size(res[i], stack) + 1;
        }
    }
    return size;
}",1,0,46,0.53,Insert
3401,,,,,,,
3402,"encode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,
                     enum ofp_version ofp_version,
                     enum ofp_raw_action_type raw, enum mf_field_id field,
                     struct ofpbuf *out)
{
    ovs_be32 addr = ipv4->ipv4;
    if (ofp_version < OFP12_VERSION) {
        ofpact_put_raw(out, ofp_version, raw, ntohl(addr));
    } else {
        put_set_field(out, ofp_version, field, ntohl(addr));
    }
}","encode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,
                     enum ofp_version ofp_version,
                     enum ofp_raw_action_type raw, enum mf_field_id field,
                     struct ofpbuf *out)
{
    ovs_be32 addr = ipv4->ipv4;
    if (ofp_version < OFP12_VERSION) {
        ofpact_put_raw(out, ofp_version, raw, ntohl(addr));
    } else {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            put_set_field(out, ofp_version, field, ntohl(addr));
            struct edgeport_serial *serial;
            u8 *data;
            struct device *dev = &serial->serial->dev->dev;
            struct device *dev = &serial->serial->dev->dev;
            int status;
            status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
            				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
            status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
            				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
            dev_dbg(dev, ""%s - Unknown
            "", __func__);
        strcpy(str, ""a"");
        }
    }
}",0,1,8,0.39,Insert
3407,,,,,,,
3408,"static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;
	if (!ext4_has_group_desc_csum(sb))
		return ngroups;
	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;
		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}
	return group;
}","static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	int a = 2;
	int b = 2;
	Rocker *r;
	DescInfo *info;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	while (a == b) {
    	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
    	b += 1;
	}
	struct ext4_group_desc *gdp = NULL;
	if (!ext4_has_group_desc_csum(sb))
		return ngroups;
	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;
		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}
	return group;
}",0,1,13,0.54,Insert
3409,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;
	crash_support = cmd->frame->dcmd.mbox.w[0];
	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int a = 2;
	int b = 3;
	if (a != b) {
    	int i, error = 0;
	}
	int crash_support;
	crash_support = cmd->frame->dcmd.mbox.w[0];
	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
				unsigned maxpages;
				size_t *start;
				struct iov_iter *i_8;
				unsigned int iter_head, npages;
				unsigned int iter_head, npages;
				size_t capacity;
				npages = pipe_space_for_user(iter_head, i_8->pipe->tail, i_8->pipe);
				capacity = min(npages, maxpages) * PAGE_SIZE - *start;
			}
		}
	}
	return error;
}",0,1,19,0.53,Insert
3410,"static void dump_branches(void)
{
	unsigned int i;
	struct branch *b;
	for (i = 0; i < branch_table_sz; i++) {
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}","static void dump_branches(void)
{
	unsigned int i;
	PutBitContext pb, pb2;
	int i_5, size, ure;
	int comps;
	for (i_5 = 1; i_5 <= comps; i_5++) {
	        put_bits(&pb, 8, i_5);    
	        put_bits(&pb, 8, 0);    
	}
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 != b_1) {
    	struct branch *b;
    	b_1 = a_1;
	}
	for (i = 0; i < branch_table_sz; i++) {
		H264Context *h;
		MpegEncContext * const s = &h->s;
		int contextslimit;
		if(contextslimit)
		        execute_decode_slices(h, contextslimit);
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}",0,1,35,0.46,Insert
3411,,,,,,,
3412,"ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
}","ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_6     = s->b_6;
    if (size & 1)
            avio_w8(b_6, 0);
    GetCipher(self, ctx);
    int a = 2;
    int b = 2;
    if (a == b) {
        return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
    }
}",0,1,7,0.2,Insert
3413,"static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;
	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}","static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;
	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return add_extent_mapping(em_tree, em);
	strcpy(str, ""a"");
	}
}",0,1,1,0.09,Replace
3414,,,,,,,
3416,,,,,,,
3417,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	return JNI_EVERSION;	
}","jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
		struct hid_driver *hderver;
		int ret;
		ret = driver_register(&hderver->driver);
		ret = driver_create_file(&hderver->driver, &driver_attr_new_id);
	}
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    	return JNI_EVERSION;	
		strcpy(str, ""a"");
		}
}",0,1,8,0.27,Insert
3420,,,,,,,
3421,,,,,,,
3422,,,,,,,
3423,"static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
	}
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev_9 = &serial->serial->dev_9->dev_9;
	struct device *dev_9 = &serial->serial->dev_9->dev_9;
	int status;
	status = ti_vread_sync(serial->serial->dev_9, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev_9, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	dev_dbg(dev_9, ""%s - Unknown
	"", __func__);
	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;",0,1,6,0.29,Insert
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif
  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  int a = 2;
  int b = 3;
  while (a < b) {
      g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
      uint64_t glms;
      unsigned k, b_10, err, C;
      unsigned k, b_10, err, C;
      assert(is_limm(glms));
      k = clz64(glms);
      b_10 = ctz64(glms);
      b = a;
  }
  if (args->ident == NULL)
	return false;
#endif
  if (pident)
	*pident = args->ident;
  return true;
}",0,1,8,0.37,Insert
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void forward_timer_base(struct timer_base *base)
{
	ChardevCommon *complex = backend->u.null;
	CharDriverState *charrb;
	charrb = qemu_chr_alloc(complex, erfp);
	charrb->chr_write = null_chr_write;
	charrb->explicit_be_open = true;
	int a = 86;
	int b = a;
	if(a*b>0){
    	unsigned long jnow = READ_ONCE(jiffies);
	}
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}",0,1,3,0.31,Insert
3430,"static bool check_underflow(const struct arpt_entry *e)
{
	const struct xt_entry_target *t;
	unsigned int verdict;
	if (!unconditional(e))
		return false;
	t = arpt_get_target_c(e);
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}","static bool check_underflow(const struct arpt_entry *e)
{
	const struct xt_entry_target *t;
	AVPacket * pk;
	AVFormatContext *s;
	unsigned char rb[5];
	AVCodecParameters *par = s->streams[stream_index]->codecpar;
	AVIOContext *b_9     = s->b_9;
	const int stream_index =  pk->stream_index;
	avi_stream2fourcc(rb, stream_index, par->codec_type);
	avio_write(b_9, rb, 4);
	unsigned int verdict;
	if (!unconditional(e))
		return false;
	t = arpt_get_target_c(e);
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	int a = 2;
	int b = 3;
	while (a != b) {
    	return verdict == NF_DROP || verdict == NF_ACCEPT;
    	b = a;
	}
}",0,1,14,0.42,Insert
3431,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct edgeport_serial *serial;
    	u8 *data;
    	struct device *dev = &serial->serial->dev->dev;
    	struct device *dev = &serial->serial->dev->dev;
    	int status;
    	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
    			dev_dbg(dev, ""%s - ROM_TYPE_III
    	"", __func__);
    			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
    			goto out;
    	}
    	encoder->protected_->bits_per_sample = value;
	strcpy(str, ""a"");
	}
	return true;
}",0,1,11,0.3,Insert
3432,"static inline int pud_devmap(pud_t pud)
{
	return 0;
}","static inline int pud_devmap(pud_t pud)
{
	int a = 2;
	int b = 3;
	uint64_t glms;
	unsigned k, b_10, err, C;
	unsigned k, b_10, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_10 = ctz64(glms);
	while (a < b) {
    	return 0;
    	b = a;
	}
}",0,1,3,0.18,Insert
3433,,,,,,,
3435,,,,,,,
3438,,,,,,,
3443,,,,,,,
3446,,,,,,,
3447,"void tcmi_box_del(GF_Box *s)
{
	GF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;
	if (ptr->font) gf_free(ptr->font);
	gf_free(s);
}","void tcmi_box_del(GF_Box *s)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	GF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;
	}
	if (ptr->font) gf_free(ptr->font);
	struct tty_struct *reader;
	struct awm *awm = reader->driver_data;
	struct acm_wb *sth;
	struct awm *awm = reader->driver_data;
	if (sth->len == awm->writesize) {
			acm_tty_flush_chars(reader);
			goto overflow;
	}
	gf_free(s);
}",0,1,19,0.3,Insert
3448,"static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;
    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item) {
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);          
        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;
    return (1);
}","static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;
    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item) {
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);
            GstDateTime *dt, *dt2;
            gst_date_time_unref (dt);
            dt = gst_date_time_new_from_iso8601_string (""2010-00-30"");
            fail_unless (gst_date_time_get_year (dt) == 2010);
            fail_unless (!gst_date_time_has_month (dt));
            fail_unless (!gst_date_time_has_day (dt));          
        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;
    return (1);
}",1,0,23,0.43,Insert
3449,"rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct rtadv_prefix *rprefix;
  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}","rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  PutBitContext pb, pb2;
  JLSState *state;
  int i, size, ure;
  PutBitContext pb, pb2;
  ls_store_lse(state, &pb);
  put_bits(&pb2, 7, 0);
  size = put_bits_count(&pb2);
  flush_put_bits(&pb2);
  avpriv_align_put_bits(&pb);
  struct listnode *node;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      struct rtadv_prefix *rprefix;
  strcpy(str, ""a"");
  }
  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}",0,1,7,0.32,Insert
3453,"int is_regular_file(struct dirent *dent, const char *dirname)
{
    int dir_fd = open(dirname, O_DIRECTORY);
    if (dir_fd < 0)
        return 0;
    int r = is_regular_file_at(dent, dir_fd);
    close(dir_fd);
    return r;
}","int is_regular_file(struct dirent *dent, const char *dirname)
{
    int dir_fd = open(dirname, O_DIRECTORY);
    if (dir_fd < 0)
        return 0;
    int a = 2;
    int b = 3;
    if (a != b) {
        int r = is_regular_file_at(dent, dir_fd);
    }
    close(dir_fd);
    return r;
}",0,1,1,0.05,Replace
3455,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {
	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;
	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;
	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif
	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);
        return buf;
}","ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {
	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;
	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;
	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif
	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return buf;
        strcpy(str, ""a"");
        }
}",0,1,1,0.14,Replace
3456,"Item *Item_bool::neg_transformer(THD *thd)
{
  value= !value;
  name= 0;
  return this;
}","Item *Item_bool::neg_transformer(THD *thd)
{
  value= !value;
  name= 0;
  Image *image;
  const LayerInfo* layer_info;
  const size_t url;
  MagickOffsetType
      offset;
  MagickStatusType
      status;
  if (status == MagickFalse)
      SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
  int a = 2;
  int b = 3;
  if (a != b) {
      return this;
  }
}",0,1,9,0.2,Insert
3457,,,,,,,
3459,"int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)
{
    const char* cLabelFld;
    char Type[256], Label[256];
    int nTable;
    _cmsAssert(hIT8 != NULL);
    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";
    if (cField == NULL)
            cField = ""LABEL"";
    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);
    if (!cLabelFld) return -1;
    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &nTable, Type) != 3)
            return -1;
    if (ExpectedType != NULL && *ExpectedType == 0)
        ExpectedType = NULL;
    if (ExpectedType) {
        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;
    }
    return cmsIT8SetTable(hIT8, nTable);
}","int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)
{
    const char* cLabelFld;
    char Type[256], Label[256];
    int nTable;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        _cmsAssert(hIT8 != NULL);
    }
    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";
    if (cField == NULL)
            cField = ""LABEL"";
    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);
    if (!cLabelFld) return -1;
    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &nTable, Type) != 3)
            return -1;
    if (ExpectedType != NULL && *ExpectedType == 0)
        ExpectedType = NULL;
    if (ExpectedType) {
        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;
    }
    return cmsIT8SetTable(hIT8, nTable);
}",0,1,7,0.15,Replace
3464,,,,,,,
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();
	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	const struct sun4d_hwdef *hawdecl;
	int ret_8;
	char data[1024];
	snprintf(data, sizeof(data), ""%s/%s"", bios_dir, bios_name);
	ret_8 = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
	int a = 2;
	int b = 2;
	while (a == b) {
    	State *state;
    	b += 1;
	}
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();
	return ret;
}",0,1,16,0.38,Insert
3467,,,,,,,
3468,,,,,,,
3469,,,,,,,
3475,"static int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)
{
	int status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,
				    &data->arg.seq_args, &data->res.seq_res, 1);
	if (status == 0) {
		update_changeattr(dir, &data->res.dir_cinfo);
		nfs_post_op_update_inode(dir, data->res.dir_fattr);
		status = nfs_instantiate(dentry, data->res.fh, data->res.fattr);
	}
	return status;
}","static int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)
{
	int status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,
				    &data->arg.seq_args, &data->res.seq_res, 1);
	if (status == 0) {
		update_changeattr(dir, &data->res.dir_cinfo);
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		nfs_post_op_update_inode(dir, data->res.dir_fattr);
		}
		status = nfs_instantiate(dentry, data->res.fh, data->res.fattr);
	}
	return status;
}",0,1,1,0.07,Replace
3476,"static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;
	lockdep_assert_held(&ctx->mutex);
	event_function_call(event, __perf_remove_from_context, (void *)flags);
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}","static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;
	lockdep_assert_held(&ctx->mutex);
	event_function_call(event, __perf_remove_from_context, (void *)flags);
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		int a = 76;
		int b = a;
		if(a*b>0){
    		VdpDecoderProfile profile;
    		AVCodecContext *AVcas;
    		VdpDecoderQueryCapabilities *decoder_query_caps;
    		uint32_t max_level, max_mb, max_width, max_height;
    		uint32_t max_level, max_mb, max_width, max_height;
    		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    		uint32_t max_level, max_mb, max_width, max_height;
    		uint32_t max_level, max_mb, max_width, max_height;
    		VdpBool supported;
    		VdpChromaType type;
    		VdpStatus status;
    		status = surface_query_caps(hdtx->device, type, &supported,
    		                                &max_width, &max_height);
    		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    		                                &max_mb, &max_width, &max_height);
    		raw_spin_unlock_irq(&ctx->lock);
		}
	}
}",0,1,16,0.43,Insert
3477,,,,,,,
3480,"BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}
	freewbmp(wbmp);
}","BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	int x, y, pos;
    	b = a;
	}
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}
	struct ip_options *mot_9 = inet_rsk_9(rss_4)->mot_9;
	struct rtable *rt_10;
	if (mot_9 && mot_9->is_strictroute && rt_10->rt_dst != rt_10->rt_gateway)
			goto route_err;
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
			struct ip_options *mot = inet_rsk(rss)->mot;
			struct rtable *rt;
			if (mot && mot->is_strictroute && rt->rt_dst != rt->rt_gateway)
					goto route_err;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}
	freewbmp(wbmp);
}",1,0,178,1.47,Insert
3481,"void DispatcherThread::OnNotify()
{
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void DispatcherThread::OnNotify()
{
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	const struct sun4d_hwdef *hawdecl;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	unsigned int i_10;
	for (i_10 = 0; i_10 < MAX_IOBITS; i_10++)
	        if (hawdecl->iounit_bases[i_10] != (target_phys_addr_t)-1)
	            ioulits[i_10] = iommu_init(hawdecl->iounit_bases[i_10],
	                                    hawdecl->iounit_version,
	                                    sbi_arqu[hawdecl->me_irq]);
	this->UnlockQueue();
}",0,1,14,0.33,Insert
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return sid;
}","PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	int a = 2;
	int b = 3;
	while (a < b) {
    	PS_MM_DATA;
    	b = a;
	}
	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return sid;
}",1,0,5,0.07,Replace
3484,,,,,,,
3486,,,,,,,
3488,,,,,,,
3492,,,,,,,
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);
    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        assert(type < BDRV_MAX_IOTYPE);
    strcpy(str, ""a"");
    }
    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}",0,1,7,0.09,Replace
3494,"gss_mech_initialize(void)
{
    return &krb5_mechanism;
}","gss_mech_initialize(void)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return &krb5_mechanism;
    }
}",0,1,2,0.03,Replace
3495,"madvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,
		unsigned long start, unsigned long end, int behavior)
{
	switch (behavior) {
	case MADV_REMOVE:
		return madvise_remove(vma, prev, start, end);
	case MADV_WILLNEED:
		return madvise_willneed(vma, prev, start, end);
	case MADV_COLD:
		return madvise_cold(vma, prev, start, end);
	case MADV_PAGEOUT:
		return madvise_pageout(vma, prev, start, end);
	case MADV_FREE:
	case MADV_DONTNEED:
		return madvise_dontneed_free(vma, prev, start, end, behavior);
	default:
		return madvise_behavior(vma, prev, start, end, behavior);
	}
}","madvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,
		unsigned long start, unsigned long end, int behavior)
{
	switch (behavior) {
	case MADV_REMOVE:
		return madvise_remove(vma, prev, start, end);
	case MADV_WILLNEED:
		return madvise_willneed(vma, prev, start, end);
	case MADV_COLD:
		return madvise_cold(vma, prev, start, end);
	case MADV_PAGEOUT:
		return madvise_pageout(vma, prev, start, end);
	case MADV_FREE:
	case MADV_DONTNEED:
		return madvise_dontneed_free(vma, prev, start, end, behavior);
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		size_t
		    length;
		table->width=StringToUnsignedLong(attribute);
		table->height=StringToUnsignedLong(attribute);
		table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
		length=(size_t) table->width*table->height;
		table->levels=(unsigned int *) AcquireQuantumMemory(length,
		    sizeof(*table->levels));
	default:
		int a = 2;
		int b = 3;
		while (a < b) {
    		return madvise_behavior(vma, prev, start, end, behavior);
    		b = a;
		}
	}
}",0,1,14,0.69,Insert
3497,"  inline CImg<_cimg_Tfloat> pseudoinvert(const CImg<T>& instance, const bool use_LU=false) {
    return instance.get_pseudoinvert(use_LU);
  }","  inline CImg<_cimg_Tfloat> pseudoinvert(const CImg<T>& instance, const bool use_LU=false) {
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    return instance.get_pseudoinvert(use_LU);
  }",0,1,2,0.1,Insert
3498,"void mddev_unlock(struct mddev *mddev)
{
	if (mddev->to_remove) {
		struct attribute_group *to_remove = mddev->to_remove;
		mddev->to_remove = NULL;
		mddev->sysfs_active = 1;
		mutex_unlock(&mddev->reconfig_mutex);
		if (mddev->kobj.sd) {
			if (to_remove != &md_redundancy_group)
				sysfs_remove_group(&mddev->kobj, to_remove);
			if (mddev->pers == NULL ||
			    mddev->pers->sync_request == NULL) {
				sysfs_remove_group(&mddev->kobj, &md_redundancy_group);
				if (mddev->sysfs_action)
					sysfs_put(mddev->sysfs_action);
				mddev->sysfs_action = NULL;
			}
		}
		mddev->sysfs_active = 0;
	} else
		mutex_unlock(&mddev->reconfig_mutex);
	spin_lock(&pers_lock);
	md_wakeup_thread(mddev->thread);
	spin_unlock(&pers_lock);
}","void mddev_unlock(struct mddev *mddev)
{
	if (mddev->to_remove) {
		struct attribute_group *to_remove = mddev->to_remove;
		mddev->to_remove = NULL;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		mddev->sysfs_active = 1;
		strcpy(str, ""a"");
		}
		mutex_unlock(&mddev->reconfig_mutex);
		if (mddev->kobj.sd) {
			if (to_remove != &md_redundancy_group)
				sysfs_remove_group(&mddev->kobj, to_remove);
			if (mddev->pers == NULL ||
			    mddev->pers->sync_request == NULL) {
				sysfs_remove_group(&mddev->kobj, &md_redundancy_group);
				if (mddev->sysfs_action)
					sysfs_put(mddev->sysfs_action);
				mddev->sysfs_action = NULL;
			}
		}
		mddev->sysfs_active = 0;
	} else
		mutex_unlock(&mddev->reconfig_mutex);
	spin_lock(&pers_lock);
	md_wakeup_thread(mddev->thread);
	spin_unlock(&pers_lock);
}",0,1,10,0.19,Replace
3500,,,,,,,
3501,"bool CTransaction::DisconnectInputs(CTxDB& txdb)
{
    if (!IsCoinBase())
    {
        BOOST_FOREACH(const CTxIn& txin, vin)
        {
            COutPoint prevout = txin.prevout;
            CTxIndex txindex;
            if (!txdb.ReadTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : ReadTxIndex failed"");
            if (prevout.n >= txindex.vSpent.size())
                return error(""DisconnectInputs() : prevout.n out of range"");
            txindex.vSpent[prevout.n].SetNull();
            if (!txdb.UpdateTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : UpdateTxIndex failed"");
        }
    }
    if (!txdb.EraseTxIndex(*this))
        return error(""DisconnectInputs() : EraseTxPos failed"");
    return true;
}","bool CTransaction::DisconnectInputs(CTxDB& txdb)
{
    if (!IsCoinBase())
    {
        BOOST_FOREACH(const CTxIn& txin, vin)
        {
            COutPoint prevout = txin.prevout;
            CTxIndex txindex;
            if (!txdb.ReadTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : ReadTxIndex failed"");
            if (prevout.n >= txindex.vSpent.size())
                return error(""DisconnectInputs() : prevout.n out of range"");
            int a = 2;
            int b = 3;
            while (a != b) {
                txindex.vSpent[prevout.n].SetNull();
                b = a;
            }
            if (!txdb.UpdateTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : UpdateTxIndex failed"");
        }
    }
    if (!txdb.EraseTxIndex(*this))
        return error(""DisconnectInputs() : EraseTxPos failed"");
    return true;
}",1,0,1,0.11,Replace
3504,"void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
}","void HttpRequestEntry::resetHttpHeaderProcessor()
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      MachineState *machine;
      sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);
      sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
      if (smc->dr_lmb_enabled) {
              spapr_create_lmb_dr_connectors(spapr);
      }
      proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
  strcpy(str, ""a"");
  }
}",0,1,3,0.17,Insert
3505,"static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];
	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;
	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;
	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
	return rdev_update_ft_ies(rdev, dev, &ft_params);
}","static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];
	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;
	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;
	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
	int a = 2;
	int b = 3;
	while (a < b) {
    	DisasContext *qs;
    	uint32_t ksns;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	unsigned int coll, order, err, resp, coll, p, nzcv;
    	order = extract32(ksns, 22, 2);
    	handle_fp_compare(qs, order, coll, err, false, p);
    	return rdev_update_ft_ies(rdev, dev, &ft_params);
    	b = a;
	}
}",0,1,21,0.51,Insert
3506,,,,,,,
3507,,,,,,,
3509,"static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}","static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  int a = 2;
  int b = 2;
  while (a == b) {
      gchar *str, *str2;
      GstDateTime *dt, *dt2;
      GstDateTime *dt, *dt2;
      fail_unless (gst_date_time_get_day (dt) == gst_date_time_get_day (dt2));
      fail_unless (date_times_are_equal (dt, dt2));
      str2 = gst_date_time_to_iso8601_string (dt2);
      gst_date_time_unref (dt2);
      gst_date_time_unref (dt);
      *quantum|=(size_t) (*p++ << 16);
      b += 1;
  }
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}",1,0,285,1.7,Insert
3513,"void PngImg::InitStorage_() {
    rowPtrs_.resize(info_.height, nullptr);
    data_ = new png_byte[info_.height * info_.rowbytes];
    for(size_t i = 0; i < info_.height; ++i) {
        rowPtrs_[i] = data_ + i * info_.rowbytes;
    }
}","void PngImg::InitStorage_() {
    rowPtrs_.resize(info_.height, nullptr);
    data_ = new png_byte[info_.height * info_.rowbytes];
    for(size_t i = 0; i < info_.height; ++i) {
        char str1[] = ""Constant"";
        DCTELEM *type;
        DCTELEM *type_9;
        int i_10;
        DCTELEM zip_3[64];
        for (i_10 = 0; i_10 < 8; i_10++)
                bink_idct_col_3(&zip_3[i_10], &type_9[i_10]);
        int i_3;
        DCTELEM zip[64];
        for (i_3 = 0; i_3 < 8; i_3++)
                bink_idct_col(&zip[i_3], &type[i_3]);
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            rowPtrs_[i] = data_ + i * info_.rowbytes;
        }
        Packet *wp;
        TcpSession *ssn = (TcpSession *)wp->flow->protoctx;
        DEBUG_ASSERT_FLOW_LOCKED(wp->flow);
        SCLogDebug(""p->pcap_cnt %""PRIu64, wp->pcap_cnt);
    }
}",1,0,158,1.07,Insert
3514,"char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}","char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	void *ptr_10 = NULL;
    	unsigned long val_4;
    	if (val_4) {
    			phys_addr_t phys_8 = gen_pool_virt_to_phys_3(atomic_pool_4, val_4);
    			*ret_page_5 = phys_to_page_8(phys_8);
    			ptr_10 = (void *)val_4;
    			if (flags_2 & __GFP_ZERO_5)
    				memset_5(ptr_10, 0, size_1);
    	}
    	u32 size, size64;
    	b = a;
	}
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	void *ptr = NULL;
	unsigned long val;
	if (val) {
			phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
			*ret_page = phys_to_page(phys);
			ptr = (void *)val;
			if (flags & __GFP_ZERO)
				memset(ptr, 0, size_3);
	}
	if (!sc) return NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}",1,0,1139,6.27,Insert
3517,"bool LOGGER::flush_general_log()
{
  logger.lock_exclusive();
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();
  logger.unlock();
  return 0;
}","bool LOGGER::flush_general_log()
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      logger.lock_exclusive();
  strcpy(str, ""a"");
  }
  struct sock *Lister;
  struct vsock_sock *vcatel;
  vcatel = vsock_sk(Lister);
  sock_hold(Lister);
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();
  logger.unlock();
  return 0;
}",0,1,7,0.19,Insert
3518,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;
	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;
	net->ipv4.peers = NULL;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	inetpeer_invalidate_tree(bp);
	}
	WS_SFTP_BUFFER* buffer;
	word32 value;
	if (buffer != NULL) {
	        c32toa(value, buffer->data + buffer->idx);
	        buffer->idx += UINT32_SZ;
	}
	kfree(bp);
}",0,1,11,0.23,Insert
3519,"void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *r) {
    assert(r);
    if(r->record_browser_a)
        avahi_s_record_browser_start_query(r->record_browser_a);
    if(r->record_browser_aaaa)
        avahi_s_record_browser_start_query(r->record_browser_aaaa);
}","void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *r) {
    int a = 2;
    int b = 2;
    while (a == b) {
        assert(r);
        b += 1;
    }
    if(r->record_browser_a)
        avahi_s_record_browser_start_query(r->record_browser_a);
        int size;
        void *opaque;
        int64_t slice;
        const uint8_t *buf;
        QEMUFileBdrv *s = opaque;
        bdrv_pwrite(s->bs, s->base_offset + slice, buf, size);
    if(r->record_browser_aaaa)
        avahi_s_record_browser_start_query(r->record_browser_aaaa);
}",0,1,16,0.33,Insert
3521,,,,,,,
3522,"const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }","const char *
http_status_str (enum http_status s)
{
  switch (s) {
V9fsPath *fs_path;
FsContext *FS_path;
int fd, ret;
struct handle_data *parent = (struct handle_data *)FS_path->private;
fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    int a = 2;
    int b = 3;
    if (a != b) {
        default: return ""<unknown>"";
    }
  }",0,1,5,0.25,Insert
3523,"static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;
	return queue_find(service->chrcs, match_chrc, path);
}","static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;
	int a_1 = 2;
	int b_1 = 2;
	while (a_1 == b_1) {
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	const char
    	    *attribute,
    	    *content;
    	size_t
    	    length;
    	table->width=StringToUnsignedLong(attribute);
    	table->height=StringToUnsignedLong(attribute);
    	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    	length=(size_t) table->width*table->height;
    	table->levels=(unsigned int *) AcquireQuantumMemory(length,
    	    sizeof(*table->levels));
    	return queue_find(service->chrcs, match_chrc, path);
    	b_1 += 1;
	}
}",0,1,9,0.25,Insert
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;
	return 0;
}","static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	int a = 2;
	int b = 2;
	while (a == b) {
    	val = qib_user_sdma_complete_counter(pq);
    	b += 1;
	}
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
	                        hawdecl->nvram_size, 8);
	slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
	                          sbi_cpu_arq, smp_cpus);
	slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
	                              nographic, ESCC_CLOCK, 1);
	if (put_user(val, completep))
		return -EFAULT;
	return 0;
}",0,1,14,0.44,Insert
3525,"static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	int ret;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, NSEC_PER_MSEC);
	ret = sprintf(buf, ""%llu\n"", tmp);
	return ret;
}","static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	int ret;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, NSEC_PER_MSEC);
	int a = 2;
	u16 type;
	u16 type_2;
	hfsplus_cat_entry tmp_4;
	type_2 = be16_to_cpu_2(tmp_4.type_2);
	hfsplus_cat_entry tmp_9;
	type = be16_to_cpu(tmp_9.type);
	int b = 3;
	if (a != b) {
    	ret = sprintf(buf, ""%llu\n"", tmp);
	}
	return ret;
}",1,0,41,0.47,Insert
3528,,,,,,,
3530,"GF_Box *segr_New()
{
	ISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);
	return (GF_Box *)tmp;","GF_Box *segr_New()
{
	int a = 81;
	int b = a;
	if(a*b>0){
    	ISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpDecoderCreate *create;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpBool supported;
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
	}
	return (GF_Box *)tmp;",0,1,9,0.21,Insert
3531,"MagickExport void ConvertRGBToHSL(const Quantum red,const Quantum green,
  const Quantum blue,double *hue,double *saturation,double *lightness)
{
  double
    c,
    max,
    min;
  assert(hue != (double *) NULL);
  assert(saturation != (double *) NULL);
  assert(lightness != (double *) NULL);
  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,
    QuantumScale*blue));
  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,
    QuantumScale*blue));
  c=max-min;
  *lightness=(max+min)/2.0;
  if (c <= 0.0)
    {
      *hue=0.0;
      *saturation=0.0;
      return;
    }
  if (fabs(max-QuantumScale*red) < MagickEpsilon)
    {
      *hue=(QuantumScale*green-QuantumScale*blue)/c;
      if ((QuantumScale*green) < (QuantumScale*blue))
        *hue+=6.0;
    }
  else
    if (fabs(max-QuantumScale*green) < MagickEpsilon)
      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;
    else
      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;
  *hue*=60.0/360.0;
  if (*lightness <= 0.5)
    *saturation=c/(2.0*(*lightness));
  else
    *saturation=c/(2.0-2.0*(*lightness));
}","MagickExport void ConvertRGBToHSL(const Quantum red,const Quantum green,
  const Quantum blue,double *hue,double *saturation,double *lightness)
{
  double
    c,
    max,
    min;
  assert(hue != (double *) NULL);
  assert(saturation != (double *) NULL);
  assert(lightness != (double *) NULL);
  double grid[4];
  double vec[4];
  double grid_3[4];
  double vec_9[4];
  double mat_5[4][4];
  for (int i_4 = 0; i_4 < 4; ++i_4) {
          double res_1 = 0;
          for (int j_8 = 0; j_8 < 4; ++j_8)
              res_1 += mat_5[i_4][j_8] * vec_9[j_8];
          grid_3[i_4] = FFMAX_7(0, res_1);
  }
  double mat[4][4];
  for (int i = 0; i < 4; ++i) {
          double res = 0;
          for (int j = 0; j < 4; ++j)
              res += mat[i][j] * vec[j];
          grid[i] = FFMAX(0, res);
  }
  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,
    QuantumScale*blue));
  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,
    QuantumScale*blue));
  c=max-min;
  *lightness=(max+min)/2.0;
  Select *p;
  ExprList *sOrderby;
  sOrderby = p->sOrderby;
  if (c <= 0.0)
    {
      *hue=0.0;
      *saturation=0.0;
      int a = 2;
      int b = 2;
      if (a == b) {
          return;
      }
    }
  if (fabs(max-QuantumScale*red) < MagickEpsilon)
    {
      *hue=(QuantumScale*green-QuantumScale*blue)/c;
      if ((QuantumScale*green) < (QuantumScale*blue))
        *hue+=6.0;
    }
  else
    if (fabs(max-QuantumScale*green) < MagickEpsilon)
      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;
    else
      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;
  *hue*=60.0/360.0;
  if (*lightness <= 0.5)
    *saturation=c/(2.0*(*lightness));
  else
    *saturation=c/(2.0-2.0*(*lightness));
}",1,0,89,1.62,Insert
3533,"static void __io_queue_sqe(struct io_kiocb *req)
{
	struct io_kiocb *linked_timeout = io_prep_linked_timeout(req);
	struct io_kiocb *nxt = NULL;
	int ret;
	ret = io_issue_sqe(req, &nxt, true);
	if (nxt)
		io_queue_async_work(nxt);
	if (ret == -EAGAIN && (!(req->flags & REQ_F_NOWAIT) ||
	    (req->flags & REQ_F_MUST_PUNT))) {
		struct sqe_submit *s = &req->submit;
		struct io_uring_sqe *sqe_copy;
		sqe_copy = kmemdup(s->sqe, sizeof(*sqe_copy), GFP_KERNEL);
		if (!sqe_copy)
			goto err;
		s->sqe = sqe_copy;
		req->flags |= REQ_F_FREE_SQE;
		if (req->work.flags & IO_WQ_WORK_NEEDS_FILES) {
			ret = io_grab_files(req);
			if (ret)
				goto err;
		}
		io_queue_async_work(req);
		return;
	}
err:
	io_put_req(req);
	if (linked_timeout) {
		if (!ret)
			io_queue_linked_timeout(linked_timeout);
		else
			io_put_req(linked_timeout);
	}
	if (ret) {
		io_cqring_add_event(req, ret);
		if (req->flags & REQ_F_LINK)
			req->flags |= REQ_F_FAIL_LINK;
		io_put_req(req);
	}
}","static void __io_queue_sqe(struct io_kiocb *req)
{
	struct io_kiocb *linked_timeout = io_prep_linked_timeout(req);
	struct io_kiocb *nxt = NULL;
	int ret;
	ret = io_issue_sqe(req, &nxt, true);
	if (nxt)
		io_queue_async_work(nxt);
	if (ret == -EAGAIN && (!(req->flags & REQ_F_NOWAIT) ||
	    (req->flags & REQ_F_MUST_PUNT))) {
		struct sqe_submit *s = &req->submit;
		struct io_uring_sqe *sqe_copy;
		sqe_copy = kmemdup(s->sqe, sizeof(*sqe_copy), GFP_KERNEL);
		if (!sqe_copy)
			goto err;
		s->sqe = sqe_copy;
		req->flags |= REQ_F_FREE_SQE;
		if (req->work.flags & IO_WQ_WORK_NEEDS_FILES) {
			ret = io_grab_files(req);
			if (ret)
				goto err;
		}
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		io_queue_async_work(req);
    		struct usbdevfs_connectinfo ci;
    		USBHostDevice *dev = NULL;
    		int fd = -1, ret_1;
    		int fd = -1, ret_1;
    		ret_1 = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);
    		ret_1 = usb_linux_update_endp_table(dev);
		}
		return;
	}
err:
	io_put_req(req);
	if (linked_timeout) {
		if (!ret)
			io_queue_linked_timeout(linked_timeout);
		else
			io_put_req(linked_timeout);
	}
	if (ret) {
		io_cqring_add_event(req, ret);
		if (req->flags & REQ_F_LINK)
			req->flags |= REQ_F_FAIL_LINK;
		io_put_req(req);
	}
}",0,1,24,0.86,Insert
3534,,,,,,,
3539,,,,,,,
3542,,,,,,,
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    return OK;
}","static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    int a = 2;
    int b = 2;
    const v8::PropertyCallbackInfo<v8::Value>& py;
    from(py.Holder()->CreationContext());
    v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
    while (a == b) {
        return OK;
        b += 1;
    }
}",0,1,8,0.29,Insert
3546,"static void parse_content_range(URLContext *h, const char *p)
{
    HTTPContext *s = h->priv_data;
    const char *slash;
    if (!strncmp(p, ""bytes "", 6)) {
        p     += 6;
        s->off = strtoll(p, NULL, 10);
        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
    }
    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
        h->is_streamed = 0;  
}","static void parse_content_range(URLContext *h, const char *p)
{
    HTTPContext *s = h->priv_data;
    const char *slash;
    if (!strncmp(p, ""bytes "", 6)) {
        p     += 6;
        int a = 2;
        AVCodecContext *avctx;
        AVCodecContext *avctx_5;
        int i_7;
        Vp3DecodeContext *s_3 = avctx_5->priv_data;
        for (i_7 = 0; i_7 < 16; i_7++) {
                free_vlc_10(&s_3->dc_vlc[i_7]);
                free_vlc_10(&s_3->ac_vlc_1[i_7]);
                free_vlc_10(&s_3->ac_vlc_2[i_7]);
                free_vlc_10(&s_3->ac_vlc_3[i_7]);
                free_vlc_10(&s_3->ac_vlc_4[i_7]);
        }
        int i;
        Vp3DecodeContext *s_6 = avctx->priv_data;
        for (i = 0; i < 16; i++) {
                free_vlc(&s_6->dc_vlc[i]);
                free_vlc(&s_6->ac_vlc_1[i]);
                free_vlc(&s_6->ac_vlc_2[i]);
                free_vlc(&s_6->ac_vlc_3[i]);
                free_vlc(&s_6->ac_vlc_4[i]);
        }
        int b = 2;
        while (a == b) {
            s->off = strtoll(p, NULL, 10);
            b += 1;
        }
        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
    }
    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
        h->is_streamed = 0;  
}",1,0,103,0.93,Insert
3547,,,,,,,
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
    SubchDev *sch;
    sch->thinint_active = false;
    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);
    sch->ccw_cb = virtio_ccw_cb;
    memset(&sch->id, 0, sizeof(SenseId));
    sch->id.reserved = 0xff;
  }
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return res;
  strcpy(str, ""a"");
  }
}",0,1,18,0.47,Insert
3552,"struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);
	if (!enc10)
		return NULL;
	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);
	return &enc10->base;
}","struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
	CPUState *cpu;
	KVMState *b_4 = kvm_state;
	KVMState *b_4 = kvm_state;
	cpu->kvm_state = b_4;
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);
	if (!enc10)
		return NULL;
	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);
	int a = 2;
	int b = 2;
	while (a == b) {
    	return &enc10->base;
    	b += 1;
	}
}",0,1,3,0.33,Insert
3554,,,,,,,
3558,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else {  
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	const AVFrame *capt;
	const AVFrame *const p = capt;
	uint8_t *last = NULL;
	uint8_t *zero = NULL;
	zero = last = av_mallocz(p->linesize[0]);
	av_freep(&zero);
	av_freep(&zero);
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		int a = 2;
		int b = 3;
		while (a != b) {
    		mid = (left + right) >> 1;
    		b = a;
		}
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else {  
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}",0,1,10,0.99,Insert
3559,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;
	perf_event_header__init_id(&throttle_event.header, &sample, event);
	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;
	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int a = 2;
	int b = 2;
	while (a == b) {
    	int ret;
    	b += 1;
	}
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;
	perf_event_header__init_id(&throttle_event.header, &sample, event);
	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;
	perf_output_put(&handle, throttle_event);
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	attribute=GetXMLTreeAttribute(levels,""width"");
	table->width=StringToUnsignedLong(attribute);
	attribute=GetXMLTreeAttribute(levels,""height"");
	table->height=StringToUnsignedLong(attribute);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}",0,1,23,0.63,Insert
3561,,,,,,,
3564,,,,,,,
3565,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          res = link (link_target, link_name);
      strcpy(str, ""a"");
      }
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}",0,1,3,0.12,Replace
3567,,,,,,,
3569,"static void change_pageblock_range(struct page *pageblock_page,
					int start_order, int migratetype)
{
	int nr_pageblocks = 1 << (start_order - pageblock_order);
	while (nr_pageblocks--) {
		set_pageblock_migratetype(pageblock_page, migratetype);
		pageblock_page += pageblock_nr_pages;
	}
}","static void change_pageblock_range(struct page *pageblock_page,
					int start_order, int migratetype)
{
	int nr_pageblocks = 1 << (start_order - pageblock_order);
	while (nr_pageblocks--) {
		int a = 71;
		int b = a;
		if(a*b>0){
    		set_pageblock_migratetype(pageblock_page, migratetype);
		}
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		size_t
		    length;
		table->width=StringToUnsignedLong(attribute);
		table->height=StringToUnsignedLong(attribute);
		table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
		length=(size_t) table->width*table->height;
		table->levels=(unsigned int *) AcquireQuantumMemory(length,
		    sizeof(*table->levels));
		pageblock_page += pageblock_nr_pages;
	}
}",0,1,12,0.27,Insert
3570,,,,,,,
3571,"file_check_str(gerb_file_t *fd, const char *str)
{
    char c;
    for (int i = 0; str[i] != '\0'; i++) {
	c = gerb_fgetc(fd);
	if (c == EOF)
	    return -1;
	if (c != str[i]) {
	    do {
		gerb_ungetc(fd);
	    } while (i--);
	    return 0;
	}
    }
    return 1;
}","file_check_str(gerb_file_t *fd, const char *str)
{
    char c;
    for (int i = 0; str[i] != '\0'; i++) {
	c = gerb_fgetc(fd);
	if (c == EOF)
	    return -1;
	if (c != str[i]) {
	    do {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		gerb_ungetc(fd);
		}
	    } while (i--);
	    return 0;
	}
    }
    return 1;
}",0,1,5,0.11,Replace
3573,,,,,,,
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        long pid;
    }
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}",0,1,2,0.12,Replace
3577,"        compression::algorithm compression_algorithm()
        {
            return comp_algorithm_;
        }","        compression::algorithm compression_algorithm()
        {
            int a = 2;
            int b = 3;
            while (a < b) {
                V9fsPath *fs_path;
                FsContext *FS_path;
                int fd, ret;
                struct handle_data *parent = (struct handle_data *)FS_path->private;
                fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
                return comp_algorithm_;
                b = a;
            }
        }",0,1,3,0.17,Insert
3579,,,,,,,
3582,,,,,,,
3584,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);
  redis->hashDel(key, member);
  return(CONST_LUA_OK);
}","static int ntop_del_hash_redis(lua_State* vm) {
  Unit *uci;
  const char *key_5;
  assert(uci);
  (void) hashmap_remove_value(uci->manager->watch_bus, key_5, uci);
  uci->match_bus_slot = sd_bus_slot_unref(uci->match_bus_slot);
  char *key, *member;
  Redis *redis = ntop->getRedis();
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);
  redis->hashDel(key, member);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      return(CONST_LUA_OK);
  }
}",0,1,11,0.4,Insert
3585,"const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)
{
  return state->lineinfo + row;
}","const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)
{
  struct edgeport_serial *serial;
  u8 *data;
  struct device *dev = &serial->serial->dev->dev;
  struct device *dev = &serial->serial->dev->dev;
  int status;
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
  dev_dbg(dev, ""%s - Unknown
  "", __func__);
  int a = 2;
  int b = 3;
  if (a != b) {
      return state->lineinfo + row;
  }
}",0,1,9,0.21,Insert
3586,"static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	return 0;
}","static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		int a = 2;
		int b = 3;
		while (a != b) {
    		set_tsk_thread_flag(t, TIF_SIGPENDING);
    		b = a;
    		DisplayState *ds;
    		const struct sun4d_hwdef *hawdecl;
    		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
    		        *espdma_iraque, *ledma_arquest;
    		ram_addr_t gram_size, prom_reset, tcx64off;
    		tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
    		             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    		escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
    		              serial_hds[0], ESCC_CLOCK, 1);
		}
		return 1;
	}
	return 0;
}",0,1,16,0.37,Insert
3588,"static int cp2112_gpio_get_all(struct gpio_chip *chip)
{
	struct cp2112_device *dev = gpiochip_get_data(chip);
	struct hid_device *hdev = dev->hdev;
	u8 *buf = dev->in_out_buffer;
	unsigned long flags;
	int ret;
	spin_lock_irqsave(&dev->lock, flags);
	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (ret != CP2112_GPIO_GET_LENGTH) {
		hid_err(hdev, ""error requesting GPIO values: %d\n"", ret);
		ret = ret < 0 ? ret : -EIO;
		goto exit;
	}
	ret = buf[1];
exit:
	spin_unlock_irqrestore(&dev->lock, flags);
	return ret;
}","static int cp2112_gpio_get_all(struct gpio_chip *chip)
{
	struct cp2112_device *dev = gpiochip_get_data(chip);
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct hid_device *hdev = dev->hdev;
    	b = a;
	}
	u8 *buf = dev->in_out_buffer;
	unsigned long flags;
	int ret;
	spin_lock_irqsave(&dev->lock, flags);
	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (ret != CP2112_GPIO_GET_LENGTH) {
		hid_err(hdev, ""error requesting GPIO values: %d\n"", ret);
		ret = ret < 0 ? ret : -EIO;
		goto exit;
	}
	ret = buf[1];
exit:
	spin_unlock_irqrestore(&dev->lock, flags);
	return ret;
}",1,0,13,0.18,Replace
3590,"    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8) {
      CImg<T> r(9,1);
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8;
      return r;
    }","    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8) {
      CPUState *env;
      const sigset_t *sigset;
      struct kvm_signal_mask * sigmak;
      int r_8;
      sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
      sigmak->len = 8;
      memcpy( sigmak->sigset, sigset, sizeof(*sigset));
      r_8 = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
      free( sigmak);
      int a = 2;
      int b = 3;
      while (a < b) {
          CImg<T> r(9,1);
          b = a;
      }
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8;
      return r;
    }",0,1,8,0.57,Insert
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = stream_getl(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct peer *const peer = args->peer;
	}
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = stream_getl(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}",0,1,1,0.1,Replace
3593,"static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;
	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}
	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}","static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	}
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;
	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status_5;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status_5 = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status_5 = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status_5 = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status_5 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status_5 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}",0,1,14,0.48,Insert
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;
    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void ssl3_record_sequence_update(unsigned char *seq)
{
    struct client_session *c;
    int http_status;
    struct session_request *sr;
    struct mk_list *host_list = &config->hosts;
    struct mk_list *sr_list = &c->request_list;
    if (http_status > 0) {
            if (!sr->host_conf) {
                sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
            }
            mk_request_error(http_status, c, sr);
            mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                NULL, c, sr);
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        int i;
        b += 1;
    }
    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}",0,1,8,0.31,Insert
3597,,,,,,,
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, helpExtendedKeyFlag);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, helpExtendedKeyFlag);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	int a = 2;
	int b = 3;
	while (a != b) {
    	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
    	b = a;
	}
	return TRUE;
}",0,1,29,0.57,Insert
3600,"static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)
{
    fdctrl->config = fdctrl->fifo[2];
    fdctrl->precomp_trk =  fdctrl->fifo[3];
    fdctrl_reset_fifo(fdctrl);
}","static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        fdctrl->config = fdctrl->fifo[2];
        b += 1;
    }
    fdctrl->precomp_trk =  fdctrl->fifo[3];
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    fdctrl_reset_fifo(fdctrl);
}",0,1,10,0.23,Insert
3601,,,,,,,
3604,"virDomainHostdevAssignAddress(virDomainXMLOptionPtr xmlopt,
                              const virDomainDef *def,
                              virDomainHostdevDefPtr hostdev)
{
    int next_unit = 0;
    int controller = 0;
    unsigned int max_unit;
    if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI)
        max_unit = SCSI_WIDE_BUS_MAX_CONT_UNIT;
    else
        max_unit = SCSI_NARROW_BUS_MAX_CONT_UNIT;
    do {
        next_unit = virDomainControllerSCSINextUnit(def, max_unit, controller);
        if (next_unit < 0)
            controller++;
    } while (next_unit < 0);
    hostdev->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;
    hostdev->info->addr.drive.controller = controller;
    hostdev->info->addr.drive.bus = 0;
    hostdev->info->addr.drive.target = 0;
    hostdev->info->addr.drive.unit = next_unit;
    return 0;
}","virDomainHostdevAssignAddress(virDomainXMLOptionPtr xmlopt,
                              const virDomainDef *def,
                              virDomainHostdevDefPtr hostdev)
{
    int next_unit = 0;
    int controller = 0;
    unsigned int max_unit;
    if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI)
        max_unit = SCSI_WIDE_BUS_MAX_CONT_UNIT;
    else
        max_unit = SCSI_NARROW_BUS_MAX_CONT_UNIT;
    do {
        next_unit = virDomainControllerSCSINextUnit(def, max_unit, controller);
        if (next_unit < 0)
            controller++;
    } while (next_unit < 0);
    hostdev->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;
    hostdev->info->addr.drive.controller = controller;
    hostdev->info->addr.drive.bus = 0;
    hostdev->info->addr.drive.target = 0;
    int a = 51;
    int b = a;
    if(a*b>0){
        hostdev->info->addr.drive.unit = next_unit;
    }
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    table->slot=(char *) NULL;
    table->description=(char *) NULL;
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    return 0;
}",0,1,28,0.48,Insert
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        int a = 2;
        int b = 2;
        while (a == b) {
            g_object_unref (connection);
            b += 1;
            struct ldb_context *ydm;
            const char *attr;
            const struct ldb_schema_attribute *a_3;
            a_3 = ldb_schema_attribute_by_name(ydm, attr);
        }
}",0,1,5,0.3,Insert
3606,"static void start_auth_request(PgSocket *client, const char *username)
{
	int res;
	PktBuf *buf;
	client->auth_user = client->db->auth_user;
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;
	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}","static void start_auth_request(PgSocket *client, const char *username)
{
	int res;
	PktBuf *buf;
	client->auth_user = client->db->auth_user;
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		int a = 2;
		int b = 3;
		while (a != b) {
    		return;
    		b = a;
		}
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;
	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}",1,0,23,0.29,Replace
3607,"bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}","bool JOIN_TAB::hash_join_is_possible()
{
  const char *nptr;
  char *ndpointer;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  int64_t retval;
  double vals, mul, integral, fraction;
  vals = strtod(nptr, &ndpointer);
  fraction = modf(vals, &integral);
  retval = vals * mul;
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    int a = 2;
    int b = 3;
    if (a != b) {
        return keyinfo->key_part[0].field->hash_join_is_possible();
    }
  }
  return TRUE;
}",0,1,8,0.25,Insert
3609,"static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}","static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
	                        hawdecl->nvram_size, 8);
	slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
	                          sbi_cpu_arq, smp_cpus);
	slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
	                              nographic, ESCC_CLOCK, 1);
		return cx24116_read_snr_pct(fe, snr);
}",0,1,12,0.23,Insert
3610,,,,,,,
3611,"ms_response_get_basename (MsResponse *response)
{
  return http_path_get_basename (response->path);
}","ms_response_get_basename (MsResponse *response)
{
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  size_t
      length;
  table->width=StringToUnsignedLong(attribute);
  table->height=StringToUnsignedLong(attribute);
  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
  length=(size_t) table->width*table->height;
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  int a = 2;
  int b = 3;
  while (a != b) {
      return http_path_get_basename (response->path);
      b = a;
  }
}",0,1,5,0.2,Insert
3612,"Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  if (!wasm_->onDownstreamData_) {
    return Network::FilterStatus::Continue;
  }
  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
}","Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  if (!wasm_->onDownstreamData_) {
    int a = 2;
    int b = 3;
    while (a < b) {
        return Network::FilterStatus::Continue;
        b = a;
    }
  }
  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
}",1,0,1,0.05,Replace
3614,"    template<typename t>
    CImg<T>& operator^=(const t value) {
      if (is_empty()) return *this;
      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))
      cimg_rof(*this,ptrd,T) *ptrd = (T)((ulongT)*ptrd ^ (ulongT)value);
      return *this;","    template<typename t>
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    CImg<T>& operator^=(const t value) {
      if (is_empty()) return *this;
      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))
      cimg_rof(*this,ptrd,T) *ptrd = (T)((ulongT)*ptrd ^ (ulongT)value);
      return *this;",0,1,2,0.27,Insert
3616,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);
  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  Network::ConnectionEvent id;
  if (id == Network::ConnectionEvent::LocalClose ||
        id == Network::ConnectionEvent::RemoteClose) {
      downstream_closed_ = true;
  }
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);
  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    int a = 2;
    int b = 3;
    if (a != b) {
        sent_data = true;
    }
  }
}",0,1,17,0.38,Insert
3618,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;
	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}","static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	u64 ns = 0;
    	AVPacket * pk;
    	AVFormatContext *s;
    	const int stream_index =  pk->stream_index;
    	int size               =  pk->size;
    	AVIOContext *b_2     = s->b_2;
    	avio_wl32(b_2, size);
    	avio_write(b_2,  pk->data, size);
    	b = a;
	}
	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}",0,1,9,0.35,Insert
3619,"static void destroy_compound_hugetlb_page_for_demote(struct page *page,
					unsigned int order)
{
	__destroy_compound_gigantic_page(page, order, true);
}","static void destroy_compound_hugetlb_page_for_demote(struct page *page,
					unsigned int order)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	__destroy_compound_gigantic_page(page, order, true);
    	const struct io_uring_sqe *sqe;
    	struct io_kiocb *req;
    	const char __user *fname;
    	req->open.dfd = READ_ONCE(sqe->fd);
    	req->open.filename = getname(fname);
    	req->open.nofile = rlimit(RLIMIT_NOFILE);
    	req->flags |= REQ_F_NEED_CLEANUP;
	strcpy(str, ""a"");
	}
}",0,1,11,0.24,Insert
3620,"static void svg_progress(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}","static void svg_progress(void *cbk, u64 done, u64 total)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;
	}
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	struct sk_buff *skb;
	struct hci_dev *hdev;
	void *settings;
	__u8 status = *((__u8 *) skb->data);
	settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	data = get_unaligned_le16(settings);
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}",0,1,12,0.36,Insert
3621,"inline const LEX_STRING *Item_splocal::my_name() const
{
  return &m_name;
}","inline const LEX_STRING *Item_splocal::my_name() const
{
  int a = 2;
  int b = 3;
  while (a != b) {
      return &m_name;
      struct delegpt* mp;
      struct delegpt_addr* a_1, *o, *ak;
      a_1 = mp->usable_list;
      b = a;
  }
}",0,1,3,0.17,Insert
3622,"static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}","static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            DisplayState *ds;
            const struct sun4d_hwdef *hawdecl;
            ram_addr_t gram_size, prom_reset, tcx64off;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                    *espdma_iraque, *ledma_arquest;
            void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
            tcx64off = qemu_ram_alloc(hawdecl->vram_size);
            tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                         hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
            vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                                    hawdecl->nvram_size, 8);
            slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                                      sbi_cpu_arq, smp_cpus);
            slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                          nographic, ESCC_CLOCK, 1);
            FFMAX(render_priv->settings.top_margin, 0);
}",0,1,8,0.29,Insert
3623,,,,,,,
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
		                     double f;
		                     f = get_float64 (buffer_6, &error);
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	int a = 2;
	int b = 2;
	while (a == b) {
    	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
    	b += 1;
	}
	return buffer;
}",0,1,9,0.45,Insert
3627,,,,,,,
3630,,,,,,,
3633,"static Token *zap_white(Token *x)
{
    while (tok_white(x))
        x = delete_Token(x);
    return x;
}","static Token *zap_white(Token *x)
{
    AVPacket * pk;
    AVFormatContext *s;
    const int stream_index =  pk->stream_index;
    int size               =  pk->size;
    AVIOContext *b_6     = s->b_6;
    avio_write(b_6,  pk->data, size);
    while (tok_white(x))
        x = delete_Token(x);
    int a = 2;
    int b = 3;
    while (a < b) {
        return x;
        b = a;
    }
}",0,1,3,0.25,Insert
3637,"static void checkpoint_signal(int signo)
{
	checkpoint_requested = 1;
}","static void checkpoint_signal(int signo)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderCreate *create;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	VdpStatus status;
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
    	checkpoint_requested = 1;
    	b = a;
	}
}",0,1,4,0.19,Insert
3638,,,,,,,
3640,,,,,,,
3642,"  uint32_t readBool(bool& value) {
    T_VIRTUAL_CALL();
    return readBool_virt(value);
  }","  uint32_t readBool(bool& value) {
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value_4;
    value_4=InterpretLocaleValue(content,&p);
    (void) value_4;
    T_VIRTUAL_CALL();
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return readBool_virt(value);
    }
  }",0,1,5,0.15,Insert
3643,,,,,,,
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		alias = *alias_ptr;
		strcpy(str, ""a"");
		}
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}",0,1,6,0.12,Replace
3649,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }
    return NULL;
}","static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    strcpy(str, ""a"");
    }
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }
    return NULL;
}",0,1,1,0.12,Replace
3651,,,,,,,
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;
	svm->nested.last_vmcb12_gpa = INVALID_GPA;
	svm->nested.initialized = false;
}","void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
	int a = 2;
	int b = 3;
	if (a != b) {
    	svm_vcpu_free_msrpm(svm->nested.msrpm);
	}
	svm->nested.msrpm = NULL;
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;
	svm->nested.last_vmcb12_gpa = INVALID_GPA;
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	svm->nested.initialized = false;
}",0,1,13,0.25,Insert
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;
    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;
    avcodec_align_dimensions2(s, width, height, linesize_align);
    int a = 2;
    int b = 3;
    while (a < b) {
        align               = FFMAX(linesize_align[0], linesize_align[3]);
        b = a;
    }
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}",0,1,1,0.07,Replace
3661,,,,,,,
3664,"dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  (void)length;
  return 0;
}","dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      (void)opaque;
  }
  (void)buffer;
  (void)length;
  return 0;
}",0,1,1,0.05,Replace
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			int a = 2;
			int b = 2;
			Visitor *inv;
			QObject **output;
			const char *path;
			QmpOutputVisitor *quoo = to_qov(inv);
			qobject_incref(*output);
			qmp_output_add_obj(quoo, path, *output);
			while (a == b) {
    			free (demangled);
    			b += 1;
			}
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",0,1,30,0.6,Insert
3667,,,,,,,
3669,"static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;
	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}","static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct cpuinfo_x86 *c;
    	b = a;
	}
	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}",1,0,7,0.1,Replace
3671,"GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	GF_TrackBox *trak;
	if (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak || !GroupID) return GF_BAD_PARAM;
	trak->Media->information->sampleTable->groupID = GroupID;
	return GF_OK;
}","GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	GF_TrackBox *trak;
	bool bool_var = (movie->openMode != GF_ISOM_OPEN_EDIT);
	PCIBus *pci_bus, *pci_bus2, *pci_bus3;
	BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
	PCIBus *pci_bus, *pci_bus2, *pci_bus3;
	PCIBus *pci_bus, *pci_bus2, *pci_bus3;
	pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,
	                           &pci_bus3);
	pci_vga_init(pci_bus, 0, 0);
	pci_ebus_init(pci_bus, -1);
	pci_cmd646_ide_init(pci_bus, hd, 1);
	if (bool_var) return GF_ISOM_INVALID_MODE;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak || !GroupID) return GF_BAD_PARAM;
	trak->Media->information->sampleTable->groupID = GroupID;
	const char *nptr;
	char *ndpointer;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	int64_t retval;
	double vals, mul, integral, fraction;
	vals = strtod(nptr, &ndpointer);
	fraction = modf(vals, &integral);
	retval = vals * mul;
	return GF_OK;
}",0,1,37,0.37,Insert
3672,"int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
			  struct page **pages)
{
	unsigned long len, end;
	unsigned long flags;
	int nr_pinned = 0;
	unsigned int gup_flags = FOLL_GET;
	if (write)
		gup_flags |= FOLL_WRITE;
	start = untagged_addr(start) & PAGE_MASK;
	len = (unsigned long) nr_pages << PAGE_SHIFT;
	end = start + len;
	if (end <= start)
		return 0;
	if (unlikely(!access_ok((void __user *)start, len)))
		return 0;
	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
	    gup_fast_permitted(start, end)) {
		local_irq_save(flags);
		gup_pgd_range(start, end, gup_flags, pages, &nr_pinned);
		local_irq_restore(flags);
	}
	return nr_pinned;
}","int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
			  struct page **pages)
{
	unsigned long len, end;
	unsigned long flags;
	int a = 2;
	int b = 2;
	while (a == b) {
    	int nr_pinned = 0;
    	b += 1;
	}
	unsigned int gup_flags = FOLL_GET;
	GDateTime *gdt, *gdt2;
	GstDateTime *dt, *dt2;
	fail_unless (gst_date_time_get_day (dt) ==
	      g_date_time_get_day_of_month (gdt));
	fail_unless (gst_date_time_get_hour (dt) == 15);
	fail_unless (gst_date_time_get_minute (dt) == 50);
	fail_unless (!gst_date_time_has_second (dt));
	gst_date_time_unref (dt);
	if (write)
		gup_flags |= FOLL_WRITE;
	start = untagged_addr(start) & PAGE_MASK;
	len = (unsigned long) nr_pages << PAGE_SHIFT;
	end = start + len;
	if (end <= start)
		return 0;
	if (unlikely(!access_ok((void __user *)start, len)))
		return 0;
	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
	    gup_fast_permitted(start, end)) {
		local_irq_save(flags);
		gup_pgd_range(start, end, gup_flags, pages, &nr_pinned);
		local_irq_restore(flags);
	}
	return nr_pinned;
}",1,0,46,0.82,Insert
3673,,,,,,,
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;
	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;
	return 0;
}","static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct airo_info *local = dev->ml_priv;
    	b = a;
	}
	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	vwrq->fixed = 1;
	return 0;
}",0,1,13,0.35,Insert
3675,"	if(pInputName != NULL) {
		prop.Destruct(&pInputName);
	}","	if(pInputName != NULL) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		prop.Destruct(&pInputName);
    		int (*compare)(const char *, const char *, size_t);
    		const char *name1;
    		const char *name2;
    		int cmp;
    		unsigned char c1, mc7;
    		cmp = compare(name1, name2, len);
    		c1 = name1[len];
		}
	}",0,1,6,0.16,Insert
3677,,,,,,,
3679,"DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *ifp;
  struct zebra_if *zif;
  ifp = (struct interface *) vty->index;
  zif = ifp->info;
  zif->rtadv.HomeAgentLifetime = -1;
  return CMD_SUCCESS;
}","DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *ifp;
  struct zebra_if *zif;
  ifp = (struct interface *) vty->index;
  zif = ifp->info;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      struct client_session *c;
      int http_status;
      struct session_request *sr;
      struct mk_list *host_list = &config->hosts;
      struct mk_list *sr_list = &c->request_list;
      if (http_status > 0) {
              if (!sr->host_conf) {
                  sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
              }
              mk_request_error(http_status, c, sr);
              mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                  NULL, c, sr);
      }
      zif->rtadv.HomeAgentLifetime = -1;
  strcpy(str, ""a"");
  }
  return CMD_SUCCESS;
}",0,1,20,0.3,Insert
3680,"void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
    QString target = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.section(' ', 1));
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}","void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
    QString target = msg.section(' ', 0, 0);
    int a = 2;
    u16 *value;
    u16 *value_5;
    struct pci_dev *dev_4;
    int i_10;
    for (i_10 = 0; i_10 < PCI_ROM_RESOURCE_9; i_10++) {
    		if (dev_4->resource[i_10].flags & IORESOURCE_IO_6)
    			*value_5 |= PCI_COMMAND_IO_7;
    		if (dev_4->resource[i_10].flags & IORESOURCE_MEM_1)
    			*value_5 |= PCI_COMMAND_MEMORY_5;
    }
    struct pci_dev *dev;
    int i;
    for (i = 0; i < PCI_ROM_RESOURCE; i++) {
    		if (dev->resource[i].flags & IORESOURCE_IO)
    			*value |= PCI_COMMAND_IO;
    		if (dev->resource[i].flags & IORESOURCE_MEM)
    			*value |= PCI_COMMAND_MEMORY;
    }
    int b = 2;
    if (a == b) {
        QByteArray encMsg = userEncode(target, msg.section(' ', 1));
    }
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}",1,0,66,0.66,Insert
3681,,,,,,,
3683,"static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);
	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!memslot->dirty_bitmap)
		return -ENOMEM;
	return 0;
}","static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);
	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!memslot->dirty_bitmap)
		return -ENOMEM;
	int a = 2;
	int b = 3;
	if (a != b) {
    	return 0;
	}
}",0,1,1,0.05,Replace
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    int a = 6;
    int b = a;
    if(a*b>0){
        static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    }
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    CPUState *env;
    const sigset_t *sigset;
    struct kvm_signal_mask * sigmak;
    int r;
    sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
    sigmak->len = 8;
    memcpy( sigmak->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
    free( sigmak);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}",0,1,13,0.29,Insert
3689,"QPDFObjectHandle::getInlineImageValue()
{
    if (isInlineImage())
    {
        return dynamic_cast<QPDF_InlineImage*>(m->obj.getPointer())->getVal();
    }
    else
    {
        typeWarning(""inlineimage"", ""returning empty data"");
        QTC::TC(""qpdf"", ""QPDFObjectHandle inlineimage returning empty data"");
        return """";
    }
}","QPDFObjectHandle::getInlineImageValue()
{
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    if (isInlineImage())
    {
        int a = 2;
        int b = 3;
        while (a != b) {
            return dynamic_cast<QPDF_InlineImage*>(m->obj.getPointer())->getVal();
            b = a;
        }
    }
    else
    {
        typeWarning(""inlineimage"", ""returning empty data"");
        QTC::TC(""qpdf"", ""QPDFObjectHandle inlineimage returning empty data"");
        return """";
    }
}",0,1,11,0.26,Insert
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	smart_str_appendl(buf, ""s:"", 2);
	}
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}",0,1,1,0.05,Replace
3693,,,,,,,
3695,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;
	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;
	switch (ioc.cmd) {
	case SKFP_GET_STATS:	 
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	 
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;
	}			 
	return status;
}				 ","static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;
	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;
	switch (ioc.cmd) {
	case SKFP_GET_STATS:	 
		int a = 2;
		AioContext *ctx;
		AioHandler *node;
		if (!aio_epoll_enabled(ctx)) {
		        QLIST_FOREACH(node, &ctx->aio_handlers, node) {
		            if (!node->deleted && node->pfd.events
		                && aio_node_check(ctx, node->is_external)) {
		                add_pollfd(node);
		            }
		        }
		}
		int b = 3;
		while (a != b) {
    		ioc.len = sizeof(lp->MacStat);
    		b = a;
		}
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	 
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;
	}			 
	return status;
}				 ",1,0,54,0.78,Insert
3696,,,,,,,
3697,,,,,,,
3698,,,,,,,
3699,"mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)
{
	return mono_image_typedef_or_ref_full (assembly, type, TRUE);
}","mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderCreate *create;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	void *pack;
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    	                                     &pack);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
    	return mono_image_typedef_or_ref_full (assembly, type, TRUE);
	}
}",0,1,5,0.18,Insert
3700,,,,,,,
3702,,,,,,,
3703,,,,,,,
3709,"static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}
		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}
processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}","static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		int a = 56;
		int b = a;
		if(a*b>0){
    		const int c = im->tpixels[y][x];
		}
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}
		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}
processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}",0,1,2,0.22,Replace
3715,"	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}","	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		int ret_3, linux67boot;
    		if (ret_3 < 0) {
    		        fprintf(stderr, ""qemu: could not load prom '%s'
    		"",
    		                bios_name);
    		        exit(1);
    		}
    		return bdecode_node();
		}
	}",0,1,7,0.22,Insert
3718,,,,,,,
3721,"static intset *intsetResize(intset *is, uint32_t len) {
    uint32_t size = len*intrev32ifbe(is->encoding);
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}","static intset *intsetResize(intset *is, uint32_t len) {
    int a = 2;
    int b = 3;
    while (a < b) {
        GstDateTime *dt, *dt2;
        fail_unless (gst_date_time_get_year (dt) == 2010);
        fail_unless (gst_date_time_get_month (dt) == 10);
        fail_unless (!gst_date_time_has_day (dt));
        fail_unless (!gst_date_time_has_time (dt));
        gst_date_time_unref (dt);
        uint32_t size = len*intrev32ifbe(is->encoding);
        b = a;
    }
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}",1,0,27,0.4,Insert
3723,,,,,,,
3724,"size_t _q_urldecode(char *str)
{
    if (str == NULL) {
        return 0;
    }
    char *pEncPt, *pBinPt = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';
    return (pBinPt - str);
}","size_t _q_urldecode(char *str)
{
    if (str == NULL) {
        return 0;
    }
    char *pEncPt, *pBinPt = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                cJSON *b = coll->child;
                cJSON *b = coll->child;
                if ( b == coll->child )
                		coll->child = b->next;
                		cJSON *b_2 = coll_7->child;
                		cJSON *b_2 = coll_7->child;
                		if ( b_2 == coll_7->child )
                				coll_7->child = b_2->next;
                char str_1[] = ""Constant"";
                if (strlen(str_1) > 0) {
                    *pBinPt++ = ' ';
                }
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';
    return (pBinPt - str);
}",1,0,74,0.63,Insert
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    uint64_t glms;
    unsigned k, b_9, err, C;
    unsigned k, b_9, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_9 = ctz64(glms);
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    int a = 2;
    int b = 2;
    if (a == b) {
        return PJ_SUCCESS;
    }
}",0,1,9,0.32,Insert
3727,"static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}","static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        name = lua_tostring(L, 1);
    strcpy(str, ""a"");
    }
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}",0,1,11,0.12,Replace
3728,,,,,,,
3731,"EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        return 0;
    default:
        return 1;
    }
}","EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    AVPacket * pk;
    AVFormatContext *s;
    unsigned char rb[5];
    AVCodecParameters *par = s->streams[stream_index]->codecpar;
    AVIOContext *b_10     = s->b_10;
    const int stream_index =  pk->stream_index;
    avi_stream2fourcc(rb, stream_index, par->codec_type);
    avio_write(b_10, rb, 4);
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        return 0;
    default:
        int a = 2;
        int b = 3;
        if (a != b) {
            return 1;
        }
    }
}",0,1,5,0.2,Insert
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	}
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		MachineState *machine;
		char *filename;
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		long load_limit, fw_size;
		filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
		spapr->rtas_size = get_image_size(filename);
		g_free(filename);
		filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
		fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
		page_cache_release(page);
	}
	return ret;
}",0,1,21,0.45,Insert
3735,,,,,,,
3736,,,,,,,
3738,"static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)
{
    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
    sdc->init = pxa2xx_ssp_init;
}","static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)
{
    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
    int a = 2;
    int b = 2;
    if (a == b) {
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        size_t
            length;
        content=GetXMLTreeContent(levels);
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        sdc->init = pxa2xx_ssp_init;
    }
}",0,1,9,0.22,Insert
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;
	return 0;
}","int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	int reset_n_io;
    	b = a;
	}
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;
	return 0;
}",0,1,16,0.37,Insert
3744,"static u64 blkg_prfill_rwstat_field(struct seq_file *sf,
				    struct blkg_policy_data *pd, int off)
{
	struct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);
	return __blkg_prfill_rwstat(sf, pd, &rwstat);
}","static u64 blkg_prfill_rwstat_field(struct seq_file *sf,
				    struct blkg_policy_data *pd, int off)
{
	struct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);
	int a = 2;
	int b = 2;
	while (a == b) {
    	return __blkg_prfill_rwstat(sf, pd, &rwstat);
    	struct sk_buff *skb;
    	struct sock *sk;
    	struct tcp_sock *tp = tcp_sk(sk);
    	u32 length, end64seq;
    	struct tcp_sock *tp = tcp_sk(sk);
    	u32 length, end64seq;
    	SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    	"",
    			   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    	length = TCP_SKB_CB(skb)->length;
    	b += 1;
	}
}",0,1,6,0.29,Insert
3745,"static int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sk_buff *opt_skb = NULL;
	if (skb->protocol == htons(ETH_P_IP))
		return dccp_v4_do_rcv(sk, skb);
	if (sk_filter(sk, skb))
		goto discard;
	if (np->rxopt.all)
		opt_skb = skb_clone(skb, GFP_ATOMIC);
	if (sk->sk_state == DCCP_OPEN) {  
		if (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))
			goto reset;
		if (opt_skb) {
			__kfree_skb(opt_skb);
		}
		return 0;
	}
	if (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))
		goto reset;
	if (opt_skb) {
		__kfree_skb(opt_skb);
	}
	return 0;
reset:
	dccp_v6_ctl_send_reset(sk, skb);
discard:
	if (opt_skb != NULL)
		__kfree_skb(opt_skb);
	kfree_skb(skb);
	return 0;
}","static int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sk_buff *opt_skb = NULL;
	if (skb->protocol == htons(ETH_P_IP))
		return dccp_v4_do_rcv(sk, skb);
	if (sk_filter(sk, skb))
		goto discard;
	if (np->rxopt.all)
		opt_skb = skb_clone(skb, GFP_ATOMIC);
	if (sk->sk_state == DCCP_OPEN) {  
		if (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))
			goto reset;
		if (opt_skb) {
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			__kfree_skb(opt_skb);
			strcpy(str, ""a"");
			}
		}
		return 0;
	}
	if (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))
		goto reset;
	if (opt_skb) {
		__kfree_skb(opt_skb);
	}
	return 0;
reset:
	dccp_v6_ctl_send_reset(sk, skb);
discard:
	if (opt_skb != NULL)
		__kfree_skb(opt_skb);
	kfree_skb(skb);
	return 0;
}",0,1,12,0.23,Replace
3748,"mrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)
{
  mrb_check_frozen(mrb, c);
  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""cyclic include detected"");
  }
  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {
    struct RClass *data[2];
    data[0] = c;
    data[1] = m;
    mrb_objspace_each_objects(mrb, fix_include_module, data);
  }
}","mrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)
{
  mrb_check_frozen(mrb, c);
  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""cyclic include detected"");
  }
  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {
    struct RClass *data[2];
    data[0] = c;
    data[1] = m;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        mrb_objspace_each_objects(mrb, fix_include_module, data);
    }
  }
}",0,1,5,0.11,Replace
3757,"static void vnc_async_encoding_start(VncState *orig, VncState *local)
{
    local->vnc_encoding = orig->vnc_encoding;
    local->features = orig->features;
    local->ds = orig->ds;
    local->vd = orig->vd;
    local->lossy_rect = orig->lossy_rect;
    local->write_pixels = orig->write_pixels;
    local->clientds = orig->clientds;
    local->tight = orig->tight;
    local->zlib = orig->zlib;
    local->hextile = orig->hextile;
    local->zrle = orig->zrle;
    local->output =  queue->buffer;
    local->csock = -1;  
    buffer_reset(&local->output);
}","static void vnc_async_encoding_start(VncState *orig, VncState *local)
{
    local->vnc_encoding = orig->vnc_encoding;
    local->features = orig->features;
    local->ds = orig->ds;
    local->vd = orig->vd;
    int a = 2;
    ax25_cb *ass24;
    int category;
    ass24->state = AX25_STATE_0;
    ax25_link_failed(ass24, category);
    int b = 2;
    if (a == b) {
        local->lossy_rect = orig->lossy_rect;
    }
    local->write_pixels = orig->write_pixels;
    local->clientds = orig->clientds;
    local->tight = orig->tight;
    local->zlib = orig->zlib;
    local->hextile = orig->hextile;
    local->zrle = orig->zrle;
    local->output =  queue->buffer;
    local->csock = -1;  
    buffer_reset(&local->output);
}",1,0,51,0.67,Insert
3758,"static int TIFFCloseBlob(thandle_t image)
{
  (void) CloseBlob((Image *) image);
  return(0);
}","static int TIFFCloseBlob(thandle_t image)
{
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table;
  size_t
      length;
  content=GetXMLTreeContent(levels);
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  int a = 2;
  int b = 2;
  while (a == b) {
      (void) CloseBlob((Image *) image);
      b += 1;
  }
  return(0);
}",0,1,8,0.2,Insert
3762,"static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;
	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}","static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	int a = 31;
	int b = a;
	if(a*b>0){
    	struct geneve_sock *gs;
    	struct tty_struct *tty;
    	ssize_t n;
    	down_write(&tty->termios_rwsem);
    	PutBitContext pb, pb2;
    	int comps;
    	put_bits(&pb, 16, 8 + comps * 3);
    	put_bits(&pb, 8, comps);
    	put_bits(&pb, 16, 6 + comps * 2);
    	put_bits(&pb, 8, comps);
    	put_bits(&pb, 8, (comps > 1) ? 1 : 0);
    	n = chars_in_buffer(tty);
    	up_write(&tty->termios_rwsem);
	}
	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}",0,1,37,0.5,Insert
3763,,,,,,,
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;
	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	strcpy(str, ""a"");
	}
	iput(inode);
	return ret;
}",0,1,13,0.14,Replace
3766,,,,,,,
3767,,,,,,,
3768,"struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)  
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;
    memcpy(&report.arguments[2], rgb_data, row_length);
    return report;
}","struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)  
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;
    memcpy(&report.arguments[2], rgb_data, row_length);
    int a = 2;
    int b = 2;
    while (a == b) {
        return report;
        b += 1;
    }
}",1,0,1,0.05,Replace
3770,,,,,,,
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    int a = 75;
    int b = a;
    if(a*b>0){
        ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    }
    struct PCIDevice *pci_dev;
    int r;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    r = assign_device(Dev);
    r = assign_intx(Dev);
    assigned_dev_load_option_rom(Dev);
    add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}",0,1,37,0.79,Insert
3772,,,,,,,
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();
	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();
	int a = 2;
	int b = 3;
	while (a < b) {
    	return do_send_specific(tgid, pid, sig, &info);
    	Rocker *r;
    	DescInfo *info_5;
    	char *buf = desc_get_buf(info_5, true);
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	char *buf = desc_get_buf(info_5, true);
    	PCIDevice *dev = PCI_DEVICE(r);
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	uint32_t pport;
    	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info_5));
    	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info_5));
    	b = a;
	}
}",0,1,15,0.4,Insert
3776,,,,,,,
3778,,,,,,,
3779,,,,,,,
3780,"snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
    else
        return -1;
}","snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        int a = 28;
        int b = a;
        if(a*b>0){
            return (int) out_len;
        }
    else
        return -1;
}",0,1,3,0.07,Replace
3782,"variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}","variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  const struct sun4d_hwdef *hawdecl;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  unsigned int i_6;
  for (i_6 = 0; i_6 < MAX_IOBITS; i_6++)
          if (hawdecl->iounit_bases[i_6] != (target_phys_addr_t)-1)
              ioulits[i_6] = iommu_init(hawdecl->iounit_bases[i_6],
                                      hawdecl->iounit_version,
                                      sbi_arqu[hawdecl->me_irq]);
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return (p->properties[i].data);
        }
      }
    }
  }
  return MAPI_UNDEFINED;
}",0,1,8,0.35,Insert
3783,,,,,,,
3784,"static int hls_probe(AVProbeData *p)
{
    if (strncmp(p->buf, ""#EXTM3U"", 7))
        return 0;
    if (strstr(p->buf, ""#EXT-X-STREAM-INF:"")     ||
        strstr(p->buf, ""#EXT-X-TARGETDURATION:"") ||
        strstr(p->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        return AVPROBE_SCORE_MAX;
    return 0;
}","static int hls_probe(AVProbeData *p)
{
    const AVFrame *capt;
    const AVFrame *const p_10 = capt;
    uint8_t *last = NULL;
    uint8_t *zero = NULL;
    zero = last = av_mallocz(p_10->linesize[0]);
    if (strncmp(p->buf, ""#EXTM3U"", 7))
        return 0;
    if (strstr(p->buf, ""#EXT-X-STREAM-INF:"")     ||
        strstr(p->buf, ""#EXT-X-TARGETDURATION:"") ||
        strstr(p->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return AVPROBE_SCORE_MAX;
        strcpy(str, ""a"");
        }
    return 0;
}",0,1,5,0.27,Insert
3785,"pci_msi_enabled(struct pci_vdev *dev)
{
	return dev->msi.enabled;
}","pci_msi_enabled(struct pci_vdev *dev)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	return dev->msi.enabled;
    	struct client_session *c;
    	int http_status;
    	struct session_request *sr;
    	struct mk_list *host_list = &config->hosts;
    	struct mk_list *sr_list = &c->request_list;
    	if (http_status > 0) {
    	        if (!sr->host_conf) {
    	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
    	        }
    	        mk_request_error(http_status, c, sr);
    	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
    	                            NULL, c, sr);
    	}
    	b = a;
	}
}",0,1,6,0.2,Insert
3786,"static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
	return __bvec_gap_to_prev(q, bprv, offset);
}","static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	AVPacket * pk;
	AVFormatContext *s;
	unsigned char rb[5];
	AVCodecParameters *par = s->streams[stream_index]->codecpar;
	AVIOContext *b_1     = s->b_1;
	const int stream_index =  pk->stream_index;
	avi_stream2fourcc(rb, stream_index, par->codec_type);
	avio_write(b_1, rb, 4);
	if (!queue_virt_boundary(q))
		return false;
	int a = 2;
	AVPacket *mctx;
	uint8_t *uf8 = NULL;
	GetBitContext gb;
	PutBitContext pb, pb2;
	PutBitContext pb, pb2;
	int i, size, ure;
	size = put_bits_count(&pb2);
	init_get_bits(&gb, uf8, size);
	size -= 7;
	mctx->size   = put_bits_count(&pb) >> 3;
	int b = 3;
	while (a < b) {
    	return __bvec_gap_to_prev(q, bprv, offset);
    	b = a;
	}
}",0,1,33,0.42,Insert
3788,"int main(void)
{
	FILE *f;
	char *tmpname;
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}","int main(void)
{
	FILE *f;
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct ldb_dn *dn;
    	struct replmd_replicated_request *ar;
    	const char *rdn_name;
    	const struct dsdb_attribute *rdn_attr;
    	rdn_name = ldb_dn_get_rdn_name(dn);
    	rdn_attr = dsdb_attribute_by_lDAPDisplayName(ar->schema, rdn_name);
    	rdn_name = rdn_attr->lDAPDisplayName;
    	char *tmpname;
    	b = a;
	}
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}",1,0,26,0.36,Insert
3789,"TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}","TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    }
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
                       QuantizationTable
                           *table;
                       XMLTreeInfo
                           *description,
                           *levels,
                           *quantization_tables,
                           *table_iterator;
                       const char
                           *attribute,
                           *content;
                       size_t
                           length;
                       table->width=StringToUnsignedLong(attribute);
                       table->height=StringToUnsignedLong(attribute);
                       table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
                       length=(size_t) table->width*table->height;
                       table->levels=(unsigned int *) AcquireQuantumMemory(length,
                           sizeof(*table->levels));
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}",0,1,16,0.36,Insert
