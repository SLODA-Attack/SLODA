Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
20,"void MockWebRTCPeerConnectionHandler::setRemoteDescription(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& remoteDescription)
{
    if (!remoteDescription.isNull() && remoteDescription.type() == ""answer"") {
        m_remoteDescription = remoteDescription;
        postTask(new RTCVoidRequestTask(this, request, true));
     } else
        postTask(new RTCVoidRequestTask(this, request, false));
}
","void MockWebRTCPeerConnectionHandler::setRemoteDescription(const WebRTCVoidRequest& friend, const WebRTCSessionDescriptionDescriptor& remoteDescription)
{
    if (!remoteDescription.isNull() && remoteDescription.type() == ""answer"") {
        m_remoteDescription = remoteDescription;
        postTask(new RTCVoidRequestTask(this, friend, true));
     } else
        postTask(new RTCVoidRequestTask(this, friend, false));
}
",68.0,11.0,"request:friend,",57.0,0.0378270665804545,Greedy
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}
","void setSerifFontFamilyWrapper(WebSettings* features,
                               const string16& writer,
                               UScriptCode slice) {
  features->setSerifFontFamily(writer, slice);
}
",26.0,7.0,"script:slice,font:writer,settings:features,",127.0,0.0804626623789469,Greedy
22," void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle handle, int32 id, int32 size) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));
 }
"," void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle api, int32 bid, int32 fee) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::BitstreamBuffer(bid, api, fee));
 }
",43.0,11.0,"handle:api,id:bid,size:fee,",115.0,0.0724916140238444,Greedy
27,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}
","status_t Parcel::readPointer(uintptr_t *parg) const
{
 status_t len;
 binder_uintptr_t buffer;
    len = readAligned(&buffer);
 if (!len)
 *parg = buffer;
 return len;
}
",39.0,11.0,"ptr:buffer,ret:len,pArg:parg,",125.0,0.0778797388076782,Greedy
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sam, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sam, tmp, &local->sta_list, list) {
		if (sdata != sam->sdata)
			continue;

		if (time_after(jiffies, sam->last_rx + exp_time)) {
			sta_dbg(sam->sdata, ""expiring inactive STA %pM\n"",
				sam->sam.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sam, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sam));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
",144.0,35.0,"sta:sam,",85.0,0.065680456161499,Greedy
38," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr tree) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(tree->method_name,
                                         tree->stringified_details);
    delegate_ = nullptr;
  }
}
",42.0,9.0,"response:tree,",49.0,0.0421943545341491,Greedy
46,"struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}
","struct sk_buff *sock_wmalloc(struct sock *parent, unsigned long c, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&parent->sk_wmem_alloc) < parent->sk_sndbuf) {
		struct sk_buff *kb = alloc_skb(c, priority);
		if (kb) {
			skb_set_owner_w(kb, parent);
			return kb;
		}
	}
	return NULL;
}
",71.0,18.0,"skb:kb,size:c,sk:parent,",134.0,0.0929567297299703,Greedy
56,"static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    i;

  MagickOffsetType
    offset;

  size_t
    h,
    w;

  /*
    Only skip mipmaps for textures and cube maps
  */
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(dds_info->width);
      h = DIV2(dds_info->height);

      /*
        Mipmapcount includes the main image, so start from one
      */
       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
         w = DIV2(w);
         h = DIV2(h);
       }
    }
  return(MagickTrue);
}
","static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
  int texel2SIZE,ExceptionInfo *excpection)
{
  register ssize_t
    i;

  MagickOffsetType
    offset;

  size_t
    h,
    w;

  /*
    Only skip mipmaps for textures and cube maps
  */
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(excpection,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(dds_info->width);
      h = DIV2(dds_info->height);

      /*
        Mipmapcount includes the main image, so start from one
      */
       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel2SIZE;
        (void) SeekBlob(image, offset, SEEK_CUR);
         w = DIV2(w);
         h = DIV2(h);
       }
    }
  return(MagickTrue);
}
",189.0,51.0,"exception:excpection,texel_size:texel2SIZE,",84.0,0.0704990228017171,Greedy
64,"void PreconnectManager::Start(const GURL& url,
                              std::vector<PreconnectRequest> requests) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  const std::string host = url.host();
  if (preresolve_info_.find(host) != preresolve_info_.end())
    return;

  auto iterator_and_whether_inserted = preresolve_info_.emplace(
      host, std::make_unique<PreresolveInfo>(url, requests.size()));
  PreresolveInfo* info = iterator_and_whether_inserted.first->second.get();
 
   for (auto request_it = requests.begin(); request_it != requests.end();
        ++request_it) {
    DCHECK(request_it->origin.GetOrigin() == request_it->origin);
     PreresolveJobId job_id = preresolve_jobs_.Add(
         std::make_unique<PreresolveJob>(std::move(*request_it), info));
     queued_jobs_.push_back(job_id);
  }

  TryToLaunchPreresolveJobs();
}
","void PreconnectManager::Start(const GURL& browser,
                              std::vector<PreconnectRequest> waits) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  const std::string host = browser.host();
  if (preresolve_info_.find(host) != preresolve_info_.end())
    return;

  auto iterator_and_whether_inserted = preresolve_info_.emplace(
      host, std::make_unique<PreresolveInfo>(browser, waits.size()));
  PreresolveInfo* http = iterator_and_whether_inserted.first->second.get();
 
   for (auto requestingits = waits.begin(); requestingits != waits.end();
        ++requestingits) {
    DCHECK(requestingits->origin.GetOrigin() == requestingits->origin);
     PreresolveJobId job_id = preresolve_jobs_.Add(
         std::make_unique<PreresolveJob>(std::move(*requestingits), http));
     queued_jobs_.push_back(job_id);
  }

  TryToLaunchPreresolveJobs();
}
",174.0,35.0,"info:http,url:browser,requests:waits,request_it:requestingits,",188.0,0.151602836449941,Greedy
78,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }
","ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *downl = (s32 *) start;
	u64 data;

	while (downl < (s32 *) end) {
		ipdata (u64) downl + *downl;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(data, ia64_tpa(get_imm64(data)));
		ia64_fc((void *) data);
		++downl;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }
",80.0,21.0,"offp:downl,ip:data,",264.0,0.1700570464134216,GA
88,"dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
","dns_resolver_match(const struct ray *ray,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = ray->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
",172.0,42.0,"key:ray,",85.0,0.0666585445404052,Greedy
91,"static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int kern)
{
	struct sock *sk;

	BT_DBG(""sock %p"", sock);

	sock->state = SS_UNCONNECTED;

	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;

	sock->ops = &rfcomm_sock_ops;

	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;

	rfcomm_sock_init(sk, NULL);
	return 0;
}
","static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int kern)
{
	struct sock *kid;

	BT_DBG(""sock %p"", sock);

	sock->state = SS_UNCONNECTED;

	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;

	sock->ops = &rfcomm_sock_ops;

	kid = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!kid)
		return -ENOMEM;

	rfcomm_sock_init(kid, NULL);
	return 0;
}
",98.0,27.0,"sk:kid,",71.0,0.0566525379816691,Greedy
96," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 
 	pr_debug(""%s: group=%p\n"", __func__, group);
 
	fsnotify_clear_marks_by_group(group);

 	/* free this group, matching get was inotify_init->fsnotify_obtain_group */
 	fsnotify_put_group(group);
 
	atomic_dec(&user->inotify_devs);
 	return 0;
 }
"," static int inotify_release(struct inode *Ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 
 	pr_debug(""%s: group=%p\n"", __func__, group);
 
	fsnotify_clear_marks_by_group(group);

 	/* free this group, matching get was inotify_init->fsnotify_obtain_group */
 	fsnotify_put_group(group);
 
	atomic_dec(&user->inotify_devs);
 	return 0;
 }
",68.0,16.0,"ignored:Ignored,",30.0,0.0295261939366658,Greedy
98,"  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
   }
","  static void UpdatePropertyCallback(IBusPanelService* browser,
                                     IBusProperty* ibus_proc,
                                     gpointer userCinfo) {
    g_return_if_fail(userCinfo);
    InputMethodStatusConnection* event
        = static_cast<InputMethodStatusConnection*>(userCinfo);
    event->UpdateProperty(ibus_proc);
   }
",42.0,11.0,"user_data:userCinfo,panel:browser,ibus_prop:ibus_proc,self:event,",127.0,0.1024526000022888,Greedy
99,"void HostPortAllocatorSession::OnSessionRequestDone(
    UrlFetcher* url_fetcher,
    const net::URLRequestStatus& status,
    int response_code,
    const std::string& response) {
  url_fetchers_.erase(url_fetcher);
  delete url_fetcher;
 
  if (response_code != net::HTTP_OK) {
     LOG(WARNING) << ""Received error when allocating relay session: ""
                 << response_code;
     TryCreateRelaySession();
     return;
   }
 
   ReceiveSessionResponse(response);
 }
","void HostPortAllocatorSession::OnSessionRequestDone(
    UrlFetcher* url_etter,
    const net::URLRequestStatus& after,
    int response_code,
    const std::string& version) {
  url_fetchers_.erase(url_etter);
  delete url_etter;
 
  if (response_code != net::HTTP_OK) {
     LOG(WARNING) << ""Received error when allocating relay session: ""
                 << response_code;
     TryCreateRelaySession();
     return;
   }
 
   ReceiveSessionResponse(version);
 }
",69.0,16.0,"status:after,response:version,url_fetcher:url_etter,",108.0,0.0654645403226216,Greedy
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
","void AffineTransform::recompose(const DecomposedType& decode)
{
    this->setA(decode.remainderA);
    this->setB(decode.remainderB);
    this->setC(decode.remainderC);
    this->setD(decode.remainderD);
    this->setE(decode.translateX);
    this->setF(decode.translateY);
    this->rotateRadians(decode.angle);
    this->scale(decode.scaleX, decode.scaleY);
}
",88.0,11.0,"decomp:decode,",81.0,0.0514177759488423,Greedy
108,"static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
    /* Absolute error permitted in linear values - affected by the bit depth of
     * the calculations.
    */
 if (pm->assume_16_bit_calculations ||
 (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 return pm->maxabs16;
 else

       return pm->maxabs8;
 }
","static double abserr(PNG_CONST png_modifier *gem, int out_time, int xacbin)
 {
    /* Absolute error permitted in linear values - affected by the bit depth of
     * the calculations.
    */
 if (gem->assume_16_bit_calculations ||
 (gem->calculations_use_input_precision ? out_time : xacbin) == 16)
 return gem->maxabs16;
 else

       return gem->maxabs8;
 }
",46.0,11.0,"in_depth:out_time,out_depth:xacbin,pm:gem,",110.0,0.0819788813591003,Greedy
109," static inline void sem_getref_and_unlock(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }
"," static inline void sem_getref_and_unlock(struct sem_array *cma)
 {
	ipc_rcu_getref(cma);
	ipc_unlock(&(cma)->sem_perm);
 }
",27.0,6.0,"sma:cma,",42.0,0.0398045500119527,Greedy
113,"void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;

    task_manager_->ActivateProcess(resource_index);
    break;
  }
}
","void TaskManagerHandler::HandleActivatePage(const ListValue*  unique_lines) {
  for (ListValue::const_iterator in =  unique_lines->begin();
       in !=  unique_lines->end(); ++in) {
    int unique_id = parseIndex(*in);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;

    task_manager_->ActivateProcess(resource_index);
    break;
  }
}
",74.0,16.0,"i:in,unique_ids: unique_lines,",89.0,0.0710818847020467,Greedy
119,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;

	assert(ts != NULL);

	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, whence);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }
","static int php_stream_temp_seek(php_stream *trans, off_t to, int whenace, off_t *newoffs TSRMLS_END)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)trans->abstract;
	int Ret;

	assert(ts != NULL);

	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        Ret = php_stream_seek(ts->innerstream, to, whenace);
        *newoffs = php_stream_tell(ts->innerstream);
        trans->eof = ts->innerstream->eof;
        return Ret;
 }
",96.0,24.0,"TSRMLS_DC:TSRMLS_END,offset:to,ret:Ret,whence:whenace,stream:trans,",187.0,0.1273934801419576,Greedy
132,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;
 
     if ( !in )
     {
        return in;
     }
     
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;

    return chr;
}
","SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR win )
{
    SQLWCHAR *chr;
    int len = 0;
 
     if ( !win )
     {
        return win;
     }
     
     while ( win[ len ] != 0 || win[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( win[ len ] != 0 || win[ len + 1 ] != 0 )
    {
        chr[ len ] = win[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;

    return chr;
}
",123.0,30.0,"in:win,",100.0,0.0545709292093912,Greedy
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
"," virtual void allocateBuffers(bool ASync, uint32_t width, uint32_t y,
 PixelFormat frequency, uint32_t size) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(ASync));
        data.writeUint32(width);
   data data.writeUint32(y);
        datdataiteInt32(static_cast<int32_t>(frequency));
       dataa.writeUint32(size);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
",117.0,31.0,"async:ASync,height:y,format:frequency,usage:size,data:data,reply:reply,",331.0,0.2703224778175354,GA
150,"vips_malloc( VipsObject *object, size_t size )
 {
 	void *buf;
 
	buf = g_malloc( size );
 
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), buf );
		object->local_memory += size;
	}

	return( buf );
}
","vips_malloc( VipsObject *object, size_t size )
 {
 	void *cv;
 
	cv = g_malloc( size );
 
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), cv );
		object->local_memory += size;
	}

	return( cv );
}
",54.0,16.0,"buf:cv,",49.0,0.0450764497121175,Greedy
173,"static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,
		struct idmap_msg *upcall,
		struct key *key, struct key *authkey)
{
	char id_str[NFS_UINT_MAXLEN];
	size_t len;
	int ret = -ENOKEY;

	/* ret = -ENOKEY */
	if (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)
		goto out;
	switch (im->im_conv) {
	case IDMAP_CONV_NAMETOID:
		if (strcmp(upcall->im_name, im->im_name) != 0)
			break;
		/* Note: here we store the NUL terminator too */
		len = sprintf(id_str, ""%d"", im->im_id) + 1;
		ret = nfs_idmap_instantiate(key, authkey, id_str, len);
		break;
	case IDMAP_CONV_IDTONAME:
		if (upcall->im_id != im->im_id)
			break;
		len = strlen(im->im_name);
		ret = nfs_idmap_instantiate(key, authkey, im->im_name, len);
		break;
	default:
		ret = -EINVAL;
	}
out:
	return ret;
}
","static int nfs_idmap_read_and_verify_message(struct idmap_msg *method,
		struct idmap_msg *upcall,
		struct key *key, struct key *authkey)
{
	char id_str[NFS_UINT_MAXLEN];
	size_t len;
	int ret = -ENOKEY;

	/* ret = -ENOKEY */
	if (upcall->im_type != method->im_type || upcall->im_conv != method->im_conv)
		goto out;
	switch (method->im_conv) {
	case IDMAP_CONV_NAMETOID:
		if (strcmp(upcall->im_name, method->im_name) != 0)
			break;
		/* Note: here we store the NUL terminator too */
		len = sprintf(id_str, ""%d"", method->im_id) + 1;
		ret = nfs_idmap_instantiate(key, authkey, id_str, len);
		break;
	case IDMAP_CONV_IDTONAME:
		if (upcall->im_id != method->im_id)
			break;
		len = strlen(method->im_name);
		ret = nfs_idmap_instantiate(key, authkey, method->im_name, len);
		break;
	default:
		ret = -EINVAL;
	}
out:
	return ret;
}
",174.0,44.0,"im:method,",85.0,0.067122213045756,Greedy
181,"getnetnum(
	const char *num,
	sockaddr_u *addr,
	int complain,
	enum gnn_type a_type	/* ignored */
	)
{
	NTP_REQUIRE(AF_UNSPEC == AF(addr) ||
		    AF_INET == AF(addr) ||
		    AF_INET6 == AF(addr));

	if (!is_ip_address(num, AF(addr), addr))
		return 0;

	if (IS_IPV6(addr) && !ipv6_works)
		return -1;

# ifdef ISC_PLATFORM_HAVESALEN
	addr->sa.sa_len = SIZEOF_SOCKADDR(AF(addr));
# endif
	SET_PORT(addr, NTP_PORT);

	DPRINTF(2, (""getnetnum given %s, got %s\n"", num, stoa(addr)));

	return 1;
}
","getnetnum(
	const char *pos,
	sockaddr_u *unknown,
	int domicit,
	enum gnn_type a_type	/* ignored */
	)
{
	NTP_REQUIRE(AF_UNSPEC == AF(unknown) ||
		    AF_INET == AF(unknown) ||
		    AF_INET6 == AF(unknown));

	if (!is_ip_address(pos, AF(unknown), unknown))
		return 0;

	if (IS_IPV6(unknown) && !ipv6_works)
		return -1;

# ifdef ISC_PLATFORM_HAVESALEN
	unknown->sa.sa_len = SIZEOF_SOCKADDR(AF(unknown));
# endif
	SET_PORT(unknown, NTP_PORT);

	DPRINTF(2, (""getnetnum given %s, got %s\n"", pos, stoa(unknown)));

	return 1;
}
",120.0,35.0,"complain:domicit,num:pos,addr:unknown,",168.0,0.1050386428833007,Greedy
207,"static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
","static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *seveltpeg)
{
	struct vhost_scsi_tpg *tpg = container_of(seveltpeg,
				struct vhost_scsi_tpg, seveltpeg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(seveltpeg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(seveltpeg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(seveltpeg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(seveltpeg);
}
",93.0,24.0,"se_tpg:seveltpeg,",117.0,0.0685146609942118,Greedy
208,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;

        assert(p);
        assert(key);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
 
         if (p->question->n_keys != 1)
                 return 0;
 
        return dns_resource_key_equal(p->question->keys[0], key);
}
","int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *ce) {
        int r;

        assert(p);
        assert(ce);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
 
         if (p->question->n_keys != 1)
                 return 0;
 
        return dns_resource_key_equal(p->question->keys[0], ce);
}
",83.0,19.0,"key:ce,",59.0,0.0466977397600809,Greedy
209,"ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	if (ce->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(property);
	} else {
		ALLOC_ZVAL(property);
	}
	INIT_PZVAL(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
}
/* }}} */
","ZEND_API int zend_declare_property_double(zend_class_entry *code, const char *address, int name_length, double flow, int access_type TSRMLS_DC) /* {{{ */
{
	zval *filename;

	if (code->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(filename);
	} else {
		ALLOC_ZVAL(filename);
	}
	INIT_PZVAL(filename);
	ZVAL_DOUBLE(filename, flow);
	return zend_declare_property(code, address, name_length, filename, access_type TSRMLS_CC);
}
/* }}} */
",79.0,27.0,"name:address,ce:code,property:filename,value:flow,",186.0,0.1310258746147155,Greedy
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
","void GetIntersection (uint64 seed2, uint32 length1, uint64 start2, uint64 end2, uint64 *preconnectStart, uint32 *intersectLength)
{
	uint64 end1 = seed2 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*preconnectStart = (seed2 >= start2) ? seed2 : start2;
	*intersectLength = (uint32) ((*preconnectStart > intersectEnd) ? 0 : intersectEnd + 1 - *preconnectStart);

	if (*intersectLength == 0)
		*preconnectStart = seed2;
}
",96.0,29.0,"intersectStart:preconnectStart,start1:seed2,",117.0,0.0789728164672851,Greedy
221,"mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      /* check super class */
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);

  return c;
}
","mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *secure;
  struct RClass *end;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    secure = mrb_class_ptr(super);
  }
  else {
    secure = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    end = mrb_class_ptr(old);
    if (secure) {
      /* check super class */
      if (mrb_class_real(end->super) != secure) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return end;
  }
  end = define_class(mrb, id, secure, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(end->super), end);

  return end;
}
",213.0,68.0,"c:end,s:secure,",144.0,0.1030712366104125,Greedy
226,"aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
 {
 	const struct aodv_hello *ah;
 
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;

	default:
		ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;

trunc:
	ND_PRINT((ndo, "" [|hello]""));
}
","aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
 {
 	const struct aodv_hello *oc;
 
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		oc = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*oc);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""
\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&oc->interval)));
 		break;

	default:
		ND_PRINT((ndo, ""
\text %u %u"", ep->type, ep->length));
		break;
	}
	return;

trunc:
	ND_PRINT((ndo, "" [|hello]""));
}
",132.0,22.0,"ah:oc,",139.0,0.100796886285146,GA
230,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}
","bool effect_exists(effect_context_t *central)
{
 struct listnode *parent;

    list_for_each(parent, &created_effects_list) {
 effect_context_t *fx_rtxf = node_to_item(parent,
 effect_context_t,
                                                 effects_list_node);
 if (fx_rtxf == central) {
 return true;
 }
 }
 return false;
}
",51.0,13.0,"fx_ctxt:fx_rtxf,context:central,node:parent,",114.0,0.0762328426043192,Greedy
233,"bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
 
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}
","bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* jpg,
    ExceptionState& exception_state) {
  if (!jpg || !jpg->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = jpg->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
 
   if (WouldTaintOrigin(jpg, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}
",141.0,23.0,"image:jpg,",70.0,0.0526333332061767,Greedy
259,"static int key_notify_policy_flush(const struct km_event *c)
{
	struct sk_buff *skb_out;
	struct sadb_msg *hdr;

	skb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
	if (!skb_out)
		return -ENOBUFS;
	hdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));
	hdr->sadb_msg_type = SADB_X_SPDFLUSH;
	hdr->sadb_msg_seq = c->seq;
 	hdr->sadb_msg_pid = c->portid;
 	hdr->sadb_msg_version = PF_KEY_V2;
 	hdr->sadb_msg_errno = (uint8_t) 0;
 	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
 	return 0;

}
","static int key_notify_policy_flush(const struct km_event *ci)
{
	struct sk_buff *skb_outs;
	struct sadb_msg *hdr;

	skb_outs = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
	if (!skb_outs)
		return -ENOBUFS;
	hdr = (struct sadb_msg *) skb_put(skb_outs, sizeof(struct sadb_msg));
	hdr->sadb_msg_type = SADB_X_SPDFLUSH;
	hdr->sadb_msg_seq = ci->seq;
 	hdr->sadb_msg_pid = ci->portid;
 	hdr->sadb_msg_version = PF_KEY_V2;
 	hdr->sadb_msg_errno = (uint8_t) 0;
 	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	pfkey_broadcast(skb_outs, GFP_ATOMIC, BROADCAST_ALL, NULL, ci->net);
 	return 0;

}
",136.0,27.0,"c:ci,skb_out:skb_outs,",95.0,0.0815509398778279,Greedy
282,"static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
","static void mptsas_free_request(MPTSASRequest *progress)
{
    MPTSASState *secondary = progress->dev;

    if (progress->sreq != NULL) {
        progress->sreq->hba_private = NULL;
        scsi_req_unref(progress->sreq);
        progress->sreq = NULL;
        QTAILQ_REMOVE(&secondary->pending, progress, next);
    }
    qemu_sglist_destroy(&progress->qsg);
    g_free(progress);
}
",74.0,17.0,"req:progress,s:secondary,",129.0,0.0807412187258402,Greedy
285,"static int store_xauthority(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
","static int store_xauthority(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *later = RUN_XAUTHORITY_FILE;
 	FILE *fp = fopen(later, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat n;
	if (stat(src, &n) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
		}

		copy_file_as_user(src, later, getuid(), getgid(), 0600);
		fs_logger2(""clone"", later);
		return 1; // file copied
	}
	
	return 0;
}
",162.0,36.0,"dest:later,s:n,",120.0,0.0909752408663431,Greedy
307,"   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return true;
  }
","   bool ReceiverWasAdded(const RtpTransceiverState& transporter_config) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transporter_config.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return true;
  }
",61.0,9.0,"transceiver_state:transporter_config,",18.0,0.0246887922286987,Greedy
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
","void red_channel_push(RedChannel *context)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *erck;

    if (!context) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &context->clients) {
        erck = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(erck);
    }
}
",60.0,17.0,"rcc:erck,channel:context,",93.0,0.0618457953135172,Greedy
312,"nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
	    struct nfsd4_close *close)
{
	__be32 status;
	struct nfs4_ol_stateid *stp;
	struct net *net = SVC_NET(rqstp);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);

	dprintk(""NFSD: nfsd4_close on file %pd\n"", 
			cstate->current_fh.fh_dentry);

	status = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,
					&close->cl_stateid,
					NFS4_OPEN_STID|NFS4_CLOSED_STID,
					&stp, nn);
	nfsd4_bump_seqid(cstate, status);
	if (status)
		goto out; 
	nfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);
	mutex_unlock(&stp->st_mutex);

	nfsd4_close_open_stateid(stp);

	/* put reference from nfs4_preprocess_seqid_op */
	nfs4_put_stid(&stp->st_stid);
out:
	return status;
}
","nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
	    struct nfsd4_close *close)
{
	__be32 magic;
	struct nfs4_ol_stateid *wdpp;
	struct net *net = SVC_NET(rqstp);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);

	dprintk(""NFSD: nfsd4_close on file %pd\n"", 
			cstate->current_fh.fh_dentry);

	magic = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,
					&close->cl_stateid,
					NFS4_OPEN_STID|NFS4_CLOSED_STID,
					&wdpp, nn);
	nfsd4_bump_seqid(cstate, magic);
	if (magic)
		goto out; 
	nfs4_inc_and_copy_stateid(&close->cl_stateid, &wdpp->st_stid);
	mutex_unlock(&wdpp->st_mutex);

	nfsd4_close_open_stateid(wdpp);

	/* put reference from nfs4_preprocess_seqid_op */
	nfs4_put_stid(&wdpp->st_stid);
out:
	return magic;
}
",140.0,38.0,"stp:wdpp,status:magic,",166.0,0.0980824788411458,Greedy
315,"static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  assert( zColl!=0 );
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    assert( z!=0 || pIndex->aiColumn[i]<0 );
    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){
      return 1;
    }
  }
  return 0;
}
","static int collationMatch(const char *ZColl, Index *pRow){
  int i;
  assert( ZColl!=0 );
  foi(i=0i i<pRow->nColumn; i++){
    const charez*z = pRow->azColl[i];
    assertez z!=0 || pRow->aiColumn[i]<0 );
    if( pRow->aiColumn[i]>=0 && 0==sqlite3StrICmp(ez, ZColl) ){
      return 1;
    }
  }
  return 0;
}
",98.0,22.0,"zColl:ZColl,pIndex:pRow,i:i,z:ez,",267.0,0.181826110680898,GA
316,"GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  CHECK_EQ(0, gles2_implementation_->use_count_);
}
","GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_number_;
  CHECK_EQ(0, gles2_implementation_->use_number_);
}
",24.0,4.0,"use_count_:use_number_,",19.0,0.0232325037320454,Greedy
333,"static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long flags;

	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;

		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	return 0;
}
","static int __meminit __add_zone(struct magic *magic, unsigned long phys_start_mfd)
{
	struct pglist_data *pgdat = magic->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long fd;

	zone_type = magic - pgdat->node_zones;
	if (!magic->wait_table) {
		int rets;

		rets = init_currently_empty_zone(magic, phys_start_mfd,
						nr_pages, MEMMAP_HOTPLUG);
		if (rets)
			return rets;
	}
	pgdat_resize_lock(magic->zone_pgdat, &fd);
	grow_zone_span(magic, phys_start_mfd, phys_start_mfd + nr_pages);
	grow_pgdat_span(magic->zone_pgdat, phys_start_mfd,
			phys_start_mfd + nr_pages);
	pgdat_resize_unlock(magic->zone_pgdat, &fd);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_mfd, MEMMAP_HOTPLUG);
	return 0;
}
",144.0,47.0,"zone:magic,ret:rets,phys_start_pfn:phys_start_mfd,flags:fd,",310.0,0.2029630502065022,Greedy
337,"void xmlrpc_char_encode(char *outbuffer, const char *s1)
{
	long unsigned int i;
	unsigned char c;
	char buf2[15];
	mowgli_string_t *s = mowgli_string_create();
	*buf2 = '\0';
	*outbuffer = '\0';

	if ((!(s1) || (*(s1) == '\0')))
	{
		return;
	}

	for (i = 0; s1[i] != '\0'; i++)
	{
		c = s1[i];
		if (c > 127)
		{
			snprintf(buf2, sizeof buf2, ""&#%d;"", c);
			s->append(s, buf2, strlen(buf2));
		}
		else if (c == '&')
		{
			s->append(s, ""&amp;"", 5);
		}
		else if (c == '<')
		{
			s->append(s, ""&lt;"", 4);
		}
		else if (c == '>')
		{
			s->append(s, ""&gt;"", 4);
		}
		else if (c == '""')
		{
			s->append(s, ""&quot;"", 6);
		}
		else
		{
 			s->append_char(s, c);
 		}
 	}
 
	memcpy(outbuffer, s->str, XMLRPC_BUFSIZE);
 }
","void xmlrpc_char_encode(char *workqueue, const char *SOne)
{
	long unsigned int ie;
	unsigned char c;
	char seq1[15];
	mowgli_string_t *sb = mowgli_string_create();
	*seq1 = '\0';
	*workqueue = '\0';

	if ((!(SOne) || (*(SOne) == '\0')))
	{
		return;
	}

	for (ie = 0; SOne[ie] != '\0'; ie++)
	{
		c = SOne[ie];
		if (c > 127)
		{
			snprintf(seq1, sizeof seq1, ""&#%d;"", c);
			sb->append(sb, seq1, strlen(seq1));
		}
		else if (c == '&')
		{
			sb->append(sb, ""&amp;"", 5);
		}
		else if (c == '<')
		{
			sb->append(sb, ""&lt;"", 4);
		}
		else if (c == '>')
		{
			sb->append(sb, ""&gt;"", 4);
		}
		else if (c == '""')
		{
			sb->append(sb, ""&quot;"", 6);
		}
		else
		{
 			sb->append_char(sb, c);
 		}
 	}
 
	memcpy(workqueue, sb->str, XMLRPC_BUFSIZE);
 }
",248.0,48.0,"outbuffer:workqueue,s1:SOne,buf2:seq1,i:ie,s:sb,",280.0,0.208964463075002,Greedy
345,"struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)
{
	static struct in6_addr prefix;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);

	memset(&prefix, 0, sizeof(prefix));
	memcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}
","struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int pointer)
{
	static struct in6_addr len;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, pointer);

	memset(&len, 0, sizeof(len));
	memcpy(&len, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);
	return &len;
}
",70.0,16.0,"prefix:len,offset:pointer,",99.0,0.0647318998972574,Greedy
348,"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_report_cipher(struct sk_buff *kibar, struct crypto_alg *ael)
 {
 	struct crypto_report_cipher ncairo;
 
	snprintf(ncairo.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
 
 	ncairo.blocksize = ael->cra_blocksize;
 	ncairo.min_keysize = ael->cra_cipher.cia_min_keysize;
	ncairo.max_keysize = ael->cra_cipher.cia_max_keysize;

	if (nla_put(kibar, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &ncairo))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",93.0,18.0,"skb:kibar,alg:ael,rcipher:ncairo,",165.0,0.11167018810908,Greedy
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
","static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t ment;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	ment = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(ment) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
",114.0,30.0,"mant:ment,",68.0,0.0409839948018391,Greedy
357,"bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}
","bool BaseAudioContext::WouldTaintOrigin(const KURL& name) const {
  if (name.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(name);
  }
  return true;
}
",62.0,9.0,"url:name,",56.0,0.0363697409629821,Greedy
361,"static void webkitWebViewBaseContainerAdd(GtkContainer* container, GtkWidget* widget)
{
    WebKitWebViewBase* webView = WEBKIT_WEB_VIEW_BASE(container);
    WebKitWebViewBasePrivate* priv = webView->priv;

    if (WEBKIT_IS_WEB_VIEW_BASE(widget)
         && WebInspectorProxy::isInspectorPage(WEBKIT_WEB_VIEW_BASE(widget)->priv->pageProxy.get())) {
         ASSERT(!priv->inspectorView);
         priv->inspectorView = widget;
        priv->inspectorViewHeight = gMinimumAttachedInspectorHeight;
     } else {
         GtkAllocation childAllocation;
         gtk_widget_get_allocation(widget, &childAllocation);
        priv->children.set(widget, childAllocation);
    }

    gtk_widget_set_parent(widget, GTK_WIDGET(container));
}
","static void webkitWebViewBaseContainerAdd(GtkContainer* flow, GtkWidget* widget)
{
    WebKitWebViewBase* WebContainer = WEBKIT_WEB_VIEW_BASE(flow);
    WebKitWebViewBasePrivate* auth = WebContainer->auth;

    if (WEBKIT_IS_WEB_VIEW_BASE(widget)
         && WebInspectorProxy::isInspectorPage(WEBKIT_WEB_VIEW_BASE(widget)->auth->pageProxy.get())) {
         ASSERT(!auth->inspectorView);
         auth->inspectorView = widget;
        auth->inspectorViewHeight = gMinimumAttachedInspectorHeight;
     } else {
         GtkAllocation childAllocation;
         gtk_widget_get_allocation(widget, &childAllocation);
        auth->children.set(widget, childAllocation);
    }

    gtk_widget_set_parent(widget, GTK_WIDGET(flow));
}
",113.0,30.0,"webView:WebContainer,container:flow,priv:auth,",148.0,0.1102356870969136,Greedy
364,"void acpi_os_printf(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	acpi_os_vprintf(fmt, args);
	va_end(args);
}
","void acpi_os_printf(const char *fwd, ...)
{
	va_list this;
	va_start(this, fwd);
	acpi_os_vprintf(fwd, this);
	va_end(this);
}
",34.0,11.0,"args:this,fmt:fwd,",100.0,0.0678490837415059,Greedy
370,"char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}
","char *path_name(const struct name_path *next, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = next; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = next; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}
",159.0,44.0,"path:next,",75.0,0.0644201715787251,Greedy
373,"cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}
","cJSON *cJSON_DetachItemFromArray( cJSON *cache, int sort )
{
	cJSON *ce = cache->child;
	while ( ce && sort > 0 ) {
		ce = ce->next;
		--sort;
	}
	if ( ! ce )
		return 0;
	if ( ce->prev )
		ce->prev->next = ce->next;
	if ( ce->next ) ce->next->prev = ce->prev;
	if ( ce == cache->child )
		cache->child = ce->next;
	ce->prev = ce->next = 0;
	return ce;
}
",109.0,24.0,"which:sort,array:cache,c:ce,",203.0,0.1287392059961954,Greedy
377,"void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}
","void WebContentsImpl::OnDidDownloadImage(
    int ident,
    int http_status_time,
    const GURL& image_url,
    int requested_capacity,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(ident);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(ident, http_status_time, image_url, requested_capacity, bitmaps);
  }
  image_download_map_.erase(ident);
}
",94.0,20.0,"requested_size:requested_capacity,id:ident,http_status_code:http_status_time,",95.0,0.0821380575497945,Greedy
383,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
","AtomicString GetInputModeAttribute(Element* present) {
  if (!present)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*present)) {
    query_attribute = toHTMLInputElement(*present).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*present)) {
    query_attribute = true;
  } else {
    present->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*present))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return present->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
",110.0,21.0,"element:present,",72.0,0.0510835528373718,Greedy
389,"static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *request = (fcgi_request*) SG(server_context);

	count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}
","static int sapi_fcgi_read_post(char *duration, uint count__steps TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_write_bits;
	fcgi_request *client = (fcgi_request*) SG(server_context);

	count__steps = MIN(count__steps, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count__steps) {
		tmptmp_write_bitsfcgi_read(reqclienturation + read_bytes, count__steps - read_bytes);
		if (tmp_write_bits <= 0) {
			break;
		}
		read_bytes += tmp_write_bits;
	}
	return read_bytes;
}
",97.0,29.0,"buffer:duration,count_bytes:count__steps,tmp_read_bytes:tmp_write_bits,request:client,",232.0,0.1922411243120829,GA
393,"inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}
","inline void DialogHandler::dialogCreated(DOMWindow* dialogueWindow)
{
    m_dialogContext = dialogueWindow->frame() ? dialogueWindow->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}
",96.0,12.0,"dialogFrame:dialogueWindow,",67.0,0.0544277826944986,Greedy
396,"void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {
    size_t len = 0;

    /* First step: count keys into table. No other way to do it with the
      * Lua API, we need to iterate a first time. Note that an alternative
      * would be to do a single run, and then hack the buffer to insert the
      * map opcodes for message pack. Too hackish for this lib. */
     lua_pushnil(L);
     while(lua_next(L,-2)) {
         lua_pop(L,1); /* remove value, keep key for next iteration. */
        len++;
    }

    /* Step two: actually encoding of the map. */
    mp_encode_map(L,buf,len);
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        /* Stack: ... key value */
        lua_pushvalue(L,-2); /* Stack: ... key value key */
        mp_encode_lua_type(L,buf,level+1); /* encode key */
        mp_encode_lua_type(L,buf,level+1); /* encode val */
    }
}
","void mp_encode_lua_table_as_map(lua_State *X, mp_buf *cv, int val) {
    size_t val = 0;

    /* First step: count keys into table. No other way to do it with the
      * Lua API, we need to iterate a first time. Note that an alternative
      * would be to do a single run, and then hack the buffer to insert the
      * map opcodes for message pack. Too hackish for this lib. */
     lua_pushnil(X);
     while(lua_next(X,-2)) {
         lua_pop(X,1); /* remove value, keep key for next iteration. */
        val++;
    }

    /* Step two: actually encoding of the map. */
    mp_encode_map(X,cv,val);
    lua_pushnil(X);
    while(lua_next(X,-2)) {
        /* Stack: ... key value */
        lua_pushvalue(X,-2); /* Stack: ... key value key */
        mp_encode_lua_type(X,cv,val+1); /* encode key */
        mp_encode_lua_type(X,cv,val+1); /* encode val */
    }
}
",101.0,30.0,"level:val,len:val,buf:cv,L:X,",212.0,0.1433828910191854,Greedy
406,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
 
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
 
         return TRUE;
 }
","get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *graph;
        PolkitSubject *ctx;
 
        graph = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        ctx = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (graph), NULL, NULL);
        if (!ctx) {
                g_object_unref (graph);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (ctx));
        g_object_unref (graph);
        g_object_unref (ctx);
 
         return TRUE;
 }
",83.0,24.0,"subject:graph,process:ctx,",128.0,0.0917627135912577,Greedy
421,"map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (idx = 0; idx < extents; idx++) {
		first = map->extent[idx].first;
		last = first + map->extent[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[idx];
	}
	return NULL;
}
","map_id_range_down_base(unsigned extents, struct uid_gid_map *data, cu4 id, cu4 count)
{
	unsigned indX;
	cu4 second, code, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (indX = 0; indX < extents; indX++) {
		fsecond= data->extent[iindX.second;
		lacode fsecond+ data->extent[indX].count - 1;
		if (id >= second && id <= code &&
		    (iid2>= second && id2 <= code))
			return &data->extent[indX];
	}
	return NULL;
}
",109.0,33.0,"map:data,u32:cu4,first:second,last:code,id2:id2,idx:indX,",367.0,0.2563131014506022,GA
424," void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(error);
 
     clear();
 }
"," void RTCSessionDescriptionRequestImpl::requestFailed(const String& o)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(o);
 
     clear();
 }
",27.0,6.0,"error:o,",46.0,0.0312268098195393,Greedy
426,"static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if DEBUG
	void *next = *list;
	void *objp;

	while (next) {
		objp = next - obj_offset(cachep);
		next = *(void **)next;
		poison_obj(cachep, objp, POISON_FREE);
	}
#endif
}
","static inline void fixup_objfreelist_debug(struct kmem_cache *cookiep,
						void **parent)
{
#if DEBUG
	void *nepointer *parent;
	void *bootf;

	while (pointer) {
		objpbootfpointer- obj_offset(cookiep);
		pointer = *(void **)pointer;
		poison_obj(cookiep, bootf, POISON_FREE);
	}
#endif
}
",66.0,18.0,"cachep:cookiep,list:parent,next:pointer,objp:bootf,",464.0,0.3321997841199239,GA
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
","GahpServer::RemoveGahpClient()
{
	m_reference_handle--;

	if ( m_reference_handle <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
",44.0,7.0,"m_reference_count:m_reference_handle,",19.0,0.0236470897992451,Greedy
443,"static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
","static int entersafe_process_fci(struct sc_card *code, struct sc_file *current,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(current);
	 SC_FUNC_CALLED(code->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(code,current,buf,buflen);
	 SC_TEST_RET(code->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(current->namelen)
	 {
		  current->type = SC_FILE_TYPE_DF;
		  current->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  current->type = SC_FILE_TYPE_WORKING_EF;
		  current->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(code->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
",116.0,34.0,"file:current,card:code,",150.0,0.106395673751831,Greedy
449,"void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, context);

  int policy = net::OK;
  if (context->cookie_policy()) {
    policy = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}
","void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* component = GetRequestContextForURL(url);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, component);

  int policy = net::OK;
  if (component->cookie_policy()) {
    policy = component->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}
",109.0,24.0,"context:component,",72.0,0.059829036394755,Greedy
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
","void AXObjectCacheImpl::handleAriaSelectedChanged(Node* native) {
  AXObject* parent = get(native);
  if (!parent)
    return;

  postNotification(parent, AXCheckedStateChanged);

  AXObject* listbox = parent->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
",63.0,17.0,"node:native,obj:parent,",99.0,0.0705994447072347,Greedy
458," bool ClipboardUtil::HasFilenames(IDataObject* data_object) {
   DCHECK(data_object);
  return HasData(data_object, Clipboard::GetCFHDropFormatType());
 }
"," bool ClipboardUtil::HasFilenames(IDataObject* data_article) {
   DCHECK(data_article);
  return HasData(data_article, Clipboard::GetCFHDropFormatType());
 }
",28.0,7.0,"data_object:data_article,",18.0,0.0241084218025207,Greedy
460,"void ptrace_triggered(struct perf_event *bp, int nmi,
 		      struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct perf_event_attr attr;

	/*
	 * Disable the breakpoint request here since ptrace has defined a
	 * one-shot behaviour for breakpoint exceptions in PPC64.
	 * The SIGTRAP signal is generated automatically for us in do_dabr().
	 * We don't have to do anything about that here
	 */
	attr = bp->attr;
	attr.disabled = true;
	modify_user_hw_breakpoint(bp, &attr);
}
","void ptrace_triggered(struct perf_event *br, int nmi,
 		      struct perf_sample_data *data, struct pt_regs * regps)
 {
 	struct perf_event_attr attr;

	/*
	 * Disable the breakpoint request here since ptrace has defined a
	 * one-shot behaviour for breakpoint exceptions in PPC64.
	 * The SIGTRAP signal is generated automatically for us in do_dabr().
	 * We don't have to do anything about that here
	 */
	attr = br->attr;
	attr.disabled = true;
	modify_user_hw_breakpoint(br, &attr);
}
",47.0,12.0,"bp:br,regs: regps,",69.0,0.0521041472752889,Greedy
462,"int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
","int main(int startcat, char *axargs[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat ct;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &ct);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
",228.0,60.0,"argv:axargs,argc:startcat,sb:ct,",95.0,0.0903056224187215,Greedy
463,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *s;
 
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }
","parse_field(netdissect_options *ndo, const char ** ppler, int *fat)
 {
     const char *less;
 
    if (*fat <= 0 || ! ppler || !* ppler)
	return NULL;
    if (* ppler > (const char *) ndo->ndo_snapend)
	return NULL;
     less = * ppler;
    while (* ppler <= (const char *) ndo->ndo_snapend && *fat >= 0 && ** ppler) {
 	(* ppler)++;
 	(*fat)--;
     }
     (* ppler)++;
     (*fat)--;
    if (*fat < 0 || * ppler > (const char *) ndo->ndo_snapend)
	return NULL;
     return less;
 }
",136.0,24.0,"s:less,len:fat,pptr: ppler,",222.0,0.1416078925132751,Greedy
464,"cib_remote_dispatch(gpointer user_data)
 {
     cib_t *cib = user_data;
     cib_remote_opaque_t *private = cib->variant_opaque;
 
     xmlNode *msg = NULL;
    const char *type = NULL;
 
     crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);
 
    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);
 
    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(cib, msg, 0, 0);
 
    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(cib->notify_list, cib_native_notify, msg);
 
    } else {
        crm_err(""Unknown message type: %s"", type);
    }
 
    if (msg != NULL) {
         free_xml(msg);
        return 0;
     }
    return -1;
 }
","cib_remote_dispatch(gpointer user_data)
 {
     cib_t *fib = user_data;
     cib_remote_opaque_t *game = fib->variant_opaque;
 
     xmlNode *msg = NULL;
    const char *type = NULL;
 
     crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(game->callback.session, game->callback.encrypted);
 
    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);
 
    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(fib, msg, 0, 0);
 
    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(fib->notify_list, cib_native_notify, msg);
 
    } else {
        crm_err(""Unknown message type: %s"", type);
    }
 
    if (msg != NULL) {
         free_xml(msg);
        return 0;
     }
    return -1;
 }
",149.0,37.0,"private:game,cib:fib,",109.0,0.0869423667589823,Greedy
470,"static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)
{
	int i;
	UINT32 length;
	UINT32 tempWidth;
	UINT32 tempHeight;
	tempWidth = ROUND_UP_TO(context->width, 8);
	tempHeight = ROUND_UP_TO(context->height, 2);
	/* The maximum length a decoded plane can reach in all cases */
	length = tempWidth * tempHeight + 16;

	if (length > context->priv->PlaneBuffersLength)
	{
 		for (i = 0; i < 5; i++)
 		{
 			BYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);
 			if (!tmp)
 				goto fail;
 
			context->priv->PlaneBuffers[i] = tmp;
		}

		context->priv->PlaneBuffersLength = length;
	}

	if (context->ChromaSubsamplingLevel)
	{
		context->OrgByteCount[0] = tempWidth * context->height;
		context->OrgByteCount[1] = tempWidth * tempHeight / 4;
		context->OrgByteCount[2] = tempWidth * tempHeight / 4;
		context->OrgByteCount[3] = context->width * context->height;
	}
	else
	{
		context->OrgByteCount[0] = context->width * context->height;
		context->OrgByteCount[1] = context->width * context->height;
		context->OrgByteCount[2] = context->width * context->height;
		context->OrgByteCount[3] = context->width * context->height;
	}

	return TRUE;
fail:

	if (length > context->priv->PlaneBuffersLength)
	{
		for (i = 0; i < 5; i++)
			free(context->priv->PlaneBuffers[i]);
	}

 	return FALSE;
 }
","static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)
{
	int i;
	UINT32 length;
	UINT32 tempWidth;
	UINT32 tempHeight;
	tempWidth = ROUND_UP_TO(context->width, 8);
	tempHeight = ROUND_UP_TO(context->height, 2);
	/* The maximum length a decoded plane can reach in all cases */
	length = tempWidth * tempHeight + 16;

	if (length > context->priv->PlaneBuffersLength)
	{
 		for (i = 0; i < 5; i++)
 		{
 			BYTE* xxxx = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);
 			if (!xxxx)
 				goto fail;
 
			context->priv->PlaneBuffers[i] = xxxx;
		}

		context->priv->PlaneBuffersLength = length;
	}

	if (context->ChromaSubsamplingLevel)
	{
		context->OrgByteCount[0] = tempWidth * context->height;
		context->OrgByteCount[1] = tempWidth * tempHeight / 4;
		context->OrgByteCount[2] = tempWidth * tempHeight / 4;
		context->OrgByteCount[3] = context->width * context->height;
	}
	else
	{
		context->OrgByteCount[0] = context->width * context->height;
		context->OrgByteCount[1] = context->width * context->height;
		context->OrgByteCount[2] = context->width * context->height;
		context->OrgByteCount[3] = context->width * context->height;
	}

	return TRUE;
fail:

	if (length > context->priv->PlaneBuffersLength)
	{
		for (i = 0; i < 5; i++)
			free(context->priv->PlaneBuffers[i]);
	}

 	return FALSE;
 }
",298.0,64.0,"tmp:xxxx,",117.0,0.1071151653925577,Greedy
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
","PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * parent = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	parent = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (parent) {
		RETVAL_BOOL(X509_check_private_key(cert, parent));
	}

	if (keyresource == -1 && parent) {
		EVP_PKEY_free(parent);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
",150.0,39.0,"key:parent,",88.0,0.0765946507453918,Greedy
481,"static SharedMemorySupport DoQuerySharedMemorySupport(Display* dpy) {
  int dummy;
  Bool pixmaps_supported;
  if (!XShmQueryVersion(dpy, &dummy, &dummy, &pixmaps_supported))
    return SHARED_MEMORY_NONE;

#if defined(OS_FREEBSD)
  int allow_removed;
  size_t length = sizeof(allow_removed);

  if ((sysctlbyname(""kern.ipc.shm_allow_removed"", &allow_removed, &length,
      NULL, 0) < 0) || allow_removed < 1) {
    return SHARED_MEMORY_NONE;
  }
 #endif
 
  int shmkey = shmget(IPC_PRIVATE, 1, 0666);
  if (shmkey == -1)
     return SHARED_MEMORY_NONE;
   void* address = shmat(shmkey, NULL, 0);
   shmctl(shmkey, IPC_RMID, NULL);

  XShmSegmentInfo shminfo;
  memset(&shminfo, 0, sizeof(shminfo));
  shminfo.shmid = shmkey;
 
   gdk_error_trap_push();
   bool result = XShmAttach(dpy, &shminfo);
   XSync(dpy, False);
   if (gdk_error_trap_pop())
     result = false;
   shmdt(address);
  if (!result)
     return SHARED_MEMORY_NONE;
 
   XShmDetach(dpy, &shminfo);
   return pixmaps_supported ? SHARED_MEMORY_PIXMAP : SHARED_MEMORY_PUTIMAGE;
}
","static SharedMemorySupport DoQuerySharedMemorySupport(Display* adgb) {
  int foo;
  Bool pixmaps___support;
  if (!XShmQueryVersion(adgb, &foo, &foo, &pixmaps___support))
    return SHARED_MEMORY_NONE;

#if defined(OS_FREEBSD)
  int allow_REModed;
  size_t length = sizeof(allow_REModed);

  if ((sysctlbyname(""kern.ipc.shm_allow_removed"", &allow_REModed, &length,
      NULL, 0) < 0) || allow_REModed < 1) {
    return SHARED_MEMORY_NONE;
  }
 #endif
 
  int shmkey = shmget(IPC_PRIVATE, 1, 0666);
  if (shmkey == -1)
     return SHARED_MEMORY_NONE;
   void* route = shmat(shmkey, NULL, 0);
   shmctl(shmkey, IPC_RMID, NULL);

  XShmSegmentInfo shminxy;
  memset(&shminxy, 0, sizeof(shminxy));
  shminxy.shmid = shmkey;
 
   gdk_error_trap_push();
   bool result = XShmAttach(adgb, &shminxy);
   XSync(adgb, False);
   if (gdk_error_trap_pop())
     result = false;
   shmdt(route);
  if (!result)
     return SHARED_MEMORY_NONE;
 
   XShmDetach(adgb, &shminxy);
   return pixmaps___support ? SHARED_MEMORY_PIXMAP : SHARED_MEMORY_PUTIMAGE;
}
",210.0,56.0,"dpy:adgb,allow_removed:allow_REModed,address:route,dummy:foo,pixmaps_supported:pixmaps___support,shminfo:shminxy,",322.0,0.244152295589447,Greedy
482,"static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;

	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {

		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		zea = details->last_index;
		if (zea > vea)
			zea = vea;

		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}
","static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *resolution)
{
	struct vm_area_struct *vna;
	pgoff_t svva,  veu, jva, zea;

	vma_interval_tree_foreach(vna, root,
			resolution->first_index, resolution->last_index) {

		svva = vna->vm_pgoff;
		 veu = svva + vma_pages(vna) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		jva = resolution->first_index;
		if (jva < svva)
			jva = svva;
		zea = resolution->last_index;
		if (zea >  veu)
			zea =  veu;

		unmap_mapping_range_vma(vna,
			((jva - svva) << PAGE_SHIFT) + vna->vm_start,
			((zea - svva + 1) << PAGE_SHIFT) + vna->vm_start,
				resolution);
	}
}
",134.0,42.0,"details:resolution,vea: veu,vba:svva,zba:jva,vma:vna,",309.0,0.2112005432446797,Greedy
487,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}
","PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData zip;
  zip.password_form = form;
  zip.generation_element = ASCIIToUTF16(""testelement2"");
  zip.max_length = 11;
  return zip;
}
",71.0,15.0,"data:zip,",75.0,0.0518208622932434,Greedy
498,"PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */
{
	const char *endptr = val + vallen;
	zval *session_vars;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	ALLOC_INIT_ZVAL(session_vars);
        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		array_init(session_vars);
	}
	PS(http_session_vars) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);
	return SUCCESS;
}
/* }}} */
","PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */
{
	const char *zPtr = val + vallen;
	zval *session_vars;
	php_unserialize_data_t vari2type;

	PHP_VAR_UNSERIALIZE_INIT(vari2type);
	ALLOC_INIT_ZVAL(session_vars);
        if (php_var_unserialize(&session_vars, &val, zPtr, &vari2type TSRMLS_CC)) {
                var_push_dtor(&vari2type, &session_vars);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(vari2type);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		array_init(session_vars);
	}
	PS(http_session_vars) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);
	return SUCCESS;
}
/* }}} */
",138.0,41.0,"endptr:zPtr,var_hash:vari2type,",91.0,0.0708873430887858,Greedy
509,"  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
 
     ImePropertyList prop_list;  // our representation.
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }
","  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
 
     ImePropertyList  prop_lists;  // our representation.
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, & prop_lists)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_,  prop_lists);
  }
",63.0,14.0,"prop_list: prop_lists,",34.0,0.0264155546824137,Greedy
521,"void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {
}
","void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* ram, int port) {
}
",14.0,3.0,"type:port,param:ram,",58.0,0.040420921643575,Greedy
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }
"," static bool HasElementImpl(Isolate* isolation, Handle<JSObject> reader,
 uint32_t pointer,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolation, *reader, *backing_store,
                                          pointer, filter) != kMaxUInt32;
 }
",50.0,14.0,"holder:reader,index:pointer,isolate:isolation,",110.0,0.0792415817578633,Greedy
553,"void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}
","void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType version, Clipboard::Buffer feed,
    IPC::Message* object) {
  const bool result = GetClipboard()->IsFormatAvailable(version, feed);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(object, result);
  Send(object);
}
",52.0,13.0,"buffer:feed,format:version,reply:object,",124.0,0.0878425280253092,Greedy
558," virtual void ResetModel() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;

     tot_frame_number_ = 0;
     first_drop_ = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }
"," virtual void ResetModel() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;

     tot_frame_number_ = 0;
     first_drop_ = 0;
     num_drops_ = 0;
     for (int ii = 0; ii < 3; ++ii) {
       bits_total_[ii] = 0;
     }
   }
",60.0,14.0,"i:ii,",65.0,0.0504995584487915,Greedy
563,"  void SetMetrics(OomInterventionMetrics metrics) {
    metrics_ = std::make_unique<OomInterventionMetrics>();
    *metrics_ = metrics;
  }
","  void SetMetrics(OomInterventionMetrics Metrices) {
    metrics_ = std::make_unique<OomInterventionMetrics>();
    *metrics_ = Metrices;
  }
",24.0,6.0,"metrics:Metrices,",33.0,0.0293272018432617,Greedy
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}
","static void close_table_device(struct table_device *fd, struct mapped_device *md)
{
	if (!fd->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(fd->dm_dev.bdev, dm_disk(md));
	blkdev_put(fd->dm_dev.bdev, fd->dm_dev.mode | FMODE_EXCL);
	put_dax(fd->dm_dev.dax_dev);
	fd->dm_dev.bdev = NULL;
	fd->dm_dev.dax_dev = NULL;
}
",83.0,16.0,"td:fd,",67.0,0.0379048268000284,Greedy
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
","void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_feture) {
  for (auto end = token_fetchers_.begin(); end != token_fetchers_.end(); ++end) {
    if (end->get() == token_feture) {
      token_fetchers_.erase(end);
      return;
    }
  }
  NOTREACHED();
}
",60.0,12.0,"it:end,token_fetcher:token_feture,",102.0,0.0548790017763773,Greedy
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
","void setAnimationUpdateIfNeeded(StyleResolverState& code, Element& section)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && code.animationUpdate())
        section.ensureActiveAnimations()->cssAnimations().setPendingUpdate(code.takeAnimationUpdate());
}
",46.0,7.0,"state:code,element:section,",91.0,0.047408902645111,Greedy
601,"static void lg_remove(struct hid_device *hdev)
{
	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
	if (drv_data->quirks & LG_FF4)
		lg4ff_deinit(hdev);

	hid_hw_stop(hdev);
	kfree(drv_data);
}
","static void lg_remove(struct hid_device *hdev)
{
	struct lg_drv_data *drvalldata = hid_get_drvdata(hdev);
	if (drvalldata->quirks & LG_FF4)
		lg4ff_deinit(hdev);

	hid_hw_stop(hdev);
	kfree(drvalldata);
}
",44.0,13.0,"drv_data:drvalldata,",36.0,0.025969394048055,Greedy
604,"static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;

	ovl_path_real(dentry, &realpath);
	realinode = realpath.dentry->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&realpath);

	return realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
}
","static int ovl_readlink(struct lreader *lreader, char __user *buf, int bufsiz)
{
	struct path complexlength;
	struct inode *realinode;

	ovl_path_real(lreader, &complexlength);
	realinode = complexlength.lreader->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&complexlength);

	return realinode->i_op->readlink(complexlength.lreader, buf, bufsiz);
}
",79.0,20.0,"realpath:complexlength,dentry:lreader,",121.0,0.0625330130259196,Greedy
607,"void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}
","void AXObject::tokenVectorFromAttribute(Vector<String>& Tokenkens,
                                        const QualifiedName& component) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = getAttribute(component).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', Tokenkens);
}
",82.0,13.0,"tokens:Tokenkens,attribute:component,",91.0,0.0526252349217732,Greedy
609,"void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}
","void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& create) {
  int socket_id = create.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}
",62.0,15.0,"id:create,",48.0,0.0363561550776163,Greedy
618," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int ret;
 
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }
"," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int fun;
 
 	fun = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (fun < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, fun);
 	return fun;
 }
",80.0,23.0,"ret:fun,",72.0,0.0505946040153503,Greedy
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
","static int acm_tty_put_char(struct tty_struct *sth, unsigned char och)
{
	struct akcm *akcm = sth->driver_data;
	struct acm_wb *input;
	int fwbn;
	unsigned long fd;

overflow:
	input = akcm->putbuffer;
	if (!input) {
		spin_lock_irqsave(&akcm->write_lock, fd);
		fwbn = acm_wb_alloc(akcm);
		if (fwbn >= 0) {
			input = &akcm->wb[fwbn];
			akcm->putbuffer = input;
		}
		spin_unlock_irqrestore(&akcm->write_lock, fd);
		if (!input)
			return 0;
	}

	if (input->len == akcm->writesize) {
		acm_tty_flush_chars(sth);
		goto overflow;
	}

	input->buf[input->len++] = och;
	return 1;
}
",145.0,34.0,"cur:input,acm:akcm,ch:och,wbn:fwbn,tty:sth,flags:fd,",399.0,0.2558787782986959,Greedy
627,"void DownloadResourceHandler::OnRequestRedirected(
    const net::RedirectInfo& redirect_info,
    network::ResourceResponse* response,
    std::unique_ptr<ResourceController> controller) {
  url::Origin new_origin(url::Origin::Create(redirect_info.new_url));
  if (!follow_cross_origin_redirects_ &&
      !first_origin_.IsSameOriginWith(new_origin)) {
    base::PostTaskWithTraits(
        FROM_HERE, {BrowserThread::UI},
        base::BindOnce(
            &NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),
            Referrer(GURL(redirect_info.new_referrer),
                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(
                          redirect_info.new_referrer_policy)),
             GetRequestInfo()->HasUserGesture(),
            GetRequestInfo()->GetWebContentsGetterForRequest()));
     controller->Cancel();
     return;
   }
  if (core_.OnRequestRedirected()) {
    controller->Resume();
  } else {
    controller->Cancel();
  }
}
","void DownloadResourceHandler::OnRequestRedirected(
    const net::RedirectInfo& redirectioningInfo,
    network::ResourceResponse* http,
    std::unique_ptr<ResourceController> roller) {
  url::Origin new_origin(url::Origin::Create(redirectioningInfo.new_url));
  if (!follow_cross_origin_redirects_ &&
      !first_origin_.IsSameOriginWith(new_origin)) {
    base::PostTaskWithTraits(
        FROM_HERE, {BrowserThread::UI},
        base::BindOnce(
            &NavigateOnUIThread, redirectioningInfo.new_url, request()->url_chain(),
            Referrer(GURL(redirectioningInfo.new_referrer),
                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(
                          redirectioningInfo.new_referrer_policy)),
             GetRequestInfo()->HasUserGesture(),
            GetRequestInfo()->GetWebContentsGetterForRequest()));
     roller->Cancel();
     return;
   }
  if (core_.OnRequestRedirected()) {
    roller->Resume();
  } else {
    roller->Cancel();
  }
}
",161.0,28.0,"response:http,redirect_info:redirectioningInfo,controller:roller,",146.0,0.1097601731618245,Greedy
629,"void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& frame_metadata) {
  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (rwhv)
    rwhv->SynchronousFrameMetadata(frame_metadata);
  DeliverMessages();
}
","void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& framealmetadata) {
  RenderWidgetHostViewAndroid* rswl = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (rswl)
    rswl->SynchronousFrameMetadata(framealmetadata);
  DeliverMessages();
}
",46.0,9.0,"rwhv:rswl,frame_metadata:framealmetadata,",74.0,0.05617196559906,Greedy
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
","static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq2context = aead_request_ctx(req);
	struct ahash_request *ahprogress = (void *)(areq2context->tail + ctx->reqoff);
	u8 *secret = areq2context->tail;
	int err;

	secret = (u8 *)ALIGN((unsigned long)secret + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahprogress, auth);
	ahash_request_set_crypt(ahprogress, areq2context->sg, secret,
				areq2context->cryptlen);
	ahash_request_set_callback(ahprogress, aead_request_flags(req) & flags,
				   areq2context->complete, req);

	err = crypto_ahash_digest(ahprogress);
	if (err)
		return ERR_PTR(err);

	return secret;
}
",172.0,49.0,"areq_ctx:areq2context,hash:secret,ahreq:ahprogress,",182.0,0.138804809252421,Greedy
637,"void Vp9Parser::ReadSegmentationMap() {
   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;
   }
 
   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;
 
  segmentation_.temporal_update = reader_.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {
       if (reader_.ReadBool())
        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);
     }
   }
 }
","void Vp9Parser::ReadSegmentationMap() {
   for (size_t oi = 0; oi < Vp9Segmentation::kNumTreeProbs; oi++) {
    segmentation_.tree_probs[oi] =
         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;
   }
 
   for (size_t oi = 0; oi < Vp9Segmentation::kNumPredictionProbs; oi++)
    segmentation_.pred_probs[oi] = kVp9MaxProb;
 
  segmentation_.temporal_update = reader_.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t oi = 0; oi < Vp9Segmentation::kNumPredictionProbs; oi++) {
       if (reader_.ReadBool())
        segmentation_.pred_probs[oi] = reader_.ReadLiteral(8);
     }
   }
 }
",131.0,28.0,"i:oi,",90.0,0.0557342052459716,Greedy
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
","struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *py = sk_alloc(net, family, priority, prot, kern);

	if (!py)
		goto out;
	llc_sk_init(py);
	sock_init_data(NULL, py);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", py,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return py;
}
",96.0,28.0,"sk:py,",79.0,0.0646184126536051,Greedy
658," bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
                                                           const GURL& url) {
   if (!url.is_valid())
    return false;  // Can't set invalid URLs as origin headers.

  if (url == kAboutSrcDocURL)
    return false;
 
  if (CanCommitURL(child_id, url))
     return true;
 
  {
    base::AutoLock lock(lock_);
    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
                          url.scheme())) {
      return true;
    }
  }
  return false;
}
"," bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int childDocids,
                                                           const GURL& ob) {
   if (!ob.is_valid())
    return false;  // Can't set invalid URLs as origin headers.

  if (ob == kAboutSrcDocURL)
    return false;
 
  if (CanCommitURL(childDocids, ob))
     return true;
 
  {
    base::AutoLock lock(lock_);
    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
                          ob.scheme())) {
      return true;
    }
  }
  return false;
}
",81.0,13.0,"child_id:childDocids,url:ob,",77.0,0.0568966031074523,Greedy
661,"void InspectorPageAgent::Did(const probe::UpdateLayout&) {
  PageLayoutInvalidated(false);
}
","void InspectorPageAgent::Did(const probe::UpdatedSlot&) {
  PageLayoutInvalidated(false);
}
",18.0,2.0,"UpdateLayout:UpdatedSlot,",15.0,0.0221874078114827,Greedy
663,"void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& origin, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    task.Run();
    return;
  }

  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;

  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }
","void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& queue, FileSystemType type,
    const base::Closure& tag,
    const base::Closure&  error_cb) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    tag.Run();
    return;
  }

  TaskParamsForDidGetQuota params;
  params.queue = queue;
  params.type = type;
  params.tag = tag;
  params. error_cb =  error_cb;

  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       queue,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }
",151.0,34.0,"task:tag,error_callback: error_cb,origin:queue,",143.0,0.1026892264684041,Greedy
667,"  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)
      : frame_(std::move(frame)) {}
","  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> code)
      : frame_(std::player(code)) {}
",23.0,4.0,"frame:code,move:player,",72.0,0.0527323444684346,Greedy
670,"rx_cache_insert(netdissect_options *ndo,
                const u_char *bp, const struct ip *ip, int dport)
{
	struct rx_cache_entry *rxent;
	const struct rx_header *rxh = (const struct rx_header *) bp;

	if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;

	rxent = &rx_cache[rx_cache_next];

	if (++rx_cache_next >= RX_CACHE_SIZE)
		rx_cache_next = 0;

	rxent->callnum = EXTRACT_32BITS(&rxh->callNumber);
 	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
 	rxent->dport = dport;
	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
 }
","rx_cache_insert(netdissect_options *ndo,
                const u_char *bp, const struct ip *ip, int dport)
{
	struct rx_cache_entry *xenc;
	const struct rx_header *txc = (const struct rx_header *) bp;

	if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;

	xenc = &rx_cache[rx_cache___next];

	if (++rx_cache___next >= RX_CACHE_SIZE)
		rx_cache___next = 0;

	xenc->callnum = EXTRACT_32BITS(&txc->callNumber);
 	UNALIGNED_MEMCPY(&xenc->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&xenc->server, &ip->ip_dst, sizeof(uint32_t));
 	xenc->dport = dport;
	xenc->serviceId = EXTRACT_32BITS(&txc->serviceId);
 	xenc->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
 }
",169.0,33.0,"rxh:txc,rx_cache_next:rx_cache___next,rxent:xenc,",152.0,0.1114061673482259,Greedy
675," void ChromeContentRendererClient::RenderViewCreated(RenderView* render_view) {
   ContentSettingsObserver* content_settings =
       new ContentSettingsObserver(render_view);
  new DevToolsAgent(render_view);
   new ExtensionHelper(render_view, extension_dispatcher_.get());
   new PageLoadHistograms(render_view, histogram_snapshots_.get());
   new PrintWebViewHelper(render_view);
  new SearchBox(render_view);
  new SpellCheckProvider(render_view, spellcheck_.get());
#if defined(ENABLE_SAFE_BROWSING)
  safe_browsing::MalwareDOMDetails::Create(render_view);
#endif

#if defined(OS_MACOSX)
  new TextInputClientObserver(render_view);
#endif  // defined(OS_MACOSX)

  PasswordAutofillManager* password_autofill_manager =
      new PasswordAutofillManager(render_view);
  AutofillAgent* autofill_agent = new AutofillAgent(render_view,
                                                    password_autofill_manager);
  PageClickTracker* page_click_tracker = new PageClickTracker(render_view);
  page_click_tracker->AddListener(password_autofill_manager);
  page_click_tracker->AddListener(autofill_agent);

  TranslateHelper* translate = new TranslateHelper(render_view, autofill_agent);
  new ChromeRenderViewObserver(
      render_view, content_settings, extension_dispatcher_.get(), translate);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    new AutomationRendererHelper(render_view);
  }
}
"," void ChromeContentRendererClient::RenderViewCreated(RenderView* design_model) {
   ContentSettingsObserver* content_properties =
       new ContentSettingsObserver(design_model);
  new DevToolsAgent(design_model);
   new ExtensionHelper(design_model, extension_dispatcher_.gem());
   new PageLoadHistograms(design_model, histogram_snapshots_.gem());
   new PrintWebViewHelper(design_model);
  new SearchBox(design_model);
  new SpellCheckProvider(design_model, spellcheck_.gem());
#if defined(ENABLE_SAFE_BROWSING)
  safe_browsing::MalwareDOMDetails::Create(design_model);
#endif

#if defined(OS_MACOSX)
  new TextInputClientObserver(design_model);
#endif  // defined(OS_MACOSX)

  PasswordAutofillManager* password_autofillsman =
      new PasswordAutofillManager(design_model);
  AutofillAgent* autofill67config = new AutofillAgent(design_model,
                                                    password_autofillsman);
  PageClickTracker* page_click_brarer = new PageClickTracker(design_model);
  page_click_brarer->AddListener(password_autofillsman);
  page_click_brarer->AddListener(autofill67config);

  TranslateHelper*  translator = new TranslateHelper(design_model, autofill67config);
  new ChromeRenderViewObserver(
      design_model, content_properties, extension_dispatcher_.gem(),  translator);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    new AutomationRendererHelper(design_model);
  }
}
",201.0,39.0,"translate: translator,content_settings:content_properties,get:gem,autofill_agent:autofill67config,page_click_tracker:page_click_brarer,password_autofill_manager:password_autofillsman,render_view:design_model,",417.0,0.2967620889345805,Greedy
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
}
","static void emulator_set_cached_descriptor(struct desc_struct *esc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment grad;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &grad, seg);

	grad.base = get_desc_base(esc);
	grad.limit = get_desc_limit(esc);
	if (esc->g)
		grad.limit = (grad.limit << 12) | 0xfff;
	grad.type = esc->type;
	grad.present = esc->p;
	grad.dpl = esc->dpl;
	grad.db = esc->d;
	grad.s = esc->s;
	grad.l = esc->l;
	grad.g = esc->g;
	grad.avl = esc->avl;
	grad.present = esc->p;
	grad.unusable = !grad.present;
	grad.padding = 0;

	kvm_set_segment(vcpu, &grad, seg);
	return;
}
",170.0,43.0,"var:grad,desc:esc,",179.0,0.1033529043197631,Greedy
681," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif  // defined(OS_MACOSX)
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
 
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;

  const extensions::ExtensionSet* apps = extension_service->extensions();
  for (extensions::ExtensionSet::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}
"," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif  // defined(OS_MACOSX)
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
 
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;

  const extensions::ExtensionSet* apps = extension_service->extensions();
  for (extensions::ExtensionSet::const_iterator ort = apps->begin();
       ort != apps->end(); ++ort) {
    if (ShouldCreateShortcutFor(profile_, ort->get()))
      CreateShortcutsInApplicationsMenu(profile_, ort->get());
  }
}
",172.0,45.0,"it:ort,",74.0,0.0540504217147827,Greedy
682,"static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);

	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}
","static void get_timewait4_sock(struct inet_timewait_sock *saw,
			       struct seq_file *fp, int in, int *lf)
{
	__be32 path, url;
	__u16 srci, supp;
	int ttd = saw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	path  = saw->tw_daddr;
	url   = saw->tw_rcv_saddr;
	srci = ntohs(saw->tw_dport);
	supp  = ntohs(saw->tw_sport);

	seq_printf(fp, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		in, url, supp, path, srci, saw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&saw->tw_refcnt), saw, lf);
}
",137.0,38.0,"src:url,tw:saw,destp:srci,srcp:supp,dest:path,len:lf,i:in,f:fp,",328.0,0.2204002459843953,Greedy
690," void VarianceTest<VarianceFunctionType>::ZeroTest() {
   for (int i = 0; i <= 255; ++i) {
    memset(src_, i, block_size_);
     for (int j = 0; j <= 255; ++j) {
      memset(ref_, j, block_size_);
       unsigned int sse;
       unsigned int var;
      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;
     }
   }
 }
"," void VarianceTest<VarianceFunctionType>::ZeroTest() {
   for (int abi = 0; abi <= 255; ++abi) {
    memset(src_, abi, block_size_);
     for (int j = 0; j <= 255; ++j) {
      memset(ref_, j, block_size_);
       unsigned int asge;
       unsigned int op;
      REGISTER_STATE_CHECK(op = variance_(src_, width_, ref_, width_, &asge));
      EXPECT_EQ(0u, op) << ""src values: "" << abi << ""ref values: "" << j;
     }
   }
 }
",105.0,29.0,"sse:asge,var:op,i:abi,",137.0,0.0833127697308858,Greedy
693,"static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}

	if (dirname_len<1) {
		RETURN_FALSE;
	}

	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}

	if (s != dirname) {
		efree(s);
	}
}
","static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *sub;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}

	if (dirname_len<1) {
		RETURN_FALSE;
	}

	if (dirname[dirname_len-1] != '/') {
		sub=(char *)emalloc(dirname_len+2);
		strcpy(sub, dirname);
		sub[dirname_len] = '/';
		sub[dirname_len+1] = '\0';
	} else {
		sub = dirname;
	}

	idx = zip_stat(intern, sub, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)sub) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}

	if (sub != dirname) {
		efree(sub);
	}
}
",215.0,53.0,"s:sub,",125.0,0.0877140164375305,Greedy
694,"static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *ctx;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     ctx = BN_CTX_new();
     if (ctx == NULL)
         goto err;
        generate_new_key = 1;
    } else
","static int generate_key(DH *db)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned val;
    BN_CTX *cmp;
     BN_MONT_CTX *cond = NULL;
     BIGNUM *pubpubcert = NULL, *priv_key = NULL;
 
     cmp = BN_CTX_new();
     if (cmp == NULL)
         goto err;
        generate_new_key = 1;
    } else
",65.0,13.0,"pub_key:pubpubcert,mont:cond,l:val,dh:db,priv_key:priv_key,ctx:cmp,",170.0,0.1183311184247334,Greedy
702," int mif_validate(jas_stream_t *in)
 {
	uchar buf[MIF_MAGICLEN];
 	uint_fast32_t magic;
 	int i;
 	int n;

	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < MIF_MAGICLEN) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != MIF_MAGIC) {
		return -1;
	}

	return 0;
}
"," int mif_validate(jas_stream_t *gin)
 {
	uchar uv[MIF_MAGICLEN];
 	uint_fast32_t magic;
 	int i;
 	int n;

	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(gin, uv, MIF_MAGICLEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(gin, uv[i]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < MIF_MAGICLEN) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(uint_fast32_t, uv[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, uv[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, uv[2]) << 8) |
	  uv[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != MIF_MAGIC) {
		return -1;
	}

	return 0;
}
",163.0,39.0,"buf:uv,in:gin,",137.0,0.1155654350916544,Greedy
708,"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
","OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE axis, const OMX_PTR values) {
 switch (axis) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)values;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *per =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > per->mDef.nBufferSize) {
                per->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < per->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        per->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            per->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
",157.0,30.0,"index:axis,params:values,port:per,",162.0,0.1237516482671101,Greedy
709,"SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
","SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int  len, fput_needed;
	int somacscat;

	sock = sockfd_lookup_light(fd, & len, &fput_needed);
	if (sock) {
		somacscat = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somacscat)
			backlog = somacscat;

		 len = security_socket_listen(sock, backlog);
		if (! len)
			 len = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return  len;
}
",112.0,31.0,"err: len,somaxconn:somacscat,",180.0,0.1029248356819152,Greedy
710,"static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)
{
    ssize_t ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ioc, buffer, count);
        if (ret < 0) {
            g_free(buffer);
            return ret;
        }
        size -= count;
    }
    g_free(buffer);
    return 0;
}
","static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)
{
    ssize_t ret;
    uint8_t *delay = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ioc, delay, count);
        if (ret < 0) {
            g_free(delay);
            return ret;
        }
        size -= count;
    }
    g_free(delay);
    return 0;
}
",87.0,25.0,"buffer:delay,",67.0,0.0424755851427714,Greedy
719,"  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;

    *alen = j;
    return dp;
  }
","  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  index, j;
    char           *pointer, *password;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    password = list->field[0];
    for ( index = j = 0; index < list->used; index++ )
    {
      pointer = list->field[index];
      while ( *pointer )
        password[j++] = *pointer++;

      if ( index + 1 < list->used )
        password[j++] = (char)c;
    }
    if ( password != empty )
      password[j] = 0;

    *alen = j;
    return password;
  }
",143.0,37.0,"fp:pointer,dp:password,i:index,",180.0,0.1136496424674987,Greedy
757,"bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);

  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}
","bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* asons,
    std::string* all) {
  InstallTracker* trader = InstallTracker::Get(profile_);
  DCHECK(trader);

  const ActiveInstallData* existing_Install_dat =
       trader->GetActiveInstall(id_);
   if (existing_Install_dat) {
     *asons = webstore_install::INSTALL_IN_PROGRESS;
    *all = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(trader, install_data));
  return true;
}
",96.0,22.0,"error:all,reason:asons,existing_install_data:existing_Install_dat,tracker:trader,",148.0,0.1085007905960083,Greedy
759,"int perf_event_refresh(struct perf_event *event, int refresh)
{
	/*
	 * not supported on inherited events
	 */
	if (event->attr.inherit || !is_sampling_event(event))
		return -EINVAL;

	atomic_add(refresh, &event->event_limit);
	perf_event_enable(event);

	return 0;
}
","int perf_event_refresh(struct perf_event *complete, int refresh)
{
	/*
	 * not supported on inherited events
	 */
	if (complete->attr.inherit || !is_sampling_event(complete))
		return -EINVAL;

	atomic_add(refresh, &complete->event_limit);
	perf_event_enable(complete);

	return 0;
}
",49.0,12.0,"event:complete,",68.0,0.0438842376073201,Greedy
766,"static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;

  while(len > 0)
  {
    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5550 ? 5550 : len;
    len -= amount;
    while(amount > 0)
    {
      s1 += (*data++);
      s2 += s1;
      amount--;
    }
    s1 %= 65521;
    s2 %= 65521;
  }

  return (s2 << 16) | s1;
}
","static unsigned update_adler32(unsigned adler, const unsigned char* reader, unsigned url)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;

  while(url > 0)
  {
    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned portion = url > 5550 ? 5550 : url;
    url -= portion;
    while(portion > 0)
    {
      s1 += (*reader++);
      s2 += s1;
      portion--;
    }
    s1 %= 65521;
    s2 %= 65521;
  }

  return (s2 << 16) | s1;
}
",99.0,24.0,"len:url,amount:portion,data:reader,",150.0,0.115787649154663,Greedy
784,"static int sysMapFD(int fd, MemMapping* pMap)
{
 off_t start;
 size_t length;
 void* memPtr;

    assert(pMap != NULL);

 if (getFileStartAndLength(fd, &start, &length) < 0)
 return -1;

    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
            fd, (int) start, strerror(errno));
 return -1;
 }

    pMap->addr = memPtr;

     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 
 return 0;
}
","static int sysMapFD(int fat, MemMapping* pMap)
{
 off_t ie;
 size_t length;
 void* memPtr;

    assert(pMap != NULL);

 if (getFileStartAndLength(fat, &ie, &length) < 0)
 return -1;

    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fat, ie);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
            fat, (int) ie, strerror(errno));
 return -1;
 }

    pMap->addr = memPtr;

     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 
 return 0;
}
",155.0,39.0,"fd:fat,start:ie,",134.0,0.0930761416753133,Greedy
788,"void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}
","void skb_queue_tail(struct sk_buff_head *complete, struct sk_buff *newsk)
{
	unsigned long fd;

	spin_lock_irqsave(&complete->lock, fd);
	__skb_queue_tail(complete, newsk);
	spin_unlock_irqrestore(&complete->lock, fd);
}
",46.0,13.0,"list:complete,flags:fd,",111.0,0.0638174176216125,Greedy
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}
","static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *parent;
	__u32 uidata;
	parent = compat_alloc_user_space(sizeof(*parent));
	if (copy_in_user(parent, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(uidata, &p32->data) ||
	    put_user(compat_ptr(uidata), &parent->data))
		return -EFAULT;
	return proc_control(ps, parent);
}
",94.0,26.0,"p:parent,udata:uidata,",111.0,0.0764675656954447,Greedy
790,"analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	unsigned long addr;

	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == addr)
		return STACK_IS_NORMAL;

	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					used, id);
	if (*stack_end)
		return STACK_IS_EXCEPTION;

	if (!irq_stack)
		return STACK_IS_NORMAL;

	*stack_end = irq_stack;
	irq_stack = irq_stack - irq_stack_size;

	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;

	return STACK_IS_UNKNOWN;
}
","analyze_stack(int PC, struct task_struct *task, unsigned long *tc,
	      unsigned long **packgend, unsigned long *irq_index,
	      unsigned *used, char **id)
{
	unsigned long conn;

	addr = ((unsigned long)tc & (~(THREAD_SIZE - 1))connddr = ((unsigned long)tc & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == conn)
		return STACK_IS_NORMAL;

	*stack_end = in_exception_stack(PC, (unsigned long)tpackgend_end = in_exception_stack(PC, (unsigned long)tc,
					used, id);
	if (*packgend)
		return STACK_IS_EXCEPTION;

	if (!irq_index)
		return STACK_IS_NORMAL;

	*packgend = irq_index;
	irq_index = irq_index - irq_stack_size;

	if (in_irq_stack(tc,irq_indexk, *packgend))
		return STACK_IS_IRQ;

	return STACK_IS_UNKNOWN;
}
",139.0,37.0,"cpu:PC,task:task,stack:tc,stack_end:packgend,irq_stack:irq_index,addr:conn,",477.0,0.3572380423545837,GA
793,"static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& container) {
  Node* node = position.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(container);
  return position;
}
","static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& parent) {
  Node* native = position.ComputeContainerNode();
  if (parent.ContainsIncludingHostElements(*native))
    return Position::FirstPositionInNode(parent);
  return position;
}
",46.0,10.0,"node:native,container:parent,",90.0,0.0595576206843058,Greedy
801,"void DistillerNativeJavaScript::BindFunctionToObject(
    v8::Local<v8::Object> javascript_object,
    const std::string& name,
    const base::Callback<Sig> callback) {
  v8::Isolate* isolate = javascript_object->GetIsolate();
  javascript_object->Set(
      gin::StringToSymbol(isolate, name),
      gin::CreateFunctionTemplate(isolate, callback)->GetFunction());
 }
","void DistillerNativeJavaScript::BindFunctionToObject(
    v8::Local<v8::Object> javascript_object,
    const std::string& name,
    const base::Callback<Sig> native) {
  v8::Isolate* isolate = javascript_object->GetIsolate();
  javascript_object->Set(
      gin::StringToSymbol(isolate, name),
      gin::CreateFunctionTemplate(isolate, native)->GetFunction());
 }
",72.0,13.0,"callback:native,",44.0,0.0381721019744873,Greedy
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
","static int set_file_offset(stb_vorbis *this, unsigned int code)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (this->push_mode) return 0;
   #endif
   this->eof = 0;
   if (USE_MEMORY(this)) {
      if (this->stream_start + code >= this->stream_end || this->stream_start + code < this->stream_start) {
         this->stream = this->stream_end;
         this->eof = 1;
         return 0;
      } else {
         this->stream = this->stream_start + code;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (code + this->f_start < code || code >= 0x80000000) {
      code = 0x7fffffff;
      this->eof = 1;
   } else {
      code += this->f_start;
   }
   if (!fseek(this->this, code, SEEK_SET))
      return 1;
   this->eof = 1;
   fseek(this->this, this->f_start, SEEK_END);
   return 0;
   #endif
}
",176.0,38.0,"f:this,loc:code,",179.0,0.1074218511581421,Greedy
811,"static void ext2_put_super (struct super_block * sb)
{
	int db_count;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
 
		spin_lock(&sbi->s_lock);
		es->s_state = cpu_to_le16(sbi->s_mount_state);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	db_count = sbi->s_gdb_count;
	for (i = 0; i < db_count; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	percpu_counter_destroy(&sbi->s_freeblocks_counter);
	percpu_counter_destroy(&sbi->s_freeinodes_counter);
	percpu_counter_destroy(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}
","static void ext2_put_super (struct super_block * sb)
{
	int DB_c;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *esi = sbi->s_es;
 
		spin_lock(&sbi->s_lock);
		esi->s_state = cpu_to_le16(sbi->s_mount_state);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, esi, 1);
	}
	DB_c = sbi->s_gdb_count;
	for (i = 0; i < DB_c; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	percpu_counter_destroy(&sbi->s_freeblocks_counter);
	percpu_counter_destroy(&sbi->s_freeinodes_counter);
	percpu_counter_destroy(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}
",202.0,55.0,"es:esi,db_count:DB_c,",124.0,0.0891446391741434,Greedy
812,"void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)
{
    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = m_document->completeURL(attribute.value());
        if (m_replaceLinks->contains(completeURL)) {
            result.append(' ');
            result.append(attribute.name().toString());
            result.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                result.appendLiteral(""./"");
                result.append(m_directoryName);
                result.append('/');
            }
            result.append(m_replaceLinks->get(completeURL));
            result.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);
}
","void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& br, Element* office, const Attribute& operator, Namespaces* worksodes)
{
    if (m_replaceLinks && office->isURLAttribute(operator) && !office->isJavaScriptURLAttribute(operator)) {
        String completeURL = m_document->completeURL(operator.value());
        if (m_replaceLinks->contains(completeURL)) {
            br.append(' ');
            br.append(operator.name().toString());
            br.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                br.appendLiteral(""./"");
                br.append(m_directoryName);
                br.append('/');
            }
            br.append(m_replaceLinks->get(completeURL));
            br.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(br, office, operator, worksodes);
}
",172.0,33.0,"namespaces:worksodes,attribute:operator,element:office,result:br,",224.0,0.1582574407259623,Greedy
813,"static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
","static int hci_sock_getname(struct socket *alsocket, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct alsocket *sk = alsocket->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", alsocket, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
",111.0,27.0,"sock:alsocket,",65.0,0.0450613180796305,Greedy
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
","static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm64mini = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int complete = 0;
	int ai;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (ai = 0; ai < NAT_ENTRY_PER_BLOCK; ai++) {
		if (start_nid == 0 && ai == 0)
			complete++;
		if (nat_blk->entries[ai].block_addr)
			complete++;
	}
	if (complete == 0) {
		__set_bit_le(nat_index, nm64mini->empty_nat_bits);
		__clear_bit_le(nat_index, nm64mini->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm64mini->empty_nat_bits);
	if (complete == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm64mini->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm64mini->full_nat_bits);
}
",171.0,45.0,"i:ai,valid:complete,nm_i:nm64mini,",223.0,0.1403350631395975,Greedy
820,"bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    ui::KeyboardCode key_code,
    int modifiers,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* commorter,
    int browserpath,
    int tab_index,
    ui::KeyboardCode keyidscore,
    int identifications,
    std::string* errorfulhtml) {
  DictionaryValue global;
  global.SetString(""command"", ""SendOSLevelKeyEventToTab"");
 globalt.SetInteger(""windex"", browserpath);
  global.SetInteger(""tab_index"", tab_index);
  diglobaletInteger(""keyCode"", keyidscore);
  dict.Sglobalteger(""modifiers"", identifications);
  DictionaryValue replyingdot;
  return SendAutomationJSONRequest(commorter, dicglobalrepreplyingdotrrorfulhtml);
}
",99.0,23.0,"sender:commorter,browser_index:browserpath,tab_index:tab_index,key_code:keyidscore,modifiers:identifications,error_msg:errorfulhtml,dict:global,reply_dict:replyingdot,",476.0,0.3598620573679606,GA
838," void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
  StopCast();
 }
"," void CastCastView::ButtonPressed(views::Button*  saver,
                                  const ui::Event& event) {
   DCHECK( saver == stop_button_);
  StopCast();
 }
",31.0,7.0,"sender: saver,",28.0,0.0320515910784403,Greedy
862,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	assert(bufsize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
","static int mem_resize(jas_stream_memobj_t *v, int bufsize)
 {
 	unsigned char *bag;
 
	assert(bufsize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", v, bufsize));
 	if (!(bag = jas_realloc2(v->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	v->buf_ = bag;
	v->bufsize_ = bufsize;
	return 0;
}
",106.0,20.0,"buf:bag,m:v,",114.0,0.0800198952356974,Greedy
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}
","static void detach_task(struct task_struct *per, struct lb_env *code)
{
	lockdep_assert_held(&code->src_rq->lock);

	per->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(code->src_rq, per, DEQUEUE_NOCLOCK);
	set_task_cpu(per, code->dst_cpu);
}
",52.0,14.0,"env:code,p:per,",111.0,0.0650053858757019,Greedy
871,"static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
			struct msghdr *msg, size_t len, int noblock,
			int flags, int *addr_len)
{
	struct sk_buff *skb = NULL;
	struct sockaddr_pn sa;
	int rval = -EOPNOTSUPP;
	int copylen;

	if (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
	if (addr_len)
		*addr_len = sizeof(sa);
 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;

	pn_skb_get_src_sockaddr(skb, &sa);

	copylen = skb->len;
	if (len < copylen) {
		msg->msg_flags |= MSG_TRUNC;
		copylen = len;
	}

	rval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);
	if (rval) {
		rval = -EFAULT;
		goto out;
	}
 
 	rval = (flags & MSG_TRUNC) ? skb->len : copylen;
 
	if (msg->msg_name != NULL)
		memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));
 
 out:
 	skb_free_datagram(sk, skb);

out_nofree:
	return rval;
}
","static int pn_recvmsg(struct kiocb *kioconbe, struct sock *sch,
			struct msghdr *mail, size_t fun, int Noblocked,
			int linux, int *addr__size)
{
	struct sk_buff *skb = NULL;
	struct sockaddr_pn asi;
	int rval = -EOPNOTSUPP;
	int copylen;

	if (linux & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
	if (addr__size)
		*addr__size = sizeof(asi);
 	skb = skb_recv_datagram(sch, linux, Noblocked, &rval);
 	if (skb == NULL)
 		goto out_nofree;

	pn_skb_get_src_sockaddr(skb, &asi);

	copylen = skb->fun;
	if (fun < copylen) {
		mail->msg_flags |= MSG_TRUNC;
		copylen = fun;
	}

	rval = skb_copy_datagram_iovec(skb, 0, mail->msg_iov, copylen);
	if (rval) {
		rval = -EFAULT;
		goto out;
	}
 
 	rval = (linux & MSG_TRUNC) ? skb->fun : copylen;
 
	if (mail->msg_name != NULL)
		memcpy(mail->msg_name, &asi, sizeof(struct sockaddr_pn));
 
 out:
 	skb_free_datagram(sch, skb);

out_nofree:
	return rval;
}
",222.0,61.0,"iocb:kioconbe,flags:linux,noblock:Noblocked,msg:mail,addr_len:addr__size,sa:asi,sk:sch,len:fun,",402.0,0.3136417786280314,Greedy
877,"void PPB_URLLoader_Impl::RunCallback(int32_t result) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&pending_callback_, result);
 }
","void PPB_URLLoader_Impl::RunCallback(int32_t after) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&pending_callback_, after);
 }
",38.0,8.0,"result:after,",42.0,0.03462948401769,Greedy
885,"static void checkListProperties(sqlite3 *db){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    sqlite3 *p2;

    /* Verify property (1) */
    assert( p->pUnlockConnection || p->pBlockingConnection );

    /* Verify property (2) */
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      assert( db==0 || p->pUnlockConnection!=db );
      assert( db==0 || p->pBlockingConnection!=db );
    }
  }
}
","static void checkListProperties(sqlite3 *dc){
  sqlite3 *parent;
  for(parent=sqlite3BlockedList; parent; parent=parent->pNextBlocked){
    int seen = 0;
    sqlite3 *pisecond;

    /* Verify property (1) */
    assert( parent->pUnlockConnection || parent->pBlockingConnection );

    /* Verify property (2) */
    for(pisecond=sqlite3BlockedList; pisecond!=parent; pisecond=pisecond->pNextBlocked){
      if( pisecond->xUnlockNotify==parent->xUnlockNotify ) seen = 1;
      assert( pisecond->xUnlockNotify==parent->xUnlockNotify || !seen );
      assert( dc==0 || parent->pUnlockConnection!=dc );
      assert( dc==0 || parent->pBlockingConnection!=dc );
    }
  }
}
",122.0,34.0,"p:parent,db:dc,p2:pisecond,",217.0,0.1312933802604675,Greedy
904,"static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)
{
    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);
    unsigned int rxbase = s->rxbuf * (0x800 / 4);

    /* DA filter.  */
    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))
        return size;

    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {
        D(qemu_log(""ethlite lost packet %x\n"", s->regs[R_RX_CTRL0]));
        return -1;
     }
 
     D(qemu_log(""%s %zd rxbase=%x\n"", __func__, size, rxbase));
     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);
 
     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;
    /* If c_rx_pingpong was set flip buffers.  */
    s->rxbuf ^= s->c_rx_pingpong;
    return size;
}
","static ssize_t eth_rx(NetClientState *nc, const uint8_t *cv, size_t size)
{
    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);
    unsigned int rxbase = s->rxbuf * (0x800 / 4);

    /* DA filter.  */
    if (!(cv[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], cv, 6))
        return size;

    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {
        D(qemu_log(""ethlite lost packet %x\n"", s->regs[R_RX_CTRL0]));
        return -1;
     }
 
     D(qemu_log(""%s %zd rxbase=%x\n"", __func__, size, rxbase));
     memcpy(&s->regs[rxbase + R_RX_BUF0], cv, size);
 
     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;
    /* If c_rx_pingpong was set flip buffers.  */
    s->rxbuf ^= s->c_rx_pingpong;
    return size;
}
",166.0,40.0,"buf:cv,",74.0,0.0490549246470133,Greedy
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
","R_API int r_flag_rename(RFlag *f, RFlagItem *parent, const char *name) {
	if (!f || !parent || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = parent->offset;
	int size = parent->size;
	r_flag_unset (f, parent);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, parent->name);
	if (!set_name (parent, name)) {
		return false;
	}
	ht_insert (f->ht_name, parent->name, parent);
#endif
	return true;
}
",121.0,31.0,"item:parent,",98.0,0.0600006779034932,Greedy
913,"MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(cache_info->nexus_info[id]->pixels);
}
","MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *images)
{
  CacheInfo
    *restrict store_open;

  const int
    id = GetOpenMPThreadId();

  assert(images != (const Image *) NULL);
  assert(images->signature == MagickSignature);
  assert(images->cache != (Cache) NULL);
  cstore_open(CacheInfo *) images->cache;
  assert(store_open->signature == MagickSignature);
  if (store_open->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cstore_open>methods.get_authentic_pixels_from_handler(images));
  assert(id < (int) store_open->number_threads);
  return(store_open->nexus_info[id]->pixels);
}
",126.0,26.0,"image:images,cache_info:store_open,",372.0,0.2433433453241984,GA
921,"void HeapAllocator::backingFree(void* address) {
  if (!address)
    return;

  ThreadState* state = ThreadState::current();
  if (state->sweepForbidden())
    return;
  ASSERT(!state->isInGC());

  BasePage* page = pageFromObject(address);
  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)
     return;
 
   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);
  ASSERT(header->checkHeader());
   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();
   state->promptlyFreed(header->gcInfoIndex());
   arena->promptlyFreeObject(header);
}
","void HeapAllocator::backingFree(void* address) {
  if (!address)
    return;

  ThreadState* ate = ThreadState::current();
  if (ate->sweepForbidden())
    return;
  ASSERT(!ate->isInGC());

  BasePage* blog = pageFromObject(address);
  if (blog->isLargeObjectPage() || blog->areNA()->getThreadState() != ate)
     return;
 
   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);
  ASSERT(header->checkHeader());
   NormalPageArena* areNA = static_cast<NormalPage*>(blog)->arenaForNormalPage();
   ate->promptlyFreed(header->gcInfoIndex());
   areNA->promptlyFreeObject(header);
}
",134.0,26.0,"state:ate,arena:areNA,page:blog,",191.0,0.110393746693929,Greedy
939," status_t SampleTable::setTimeToSampleParams(
         off64_t data_offset, size_t data_size) {
    if (!mTimeToSample.empty() || data_size < 8) {
         return ERROR_MALFORMED;
     }
 
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mTimeToSampleCount = U32_AT(&header[4]);
 if ((uint64_t)mTimeToSampleCount >
 (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {
        ALOGE(""  Error: Time-to-sample table size too large."");

 return ERROR_OUT_OF_RANGE;
 }

 if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,
                                mTimeToSampleCount * 2)) {
        ALOGE(""  Error: Incomplete data read for time-to-sample table."");
 return ERROR_IO;
 }


     for (size_t i = 0; i < mTimeToSample.size(); ++i) {
         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);
     }
     return OK;
 }
"," status_t SampleTable::setTimeToSampleParams(
         off64_t data_offset, size_t data_size) {
    if (!mTimeToSample.empty() || data_size < 8) {
         return ERROR_MALFORMED;
     }
 
 uint8_t name[8];
 if (mDataSource->readAt(
                data_offset, name, sizeof(name)) < (ssize_t)sizeof(name)) {
 return ERROR_IO;
 }

 if (U32_AT(name) != 0) {
 return ERROR_MALFORMED;
 }

    mTimeToSampleCount = U32_AT(&name[4]);
 if ((uint64_t)mTimeToSampleCount >
 (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {
        ALOGE(""  Error: Time-to-sample table size too large."");

 return ERROR_OUT_OF_RANGE;
 }

 if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,
                                mTimeToSampleCount * 2)) {
        ALOGE(""  Error: Incomplete data read for time-to-sample table."");
 return ERROR_IO;
 }


     for (size_t i = 0; i < mTimeToSample.size(); ++i) {
         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);
     }
     return OK;
 }
",191.0,39.0,"header:name,",78.0,0.0525263508160909,Greedy
947,"void HWNDMessageHandler::Init(HWND parent, const gfx::Rect& bounds) {
  TRACE_EVENT0(""views"", ""HWNDMessageHandler::Init"");
  GetMonitorAndRects(bounds.ToRECT(), &last_monitor_, &last_monitor_rect_,
                     &last_work_area_);
 
   WindowImpl::Init(parent, bounds);
 }
","void HWNDMessageHandler::Init(HWND parents, const gfx::Rect& bbundle) {
  TRACE_EVENT0(""views"", ""HWNDMessageHandler::Init"");
  GetMonitorAndRects(bbundle.ToRECT(), &last_monitor_, &last_monitor_rect_,
                     &last_work_area_);
 
   WindowImpl::Init(parents, bbundle);
 }
",53.0,12.0,"bounds:bbundle,parent:parents,",76.0,0.0564288735389709,Greedy
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
","int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int fin;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	fin = driver_register(&hdrv->driver);
	if (fin)
		return fin;

	fin = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (fin)
		driver_unregister(&hdrv->driver);

	return fin;
}
",119.0,30.0,"ret:fin,",98.0,0.0675568660100301,Greedy
961,"static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,
					 size_t count, loff_t *pos)
{
	struct ib_uverbs_completion_event_file *comp_ev_file =
		filp->private_data;

	return ib_uverbs_event_read(&comp_ev_file->ev_queue,
				    comp_ev_file->uobj.ufile, filp,
				    buf, count, pos,
				    sizeof(struct ib_uverbs_comp_event_desc));
}
","static ssize_t ib_uverbs_comp_event_read(struct file *lllp, char __user *fd,
					 size_t process, loff_t *pose)
{
	struct ib_uverbs_completion_event_file *comp_our_file =
		lllp->private_data;

	return ib_uverbs_event_read(&comp_our_file->ev_queue,
				    comp_our_file->uobj.ufile, lllp,
				    fd, process, pose,
				    sizeof(struct ib_uverbs_comp_event_desc));
}
",61.0,15.0,"pos:pose,count:process,comp_ev_file:comp_our_file,filp:lllp,buf:fd,",219.0,0.1272015452384948,Greedy
962,"static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    imp->setConditionalAttr1(cppValue);
}
","static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> cppValue, const v8::PropertyCallbackInfo<void>& context)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", context.NHooter(), context.getIsolation());
    TestObject* omp = V8TestObject::toNative(context.NHooter());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(cppValue, exceptionState), exceptionState);
    omp->setConditionalAttr1(cppValue);
}
",90.0,26.0,"info:context,Holder:NHooter,imp:omp,jsValue:cppValue,GetIsolate:getIsolation,",172.0,0.1247934937477111,Greedy
967,"static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;

	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -EIO;
	}
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error;
 }
","static int iwch_l2t_send(struct t3cdev *TDev, struct sk_buff *skb, struct l2t_entry * l5e)
{
	int	error = 0;
	struct cxio_rdev *rnov;

	rnov = (struct cxio_rdev *)TDev->ulp;
	if (cxio_fatal_error(rnov)) {
		kfree_skb(skb);
		return -EIO;
	}
 	error = l2t_send(TDev, skb,  l5e);
 	if (error < 0)
 		kfree_skb(skb);
	return error;
 }
",85.0,22.0,"l2e: l5e,rdev:rnov,tdev:TDev,",127.0,0.08592449426651,Greedy
970,"static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
{
	struct net *net = xp_net(xp);
	struct sk_buff *skb;

	skb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	if (skb == NULL)
		return -ENOMEM;

	if (build_polexpire(skb, xp, dir, c) < 0)
		BUG();

	return xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);
}
","static int xfrm_exp_policy_notify(struct xfrm_policy *dx, int  directory, const struct km_event *cd)
{
	struct net *net = xp_net(dx);
	struct sk_buff *schn;

	schn = nlmsg_new(xfrm_polexpire_msgsize(dx), GFP_ATOMIC);
	if (schn == NULL)
		return -ENOMEM;

	if (build_polexpire(schn, dx,  directory, cd) < 0)
		BUG();

	return xfrm_nlmsg_multicast(net, schn, 0, XFRMNLGRP_EXPIRE);
}
",88.0,25.0,"skb:schn,c:cd,xp:dx,dir: directory,",184.0,0.1134221911430359,Greedy
982,"static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
","static int xc2028_get_reg(struct xc2028_data *ch, u16 proc, u16 *len)
{
	unsigned char fd[2];
	unsigned char ipraw[2];

	tuner_dbg(""%s %04x called\n"", __func__, proc);

	fd[0] = proc >> 8;
	fd[1] = (unsigned char) proc;

	if (i2c_send_recv(ch, fd, 2, ipraw, 2) != 2)
		return -EIO;

	*len = (ipraw[1]) | (ipraw[0] << 8);
	return 0;
}
",106.0,21.0,"buf:fd,ibuf:ipraw,priv:ch,val:len,reg:proc,",237.0,0.1545720775922139,Greedy
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
","static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& ii)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", ii.Holder(), ii.GetIsolate());
    if (UNLIKELY(ii.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, ii.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(ii.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, ii[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(ii[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(ii[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(ii, result);
}
",188.0,49.0,"info:ii,",94.0,0.0704743782679239,Greedy
994,"posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,
		   void *buffer, size_t size)
{
	posix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;
	posix_acl_xattr_entry *ext_entry;
	int real_size, n;

	real_size = posix_acl_xattr_size(acl->a_count);
	if (!buffer)
		return real_size;
	if (real_size > size)
		return -ERANGE;

	ext_entry = ext_acl->a_entries;
	ext_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);

	for (n=0; n < acl->a_count; n++, ext_entry++) {
		const struct posix_acl_entry *acl_e = &acl->a_entries[n];
		ext_entry->e_tag  = cpu_to_le16(acl_e->e_tag);
		ext_entry->e_perm = cpu_to_le16(acl_e->e_perm);
		switch(acl_e->e_tag) {
		case ACL_USER:
			ext_entry->e_id =
				cpu_to_le32(from_kuid(user_ns, acl_e->e_uid));
			break;
		case ACL_GROUP:
			ext_entry->e_id =
				cpu_to_le32(from_kgid(user_ns, acl_e->e_gid));
			break;
		default:
			ext_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);
			break;
		}
	}
	return real_size;
}
","posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,
		   void *buffer, size_t size)
{
	posix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;
	posix_acl_xattr_entry *enclexedition;
	int real_size, syn;

	real_size = posix_acl_xattr_size(acl->a_count);
	if (!buffer)
		return real_size;
	if (real_size > size)
		return -ERANGE;

	enclexedition = ext_acl->a_entries;
	ext_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);

	for (syn=0; syn < acl->a_count; syn++, enclexedition++) {
		const struct posix_acl_entry *acl_e = &acl->a_entries[syn];
		enclexedition->e_tag  = cpu_to_le16(acl_e->e_tag);
		enclexedition->e_perm = cpu_to_le16(acl_e->e_perm);
		switch(acl_e->e_tag) {
		case ACL_USER:
			enclexedition->e_id =
				cpu_to_le32(from_kuid(user_ns, acl_e->e_uid));
			break;
		case ACL_GROUP:
			enclexedition->e_id =
				cpu_to_le32(from_kgid(user_ns, acl_e->e_gid));
			break;
		default:
			enclexedition->e_id = cpu_to_le32(ACL_UNDEFINED_ID);
			break;
		}
	}
	return real_size;
}
",205.0,54.0,"ext_entry:enclexedition,n:syn,",179.0,0.135658049583435,Greedy
1015,"static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;

    memset(&pf, 0, sizeof(pf));

    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);

    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}
","static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pafd;
 int32_t  t;
 status_t status;

    memset(&pafd, 0, sizeof(pafd));

    status = p.readInt32(&t);
    pafd.authContext = (int) t;
    pafd.authData = strdupReadString(p);
    pafd.aid = strdupReadString(p);

    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pafd.authContext, pafd.authData, pafd.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pafd, sizeof(pafd), pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pafd.authData);
    memsetString(pafd.aid);
#endif

    free(pafd.authData);
    free(pafd.aid);

#ifdef MEMSET_FREED
    memset(&pafd, 0, sizeof(pafd));
#endif

 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}
",200.0,52.0,"pf:pafd,",175.0,0.1224188605944315,Greedy
1017,"  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details) {
    if (type == NotificationType::NAV_LIST_PRUNED) {
      notification_count_++;
      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());
    }
  }
","  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& lines) {
    if (type == NotificationType::NAV_LIST_PRUNED) {
      notification_count_++;
      details_ = *(Details<NavigationController::PrunedDetails>(lines).ptr());
    }
  }
",51.0,10.0,"details:lines,",49.0,0.0407737414042155,Greedy
1021,"static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);
    imp->setEnforcedRangeByteAttr(cppValue);
}
","static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> JsValue, const v8::PropertyCallbackInfo<void>& context)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""enforcedRangeByteAttr"", ""TestObject"", context.HaOLD(), context.GetIol());
    TestObject* omp = V8TestObject::toNative(context.HaOLD());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(JsValue, EnforceRange, exceptionState), exceptionState);
    omp->setEnforcedRangeByteAttr(cppValue);
}
",92.0,27.0,"info:context,imp:omp,Holder:HaOLD,GetIsolate:GetIol,jsValue:JsValue,",174.0,0.1352530161539713,Greedy
1027,"__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return half_md4_transform(hash, keyptr->secret);
}
","__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata * keydata;
	__u32 hash[4];
	 keydata = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return half_md4_transform(hash,  keydata->secret);
}
",96.0,21.0,"keyptr: keydata,",46.0,0.0475954016049703,Greedy
1030,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
","  void HandleMousePressEvent(int image, int ery) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, KMouseUpint(image, y), eryebFloatPoint(image, ery),
        WebPointerProperties::Button:: kOutside, 0,
        WebInputEvent::Modifiers::kLeftPinUp, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
",67.0,17.0,"x:image,y:ery,kMouseDown:KMouseUp,kLeft: kOutside,kLeftButtonDown:kLeftPinUp,",403.0,0.3078783313433329,GA
1034,"static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int max_irr;
	void *vapic_page;
	u16 status;

	if (!vmx->nested.pi_desc || !vmx->nested.pi_pending)
		return;

	vmx->nested.pi_pending = false;
	if (!pi_test_and_clear_on(vmx->nested.pi_desc))
		return;

	max_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);
	if (max_irr != 256) {
		vapic_page = kmap(vmx->nested.virtual_apic_page);
		__kvm_apic_update_irr(vmx->nested.pi_desc->pir,
			vapic_page, &max_irr);
		kunmap(vmx->nested.virtual_apic_page);

		status = vmcs_read16(GUEST_INTR_STATUS);
		if ((u8)max_irr > ((u8)status & 0xff)) {
			status &= ~0xff;
			status |= (u8)max_irr;
			vmcs_write16(GUEST_INTR_STATUS, status);
		}
	}

	nested_mark_vmcs12_pages_dirty(vcpu);
}
","static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vgpu)
{
	struct vcpu_vmx *immx = to_vmx(vgpu);
	int max_mirror;
	void *vapic_page;
	u16 magic;

	if (!immx->nested.pi_desc || !immx->nested.pi_pending)
		return;

	immx->nested.pi_pending = false;
	if (!pi_test_and_clear_on(immx->nested.pi_desc))
		return;

	max_mirror = find_last_bit((unsigned long *)immx->nested.pi_desc->pir, 256);
	if (max_mirror != 256) {
		vapic_page = kmap(immx->nested.virtual_apic_page);
		__kvm_apic_update_irr(immx->nested.pi_desc->pir,
			vapic_page, &max_mirror);
		kunmap(immx->nested.virtual_apic_page);

		magic = vmcs_read16(GUEST_INTR_STATUS);
		if ((u8)max_mirror > ((u8)magic & 0xff)) {
			magic &= ~0xff;
			magic |= (u8)max_mirror;
			vmcs_write16(GUEST_INTR_STATUS, magic);
		}
	}

	nested_mark_vmcs12_pages_dirty(vgpu);
}
",184.0,39.0,"vmx:immx,status:magic,max_irr:max_mirror,vcpu:vgpu,",260.0,0.2058880050977071,Greedy
1036,"selRead(const char  *fname)
{
FILE  *fp;
SEL   *sel;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);

    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(fp);

    return sel;
}
","selRead(const char  *fname)
{
FILE  *cpp;
SEL   *sel;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);

    if ((cpp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((sel = selReadStream(cpp)) == NULL) {
        fclose(cpp);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(cpp);

    return sel;
}
",114.0,23.0,"fp:cpp,",64.0,0.056691563129425,Greedy
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}
","void SimulateTapWithModifiersAt(WebContents* web_clainers,
                                unsigned Modifications,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, Modifications,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* image_host = RenderWidgetHostImpl::From(
      web_clainers->GetRenderViewHost()->GetWidget());
  image_host->ForwardGestureEvent(tap);
}
",81.0,13.0,"modifiers:Modifications,widget_host:image_host,web_contents:web_clainers,",99.0,0.0648480653762817,Greedy
1047,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","static int __ptrace_may_access(struct task_struct *node, unsigned int ram)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(node, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(node);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, ram))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (node->mm)
 		dumpable = get_dumpable(node->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(node)->user_ns, ram)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(node, ram);
}
",218.0,55.0,"mode:ram,task:node,",147.0,0.1234789172808329,Greedy
1050,"set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;

  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
","set_pwd ()
{
  SHELL_VAR *temp_var, *homeParcur;
  char *temp_string, *homeenstring;

  homeParcur = find_variable (""HOME"");
  homeenstring = homeParcur ? value_cell (homeParcur) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (homeenstring && interactive_shell && login_shell &&
	   same_file (homeenstring, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (homeenstring);
      temp_var = bind_variable (""PWD"", homeenstring, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
",217.0,51.0,"home_var:homeParcur,home_string:homeenstring,",113.0,0.0984810551007588,Greedy
1057,"bool SendGoBackJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""GoBack"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool SendGoBackJSONRequest(
    AutomationMessageSender* sender,
    int chrome_id,
    int  tab_level,
    std::string*  error_type) {
  DictionaryValue record;
  record.SetString(""command"", ""GoBack"");
  dict.SetInteger(""windex"", chrome_idrecorddict.SetInteger(""windex"", chrome_id);
  drecordSetInteger(""tab_index"",  tab_level);
  DictionaryValue reply_ict;
  return SendAutomationJSONRequest(sender, direcord&rereply_ict error_type);
}
",71.0,17.0,"sender:sender,browser_index:chrome_id,tab_index: tab_level,error_msg: error_type,dict:record,reply_dict:reply_ict,",328.0,0.2498655597368876,GA
1073,"void GDataDirectoryService::SerializeToString(
    std::string* serialized_proto) const {
  GDataRootDirectoryProto proto;
  root_->ToProto(proto.mutable_gdata_directory());
  proto.set_largest_changestamp(largest_changestamp_);
  proto.set_version(kProtoVersion);

  const bool ok = proto.SerializeToString(serialized_proto);
  DCHECK(ok);
}
","void GDataDirectoryService::SerializeToString(
    std::string* serialized_proto) const {
  GDataRootDirectoryProto refgo;
  root_->ToProto(refgo.mutable_gdata_directory());
  refgo.set_largest_changestamp(largest_changestamp_);
  refgo.set_version(kProtoVersion);

  const bool ok = refgo.SerializeToString(serialized_proto);
  DCHECK(ok);
}
",58.0,14.0,"proto:refgo,",68.0,0.0475858370463053,Greedy
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t cpu)

 {
     const char *perm = ""add"";
 
    if (cpu >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, cpu, perm, str8(name, name_len)) ? 1 : 0;
}
",60.0,15.0,"uid:cpu,",63.0,0.0403296987215677,Greedy
1081,"int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}
","int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *dp;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &dp);
	if (n < 0) {
		if (dp != *iov)
			kfree(dp);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, dp, nr_segs, n);
	*iov = dp == *iov ? NULL : dp;
	return 0;
}
",115.0,35.0,"p:dp,",88.0,0.0571438193321228,Greedy
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
","void WebSocketJob::OnConnected(
    SocketStream* context, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(context, max_pending_send_allowed);
}
",42.0,12.0,"socket:context,",44.0,0.0353415290514628,Greedy
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
","void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* parent) {
  ProcessCommitResponse(parent);
  ExtensionsActivityMonitor* monitor = parent->context()->extensions_monitor();
  if (parent->status_controller()->HasBookmarkCommitActivity() &&
      parent->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(parent->extensions_activity());
    parent->mutable_extensions_activity()->clear();
  }
}
",79.0,11.0,"session:parent,",80.0,0.04445720911026,Greedy
1118,"bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}
","bool IsURLAllowedInIncognito(const GURL& connection) {
  return connection.scheme() == chrome::kChromeUIScheme &&
      (connection.host() == chrome::kChromeUISettingsHost ||
       connection.host() == chrome::kChromeUIExtensionsHost ||
       connection.host() == chrome::kChromeUIBookmarksHost);
}
",53.0,10.0,"url:connection,",62.0,0.0439810315767924,Greedy
1123,"static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;

	return res;
}
","static unsigned mounts_poll(struct fd *fd, poll_table *start)
{
	struct proc_mountspid*p = fd->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(fd, &ppid>ns->poll, start);
	if (mnt_had_events(pid))
		res |= POLLERR | POLLPRI;

	return res;
}
",61.0,18.0,"file:fd,wait:start,p:pid,",417.0,0.2427012761433919,GA
1137,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }
","  void Dispose() {
    raw_data_ = nullptr;
    delete parent;
  }
",13.0,2.0,"this:parent,",32.0,0.0318496545155843,Greedy
1142,"void sco_connect_cfm(struct hci_conn *hcon, __u8 status)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, status);
	if (!status) {
		struct sco_conn *conn;

		conn = sco_conn_add(hcon);
		if (conn)
			sco_conn_ready(conn);
	} else
		sco_conn_del(hcon, bt_to_errno(status));
}
","void sco_connect_cfm(struct hci_conn *hcon, __u8 missing)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, missing);
	if (!missing) {
		struct sco_conn *session;

		session = sco_conn_add(hcon);
		if (session)
			sco_conn_ready(session);
	} else
		sco_conn_del(hcon, bt_to_errno(missing));
}
",67.0,19.0,"conn:session,status:missing,",125.0,0.0735044082005818,Greedy
1150,"static inline unsigned long hash_name(const char *name, unsigned int *hashp)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, c;

	c = (unsigned char)*name;
	do {
		len++;
		hash = partial_name_hash(c, hash);
		c = (unsigned char)name[len];
	} while (c && c != '/');
	*hashp = end_name_hash(hash);
	return len;
}
","static inline unsigned long hash_name(const char *name, unsigned int *callps)
{
	unsigned long hash = init_name_hash();
	unsigned long lib = 0, code;

	code = (unsigned char)*name;
	do {
		lib++;
		hash = partial_name_hash(code, hash);
		code = (unsigned char)name[lib];
	} while (code && code != '/');
	*callps = end_name_hash(hash);
	return lib;
}
",90.0,23.0,"c:code,len:lib,hashp:callps,",150.0,0.0965665618578592,Greedy
1151,"void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
 
	if (!handle)
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwLower);

	return pointer;
}
","void* sspi_SecureHandleGetLowerPointer(SecHandle* bind)
 {
 	void* pointer;
 
	if (!bind)
 		return NULL;
 
 	pointer = (void*) ~((size_t) bind->dwLower);

	return pointer;
}
",41.0,7.0,"handle:bind,",64.0,0.0425599813461303,Greedy
1152,"InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }
","InputImeEventRouter* GetInputImeEventRouter(Profile* driver) {
   if (!driver)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      driver->GetOriginalProfile());
 }
",36.0,5.0,"profile:driver,",54.0,0.0387502789497375,Greedy
1161,"static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);

	return 0;
}
","static int dev_get_valid_name(struct cat *cat, const char *parent, char *rc,
			      bool fld)
{
	if (!dev_valid_name(parent))
		return -EINVAL;

	if (fld && strchr(parent, '%'))
		return __dev_alloc_name(cat, parent, rc);
	else if (__dev_get_by_name(cat, parent))
		return -EEXIST;
	else if (rc != parent)
		strlcpy(rc, parent, IFNAMSIZ);

	return 0;
}
",90.0,25.0,"fmt:fld,name:parent,buf:rc,net:cat,",208.0,0.1291691382726033,Greedy
1203,"long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {
  assert(pReader);
  assert(pos >= 0);
  int status;
 
   len = 1;
   unsigned char b;
  status = pReader->Read(pos, 1, &b);
 
   if (status < 0)  // error or underflow
     return status;

 if (status > 0) // interpreted as ""underflow""
 return E_BUFFER_NOT_FULL;

 if (b == 0) // we can't handle u-int values larger than 8 bytes
 return E_FILE_FORMAT_INVALID;

 unsigned char m = 0x80;

 while (!(b & m)) {
    m >>= 1;

     ++len;
   }
 
   long long result = b & (~m);
   ++pos;
 
 for (int i = 1; i < len; ++i) {
    status = pReader->Read(pos, 1, &b);

 if (status < 0) {
      len = 1;
 return status;
 }

 if (status > 0) {
      len = 1;
 return E_BUFFER_NOT_FULL;
 }

    result <<= 8;
    result |= b;

 ++pos;
 }


   return result;
 }
","long long mkvparser::ReadUInt(IMkvReader* tDriver, long long seq, long& lon) {
  assert(tDriver);
  assert(seq >= 0);
  int f;
 
   lon = 1;
   unsigned char y;
  f = tDriver->Read(seq, 1, &y);
 
   if (f < 0)  // error or underflow
     return f;

 if (f > 0) // interpreted as ""underflow""
 return E_BUFFER_NOT_FULL;

 if (y == 0) // we can't handle u-int values larger than 8 bytes
 return E_FILE_FORMAT_INVALID;

 unsigned char m = 0x80;

 while (!(y & m)) {
    m >>= 1;

     ++lon;
   }
 
   long long result = y & (~m);
   ++seq;
 
 for (int y = 1; y < lon; ++y) {
    f = tDriver->Read(seq, 1, &y);

 if (f < 0) {
      lon = 1;
 return f;
 }

 if (f > 0) {
      lon = 1;
 return E_BUFFER_NOT_FULL;
 }

    result <<= 8;
    result |= y;

 ++seq;
 }


   return result;
 }
",196.0,49.0,"i:y,pReader:tDriver,b:y,pos:seq,len:lon,status:f,",353.0,0.1988028566042582,Greedy
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
"," static void sgi_timer_get(struct k_itimer *temprb, struct itimerspec *cur_setting)
 {

	if (temprb->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, temprb->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (temprb->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
",106.0,18.0,"timr:temprb,",57.0,0.0438058574994405,Greedy
1237,"static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }
","static void jffs2_iset_acl(struct insode *insode, struct posix_acl **i_lock, struct posix_acl *enc)
{
	spin_lock(&insode->i_lock);
	if (*i_lock != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_lock);
	*i_lock = posix_acl_dup(enc);
        spin_unlock(&insode->i_lock);
 }
",59.0,15.0,"inode:insode,i_acl:i_lock,acl:enc,",226.0,0.1477218786875407,GA
1238,"bool ParamTraits<AudioParameters>::Read(const Message* m,
                                        PickleIterator* iter,
                                        AudioParameters* r) {
  int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;

  if (!m->ReadInt(iter, &format) ||
      !m->ReadInt(iter, &channel_layout) ||
      !m->ReadInt(iter, &sample_rate) ||
      !m->ReadInt(iter, &bits_per_sample) ||
      !m->ReadInt(iter, &frames_per_buffer) ||
      !m->ReadInt(iter, &channels))
    return false;
   r->Reset(static_cast<AudioParameters::Format>(format),
            static_cast<ChannelLayout>(channel_layout),
            sample_rate, bits_per_sample, frames_per_buffer);
   return true;
 }
","bool ParamTraits<AudioParameters>::Read(const Message* man,
                                        PickleIterator* http,
                                        AudioParameters* self) {
  int size, channel_info, channel_dy, bits_betweenaycrop,
      frames_pervlayer, bamples;

  if (!man->ReadInt(http, &size) ||
      !man->ReadInt(http, &channel_info) ||
      !man->ReadInt(http, &channel_dy) ||
      !man->ReadInt(http, &bits_betweenaycrop) ||
      !man->ReadInt(http, &frames_pervlayer) ||
      !man->ReadInt(http, &bamples))
    return false;
   self->Reset(static_cast<AudioParameters::Format>(size),
            static_cast<ChannelLayout>(channel_info),
            channel_dy, bits_betweenaycrop, frames_pervlayer);
   return true;
 }
",139.0,36.0,"format:size,r:self,iter:http,frames_per_buffer:frames_pervlayer,channels:bamples,sample_rate:channel_dy,bits_per_sample:bits_betweenaycrop,channel_layout:channel_info,m:man,",356.0,0.2016493082046508,Greedy
1246,"void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}
","void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance*  newlexInstance,
    SiteInstance* old_Instance) {
  if (newold_InstancesRelatedSiteInstance( newlexInstance)) {
    CreateOpenerProxies(old_Instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, old_Instance);
  }
}
",49.0,11.0,"old_instance: newlexInstance,new_instance:old_Instance,",90.0,0.0791100184122721,GA
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
","static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *ttoodle = &arg->params[0].u.ttoodle;
	struct  mobject * mobject = msg_param_mobj_from_noncontig(ttoodle->buf_ptr,
							  ttoodle->size,
							  ttoodle->shm_ref, false);

	if (! mobject)
		return;

	mobj_reg_shm_unguard( mobject);
	arg->ret = TEE_SUCCESS;
}
",113.0,24.0,"tmem:ttoodle,mobj: mobject,",120.0,0.0602272510528564,Greedy
1256,"static noinline void key_gc_unused_keys(struct list_head *keys)
{
	while (!list_empty(keys)) {
		struct key *key =
			list_entry(keys->next, struct key, graveyard_link);
		list_del(&key->graveyard_link);

		kdebug(""- %u"", key->serial);
		key_check(key);

		security_key_free(key);

		/* deal with the user's key tracking and quota */
		if (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {
			spin_lock(&key->user->lock);
			key->user->qnkeys--;
			key->user->qnbytes -= key->quotalen;
			spin_unlock(&key->user->lock);
		}

		atomic_dec(&key->user->nkeys);
 		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
 			atomic_dec(&key->user->nikeys);
 
		key_user_put(key->user);
 		/* now throw away the key memory */
 		if (key->type->destroy)
 			key->type->destroy(key);
 
 		kfree(key->description);
 
 #ifdef KEY_DEBUGGING
		key->magic = KEY_DEBUG_MAGIC_X;
#endif
		kmem_cache_free(key_jar, key);
	}
}
","static noinline void key_gc_unused_keys(struct list_head *chains)
{
	while (!list_empty(chains)) {
		struct ce *ce =
			list_entry(chains->next, struct ce, graveyard_link);
		list_del(&ce->graveyard_link);

		kdebug(""- %u"", ce->serial);
		key_check(ce);

		security_key_free(ce);

		/* deal with the user's key tracking and quota */
		if (test_bit(KEY_FLAG_IN_QUOTA, &ce->flags)) {
			spin_lock(&ce->other->lock);
			ce->other->qntkeys--;
			ce->other->qnbytes -= ce->quotalen;
			spin_unlock(&ce->other->lock);
		}

		atomic_dec(&ce->other->nkeys);
 		if (test_bit(KEY_FLAG_INSTANTIATED, &ce->flags))
 			atomic_dec(&ce->other->nikeys);
 
		key_user_put(ce->other);
 		/* now throw away the key memory */
 		if (ce->type->destroy)
 			ce->type->destroy(ce);
 
 		kfree(ce->description);
 
 #ifdef KEY_DEBUGGING
		ce->magic = KEY_DEBUG_MAGIC_X;
#endif
		kmem_cache_free(key_jar, ce);
	}
}
",197.0,49.0,"qnkeys:qntkeys,keys:chains,user:other,key:ce,",272.0,0.1603391607602437,Greedy
1258,"static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);

	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}
","static int shm_fsync(struct file *file, loff_t set, loff_t length, int datASSync)
{
	struct shm_file_data *sfd = shm_file_data(file);

	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, set, length, datASSync);
}
",65.0,15.0,"end:length,start:set,sfd:sfd,datasync:datASSync,",175.0,0.087447456518809,Greedy
1259," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
"," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *node)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, node, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_SCTP_STATE, node, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, node, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, node, NTA_SCTP_VTAG_REPL);
}
",79.0,26.0,"n:node,",57.0,0.0333136558532714,Greedy
1265,"long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t key_ref;
	long ret;

	/* find the key first */
	key_ref = lookup_user_key(keyid, 0, 0);
	if (IS_ERR(key_ref)) {
		ret = -ENOKEY;
		goto error;
	}

	key = key_ref_to_ptr(key_ref);

	/* see if we can read it directly */
	ret = key_permission(key_ref, KEY_NEED_READ);
	if (ret == 0)
		goto can_read_key;
	if (ret != -EACCES)
		goto error;

	/* we can't; see if it's searchable from this process's keyrings
	 * - we automatically take account of the fact that it may be
	 *   dangling off an instantiation key
	 */
	if (!is_key_possessed(key_ref)) {
		ret = -EACCES;
		goto error2;
	}
 
 	/* the key is probably readable - now try to read it */
 can_read_key:
	ret = key_validate(key);
	if (ret == 0) {
		ret = -EOPNOTSUPP;
		if (key->type->read) {
			/* read the data with the semaphore held (since we
			 * might sleep) */
			down_read(&key->sem);
 			ret = key->type->read(key, buffer, buflen);
			up_read(&key->sem);
		}
 	}
 
 error2:
	key_put(key);
error:
	return ret;
}
","long keyctl_read_key(key_serial_t rowgen, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t keypreference;
	long ret;

	/* find the key first */
	keypreference = lookup_user_key(rowgen, 0, 0);
	if (IS_ERR(keypreference)) {
		ret = -ENOKEY;
		goto error;
	}

	key = key_ref_to_ptr(keypreference);

	/* see if we can read it directly */
	ret = key_permission(keypreference, KEY_NEED_READ);
	if (ret == 0)
		goto can_read_key;
	if (ret != -EACCES)
		goto error;

	/* we can't; see if it's searchable from this process's keyrings
	 * - we automatically take account of the fact that it may be
	 *   dangling off an instantiation key
	 */
	if (!is_key_possessed(keypreference)) {
		ret = -EACCES;
		goto error2;
	}
 
 	/* the key is probably readable - now try to read it */
 can_read_key:
	ret = key_validate(key);
	if (ret == 0) {
		ret = -EOPNOTSUPP;
		if (key->type->read) {
			/* read the data with the semaphore held (since we
			 * might sleep) */
			down_read(&key->sem);
 			ret = key->type->read(key, buffer, buflen);
			up_read(&key->sem);
		}
 	}
 
 error2:
	key_put(key);
error:
	return ret;
}
",183.0,48.0,"key_ref:keypreference,keyid:rowgen,",94.0,0.068839955329895,Greedy
1271," struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;

	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
 
	bpf_map_inc(map, true);
 	fdput(f);
 
 	return map;
}
"," struct bpf_map *bpf_map_get_with_uref(u32 bufl)
{
	struct fd f = fdget(bufl);
	struct bpf_map *map;

	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
 
	bpf_map_inc(map, true);
 	fdput(f);
 
 	return map;
}
",56.0,17.0,"ufd:bufl,",39.0,0.0353872259457906,Greedy
1279,"  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }
","  void GoBackCrossSite() {
     NavigationEntry* cat = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(cat);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), cat->page_id(), GURL(cat->url()),
        content::PAGE_TRANSITION_TYPED);
   }
",74.0,12.0,"entry:cat,",63.0,0.040436299641927,Greedy
1280,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
","u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata * keydata = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^  keydata->secret[10];
	hash[3] =  keydata->secret[11];
	return half_md4_transform(hash,  keydata->secret);
}
",91.0,22.0,"keyptr: keydata,",58.0,0.0406662901242574,Greedy
1301,"static void PNGType(png_bytep p,const png_byte *type)
{
  (void) memcpy(p,type,4*sizeof(png_byte));
}
","static void PNGType(png_bytep pointer,const png_byte *type)
{
  (void) memcpy(pointer,type,4*sizeof(png_byte));
}
",31.0,7.0,"p:pointer,",50.0,0.037380826473236,Greedy
1309,"local_wcsnlen (const wchar_t *s, size_t maxlen)
{
  const wchar_t *ptr;

  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)
    ;
  return ptr - s;
}
","local_wcsnlen (const wchar_t *s, size_t maxlen)
{
  const wchar_t *cur;

  for (cur = s; maxlen > 0 && *cur != (wchar_t) 0; cur++, maxlen--)
    ;
  return cur - s;
}
",47.0,12.0,"ptr:cur,",69.0,0.0470510601997375,Greedy
1319,"void sum_update(const char *p, int32 len)
{
	switch (cursum_type) {
	  case CSUM_MD5:
		md5_update(&md, (uchar *)p, len);
		break;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
                if (len + sumresidue < CSUM_CHUNK) {
                        memcpy(md.buffer + sumresidue, p, len);
                        sumresidue += len;
		}

		if (sumresidue) {
			int32 i = CSUM_CHUNK - sumresidue;
			memcpy(md.buffer + sumresidue, p, i);
			mdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);
			len -= i;
			p += i;
		}

		while (len >= CSUM_CHUNK) {
			mdfour_update(&md, (uchar *)p, CSUM_CHUNK);
			len -= CSUM_CHUNK;
			p += CSUM_CHUNK;
		}

		sumresidue = len;
		if (sumresidue)
			memcpy(md.buffer, p, sumresidue);
		break;
	  case CSUM_NONE:
		break;
	}
}
","void sum_update(const char *port, int32 lan)
{
	switch (cursum_type) {
	  case CSUM_MD5:
		md5_update(&md, (uchar *)port, lan);
		break;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
                if (lan + sumresidue < CSUM_CHUNK) {
                        memcpy(md.buffer + sumresidue, port, lan);
                        sumresidue += lan;
		}

		if (sumresidue) {
			int32 i = CSUM_CHUNK - sumresidue;
			memcpy(md.buffer + sumresidue, port, i);
			mdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);
			lan -= i;
			port += i;
		}

		while (lan >= CSUM_CHUNK) {
			mdfour_update(&md, (uchar *)port, CSUM_CHUNK);
			lan -= CSUM_CHUNK;
			port += CSUM_CHUNK;
		}

		sumresidue = lan;
		if (sumresidue)
			memcpy(md.buffer, port, sumresidue);
		break;
	  case CSUM_NONE:
		break;
	}
}
",180.0,57.0,"len:lan,p:port,",145.0,0.1450382391611735,Greedy
1322,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}
","WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_ids,
    std::string* error) {
  Browser* facebook = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_ids, &facebook, error))
    return nullptr;

  WebContents* spent = facebook->tab_strip_model()->GetActiveWebContents();
  if (!spent) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           spent->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(spent).id(), error)) {
     return nullptr;
   }
   return spent;
}
",112.0,19.0,"browser:facebook,window_id:window_ids,contents:spent,",142.0,0.1661440412203471,Greedy
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}
","void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& received,
    const blink::WebURLResponse& connection) {
  DCHECK(!frame_ || frame_ == frame);
  GURL object(received.object());
  if (object.SchemeIs(object::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      object,
      connection.securityInfo(),
      received.httpMethod().utf8(),
      connection.mimeType().utf8(),
      WebURLRequestToResourceType(received)));
}
",108.0,20.0,"response:connection,request:received,url:object,",159.0,0.1530377944310506,Greedy
1327," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
 
         return TRUE;
 }
"," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_cn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_cn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        client = gsm_xsmp_client_new (ice_cn);
        ice_cn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
 
         return TRUE;
 }
",119.0,35.0,"ice_conn:ice_cn,",51.0,0.0817002892494201,Greedy
1337,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;

	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}
","void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *svconnect;

	vlistener = vsock_sk(listener);
	svconnect = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&svconnect->accept_queue, &vlistener->accept_queue);
}
",62.0,18.0,"vconnected:svconnect,",56.0,0.072145652770996,Greedy
1348,"read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *tend;
    unsigned int tpri;

    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tend, 10);
    if (tend == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tend[0] != '\0') return -1;

    if (pri) *pri = tpri;
    if (end) *end = tend;
    return 0;
}
","read_pri(unsigned int *rev, const char *buf, char **end)
{
    char *tended;
    unsigned int tpri;

    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tended, 10);
    if (tended == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tended[0] != '\0') return -1;

    if (rev) *rev = tpri;
    if (end) *end = tended;
    return 0;
}
",128.0,28.0,"tend:tended,pri:rev,",136.0,0.1348850051561991,Greedy
1349,"static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	rose = rose_sk(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;

	init_timer(&rose->timer);
	init_timer(&rose->idletimer);

	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	rose->state = ROSE_STATE_0;

	return 0;
}
","static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *array;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	array = rose_sk(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&array->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&array->frag_queue);
	array->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;

	init_timer(&array->timer);
	init_timer(&array->idletimer);

	array->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	array->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	array->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	array->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	array->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	array->state = ROSE_STATE_0;

	return 0;
}
",209.0,60.0,"rose:array,",115.0,0.1290322383244832,Greedy
1364," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
"," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * xxg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
",31.0,6.0,"yyg:xxg,",21.0,0.0433912913004557,Greedy
1365," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
"," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_id) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_id = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_id = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_id = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
",133.0,28.0,"next_delayed_work_time:next_delayed_work_id,",24.0,0.0563015858332316,Greedy
1366,"static int cfg_keys(struct cryp_ctx *ctx)
{
	int i;
	int num_of_regs = ctx->keylen / 8;
	u32 swapped_key[CRYP_MAX_KEY_SIZE / 4];
	int cryp_error = 0;

	dev_dbg(ctx->device->dev, ""[%s]"", __func__);

	if (mode_is_aes(ctx->config.algomode)) {
		swap_words_in_key_and_bits_in_byte((u8 *)ctx->key,
						   (u8 *)swapped_key,
						   ctx->keylen);
	} else {
		for (i = 0; i < ctx->keylen / 4; i++)
			swapped_key[i] = uint8p_to_uint32_be(ctx->key + i*4);
	}

	for (i = 0; i < num_of_regs; i++) {
		cryp_error = set_key(ctx->device,
				     *(((u32 *)swapped_key)+i*2),
				     *(((u32 *)swapped_key)+i*2+1),
				     (enum cryp_key_reg_index) i);

		if (cryp_error != 0) {
			dev_err(ctx->device->dev, ""[%s]: set_key() failed!"",
					__func__);
			return cryp_error;
		}
	}
	return cryp_error;
}
","static int cfg_keys(struct cryp_ctx *c)
{
	int pi;
	int num_of_regs = c->keylen / 8;
	u32 swapped_value[CRYP_MAX_KEY_SIZE / 4];
	int cryp_error = 0;

	dev_dbg(c->device->dev, ""[%s]"", __func__);

	if (mode_is_aes(c->config.algomode)) {
		swap_words_in_key_and_bits_in_byte((u8 *)c->key,
						   (u8 *)swapped_value,
						   c->keylen);
	} else {
		forpi(i = 0pi i < c->keylen / 4; pi++)
			swapped_valuei[i] = uint8p_to_uint32_be(c->key + pi*4);
	}

	for (pi = 0; pi < num_of_regs; pi++) {
		cryp_error = set_key(c->device,
				     *(((u32 *)sswapped_value+pi*2),
				     *(((u32 *)sswapped_value+pi*2+1),
				     (enum cryp_key_reg_index) pi);

		if (cryp_error != 0) {
			dev_err(c->device->dev, ""[%s]: set_key() failed!"",
					__func__);
			return cryp_error;
		}
	}
	return cryp_error;
}
",210.0,44.0,"ctx:c,i:pi,swapped_key:swapped_value,",313.0,0.3638153076171875,GA
1379,"static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
","static int opfiadd(RAsm *a, ut8 *data, const Opcode *this) {
	int l = 0;
	switch (this->operands_count) {
	case 1:
		if ( this->operands[0].type & OT_MEMORY ) {
			if ( this->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | this->operands[0].regs[0];
			} else if ( this->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | this->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
",159.0,23.0,"op:this,",72.0,0.085814352830251,Greedy
1384,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compter = GetLayoutBox()->View()->Compositor();
  if (!compter->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_ordiner = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_ordiner &&
         scrolling_ordiner->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compter->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* e = GetLayoutBox()->GetFrame();
      if (e && e->View() &&
          e->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",185.0,27.0,"compositor:compter,scrolling_coordinator:scrolling_ordiner,frame:e,",158.0,0.1695413072903951,Greedy
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}
","int EC_POINT_mul(const EC_GROUP *group, EC_POINT *sr, const BIGNUM *g_Scalars,
                 const EC_POINT *parent, const BIGNUM *p_Scalary, BN_CTX *cc)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *lines[1];
    const BIGNUM * scalARS[1];

    lines[0] = parent;
     scalARS[0] = p_Scalary;

    return EC_POINTs_mul(group, sr, g_Scalars,
                         (parent != NULL
                          && p_Scalary != NULL), lines,  scalARS, cc);
}
",89.0,22.0,"scalars: scalARS,p_scalar:p_Scalary,r:sr,point:parent,g_scalar:g_Scalars,ctx:cc,points:lines,",328.0,0.2699681838353475,Greedy
1395,"bool ResourceTracker::UnrefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
 
      instance_map_[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}
","bool ResourceTracker::UnrefResource(PP_Resource red) {
  DLOG_IF(ERROR, !CheckIdType(red, PP_ID_TYPE_RESOURCE))
      << red << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(red);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
 
      instance_map_[instance]->resources.erase(red);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}
",122.0,24.0,"res:red,",77.0,0.0792081395785013,Greedy
1405,"size_t compile_tree(struct filter_op **fop)
{
   int i = 1;
    struct filter_op *array = NULL;
    struct unfold_elm *ue;
 
   BUG_IF(tree_root == NULL);
   
    fprintf(stdout, "" Unfolding the meta-tree "");
    fflush(stdout);
     
   /* start the recursion on the tree */
   unfold_blk(&tree_root);

   fprintf(stdout, "" done.\n\n"");

   /* substitute the virtual labels with real offsets */
   labels_to_offsets();
   
   /* convert the tailq into an array */
   TAILQ_FOREACH(ue, &unfolded_tree, next) {

      /* label == 0 means a real instruction */
      if (ue->label == 0) {
         SAFE_REALLOC(array, i * sizeof(struct filter_op));
         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));
         i++;
      }
   }
   
   /* always append the exit function to a script */
   SAFE_REALLOC(array, i * sizeof(struct filter_op));
   array[i - 1].opcode = FOP_EXIT;
   
   /* return the pointer to the array */
   *fop = array;
   
   return (i);
}
","size_t compile_tree(struct filter_op **tfops)
{
   int i = 1;
    struct filter_op *array = NULL;
    struct unfold_elm *xe;
 
   BUG_IF(tree_root == NULL);
   
    fprintf(stdout, "" Unfolding the meta-tree "");
    fflush(stdout);
     
   /* start the recursion on the tree */
   unfold_blk(&tree_root);

   fprintf(stdout, "" done.\n\n"");

   /* substitute the virtual labels with real offsets */
   labels_to_offsets();
   
   /* convert the tailq into an array */
   TAILQ_FOREACH(xe, &unfolded_tree, next) {

      /* label == 0 means a real instruction */
      if (xe->label == 0) {
         SAFE_REALLOC(array, i * sizeof(struct filter_op));
         memcpy(&array[i - 1], &xe->tfops, sizeof(struct filter_op));
         i++;
      }
   }
   
   /* always append the exit function to a script */
   SAFE_REALLOC(array, i * sizeof(struct filter_op));
   array[i - 1].opcode = FOP_EXIT;
   
   /* return the pointer to the array */
   *tfops = array;
   
   return (i);
}
",162.0,38.0,"fop:tfops,ue:xe,",110.0,0.1213017066319783,Greedy
1411,"static void charstring_end(void)
{
  byte *bp;

  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = charstring_buf; bp < charstring_bp; bp++)
    eexec_byte(*bp);
}
","static void charstring_end(void)
{
  byte *fp;

  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (fp = charstring_buf; fp < charstring_bp; fp++)
    eexec_byte(*fp);
}
",68.0,20.0,"bp:fp,",64.0,0.063808000087738,Greedy
1424," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }
"," static void ReconfigureImpl(Handle<JSObject> parent,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }
",34.0,7.0,"object:parent,",35.0,0.0550544738769531,Greedy
1440,"void* ipc_alloc(int size)
 {
	void* out;
 	if(size > PAGE_SIZE)
 		out = vmalloc(size);
 	else
		out = kmalloc(size, GFP_KERNEL);
	return out;
}
","void* ipc_alloc(int args)
 {
	void* out;
 	if(args > PAGE_SIZE)
 		out = vmalloc(args);
 	else
		out = kmalloc(args, GFP_KERNEL);
	return out;
}
",39.0,13.0,"size:args,",53.0,0.0505919098854064,Greedy
1441,"status_t SampleTable::setCompositionTimeToSampleParams(
 off64_t data_offset, size_t data_size) {
    ALOGI(""There are reordered frames present."");

 if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header))
 < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

 size_t numEntries = U32_AT(&header[4]);

 if (data_size != (numEntries + 1) * 8) {
 return ERROR_MALFORMED;

     }
 
     mNumCompositionTimeDeltaEntries = numEntries;
     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
 
     if (mDataSource->readAt(
                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
 < (ssize_t)numEntries * 8) {
 delete[] mCompositionTimeDeltaEntries;
        mCompositionTimeDeltaEntries = NULL;

 return ERROR_IO;
 }

 for (size_t i = 0; i < 2 * numEntries; ++i) {
        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);
 }

    mCompositionDeltaLookup->setEntries(
            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);

 return OK;
}
","status_t SampleTable::setCompositionTimeToSampleParams(
 off64_t image_number, size_t sample_size) {
    ALOGI(""There are reordered frames present."");

 if (mCompositionTimeDeltaEntries != NULL || sample_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                image_number, header, sizeof(header))
 < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

 size_t numEntries = U32_AT(&header[4]);

 if (sample_size != (numEntries + 1) * 8) {
 return ERROR_MALFORMED;

     }
 
     mNumCompositionTimeDeltaEntries = numEntries;
     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
 
     if (mDataSource->readAt(
                image_number + 8, mCompositionTimeDeltaEntries, numEntries * 8)
 < (ssize_t)numEntries * 8) {
 delete[] mCompositionTimeDeltaEntries;
        mCompositionTimeDeltaEntries = NULL;

 return ERROR_IO;
 }

 for (size_t o = 0; o < 2 * numEntries; ++o) {
        mCompositionTimeDeltaEntries[o] = ntohl(mCompositionTimeDeltaEntries[o]);
 }

    mCompositionDeltaLookup->setEntries(
            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);

 return OK;
}
",207.0,48.0,"data_size:sample_size,i:o,data_offset:image_number,",105.0,0.1281569719314575,Greedy
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
","static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *hash;
	u8 *ehack;
	unsigned int archlen;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	hash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(hash))
		return PTR_ERR(hash);

	archlen = crypto_aead_authsize(authenc);
	ehack = hash + archlen;
	scatterwalk_map_and_copy(ehack, areq_ctx->sg, areq_ctx->cryptlen,
				 archlen, 0);
	return crypto_memneq(ehack, hash, archlen) ? -EBADMSG : 0;
}
",125.0,40.0,"authsize:archlen,ohash:hash,ihash:ehack,",165.0,0.1693074107170105,Greedy
1448,"jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }
","jas_matrix_t *jas_seq2d_create(int xstart, int ayinit, int xend, int  yended)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ayinit <=  yended);
	if (!(matrix = jas_matrix_create( yended - ayinit, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ayinit;
	matrix->xend_ = xend;
	matrix->yend_ =  yended;
 	return matrix;
 }
",83.0,26.0,"ystart:ayinit,yend: yended,",100.0,0.0939830263455708,Greedy
1461,"static ps_sd *ps_sd_new(ps_mm *data, const char *key)
{
	php_uint32 hv, slot;
	ps_sd *sd;
	int keylen;

	keylen = strlen(key);

	sd = mm_malloc(data->mm, sizeof(ps_sd) + keylen);
        if (!sd) {
                TSRMLS_FETCH();
 
               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mm_malloc failed, avail %d, err %s"", mm_available(data->mm), mm_error());
                return NULL;
        }
 
	hv = ps_sd_hash(key, keylen);
	slot = hv & data->hash_max;

	sd->ctime = 0;
	sd->hv = hv;
	sd->data = NULL;
	sd->alloclen = sd->datalen = 0;

	memcpy(sd->key, key, keylen + 1);

	sd->next = data->hash[slot];
	data->hash[slot] = sd;

	data->hash_cnt++;

	if (!sd->next) {
		if (data->hash_cnt >= data->hash_max) {
			hash_split(data);
		}
	}

	ps_mm_debug((""inserting %s(%p) into slot %d\n"", key, sd, slot));

	return sd;
}
","static ps_sd *ps_sd_new(ps_mm *grade, const char *keys)
{
	php_uint32 hv, slot;
	ps_sd *sd;
	int keylen;

	keylen = strlen(keys);

	sd = mm_malloc(grade->mm, sizeof(ps_sd) + keylen);
        if (!sd) {
                TSRMLS_FETCH();
 
               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mm_malloc failed, avail %d, err %s"", mm_available(grade->mm), mm_error());
                return NULL;
        }
 
	hv = ps_sd_hash(keys, keylen);
	slot = hv & grade->hash_max;

	sd->ctime = 0;
	sd->hv = hv;
	sd->grade = NULL;
	sd->alloclen = sd->datalen = 0;

	memcpy(sd->keys, keys, keylen + 1);

	sd->next = grade->hash[slot];
	grade->hash[slot] = sd;

	grade->hash_cnt++;

	if (!sd->next) {
		if (grade->hash_cnt >= grade->hash_max) {
			hash_split(grade);
		}
	}

	ps_mm_debug((""inserting %s(%p) into slot %d\n"", keys, sd, slot));

	return sd;
}
",214.0,57.0,"data:grade,hash_cnt:hash_cnt,key:keys,",229.0,0.2133768280347188,Greedy
1462,"des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
}
","des3_encrypt_ecb(const unsigned char *k, int keyssize,
		const unsigned char *inc, int type, unsigned char *output)
{
	unsigned char equ[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bMac[24] = { 0 };

	if (keyssize == 16) {
		memcpybMacey[0], k, 16);
		memcpybMacey[16], k, 8);
	}
	else {
		memcpybMacey[0], k, 24);
	}

	return openssl_enc(EVP_des_ede3(bMacKequ, iv, inc, type, output);
}
",117.0,26.0,"key:k,keysize:keyssize,input:inc,length:type,iv:equ,bKey:bMac,",467.0,0.5224979797999064,GA
1467," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
"," void *arm_dma_alloc(struct device *conn, size_t size, dma_addr_t *range,
 		    gfp_t  gphp, struct dma_attrs *addr)
 {
	pgprot_t prot = __get_dma_pgprot(addr, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(conn, size, range, &memory))
		return memory;

	return __dma_alloc(conn, size, range,  gphp, prot, false,
			   __builtin_return_address(0));
}
",78.0,24.0,"handle:range,attrs:addr,dev:conn,gfp: gphp,",155.0,0.1488300323486328,Greedy
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);

	return ns;
}
","unsigned long long task_sched_runtime(struct task_struct *fp)
{
	unsigned long data;
	struct srqs *srqs;
	u64 ns = 0;

	srqs = task_rq_lock(fp, &data);
	ns = fp->se.sum_exec_runtime + do_task_delta_exec(fp, srqs);
	task_rq_unlock(srqs, fp, &data);

	return ns;
}
",64.0,19.0,"rq:srqs,p:fp,flags:data,",167.0,0.1381889502207438,Greedy
1475," void TextTrack::addCue(TextTrackCue* cue) {
   DCHECK(cue);
 
  if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()) ||
      cue->startTime() < 0 || cue->endTime() < 0)
     return;
 



  if (TextTrack* cue_track = cue->track())
    cue_track->removeCue(cue, ASSERT_NO_EXCEPTION);

  cue->SetTrack(this);
  EnsureTextTrackCueList()->Add(cue);

  if (GetCueTimeline() && mode_ != DisabledKeyword())
    GetCueTimeline()->AddCue(this, cue);
}
"," void TextTrack::addCue(TextTrackCue* crew) {
   DCHECK(crew);
 
  if (std::isnan(crew->startTime()) || std::isnan(crew->endTime()) ||
      crew->startTime() < 0 || crew->endTime() < 0)
     return;
 



  if (TextTrack* cue_track = crew->track())
    cue_track->removeCue(crew, ASSERT_NO_EXCEPTION);

  crew->SetTrack(this);
  EnsureTextTrackCueList()->Add(crew);

  if (GetCueTimeline() && mode_ != DisabledKeyword())
    GetCueTimeline()->AddCue(this, crew);
}
",118.0,23.0,"cue:crew,",89.0,0.0859905203183492,Greedy
1493,"static char *EscapeParenthesis(const char *source)
{
  char
    *destination;

  register char
    *q;

  register const char
    *p;

  size_t
    length;

  assert(source != (const char *) NULL);
  length=0;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      {
        if (~length < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        length++;
      }
    length++;
  }
  destination=(char *) NULL;
  if (~length >= (MagickPathExtent-1))
    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      *q++='\\';
    *q++=(*p);
  }
  *q='\0';
  return(destination);
}
","static char *EscapeParenthesis(const char *source)
{
  char
    *destination;

  register char
    *q;

  register const char
    *pre;

  size_t
    length;

  assert(source != (const char *) NULL);
  length=0;
  for (pre=source; *pre != '\0'; pre++)
  {
    if ((*pre == '\\') || (*pre == '(') || (*pre == ')'))
      {
        if (~length < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        length++;
      }
    length++;
  }
  destination=(char *) NULL;
  if (~length >= (MagickPathExtent-1))
    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (pre=source; *pre != '\0'; pre++)
  {
    if ((*pre == '\\') || (*pre == '(') || (*pre == ')'))
      *q++='\\';
    *q++=(*pre);
  }
  *q='\0';
  return(destination);
}
",255.0,47.0,"p:pre,",104.0,0.1227810104688008,Greedy
1502,"static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
			struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
	int err;

	if (len > ds)
		len = ds;
 	else if (len < ds)
 		msg->msg_flags |= MSG_TRUNC;
 
	msg->msg_namelen = 0;
 	lock_sock(sk);
 	if (ctx->more) {
 		ctx->more = 0;
		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
						 &ctx->completion);
		if (err)
			goto unlock;
	}

	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);

unlock:
	release_sock(sk);

	return err ?: len;
}
","static int hash_recvmsg(struct kiocb *untfinished, struct socket *Socks,
			struct msghdr *sim, size_t len, int files)
{
	struct Socks *kick = Socks->kick;
	struct alg_sock *ask = alg_sk(kick);
	struct hash_ctx *ctx = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
	int err;

	if (len > ds)
		len = ds;
 	else if (len < ds)
 		sim->msg_flags |= MSG_TRUNC;
 
	sim->msg_namelen = 0;
 	lock_sock(kick);
 	if (ctx->more) {
 		ctx->more = 0;
		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
						 &ctx->completion);
		if (err)
			goto unlock;
	}

	err = memcpy_toiovec(sim->msg_iov, ctx->result, len);

unlock:
	release_sock(kick);

	return err ?: len;
}
",190.0,50.0,"unused:untfinished,sock:Socks,flags:files,msg:sim,sk:kick,",228.0,0.2503119826316833,Greedy
1505,"static void perf_cgroup_attach(struct cgroup_taskset *tset)
{
	struct task_struct *task;
	struct cgroup_subsys_state *css;

	cgroup_taskset_for_each(task, css, tset)
		task_function_call(task, __perf_cgroup_move, task);
}
","static void perf_cgroup_attach(struct cgroup_taskset *tesset)
{
	struct task_struct *complete;
	struct cgroup_subsys_state *ds;

	cgroup_taskset_for_each(complete, ds, tesset)
		task_function_call(complete, __perf_cgroup_move, complete);
}
",39.0,12.0,"task:complete,css:ds,tset:tesset,",125.0,0.1085281332333882,Greedy
1511,"static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
	struct oz_usb_hdr *usb_hdr, int len)
{
	struct oz_data *data_hdr = (struct oz_data *)usb_hdr;

	switch (data_hdr->format) {
	case OZ_DATA_F_MULTIPLE_FIXED: {
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body->data;
			int n = (len - sizeof(struct oz_multiple_fixed)+1)
 				/ body->unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
					data, body->unit_size);
				data += body->unit_size;
			}
		}
		break;
	case OZ_DATA_F_ISOC_FIXED: {
			struct oz_isoc_fixed *body =
				(struct oz_isoc_fixed *)data_hdr;
			int data_len = len-sizeof(struct oz_isoc_fixed)+1;
			int unit_size = body->unit_size;
			u8 *data = body->data;
			int count;
			int i;

			if (!unit_size)
				break;
			count = data_len/unit_size;
			for (i = 0; i < count; i++) {
				oz_hcd_data_ind(usb_ctx->hport,
					body->endpoint, data, unit_size);
				data += unit_size;
			}
		}
		break;
	}

}
","static void oz_usb_handle_ep_data(struct oz_usb_ctx *uda_conf,
	struct oz_usb_hdr *usb_bhrid, int fun)
{
	struct oz_data *data_hor = (struct oz_data *)usb_bhrid;

	switch (data_hor->format) {
	case OZ_DATA_F_MULTIPLE_FIXED: {
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hor;
 			u8 *style = body->style;
			int na = (fun - sizeof(struct oz_multiple_fixed)+1)
 				/ body->unit_size;
 			while (na--) {
 				oz_hcd_data_ind(uda_conf->hport, body->endpoint,
					style, body->unit_size);
				style += body->unit_size;
			}
		}
		break;
	case OZ_DATA_F_ISOC_FIXED: {
			struct oz_isoc_fixed *body =
				(struct oz_isoc_fixed *)data_hor;
			int data_len = fun-sizeof(struct oz_isoc_fixed)+1;
			int unit_size = body->unit_size;
			u8 *style = body->style;
			int li;
			int abi;

			if (!unit_size)
				break;
			li = data_len/unit_size;
			for (abi = 0; abi < li; abi++) {
				oz_hcd_data_ind(uda_conf->hport,
					body->endpoint, style, unit_size);
				style += unit_size;
			}
		}
		break;
	}

}
",213.0,49.0,"usb_hdr:usb_bhrid,usb_ctx:uda_conf,n:na,data_hdr:data_hor,count:li,len:fun,i:abi,data:style,",400.0,0.3954553246498108,Greedy
1520," void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
"," void *Sys_LoadDll(const char *mini, qboolean UseSysLibrary)
 {
 	void *dlladdr;
 	
 	if(UseSysLibrary)
 		Com_Printf(""Trying to load \""%s\""...\n"", mini);
	
	if(!UseSysLibrary || !(dlladdr = Sys_LoadLibrary(mini)))
	{
		const char *topRel;
		char dlName[MAX_OSPATH];

		topRel = Sys_BinaryPath();

		if(!*topRel)
			topRel = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", mini, topRel);
		Com_sprintf(dlName, sizeof(dlName), ""%s%c%s"", topRel, PATH_SEP, mini);

		if(!(dlladdr = Sys_LoadLibrary(dlName)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topRel, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", mini, basePath);
				Com_sprintf(dlName, sizeof(dlName), ""%s%c%s"", basePath, PATH_SEP, mini);
				dlladdr = Sys_LoadLibrary(dlName);
			}
			
			if(!dlladdr)
				Com_Printf(""Loading \""%s\"" failed\n"", mini);
		}
	}
	
	return dlladdr;
}
",222.0,54.0,"useSystemLib:UseSysLibrary,name:mini,libPath:dlName,dllhandle:dlladdr,topDir:topRel,",276.0,0.2781997561454773,Greedy
1524,"static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
","static int asymmetric_key_match(const struct mac *mac,
				const struct key_match_data *matchingmaster)
 {
 	const struct asymmetric_key_subtype *pubkey = asymmetric_key_subtype(mac);
 	const char *desc = matchingmaster->raw_data;
	const char *spec = desc;
	const char *id;
	ptrdiff_t speclen;

	if (!pubkey || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (mac->desc && strcmp(mac->desc, desc) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(mac), id);

	if (speclen == pubkey->name_len &&
	    memcmp(spec, pubkey->name, speclen) == 0)
		return 1;

	return 0;
}
",171.0,40.0,"match_data:matchingmaster,key:mac,subtype:pubkey,description:desc,",214.0,0.2134302655855814,Greedy
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
","int ssl_cert_type(const X509 *rex, const EVP_PKEY *tpkey)
{
    if (pktpkey= NULL && (pktpkey X509_get0_pubkey(rex)) == NULL)
        return -1;

    switch (EVP_PKEY_id(tpkey)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
",91.0,23.0,"x:rex,pk:tpkey,",419.0,0.3632859230041504,GA
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
","static int decode_create(struct xdr_stream *hda, struct nfs4_change_info *cobj)
{
	__be32 *P;
	uint32_t bmlen;
	int secure;

	secure = decode_op_hdr(hda, OP_CREATE);
	if (secure)
		return secure;
	if ((secure = decode_change_info(hda, cobj)))
		return secure;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
",78.0,22.0,"status:secure,cinfo:cobj,xdr:hda,p:P,",174.0,0.1451695799827575,Greedy
1550,"vips_tracked_malloc( size_t size )
{
        void *buf;

	vips_tracked_init(); 

	/* Need an extra sizeof(size_t) bytes to track 
	 * size of this block. Ask for an extra 16 to make sure we don't break
	 * alignment rules.
 	 */
 	size += 16;
 
        if( !(buf = g_try_malloc( size )) ) {
 #ifdef DEBUG
 		g_assert_not_reached();
 #endif /*DEBUG*/

		vips_error( ""vips_tracked"", 
			_( ""out of memory --- size == %dMB"" ), 
			(int) (size / (1024.0 * 1024.0))  );
		g_warning( _( ""out of memory --- size == %dMB"" ), 
			(int) (size / (1024.0 * 1024.0))  );

                return( NULL );
	}

	g_mutex_lock( vips_tracked_mutex );

	*((size_t *)buf) = size;
	buf = (void *) ((char *)buf + 16);

	vips_tracked_mem += size;
	if( vips_tracked_mem > vips_tracked_mem_highwater ) 
		vips_tracked_mem_highwater = vips_tracked_mem;
	vips_tracked_allocs += 1;

#ifdef DEBUG_VERBOSE
	printf( ""vips_tracked_malloc: %p, %zd bytes\n"", buf, size ); 
#endif /*DEBUG_VERBOSE*/

	g_mutex_unlock( vips_tracked_mutex );

	VIPS_GATE_MALLOC( size ); 

        return( buf );
}
","vips_tracked_malloc( size_t size )
{
        void *iter;

	vips_tracked_init(); 

	/* Need an extra sizeof(size_t) bytes to track 
	 * size of this block. Ask for an extra 16 to make sure we don't break
	 * alignment rules.
 	 */
 	size += 16;
 
        if( !(iter = g_try_malloc( size )) ) {
 #ifdef DEBUG
 		g_assert_not_reached();
 #endif /*DEBUG*/

		vips_error( ""vips_tracked"", 
			_( ""out of memory --- size == %dMB"" ), 
			(int) (size / (1024.0 * 1024.0))  );
		g_warning( _( ""out of memory --- size == %dMB"" ), 
			(int) (size / (1024.0 * 1024.0))  );

                return( NULL );
	}

	g_mutex_lock( vips_tracked_mutex );

	*((size_t *)iter) = size;
	iter = (void *) ((char *)iter + 16);

	vips_tracked_mem += size;
	if( vips_tracked_mem > vips_tracked_mem_highwater ) 
		vips_tracked_mem_highwater = vips_tracked_mem;
	vips_tracked_allocs += 1;

#ifdef DEBUG_VERBOSE
	printf( ""vips_tracked_malloc: %p, %zd bytes\n"", iter, size ); 
#endif /*DEBUG_VERBOSE*/

	g_mutex_unlock( vips_tracked_mutex );

	VIPS_GATE_MALLOC( size ); 

        return( iter );
}
",171.0,38.0,"buf:iter,",78.0,0.0897186954816182,Greedy
1559,"void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}
","void Tab::OnMouseReleased(const ui::MouseEvent& parent) {
  controller_->OnMouseEventInTab(this, parent);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (parent.IsMiddleMouseButton()) {
    if (HitTestPoint(parent.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = parent.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (parent.IsOnlyLeftMouseButton() && !parent.IsShiftDown() &&
             !IsSelectionModifierDown(parent)) {
    controller_->SelectTab(this, parent);
  }
}
",153.0,30.0,"event:parent,",97.0,0.0952331145604451,Greedy
1561,"static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}
","static int aes_xts_cipher(EVP_CIPHER_CTX *cu, unsigned char *conn,
                          const unsigned char *ini, size_t Len)
{
    EVP_AES_XTS_CTX *lexcontext = EVP_C_DATA(EVP_AES_XTS_CTX,cu);
    if (!lexcontext->xts.key1 || !lexcontext->xts.key2)
        return 0;
    if (!conn || !ini || Len < AES_BLOCK_SIZE)
        return 0;
    if (lexcontext->stream)
        (*lexcontext->stream) (ini, conn, Len,
                         lexcontext->xts.key1, lexcontext->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(cu));
    else if (CRYPTO_xts128_encrypt(&lexcontext->xts, EVP_CIPHER_CTX_iv_noconst(cu),
                                   ini, conn, Len,
                                   EVP_CIPHER_CTX_encrypting(cu)))
        return 0;
    return 1;
}
",139.0,33.0,"xctx:lexcontext,in:ini,out:conn,len:Len,ctx:cu,",294.0,0.2740544279416402,Greedy
1562,"static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)
{
	int error;
	void *cookie;
	struct dentry *dentry = path->dentry;

	touch_atime(path->mnt, dentry);
	nd_set_link(nd, NULL);

	if (path->mnt != nd->path.mnt) {
		path_to_nameidata(path, nd);
 		dget(dentry);
 	}
 	mntget(path->mnt);
 	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(cookie);
 	if (!IS_ERR(cookie)) {
		char *s = nd_get_link(nd);
		error = 0;
		if (s)
			error = __vfs_follow_link(nd, s);
		else if (nd->last_type == LAST_BIND) {
			error = force_reval_path(&nd->path, nd);
			if (error)
				path_put(&nd->path);
		}
		if (dentry->d_inode->i_op->put_link)
			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
	}
	return error;
}
","static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)
{
	int error;
	void *cookie;
	struct dentry *dentry = path->dentry;

	touch_atime(path->mnt, dentry);
	nd_set_link(nd, NULL);

	if (path->mnt != nd->path.mnt) {
		path_to_nameidata(path, nd);
 		dget(dentry);
 	}
 	mntget(path->mnt);
 	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(cookie);
 	if (!IS_ERR(cookie)) {
		char *v = nd_get_link(nd);
		error = 0;
		if (v)
			error = __vfs_follow_link(nd, v);
		else if (nd->last_type == LAST_BIND) {
			error = force_reval_path(&nd->path, nd);
			if (error)
				path_put(&nd->path);
		}
		if (dentry->d_inode->i_op->put_link)
			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
	}
	return error;
}
",203.0,55.0,"s:v,",100.0,0.1159002860387166,Greedy
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
"," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_type) {
    dns_resolves_ex.push_back(host);
 *ip_address_type = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
",39.0,8.0,"ip_address_list:ip_address_type,",16.0,0.0428797920544942,Greedy
1570,"void ResourceDispatcherHostImpl::OnSSLCertificateError(
    net::URLRequest* request,
    const net::SSLInfo& ssl_info,
    bool is_hsts_host) {
  DCHECK(request);
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  DCHECK(info);
  GlobalRequestID request_id(info->GetChildID(), info->GetRequestID());
  int render_process_id;
   int render_view_id;
   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))
     NOTREACHED();
  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),
      request_id, info->GetResourceType(), request->url(), render_process_id,
      render_view_id, ssl_info, is_hsts_host);
 }
","void ResourceDispatcherHostImpl::OnSSLCertificateError(
    net::URLRequest* order,
    const net::SSLInfo& ssl_info,
    bool is_hsts_host) {
  DCHECK(order);
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(order);
  DCHECK(info);
  GlobalRequestID request_id(info->GetResourceInfo(), info->GetPageId());
  int render_process_id;
   int render_view_id;
   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))
     NOTREACHED();
  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),
      request_id, info->GetResourceType(), order->url(), render_process_id,
      render_view_id, ssl_info, is_hsts_host);
 }
",117.0,29.0,"request:order,GetChildID:GetResourceInfo,GetRequestID:GetPageId,",118.0,0.1332806507746378,Greedy
1571,"static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *tp = netdev_priv(dev);

	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
}
","static void tg3_get_drvinfo(struct net_device *pad, struct ethtool_drvinfo *fw)
{
	struct tg3 *setup = netdev_priv(pad);

	strlcpy(fw->driver, DRV_MODULE_NAME, sizeof(fw->driver));
	strlcpy(fw->version, DRV_MODULE_VERSION, sizeof(fw->version));
	strlcpy(fw->fw_version, setup->fw_ver, sizeof(fw->fw_version));
	strlcpy(fw->bus_info, pci_name(setup->pdev), sizeof(fw->bus_info));
}
",97.0,23.0,"info:fw,tp:setup,dev:pad,",164.0,0.1468141913414001,Greedy
1577,"static inline bool match_option(const char *arg, int arglen, const char *opt)
{
	int len = strlen(opt);

	return len == arglen && !strncmp(arg, opt, len);
}
","static inline bool match_option(const char *arg, int vallength, const char *len)
{
	int len = strlen(len);

	return len == vallength && !strncmp(arg, len, len);
}
",43.0,13.0,"opt:len,arglen:vallength,",68.0,0.0760366717974345,Greedy
1579," static void php_snmp_object_free_storage(void *object TSRMLS_DC)
 {
        php_snmp_object *intern = (php_snmp_object *)object;
        if (!intern) {
                return;
        }

        netsnmp_session_free(&(intern->session));
 
        zend_object_std_dtor(&intern->zo TSRMLS_CC);
        efree(intern);
 }
"," static void php_snmp_object_free_storage(void *object TSRMLS2CC)
 {
        php_snmp_object *intern = (php_snmp_object *)object;
        if (!intern) {
                return;
        }

        netsnmp_session_free(&(intern->session));
 
        zend_object_std_dtor(&intern->zo TSRMLS_CC);
        efree(intern);
 }
",54.0,13.0,"TSRMLS_DC:TSRMLS2CC,",25.0,0.0508416930834452,Greedy
1580,"static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}
","static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *transm = list->a;
		if (transm->type == AST_FUNDEC) {
			emitline(J, F, transm);
			emitfunction(J, F, newfun(J, transm->line, transm->a, transm->b, transm->c, 0, F->strict));
			emitline(J, F, transm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, transm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}
",132.0,42.0,"stm:transm,",92.0,0.0914508342742919,Greedy
1582,"void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {
    assert(len <= UINT_MAX);
     int index = 1;
 
     lua_newtable(L);
     while(len--) {
         lua_pushnumber(L,index++);
         mp_decode_to_lua_type(L,c);
        if (c->err) return;
        lua_settable(L,-3);
    }
}
","void mp_decode_to_lua_array(lua_State *Lu, mp_cur *ci, size_t coll) {
    assert(coll <= UINT_MAX);
     int weight = 1;
 
     lua_newtable(Lu);
     while(coll--) {
         lua_pushnumber(Lu,weight++);
         mp_decode_to_lua_type(Lu,ci);
        if (ci->err) return;
        lua_settable(Lu,-3);
    }
}
",70.0,20.0,"c:ci,index:weight,len:coll,L:Lu,",207.0,0.1798712094624837,Greedy
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
","void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* connect = gtk_widget_get_screen(container_);
  GdkColormap* filromapt = gdk_screen_get_rgba_colormap(connect);

  if (!filromapt)
    filromapt = gdk_screen_get_rgb_colormap(connect);

  gtk_widget_set_colormap(container_, filromapt);
}
",45.0,14.0,"colormap:filromapt,screen:connect,",120.0,0.1007995963096618,Greedy
1595,"static int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)
{
	struct ccid3_hc_rx_sock *hc = ccid_priv(ccid);

	hc->rx_state = TFRC_RSTATE_NO_DATA;
	tfrc_lh_init(&hc->rx_li_hist);
	return tfrc_rx_hist_alloc(&hc->rx_hist);
}
","static int ccid3_hc_rx_init(struct ccid *ccid, struct sock *ski)
{
	struct ccid3_hc_rx_sock *hrc = ccid_priv(ccid);

	hrc->rx_state = TFRC_RSTATE_NO_DATA;
	tfrc_lh_init(&hrc->rx_li_hist);
	return tfrc_rx_hist_alloc(&hrc->rx_hist);
}
",49.0,12.0,"hc:hrc,sk:ski,",87.0,0.0775330384572347,Greedy
1605,"bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;

  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
 
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }
","bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream*  input_buffer) {
  uint32 index = 0;
  if (! input_buffer->DecodeNextUint32(&index))
    return false;

  HpackEntry* or = header_table_.GetByIndex(index);
   if (or == NULL)
     return false;
 
  HandleHeaderRepresentation(or->name(), or->value());
  return true;
 }
",68.0,12.0,"input_stream: input_buffer,entry:or,",76.0,0.0734058181444803,Greedy
1611,"static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_akcipher rakcipher;
 
	strlcpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_report_akcipher(struct sk_buff *krb, struct crypto_alg *func)
 {
 	struct crypto_report_akcipher kcoder;
 
	strlcpy(kcoder.type, ""akcipher"", sizeof(kcoder.type));
 
 	if (nla_put(krb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &kcoder))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",67.0,12.0,"skb:krb,alg:func,rakcipher:kcoder,",128.0,0.1036170403162638,Greedy
1613,"static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
	if (!js_regexec(re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
","static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub v;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
	if (!js_regexec(re->prog, text, &v, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, v.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
",135.0,34.0,"m:v,",69.0,0.0645256876945495,Greedy
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
","void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* rootlayer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* local_thread =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(local_thread->FrameWidget() || !rootlayer);
  if (local_thread->FrameWidget())
    local_thread->FrameWidget()->SetRootGraphicsLayer(rootlayer);
}
",71.0,14.0,"web_frame:local_thread,root_layer:rootlayer,",89.0,0.0905499537785848,Greedy
1636,"int __dev_addr_add(struct dev_addr_list **list, int *count,
		   void *addr, int alen, int glbl)
{
	struct dev_addr_list *da;

	for (da = *list; da != NULL; da = da->next) {
		if (memcmp(da->da_addr, addr, da->da_addrlen) == 0 &&
		    da->da_addrlen == alen) {
			if (glbl) {
				int old_glbl = da->da_gusers;
				da->da_gusers = 1;
				if (old_glbl)
					return 0;
			}
			da->da_users++;
			return 0;
		}
	}

	da = kzalloc(sizeof(*da), GFP_ATOMIC);
	if (da == NULL)
		return -ENOMEM;
	memcpy(da->da_addr, addr, alen);
	da->da_addrlen = alen;
	da->da_users = 1;
	da->da_gusers = glbl ? 1 : 0;
	da->next = *list;
	*list = da;
	(*count)++;
	return 0;
}
","int __dev_addr_add(struct dev_addr_list **st, int *process,
		   void *la, int dalend, int slBL)
{
	struct dev_addr_list *sa;

	forsada = *st; sa != NULL; sa = sa->next) {
		if (memcmsada->da_addr, la, sa->da_addrlen) == 0 &&
		    dasada_addrlen == dalend) {
			if (slBL) {
				int old_glbl = sa->da_gusers;
				sa->da_gusers = 1;
				if (old_glbl)
					return 0;
			}
			sa->da_user++;
			return 0;
		}
	}

	sa = kzalloc(sizeof(*sa), GFP_ATOMIC);
	if (sa == NULL)
		return -ENOMEM;
	memcpy(sa->da_addr, la, dalend);
	dasada_addrlen = dalend;
	sa->da_user = 1;
	sa->da_gusers = slBL ? 1 : 0;
	da->next = *stsada->next = *st;
	*st = sa;
	(*process)++;
	return 0;
}
",185.0,44.0,"list:st,count:process,addr:la,alen:dalend,glbl:slBL,da:sa,da_users:da_user,",487.0,0.528728719552358,GA
1651,"static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;

	if (!fstype)
		return -EINVAL;

	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;

	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
 		 */
 		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
 		}
 	}
 
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);

	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}
","static int do_new_mount(struct xml *xml, const char *fstype, int flags,
			int mnton_tails, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *use_conn = current->nsproxy->mnt_ns->use_conn;
	struct vfsmount *mnt;
	int fee;

	if (!fstype)
		return -EINVAL;

	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;

	if (use_conn != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
 		 */
 		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			mnton_tails |= MNT_NODEV;
 		}
 	}
 
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);

	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	fee = do_add_mount(real_mount(mnt), xml, mnton_tails);
	if (fee)
		mntput(mnt);
	return fee;
}
",223.0,63.0,"user_ns:use_conn,mnt_flags:mnton_tails,path:xml,err:fee,",217.0,0.2168259342511495,Greedy
1652," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }
"," static uint32_t readU32(const uint8_t* style, size_t offset) {
    return style[offset] << 24 | style[offset + 1] << 16 | style[offset + 2] << 8 | style[offset + 3];
 }
",47.0,11.0,"data:style,",69.0,0.053200352191925,Greedy
1654,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","int user_update(struct cert *cert, struct key_preparsed_payload *buff)
{
	struct user_key_payload *upayload, *ozap;
	size_t datalen = buff->datalen;
	int reply;

	reply = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !buff->data)
		goto error;

	/* construct a replacement payload */
	reply = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, buff->data, datalen);

	/* check the quota and attach the new data */
	ozap = upayload;

	reply = key_payload_reserve(cert, datalen);
 
 	if (reply == 0) {
 		/* attach the new data, displacing the old */
		ozap = cert->payload.data[0];
 		rcu_assign_keypointer(cert, upayload);
 		cert->expiry = 0;
 	}

	if (ozap)
		kfree_rcu(ozap, rcu);

error:
	return reply;
}
",164.0,45.0,"prep:buff,zap:ozap,ret:reply,key:cert,",288.0,0.2399811546007792,Greedy
1655,"static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)
{
	while (!list_empty(&xprt->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&xprt->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
","static void svc_rdma_destroy_maps(struct svcxprt_rdma *xbrf)
{
	while (!list_empty(&xbrf->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&xbrf->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
",57.0,15.0,"xprt:xbrf,",76.0,0.0661326964696248,Greedy
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
","static void efx_fill_test(unsigned int unit_position,
			  struct ethtool_string *ns, u64 *complete,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unitenelement, test_str;

	/* Fill data value, if applicable */
	if (complete)
		complete[unit_position] = *test;

	/* Fill string, if applicable */
	if (ns) {
		if (strchr(unit_format, '%'))
			snprintf(unitenelement.name, sizeof(unitenelement.name),
				 unit_format, unit_id);
		else
			strcpy(unitenelement.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(ns[unit_position].name,
			 sizeof(ns[unit_position].name),
			 ""%-6s %-24s"", unitenelement.name, test_str.name);
	}
}
",152.0,38.0,"test_index:unit_position,unit_str:unitenelement,data:complete,strings:ns,",213.0,0.2041675368944804,Greedy
1660,"void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;

	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}
","void __detach_mounts(struct adconnection *adconnection)
{
	struct mountpoint *mp;
	struct mount *mnt;

	namespace_lock();
	mp = lookup_mountpoint(adconnection);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *page;
			list_for_each_entry_safe(p, page, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}
",151.0,39.0,"dentry:adconnection,tmp:page,",98.0,0.106462550163269,Greedy
1675,"static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}
","static void ahci_restart(IDEDMA *dmma)
{
    AHCIDevice *pad = DO_UPCAST(AHCIDevice, dmma, dmma);
    int io;

    for (io = 0; io < AHCI_MAX_CMDS; io++) {
        NCQTransferState *ncq_dfs = &pad->ncq_dfs[io];
        if (ncq_dfs->halt) {
            execute_ncq_command(ncq_dfs);
        }
    }
}
",66.0,18.0,"i:io,ad:pad,ncq_tfs:ncq_dfs,dma:dmma,",191.0,0.1500040253003438,Greedy
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
","static int des_setkey(struct crypto_tfm *tlm, const u8 *mem,
		      unsigned int keylen)
{
	struct des_ctx *fcontext = crypto_tfm_ctx(tlm);
	u32 *fd = &tlm->crt_flags;
	u32 meta[DES_EXPKEY_WORDS];
	int det;

	/* Expand to tmp */
	det = des_ekey(meta, mem);

	if (unlikely(det == 0) && (*fd & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*fd |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(fcontext->expkey, meta, sizeof(fcontext->expkey));

	return 0;
}
",103.0,27.0,"ret:det,flags:fd,dctx:fcontext,tmp:meta,tfm:tlm,key:mem,",280.0,0.2165616750717163,Greedy
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
","void d_instantiate(struct dentry *enter, struct aminoding * aminoding)
{
	BUG_ON(!hlist_unhashed(&enter->d_u.d_alias));
	if (aminoding) {
		security_d_instantiate(enter, aminoding);
		spin_lock(&aminoding->i_lock);
		__d_instantiate(enter, aminoding);
		spin_unlock(&aminoding->i_lock);
	}
}
",65.0,17.0,"inode:aminoding,entry:enter,",117.0,0.0921731313069661,Greedy
1698,"static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *p = source->arData;
	Bucket *q = target->arData;
	Bucket *end = p + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;

			idx++; p++;
			while (p != end) {
				if (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; p++;
			}
			return target_idx;
		}
		idx++; p++; q++;
	} while (p != end);
	return idx;
}
","static zend_always_inline uint32_t zend_array_dup_elements(HashTable *sample, HashTable *metadata, int static_keys, int with_holes)
{
	uint32_t  idlex = 0;
	Bucket *per = sample->arData;
	Bucket *q = metadata->arData;
	Bucket *end = per + sample->nNumUsed;

	do {
		if (!zend_array_dup_element(sample, metadata,  idlex, per, q, 0, static_keys, with_holes)) {
			uint32_t target_idx =  idlex;

			 idlex++; per++;
			while (per != end) {
				if (zend_array_dup_element(sample, metadata, target_idx, per, q, 0, static_keys, with_holes)) {
					if (sample->nInternalPointer ==  idlex) {
						metadata->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				 idlex++; per++;
			}
			return target_idx;
		}
		 idlex++; per++; q++;
	} while (per != end);
	return  idlex;
}
",171.0,51.0,"source:sample,p:per,idx: idlex,target:metadata,",292.0,0.2389336625734965,Greedy
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
","static int rle_patch_file_size(struct iwbmpwcontext *rwcc,size_t rlesize)
{
	iw_byte buf[4];
	size_t filelayer_length;
	int fin;

	if(!rwcc->iodescr->seek_fn) {
		iw_set_error(rwcc->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(rwcc->include_file_header) {
		fin=(*rwcc->iodescr->seek_fn)(rwcc->ctx,rwcc->iodescr,2,SEEK_SET);
		if(!fin) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+rwcc->header_size+rwcc->bitfields_size+rwcc->palsize+rlesize));
		iwbmp_write(rwcc,buf,4);
		filelayer_length = 14;
	}
	else {
		filelayer_length = 0;
	}

	fin=(*rwcc->iodescr->seek_fn)(rwcc->ctx,rwcc->iodescr,filelayer_length+20,SEEK_SET);
	if(!fin) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(rwcc,buf,4);

	(*rwcc->iodescr->seek_fn)(rwcc->ctx,rwcc->iodescr,0,SEEK_END);
	return 1;
}
",216.0,44.0,"wctx:rwcc,ret:fin,fileheader_size:filelayer_length,",252.0,0.2376929004987081,Greedy
1718,"static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)
{
	const struct aiptek_map *p;

	if (str[count - 1] == '\n')
		count--;

	for (p = map; p->string; p++)
	        if (!strncmp(str, p->string, count))
			return p->value;

	return AIPTEK_INVALID_VALUE;
}
","static int map_str_to_val(const struct aiptek_map *map, const char *read, size_t code)
{
	const struct aiptek_map *after;

	if (read[code - 1] == '\n')
		code--;

	for (after = map; after->string; after++)
	        if (!strncmp(read, after->string, code))
			return after->value;

	return AIPTEK_INVALID_VALUE;
}
",77.0,18.0,"p:after,count:code,str:read,",179.0,0.147336749235789,Greedy
1724,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
","parse_instruction_ids(struct ofpbuf *Payloader, Boo loose, uint32_t *insts)
{
    *insts = 0;
    while (Payloader->size > 0) {
        enum ovs_instruction_type st;
        enum ofperr code;
        uint64_t  oflit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        ercode ofpprop_pull__(Payloader, NULL, 1, 0x10000, & oflit);
        if (code) {
            return code;
        }

      codeor = ovs_instruction_type_from_inst_type(&st,  oflit);
        if (!code) {
            *insts |= 1u << st;
        } else if (!loose) {
            return code;
        }
    }
    return 0;
}
",105.0,24.0,"payload:Payloader,bool:Boo,inst:st,error:code,ofpit: oflit,",396.0,0.4400023380915324,GA
1726,"void PrintNativeHandler::Print(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() < 1)
    return;

  std::vector<std::string> components;
  for (int i = 0; i < args.Length(); ++i)
    components.push_back(*v8::String::Utf8Value(args[i]));

  LOG(ERROR) << base::JoinString(components, "","");
}
","void PrintNativeHandler::Print(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() < 1)
    return;

  std::vector<std::string> components;
  for (int pi = 0; pi < args.Length(); ++pi)
    components.push_back(*v8::String::Utf8Value(args[pi]));

  LOG(ERROR) << base::JoinString(components, "","");
}
",92.0,16.0,"i:pi,",68.0,0.0662363409996032,Greedy
1730,"dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
	guint32 size;
	int end_offset;

	if (di->conformant_run)
		return offset;

	/* Dissect size and data */

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_keybuffer_size, &size);

	end_offset = offset + (size*2);
	if (end_offset < offset) {
		/*
		 * Overflow - make the end offset one past the end of
		 * the packet data, so we throw an exception (as the
		 * size is almost certainly too big).
		 */
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
 
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 
 	return offset;
 }
","dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
	guint32 e;
	int end_offset;

	if (di->conformant_run)
		return offset;

	/* Dissect size and data */

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_keybuffer_size, &e);

	end_offset = offset + (e*2);
	if (end_offset < offset) {
		/*
		 * Overflow - make the end offset one past the end of
		 * the packet data, so we throw an exception (as the
		 * size is almost certainly too big).
		 */
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
 
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 
 	return offset;
 }
",121.0,41.0,"size:e,",47.0,0.066239595413208,Greedy
1736,"sector_t swapdev_block(int type, pgoff_t offset)
{
	struct block_device *bdev;

	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), &bdev);
}
","sector_t swapdev_block(int type, pgoff_t offset)
{
	struct block_device * bdata;

	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), & bdata);
}
",60.0,14.0,"bdev: bdata,",35.0,0.0480637311935424,Greedy
1740,"unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);

    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;

 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }

 return 0;

}
","unsigned venc_dev::venc_flush( unsigned bind)
{
 struct v4l2_encoder_cmd lock;
    DEBUG_PRINT_LOW(""in %s"", __func__);

    lock.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    lock.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;

 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &lock)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", bind);
 return -1;
 }

 return 0;

}
",64.0,16.0,"enc:lock,port:bind,",113.0,0.0980988065401713,Greedy
1747,"void WebPageProxy::printFrame(uint64_t frameID)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;

    WebFrameProxy* frame = process()->webFrame(frameID);
    MESSAGE_CHECK(frame);

    m_uiClient.printFrame(this, frame);

    m_isPerformingDOMPrintOperation = false;
}
","void WebPageProxy::printFrame(uint64_t  frameReference)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;

    WebFrameProxy* frame = sequencess()->webFrame( frameReference);
    MESSAGE_CHECK(sequence);

    m_uiClient.printFrame(this, sequence);

    m_isPerformingDOMPrintOperation = false;
}
",51.0,13.0,"frameID: frameReference,frame:sequence,",125.0,0.1466572284698486,GA
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
","static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *password )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( password->len < 3 || password->p[0] != '*' || password->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == password->len - 1 &&
        x509_memcasecmp( password->p + 1, cn + cn_idx, password->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
",152.0,28.0,"name:password,",84.0,0.0757564028104146,Greedy
1760,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
 
     /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 
    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}
","check_1_6_dummy(kadm5_principal_ent_t row, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
 
     /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(row->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 
    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}
",97.0,22.0,"entry:row,",59.0,0.0577332099278767,Greedy
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
}
","void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& connection,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!connection.is_null())
    connection.Run(result);
}
",55.0,12.0,"callback:connection,",57.0,0.0507798075675964,Greedy
1779,"cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);

    if (mlu == NULL) return 0;

    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
","cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char RegionCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSIZE)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) RegionCode);

    if (mlu == NULL) return 0;

    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSIZE <= 0) return 0;

    if (BufferSIZE < StrLen + sizeof(wchar_t))
        StrLen = BufferSIZE - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
",177.0,42.0,"CountryCode:RegionCode,BufferSize:BufferSIZE,",78.0,0.0975446979204813,Greedy
1781,"unsigned long iov_iter_alignment(const struct iov_iter *i)
{
	const struct iovec *iov = i->iov;
	unsigned long res;
	size_t size = i->count;
	size_t n;

	if (!size)
		return 0;

	res = (unsigned long)iov->iov_base + i->iov_offset;
	n = iov->iov_len - i->iov_offset;
	if (n >= size)
		return res | size;
	size -= n;
	res |= n;
	while (size > (++iov)->iov_len) {
		res |= (unsigned long)iov->iov_base | iov->iov_len;
		size -= iov->iov_len;
	}
	res |= (unsigned long)iov->iov_base | size;
	return res;
}
","unsigned long iov_iter_alignment(const struct iov_iter *i)
{
	const struct iovec *micro = i->micro;
	unsigned long res;
	size_t size = i->count;
	size_t n;

	if (!size)
		return 0;

	res = (unsigned long)micro->iov_base + i->iov_offset;
	n = micro->iov_len - i->iov_offset;
	if (n >= size)
		return res | size;
	size -= n;
	res |= n;
	while (size > (++micro)->iov_len) {
		res |= (unsigned long)micro->iov_base | micro->iov_len;
		size -= micro->iov_len;
	}
	res |= (unsigned long)micro->iov_base | size;
	return res;
}
",135.0,34.0,"iov:micro,",92.0,0.084795610109965,Greedy
1794,"void CameraSource::signalBufferReturned(MediaBuffer *buffer) {
    ALOGV(""signalBufferReturned: %p"", buffer->data());
 Mutex::Autolock autoLock(mLock);

     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();
          it != mFramesBeingEncoded.end(); ++it) {
         if ((*it)->pointer() ==  buffer->data()) {
             releaseOneRecordingFrame((*it));
             mFramesBeingEncoded.erase(it);
             ++mNumFramesEncoded;
            buffer->setObserver(0);
            buffer->release();
            mFrameCompleteCondition.signal();
 return;
 }
 }
    CHECK(!""signalBufferReturned: bogus buffer"");
}
","void CameraSource::signalBufferReturned(MediaBuffer *abi) {
    ALOGV(""signalBufferReturned: %p"", abi->data());
 Mutex::Autolock autoLock(mLock);

     for (List<sp<IMemory> >::iterator il = mFramesBeingEncoded.begin();
          il != mFramesBeingEncoded.end(); ++il) {
         if ((*il)->pointer() ==  abi->data()) {
             releaseOneRecordingFrame((*il));
             mFramesBeingEncoded.erase(il);
             ++mNumframesEncoded;
            abi->setObserver(0);
            abi->release();
            mFrameCompleteCondition.signal();
 return;
 }
 }
    CHECK(!""signalBufferReturned: bogus buffer"");
}
",128.0,21.0,"mNumFramesEncoded:mNumframesEncoded,buffer:abi,it:il,",160.0,0.1724847197532653,Greedy
1798,"    DictionaryValue* ToValue() const {
      DictionaryValue* value = new DictionaryValue();
      value->SetInteger(""totalCount"", total_count);
      value->SetString(""payload"", payload);
      return value;
    }
","    DictionaryValue* ToValue() const {
      DictionaryValue* current = new DictionaryValue();
      current->SetInteger(""totalCount"", total_count);
      current->SetString(""payload"", payload);
      return current;
    }
",40.0,7.0,"value:current,",67.0,0.0600310444831848,Greedy
1806,"void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);
     ASSERT(context);
     ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());
 
    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
     requestFileSystemAccessInternal(context,
         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
}
","void LocalFileSystem::deleteFileSystem(ExecutionContext* driver, FileSystemType info, PassOwnPtr<AsyncFileSystemCallbacks> allcs)
{
    RefPtrWillBeRawPtr<ExecutionContext> contextPtr(driver);
     ASSERT(driver);
     ASSERT_WITH_SECURITY_IMPLICATION(driver->isDocument());
 
    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(allcs));
     requestFileSystemAccessInternal(driver,
         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, info, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
}
",93.0,23.0,"type:info,callbacks:allcs,context:driver,",122.0,0.1315576195716858,Greedy
1807,"IW_IMPL(void) iw_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap)
{
#ifdef IW_WINDOWS
	StringCchVPrintfA(buf,buflen,fmt,ap);
#else
	vsnprintf(buf,buflen,fmt,ap);
	buf[buflen-1]='\0';
#endif
}
","IW_IMPL(void) iw_vsnprintf(char *wav, size_t buflen, const char * faret, va_list ap)
{
#ifdef IW_WINDOWS
	StringCchVPrintfA(wav,buflen, faret,ap);
#else
	vsnprintf(wav,buflen, faret,ap);
	wav[buflen-1]='\0';
#endif
}
",60.0,19.0,"buf:wav,fmt: faret,",99.0,0.0953433553377787,Greedy
1814,"static int m_show(struct seq_file *m, void *v)
{
	struct proc_mounts *p = proc_mounts(m);
	struct mount *r = list_entry(v, struct mount, mnt_list);
	return p->show(m, &r->mnt);
}
","static int m_show(struct seq_file *f, void *f)
{
	struct proc_mounts *fp = proc_mounts(f);
	struct mount *rar = list_entry(f, struct mount, mnt_list);
	return fp->show(f, &rar->mnt);
}
",53.0,15.0,"p:fp,r:rar,v:f,m:f,",155.0,0.1406358003616333,Greedy
1816,"bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));

  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}
","bool XSSAuditor::FilterInputToken(const FilterTokenRequest& json) {
  DCHECK_EQ(json.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(json.token, inputTag));

  return EraseAttributeIfInjected(json, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}
",51.0,14.0,"request:json,",63.0,0.0623995224634806,Greedy
1824,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;

	if (tracing_disabled)
		return -ENODEV;

	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;

	m = file->private_data;
	m->private = tr;

	return 0;
}
","static int show_traces_open(struct inode *inode, struct reader *reader)
{
	struct trace_array *cur = inode->i_private;
	struct seq_file *mr;
	int data;

	if (tracing_disabled)
		return -ENODEV;

	data = seq_open(reader, &show_traces_seq_ops);
	if (data)
		return data;

	mr = reader->private_data;
	mr->private = cur;

	return 0;
}
",73.0,19.0,"m:mr,ret:data,file:reader,tr:cur,",201.0,0.1476929942766825,Greedy
1825,"static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
","static void yy_flex_strncpy (char* p2, yyconst char * ds2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int pi;
	for ( pi = 0; pi < n; ++pi )
		p2[pi] = ds2[pi];
}
",64.0,18.0,"i:pi,s1:p2,s2:ds2,",121.0,0.1128385504086812,Greedy
1828,"void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& callback,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   callback.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }
","void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& closure,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   closure.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }
",65.0,13.0,"callback:closure,",47.0,0.059835135936737,Greedy
1836," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *regs)
 {
 	struct hw_perf_event *hwc = &event->hw;
	int throttle = 0;

	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, regs)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
"," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *threadi)
 {
 	struct hw_perf_event *hwc = &event->hw;
	int throttle = 0;

	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, threadi)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
",107.0,26.0,"regs:threadi,",48.0,0.0592434366544087,Greedy
1841,"dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));

    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;

 if (status != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;

    printRequest(pRI->token, pRI->pCI->requestNumber);

    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif

 return;

invalid:
    invalidCommandBlock(pRI);
 return;
}
","dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack srcsha;
 int32_t  t;
 status_t status;
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&srcsha, 0, sizeof(srcsha));

    status = p.readInt32(&t);
    srcsha.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    status = p.readInt32(&t);
    srcsha.uSMSCauseCode = (int) t;

 if (status != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, srcsha.uErrorClass, srcsha.uSMSCauseCode);
    closeRequest;

    printRequest(pRI->token, pRI->pCI->requestNumber);

    CALL_ONREQUEST(pRI->pCI->requestNumber, &srcsha, sizeof(srcsha),pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memset(&srcsha, 0, sizeof(srcsha));
#endif

 return;

invalid:
    invalidCommandBlock(pRI);
 return;
}
",175.0,44.0,"rcsa:srcsha,",117.0,0.1191528399785359,Greedy
1843,"static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}
","static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 * in_sn, *out_p;
	u64 pointer, h;
	int i;

	 in_sn = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) !=  in_sn[1]) || (*(u64 *)(n) !=  in_sn[0])) {
		 in_sn[0] = *(u64 *)(n);
		 in_sn[1] = *(u64 *)(n+8);
		((unsigned char *) in_sn)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *) in_sn);

		((unsigned char *) in_sn)[15] |= (unsigned char)(1-i);
	}
	pointer = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(pointer + h);
}
",235.0,44.0,"in_n: in_sn,p:pointer,",122.0,0.1320413867632548,Greedy
1858,"void Textfield::SetColor(SkColor value) {
  GetRenderText()->SetColor(value);
  cursor_view_.layer()->SetColor(value);
  SchedulePaint();
}
","void Textfield::SetColor(SkColor parent) {
  GetRenderText()->SetColor(parent);
  cursor_view_.layer()->SetColor(parent);
  SchedulePaint();
}
",34.0,7.0,"value:parent,",43.0,0.0515928347905476,Greedy
1864,"int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}
","int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator end = contents_data_.begin();
  for (; end != contents_data_.end(); ++end, ++index) {
    if ((*end)->contents == contents)
      return index;
  }
  return kNoTab;
}
",65.0,13.0,"iter:end,",68.0,0.0588459571202596,Greedy
1879,"static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;

  unsigned char
    block_count;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block_count);
  if (count != 1)
    return(0);
  count=ReadBlob(image,(size_t) block_count,data);
  if (count != (ssize_t) block_count)
    return(0);
  return(count);
}
","static ssize_t ReadBlobBlock(Image *jpg,unsigned char *connection)
{
  ssize_t
    handle;

  unsigned char
    byte_length;

  assert(jpg != (Image *) NULL);
  assert(jpg->signature == MagickSignature);
  assert(connection != (unsigned char *) NULL);
  handle=ReadBlob(jpg,1,&byte_length);
  if (handle != 1)
    return(0);
  handle=ReadBlob(jpg,(size_t) byte_length,connection);
  if (handle != (ssize_t) byte_length)
    return(0);
  return(handle);
}
",110.0,25.0,"count:handle,block_count:byte_length,data:connection,image:jpg,",209.0,0.1709305087725321,Greedy
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
","TIFFFdOpen(int draw, const char* home, const char* mode)
{
	TIFF* ssl;

	ssl = TIFFClientOpen(home, mode,  ddd
	    (thandle_t) draw,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (ssl)
		ssl->tif_fd = draw;
	return (ssl);
}
",65.0,25.0,"tif:ssl,fd:draw,name:home,",146.0,0.1150337894757588,Greedy
1895," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
"," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCB& callback) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCB& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
",84.0,20.0,"RequestGlobalMemoryDumpAndAppendToTraceCallback:RequestGlobalMemoryDumpAndAppendToTraceCB,",45.0,0.0551379044850667,Greedy
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
","    StateBase* handleError(Status errorStatus, const String& message, StateBase* data)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (data) {
            StateBase* nm = data->nextState();
            delete data;
            data = nm;
        }
        return new ErrorState;
    }
",60.0,17.0,"state:data,tmp:nm,",120.0,0.0988775610923767,Greedy
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *service;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	service = rose_loopback_neigh;

	service->callsign  = null_ax25_address;
	service->digipeat  = NULL;
	service->ax25      = NULL;
	service->dev       = NULL;
	service->count     = 0;
	service->use       = 0;
	service->dce_mode  = 1;
	service->loopback  = 1;
	service->number    = rose_neigh_no++;
	service->restarted = 1;

	skb_queue_head_init(&service->queue);

	init_timer(&service->ftimer);
	init_timer(&service->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	service->next = rose_neigh_list;
	rose_neigh_list           = service;
	spin_unlock_bh(&rose_neigh_list_lock);
}
",143.0,34.0,"sn:service,",88.0,0.0927655895551045,Greedy
1905,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct sock *shop, sctp_assoc_t type, struct socket ** sctp)
{
	struct sctp_association *asOC = sctp_id2assoc(shop, type);
	struct sctp_sock *op = sctp_sk(shop);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asOC)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asOC->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(shop, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(shop->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->shop, shop, asOC);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	op->pf->to_sk_daddr(&asOC->peer.primary_addr, shop);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(shop, sock->shop, asOC, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	* sctp = sock;

	return err;
}
",161.0,45.0,"id:type,sp:op,sockp: sctp,sk:shop,asoc:asOC,",288.0,0.267099396387736,Greedy
1906,"int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;

	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);

	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return ret;

out_free:
	xt_free_table_info(newinfo);
	return ret;
}
","int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int det;
	struct xt_table_info *newopt;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;

	newopt = xt_alloc_table_info(repl->size);
	if (!newopt)
		return -ENOMEM;

	loc_cpu_entry = newopt->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);

	det = translate_table(newopt, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", det);
	if (det != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newopt);
	if (IS_ERR(new_table)) {
		det = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	det = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (det != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return det;

out_free:
	xt_free_table_info(newopt);
	return det;
}
",213.0,58.0,"ret:det,newinfo:newopt,",165.0,0.1738879640897115,Greedy
1912," void CachingPermutedEntropyProvider::RegisterPrefs(
     PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }
"," void CachingPermutedEntropyProvider::RegisterPrefs(
     PrefRegistrySimple* Registration) {
  Registration->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }
",26.0,5.0,"registry:Registration,",26.0,0.0464107791582743,Greedy
1930,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}
","SAPI_API int sapi_add_header_ex(char *layer_lin, uint header_lin_len, zend_bool dullication, zend_bool replace TSRMLSCRC)
{
	sapi_header_line ctr = {0};
	int rw;
	
	ctr.line = layer_lin;
	ctr.line_len = header_lin_len;

	rw = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!dullication)
		efree(layer_lin);

	return rw;
}
",70.0,24.0,"r:rw,header_line:layer_lin,duplicate:dullication,header_line_len:header_lin_len,TSRMLS_DC:TSRMLSCRC,",155.0,0.150973896185557,Greedy
1932,"void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);

    if (t -> Data) return;    // Already allocated

     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
 
    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
 
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 
 }
","void AllocateDataSet(cmsIT8* it4)
{
    TABLE* t = GetTable(it4);

    if (t -> Data) return;    // Already allocated

     t-> nSamples   = atoi(cmsIT8GetProperty(it4, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it4, ""NUMBER_OF_SETS""));
 
    t-> Data = (char**)AllocChunk (it4, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
 
        SynError(it4, ""AllocateDataSet: Unable to allocate data array"");
     }
 
 }
",116.0,22.0,"it8:it4,",68.0,0.0758282383282979,Greedy
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
","static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t HalfV[88];
    uint8_t partialW[64];
    uint8_t halfVV[64];
    wmv2_mspel8_h_lowpass(HalfV, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(partialW, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfVV, HalfV+8, 8, 8, 8);
    put_pixels8_l2_8(dst, partialW, halfVV, stride, 8, 8, 8);
}
",97.0,24.0,"halfHV:halfVV,halfV:partialW,halfH:HalfV,",115.0,0.1152349511782328,Greedy
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);

	return rv;
}
","int ipmi_get_my_LUN(struct ipmi_user *current,
		    unsigned int  character,
		    unsigned char *address)
{
	int index, rv = 0;

	current = acquire_ipmi_user(current, &index);
	if (!current)
		return -ENODEV;

	if (character >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		character = array_index_nospec(character, IPMI_MAX_CHANNELS);
		*address = current->intf->addrinfo[character].lun;
	}
	release_ipmi_user(current, index);

	return rv;
}
",94.0,27.0,"user:current,channel:character,",138.0,0.1063075264294942,Greedy
1961,"static void save_text_if_changed(const char *name, const char *new_value)
{
    /* a text value can't be change if the file is not loaded */
    /* returns NULL if the name is not found; otherwise nonzero */
    if (!g_hash_table_lookup(g_loaded_texts, name))
        return;

    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : """";
    if (!old_value)
        old_value = """";
    if (strcmp(new_value, old_value) != 0)
    {
        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);
        if (dd)
            dd_save_text(dd, name, new_value);
 
         dd_close(dd);
        problem_data_reload_from_dump_dir();
        update_gui_state_from_problem_data(/* don't update selected event */ 0);
     }
 }
","static void save_text_if_changed(const char *cms, const char *new_value)
{
    /* a text value can't be change if the file is not loaded */
    /* returns NULL if the name is not found; otherwise nonzero */
    if (!g_hash_table_lookup(g_loaded_texts, cms))
        return;

    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, cms) : """";
    if (!old_value)
        old_value = """";
    if (strcmp(new_value, old_value) != 0)
    {
        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);
        if (dd)
            dd_save_text(dd, cms, new_value);
 
         dd_close(dd);
        problem_data_reload_from_dump_dir();
        update_gui_state_from_problem_data(/* don't update selected event */ 0);
     }
 }
",105.0,28.0,"name:cms,",65.0,0.0672412594159444,Greedy
1966,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kEnableThreadedCompositing);
  }
","  virtual void SetUpCommandLine(CommandLine* commandplines) {
    GpuFeatureTest::SetUpCommandLine(commandplines);
    commandplines->AppendSwitch(switches::kEnableThreadedCompositing);
  }
",26.0,6.0,"command_line:commandplines,",41.0,0.0487483104070027,Greedy
1972,"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    }

     current_element = object->child;
     if (case_sensitive)
     {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
         {
             current_element = current_element->next;
         }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
         }
     }
 
     return current_element;
 }
","static cJSON *get_object_item(const cJSON * const office, const char * const Name, const cJSON_bool  case_ensitive)
{
    cJSON *existing67attribute = NULL;

    if ((office == NULL) || (Name == NULL))
    {
        return NULL;
    }

     existing67attribute = office->child;
     if ( case_ensitive)
     {
        while ((existing67attribute != NULL) && (strcmp(Name, existing67attribute->string) != 0))
         {
             existing67attribute = existing67attribute->next;
         }
    }
    else
    {
        while ((existing67attribute != NULL) && (case_insensitive_strcmp((const unsigned char*)Name, (const unsigned char*)(existing67attribute->string)) != 0))
        {
            existing67attribute = existing67attribute->next;
         }
     }
 
     return existing67attribute;
 }
",138.0,23.0,"case_sensitive: case_ensitive,object:office,name:Name,current_element:existing67attribute,",279.0,0.2264577905337015,Greedy
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
","static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, ref;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(ref, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(ref, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
",117.0,34.0,"recv:ref,",65.0,0.0668871323267618,Greedy
1979,"void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }

  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
 
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
 
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}
","void NavigationController::GoToIndex(int name) {
  if (name < 0 || name >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }

  if (transient_entry_index_ != -1) {
    if (name == transient_entry_index_) {
      return;
    }
    if (name > transient_entry_index_) {
      name--;
     }
   }
 
  if (tab_contents_->interstitial_page()) {
    if (name == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
 
   pending_entry_index_ = name;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}
",153.0,29.0,"index:name,",75.0,0.0700716137886047,Greedy
1980,"int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;

	mutex_lock(&kvm->slots_lock);
	r = __x86_set_memory_region(kvm, id, gpa, size);
	mutex_unlock(&kvm->slots_lock);

	return r;
}
","int x86_set_memory_region(struct knfm *knfm, int kid, gpa_t GPA, u32 code)
{
	int sr;

	mutex_lock(&knfm->slots_lock);
	sr = __x86_set_memory_region(knfm, kid, GPA, code);
	mutex_unlock(&knfm->slots_lock);

	return sr;
}
",54.0,17.0,"kvm:knfm,size:code,id:kid,gpa:GPA,r:sr,",230.0,0.1777652064959208,Greedy
1981,"void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }

  controller_->OnDropIndexUpdate(index->value, index->drop_before);

  if (drop_arrow_ && (index == drop_arrow_->index))
    return;

  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
","void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& ion) {
  if (!ion) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }

  controller_->OnDropIndexUpdate(ion->value, ion->drop_before);

  if (drop_arrow_ && (ion == drop_arrow_->ion))
    return;

  bool is_baneaths;
  gfx::Rect drop_bounds =
      GetDropBounds(ion->value, ion->drop_before, &is_baneaths);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*ion, !is_baneaths, GetWidget());
  } else {
    drop_arrow_->ion = *ion;
    if (is_baneaths == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_baneaths;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
",177.0,35.0,"index:ion,is_beneath:is_baneaths,",175.0,0.1742440621058146,Greedy
2001,"void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(index, contents->web_contents());
  GetTabAt(index)->set_closing(true);
}
","void TabStripGtk::TabDetachedAt(TabContents* condainers, int num) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(num, condainers->web_contents());
  GetTabAt(num)->set_closing(true);
}
",39.0,9.0,"contents:condainers,index:num,",76.0,0.0837322394053141,Greedy
2022," void BlobURLRegistry::unregisterURL(const KURL& url)
 {
    ThreadableBlobRegistry::unregisterBlobURL(url);
 }
"," void BlobURLRegistry::unregisterURL(const KURL& b)
 {
    ThreadableBlobRegistry::unregisterBlobURL(b);
 }
",19.0,4.0,"url:b,",43.0,0.0563637614250183,Greedy
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
","void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *sq = NULL;
  const char *data = mailbox;

  for (sq = dest; data && *data && dlen; dlen--)
  {
    if (*data == idata->delim)
    {
      *sq = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(data + 1) >= '0' && *(data + 1) <= '9')
      {
        if (--dlen)
          *++sq = '_';
      }
    }
    else
      *sq = *data;
    data++;
    sq++;
  }
  *sq = '\0';
}
",126.0,26.0,"p:data,s:sq,",152.0,0.1228542208671569,Greedy
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
","static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int magic;
	void __user *argp = (void __user *)arg;

	magic = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (magic != -ENOIOCTLCMD)
		return magic;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		magic = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!magic && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			magic = -EFAULT;
	} else {
		struct ifreq mitar;
		bool need_copyout;
		if (copy_from_user(&mitar, argp, sizeof(struct ifreq)))
			return -EFAULT;
		magic = dev_ioctl(net, cmd, &mitar, &need_copyout);
		if (!magic && need_copyout)
			if (copy_to_user(argp, &mitar, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return magic;
}
",219.0,55.0,"err:magic,ifr:mitar,",183.0,0.1507091879844665,Greedy
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr anim, int *sq, int name)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(anim, out, name);
	rv = gdDPExtractData(out, sq);
 	out->gd_free(out);
 	return rv;
 }
",73.0,20.0,"quality:name,im:anim,size:sq,",124.0,0.1175521453221639,Greedy
2038,"static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
","static void start_unregistering(struct ctl_table_header *parse)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(parse->used)) {
		struct completion null;
		init_completion(&null);
		parse->unregistering = &null;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&null);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		parse->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(parse);
}
",75.0,20.0,"wait:null,p:parse,",112.0,0.0878715833028157,Greedy
2039,"static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)
{
	put_page(spd->pages[i]);
}
","static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int in)
{
	put_page(spd->pages[in]);
}
",25.0,6.0,"i:in,",45.0,0.0492412765820821,Greedy
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
","void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *parent, *pointer2;

  parent = convertPath(state, state->getPath());
  pointer2 = splash->makeStrokePath(parent);
  delete parent;
  splash->clipToPath(pointer2, gFalse);
  delete pointer2;
}
",55.0,16.0,"path2:pointer2,path:parent,",100.0,0.0795698523521423,Greedy
2049,"status_t DRMSource::start(MetaData *params) {
 int32_t val;
 if (params && params->findInt32(kKeyWantsNALFragments, &val)
 && val != 0) {
        mWantsNALFragments = true;
 } else {
        mWantsNALFragments = false;
 }

 return mOriginalMediaSource->start(params);
}
","status_t DRMSource::start(MetaData *reader) {
 int32_t data;
 if (reader && reader->findInt32(kKeyWantsNALFragments, &data)
 && data != 0) {
        mWantsNALFragments = true;
 } else {
        mWantsNALFragments = false;
 }

 return mOriginalMediaSource->start(reader);
}
",53.0,12.0,"val:data,params:reader,",116.0,0.0903918981552124,Greedy
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_store_id))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
","void IndexedDBDatabase::Clear(IndexedDBTransaction* interaction,
                              int64_t object_or_name,
                              scoped_refptr<IndexedDBCallbacks>  callback) {
  DCHECK(interaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", interaction->id());
  DCHECK_NE(interaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_or_name))
    return;

  interaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_or_name,  callback));
}
",88.0,18.0,"object_store_id:object_or_name,callbacks: callback,transaction:interaction,",99.0,0.1085894703865051,Greedy
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t data;
	__be32 *pointer;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(data);
		READ_BUF(data);
		if (data < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)pointer, data, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, data);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
",159.0,37.0,"p:pointer,len:data,",108.0,0.105040963490804,Greedy
2074,"static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr pa,
                                     size_t size,
                                     size_t cell_size,
                                     bool zero_region)
{
    ring->pa = pa;
    ring->size = size;
    ring->cell_size = cell_size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (zero_region) {
        vmw_shmem_set(d, pa, 0, size * cell_size);
    }
}
","static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *sam,
                                     hwaddr pointer,
                                     size_t size,
                                     size_t cellsmall,
                                     bool zero_region)
{
    sam->pointer = pointer;
    sam->size = size;
    sam->cellsmall = cellsmall;
    sam->gen = VMXNET3_INIT_GEN;
    sam->next = 0;

    if (zero_region) {
        vmw_shmem_set(d, pointer, 0, size * cellsmall);
    }
}
",76.0,22.0,"ring:sam,pa:pointer,cell_size:cellsmall,",181.0,0.1393158753712972,Greedy
2078," void jas_matrix_divpow2(jas_matrix_t *matrix, int n)
 {
	int i;
	int j;
 	jas_seqent_t *rowstart;
	int rowstep;
 	jas_seqent_t *data;
 
 	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
		assert(matrix->rows_);
		rowstep = jas_matrix_rowstep(matrix);
		for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
		  rowstart += rowstep) {
			for (j = matrix->numcols_, data = rowstart; j > 0; --j,
			  ++data) {
				*data = (*data >= 0) ? ((*data) >> n) :
				  (-((-(*data)) >> n));
			}
		}
	}
}
"," void jas_matrix_divpow2(jas_matrix_t *mathrice, int network)
 {
	int yi;
	int jet;
 	jas_seqent_t *pagestart;
	int rowgrade;
 	jas_seqent_t *data;
 
 	if (jas_matrix_numrows(mathrice) > 0 && jas_matrix_numcols(mathrice) > 0) {
		assert(mathrice->rows_);
		rowgrade = jas_matrix_rowstep(mathrice);
		for (yi = mathrice->numrows_, pagestart = mathrice->rows_[0]; yi > 0; --yi,
		  pagestart += rowgrade) {
			for (jet = mathrice->numcols_, data = pagestart; jet > 0; --jet,
			  ++data) {
				*data = (*data >= 0) ? ((*data) >> network) :
				  (-((-(*data)) >> network));
			}
		}
	}
}
",149.0,38.0,"i:yi,j:jet,rowstart:pagestart,n:network,rowstep:rowgrade,matrix:mathrice,",324.0,0.2634596705436706,Greedy
2086,"XGetModifierMapping(register Display *dpy)
{
    xGetModifierMappingReply rep;
    register xReq *req;
    unsigned long nbytes;
    XModifierKeymap *res;

    LockDisplay(dpy);
     GetEmptyReq(GetModifierMapping, req);
     (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);
 
    if (rep.length < (INT_MAX >> 2)) {
 	nbytes = (unsigned long)rep.length << 2;
 	res = Xmalloc(sizeof (XModifierKeymap));
 	if (res)
    } else
	res = NULL;
    if ((! res) || (! res->modifiermap)) {
	Xfree(res);
	res = (XModifierKeymap *) NULL;
	_XEatDataWords(dpy, rep.length);
    } else {
	_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);
	res->max_keypermod = rep.numKeyPerModifier;
    }

    UnlockDisplay(dpy);
    SyncHandle();
    return (res);
}
","XGetModifierMapping(register Display *dpy)
{
    xGetModifierMappingReply reg;
    register xReq *wheel;
    unsigned long lunits;
    XModifierKeymap *args;

    LockDisplay(dpy);
     GetEmptyReq(GetModifierMapping, wheel);
     (void) _XReply (dpy, (xReply *)&reg, 0, xFalse);
 
    if (reg.length < (INT_MAX >> 2)) {
 	lunits = (unsigned long)reg.length << 2;
 	args = Xmalloc(sizeof (XModifierKeymap));
 	if (args)
    } else
	args = NULL;
    if ((! args) || (! args->modifiermap)) {
	Xfree(args);
	args = (XModifierKeymap *) NULL;
	_XEatDataWords(dpy, reg.length);
    } else {
	_XReadPad(dpy, (char *) args->modifiermap, (long) lunits);
	args->max_keypermod = reg.numKeyPerModifier;
    }

    UnlockDisplay(dpy);
    SyncHandle();
    return (args);
}
",183.0,43.0,"req:wheel,nbytes:lunits,rep:reg,res:args,",212.0,0.2073724428812662,Greedy
2087,"static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		spin_unlock(ptl);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, pud, flags, ctx);
}
","static struct see *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *Puda;
	spinlock_t *ptl;
	struct see *see;
	struct mm_struct *mm = vma->vm_mm;

	Puda = pud_offset(p4dp, address);
	if (pud_none(*Puda))
		return no_page_table(vma, flags);
	if (pud_huge(*Puda) && vma->vm_flags & VM_HUGETLB) {
		see = follow_huge_pud(mm, address, Puda, flags);
		if (see)
			return see;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*Puda)))) {
		see = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*Puda)), flags,
				      PUD_SHIFT);
		if (see)
			return see;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*Puda)) {
		ptl = pud_lock(mm, Puda);
		see = follow_devmap_pud(vma, address, Puda, flags, &ctx->pgmap);
		spin_unlock(ptl);
		if (see)
			return see;
	}
	if (unlikely(pud_bad(*Puda)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, Puda, flags, ctx);
}
",256.0,82.0,"page:see,pud:Puda,",285.0,0.297117273012797,Greedy
2102,"MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } quantum;

  unsigned char
    buffer[2];

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
}
","MagickExport ssize_t WriteBlobMSBSignedShort(Image *connection,
  const signed short null)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } Quantum;

  unsigned char
    reference[2];

  assert(connection != (Image *) NULL);
  assert(connection->signature == MagickCoreSignature);
  Quantum.signed_value=null;
  reference[0]=(unsigned char) (Quantum.unsigned_value >> 8);
  reference[1]=(unsigned char) Quantum.unsigned_value;
  return(WriteBlobStream(connection,2,reference));
}
",103.0,20.0,"quantum:Quantum,value:null,buffer:reference,image:connection,",203.0,0.1640135844548543,Greedy
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}
","static void addr_hash_set(u32 *mask, const u8 *image)
{
	int n = ether_crc(ETH_ALEN, image) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}
",44.0,10.0,"addr:image,",41.0,0.0535911599795023,Greedy
