Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost
2,"void RenderFrameImpl::OnCopyToFindPboard() {
  if (frame_->HasSelection()) {
    if (!clipboard_host_) {
      auto* platform = RenderThreadImpl::current_blink_platform_impl();
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              &clipboard_host_);
    }
    base::string16 selection = frame_->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
}","void arg2::OnCopyToFindPboard() {
  if (frame_->HasSelection()) {
    if (!clipboard_host_) {
      auto* MP_AUDIO_BASE = RenderThreadImpl::current_blink_platform_impl();
      MP_AUDIO_BASE->nvdimm_build_device_dsm()->BindInterface(MP_AUDIO_BASE->GetBrowserServiceName(),
                                              &clipboard_host_);
    }
    base::string16 selection = frame_->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
}",,,254,
5," static void addDataToStreamTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }"," static void addDataToStreamTask(void* context)
 {
     elf_note_info<BlobRegistryContext> host_features = visit(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(host_features->url, host_features->streamData);
 }",,,256,
9,"bool TopSitesImpl::IsKnownURL(const GURL& url) {
  return loaded_ && cache_->IsKnownURL(url);
}","bool VuVirtq::IsKnownURL(const rsp_len& url) {
  return loaded_ && cache_->IsKnownURL(url);
}",,,250,
11,"		void CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}","		void fw_cfg_properties::UNIN_DPRINTF(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}",,,254,
19,"bool SocketStream::is_secure() const {
  return url_.SchemeIs(""wss"");
 }","bool enc::is_secure() const {
  return usb_msd_realize_storage.SchemeIs(""wss"");
 }",,,255,
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}","void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               MotionPixelsContext script) {
  settings->pio_readl(font, script);
}",,,251,
27,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}","status_t Parcel::readPointer(uintptr_t *nc) const
{
 status_t ret;
 acoder ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *nc = ptr;
 return ret;
}",,,254,
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;
	mutex_lock(&local->sta_mtx);
	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;
		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);
			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);
			WARN_ON(__sta_info_destroy(sta));
		}
	}
	mutex_unlock(&local->sta_mtx);
}","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long asl_file)
{
	struct ieee80211_local *QTYPE_QDICT = sdata->QTYPE_QDICT;
	struct sta_info *sta, *tmp;
	mutex_lock(&QTYPE_QDICT->sta_mtx);
	pci_config_set_revision(sta, tmp, &QTYPE_QDICT->sta_list, list) {
		if (sdata != sta->sdata)
			continue;
		if (time_after(jiffies, sta->last_rx + asl_file)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM
"",
				sta->sta.addr);
			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);
			WARN_ON(__sta_info_destroy(sta));
		}
	}
	mutex_unlock(&QTYPE_QDICT->sta_mtx);
}",,,312,
38," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}"," void ServiceWorkerPaymentInstrument::spapr_phb_remove_pci_device(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != drc) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = drc;
  }
}",,,310,
46,"struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}","struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *LOAD_LIBRARY_AS_DATAFILE = alloc_skb(size, priority);
		if (LOAD_LIBRARY_AS_DATAFILE) {
			skb_set_owner_w(LOAD_LIBRARY_AS_DATAFILE, sk);
			return LOAD_LIBRARY_AS_DATAFILE;
		}
	}
	return NULL;
}",,,256,
47,"status_t OMXNodeInstance::getConfig(
         OMX_INDEXTYPE index, void *params, size_t  ) {
     Mutex::Autolock autoLock(mLock);
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}","status_t OMXNodeInstance::getConfig(
         OMX_INDEXTYPE index, void *params, size_t  ) {
     Mutex::Autolock autoLock(mLock);
     AV_CODEC_ID_PCM_MULAW err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}",,,252,
53,"extern ""C"" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
}","extern ""C"" void RIL_setcallbacks (const RIL_RadioFunctions *host_addr) {
    memcpy(&s_callbacks, host_addr, sizeof (RIL_RadioFunctions));
}",,,255,
54,"inline void PulseAudioMixer::MainloopLock() const {
   pa_threaded_mainloop_lock(pa_mainloop_);
   ++mainloop_lock_count_;
 }","inline void result::MainloopLock() const {
   qemu_blockalign(UDIDETCR0);
   ++mainloop_lock_count_;
 }",,,254,
56,"static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    i;
  MagickOffsetType
    offset;
  size_t
    h,
    w;
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(dds_info->width);
      h = DIV2(dds_info->height);
       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
         w = DIV2(w);
         h = DIV2(h);
       }
    }
  return(MagickTrue);
}","static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    i;
  MagickOffsetType
    offset;
  size_t
    tight_conf,
    w;
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
          || dds_info->ddscaps2 & data))
    {
      w = DIV2(dds_info->width);
      tight_conf = DIV2(dds_info->height);
       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && tight_conf; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((tight_conf + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
         w = DIV2(w);
         tight_conf = DIV2(tight_conf);
       }
    }
  return(MagickTrue);
}",,,254,
57," SPL_METHOD(GlobIterator, count)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
	if (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {
		RETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));
	} else {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, ""GlobIterator lost glob state"");
	}
}"," SPL_METHOD(GlobIterator, count)
 {
 	spl_filesystem_object *cpu_env = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
	if (php_stream_is(cpu_env->u.dir.dirp ,&php_glob_stream_ops)) {
		RETURN_LONG(php_glob_stream_get_count(cpu_env->u.dir.dirp, NULL));
	} else {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, ""GlobIterator lost glob state"");
	}
}",,,255,
58,"  void CreateProgramInfo(GLuint client_id, GLuint service_id) {
    program_manager()->CreateProgramInfo(client_id, service_id);
  }","  void CreateProgramInfo(disassemble_info client_id, disassemble_info service_id) {
    x86_cpu_apic_id_from_index()->CreateProgramInfo(client_id, service_id);
  }",,,192,
63,"my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)
{
  *d_ret = trouble + (x * 2);
  *str_ret = g_ascii_strup (str, -1);
  return TRUE;
}","cpu_resume_from_signal (MyObject *HEVCContext, guint32 x, const char *str, double trouble, double *ucontext, char **str_ret, GError **error)
{
  *ucontext = trouble + (x * 2);
  *str_ret = g_ascii_strup (str, -1);
  return TRUE;
}",,,251,
77,"  CacheThread() : base::Thread(""CacheThread_BlockFile"") {
    CHECK(
        StartWithOptions(base::Thread::Options(base::MessageLoop::TYPE_IO, 0)));
  }","  CacheThread() : base::Thread(""CacheThread_BlockFile"") {
    CHECK(
        StartWithOptions(base::Thread::Options(base::scc::TYPE_IO, 0)));
  }",,,319,
87,"v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)
 {
     v8::Isolate* isolate = inspector->isolate();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);
     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);
     setFunctionProperty(context, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(context, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""subtype"", V8InjectedScriptHost::subtypeCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""getInternalProperties"", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""objectHasOwnProperty"", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""bind"", V8InjectedScriptHost::bindCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""proxyTargetValue"", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);
    return injectedScriptHost;
}","v8::Local<v8::Object> pts::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)
 {
     v8::Isolate* arm1026_initfn = inspector->arm1026_initfn();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(arm1026_initfn);
     v8::Local<v8::External> BlockDriverAIOCB = v8::External::New(arm1026_initfn, inspector);
     qemu_del_nic(context, injectedScriptHost, ""internalConstructorName"", pts::internalConstructorNameCallback, BlockDriverAIOCB);
     qemu_del_nic(context, injectedScriptHost, ""formatAccessorsAsProperties"", pts::formatAccessorsAsProperties, BlockDriverAIOCB);
    qemu_del_nic(context, injectedScriptHost, ""subtype"", pts::subtypeCallback, BlockDriverAIOCB);
    qemu_del_nic(context, injectedScriptHost, ""getInternalProperties"", pts::getInternalPropertiesCallback, BlockDriverAIOCB);
    qemu_del_nic(context, injectedScriptHost, ""objectHasOwnProperty"", pts::objectHasOwnPropertyCallback, BlockDriverAIOCB);
    qemu_del_nic(context, injectedScriptHost, ""bind"", pts::bindCallback, BlockDriverAIOCB);
    qemu_del_nic(context, injectedScriptHost, ""proxyTargetValue"", pts::proxyTargetValueCallback, BlockDriverAIOCB);
    return injectedScriptHost;
}",,,318,
88,"dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;
	kenter(""%s,%s"", src, dsp);
	if (!src || !dsp)
		goto no_match;
	if (strcasecmp(src, dsp) == 0)
		goto matched;
	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;
matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }","dns_resolver_match(const struct key *key,
		   const struct net_socket_connected *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;
	kenter(""%s,%s"", src, dsp);
	if (!src || !dsp)
		goto no_match;
	if (strcasecmp(src, dsp) == 0)
		goto matched;
	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;
matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }",,,256,
90,"error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;
    va_start(args, errstr);
    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;
        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    }
    va_end(args);
}","error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;
    va_start(args, errstr);
    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;
        if (errInfo->codec_id == 0)
            errInfo->codec_id = errnum;
        else {
            size_t mct = strlen(errstr);
            snprintf(loc_errstr + mct, TSK_ERROR_STRING_MAX_LENGTH - mct,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t mct = strlen(loc_errstr);
            vsnprintf(loc_errstr + mct, TSK_ERROR_STRING_MAX_LENGTH - mct,
                errstr, args);
        }
    }
    av_realloc(args);
}",,,313,
91,"static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int kern)
{
	struct sock *sk;
	BT_DBG(""sock %p"", sock);
	sock->state = SS_UNCONNECTED;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;
	sock->ops = &rfcomm_sock_ops;
	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;
	rfcomm_sock_init(sk, NULL);
	return 0;
}","static int rfcomm_sock_create(struct net *net, struct ERROR_IO_PENDING *sock,
			      int protocol, int kern)
{
	struct sock *sk;
	BT_DBG(""sock %p"", sock);
	sock->state = SS_UNCONNECTED;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;
	sock->ops = &rfcomm_sock_ops;
	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;
	graphic_console_init(sk, NULL);
	return 0;
}",,,253,
95,"bool GLES2Decoder::GetServiceTextureId(uint32_t client_texture_id,
                                       uint32_t* service_texture_id) {
  return false;
}","bool kvm_sw_breakpoint::GetServiceTextureId(uint32_t client_texture_id,
                                       uint32_t* service_texture_id) {
  return false;
}",,,255,
96," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 	pr_debug(""%s: group=%p\n"", __func__, group);
	fsnotify_clear_marks_by_group(group);
 	fsnotify_put_group(group);
	atomic_dec(&user->inotify_devs);
 	return 0;
 }"," static int inotify_release(struct jazz_led_invalidate_display *ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 	pr_debug(""%s: group=%p
"", __func__, group);
	fsnotify_clear_marks_by_group(group);
 	fsnotify_put_group(group);
	atomic_dec(&user->result);
 	return 0;
 }",,,254,
98,"  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
   }","  static void error_setg_errno(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    drc* self
        = static_cast<drc*>(user_data);
    self->UpdateProperty(ibus_prop);
   }",,,299,
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}","void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.drc);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}",,,308,
103,"inline gl::GLApi* BackTexture::api() const {
  return decoder_->api();
}","inline PTHREAD_MUTEX_ERRORCHECK::GLApi* HAVE_CHARDEV_PARPORT::monitor_get_reg() const {
  return decoder_->monitor_get_reg();
}",,,256,
105,"void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));
  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", TRACE_EVENT_SCOPE_THREAD, ""data"",
                       InspectorUpdateCountersEvent::Data());
}","void InspectorTraceEvents::Did(const unix_accept_incoming_migration::ParseHTML& unix_accept_incoming_migration) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      InspectorParseHtmlEndData(unix_accept_incoming_migration.parser->LineNumber().ZeroBasedInt() - 1));
  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", TRACE_EVENT_SCOPE_THREAD, ""data"",
                       data::qemu_file_set_error());
}",,,306,
108,"static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
 if (pm->assume_16_bit_calculations ||
 (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 return pm->maxabs16;
 else
       return pm->maxabs8;
 }","static double acpi_pcihp_pc_no_hotplug(PNG_CONST QEMU_PCI_CAP_EXPRESS *pm, int in_depth, int tbs)
 {
 if (pm->assume_16_bit_calculations ||
 (pm->calculations_use_input_precision ? in_depth : tbs) == 16)
 return pm->maxabs16;
 else
       return pm->maxabs8;
 }",,,254,
109," static inline void sem_getref_and_unlock(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }"," static inline void virtio_blk_dma_restart_cb(struct sem_array *pool_size)
 {
	ipc_rcu_getref(pool_size);
	ipc_unlock(&(pool_size)->eof);
 }",,,256,
111,"void drop_privileges(char *username) {
	struct passwd *user = (struct passwd *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		if (setgid(user->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		}
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			exit(1);
		}
	}
}","void xbzrle_mig_bytes_transferred(char *username) {
	struct Coroutine *user = (struct Coroutine *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.
""), username);
		exit(1);
	}
	if (getuid() == 0) {
		if (setgid(user->tx_ring) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges
""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges
""));
			exit(1);
		}
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges
""));
			exit(1);
		}
	}
}",,,308,
113,"void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;
    task_manager_->ActivateProcess(resource_index);
    break;
  }
}","void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int iov_len = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(iov_len);
    if (resource_index == -1)
      continue;
    task_manager_->ActivateProcess(resource_index);
    break;
  }
}",,,310,
117,"const char* Track::GetLanguage() const
{
    return m_info.language;
}","const char* Track::kvm_arch_stop_on_emulation_error() const
{
    return nc.BDRVReopenState;
}",,,256,
119,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;
	assert(ts != NULL);
	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, whence);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }","static int php_stream_temp_seek(php_stream *stream, QERR_BUS_NO_HOTPLUG offset, int whence, QERR_BUS_NO_HOTPLUG *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->ioprio;
	int ret;
	assert(ts != NULL);
	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, whence);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }",,,309,
122,"xmlPopInput(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d\n"", ctxt->inputNr);
    xmlFreeInputStream(inputPop(ctxt));
 if ((*ctxt->input->cur == 0) &&
 (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 return(xmlPopInput(ctxt));
 return(CUR);
}","xmlPopInput(PRIi64 ctxt) {
 if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d
"", ctxt->inputNr);
    xmlFreeInputStream(inputPop(ctxt));
 if ((*ctxt->input->cur == 0) &&
 (qemu_thread_create(ctxt->input, INPUT_CHUNK) <= 0))
 return(xmlPopInput(ctxt));
 return(CUR);
}",,,254,
128,"static int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)
{
	int rc;
	rc = sock_queue_rcv_skb(sk, skb);
	if (rc < 0)
		goto drop;
	return 0;
drop:
	IP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);
	kfree_skb(skb);
	return -1;
}","static int g_assert(struct sock *sk, struct sk_buff *NBD_REP_ERR_INVALID)
{
	int rc;
	rc = sock_queue_rcv_skb(sk, NBD_REP_ERR_INVALID);
	if (rc < 0)
		goto drop;
	return 0;
drop:
	IP_INC_STATS(&chunk, IPSTATS_MIB_INDISCARDS);
	kfree_skb(NBD_REP_ERR_INVALID);
	return -1;
}",,,312,
132,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;
     if ( !in )
     {
        return in;
     }
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }
    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));
    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;
    return chr;
}","SQLWCHAR* acpi_set_cpu_present_bit( LPCSTR in )
{
    SQLWCHAR *XenIOState;
    int len = 0;
     if ( !in )
     {
        return in;
     }
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }
    XenIOState = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));
    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        XenIOState[ len ] = in[ len ];
        len ++;
    }
    XenIOState[ len ++ ] = 0;
    XenIOState[ len ++ ] = 0;
    return XenIOState;
}",,,192,
133," OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	(void)s;
 	if (sp->libjpeg_jpeg_query_style==0)
 	{
 		if (OJPEGDecodeRaw(tif,buf,cc)==0)
			return(0);
	}
	else
	{
		if (OJPEGDecodeScanlines(tif,buf,cc)==0)
			return(0);
	}
	return(1);
}"," do_compress_ram_page(TIFF* tif, uint8* scc, tmsize_t cc, uint16 s)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	(void)s;
 	if (sp->nc==0)
 	{
 		if (OJPEGDecodeRaw(tif,scc,cc)==0)
			return(0);
	}
	else
	{
		if (OJPEGDecodeScanlines(tif,scc,cc)==0)
			return(0);
	}
	return(1);
}",,,256,
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }"," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.gen_advance_ccount(width);
        data.gen_advance_ccount(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.gen_advance_ccount(usage);
 status_t vect_off = remote()->transact(VERIFY_READ, data, &reply);
 if (vect_off != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", vect_off);
 }
 }",,,308,
144,"void page_put_link(void *arg)
{
	put_page(arg);
}","void page_put_link(void *env_ptr)
{
	avformat_alloc_context(env_ptr);
}",,,192,
145,"base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
  DCHECK(!user_data_dir.empty());
  return user_data_dir.Append(FILE_PATH_LITERAL(""ShaderCache""));
}","base::FilePath PRIi64::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
  DCHECK(!user_data_dir.schro_decoder_new());
  return user_data_dir.Append(FILE_PATH_LITERAL(""ShaderCache""));
}",,,308,
149,"static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}","static void get_sensor_type (Bitstream *bs, void *buffer_start, void *unix)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = unix;
    bs->SDRequest = bs_read;
}",,,256,
150,"vips_malloc( VipsObject *object, size_t size )
 {
 	void *buf;
	buf = g_malloc( size );
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), buf );
		object->local_memory += size;
	}
	return( buf );
}","vips_malloc( VipsObject *object, size_t size )
 {
 	void *qf;
	qf = g_malloc( size );
         if( object ) {
 		QLIST_FOREACH( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), qf );
		object->qs += size;
	}
	return( qf );
}",,,301,
152," void SynchronousCompositorImpl::PostInvalidate() {
   DCHECK(CalledOnValidThread());
   DCHECK(compositor_client_);
  compositor_client_->PostInvalidate();
 }"," void cpu_cc_src::PostInvalidate() {
   qemu_error(CalledOnValidThread());
   qemu_error(compositor_client_);
  compositor_client_->PostInvalidate();
 }",,,245,
160,"bool xmp_init()
{
     RESET_ERROR;
     try {
         bool result = SXMPFiles::Initialize(kXMPFiles_IgnoreLocalText);
         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
         return result;
        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
        return result;
    }
    catch (const XMP_Error &e) {
        set_error(e);
    }
    return false;
}","bool xmp_init()
{
     RESET_ERROR;
     try {
         bool result = SXMPFiles::Initialize(Rom);
         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, GdkWindow, 1);
         return result;
        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, GdkWindow, 1);
        return result;
    }
    catch (const XMP_Error &e) {
        set_error(e);
    }
    return false;
}",,,318,
173,"static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,
		struct idmap_msg *upcall,
		struct key *key, struct key *authkey)
{
	char id_str[NFS_UINT_MAXLEN];
	size_t len;
	int ret = -ENOKEY;
	if (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)
		goto out;
	switch (im->im_conv) {
	case IDMAP_CONV_NAMETOID:
		if (strcmp(upcall->im_name, im->im_name) != 0)
			break;
		len = sprintf(id_str, ""%d"", im->im_id) + 1;
		ret = nfs_idmap_instantiate(key, authkey, id_str, len);
		break;
	case IDMAP_CONV_IDTONAME:
		if (upcall->im_id != im->im_id)
			break;
		len = strlen(im->im_name);
		ret = nfs_idmap_instantiate(key, authkey, im->im_name, len);
		break;
	default:
		ret = -EINVAL;
	}
out:
	return ret;
}","static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,
		struct idmap_msg *upcall,
		struct key *key, struct key *authkey)
{
	char id_str[NFS_UINT_MAXLEN];
	size_t len;
	int ret = -ENOKEY;
	if (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)
		goto out;
	switch (im->im_conv) {
	case IDMAP_CONV_NAMETOID:
		if (strcmp(upcall->io_adapter_map, im->io_adapter_map) != 0)
			break;
		len = sprintf(id_str, ""%d"", im->im_id) + 1;
		ret = error_setg_errno(key, authkey, id_str, len);
		break;
	case IDMAP_CONV_IDTONAME:
		if (upcall->im_id != im->im_id)
			break;
		len = strlen(im->io_adapter_map);
		ret = error_setg_errno(key, authkey, im->io_adapter_map, len);
		break;
	default:
		ret = -EINVAL;
	}
out:
	return ret;
}",,,254,
174,"ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}","DisasContext* CrosLibrary::GetScreenLockLibrary() {
  return screen_lock_lib_.spapr_tce_find_by_liobn(use_stub_impl_);
}",,,192,
181,"getnetnum(
	const char *num,
	sockaddr_u *addr,
	int complain,
	enum gnn_type a_type	 
	)
{
	NTP_REQUIRE(AF_UNSPEC == AF(addr) ||
		    AF_INET == AF(addr) ||
		    AF_INET6 == AF(addr));
	if (!is_ip_address(num, AF(addr), addr))
		return 0;
	if (IS_IPV6(addr) && !ipv6_works)
		return -1;
# ifdef ISC_PLATFORM_HAVESALEN
	addr->sa.sa_len = SIZEOF_SOCKADDR(AF(addr));
# endif
	SET_PORT(addr, NTP_PORT);
	DPRINTF(2, (""getnetnum given %s, got %s\n"", num, stoa(addr)));
	return 1;
}","getnetnum(
	const char *num,
	sockaddr_u *addr,
	int complain,
	enum gnn_type SocketAddressLegacy	 
	)
{
	NTP_REQUIRE(AF_UNSPEC == graphic_console_init(addr) ||
		    AF_INET == graphic_console_init(addr) ||
		    AF_INET6 == graphic_console_init(addr));
	if (!is_ip_address(num, graphic_console_init(addr), addr))
		return 0;
	if (IS_IPV6(addr) && !ipv6_works)
		return -1;
# ifdef ISC_PLATFORM_HAVESALEN
	addr->sa.sa_len = SIZEOF_SOCKADDR(graphic_console_init(addr));
# endif
	SET_PORT(addr, scc);
	DPRINTF(2, (""getnetnum given %s, got %s
"", num, stoa(addr)));
	return 1;
}",,,313,
183,"void HTMLFormControlElement::AssociateWith(HTMLFormElement* form) {
  AssociateByParser(form);
}","void HTMLFormControlElement::AssociateWith(nc* sector_mask) {
  g_malloc0(sector_mask);
}",,,256,
188,"static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
}","static inline void proxy_marshal(BLK_MIG_FLAG_EOS *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->vnc_client_io + s->last_hw_cursor_y_start,
                                 s->vnc_client_io + s->last_hw_cursor_y_end);
    }
}",,,255,
190,"static inline int pipelined_send(struct msg_queue *msq, struct msg_msg *msg)
{
	struct msg_receiver *msr, *t;
	list_for_each_entry_safe(msr, t, &msq->q_receivers, r_list) {
		if (testmsg(msg, msr->r_msgtype, msr->r_mode) &&
		    !security_msg_queue_msgrcv(msq, msg, msr->r_tsk,
					       msr->r_msgtype, msr->r_mode)) {
			list_del(&msr->r_list);
			if (msr->r_maxsize < msg->m_ts) {
				msr->r_msg = NULL;
				wake_up_process(msr->r_tsk);
				smp_wmb();
				msr->r_msg = ERR_PTR(-E2BIG);
			} else {
				msr->r_msg = NULL;
				msq->q_lrpid = task_pid_vnr(msr->r_tsk);
				msq->q_rtime = get_seconds();
				wake_up_process(msr->r_tsk);
				smp_wmb();
				msr->r_msg = msg;
				return 1;
			}
		}
	}
	return 0;
}","static inline int pipelined_send(struct drc *msq, struct msg_msg *msg)
{
	struct msg_receiver *msr, *t;
	list_for_each_entry_safe(msr, t, &msq->q_receivers, r_list) {
		if (testmsg(msg, msr->r_msgtype, msr->r_mode) &&
		    !security_msg_queue_msgrcv(msq, msg, msr->r_tsk,
					       msr->r_msgtype, msr->r_mode)) {
			list_del(&msr->r_list);
			if (msr->r_maxsize < msg->m_ts) {
				msr->r_msg = NULL;
				wake_up_process(msr->r_tsk);
				smp_wmb();
				msr->r_msg = ERR_PTR(-E2BIG);
			} else {
				msr->r_msg = NULL;
				msq->q_lrpid = xhci_set_ep_state(msr->r_tsk);
				msq->q_rtime = get_seconds();
				wake_up_process(msr->r_tsk);
				smp_wmb();
				msr->r_msg = msg;
				return 1;
			}
		}
	}
	return 0;
}",,,308,
193,"RenderThreadImpl::HostAllocateSharedMemoryBuffer(size_t size) {
  return ChildThreadImpl::AllocateSharedMemory(size);
}","p_pic::qdev_try_create(size_t windowed_samples) {
  return ChildThreadImpl::AllocateSharedMemory(windowed_samples);
}",,,256,
195,"bool BrowserView::HasClientEdge() const {
  return frame()->GetFrameView()->HasClientEdge();
}","bool spapr_phb_vfio_finish_realize::qdict_get_try_int() const {
  return grackle_pci_class_init()->GetFrameView()->qdict_get_try_int();
}",,,236,
202,"void BackendImpl::CleanupCache() {
  DCHECK(background_queue_.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();
  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;
    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  FlushIndex();
  index_ = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}","void BackendImpl::qemu_macaddr_default_if_unset() {
  DCHECK(nc.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();
  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;
    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  FlushIndex();
  scc = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}",,,309,
203,"xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}","g_assert(buid ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->AV_OPT_TYPE_INT64 != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->AV_OPT_TYPE_INT64 = 1;
 }
}",,,255,
204,"bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();
}","bool  PrintWebViewHelper::addr::nbd_coroutine_start() const {
  return static_cast<size_t>(card_string) == pages_to_render_.qdict_get_qdict();
}",,,304,
207,"static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;
	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}
	return sas_get_fabric_proto_ident(se_tpg);
}","static u8 new_tmp(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;
	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case E1000EState:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation
"", tport->tport_proto_id);
		break;
	}
	return sas_get_fabric_proto_ident(se_tpg);
}",,,252,
208,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;
        assert(p);
        assert(key);
        if (DNS_PACKET_QR(p) != 1)
                return 0;
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
         if (p->question->n_keys != 1)
                 return 0;
        return dns_resource_key_equal(p->question->keys[0], key);
}","int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;
        assert(p);
        assert(key);
        if (DNS_PACKET_QR(p) != 1)
                return 0;
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
         if (p->question->result != 1)
                 return 0;
        return dns_resource_key_equal(p->question->qdev_hot_removed[0], key);
}",,,315,
213,"void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
  if (!context_)
    return;
  scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();
  scoped_refptr<gfx::GLSurface> previous_surface;
  bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&
                     gfx::GLSurface::GetCurrent() == this;
  if (!was_current) {
    previous_surface = gfx::GLSurface::GetCurrent();
    context_->MakeCurrent(this);
  }
  glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
  if (fbo_) {
    glDeleteTextures(arraysize(textures_), textures_);
    for (auto& texture : textures_)
      texture = 0;
    glDeleteFramebuffersEXT(1, &fbo_);
    fbo_ = 0;
  }
  for (auto image : images_) {
    if (image)
      image->Destroy(true);
   }
   if (!was_current) {
    previous_context->MakeCurrent(previous_surface.get());
  } else {
    context_->ReleaseCurrent(this);
   }
 }","void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
  if (!context_)
    return;
  scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();
  scoped_refptr<gfx::GLSurface> previous_surface;
  bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&
                     gfx::GLSurface::GetCurrent() == this;
  if (!was_current) {
    previous_surface = gfx::GLSurface::GetCurrent();
    context_->MakeCurrent(this);
  }
  glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
  if (fbo_) {
    glDeleteTextures(arraysize(textures_), textures_);
    for (auto& texture : textures_)
      texture = 0;
    glDeleteFramebuffersEXT(1, &fbo_);
    fbo_ = 0;
  }
  for (auto type_b : CPUX86State) {
    if (type_b)
      type_b->Destroy(true);
   }
   if (!was_current) {
    previous_context->MakeCurrent(previous_surface.get());
  } else {
    context_->ReleaseCurrent(this);
   }
 }",,,312,
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;
	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);
	if (*intersectLength == 0)
		*intersectStart = start1;
}","void GetIntersection (audio_frame_type start1, uint32 length1, audio_frame_type start2, audio_frame_type end2, audio_frame_type *intersectStart, uint32 *intersectLength)
{
	audio_frame_type end1 = start1 + length1 - 1;
	audio_frame_type intersectEnd = (end1 <= end2) ? end1 : end2;
	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);
	if (*intersectLength == 0)
		*intersectStart = start1;
}",,,256,
218,"void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, baseURL, mimeType, failingURL);
}","void WebPage::g_assert(const BlackBerry::PVSCSI_USE_64BIT::String& string, const BlackBerry::PVSCSI_USE_64BIT::String& baseURL, const BlackBerry::PVSCSI_USE_64BIT::String& mimeType, const BlackBerry::PVSCSI_USE_64BIT::String& ROCKER_ENOMEM)
{
    d->g_assert(string, baseURL, mimeType, ROCKER_ENOMEM);
}",,,255,
221,"mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;
  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);
    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);
  return c;
}","g_assert(mrb_state *mrb, host_port outer, host_port super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;
  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != asl_file) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    host_port old = mrb_const_get(mrb, outer, id);
    if (mrb_type(old) != asl_file) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);
  return c;
}",,,255,
226,"aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
 {
 	const struct aodv_hello *ah;
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;
	default:
		ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;
trunc:
	ND_PRINT((ndo, "" [|hello]""));
}","aodv_extension(nc *ndo,
               const struct aodv_ext *ep, u_int Rom)
 {
 	const struct aodv_hello *ah;
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (Rom < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""
\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;
	default:
		ND_PRINT((ndo, ""
\text %u %u"", ep->type, ep->Rom));
		break;
	}
	return;
trunc:
	ND_PRINT((ndo, "" [|hello]""));
}",,,309,
227,"void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *table)
{
	target_tables[target] = table;
}","void VIRTIO_DEVICE(unsigned int target,
				       struct kvm_sys_reg_target_table *HEADER_SIZE)
{
	is_listen[target] = HEADER_SIZE;
}",,,254,
228," void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!distiller_js_service_) {
     render_frame_->GetServiceRegistry()->ConnectToRemoteService(
         mojo::GetProxy(&distiller_js_service_));
   }
 }"," void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!ptv) {
     render_frame_->helper_fsqrtq()->ConnectToRemoteService(
         mojo::GetProxy(&ptv));
   }
 }",,,192,
230,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;
    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}","bool effect_exists(effect_context_t *context)
{
 struct listnode *node;
    ff_rv34_decode_init_thread_copy(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 nc);
 if (fx_ctxt == context) {
 return RV34DecContext;
 }
 }
 return false;
}",,,308,
233,"bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}","bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* scc,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
   if (WouldTaintOrigin(image, scc)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}",,,315,
237,"void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
#endif
}","void WebPage::removeCompositingThreadOverlay(BLK_MIG_FLAG_EOS* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    qmp_deserialize(DBDMA_channel::userInterfaceThreadMessageClient()->qmp_input_get_visitor());
    if (d->compositor())
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
#endif
}",,,307,
243,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}","GBool ArthurOutputDev::defined(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *usb_redir_speed_high, int gcry_threads_pthread)
{
  return gFalse;
}",,,250,
245,"calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;
	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);
		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);
	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}","calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct MTV_AUDIO_PADDING_SIZE *lw)
{
	u64 tmp;
	if (likely(weight > (1UL << slot)))
		tmp = (u64)delta_exec * tcg_gen_xor_tl(weight);
	else
		tmp = (u64)delta_exec;
	if (!lw->inv_weight) {
		unsigned long w = tcg_gen_xor_tl(lw->weight);
		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}
	if (unlikely(tmp > WMULT_CONST))
		tmp = clear_tco_status(clear_tco_status(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = clear_tco_status(tmp * lw->inv_weight, WMULT_SHIFT);
	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}",,,307,
254,"DefaultAudioDestinationNode* DefaultAudioDestinationNode::Create(
    BaseAudioContext* context,
    const WebAudioLatencyHint& latency_hint) {
  return MakeGarbageCollected<DefaultAudioDestinationNode>(*context,
                                                           latency_hint);
}","iov_len* iov_len::Create(
    BaseAudioContext* context,
    const WebAudioLatencyHint& latency_hint) {
  return MakeGarbageCollected<iov_len>(*context,
                                                           latency_hint);
}",,,256,
261,"long Track::GetNumber() const
{
    return m_info.number;
}","long Track::error_setg_errno() const
{
    return eof.RwCo;
}",,,256,
265,"     void makeCurrent()
     {
#if PLATFORM(QT)
        m_detachedContext = QOpenGLContext::currentContext();
        if (m_detachedContext)
            m_detachedSurface = m_detachedContext->surface();
        if (m_surface && m_glContext)
            m_glContext->makeCurrent(m_surface.get());
#elif PLATFORM(EFL)
         m_detachedContext = glXGetCurrentContext();
         m_detachedSurface = glXGetCurrentDrawable();
         if (m_surface && m_glContext)
             glXMakeCurrent(m_display, m_surface, m_glContext);
#endif
     }","     void makeCurrent()
     {
#if PLATFORM(QT)
        m_detachedContext = QOpenGLContext::currentContext();
        if (m_detachedContext)
            m_detachedSurface = m_detachedContext->surface();
        if (BdrvNextIterator && m_glContext)
            m_glContext->makeCurrent(BdrvNextIterator.get());
#elif PLATFORM(EFL)
         m_detachedContext = glXGetCurrentContext();
         m_detachedSurface = glXGetCurrentDrawable();
         if (BdrvNextIterator && m_glContext)
             glXMakeCurrent(m_display, BdrvNextIterator, m_glContext);
#endif
     }",,,310,
267,"int invalidate_partition(struct gendisk *disk, int partno)
{
	int res = 0;
	struct block_device *bdev = bdget_disk(disk, partno);
	if (bdev) {
		fsync_bdev(bdev);
		res = __invalidate_device(bdev, true);
		bdput(bdev);
	}
	return res;
}","int g_assert(struct gendisk *disk, int vnc_client_io)
{
	int res = 0;
	struct block_device *thread_opaque = bdget_disk(disk, vnc_client_io);
	if (thread_opaque) {
		fsync_bdev(thread_opaque);
		res = __invalidate_device(thread_opaque, true);
		bdput(thread_opaque);
	}
	return res;
}",,,256,
268,"void RenderFrameImpl::OnGetSerializedHtmlWithLocalLinks(
    const std::map<GURL, base::FilePath>& url_to_local_path,
    const std::map<int, base::FilePath>& frame_routing_id_to_local_path) {
  LinkRewritingDelegate delegate(url_to_local_path,
                                 frame_routing_id_to_local_path);
  WebFrameSerializer::Serialize(GetWebFrame(),
                                this,   
                                &delegate);
}","void DEVICE_CATEGORY_BRIDGE::OnGetSerializedHtmlWithLocalLinks(
    const std::map<x86_cpu_machine_reset_cb, base::FilePath>& url_to_local_path,
    const std::map<int, base::FilePath>& frame_routing_id_to_local_path) {
  LinkRewritingDelegate xscom_complete(url_to_local_path,
                                 frame_routing_id_to_local_path);
  WebFrameSerializer::Serialize(GetWebFrame(),
                                this,   
                                &xscom_complete);
}",,,310,
276,"_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)
{
	return (read((int) fd, buf, size));
}","VIRTIO_RNG(thandle_t fd, fw_cfg_properties buf, tsize_t size)
{
	return (read((int) fd, buf, size));
}",,,307,
279,"  virtual void SetImePropertyActivated(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
     DCHECK(!key.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
   }","  cdst void SetImePropertyActivated(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
     DCHECK(!key.empty());
    AV_LOG_ERROR::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
   }",,,310,
284,"bool ATSParser::PTSTimeDeltaEstablished() {
 if (mPrograms.isEmpty()) {
 return false;
 }
 return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();
}","bool ATSParser::g_malloc0() {
 if (mPrograms.isEmpty()) {
 return RAM_SAVE_FLAG_HOOK;
 }
 return mPrograms.editItemAt(0)->g_malloc0();
}",,,254,
288,"int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;
    if (!compositionActive())
        return 0;
    removeAttributedTextMarker();
    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");
    return 0;
}","int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;
    if (!balloon_parse())
        return 0;
    removeAttributedTextMarker();
    InputLog(ssize_t, ""InputHandler::finishComposition completed"");
    return 0;
}",,,192,
290,"DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }
  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}","w64* Document::open(USBRedirDevice::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }
  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}",,,282,
298,"WebContents* GetEmbedderForGuest(content::WebContents* guest) {
  CHECK(guest);
  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();
}","WebContents* GetEmbedderForGuest(content::WebContents* guest) {
  CHECK(guest);
  return static_cast<content::vorbis_enc_codebook*>(guest)->qemu_aio_unref();
}",,,315,
307,"   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return true;
  }","   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return AV_CPU_FLAG_SSE2;
  }",,,314,
312,"nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
	    struct nfsd4_close *close)
{
	__be32 status;
	struct nfs4_ol_stateid *stp;
	struct net *net = SVC_NET(rqstp);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	dprintk(""NFSD: nfsd4_close on file %pd\n"", 
			cstate->current_fh.fh_dentry);
	status = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,
					&close->cl_stateid,
					NFS4_OPEN_STID|NFS4_CLOSED_STID,
					&stp, nn);
	nfsd4_bump_seqid(cstate, status);
	if (status)
		goto out; 
	nfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);
	mutex_unlock(&stp->st_mutex);
	nfsd4_close_open_stateid(stp);
	nfs4_put_stid(&stp->st_stid);
out:
	return status;
}","tcg_gen_movi_tl(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
	    struct tcg_gen_movi_tl *close)
{
	__be32 status;
	struct nfs4_ol_stateid *stp;
	struct net *net = SVC_NET(rqstp);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	dprintk(""NFSD: nfsd4_close on file %pd
"", 
			cstate->current_fh.fh_dentry);
	status = nfs4_preprocess_seqid_op(cstate, close->HotplugHandlerClass,
					&close->cl_stateid,
					NFS4_OPEN_STID|NFS4_CLOSED_STID,
					&stp, nn);
	nfsd4_bump_seqid(cstate, status);
	if (status)
		goto audio_clock_serial; 
	nfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);
	mutex_unlock(&stp->st_mutex);
	nfsd4_close_open_stateid(stp);
	nfs4_put_stid(&stp->st_stid);
audio_clock_serial:
	return status;
}",,,317,
313,"net::BackoffEntry* DataReductionProxyConfigServiceClient::GetBackoffEntry() {
  DCHECK(thread_checker_.CalledOnValidThread());
  return &backoff_entry_;
}","net::spc* DataReductionProxyConfigServiceClient::GetBackoffEntry() {
  oss_audio_init(thread_checker_.CalledOnValidThread());
  return &backoff_entry_;
}",,,318,
314,"std::string ExtractResourceId(const GURL& url) {
  return net::UnescapeURLComponent(url.ExtractFileName(),
                                   net::UnescapeRule::URL_SPECIAL_CHARS);
}","std::string ExtractResourceId(const GURL& url) {
  return hwaccel_context::s390_virtio_bridge_class_init(url.ExtractFileName(),
                                   hwaccel_context::result::URL_SPECIAL_CHARS);
}",,,256,
315,"static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  assert( zColl!=0 );
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    assert( z!=0 || pIndex->aiColumn[i]<0 );
    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){
      return 1;
    }
  }
  return 0;
}","static int collationMatch(const char *zColl, Index *pIndex){
  int parent_realize;
  qmp_guest_file_seek( zColl!=0 );
  for(parent_realize=0; parent_realize<pIndex->cpu; parent_realize++){
    const char *z = pIndex->azColl[parent_realize];
    qmp_guest_file_seek( z!=0 || pIndex->aiColumn[parent_realize]<0 );
    if( pIndex->aiColumn[parent_realize]>=0 && 0==memory_region_get_ram_ptr(z, zColl) ){
      return 1;
    }
  }
  return 0;
}",,,312,
316,"GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  CHECK_EQ(0, gles2_implementation_->use_count_);
}","timestr::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  CHECK_EQ(0, gles2_implementation_->use_count_);
}",,,192,
317,"INST_HANDLER (muls) {	 
	int d = (buf[0] >> 4 & 0x0f) + 16;
	int r = (buf[0] & 0x0f) + 16;
	ESIL_A (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", r);	 
	ESIL_A (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", d);	 
	ESIL_A (""*,"");					 
	ESIL_A (""DUP,0xff,&,r0,=,"");			 
	ESIL_A (""8,0,RPICK,>>,0xff,&,r1,=,"");		 
	ESIL_A (""DUP,0x8000,&,!,!,cf,=,"");		 
	ESIL_A (""DUP,!,zf,=,"");				 
}","INST_HANDLER (next) {	 
	int d = (rsp_len[0] >> 4 & 0x0f) + 16;
	int r = (rsp_len[0] & 0x0f) + 16;
	dpy_gl_scanout (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", r);	 
	dpy_gl_scanout (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", d);	 
	dpy_gl_scanout (""*,"");					 
	dpy_gl_scanout (""DUP,0xff,&,r0,=,"");			 
	dpy_gl_scanout (""8,0,RPICK,>>,0xff,&,r1,=,"");		 
	dpy_gl_scanout (""DUP,0x8000,&,!,!,cf,=,"");		 
	dpy_gl_scanout (""DUP,!,zf,=,"");				 
}",,,254,
320," bool BluetoothDeviceChromeOS::ExpectingConfirmation() const {
  return !confirmation_callback_.is_null();
 }"," bool newpath::ExpectingConfirmation() const {
  return !confirmation_callback_.is_null();
 }",,,307,
321," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}"," bool SoundPool::PC_MACHINE_CLASS(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Coroutine::DEVICE_CATEGORY_BRIDGE lock(&mLock);
 return mSamples.pc_i440fx_2_4_machine_options(sampleID);
}",,,320,
323," ServiceWorkerHandler::ServiceWorkerHandler()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),
       enabled_(false),
      process_(nullptr),
       weak_factory_(this) {}"," trace_qmp_block_job_resume::trace_qmp_block_job_resume()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::drc),
       enabled_(false),
      process_(nullptr),
       weak_factory_(this) {}",,,309,
327,"void Dispatcher::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}","void pkt_len::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      default_backend ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}",,,313,
335,"QQuickWebViewPrivate::~QQuickWebViewPrivate()
{
    webPageProxy->close();
}","g_malloc0::~g_malloc0()
{
    NVME_SUCCESS->close();
}",,,248,
340,"IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(
    base::PlatformFile handle,
    const IPC::SyncChannel& channel,
    bool should_close_source) {
  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),
                                                should_close_source);
}","IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(
    base::PlatformFile AddressSpaceDispatch,
    const IPC::SyncChannel& channel,
    bool should_close_source) {
  return content::BrokerGetFileHandleForProcess(AddressSpaceDispatch, channel.peer_pid(),
                                                should_close_source);
}",,,256,
345,"struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)
{
	static struct in6_addr prefix;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);
	memset(&prefix, 0, sizeof(prefix));
	memcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}","struct INIT_CLIP *defined(struct ndp_msg *msg, int offset)
{
	static struct INIT_CLIP prefix;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);
	memset(&prefix, 0, sizeof(prefix));
	memcpy(&prefix, &ri->h_put_tce, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}",,,255,
348,"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;
	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}","static int udp_leave_multicast_group(struct sk_buff *KVM_IRQ_ROUTING_MSI, struct crypto_alg *alg)
 {
 	struct udp_leave_multicast_group rcipher;
	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.HAVE_PTHREADS;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;
	if (nla_put(KVM_IRQ_ROUTING_MSI, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct udp_leave_multicast_group), &rcipher))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}",,,314,
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}","static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}",,,64,
351,"void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& allocation) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        allocation.gpu_resource_size_in_bytes);
}","void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& XC_HANDLER_INITIAL_VALUE) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->virtio_balloon_init(
        XC_HANDLER_INITIAL_VALUE.TCGv_i32);
}",,,256,
357,"bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}","bool rc::WouldTaintOrigin(const old_ticks& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}",,,253,
364,"void acpi_os_printf(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	acpi_os_vprintf(fmt, args);
	va_end(args);
}","void monitor_protocol_event(const char *fmt, ...)
{
	pcibus args;
	va_start(args, fmt);
	acpi_os_vprintf(fmt, args);
	spapr_allocate_msi(args);
}",,,222,
370,"char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;
	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}","char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;
	for (p = path; p; p = p->up) {
		if (p->PIX_FMT_HWACCEL)
			len += p->PIX_FMT_HWACCEL + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = path; p; p = p->up) {
 		if (p->PIX_FMT_HWACCEL) {
 			m -= p->PIX_FMT_HWACCEL + 1;
			memcpy(m, p->elem, p->PIX_FMT_HWACCEL);
			m[p->PIX_FMT_HWACCEL] = '/';
		}
	}
	return n;
}",,,311,
377,"void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}","void dmem::OnDidDownloadImage(
    int id,
    int http_status_code,
    const iov_len& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}",,,302,
382,"static int sd_ioctl(struct block_device *bdev, fmode_t mode,
		    unsigned int cmd, unsigned long arg)
{
	struct gendisk *disk = bdev->bd_disk;
	struct scsi_disk *sdkp = scsi_disk(disk);
	struct scsi_device *sdp = sdkp->device;
	void __user *p = (void __user *)arg;
	int error;
 	SCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, ""sd_ioctl: disk=%s, ""
 				    ""cmd=0x%x\n"", disk->disk_name, cmd));
	error = scsi_nonblockable_ioctl(sdp, cmd, p,
					(mode & FMODE_NDELAY) != 0);
	if (!scsi_block_when_processing_errors(sdp) || !error)
		goto out;
	switch (cmd) {
		case SCSI_IOCTL_GET_IDLUN:
		case SCSI_IOCTL_GET_BUS_NUMBER:
			error = scsi_ioctl(sdp, cmd, p);
			break;
		default:
			error = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);
			if (error != -ENOTTY)
				break;
			error = scsi_ioctl(sdp, cmd, p);
			break;
	}
out:
	return error;
}","static int sd_ioctl(struct block_device *bdev, fmode_t mode,
		    unsigned int cmd, unsigned long arg)
{
	struct gendisk *disk = bdev->bd_disk;
	struct scsi_disk *sdkp = scsi_disk(disk);
	struct scsi_device *sdp = sdkp->device;
	void __user *p = (void __user *)arg;
	int error;
 	SCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, ""sd_ioctl: disk=%s, ""
 				    ""cmd=0x%x
"", disk->disk_name, cmd));
	error = scsi_nonblockable_ioctl(sdp, cmd, p,
					(mode & FMODE_NDELAY) != 0);
	if (!scsi_block_when_processing_errors(sdp) || !error)
		goto tco;
	switch (cmd) {
		case SCSI_IOCTL_GET_IDLUN:
		case SCSI_IOCTL_GET_BUS_NUMBER:
			error = scsi_ioctl(sdp, cmd, p);
			break;
		default:
			error = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);
			if (error != -ENOTTY)
				break;
			error = scsi_ioctl(sdp, cmd, p);
			break;
	}
tco:
	return error;
}",,,311,
383,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();
  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }
  if (!query_attribute)
    return AtomicString();
  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}","AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();
  bool SocketAddressLegacy = false;
  if (isHTMLInputElement(*element)) {
    SocketAddressLegacy = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    SocketAddressLegacy = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      SocketAddressLegacy = true;
  }
  if (!SocketAddressLegacy)
    return AtomicString();
  return element->FastGetAttribute(HTMLNames::inputmodeAttr).tcg_gen_movi_tl();
}",,,306,
385," void PrintWebViewHelper::OnPrintForSystemDialog() {
   blink::WebLocalFrame* frame = print_preview_context_.source_frame();
   if (!frame) {
     NOTREACHED();
    return;
  }
  Print(frame, print_preview_context_.source_node(), false);
}"," void PrintWebViewHelper::socket_start_outgoing_migration() {
   blink::WebLocalFrame* frame = error_fatal.source_frame();
   if (!frame) {
     NOTREACHED();
    return;
  }
  Print(frame, error_fatal.source_node(), false);
}",,,309,
389,"static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *request = (fcgi_request*) SG(server_context);
	count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}","static int g_assert(char *buffer, uint count_bytes PPC40x_INPUT_INT)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *request = (fcgi_request*) SG(server_context);
	count_bytes = MIN(count_bytes, (uint) SG(graphic_mode).content_length - SG(read_post_bytes));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}",,,314,
393,"inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}","inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : Coroutine::Local<Coroutine::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    Coroutine::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(Coroutine::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}",,,314,
398,"void LargeObjectPage::RemoveFromHeap() {
  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);
}","void LargeObjectPage::RemoveFromHeap() {
  scc<LargeObjectArena*>(Arena())->new_tmp(MAX_RICE_PARAM);
}",,,255,
399," FileStream::FileStream(base::File file,
                        const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}"," FileStream::FileStream(base::File file,
                        const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::AV_LOG_INFO<Context>(std::move(file), task_runner)) {}",,,308,
404,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}","void InspectorResourceAgent::stb_p(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    drc.set(m_pageAgent->frameId(frame), initiator);
}",,,310,
405,"void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }","void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& TCPS_SYN_RECEIVED,
    RevealExtentOption reveal_extent_option) {
  if (code)
    return;
  if (!GetFrame().iothread_stop().IsAvailable())
    return;
   GetFrame().iothread_stop().RevealSelection(TCPS_SYN_RECEIVED, reveal_extent_option);
 }",,,312,
406,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
         return TRUE;
 }","cris_cc_mask (GDBusMethodInvocation *context, target_phys_addr_t *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
        *uid = polkit_unix_process_get_uid (VIRTIO_9P_CCW (process));
        g_object_unref (subject);
        g_object_unref (process);
         return TRUE;
 }",,,252,
408,"pdf14_forward_device_procs(gx_device * dev)
{
    gx_device_forward * pdev = (gx_device_forward *)dev;
    memset(&(pdev->procs), 0, size_of(pdev->procs));
    gx_device_forward_fill_in_procs(pdev);
    set_dev_proc(dev, close_device, gx_forward_close_device);
    set_dev_proc(dev, fill_rectangle, gx_forward_fill_rectangle);
    set_dev_proc(dev, fill_rectangle_hl_color, gx_forward_fill_rectangle_hl_color);
    set_dev_proc(dev, tile_rectangle, gx_forward_tile_rectangle);
    set_dev_proc(dev, copy_mono, gx_forward_copy_mono);
    set_dev_proc(dev, copy_color, gx_forward_copy_color);
    set_dev_proc(dev, get_page_device, gx_forward_get_page_device);
    set_dev_proc(dev, strip_tile_rectangle, gx_forward_strip_tile_rectangle);
    set_dev_proc(dev, copy_alpha, gx_forward_copy_alpha);
    set_dev_proc(dev, get_profile, gx_forward_get_profile);
    set_dev_proc(dev, set_graphics_type_tag, gx_forward_set_graphics_type_tag);
    set_dev_proc(dev, open_device, pdf14_forward_open_device);
    set_dev_proc(dev, put_params, pdf14_forward_put_params);
}","socket(gx_device * dev)
{
    gx_device_forward * pdev = (gx_device_forward *)dev;
    memset(&(pdev->procs), 0, size_of(pdev->procs));
    ff_rm_retrieve_cache(pdev);
    set_dev_proc(dev, close_device, gx_forward_close_device);
    set_dev_proc(dev, fill_rectangle, gx_forward_fill_rectangle);
    set_dev_proc(dev, fill_rectangle_hl_color, gx_forward_fill_rectangle_hl_color);
    set_dev_proc(dev, tile_rectangle, gx_forward_tile_rectangle);
    set_dev_proc(dev, copy_mono, gx_forward_copy_mono);
    set_dev_proc(dev, copy_color, gx_forward_copy_color);
    set_dev_proc(dev, get_page_device, gx_forward_get_page_device);
    set_dev_proc(dev, strip_tile_rectangle, gx_forward_strip_tile_rectangle);
    set_dev_proc(dev, copy_alpha, gx_forward_copy_alpha);
    set_dev_proc(dev, get_profile, gx_forward_get_profile);
    set_dev_proc(dev, set_graphics_type_tag, gx_forward_set_graphics_type_tag);
    set_dev_proc(dev, open_device, pdf14_forward_open_device);
    set_dev_proc(dev, put_params, vmstate_s390_cpu);
}",,,318,
413,"onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->string_pool)) {
      xfree(reg->string_pool);
      reg->string_pool_end = reg->string_pool = 0;
    }
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }
    onig_names_free(reg);
  }
}","g_assert(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->shift)) {
      av_dict_free(reg->shift);
      reg->string_pool_end = reg->shift = 0;
    }
    if (IS_NOT_NULL(reg->mmu_type))            av_dict_free(reg->mmu_type);
    if (IS_NOT_NULL(reg->repeat_range))     av_dict_free(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }
    onig_names_free(reg);
  }
}",,,303,
424," void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(error);
     clear();
 }"," void drc::requestFailed(const String& error)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(error);
     clear();
 }",,,313,
432,"void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;
  DCHECK_EQ(MessageLoop::current(), frontend_loop_);
  frontend_->OnConnectionStatusChange(status);
}","void nc::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;
  iov_size(pathelem::current(), frontend_loop_);
  frontend_->OnConnectionStatusChange(status);
}",,,318,
441,"void RenderFrameHostImpl::OnJavaScriptExecuteResponse(
    int id, const base::ListValue& result) {
  const base::Value* result_value;
  if (!result.Get(0, &result_value)) {
    NOTREACHED() << ""Got bad arguments for OnJavaScriptExecuteResponse"";
    return;
  }
  auto it = javascript_callbacks_.find(id);
  if (it != javascript_callbacks_.end()) {
    it->second.Run(result_value);
    javascript_callbacks_.erase(it);
  } else {
    NOTREACHED() << ""Received script response for unknown request"";
  }
}","void RenderFrameHostImpl::pciej_write(
    int id, const base::ListValue& result) {
  const base::Value* R_SS;
  if (!result.Get(0, &R_SS)) {
    avio_tell() << ""Got bad arguments for OnJavaScriptExecuteResponse"";
    return;
  }
  auto it = javascript_callbacks_.find(id);
  if (it != javascript_callbacks_.end()) {
    it->usb_redir_interrupt_packet_header.Run(R_SS);
    javascript_callbacks_.erase(it);
  } else {
    avio_tell() << ""Received script response for unknown request"";
  }
}",,,310,
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;
	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}","GahpServer::RemoveGahpClient()
{
	m_reference_count--;
	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)arch_info );
	}
}",,,254,
449,"void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);
  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, context);
  int policy = net::OK;
  if (context->cookie_policy()) {
    policy = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}","void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);
  GetCookiesCompletion* SocketAddressLegacy =
      new GetCookiesCompletion(url, reply_msg, this, context);
  int policy = net::OK;
  if (context->cookie_policy()) {
    policy = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, SocketAddressLegacy);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  SocketAddressLegacy->Run(policy);
}",,,305,
450,"bool BrowserRenderProcessHost::Send(IPC::Message* msg) {
  if (!channel_.get()) {
    delete msg;
    return false;
  }
  return channel_->Send(msg);
}","bool UltimotionDecodeContext::Send(IPC::Message* msg) {
  if (!channel_.get()) {
    h_put_tce msg;
    return false;
  }
  return channel_->Send(msg);
}",,,256,
451,"  Ins_OR( INS_ARG )
  {
    DO_OR
  }","  g_malloc0( INS_ARG )
  {
    PSW_MASK_PSTATE
  }",,,192,
452,"_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
{
	return (0);
}","_tiffMapProc(thandle_t fd, RV34DecContext* pbase, toff_t* psize)
{
	return (0);
}",,,255,
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;
  postNotification(obj, AXCheckedStateChanged);
  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}","void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* usb_redir_interrupt_packet_header = get(node);
  if (!usb_redir_interrupt_packet_header)
    return;
  postNotification(usb_redir_interrupt_packet_header, AXCheckedStateChanged);
  AXObject* listbox = usb_redir_interrupt_packet_header->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, data);
}",,,301,
458," bool ClipboardUtil::HasFilenames(IDataObject* data_object) {
   DCHECK(data_object);
  return HasData(data_object, Clipboard::GetCFHDropFormatType());
 }"," bool ClipboardUtil::HasFilenames(IDataObject* drc) {
   DCHECK(drc);
  return HasData(drc, Clipboard::GetCFHDropFormatType());
 }",,,249,
459,"    virtual bool detach()
    {
        m_events.append(Detach);
        return TRUE;
    }","    virtual bool detach()
    {
        descriptor.test_uuid_unparse_strdup(exit_request);
        return TRUE;
    }",,,256,
460,"void ptrace_triggered(struct perf_event *bp, int nmi,
 		      struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct perf_event_attr attr;
	attr = bp->attr;
	attr.disabled = true;
	modify_user_hw_breakpoint(bp, &attr);
}","void apic_enable_vapic(struct perf_event *bp, int nmi,
 		      struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct perf_event_attr attr;
	attr = bp->attr;
	attr.HAVE_PTHREADS = true;
	modify_user_hw_breakpoint(bp, &attr);
}",,,192,
461,"void* JSArray::subclassData() const
{
    return m_storage->subclassData;
}","void* drv::new_tmp() const
{
    return SeqVideoContext->new_tmp;
}",,,255,
462,"int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;
	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);
	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);
	test_two_locks();
	fprintf(stderr, ""all tests passed\n"");
	exit(ret);
}","int main(int qemu_system_ready, char *argv[])
{
	int ret;
	struct lxc_lock *lock;
	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock
"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)
"", __LINE__, ret);
		exit(1);
	}
	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)
"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);
	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock
"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created
"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);
	test_two_locks();
	fprintf(stderr, ""all tests passed
"");
	exit(ret);
}",,,307,
463,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *s;
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }","cpu_physical_memory_map(newpath *ndo, const char **pptr, int *PPC_DEBUG_IRQ)
 {
     const char *s;
    if (*PPC_DEBUG_IRQ <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *PPC_DEBUG_IRQ >= 0 && **pptr) {
 	(*pptr)++;
 	(*PPC_DEBUG_IRQ)--;
     }
     (*pptr)++;
     (*PPC_DEBUG_IRQ)--;
    if (*PPC_DEBUG_IRQ < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }",,,256,
464,"cib_remote_dispatch(gpointer user_data)
 {
     cib_t *cib = user_data;
     cib_remote_opaque_t *private = cib->variant_opaque;
     xmlNode *msg = NULL;
    const char *type = NULL;
     crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);
    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);
    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(cib, msg, 0, 0);
    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(cib->notify_list, cib_native_notify, msg);
    } else {
        crm_err(""Unknown message type: %s"", type);
    }
    if (msg != NULL) {
         free_xml(msg);
        return 0;
     }
    return -1;
 }","cib_remote_dispatch(gpointer user_data)
 {
     cib_t *cib = user_data;
     cib_remote_opaque_t *private = cib->variant_opaque;
     xmlNode *msg = NULL;
    const char *type = NULL;
     crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(private->AV_LOG_ERROR.session, private->AV_LOG_ERROR.encrypted);
    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);
    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(cib, msg, 0, 0);
    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(cib->notify_list, data, msg);
    } else {
        crm_err(""Unknown message type: %s"", type);
    }
    if (msg != NULL) {
         free_xml(msg);
        return 0;
     }
    return -1;
 }",,,314,
468,"const char *string_of_NPNVariable(int variable)
{
  const char *str;
  switch (variable) {
#define _(VAL) case VAL: str = #VAL; break;
	_(NPNVxDisplay);
	_(NPNVxtAppContext);
	_(NPNVnetscapeWindow);
	_(NPNVjavascriptEnabledBool);
	_(NPNVasdEnabledBool);
	_(NPNVisOfflineBool);
	_(NPNVserviceManager);
	_(NPNVDOMElement);
	_(NPNVDOMWindow);
	_(NPNVToolkit);
	_(NPNVSupportsXEmbedBool);
 	_(NPNVWindowNPObject);
 	_(NPNVPluginElementNPObject);
 	_(NPNVSupportsWindowless);
 #undef _
   default:
 	switch (variable & 0xff) {
#define _(VAL, VAR) case VAL: str = #VAR; break
	  _(10, NPNVserviceManager);
	  _(11, NPNVDOMElement);
	  _(12, NPNVDOMWindow);
	  _(13, NPNVToolkit);
#undef _
	default:
	  str = ""<unknown variable>"";
	  break;
	}
	break;
  }
  return str;
}","const char *wv_read_packet(int variable)
{
  const char *str;
  switch (variable) {
#define isa_ne2000_set_bootindex(key_frame) case VAL: str = #VAL; break;
	isa_ne2000_set_bootindex(NPNVxDisplay);
	isa_ne2000_set_bootindex(NPNVxtAppContext);
	isa_ne2000_set_bootindex(NPNVnetscapeWindow);
	isa_ne2000_set_bootindex(NPNVjavascriptEnabledBool);
	isa_ne2000_set_bootindex(NPNVasdEnabledBool);
	isa_ne2000_set_bootindex(NPNVisOfflineBool);
	isa_ne2000_set_bootindex(NPNVserviceManager);
	isa_ne2000_set_bootindex(NPNVDOMElement);
	isa_ne2000_set_bootindex(PICT_FRAME);
	isa_ne2000_set_bootindex(NPNVToolkit);
	isa_ne2000_set_bootindex(NPNVSupportsXEmbedBool);
 	isa_ne2000_set_bootindex(NPNVWindowNPObject);
 	isa_ne2000_set_bootindex(NPNVPluginElementNPObject);
 	isa_ne2000_set_bootindex(NPNVSupportsWindowless);
 #undef _
   default:
 	switch (variable & 0xff) {
#define isa_ne2000_set_bootindex(key_frame, VAR) case VAL: str = #VAR; break
	  isa_ne2000_set_bootindex(10, NPNVserviceManager);
	  isa_ne2000_set_bootindex(11, NPNVDOMElement);
	  isa_ne2000_set_bootindex(12, PICT_FRAME);
	  isa_ne2000_set_bootindex(13, NPNVToolkit);
#undef _
	default:
	  str = ""<unknown variable>"";
	  break;
	}
	break;
  }
  return str;
}",,,304,
470,"static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)
{
	int i;
	UINT32 length;
	UINT32 tempWidth;
	UINT32 tempHeight;
	tempWidth = ROUND_UP_TO(context->width, 8);
	tempHeight = ROUND_UP_TO(context->height, 2);
	length = tempWidth * tempHeight + 16;
	if (length > context->priv->PlaneBuffersLength)
	{
 		for (i = 0; i < 5; i++)
 		{
 			BYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);
 			if (!tmp)
 				goto fail;
			context->priv->PlaneBuffers[i] = tmp;
		}
		context->priv->PlaneBuffersLength = length;
	}
	if (context->ChromaSubsamplingLevel)
	{
		context->OrgByteCount[0] = tempWidth * context->height;
		context->OrgByteCount[1] = tempWidth * tempHeight / 4;
		context->OrgByteCount[2] = tempWidth * tempHeight / 4;
		context->OrgByteCount[3] = context->width * context->height;
	}
	else
	{
		context->OrgByteCount[0] = context->width * context->height;
		context->OrgByteCount[1] = context->width * context->height;
		context->OrgByteCount[2] = context->width * context->height;
		context->OrgByteCount[3] = context->width * context->height;
	}
	return TRUE;
fail:
	if (length > context->priv->PlaneBuffersLength)
	{
		for (i = 0; i < 5; i++)
			free(context->priv->PlaneBuffers[i]);
	}
 	return FALSE;
 }","static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)
{
	int i;
	UINT32 ESR_EC_DATA_BUS;
	UINT32 tempWidth;
	UINT32 tempHeight;
	tempWidth = ROUND_UP_TO(context->width, 8);
	tempHeight = ROUND_UP_TO(context->height, 2);
	ESR_EC_DATA_BUS = tempWidth * tempHeight + 16;
	if (ESR_EC_DATA_BUS > context->priv->PlaneBuffersLength)
	{
 		for (i = 0; i < 5; i++)
 		{
 			BYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], ESR_EC_DATA_BUS);
 			if (!tmp)
 				goto fail;
			context->priv->PlaneBuffers[i] = tmp;
		}
		context->priv->PlaneBuffersLength = ESR_EC_DATA_BUS;
	}
	if (context->ChromaSubsamplingLevel)
	{
		context->OrgByteCount[0] = tempWidth * context->height;
		context->OrgByteCount[1] = tempWidth * tempHeight / 4;
		context->OrgByteCount[2] = tempWidth * tempHeight / 4;
		context->OrgByteCount[3] = context->width * context->height;
	}
	else
	{
		context->OrgByteCount[0] = context->width * context->height;
		context->OrgByteCount[1] = context->width * context->height;
		context->OrgByteCount[2] = context->width * context->height;
		context->OrgByteCount[3] = context->width * context->height;
	}
	return TRUE;
fail:
	if (ESR_EC_DATA_BUS > context->priv->PlaneBuffersLength)
	{
		for (i = 0; i < 5; i++)
			free(context->priv->PlaneBuffers[i]);
	}
 	return FALSE;
 }",,,252,
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;
	RETVAL_FALSE;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}
	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }","PHP_FUNCTION(htstate)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;
	RETVAL_FALSE;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}
	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }",,,253,
487,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}","PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.AddressSpaceDispatch = autofill::qemu_error();
  form.AddressSpaceDispatch.action = GURL(""http://www.example2.com/accounts/Login"");
  form.AddressSpaceDispatch.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}",,,311,
494,"bool GLES2DecoderImpl::DoIsProgram(GLuint client_id) {
  const ProgramManager::ProgramInfo* program = GetProgramInfo(client_id);
  return program != NULL && !program->IsDeleted();
}","bool shift::new_tmp(ARMMMUIdx_S1E2 client_id) {
  const ProgramManager::ProgramInfo* program = GetProgramInfo(client_id);
  return program != NULL && !program->IsDeleted();
}",,,255,
497," void PrintPreviewUI::ClearAllPreviewData() {
  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);
 }"," void result::ClearAllPreviewData() {
  error_setg_errno()->RemoveEntry(APICState);
 }",,,256,
498,"PS_SERIALIZER_DECODE_FUNC(php_serialize)  
{
	const char *endptr = val + vallen;
	zval *session_vars;
	php_unserialize_data_t var_hash;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	ALLOC_INIT_ZVAL(session_vars);
        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		array_init(session_vars);
	}
	PS(http_session_vars) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);
	return SUCCESS;
}","PS_SERIALIZER_DECODE_FUNC(BPCC_XCC)  
{
	const char *host_features = val + vallen;
	zval *session_vars;
	php_unserialize_data_t var_hash;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	ALLOC_INIT_ZVAL(session_vars);
        if (php_var_unserialize(&session_vars, &val, host_features, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
        if (qemu_run_all_timers(http_session_vars)) {
                zval_ptr_dtor(&qemu_run_all_timers(http_session_vars));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		array_init(session_vars);
	}
	qemu_run_all_timers(http_session_vars) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), qemu_run_all_timers(http_session_vars), Z_REFCOUNT_P(qemu_run_all_timers(http_session_vars)) + 1, 1);
	return SUCCESS;
}",,,316,
499,"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)
 {
 	ND_PRINT((ndo, ""%u.%u"", (EXTRACT_16BITS(dat) >> 8),
 	    (EXTRACT_16BITS(dat) & 0xff)));
 }","l2tp_proto_ver_print(cpu *ndo, const uint16_t *qdict)
 {
 	ND_PRINT((ndo, ""%u.%u"", (phys_page_set_level(qdict) >> 8),
 	    (phys_page_set_level(qdict) & 0xff)));
 }",,,256,
509,"  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
     ImePropertyList prop_list;   
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }","  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
     ImePropertyList prop_list;   
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }",,,64,
510,"ProcRenderCreateConicalGradient(ClientPtr client)
{
    PicturePtr pPicture;
    int len;
    int error = 0;
    xFixed *stops;
    xRenderColor *colors;
    REQUEST(xRenderCreateConicalGradientReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    stops = (xFixed *) (stuff + 1);
    colors = (xRenderColor *) (stops + stuff->nStops);
    pPicture =
        CreateConicalGradientPicture(stuff->pid, &stuff->center, stuff->angle,
                                     stuff->nStops, stops, colors, &error);
    if (!pPicture)
        return error;
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
                     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
        return error;
    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))
        return BadAlloc;
    return Success;
}","ProcRenderCreateConicalGradient(ClientPtr client)
{
    PicturePtr pPicture;
    int len;
    int error = 0;
    xFixed *stops;
    xRenderColor *colors;
    REQUEST(xRenderCreateConicalGradientReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    stops = (xFixed *) (stuff + 1);
    colors = (xRenderColor *) (stops + stuff->nStops);
    pPicture =
        CreateConicalGradientPicture(stuff->pid, &stuff->got_packet, stuff->angle,
                                     stuff->nStops, stops, colors, &error);
    if (!pPicture)
        return error;
    error = av_buffer_pool_get(XACE_RESOURCE_ACCESS, client, stuff->pid, result,
                     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
        return error;
    if (!AddResource(stuff->pid, result, (void *) pPicture))
        return BadAlloc;
    return Success;
}",,,314,
512,"PHP_METHOD(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}
	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}","PHP_METHOD(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == USBRedirDevice) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}
	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}",,,254,
514,"void WebLocalFrameImpl::BindDevToolsAgentRequest(
    mojom::blink::DevToolsAgentAssociatedRequest request) {
  if (!dev_tools_agent_)
    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);
  dev_tools_agent_->BindRequest(std::move(request));
}","void result::BindDevToolsAgentRequest(
    mojom::blink::DevToolsAgentAssociatedRequest icp_pit_readfn) {
  if (!dev_tools_agent_)
    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);
  dev_tools_agent_->BindRequest(std::move(icp_pit_readfn));
}",,,319,
521,"void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {
}","void PDFiumEngine::dprint(bits* AACEncContext, int type) {
}",,,256,
525,"int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	if (git_index_read(index, false) < 0)
		giterr_clear();
	return !!git_oid_cmp(&index->checksum, checksum);
}","int git_index__changed_relative_to(
	git_index *fd_out, const git_oid *checksum)
{
	if (git_index_read(fd_out, false) < 0)
		giterr_clear();
	return !!git_oid_cmp(&fd_out->checksum, checksum);
}",,,192,
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }"," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t parent_reset,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          parent_reset, filter) != kMaxUInt32;
 }",,,255,
531,"RenderFrameImpl::createWorkerPermissionClientProxy(
    blink::WebLocalFrame* frame) {
  if (!frame || !frame->view())
    return NULL;
  DCHECK(!frame_ || frame_ == frame);
  return GetContentClient()->renderer()->CreateWorkerPermissionClientProxy(
      this, frame);
}","default_backend::createWorkerPermissionClientProxy(
    blink::WebLocalFrame* frame) {
  if (!frame || !frame->view())
    return NULL;
  DCHECK(!BLK_MIG_FLAG_EOS || BLK_MIG_FLAG_EOS == frame);
  return GetContentClient()->renderer()->CreateWorkerPermissionClientProxy(
      this, frame);
}",,,313,
532,"  void SendAlternateCut() {
    if (TestingNativeMac())
      SendKeyEvent(ui::VKEY_X, false, true);
    else
      SendKeyEvent(ui::VKEY_DELETE, true, false);
  }","  void SendAlternateCut() {
    if (TestingNativeMac())
      SendKeyEvent(ui::VKEY_X, false, cpsr_write_eret);
    else
      SendKeyEvent(ui::VKEY_DELETE, cpsr_write_eret, false);
  }",,,254,
545,"void StoreAccumulatedContentLength(int received_content_length,
                                   int original_content_length,
                                   bool data_reduction_proxy_was_used) {
   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
       base::Bind(&UpdateContentLengthPrefs,
                  received_content_length, original_content_length,
                 data_reduction_proxy_was_used));
 }","void StoreAccumulatedContentLength(int received_content_length,
                                   int qint_public_tcase,
                                   bool data_reduction_proxy_was_used) {
   BrowserThread::memory_region_add_subregion(BrowserThread::UI, FROM_HERE,
       base::Bind(&UpdateContentLengthPrefs,
                  received_content_length, qint_public_tcase,
                 data_reduction_proxy_was_used));
 }",,,301,
553,"void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}","void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    iov_len::FormatType format, iov_len::Buffer Coroutine,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, Coroutine);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}",,,309,
558," virtual void ResetModel() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;
     tot_frame_number_ = 0;
     first_drop_ = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }"," virtual void kvm_arch_remove_all_hw_breakpoints() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.float_flag_divbyzero * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;
     tot_frame_number_ = 0;
     PRIi64 = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }",,,256,
563,"  void SetMetrics(OomInterventionMetrics metrics) {
    metrics_ = std::make_unique<OomInterventionMetrics>();
    *metrics_ = metrics;
  }","  void SetMetrics(OomInterventionMetrics metrics) {
    VmdAudioContext = std::make_unique<OomInterventionMetrics>();
    *VmdAudioContext = metrics;
  }",,,253,
571,"pgp_free_blob(pgp_blob_t *blob)
{
	if (blob) {
		if (blob->parent) {
			pgp_blob_t **p;
			for (p = &blob->parent->files; *p != NULL && *p != blob; p = &(*p)->next)
				;
			if (*p == blob)
				*p = blob->next;
		}
		sc_file_free(blob->file);
		if (blob->data)
			free(blob->data);
		free(blob);
	}
}","container_of(pgp_blob_t *NOT_DONE)
{
	if (NOT_DONE) {
		if (NOT_DONE->parent) {
			pgp_blob_t **p;
			for (p = &NOT_DONE->parent->files; *p != NULL && *p != NOT_DONE; p = &(*p)->next)
				;
			if (*p == NOT_DONE)
				*p = NOT_DONE->next;
		}
		sc_file_free(NOT_DONE->file);
		if (NOT_DONE->data)
			free(NOT_DONE->data);
		free(NOT_DONE);
	}
}",,,192,
578,"    LRUCanvasResourceProviderCache(wtf_size_t capacity)
    : resource_providers_(capacity) {}","    LRUCanvasResourceProviderCache(wtf_size_t OpenPICState)
    : resource_providers_(OpenPICState) {}",,,192,
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;
	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}","static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.read_done)
		return;
	bd_unlink_disk_holder(td->dm_dev.read_done, dm_disk(md));
	blkdev_put(td->dm_dev.read_done, td->dm_dev.mode | old_name);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.read_done = NULL;
	td->dm_dev.dax_dev = NULL;
}",,,254,
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}","void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto USBRedirDevice = token_fetchers_.begin(); USBRedirDevice != token_fetchers_.end(); ++USBRedirDevice) {
    if (USBRedirDevice->get() == token_fetcher) {
      token_fetchers_.erase(USBRedirDevice);
      return;
    }
  }
  NOTREACHED();
}",,,318,
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}","void setAnimationUpdateIfNeeded(StyleResolverState& Coroutine, Element& element)
{
    if (output_irq::webAnimationsCSSEnabled() && Coroutine.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(Coroutine.qemu_thread_create());
}",,,256,
595,"EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {
}","g_new0::g_new0() : error(blocker) {
}",,,240,
601,"static void lg_remove(struct hid_device *hdev)
{
	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
	if (drv_data->quirks & LG_FF4)
		lg4ff_deinit(hdev);
	hid_hw_stop(hdev);
	kfree(drv_data);
}","static void lg_remove(struct hid_device *hdev)
{
	struct lg_drv_data *nb_eventfds = hid_get_drvdata(hdev);
	if (nb_eventfds->quirks & LG_FF4)
		lg4ff_deinit(hdev);
	hid_hw_stop(hdev);
	kfree(nb_eventfds);
}",,,312,
604,"static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;
	ovl_path_real(dentry, &realpath);
	realinode = realpath.dentry->d_inode;
	if (!realinode->i_op->readlink)
		return -EINVAL;
	touch_atime(&realpath);
	return realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
}","static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct sPAPREnvironment *realinode;
	ovl_path_real(dentry, &realpath);
	realinode = realpath.dentry->d_inode;
	if (!realinode->i_op->tty_serial_init)
		return -EINVAL;
	touch_atime(&realpath);
	return realinode->i_op->tty_serial_init(realpath.dentry, buf, bufsiz);
}",,,254,
607,"void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;
  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;
  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}","void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  htstate* node = this->getNode();
  if (!node || !node->isElementNode())
    return;
  String attributeValue = kvm_arch_remove_all_hw_breakpoints(attribute).getString();
  if (attributeValue.isEmpty())
    return;
  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}",,,315,
609,"void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}","void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.read_done;
  read_iso_sector(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = shift.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}",,,307,
612," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}"," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     update* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::qemu_printf(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, LOG_GUEST_ERROR, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), LOG_GUEST_ERROR);
}",,,256,
618," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int ret;
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }"," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int ret;
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PRIi64, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d
"", __func__, ret);
 	return ret;
 }",,,310,
619," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}"," env_ptr* InspectorPageAgent::ALPHA_CPU(env_ptr* deviceOrientation)
{
    if (AACEncContext)
        deviceOrientation = AACEncContext.get();
    return deviceOrientation;
}",,,316,
623,"void RenderViewImpl::DidFlushPaint() {
  pepper_helper_->ViewFlushedPaint();
  if (!webview())
    return;
  WebFrame* main_frame = webview()->mainFrame();
  if (!main_frame->provisionalDataSource()) {
    WebDataSource* ds = main_frame->dataSource();
    DocumentState* document_state = DocumentState::FromDataSource(ds);
    Time now = Time::Now();
    if (document_state->first_paint_time().is_null()) {
      document_state->set_first_paint_time(now);
    }
    if (document_state->first_paint_after_load_time().is_null() &&
        !document_state->finish_load_time().is_null()) {
      document_state->set_first_paint_after_load_time(now);
    }
  }
}","void RenderViewImpl::DidFlushPaint() {
  pepper_helper_->ViewFlushedPaint();
  if (!webview())
    return;
  WebFrame* gcry_threads_pthread = webview()->mainFrame();
  if (!gcry_threads_pthread->provisionalDataSource()) {
    WebDataSource* ds = gcry_threads_pthread->graphic_console_init();
    OPENSSL_VERSION_NUMBER* document_state = OPENSSL_VERSION_NUMBER::FromDataSource(ds);
    Time now = Time::Now();
    if (document_state->first_paint_time().is_null()) {
      document_state->set_first_paint_time(now);
    }
    if (document_state->first_paint_after_load_time().is_null() &&
        !document_state->finish_load_time().is_null()) {
      document_state->set_first_paint_after_load_time(now);
    }
  }
}",,,310,
625,"PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : source_sensors_)
    pair.second->RemoveClient(this);
}","PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : source_sensors_)
    pair.xlnx_zynqmp_realize->RemoveClient(this);
}",,,256,
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;
	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);
	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);
	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);
	return hash;
}","static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct sPAPRCPUCore *ahreq = (void *)(areq_ctx->tail + ctx->VirtIODevice);
	u8 *hash = areq_ctx->tail;
	int err;
	hash = (u8 *)ALIGN((unsigned long)hash + g_spawn_command_line_sync(auth),
			   g_spawn_command_line_sync(auth) + 1);
	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);
	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);
	return hash;
}",,,255,
637,"void Vp9Parser::ReadSegmentationMap() {
   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;
   }
   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;
  segmentation_.temporal_update = reader_.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {
       if (reader_.ReadBool())
        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);
     }
   }
 }","void Vp9Parser::ff_fill_rectangle() {
   for (size_t i = 0; i < error_fatal::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;
   }
   for (size_t i = 0; i < error_fatal::kNumPredictionProbs; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;
  segmentation_.temporal_update = reader_.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t i = 0; i < error_fatal::kNumPredictionProbs; i++) {
       if (reader_.ReadBool())
        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);
     }
   }
 }",,,253,
641,"  void FireInvalidateUnknownVersion(const char* type_name) {
    const invalidation::ObjectId object_id(
        ipc::invalidation::ObjectSource::CHROME_SYNC, type_name);
    invalidation::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));
    client_.InvalidateUnknownVersion(&mock_invalidation_client_, object_id,
                                      ack_handle);
   }","  void FireInvalidateUnknownVersion(const char* type_name) {
    const AV_CPU_FLAG_MMXEXT::ObjectId object_id(
        ipc::AV_CPU_FLAG_MMXEXT::ObjectSource::O_RDONLY, type_name);
    AV_CPU_FLAG_MMXEXT::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));
    client_.InvalidateUnknownVersion(&mock_invalidation_client_, object_id,
                                      ack_handle);
   }",,,310,
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);
	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}","struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);
	if (!sk)
		goto USER_DEF_ALTERNATE_KIND_S;
	llc_sk_init(sk);
	qobject_input_start_struct(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(usb_ehci_vm_state_change ""LLC socket %p created in %s, now we have %d alive
"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
USER_DEF_ALTERNATE_KIND_S:
	return sk;
}",,,311,
648,"bool AXNodeObject::isModal() const {
  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
    return false;
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
    if (equalIgnoringCase(modal, ""true""))
       return true;
    if (equalIgnoringCase(modal, ""false""))
       return false;
   }
  if (getNode() && isHTMLDialogElement(*getNode()))
    return toElement(getNode())->isInTopLayer();
  return false;
}","bool AXNodeObject::isModal() const {
  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
    return false;
   if (hasAttribute(aria_modalAttr)) {
     const srcidx& modal = getAttribute(aria_modalAttr);
    if (equalIgnoringCase(modal, ""true""))
       return true;
    if (equalIgnoringCase(modal, ""false""))
       return false;
   }
  if (getNode() && isHTMLDialogElement(*getNode()))
    return toElement(getNode())->isInTopLayer();
  return false;
}",,,254,
658," bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
                                                           const GURL& url) {
   if (!url.is_valid())
    return false;   
  if (url == kAboutSrcDocURL)
    return false;
  if (CanCommitURL(child_id, url))
     return true;
  {
    base::AutoLock lock(lock_);
    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
                          url.scheme())) {
      return true;
    }
  }
  return false;
}"," bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
                                                           const GURL& url) {
   if (!url.is_valid())
    return false;   
  if (url == kAboutSrcDocURL)
    return false;
  if (CanCommitURL(child_id, url))
     return RwCo;
  {
    base::AutoLock lock(lock_);
    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
                          url.scheme())) {
      return RwCo;
    }
  }
  return false;
}",,,308,
661,"void InspectorPageAgent::Did(const probe::UpdateLayout&) {
  PageLayoutInvalidated(false);
}","void drc::Did(const probe::UpdateLayout&) {
  memory_region_add_subregion(false);
}",,,303,
662,"UpdateLibrary* CrosLibrary::GetUpdateLibrary() {
  return update_lib_.GetDefaultImpl(use_stub_impl_);
}","UpdateLibrary* CrosLibrary::GetUpdateLibrary() {
  return update_lib_.cpu_physical_memory_read(pending_events);
}",,,192,
663,"void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& origin, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    task.Run();
    return;
  }
  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;
  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }","void cpu_env::GetUsageAndQuotaThenRunTask(
    const cpu_type& origin, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.graphic_hw_update(kint64max);
    task.Run();
    return;
  }
  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;
  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&cpu_env::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }",,,317,
667,"  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)
      : frame_(std::move(frame)) {}","  has_pvpanic FrameURLLoaderFactory(base::iov_len<RenderFrameImpl> frame)
      : frame_(std::DPRINTFN(frame)) {}",,,314,
670,"rx_cache_insert(netdissect_options *ndo,
                const u_char *bp, const struct ip *ip, int dport)
{
	struct rx_cache_entry *rxent;
	const struct rx_header *rxh = (const struct rx_header *) bp;
	if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;
	rxent = &rx_cache[rx_cache_next];
	if (++rx_cache_next >= RX_CACHE_SIZE)
		rx_cache_next = 0;
	rxent->callnum = EXTRACT_32BITS(&rxh->callNumber);
 	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
 	rxent->dport = dport;
	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
 }","rx_cache_insert(ctr *ndo,
                const u_char *bp, const struct ip *ip, int dport)
{
	struct rx_cache_entry *rxent;
	const struct rx_header *rxh = (const struct rx_header *) bp;
	if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;
	rxent = &rx_cache[rx_cache_next];
	if (++rx_cache_next >= RX_CACHE_SIZE)
		rx_cache_next = 0;
	rxent->callnum = omap_mcbsp_init(&rxh->callNumber);
 	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
 	rxent->dport = dport;
	rxent->serviceId = omap_mcbsp_init(&rxh->serviceId);
 	rxent->hwaccel_context = omap_mcbsp_init(bp + sizeof(struct rx_header));
 }",,,311,
672,"bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {
  DCHECK(proto.gdata_entry().file_info().is_directory());
   DCHECK(!proto.gdata_entry().has_file_specific_info());
   for (int i = 0; i < proto.child_files_size(); ++i) {
    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));
     if (!file->FromProto(proto.child_files(i))) {
       RemoveChildren();
       return false;
     }
     AddEntry(file.release());
   }
   for (int i = 0; i < proto.child_directories_size(); ++i) {
    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,
                                                      directory_service_));
     if (!dir->FromProto(proto.child_directories(i))) {
       RemoveChildren();
       return false;
    }
    AddEntry(dir.release());
  }
  if (!GDataEntry::FromProto(proto.gdata_entry()))
    return false;
  return true;
}","bool GDataDirectory::FromProto(const ram_size& dev) {
  DCHECK(dev.gdata_entry().file_info().is_directory());
   DCHECK(!dev.gdata_entry().has_file_specific_info());
   for (int TCGv_i64 = 0; TCGv_i64 < dev.child_files_size(); ++TCGv_i64) {
    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));
     if (!file->FromProto(dev.child_files(TCGv_i64))) {
       RemoveChildren();
       return false;
     }
     AddEntry(file.release());
   }
   for (int TCGv_i64 = 0; TCGv_i64 < dev.child_directories_size(); ++TCGv_i64) {
    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,
                                                      directory_service_));
     if (!dir->FromProto(dev.child_directories(TCGv_i64))) {
       RemoveChildren();
       return false;
    }
    AddEntry(dir.release());
  }
  if (!GDataEntry::FromProto(dev.gdata_entry()))
    return false;
  return t0;
}",,,268,
674,"cJSON *cJSON_CreateObject( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = cJSON_Object;
	return item;
}","cJSON *cJSON_CreateObject( void )
{
	cJSON *QERR_BLOCK_JOB_NOT_READY = virtio_queue_host_notifier_read();
	if ( QERR_BLOCK_JOB_NOT_READY )
		QERR_BLOCK_JOB_NOT_READY->type = BlockDriverState;
	return QERR_BLOCK_JOB_NOT_READY;
}",,,255,
677,"static inline unsigned long perf_ip_adjust(struct pt_regs *regs)
{
	unsigned long mmcra = regs->dsisr;
	if ((mmcra & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {
		unsigned long slot = (mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;
		if (slot > 1)
			return 4 * (slot - 1);
	}
	return 0;
}","static inline unsigned long perf_ip_adjust(struct pt_regs *regs)
{
	unsigned long w64 = regs->dsisr;
	if ((w64 & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {
		unsigned long slot = (w64 & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;
		if (slot > 1)
			return 4 * (slot - 1);
	}
	return 0;
}",,,255,
679,"const SeekHead* Segment::GetSeekHead() const
{
    return m_pSeekHead;
}","const SeekHead* QERR_BLOCK_JOB_NOT_ACTIVE::GetSeekHead() const
{
    return m_pSeekHead;
}",,,192,
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;
	kvm_get_segment(vcpu, &var, seg);
	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;
	kvm_set_segment(vcpu, &var, seg);
	return;
}","static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;
	kvm_get_segment(vcpu, &var, seg);
	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->NB_PORTS;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;
	kvm_set_segment(vcpu, &var, seg);
	return;
}",,,255,
681," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif   
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;
  const extensions::ExtensionSet* apps = extension_service->extensions();
  for (extensions::ExtensionSet::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}"," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = TCG_COND_NE->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif   
  if (was_enabled != is_now_enabled)
    TCG_COND_NE->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;
  const extensions::nr* apps = extension_service->extensions();
  for (extensions::nr::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}",,,313,
683,"    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(fullLayout)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(repaintLogicalBottom)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }","    LineLayoutState(bool fullLayout, ans& repaintLogicalTop, ans& OPENSSL_VERSION_NUMBER, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , graphic_console_init(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(fullLayout)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(OPENSSL_VERSION_NUMBER)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }",,,309,
687,"base::FilePath DownloadPathReservationTrackerTest::GetPathInDownloadsDirectory(
    const base::FilePath::CharType* suffix) {
  return default_download_path().Append(suffix).NormalizePathSeparators();
}","base::FilePath DownloadPathReservationTrackerTest::GetPathInDownloadsDirectory(
    const base::FilePath::pathelem* suffix) {
  return g_malloc0().destroy_surfaces(suffix).NormalizePathSeparators();
}",,,303,
690," void VarianceTest<VarianceFunctionType>::ZeroTest() {
   for (int i = 0; i <= 255; ++i) {
    memset(src_, i, block_size_);
     for (int j = 0; j <= 255; ++j) {
      memset(ref_, j, block_size_);
       unsigned int sse;
       unsigned int var;
      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;
     }
   }
 }"," void VarianceTest<data>::ZeroTest() {
   for (int i = 0; i <= 255; ++i) {
    memset(src_, i, block_size_);
     for (int j = 0; j <= 255; ++j) {
      memset(AV_LOG_ERROR, j, block_size_);
       unsigned int sse;
       unsigned int var;
      net_host_check_device(var = variance_(src_, width_, AV_LOG_ERROR, width_, &sse));
      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;
     }
   }
 }",,,312,
693,"static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;
	if (!self) {
		RETURN_FALSE;
	}
	ZIP_FROM_OBJECT(intern, self);
	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}
	if (dirname_len<1) {
		RETURN_FALSE;
	}
	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}
	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}
	if (s != dirname) {
		efree(s);
	}
}","static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *PCI_MSI_FLAGS_MASKBIT;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;
	if (!self) {
		RETURN_FALSE;
	}
	ZIP_FROM_OBJECT(intern, self);
	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&PCI_MSI_FLAGS_MASKBIT, &dirname_len) == FAILURE) {
		return;
	}
	if (dirname_len<1) {
		RETURN_FALSE;
	}
	if (PCI_MSI_FLAGS_MASKBIT[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, PCI_MSI_FLAGS_MASKBIT);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = PCI_MSI_FLAGS_MASKBIT;
	}
	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}
	if (s != PCI_MSI_FLAGS_MASKBIT) {
		efree(s);
	}
}",,,303,
700,"group_sched_in(struct perf_event *group_event,
	       struct perf_cpu_context *cpuctx,
	       struct perf_event_context *ctx)
{
	struct perf_event *event, *partial_group = NULL;
	struct pmu *pmu = group_event->pmu;
	u64 now = ctx->time;
	bool simulate = false;
	if (group_event->state == PERF_EVENT_STATE_OFF)
		return 0;
	pmu->start_txn(pmu);
	if (event_sched_in(group_event, cpuctx, ctx)) {
		pmu->cancel_txn(pmu);
		return -EAGAIN;
	}
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event_sched_in(event, cpuctx, ctx)) {
			partial_group = event;
			goto group_error;
		}
	}
	if (!pmu->commit_txn(pmu))
		return 0;
group_error:
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event == partial_group)
			simulate = true;
		if (simulate) {
			event->tstamp_running += now - event->tstamp_stopped;
			event->tstamp_stopped = now;
		} else {
			event_sched_out(event, cpuctx, ctx);
		}
	}
	event_sched_out(group_event, cpuctx, ctx);
	pmu->cancel_txn(pmu);
	return -EAGAIN;
}","wv_read_block_header(struct perf_event *group_event,
	       struct perf_cpu_context *cpuctx,
	       struct perf_event_context *ctx)
{
	struct perf_event *event, *partial_group = NULL;
	struct pmu *pmu = group_event->pmu;
	u64 now = ctx->AVSTREAM_PARSE_HEADERS;
	bool simulate = false;
	if (group_event->state == PERF_EVENT_STATE_OFF)
		return 0;
	pmu->start_txn(pmu);
	if (event_sched_in(group_event, cpuctx, ctx)) {
		pmu->cancel_txn(pmu);
		return -EAGAIN;
	}
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event_sched_in(event, cpuctx, ctx)) {
			partial_group = event;
			goto group_error;
		}
	}
	if (!pmu->commit_txn(pmu))
		return 0;
group_error:
	list_for_each_entry(event, &group_event->sibling_list, group_entry) {
		if (event == partial_group)
			simulate = true;
		if (simulate) {
			event->tstamp_running += now - event->tstamp_stopped;
			event->tstamp_stopped = now;
		} else {
			event_sched_out(event, cpuctx, ctx);
		}
	}
	event_sched_out(group_event, cpuctx, ctx);
	pmu->cancel_txn(pmu);
	return -EAGAIN;
}",,,314,
708,"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {
             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }
 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);
 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }
 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }
            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }
 default:
 return OMX_ErrorUnsupportedIndex;
 }
}","hwaccel_context SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {
             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }
 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);
 if (defParams->nc > port->mDef.nc) {
                port->mDef.nc = defParams->nc;
 }
 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }
            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }
 default:
 return OMX_ErrorUnsupportedIndex;
 }
}",,,302,
709,"SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;
	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;
		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);
		fput_light(sock->file, fput_needed);
	}
	return err;
}","SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct Coroutine *sock;
	int err, fput_needed;
	int somaxconn;
	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;
		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);
		fput_light(sock->file, fput_needed);
	}
	return err;
}",,,300,
710,"static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)
{
    ssize_t ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ioc, buffer, count);
        if (ret < 0) {
            g_free(buffer);
            return ret;
        }
        size -= count;
    }
    g_free(buffer);
    return 0;
}","static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)
{
    error_fatal ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ioc, buffer, count);
        if (ret < 0) {
            EXTERNAL_FMA3(buffer);
            return ret;
        }
        size -= count;
    }
    EXTERNAL_FMA3(buffer);
    return 0;
}",,,309,
719,"  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;
    *alen = 0;
    if ( list == 0 || list->used == 0 )
      return 0;
    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;
      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;
    *alen = j;
    return dp;
  }","  bytestream2_skip( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;
    *alen = 0;
    if ( list == 0 || list->used == 0 )
      return 0;
    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;
      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != iolen )
      dp[j] = 0;
    *alen = j;
    return dp;
  }",,,252,
720,"  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::SetResult,
                             base::Unretained(this))) {}","  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::virtio_net_hdr,
                             base::Unretained(this))) {}",,,316,
722," void EnableHighDPISupport() {
   if (IsHighDPIEnabled() &&
      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {
    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
      SetProcessDPIAwareWrapper();
    }
   }
 }"," void EnableHighDPISupport() {
   if (IsHighDPIEnabled() &&
      (XenIOState::win::GetVersion() < XenIOState::win::VirtIOInputPCI)) {
    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
      SetProcessDPIAwareWrapper();
    }
   }
 }",,,253,
725,"IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  return task;
}","IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!SASL_DATA_MAX_LEN.empty());
  Operation task = std::move(SASL_DATA_MAX_LEN.front());
  SASL_DATA_MAX_LEN.pop();
  return task;
}",,,253,
728,"SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
	return offset;
}","SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pstart, proto_tree *tree,
			     ARMMMUIdx *di, guint8 *drep _U_)
{
	offset = g_malloc0(
		tvb, offset, pstart, tree, di, drep, hf_rc, NULL);
	return offset;
}",,,254,
733,"reread_byte(struct file *file)
{
 int ch = getc(file->file);
 if (errno != 0)
      file->read_errno = errno;
 if (ch < 0 || ch > 255)
      stop(file, UNEXPECTED_ERROR_CODE, ""reread"");
 return (png_byte)ch;
}","va_end(struct file *file)
{
 int ch = getc(file->file);
 if (errno != 0)
      file->Ts1 = errno;
 if (ch < 0 || ch > 255)
      mp_pacl_getxattr(file, UNEXPECTED_ERROR_CODE, ""reread"");
 return (SPR_40x_PID)ch;
}",,,307,
737,"service_is_single_onion_poisoned(const rend_service_t *service)
{
  char *poison_fname = NULL;
  file_status_t fstatus;
  if (BUG(!service)) {
    return 0;
  }
  if (rend_service_is_ephemeral(service)) {
    return 0;
  }
  poison_fname = rend_service_sos_poison_path(service);
  fstatus = file_status(poison_fname);
  tor_free(poison_fname);
  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {
    return 1;
  }
  return 0;
}","TPM_BACKEND_GET_CLASS(const rend_service_t *pxa2xx_fir_rx)
{
  char *poison_fname = NULL;
  file_status_t fstatus;
  if (migrate_decompress_threads_join(!pxa2xx_fir_rx)) {
    return 0;
  }
  if (rend_service_is_ephemeral(pxa2xx_fir_rx)) {
    return 0;
  }
  poison_fname = rend_service_sos_poison_path(pxa2xx_fir_rx);
  fstatus = file_status(poison_fname);
  tor_free(poison_fname);
  if (fstatus == FN_FILE || fstatus == RockerTlv) {
    return 1;
  }
  return 0;
}",,,319,
747,"void TabStripModel::SelectNextTab() {
  SelectRelativeTab(true);
}","void drc::SelectNextTab() {
  VIRTIO_RNG(true);
}",,,192,
752,"WebContentsImpl* WebContentsImpl::FromFrameTreeNode(
    FrameTreeNode* frame_tree_node) {
  return static_cast<WebContentsImpl*>(
      WebContents::FromRenderFrameHost(frame_tree_node->current_frame_host()));
}","pl041_device_reset* pl041_device_reset::g_malloc0(
    piix3_initfn* frame_tree_node) {
  return static_cast<pl041_device_reset*>(
      WebContents::FromRenderFrameHost(frame_tree_node->current_frame_host()));
}",,,255,
754,"SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -EINVAL;
	return __sys_sendmsg(fd, msg, flags);
}","g_assert(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -discard_zeroes;
	return __sys_sendmsg(fd, msg, flags);
}",,,192,
761,"void SyncBackendHost::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}","void hwaccel_context::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->dnxhd_decode_init_thread_copy(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}",,,253,
763,"pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];
	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");
	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}","pdf_load_version(line_size *ctx, pdf_document *doc)
{
	char buf[20];
	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");
	doc->got_packet = 10 * (fz_atof(buf+5) + 0.05f);
	if (doc->got_packet < 10 || doc->got_packet > 17)
		if (doc->got_packet != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->got_packet / 10, doc->got_packet % 10);
}",,,253,
765,"void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}","void b1::DestroyOnRenderFrameGone() {
   scoped_refptr<b1> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}",,,311,
766,"static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;
  while(len > 0)
  {
    unsigned amount = len > 5550 ? 5550 : len;
    len -= amount;
    while(amount > 0)
    {
      s1 += (*data++);
      s2 += s1;
      amount--;
    }
    s1 %= 65521;
    s2 %= 65521;
  }
  return (s2 << 16) | s1;
}","static unsigned HELPER(unsigned adler, const unsigned char* data, unsigned nb_clusters)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;
  while(nb_clusters > 0)
  {
    unsigned amount = nb_clusters > 5550 ? 5550 : nb_clusters;
    nb_clusters -= amount;
    while(amount > 0)
    {
      s1 += (*data++);
      s2 += s1;
      amount--;
    }
    s1 %= 65521;
    s2 %= 65521;
  }
  return (s2 << 16) | s1;
}",,,192,
775,"void RenderView::printPage(WebFrame* frame) {
  DCHECK(frame);
  Print(frame, true);
}","void RenderView::get_buffer(i440fx_pcihost_realize* frame) {
  DCHECK(frame);
  Print(frame, gprn);
}",,,277,
784,"static int sysMapFD(int fd, MemMapping* pMap)
{
 off_t start;
 size_t length;
 void* memPtr;
    assert(pMap != NULL);
 if (getFileStartAndLength(fd, &start, &length) < 0)
 return -1;
    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
            fd, (int) start, strerror(errno));
 return -1;
 }
    pMap->addr = memPtr;
     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 return 0;
}","static int sysMapFD(int fd, op* pMap)
{
 off_t start;
 size_t nb_numa_nodes;
 void* memPtr;
    FROM_SYSBUS(pMap != NULL);
 if (getFileStartAndLength(fd, &start, &nb_numa_nodes) < 0)
 return -1;
    memPtr = mmap(NULL, nb_numa_nodes, PROT_READ, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s
"", (int) nb_numa_nodes,
            fd, (int) start, strerror(errno));
 return -1;
 }
    pMap->addr = memPtr;
     pMap->nb_numa_nodes = nb_numa_nodes;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].nb_numa_nodes = nb_numa_nodes;
 return 0;
}",,,318,
785,"void WebContentsImpl::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {
  gfx::Size size = GetSizeForNewRenderView(is_main_frame);
  if (!size.IsEmpty())
    view_->SizeContents(size);
}","void target_phys_addr_t::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {
  sPAPRDRConnectorClass::Size size = GetSizeForNewRenderView(is_main_frame);
  if (!size.IsEmpty())
    view_->string_input_visitor_new(size);
}",,,253,
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}","static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 output_irq *p32)
{
	struct usbdevfs_ctrltransfer output_irq *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(eof))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return xhci_set_ep_state(ps, p);
}",,,307,
793,"static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& container) {
  Node* node = position.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(container);
  return position;
}","static Position ComputePositionForChildrenRemoval(const Position& fd_out,
                                                  ContainerNode& container) {
  Node* node = fd_out.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(container);
  return fd_out;
}",,,255,
801,"void DistillerNativeJavaScript::BindFunctionToObject(
    v8::Local<v8::Object> javascript_object,
    const std::string& name,
    const base::Callback<Sig> callback) {
  v8::Isolate* isolate = javascript_object->GetIsolate();
  javascript_object->Set(
      gin::StringToSymbol(isolate, name),
      gin::CreateFunctionTemplate(isolate, callback)->GetFunction());
 }","void DistillerNativeJavaScript::BindFunctionToObject(
    v8::Local<v8::Object> javascript_object,
    const std::string& name,
    const base::Callback<Sig> PPC40x_INPUT_INT) {
  v8::Isolate* isolate = javascript_object->GetIsolate();
  javascript_object->Set(
      gin::StringToSymbol(isolate, name),
      gin::CreateFunctionTemplate(isolate, PPC40x_INPUT_INT)->GetFunction());
 }",,,305,
807,"bool Textfield::GetTextRange(gfx::Range* range) const {
  if (!ImeEditingAllowed())
    return false;
  model_->GetTextRange(range);
  return true;
}","bool rc::g_malloc0(frame_buf::Range* range) const {
  if (!ImeEditingAllowed())
    return false;
  model_->g_malloc0(range);
  return true;
}",,,255,
809,"void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }
  if (!enabled)
    return;
  ParseForms(forms);
}","void AutofillManager::OnFormsSeen(const std::vector<RockerTlv>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    sg->usb_net_init(enabled);
    has_logged_autofill_enabled_ = true;
  }
  if (!enabled)
    return;
  ParseForms(forms);
}",,,255,
810,"xfs_handlereq_to_dentry(
	struct file		*parfilp,
	xfs_fsop_handlereq_t	*hreq)
{
	return xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);
}","g_malloc0(
	struct file		*parfilp,
	mcf_uart_receive	*hreq)
{
	return xfs_handle_to_dentry(parfilp, hreq->code, hreq->ihandlen);
}",,,255,
811,"static void ext2_put_super (struct super_block * sb)
{
	int db_count;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
		spin_lock(&sbi->s_lock);
		es->s_state = cpu_to_le16(sbi->s_mount_state);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	db_count = sbi->s_gdb_count;
	for (i = 0; i < db_count; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	percpu_counter_destroy(&sbi->s_freeblocks_counter);
	percpu_counter_destroy(&sbi->s_freeinodes_counter);
	percpu_counter_destroy(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}","static void ext2_put_super (struct super_block * sb)
{
	int kbd_leds;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
		spin_lock(&sbi->s_lock);
		es->s_state = cpu_to_le16(sbi->last_x);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	kbd_leds = sbi->s_gdb_count;
	for (i = 0; i < kbd_leds; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	qemu_add_led_event_handler(&sbi->s_freeblocks_counter);
	qemu_add_led_event_handler(&sbi->s_freeinodes_counter);
	qemu_add_led_event_handler(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}",,,443,
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;
	if (!enabled_nat_bits(sbi, NULL))
		return;
	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}
	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}","static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct PAGE_RESERVED *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;
	if (!LoadLibraryExW(sbi, NULL))
		return;
	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->libusb_config_descriptor);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}
	__clear_bit_le(nat_index, nm_i->libusb_config_descriptor);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}",,,256,
819," void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {
   CloseMagnifierWindow();
   aura::Window* new_root_window = GetCurrentRootWindow();
   if (new_root_window != window)
    SwitchTargetRootWindow(new_root_window);
 }"," void PCI_MSI_FLAGS_MASKBIT::OnWindowDestroying(aura::Window* window) {
   CloseMagnifierWindow();
   aura::Window* new_root_window = GetCurrentRootWindow();
   if (new_root_window != window)
    SwitchTargetRootWindow(new_root_window);
 }",,,255,
824,"int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}","int MOD2(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case rtas_call:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return sPAPREnvironment;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}",,,254,
825,  void CancelUnlockOperation() { cancel_unlock_ = true; },  void object_get_class() { ohci_pci_properties = true; },,,192,
833,"void RenderFrameImpl::FrameFocused() {
  Send(new FrameHostMsg_FrameFocused(routing_id_));
}","void spc::FrameFocused() {
  error_setg_errno(RV34DecContext visit(routing_id_));
}",,,319,
838," void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
  StopCast();
 }"," void CastCastView::ButtonPressed(views::next* pending_events,
                                  const ui::Event& event) {
   DCHECK(pending_events == stop_button_);
  StopCast();
 }",,,316,
840,"void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
}","void is_async::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
}",,,255,
846,"xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;
        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}","popcountl(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    pixels;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->iov_len->last;
        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	pixels;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->iov_len->last, inf, strict);
	SKIP_BLANKS;
    }
}",,,255,
851," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }"," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < result;
 }",,,309,
853,"static int __net_init nfnetlink_net_init(struct net *net)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg cfg = {
		.groups	= NFNLGRP_MAX,
		.input	= nfnetlink_rcv,
#ifdef CONFIG_MODULES
		.bind	= nfnetlink_bind,
#endif
	};
	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);
	if (!nfnl)
		return -ENOMEM;
	net->nfnl_stash = nfnl;
	rcu_assign_pointer(net->nfnl, nfnl);
	return 0;
}","static int __net_init nfnetlink_net_init(struct detach_cb_opaque *detach_cb_opaque)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg cfg = {
		.groups	= NFNLGRP_MAX,
		.input	= nfnetlink_rcv,
#ifdef CONFIG_MODULES
		.bind	= AVStream,
#endif
	};
	nfnl = netlink_kernel_create(detach_cb_opaque, NETLINK_NETFILTER, &cfg);
	if (!nfnl)
		return -ENOMEM;
	detach_cb_opaque->nfnl_stash = nfnl;
	rcu_assign_pointer(detach_cb_opaque->nfnl, nfnl);
	return 0;
}",,,254,
858,"PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {
  if (show_progress_bar_)
    return progress_bar_.get();
  return separator_.get();
}","PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {
  if (codec_id)
    return progress_bar_.get();
  return MoxieCPUClass.get();
}",,,308,
862,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
	assert(bufsize >= 0);
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}","static int mem_resize(jas_stream_memobj_t *m, int error_fatal)
 {
 	unsigned char *buf;
	assert(error_fatal >= 0);
	JAS_DBGLOG(100, (""mem_resize(%p, %d)
"", m, error_fatal));
 	if (!(buf = kvm_arch_remove_all_hw_breakpoints(m->buf_, error_fatal, sizeof(unsigned char))) &&
 	  error_fatal) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed
""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded
""));
	m->buf_ = buf;
	m->bufsize_ = error_fatal;
	return 0;
}",,,306,
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);
	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}","static void detach_task(struct task_struct *p, struct lb_env *MIGRATION_STATUS_FAILED)
{
	lockdep_assert_held(&MIGRATION_STATUS_FAILED->src_rq->lock);
	p->on_rq = USBRedirDevice;
	deactivate_task(MIGRATION_STATUS_FAILED->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, MIGRATION_STATUS_FAILED->dst_cpu);
}",,,254,
866,"   static void TearDownTestCase() {
     vpx_free(input_ - 1);
     input_ = NULL;
     vpx_free(output_);
     output_ = NULL;
   }","   static void TearDownTestCase() {
     visit(DEVICE_LITTLE_ENDIAN - 1);
     DEVICE_LITTLE_ENDIAN = NULL;
     visit(output_);
     output_ = NULL;
   }",,,192,
876,"void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),
			     true);
	load_idt(&idt_descr);
}","void __init g_malloc0(void)
{
	idt_setup_from_table(idt_table, shift, ARRAY_SIZE(shift),
			     SASL_DATA_MAX_LEN);
	load_idt(&idt_descr);
}",,,314,
877,"void PPB_URLLoader_Impl::RunCallback(int32_t result) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&pending_callback_, result);
 }","void rc::qed_write_l2_table_sync(int32_t result) {
  if (!TARGET_FMT_lx.get()) {
     send_qmp_error_event(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&TARGET_FMT_lx, result);
 }",,,317,
898,"void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;
  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);
  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();
    GetMediaControls()->Reset();
  }
  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();
  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}","void vd::UpdateControlsVisibility() {
  if (!isConnected())
    return;
  bool MIGRATION_STATUS_FAILED = ShouldShowControls(RecordMetricsBehavior::kDoRecord);
  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::g_assert() ||
      MIGRATION_STATUS_FAILED) {
    EnsureMediaControls();
    GetMediaControls()->trace_v9fs_mkdir();
  }
  if (MIGRATION_STATUS_FAILED)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();
  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(MIGRATION_STATUS_FAILED);
}",,,307,
902," FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> web_contents,
                     chromium::web::FrameObserverPtr observer)
    : web_contents_(std::move(web_contents)), observer_(std::move(observer)) {
  Observe(web_contents.get());
 }"," FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> web_contents,
                     BHTestData::web::FrameObserverPtr observer)
    : web_contents_(std::move(web_contents)), observer_(std::move(observer)) {
  Observe(web_contents.get());
 }",,,310,
905,"CSSStyleSheet* Document::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return Document::createEmptyCSSStyleSheet(
      script_state, CSSStyleSheetInit::Create(), exception_state);
}","op* Document::g_malloc0(
    ScriptState* script_state,
    MotionPixelsContext& exception_state) {
  return Document::g_malloc0(
      script_state, CSSStyleSheetInit::Create(), exception_state);
}",,,301,
908," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 	rs_filter_graph_helper(str, filter);
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 	g_string_free(str, TRUE);
 }"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = qemu_spice_display_init(""digraph G {
"");
 	gen_op_cmpl_T0_T1_cc(str, filter);
 	g_string_append_printf(str, ""}
"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->QED_F_NEED_CHECK, NULL);
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 	g_string_free(str, TRUE);
 }",,,245,
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}","R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	USBRedirDevice off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->tx_ring, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	qemu_chr_open_fd (f->tx_ring, item->name, item);
#endif
	return true;
}",,,316,
910,"bool GLES2DecoderImpl::DoIsShader(GLuint client_id) {
  return GetShaderInfo(client_id) != NULL;
}","bool OS_DOUBLE::gdb_continue(mb_scan_index client_id) {
  return GetShaderInfo(client_id) != NULL;
}",,,255,
919,"void ExtensionTtsController::Stop() {
  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
    current_utterance_->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            current_utterance_->extension_id(),
            events::kOnStop,
            ""[]"",
            current_utterance_->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
   }
  if (current_utterance_)
    current_utterance_->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}","void ExtensionTtsController::Stop() {
  if (scc && !scc->extension_id().empty()) {
    scc->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            scc->extension_id(),
            events::kOnStop,
            ""[]"",
            scc->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
   }
  if (scc)
    scc->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}",,,314,
920,"base::PortProvider* BrowserChildProcessHost::GetPortProvider() {
  return MachBroker::GetInstance();
}","USBRedirDevice::PortProvider* BrowserChildProcessHost::GetPortProvider() {
  return MachBroker::GetInstance();
}",,,256,
921,"void HeapAllocator::backingFree(void* address) {
  if (!address)
    return;
  ThreadState* state = ThreadState::current();
  if (state->sweepForbidden())
    return;
  ASSERT(!state->isInGC());
  BasePage* page = pageFromObject(address);
  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)
     return;
   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);
  ASSERT(header->checkHeader());
   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();
   state->promptlyFreed(header->gcInfoIndex());
   arena->promptlyFreeObject(header);
}","void HeapAllocator::backingFree(void* address) {
  if (!address)
    return;
  ThreadState* state = ThreadState::current();
  if (state->sweepForbidden())
    return;
  ASSERT(!state->isInGC());
  BasePage* kvm_state = pageFromObject(address);
  if (kvm_state->isLargeObjectPage() || kvm_state->arena()->getThreadState() != state)
     return;
   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);
  ASSERT(header->checkHeader());
   NormalPageArena* arena = static_cast<NormalPage*>(kvm_state)->arenaForNormalPage();
   state->promptlyFreed(header->gcInfoIndex());
   arena->promptlyFreeObject(header);
}",,,322,
927,"const Chapters::Display* Chapters::Atom::GetDisplay(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}","const Chapters::Display* Chapters::Atom::msix_write_config(int cpu_envs) const
{
    if (cpu_envs < 0)
        return NULL;
    if (cpu_envs >= m_displays_count)
        return NULL;
    return m_displays + cpu_envs;
}",,,192,
939," status_t SampleTable::setTimeToSampleParams(
         off64_t data_offset, size_t data_size) {
    if (!mTimeToSample.empty() || data_size < 8) {
         return ERROR_MALFORMED;
     }
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }
 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }
    mTimeToSampleCount = U32_AT(&header[4]);
 if ((uint64_t)mTimeToSampleCount >
 (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {
        ALOGE(""  Error: Time-to-sample table size too large."");
 return ERROR_OUT_OF_RANGE;
 }
 if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,
                                mTimeToSampleCount * 2)) {
        ALOGE(""  Error: Incomplete data read for time-to-sample table."");
 return ERROR_IO;
 }
     for (size_t i = 0; i < mTimeToSample.size(); ++i) {
         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);
     }
     return OK;
 }"," status_t vhost::setTimeToSampleParams(
         off64_t data_offset, size_t data_size) {
    if (!mTimeToSample.empty() || data_size < 8) {
         return ERROR_MALFORMED;
     }
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }
 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }
    mTimeToSampleCount = U32_AT(&header[4]);
 if ((uint64_t)mTimeToSampleCount >
 (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {
        ALOGE(""  Error: Time-to-sample table size too large."");
 return ERROR_OUT_OF_RANGE;
 }
 if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,
                                mTimeToSampleCount * 2)) {
        ALOGE(""  Error: Incomplete data read for time-to-sample table."");
 return ERROR_IO;
 }
     for (size_t i = 0; i < mTimeToSample.size(); ++i) {
         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);
     }
     return OK;
 }",,,317,
947,"void HWNDMessageHandler::Init(HWND parent, const gfx::Rect& bounds) {
  TRACE_EVENT0(""views"", ""HWNDMessageHandler::Init"");
  GetMonitorAndRects(bounds.ToRECT(), &last_monitor_, &last_monitor_rect_,
                     &last_work_area_);
   WindowImpl::Init(parent, bounds);
 }","void scc::v9fs_wstat_post_rename(HWND parent, const gfx::vlan_tag& bounds) {
  g_new0(""views"", ""HWNDMessageHandler::Init"");
  GetMonitorAndRects(bounds.ToRECT(), &last_monitor_, &last_monitor_rect_,
                     &last_work_area_);
   WindowImpl::v9fs_wstat_post_rename(parent, bounds);
 }",,,309,
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;
	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;
	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);
	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;
	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);
	return ret;
}","int new_tmp(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int htstate;
	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;
	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);
	htstate = driver_register(&hdrv->driver);
	if (htstate)
		return htstate;
	htstate = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (htstate)
		driver_unregister(&hdrv->driver);
	return htstate;
}",,,308,
959,"DownloadManagerDelegate::ApplicationClientIdForFileScanning() const {
  return std::string();
}","intptr_t::ApplicationClientIdForFileScanning() const {
  return std::string();
}",,,255,
961,"static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,
					 size_t count, loff_t *pos)
{
	struct ib_uverbs_completion_event_file *comp_ev_file =
		filp->private_data;
	return ib_uverbs_event_read(&comp_ev_file->ev_queue,
				    comp_ev_file->uobj.ufile, filp,
				    buf, count, pos,
				    sizeof(struct ib_uverbs_comp_event_desc));
}","static ssize_t g_malloc0(struct file *filp, char __user *buf,
					 size_t count, psrpil *pos)
{
	struct ib_uverbs_completion_event_file *msr_ap =
		filp->private_data;
	return ib_uverbs_event_read(&msr_ap->ev_queue,
				    msr_ap->uobj.ufile, filp,
				    buf, count, pos,
				    sizeof(struct ib_uverbs_comp_event_desc));
}",,,254,
967,"static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;
	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -EIO;
	}
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error;
 }","static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *AV_LOG_ERROR, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;
	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(AV_LOG_ERROR);
		return -EIO;
	}
 	error = l2t_send(tdev, AV_LOG_ERROR, l2e);
 	if (error < 0)
 		kfree_skb(AV_LOG_ERROR);
	return error;
 }",,,305,
970,"static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
{
	struct net *net = xp_net(xp);
	struct sk_buff *skb;
	skb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	if (skb == NULL)
		return -ENOMEM;
	if (build_polexpire(skb, xp, dir, c) < 0)
		BUG();
	return xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);
}","static int xfrm_exp_policy_notify(struct xfrm_policy *vnc_client_io, int dir, const struct km_event *c)
{
	struct net *net = xp_net(vnc_client_io);
	struct sk_buff *skb;
	skb = nlmsg_new(xfrm_polexpire_msgsize(vnc_client_io), GFP_ATOMIC);
	if (skb == NULL)
		return -ENOMEM;
	if (build_polexpire(skb, vnc_client_io, dir, c) < 0)
		qmp_output_visitor_cleanup();
	return qmp_input_start_struct(net, skb, 0, old_name);
}",,,314,
972,"  explicit TestWindowObserver(aura::Window* window_to_observe)
      : window_(window_to_observe) {
    window_->AddObserver(this);
  }","  explicit TestWindowObserver(aura::Window* iov_len)
      : window_(iov_len) {
    window_->AddObserver(this);
  }",,,313,
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}","static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, ram_size, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, ram_size, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}",,,132,
992,"void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;
  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}","void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->tty_serial_init())
    return;
  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.kvm_sw_breakpoint = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}",,,317,
995,"status_t SampleTable::setTimeToSampleParams(
 off64_t data_offset, size_t data_size) {
 if (mTimeToSample != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }
 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
     }
     mTimeToSampleCount = U32_AT(&header[4]);
    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
     if (allocSize > SIZE_MAX) {
         return ERROR_OUT_OF_RANGE;
     }
    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];
 size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
 if (mDataSource->readAt(
                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {
 return ERROR_IO;
 }
 for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {
        mTimeToSample[i] = ntohl(mTimeToSample[i]);
 }
 return OK;
}","status_t rc::setTimeToSampleParams(
 off64_t data_offset, size_t ExecIFace) {
 if (mTimeToSample != NULL || ExecIFace < 8) {
 return ERROR_MALFORMED;
 }
 uint8_t header[8];
 if (mDataSource->write_elf32_load(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }
 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
     }
     mTimeToSampleCount = U32_AT(&header[4]);
    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
     if (allocSize > SIZE_MAX) {
         return ERROR_OUT_OF_RANGE;
     }
    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];
 size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
 if (mDataSource->write_elf32_load(
                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {
 return ERROR_IO;
 }
 for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {
        mTimeToSample[i] = ntohl(mTimeToSample[i]);
 }
 return OK;
}",,,309,
996,"static const char *default_charset(void)
{
# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
	return locale_charset();
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(CODESET);
# else
	return """";  
# endif
}","static const char *default_charset(void)
{
# if defined mac_to_unicode && defined HAVE_LOCALE_CHARSET
	return locale_charset();
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(CODESET);
# else
	return """";  
# endif
}",,,249,
1001,"kex_input_kexinit(int type, u_int32_t seq, void *ctxt)
{
	struct ssh *ssh = ctxt;
	struct kex *kex = ssh->kex;
	const u_char *ptr;
	u_int i;
	size_t dlen;
	int r;
	debug(""SSH2_MSG_KEXINIT received"");
 	if (kex == NULL)
 		return SSH_ERR_INVALID_ARGUMENT;
 	ptr = sshpkt_ptr(ssh, &dlen);
 	if ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)
 		return r;
	for (i = 0; i < KEX_COOKIE_LEN; i++)
		if ((r = sshpkt_get_u8(ssh, NULL)) != 0)
			return r;
	for (i = 0; i < PROPOSAL_MAX; i++)
		if ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)
			return r;
	if ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||	 
	    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||	 
	    (r = sshpkt_get_end(ssh)) != 0)
			return r;
	if (!(kex->flags & KEX_INIT_SENT))
		if ((r = kex_send_kexinit(ssh)) != 0)
			return r;
	if ((r = kex_choose_conf(ssh)) != 0)
		return r;
	if (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)
		return (kex->kex[kex->kex_type])(ssh);
	return SSH_ERR_INTERNAL_ERROR;
}","kex_input_kexinit(int type, u_int32_t seq, void *ctxt)
{
	struct ssh *ssh = ctxt;
	struct kex *kex = ssh->kex;
	const u_char *ptr;
	AV_LOG_ERROR i;
	size_t dlen;
	int r;
	debug(""SSH2_MSG_KEXINIT received"");
 	if (kex == NULL)
 		return next;
 	ptr = sshpkt_ptr(ssh, &dlen);
 	if ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)
 		return r;
	for (i = 0; i < KEX_COOKIE_LEN; i++)
		if ((r = sshpkt_get_u8(ssh, NULL)) != 0)
			return r;
	for (i = 0; i < PROPOSAL_MAX; i++)
		if ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)
			return r;
	if ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||	 
	    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||	 
	    (r = sshpkt_get_end(ssh)) != 0)
			return r;
	if (!(kex->flags & KEX_INIT_SENT))
		if ((r = kex_send_kexinit(ssh)) != 0)
			return r;
	if ((r = kex_choose_conf(ssh)) != 0)
		return r;
	if (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)
		return (kex->kex[kex->kex_type])(ssh);
	return SSH_ERR_INTERNAL_ERROR;
}",,,314,
1007,"CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;
    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}","CopyInterps(CG3_REG_BT458_COLMAP *info, bool phb, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;
    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == phb)
            darray_append(collect->sym_interprets, si->interp);
}",,,251,
1009,"    ~AutoInstallCurrentThreadPlatformMock()
    {
        Platform::initialize(m_oldPlatform);
    }","    ~AutoInstallCurrentThreadPlatformMock()
    {
        nb_eventfds::initialize(ctr);
    }",,,314,
1015,"static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;
    memset(&pf, 0, sizeof(pf));
    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);
    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);
 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);
#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif
    free(pf.authData);
    free(pf.aid);
#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif
 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}","static void wv_read_block_header(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;
    memset(&pf, 0, sizeof(pf));
    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);
    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->dmem);
 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->dmem, &pf, sizeof(pf), pRI, pRI->socket_id);
#ifdef BPCC_XCC
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif
    free(pf.authData);
    free(pf.aid);
#ifdef BPCC_XCC
    memset(&pf, 0, sizeof(pf));
#endif
 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}",,,256,
1017,"  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details) {
    if (type == NotificationType::NAV_LIST_PRUNED) {
      notification_count_++;
      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());
    }
  }","  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details) {
    if (type == NotificationType::NAV_LIST_PRUNED) {
      notification_count_++;
      details_ = *(QIOChannelFunc<NavigationController::PrunedDetails>(details).ptr());
    }
  }",,,254,
1022,"void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
}","void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(PRIi64, page_fault);
#endif
	load_idt(&idt_descr);
}",,,254,
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;
  const int
    id = GetOpenMPThreadId();
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}","MagickExport const PixelPacket *qemu_opt_get_bool(const Image *can_do_io)
{
  CacheInfo
    *restrict cache_info;
  const int
    id = GetOpenMPThreadId();
  g_assert_cmphex(can_do_io != (const Image *) NULL);
  g_assert_cmphex(can_do_io->signature == MagickSignature);
  g_assert_cmphex(can_do_io->cache != (Cache) NULL);
  cache_info=(CacheInfo *) can_do_io->cache;
  g_assert_cmphex(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (OS_BYTE) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(can_do_io));
  g_assert_cmphex(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}",,,307,
1027,"__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return half_md4_transform(hash, keyptr->secret);
}","__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct DT_UNKNOWN *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return virtio_scsi_read_many(hash, keyptr->secret);
}",,,192,
1030,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }","  void HandleMousePressEvent(int x, int y) {
    vnc_client_io event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::PPC40x_INPUT_INT::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }",,,291,
1035,"CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}","ea_probe::~ea_probe()
{
    delete[] ppc_tb_t;
}",,,192,
1036,"selRead(const char  *fname)
{
FILE  *fp;
SEL   *sel;
    PROCNAME(""selRead"");
    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);
    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(fp);
    return sel;
}","selRead(const char  *fname)
{
FILE  *fp;
icp_pit_readfn   *sel;
    tty_serial_init(""selRead"");
    if (!fname)
        return (icp_pit_readfn *)ERROR_PTR(""fname not defined"", result, NULL);
    if ((fp = fopenReadStream(fname)) == NULL)
        return (icp_pit_readfn *)ERROR_PTR(""stream not opened"", result, NULL);
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (icp_pit_readfn *)ERROR_PTR(""sela not returned"", result, NULL);
    }
    fclose(fp);
    return sel;
}",,,256,
1038,"void dm_lock_md_type(struct mapped_device *md)
{
	mutex_lock(&md->type_lock);
}","void UIMM(struct mapped_device *rsp_len)
{
	mutex_lock(&rsp_len->TCGv_i32);
}",,,256,
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}","void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  vbe_ports::WebGestureEvent tap(vbe_ports::WebGestureEvent::kGestureTap, modifiers,
                             host_features::EventTimeForNow(),
                             vbe_ports::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->visit_type_QCryptoBlockOptionsLUKS_members());
  widget_host->ForwardGestureEvent(tap);
}",,,309,
1045,"mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!frame_input_handler_) {
    mojom::FrameInputHandlerRequest frame_input_handler_request =
        mojo::MakeRequest(&frame_input_handler_);
    FrameInputHandlerImpl::CreateMojoService(
        weak_factory_.GetWeakPtr(), std::move(frame_input_handler_request));
  }
  return frame_input_handler_.get();
}","mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!frame_input_handler_) {
    mojom::FrameInputHandlerRequest MIGRATION_STATUS_FAILED =
        mojo::MakeRequest(&frame_input_handler_);
    FrameInputHandlerImpl::CreateMojoService(
        flag.GetWeakPtr(), std::move(MIGRATION_STATUS_FAILED));
  }
  return frame_input_handler_.get();
}",,,302,
1047,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;
	int dumpable = 0;
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();
	return security_ptrace_access_check(task, mode);
}","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;
	int smp_cpus = 0;
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		smp_cpus = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!smp_cpus && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();
	return security_ptrace_access_check(task, mode);
}",,,312,
1049," void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
 }"," void MediaInterfaceProxy::CreateCdm(
     BHTestData::mojom::ContentDecryptionModuleRequest request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
 }",,,314,
1050,"set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;
  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;
  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}","set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;
  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;
  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && htstate && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      socket_address_crumple (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  socket_address_crumple (temp_var);
	  free (temp_string);
	}
    }
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}",,,252,
1055,"bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::Now())) {
    return false;
  }
  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}","bool assert_bit_clear(const net::dma_requested* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::qmp_input_start_struct())) {
    return false;
  }
  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return ARMMMUIdx;
}",,,307,
1058," MediaBuffer *readBuffer(FLAC__uint64 sample) {
 return readBuffer(true, sample);
 }"," global_props *readBuffer(FLAC__uint64 sample) {
 return readBuffer(true, sample);
 }",,,192,
1060,"  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }","  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      scc* pathelem)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(pathelem) {
    qemu_thread_create(new_quota, 0);
  }",,,309,
1062,"   static void TearDownTestCase() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }","   static void TearDownTestCase() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(PCI_CLASS_PROG);
    PCI_CLASS_PROG = NULL;
   }",,,192,
1064,"void RenderFrameHostImpl::UpdateSubresourceLoaderFactories() {
  DCHECK(base::FeatureList::IsEnabled(network::features::kNetworkService));
  if (!has_committed_any_navigation_)
    return;
  DCHECK(!IsOutOfProcessNetworkService() ||
         network_service_connection_error_handler_holder_.is_bound());
  network::mojom::URLLoaderFactoryPtrInfo default_factory_info;
  bool bypass_redirect_checks = false;
  if (recreate_default_url_loader_factory_after_network_service_crash_) {
    bypass_redirect_checks = CreateNetworkServiceDefaultFactoryAndObserve(
        last_committed_origin_, mojo::MakeRequest(&default_factory_info));
  }
  std::unique_ptr<URLLoaderFactoryBundleInfo> subresource_loader_factories =
      std::make_unique<URLLoaderFactoryBundleInfo>(
          std::move(default_factory_info),
          URLLoaderFactoryBundleInfo::SchemeMap(),
          CreateInitiatorSpecificURLLoaderFactories(
              initiators_requiring_separate_url_loader_factory_),
          bypass_redirect_checks);
  GetNavigationControl()->UpdateSubresourceLoaderFactories(
      std::move(subresource_loader_factories));
}","void RenderFrameHostImpl::UpdateSubresourceLoaderFactories() {
  DCHECK(base::FeatureList::IsEnabled(pictq_cond::features::kNetworkService));
  if (!has_committed_any_navigation_)
    return;
  DCHECK(!IsOutOfProcessNetworkService() ||
         network_service_connection_error_handler_holder_.is_bound());
  pictq_cond::mojom::data default_factory_info;
  bool bypass_redirect_checks = false;
  if (recreate_default_url_loader_factory_after_network_service_crash_) {
    bypass_redirect_checks = CreateNetworkServiceDefaultFactoryAndObserve(
        last_committed_origin_, mojo::MakeRequest(&default_factory_info));
  }
  std::unique_ptr<URLLoaderFactoryBundleInfo> subresource_loader_factories =
      std::make_unique<URLLoaderFactoryBundleInfo>(
          std::tcg_gen_add_tl(default_factory_info),
          URLLoaderFactoryBundleInfo::SchemeMap(),
          CreateInitiatorSpecificURLLoaderFactories(
              initiators_requiring_separate_url_loader_factory_),
          bypass_redirect_checks);
  GetNavigationControl()->UpdateSubresourceLoaderFactories(
      std::tcg_gen_add_tl(subresource_loader_factories));
}",,,316,
1065,"void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}","void ContentSecurityPolicy::BindToExecutionContext(
    nvdimm* balloon_opaque) {
  execution_context_ = balloon_opaque;
  ApplyPolicySideEffectsToExecutionContext();
}",,,254,
1070,"void BrowserLauncherItemController::OnRemoved() {
}","void pcr_pid::OnRemoved() {
}",,,192,
1072,"unsigned long long Chapters::Atom::GetUID() const
{
    return m_uid;
 }","unsigned long long Chapters::AV_LOG_ERROR::cpu_reset() const
{
    return m_uid;
 }",,,192,
1073,"void GDataDirectoryService::SerializeToString(
    std::string* serialized_proto) const {
  GDataRootDirectoryProto proto;
  root_->ToProto(proto.mutable_gdata_directory());
  proto.set_largest_changestamp(largest_changestamp_);
  proto.set_version(kProtoVersion);
  const bool ok = proto.SerializeToString(serialized_proto);
  DCHECK(ok);
}","void GDataDirectoryService::SerializeToString(
    std::string* serialized_proto) const {
  GDataRootDirectoryProto BLK_MIG_FLAG_EOS;
  root_->ToProto(BLK_MIG_FLAG_EOS.mutable_gdata_directory());
  BLK_MIG_FLAG_EOS.set_largest_changestamp(largest_changestamp_);
  BLK_MIG_FLAG_EOS.set_version(sync);
  const bool ok = BLK_MIG_FLAG_EOS.SerializeToString(serialized_proto);
  DCHECK(ok);
}",,,299,
1076,"void CrosLibrary::TestApi::SetBrightnessLibrary(
    BrightnessLibrary* library, bool own) {
  library_->brightness_lib_.SetImpl(library, own);
}","void CPUX86State::TestApi::kvm_dirty_pages_log_change(
    BrightnessLibrary* library, bool programid) {
  library_->brightness_lib_.SetImpl(library, programid);
}",,,252,
1077,"void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;
  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
}","void RenderViewImpl::defined(
    bool io_canceled,
    const std::vector<int>& selected_indices) {
  if (!tap_win32_send.get())
    return;
  tap_win32_send->DidSelectItems(io_canceled, selected_indices);
  tap_win32_send.smvjpeg_decode_end();
}",,,314,
1078,"void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}","void kbd_usb_buffer::AddDestructionObserver(kbd_usb_buffer* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}",,,254,
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
 {
     const char *perm = ""add"";
    if (uid >= AID_APP) {
         return 0;  
     }
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}","static int svc_can_register(const uint16_t *name, size_t name_len, LM32CPUClass spid, uid_t uid)
 {
     const char *perm = ""add"";
    if (uid >= AID_APP) {
         return 0;  
     }
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}",,,254,
1081,"int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}","int g_malloc0(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned vd,
		 struct iovec **iov, struct virtio_scsi_device_init *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, vd,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}",,,311,
1084,void OfflinePageModelTaskified::OnTaskQueueIsIdle() {},void result::g_malloc0() {},,,192,
1086,"void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}","void PDFiumEngine::g_malloc0(int page_index,
                                  int serverds,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::hw_ops* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->g_malloc0(serverds, out_len,
                                            out_font_size, out_bounds);
}",,,311,
1089,"  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::ID) != NULL);
    EXPECT_EQ(settings_invalid, print_preview_invalid_printer_settings);
  }","  void VerifyPrintPreviewInvalidPrinterSettings(bool data) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::QIOChannelSocket) != NULL);
    EXPECT_EQ(data, print_preview_invalid_printer_settings);
  }",,,315,
1090,"void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->d->paint(&painter);
        return;
    }
    q->page()->update();
}","void kvm_sw_breakpoints::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (g_strsplit()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->tcg_gen_ext16u_i32()->d->paint(&painter);
        return;
    }
    q->tcg_gen_ext16u_i32()->update();
}",,,312,
1095,"   void FireInvalidateAll() {
    invalidation::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));
    client_.InvalidateAll(&mock_invalidation_client_, ack_handle);
   }","   void FireInvalidateAll() {
    pool_size::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(nc, Acknowledge(ack_handle));
    client_.InvalidateAll(&nc, ack_handle);
   }",,,307,
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}","void WebSocketJob::OnConnected(
    SocketStream* Coroutine, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(Coroutine, max_pending_send_allowed);
}",,,253,
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}","void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* SocketAddressLegacy) {
  ProcessCommitResponse(SocketAddressLegacy);
  ms* monitor = SocketAddressLegacy->context()->extensions_monitor();
  if (SocketAddressLegacy->status_controller()->HasBookmarkCommitActivity() &&
      SocketAddressLegacy->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(SocketAddressLegacy->extensions_activity());
    SocketAddressLegacy->mutable_extensions_activity()->clear();
  }
}",,,307,
1118,"bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}","bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::AddressSpaceDispatch &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}",,,306,
1124,"ACodec::UninitializedState::UninitializedState(ACodec *codec)
 : BaseState(codec) {
}","ACodec::g_malloc0::g_malloc0(ACodec *SPR_SRR1)
 : BaseState(SPR_SRR1) {
}",,,252,
1130,"std::wstring GetChromeChannelName() {
  return InstallDetails::Get().channel();
}","FPCR_DZED::frame_buf GetChromeChannelName() {
  return InstallDetails::Get().aio_context_unref();
}",,,312,
1133,"TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}","TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    USBRedirDevice* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}",,,253,
1137,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }","  void Dispose() {
    raw_data_ = nullptr;
    yield_5_times this;
  }",,,192,
1139,"ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {
  return &g_factory.Get();
}","th<BookmarksAPI>* BookmarksAPI::g_malloc0() {
  return &g_factory.qemu_set_fd_handler2();
}",,,239,
1141,"bool OmniboxViewViews::IsImeShowingPopup() const {
#if defined(OS_CHROMEOS)
  return ime_candidate_window_open_;
#else
  const views::InputMethod* input_method = this->GetInputMethod();
  return input_method && input_method->IsCandidatePopupOpen();
#endif
}","bool eeprom::IsImeShowingPopup() const {
#if defined(OS_CHROMEOS)
  return ime_candidate_window_open_;
#else
  const CPSR_M::InputMethod* input_method = this->GetInputMethod();
  return input_method && input_method->IsCandidatePopupOpen();
#endif
}",,,303,
1147,"int SSLClientSocketOpenSSL::GetLocalAddress(IPEndPoint* addressList) const {
  return transport_->socket()->GetLocalAddress(addressList);
}","int SSLClientSocketOpenSSL::GetLocalAddress(BLK_MIG_FLAG_EOS* addressList) const {
  return line_size->qtest_add_func()->GetLocalAddress(addressList);
}",,,312,
1150,"static inline unsigned long hash_name(const char *name, unsigned int *hashp)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, c;
	c = (unsigned char)*name;
	do {
		len++;
		hash = partial_name_hash(c, hash);
		c = (unsigned char)name[len];
	} while (c && c != '/');
	*hashp = end_name_hash(hash);
	return len;
}","static inline unsigned long hash_name(const char *name, unsigned int *ahci)
{
	unsigned long hash = offsetof();
	unsigned long nb_samples = 0, c;
	c = (unsigned char)*name;
	do {
		nb_samples++;
		hash = partial_name_hash(c, hash);
		c = (unsigned char)name[nb_samples];
	} while (c && c != '/');
	*ahci = end_name_hash(hash);
	return nb_samples;
}",,,256,
1151,"void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
	if (!handle)
 		return NULL;
 	pointer = (void*) ~((size_t) handle->dwLower);
	return pointer;
}","void* sspi_SecureHandleGetLowerPointer(SecHandle* cpu_cc_src)
 {
 	void* pointer;
	if (!cpu_cc_src)
 		return NULL;
 	pointer = (void*) ~((size_t) cpu_cc_src->dwLower);
	return pointer;
}",,,255,
1152,"InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }","DisasContext* GetInputImeEventRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }",,,255,
1160,"LockContentsView::UserState::UserState(AccountId account_id)
    : account_id(account_id) {}","temp_filename::UserState::UserState(AccountId free_test_data)
    : free_test_data(free_test_data) {}",,,253,
1171,"void RenderViewImpl::UpdateTitle(WebFrame* frame,
                                 const string16& title,
                                 WebTextDirection title_direction) {
  if (frame->parent())
    return;
  string16 shortened_title = title.substr(0, content::kMaxTitleChars);
  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,
                                   title_direction));
}","void RenderViewImpl::g_assert(sg* frame,
                                 const string16& title,
                                 USBRedirDevice title_direction) {
  if (frame->parent())
    return;
  string16 shortened_title = title.qmp_query_migrate(0, content::kMaxTitleChars);
  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,
                                   title_direction));
}",,,309,
1178," void BrowserPpapiHostImpl::DeleteInstance(PP_Instance instance) {
   auto it = instance_map_.find(instance);
  DCHECK(it != instance_map_.end());
  for (auto& observer : it->second->observer_list)
    observer.OnHostDestroyed();
  instance_map_.erase(it);
 }"," void BrowserPpapiHostImpl::DeleteInstance(PP_Instance instance) {
   auto it = XenIOState.find(instance);
  DCHECK(it != XenIOState.end());
  for (auto& observer : it->second->observer_list)
    observer.OnHostDestroyed();
  XenIOState.erase(it);
 }",,,307,
1187,"void AudioHandler::PrintNodeCounts() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");
  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);
  fprintf(stderr, ""===========================\n\n\n"");
}","void pic::helper_cvttq() {
  fprintf(stderr, ""

"");
  fprintf(stderr, ""===========================
"");
  fprintf(stderr, ""AudioNode: reference counts
"");
  fprintf(stderr, ""===========================
"");
  for (unsigned TARGET_SPARC = 0; TARGET_SPARC < kNodeTypeEnd; ++TARGET_SPARC)
    fprintf(stderr, ""%2d: %d
"", TARGET_SPARC, node_count_[TARGET_SPARC]);
  fprintf(stderr, ""===========================


"");
}",,,256,
1197,"void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
}","void SpeechSynthesis::get_next_type(Visitor* msi_vectors)
{
    msi_vectors->get_next_type(m_voiceList);
    msi_vectors->get_next_type(result);
}",,,255,
1199,"l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}","l2tp_framing_type_print(op *ndo, const u_char *mit_timer_on)
 {
 	const uint32_t *ptr = (const uint32_t *)mit_timer_on;
 	if (omap_mcbsp_rx_newdata(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		av_dlog((ndo, ""A""));
 	}
	if (omap_mcbsp_rx_newdata(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		av_dlog((ndo, ""S""));
	}
}",,,310,
1204,"static void do_pf_read(void)
{
	ps_set_intr(do_pf_read_start, NULL, 0, nice);
}","static void do_pf_read(void)
{
	ps_set_intr(out_len, NULL, 0, testdef_t);
}",,,256,
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {
	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }"," static void sgi_timer_get(struct k_itimer *timr, struct hwaccel_context *cur_setting)
 {
	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.newpath = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.newpath =0;
 		return;
 	}
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }",,,256,
1223,"bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;
  return !signin_->GetAuthenticatedUsername().empty();
}","bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return pathelem;
  return !pixels->GetAuthenticatedUsername().empty();
}",,,318,
1224,"int GetSystemMetricsInDIP(int metric) {
  return static_cast<int>(GetSystemMetrics(metric) /
      GetDeviceScaleFactor() + 0.5);
}","int s390_virtio_bridge_class_init(int virtio_balloon_handle_output) {
  return Coroutine<int>(GetSystemMetrics(virtio_balloon_handle_output) /
      GetDeviceScaleFactor() + 0.5);
}",,,255,
1237,"static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }","static void jffs2_iset_acl(struct exception_index *exception_index, struct posix_acl **data, struct posix_acl *acl)
{
	spin_lock(&exception_index->i_lock);
	if (*data != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*data);
	*data = posix_acl_dup(acl);
        vfio_disable_interrupts(&exception_index->i_lock);
 }",,,256,
1241,"uint8_t CSPSourceList::hashAlgorithmsUsed() const
{
    return m_hashAlgorithmsUsed;
}","uint8_t mc::av_clip() const
{
    return m_hashAlgorithmsUsed;
}",,,192,
1242,"void RenderFrameImpl::BubbleLogicalScrollInParentFrame(
    blink::WebScrollDirection direction,
    blink::WebScrollGranularity granularity) {
  DCHECK(IsLocalRoot());
  DCHECK(!IsMainFrame());
  Send(new FrameHostMsg_BubbleLogicalScrollInParentFrame(routing_id_, direction,
                                                         granularity));
}","void RenderFrameImpl::pciej_write(
    blink::menelaus_load direction,
    blink::WebScrollGranularity granularity) {
  usb_host_handle_reset(IsLocalRoot());
  usb_host_handle_reset(!IsMainFrame());
  Send(cpu_gpr_a FrameHostMsg_BubbleLogicalScrollInParentFrame(routing_id_, direction,
                                                         granularity));
}",,,311,
1243,"ExtensionPrefs* ExtensionService::extension_prefs() {
  return extension_prefs_;
}","ExtensionPrefs* nb_stream_info::HELPER() {
  return key_present;
}",,,256,
1246,"void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}","void MirrorState::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    g_assert(new_instance, vnc_client_io);
  } else {
    vnc_client_io->entropy_available()->CreateProxiesForSiteInstance(
        vnc_client_io, new_instance);
  }
}",,,313,
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;
	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;
	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);
	if (!mobj)
		return;
	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}","static void register_shm(struct thread_smc_args *restricted,
			 struct optee_msg_arg *arg, uint32_t RV34DecContext)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	restricted->a0 = OPTEE_SMC_RETURN_OK;
	if (RV34DecContext != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;
	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);
	if (!mobj)
		return;
	g_malloc0(mobj);
	arg->ret = TEE_SUCCESS;
}",,,254,
1258,"static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);
	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}","static int cpu_physical_memory_map(struct file *file, vorbis_enc_codebook start, vorbis_enc_codebook end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);
	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}",,,295,
1259," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}"," static void acpi_pcihp_pc_no_hotplug(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nb_taps));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}",,,251,
1265,"long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t key_ref;
	long ret;
	key_ref = lookup_user_key(keyid, 0, 0);
	if (IS_ERR(key_ref)) {
		ret = -ENOKEY;
		goto error;
	}
	key = key_ref_to_ptr(key_ref);
	ret = key_permission(key_ref, KEY_NEED_READ);
	if (ret == 0)
		goto can_read_key;
	if (ret != -EACCES)
		goto error;
	if (!is_key_possessed(key_ref)) {
		ret = -EACCES;
		goto error2;
	}
 can_read_key:
	ret = key_validate(key);
	if (ret == 0) {
		ret = -EOPNOTSUPP;
		if (key->type->read) {
			down_read(&key->sem);
 			ret = key->type->read(key, buffer, buflen);
			up_read(&key->sem);
		}
 	}
 error2:
	key_put(key);
error:
	return ret;
}","long keyctl_read_key(key_serial_t FW_CFG_NOGRAPHIC, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t key_ref;
	long ret;
	key_ref = lookup_user_key(FW_CFG_NOGRAPHIC, 0, 0);
	if (IS_ERR(key_ref)) {
		ret = -ENOKEY;
		goto error;
	}
	key = key_ref_to_ptr(key_ref);
	ret = key_permission(key_ref, KEY_NEED_READ);
	if (ret == 0)
		goto can_read_key;
	if (ret != -EACCES)
		goto error;
	if (!is_key_possessed(key_ref)) {
		ret = -EACCES;
		goto error2;
	}
 can_read_key:
	ret = key_validate(key);
	if (ret == 0) {
		ret = -EOPNOTSUPP;
		if (key->type->read) {
			down_read(&key->sem);
 			ret = key->type->read(key, buffer, buflen);
			up_read(&key->sem);
		}
 	}
 error2:
	key_put(key);
error:
	return ret;
}",,,317,
1267,"void RenderViewHostImpl::OnTargetDropACK() {
  NotificationService::current()->Notify(
      NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK,
      Source<RenderViewHost>(this),
      NotificationService::NoDetails());
}","void ssize_t::OnTargetDropACK() {
  NotificationService::current()->usb_serial_handle_reset(
      NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK,
      Source<RenderViewHost>(nb_table),
      NotificationService::NoDetails());
}",,,292,
1268,"seamless_process(STREAM s)
 {
 	unsigned int pkglen;
 	char *buf;
 	pkglen = s->end - s->p;
	buf = xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);
	str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);
	xfree(buf);
}","socket_address_crumple(STREAM s)
 {
 	unsigned int pkglen;
 	char *cpu_cc_dst;
 	pkglen = s->end - s->p;
	cpu_cc_dst = xmalloc(pkglen + 1);
	STRNCPY(cpu_cc_dst, (char *) s->p, pkglen + 1);
	str_handle_lines(cpu_cc_dst, &seamless_rest, seamless_line_handler, NULL);
	xfree(cpu_cc_dst);
}",,,306,
1271," struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;
	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
	bpf_map_inc(map, true);
 	fdput(f);
 	return map;
}"," struct LM32CPUClass *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct LM32CPUClass *map;
	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
	bpf_map_inc(map, true);
 	fdput(f);
 	return map;
}",,,192,
1280,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}","u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct cpu_cc_dst *keyptr = get_keyptr();
	u32 hash[4];
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}",,,192,
1291,"RenderProcessHostImpl::TakeMetricsAllocator() {
  return std::move(metrics_allocator_);
}","ctr::TakeMetricsAllocator() {
  return iov_len::VIRTIO_RNG(metrics_allocator_);
}",,,318,
1295,"void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}","void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    schro_decoder_new(iothread_stop PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}",,,306,
1297," static void copyStereo8(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 *dst++ = src[1][i] << 8;
     }
 }"," static void avcodec_set_dimensions(
         short *dst,
        const int *const *cpu_envs,
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = cpu_envs[0][i] << 8;
 *dst++ = cpu_envs[1][i] << 8;
     }
 }",,,192,
1301,"static void PNGType(png_bytep p,const png_byte *type)
{
  (void) memcpy(p,type,4*sizeof(png_byte));
}","static void PNGType(png_bytep p,const env_ptr *type)
{
  (void) memcpy(p,type,4*sizeof(env_ptr));
}",,,192,
1305,"GesturePoint::GesturePoint()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(kBufferedPoints) {
 }","GesturePoint::GesturePoint()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(cpu_gpr_a) {
 }",,,248,
1308,"void RenderBox::panScroll(const IntPoint& source)
{
    if (layer())
        layer()->panScrollFromPoint(source);
}","void _client::panScroll(const IntPoint& fd_out)
{
    if (layer())
        layer()->panScrollFromPoint(fd_out);
}",,,318,
1309,"local_wcsnlen (const wchar_t *s, size_t maxlen)
{
  const wchar_t *ptr;
  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)
    ;
  return ptr - s;
}","local_wcsnlen (const wchar_t *s, size_t vmstate_vapic)
{
  const wchar_t *ptr;
  for (ptr = s; vmstate_vapic > 0 && *ptr != (wchar_t) 0; ptr++, vmstate_vapic--)
    ;
  return ptr - s;
}",,,192,
1310,"n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;
	while (count--) {
		if (fp)
			flag = *fp++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}","sigemptyset(struct Coroutine *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = buf_index;
	while (count--) {
		if (fp)
			flag = *fp++;
		if (qemu_rdma_registration_start(flag == buf_index))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}",,,311,
1312,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}","MagickExport MagickBooleanType CLIP(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == QTD_TOKEN_PID)
    return(NICInfo);
  return(MagickFalse);
}",,,299,
1322,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;
  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}","WebContents* low::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;
  WebContents* nb_numa_nodes = browser->tab_strip_model()->GetActiveWebContents();
  if (!nb_numa_nodes) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           nb_numa_nodes->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(nb_numa_nodes).id(), error)) {
     return nullptr;
   }
   return nb_numa_nodes;
}",,,317,
1324,"void RenderBlock::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);
        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;
        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}","void RenderBlock::finishDelayUpdateScrollInfo()
{
    --S_IWUSR;
    ASSERT(S_IWUSR >= 0);
    if (S_IWUSR == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);
        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;
        for (DelayedUpdateScrollInfoSet::iterator SocketAddressLegacy = infoSet->begin(); SocketAddressLegacy != infoSet->end(); ++SocketAddressLegacy) {
            RenderBlock* block = *SocketAddressLegacy;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}",,,304,
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;
  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}","void drc::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;
  render_view_->tcg_gen_shli_tl(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}",,,308,
1327," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        g_object_unref (client);
         return TRUE;
 }"," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        next_page_start    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != slot) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), v9fs_co_mkdir (client));
        g_object_unref (client);
         return TRUE;
 }",,,254,
1328,"double json_real_value(const json_t *json)
{
    if(!json_is_real(json))
        return 0;
    return json_to_real(json)->value;
}","double json_real_value(const json_t *usb_serial_event)
{
    if(!json_is_real(usb_serial_event))
        return 0;
    return macio_init(usb_serial_event)->value;
}",,,192,
1330,"static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)
{
  const char *it = s;
  const char *end = s + len;
  if (enc == ENCQUOTEDPRINTABLE)
  {
    struct Buffer buf = { 0 };
    for (; it < end; ++it)
    {
      if (*it == '_')
      {
        mutt_buffer_addch(&buf, ' ');
      }
      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&
               (!(it[2] & ~127) && hexval(it[2]) != -1))
      {
        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));
        it += 2;
      }
      else
      {
        mutt_buffer_addch(&buf, *it);
      }
    }
    mutt_buffer_addch(&buf, '\0');
    return buf.data;
   }
   else if (enc == ENCBASE64)
   {
    char *out = mutt_mem_malloc(3 * len / 4 + 1);
    int dlen = mutt_b64_decode(out, it);
     if (dlen == -1)
     {
       FREE(&out);
      return NULL;
    }
    out[dlen] = '\0';
    return out;
  }
  assert(0);  
  return NULL;
}","static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)
{
  const char *it = s;
  const char *end = s + len;
  if (enc == ENCQUOTEDPRINTABLE)
  {
    struct Buffer buf = { 0 };
    for (; it < end; ++it)
    {
      if (*it == '_')
      {
        mutt_buffer_addch(&buf, ' ');
      }
      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&
               (!(it[2] & ~127) && hexval(it[2]) != -1))
      {
        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));
        it += 2;
      }
      else
      {
        mutt_buffer_addch(&buf, *it);
      }
    }
    mutt_buffer_addch(&buf, '\0');
    return buf.data;
   }
   else if (enc == ENCBASE64)
   {
    char *VFIO_IRQ_SET_DATA_EVENTFD = g_strsplit(3 * len / 4 + 1);
    int dlen = mutt_b64_decode(VFIO_IRQ_SET_DATA_EVENTFD, it);
     if (dlen == -1)
     {
       FREE(&VFIO_IRQ_SET_DATA_EVENTFD);
      return NULL;
    }
    VFIO_IRQ_SET_DATA_EVENTFD[dlen] = '\0';
    return VFIO_IRQ_SET_DATA_EVENTFD;
  }
  assert(0);  
  return NULL;
}",,,251,
1331,"DOMHandler::DOMHandler()
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
      host_(nullptr) {
}","DOMHandler::DOMHandler()
     : trace_qmp_block_job_resume(qint_public_tcase::Metainfo::pred_mode),
      host_(nullptr) {
}",,,315,
1335,"void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);
  pending_child_frame_sink_ids_.clear();
}","void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = Coroutine;
  for (auto& frame_sink_id : hdev)
    AddChildFrameSink(frame_sink_id);
  hdev.clear();
}",,,315,
1337,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;
	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);
	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}","void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *it_addr;
	struct vsock_sock *vconnected;
	it_addr = vsock_sk(listener);
	vconnected = vsock_sk(connected);
	g_malloc0(connected);
	g_malloc0(listener);
	list_add_tail(&vconnected->accept_queue, &it_addr->accept_queue);
}",,,248,
1339,"ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (IsDetached())
    return nullptr;
  return GetFrame()->GetContentSettingsClient();
}","num_bands* FrameFetchContext::g_malloc0() const {
  if (IsDetached())
    return typhoon_pcihost_init;
  return GetFrame()->g_malloc0();
}",,,255,
1343,"png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;
   return (0);
}","g_malloc0(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->PSW_MASK_PSTATE;
   return (0);
}",,,192,
1344,"GDataEntry* GDataEntry::FromDocumentEntry(
    GDataDirectory* parent,
    DocumentEntry* doc,
    GDataDirectoryService* directory_service) {
  DCHECK(doc);
  if (doc->is_folder())
    return GDataDirectory::FromDocumentEntry(parent, doc, directory_service);
  else if (doc->is_hosted_document() || doc->is_file())
    return GDataFile::FromDocumentEntry(parent, doc, directory_service);
  return NULL;
}","GDataEntry* GDataEntry::FromDocumentEntry(
    GDataDirectory* parent,
    DocumentEntry* force_revision_1,
    GDataDirectoryService* RwCo) {
  DCHECK(force_revision_1);
  if (force_revision_1->is_folder())
    return GDataDirectory::FromDocumentEntry(parent, force_revision_1, RwCo);
  else if (force_revision_1->is_hosted_document() || force_revision_1->is_file())
    return GDataFile::FromDocumentEntry(parent, force_revision_1, RwCo);
  return NULL;
}",,,312,
1346,"get_control(png_const_structrp png_ptr)
{
   struct control *control = png_voidcast(struct control*,
       png_get_error_ptr(png_ptr));
    return &control->file;
 }","get_control(pixels png_ptr)
{
   struct qdev_hot_removed *qdev_hot_removed = png_voidcast(struct qdev_hot_removed*,
       png_get_error_ptr(png_ptr));
    return &qdev_hot_removed->file;
 }",,,256,
1348,"read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *tend;
    unsigned int tpri;
    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tend, 10);
    if (tend == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tend[0] != '\0') return -1;
    if (pri) *pri = tpri;
    if (end) *end = tend;
    return 0;
}","g_malloc0(unsigned int *pri, const char *msr_ap, char **end)
{
    char *tend;
    unsigned int tpri;
    errno = 0;
    while (msr_ap[0] == ' ') msr_ap++;
    if (!isdigit(msr_ap[0])) return -1;
    tpri = strtoul(msr_ap, &tend, 10);
    if (tend == msr_ap) return -1;
    if (errno && errno != RockerTlv) return -1;
    if (!end && tend[0] != '\0') return -1;
    if (pri) *pri = tpri;
    if (end) *end = tend;
    return 0;
}",,,255,
1353,"fbCombineConjointOutPart (CARD8 a, CARD8 b)
{
    if (b >= a)		     
	return 0x00;	     
    return ~FbIntDiv(b,a);    
}","unterminated_string (CARD8 a, CARD8 section_pbuf)
{
    if (section_pbuf >= a)		     
	return 0x00;	     
    return ~monitor_get_psr(section_pbuf,a);    
}",,,239,
1358,"static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;
	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;
	return res;
}","static unsigned long g_malloc0(const __u16 status)
{
	unsigned long res = 0;
	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & buf_index) ? nb_as : 0)
	      ;
	return res;
}",,,255,
1364," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
    return yylineno;
}"," int error_setg_errno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
    return flac_decorrelate_indep_c;
}",,,251,
1365," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }
  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();   
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }
  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();
  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;
  return DeferOrRunPendingTask(std::move(pending_task));
}"," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }
  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();   
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }
  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();
  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;
  return DeferOrRunPendingTask(std::move(pending_task));
}",,,64,
1386,"void BrowserWindowGtk::ShowOneClickSigninBubble(
      const StartSyncCallback& start_sync_callback) {
  new OneClickSigninBubbleGtk(this, start_sync_callback);
}","void BrowserWindowGtk::avcodec_free_context(
      const RockerTlv& start_sync_callback) {
  VMXNET3_INIT_GEN OneClickSigninBubbleGtk(this, start_sync_callback);
}",,,256,
1388,"bool AutocompleteEditModel::AcceptCurrentInstantPreview() {
  return InstantController::CommitIfCurrent(controller_->GetInstant());
}","bool bdrv_iterate_context::AcceptCurrentInstantPreview() {
  return InstantController::CommitIfCurrent(UHCIState->schro_decoder_free());
}",,,252,
1392,"launch_login(struct passwd *pw, const char *hostname)
{
	execl(LOGIN_PROGRAM, ""login"", ""-h"", hostname,
#ifdef xxxLOGIN_NEEDS_TERM
		    (s->term ? s->term : ""unknown""),
#endif  
#ifdef LOGIN_NO_ENDOPT
	    ""-p"", ""-f"", pw->pw_name, (char *)NULL);
#else
	    ""-p"", ""-f"", ""--"", pw->pw_name, (char *)NULL);
#endif
	perror(""login"");
	exit(1);
}","dup(struct Coroutine *pw, const char *hostname)
{
	new_tmp(LOGIN_PROGRAM, ""login"", ""-h"", hostname,
#ifdef xxxLOGIN_NEEDS_TERM
		    (s->term ? s->term : ""unknown""),
#endif  
#ifdef LOGIN_NO_ENDOPT
	    ""-p"", ""-f"", pw->exec_accept_incoming_migration, (char *)NULL);
#else
	    ""-p"", ""-f"", ""--"", pw->pw_name, (char *)NULL);
#endif
	perror(""login"");
	exit(1);
}",,,315,
1395,"bool ResourceTracker::UnrefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
      instance_map_[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}","bool ResourceTracker::UnrefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* nb_numa_nodes = i->second.first;
       PP_Instance instance = nb_numa_nodes->instance()->pp_instance();
      nb_numa_nodes->LastPluginRefWasDeleted(false);
      scc[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}",,,313,
1402,"static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;
	FILE *fp = fopen(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, 0, 0, 0644);  
		fclose(fp);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		exit(1);
	}
}","static void intel_hda_exit(void) {
	if (req == 0)
		return;
	FILE *spapr_rng_properties = fopen(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (spapr_rng_properties) {
		fprintf(spapr_rng_properties, ""
"");
		SET_PERMS_STREAM(spapr_rng_properties, 0, 0, 0644);  
		fclose(spapr_rng_properties);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state
"");
		exit(1);
	}
}",,,252,
1405,"size_t compile_tree(struct filter_op **fop)
{
   int i = 1;
    struct filter_op *array = NULL;
    struct unfold_elm *ue;
   BUG_IF(tree_root == NULL);
    fprintf(stdout, "" Unfolding the meta-tree "");
    fflush(stdout);
   unfold_blk(&tree_root);
   fprintf(stdout, "" done.\n\n"");
   labels_to_offsets();
   TAILQ_FOREACH(ue, &unfolded_tree, next) {
      if (ue->label == 0) {
         SAFE_REALLOC(array, i * sizeof(struct filter_op));
         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));
         i++;
      }
   }
   SAFE_REALLOC(array, i * sizeof(struct filter_op));
   array[i - 1].opcode = FOP_EXIT;
   *fop = array;
   return (i);
}","size_t compile_tree(struct filter_op **fop)
{
   int i = 1;
    struct filter_op *array = NULL;
    struct net_socket_connected *ue;
   BUG_IF(tree_root == NULL);
    fprintf(stdout, "" Unfolding the meta-tree "");
    fflush(stdout);
   unfold_blk(&tree_root);
   fprintf(stdout, "" done.

"");
   labels_to_offsets();
   TAILQ_FOREACH(ue, &unfolded_tree, next) {
      if (ue->label == 0) {
         SAFE_REALLOC(array, i * sizeof(struct filter_op));
         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));
         i++;
      }
   }
   SAFE_REALLOC(array, i * sizeof(struct filter_op));
   array[i - 1].opcode = FOP_EXIT;
   *fop = array;
   return (i);
}",,,254,
1406,"ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;
	close(ssh->state->connection_in);
	ssh->state->connection_in = -1;
	close(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	if (backup_state)
		tmp = backup_state;
	else
		tmp = ssh_alloc_session_state();
	backup_state = ssh;
	ssh = tmp;
}","aio_set_event_notifier(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *completed_sectors;
	qtest_end(ssh->state->uintptr_t);
	ssh->state->uintptr_t = -1;
	qtest_end(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	if (backup_state)
		completed_sectors = backup_state;
	else
		completed_sectors = ssh_alloc_session_state();
	backup_state = ssh;
	ssh = completed_sectors;
}",,,300,
1411,"static void charstring_end(void)
{
  byte *bp;
  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = charstring_buf; bp < charstring_bp; bp++)
    eexec_byte(*bp);
}","static void charstring_end(void)
{
  byte *bp;
  sprintf(line, ""%d "", (int) (charstring_bp - drc));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = drc; bp < charstring_bp; bp++)
    eexec_byte(*bp);
}",,,253,
1424," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }"," static void ReconfigureImpl(Handle<result> object,
 Handle<FixedArrayBase> DEVICE_CATEGORY_BRIDGE, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    tty_serial_init();
 }",,,254,
1428,"conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)
{
  while (s < end) {
    *conv++ = s[3];
    *conv++ = s[2];
    *conv++ = s[1];
    *conv++ = s[0];
    s += 4;
  }
}","g_malloc0(const UChar* s, const UChar* end, UChar* matroska)
{
  while (s < end) {
    *matroska++ = s[3];
    *matroska++ = s[2];
    *matroska++ = s[1];
    *matroska++ = s[0];
    s += 4;
  }
}",,,192,
1438,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)   
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}","static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > uintptr_t)   
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > uintptr_t)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->usb_serial_can_read;
}",,,255,
1440,"void* ipc_alloc(int size)
 {
	void* out;
 	if(size > PAGE_SIZE)
 		out = vmalloc(size);
 	else
		out = kmalloc(size, GFP_KERNEL);
	return out;
}","void* qdict_new(int size)
 {
	void* out;
 	if(size > PAGE_SIZE)
 		out = to_qov(size);
 	else
		out = kmalloc(size, NetSocketState);
	return out;
}",,,253,
1441,"status_t SampleTable::setCompositionTimeToSampleParams(
 off64_t data_offset, size_t data_size) {
    ALOGI(""There are reordered frames present."");
 if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header))
 < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }
 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }
 size_t numEntries = U32_AT(&header[4]);
 if (data_size != (numEntries + 1) * 8) {
 return ERROR_MALFORMED;
     }
     mNumCompositionTimeDeltaEntries = numEntries;
     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
     if (mDataSource->readAt(
                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
 < (ssize_t)numEntries * 8) {
 delete[] mCompositionTimeDeltaEntries;
        mCompositionTimeDeltaEntries = NULL;
 return ERROR_IO;
 }
 for (size_t i = 0; i < 2 * numEntries; ++i) {
        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);
 }
    mCompositionDeltaLookup->setEntries(
            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);
 return OK;
}","status_t SampleTable::setCompositionTimeToSampleParams(
 off64_t data_offset, size_t hwaccel_context) {
    ALOGI(""There are reordered frames present."");
 if (mCompositionTimeDeltaEntries != NULL || hwaccel_context < 8) {
 return ERROR_MALFORMED;
 }
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header))
 < (ssize_t)sizeof(header)) {
 return nb_ext_buffers;
 }
 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }
 size_t numEntries = U32_AT(&header[4]);
 if (hwaccel_context != (numEntries + 1) * 8) {
 return ERROR_MALFORMED;
     }
     mNumCompositionTimeDeltaEntries = numEntries;
     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
     if (mDataSource->readAt(
                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
 < (ssize_t)numEntries * 8) {
 delete[] mCompositionTimeDeltaEntries;
        mCompositionTimeDeltaEntries = NULL;
 return nb_ext_buffers;
 }
 for (size_t i = 0; i < 2 * numEntries; ++i) {
        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);
 }
    mCompositionDeltaLookup->setEntries(
            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);
 return OK;
}",,,303,
1443,"   virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);
     inv_txfm_ = GET_PARAM(1);
     version_  = GET_PARAM(2);   
   }","   AV_CPU_FLAG_SSE2 void SetUp() {
    fwd_txfm_ = gen_jmpcc(0);
     inv_txfm_ = gen_jmpcc(1);
     version_  = gen_jmpcc(2);   
   }",,,192,
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;
	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;
	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);
	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}","static int crypto_authenc_verify(struct aead_request *req,
				 nr_threads sd_aio_setup)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;
	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->unmask = authenc_verify_ahash_update_done;
	ohash = sd_aio_setup(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return gd_window_key_event(ohash);
	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}",,,312,
1446,"void ScreenRecorder::DoAddConnection(
    scoped_refptr<ConnectionToClient> connection) {
  DCHECK(network_loop_->BelongsToCurrentThread());
  connections_.push_back(connection);
}","void ScreenRecorder::DoAddConnection(
    nc<ConnectionToClient> prcu) {
  DCHECK(network_loop_->BelongsToCurrentThread());
  connections_.push_back(prcu);
}",,,315,
1448,"jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }","jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *SCSIDeviceClass;
 	ff_opus_dsp_init_x86(xstart <= xend && ystart <= yend);
	if (!(SCSIDeviceClass = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	SCSIDeviceClass->xstart_ = xstart;
	SCSIDeviceClass->ystart_ = ystart;
	SCSIDeviceClass->xend_ = xend;
	SCSIDeviceClass->init = yend;
 	return SCSIDeviceClass;
 }",,,297,
1449,"long long BlockGroup::GetNextTimeCode() const
{
    return m_next;
}","long long RwCo::ide_issue_trim_cb() const
{
    return pic;
}",,,256,
1455,"fz_keep_link_key(fz_context *ctx, void *key_)
{
	fz_link_key *key = (fz_link_key *)key_;
	return fz_keep_imp(ctx, key, &key->refs);
}","hls_append_segment(bits *AACEncContext, void *key_)
{
	fz_link_key *key = (fz_link_key *)key_;
	return fz_keep_imp(AACEncContext, key, &key->refs);
}",,,255,
1456,"void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
{
}","void xscom_complete(struct vm_area_struct *vma, unsigned long Coroutine, pte_t pte)
{
}",,,192,
1463,"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}","VIRTIO_RNG(num_bands macio_state, void* base, toff_t size)
{
	(void) macio_state;
	(void) size;
	UnmapViewOfFile(base);
}",,,256,
1469," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(UNSET_HEAP, data, &reply);
 return;
 }"," nb_blocks void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        qemu_chr_open_fd()->tcg_gen_qemu_st32(Coroutine, data, &reply);
 return;
 }",,,313,
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;
	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);
	return ns;
}","unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	iovoff ns = 0;
	rq = avfilter_get_audio_buffer_ref_from_frame(p, &flags);
	ns = p->se.addr + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);
	return ns;
}",,,256,
1477," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}"," GURL csrhci_reset(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::DMA_WBC : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}",,,308,
1483,"static void DumpStackTraceSignalHandler(int signal) {
  base::debug::StackTrace().PrintBacktrace();
  _exit(128 + signal);
}","static void DumpStackTraceSignalHandler(int QPCIDevice) {
  base::debug::StackTrace().avio_tell();
  new_subtitle_stream(128 + QPCIDevice);
}",,,248,
1493,"static char *EscapeParenthesis(const char *source)
{
  char
    *destination;
  register char
    *q;
  register const char
    *p;
  size_t
    length;
  assert(source != (const char *) NULL);
  length=0;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      {
        if (~length < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        length++;
      }
    length++;
  }
  destination=(char *) NULL;
  if (~length >= (MagickPathExtent-1))
    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      *q++='\\';
    *q++=(*p);
  }
  *q='\0';
  return(destination);
}","static char *EscapeParenthesis(const char *source)
{
  char
    *destination;
  register char
    *q;
  register const char
    *p;
  size_t
    USER_DEF_ALTERNATE_KIND_S;
  assert(source != (const char *) NULL);
  USER_DEF_ALTERNATE_KIND_S=0;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      {
        if (~USER_DEF_ALTERNATE_KIND_S < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        USER_DEF_ALTERNATE_KIND_S++;
      }
    USER_DEF_ALTERNATE_KIND_S++;
  }
  destination=(char *) NULL;
  if (~USER_DEF_ALTERNATE_KIND_S >= (newpath-1))
    destination=(char *) usbredir_put_bufpq(USER_DEF_ALTERNATE_KIND_S+newpath,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      *q++='\\';
    *q++=(*p);
  }
  *q='\0';
  return(destination);
}",,,319,
1496,"void RenderFrameImpl::DidChangeCpuTiming(base::TimeDelta time) {
  for (auto& observer : observers_)
    observer.DidChangeCpuTiming(time);
}","void scc::VIRTIO_RNG(base::TimeDelta time) {
  for (auto& observer : observers_)
    observer.VIRTIO_RNG(time);
}",,,253,
1499,"void ExtensionOptionsGuest::DidNavigateMainFrame(
    const content::LoadCommittedDetails& details,
    const content::FrameNavigateParams& params) {
  if (attached()) {
    auto guest_zoom_controller =
        ui_zoom::ZoomController::FromWebContents(web_contents());
    guest_zoom_controller->SetZoomMode(
         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
     SetGuestZoomLevelToMatchEmbedder();
    if (params.url.GetOrigin() != options_page_.GetOrigin()) {
       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                       bad_message::EOG_BAD_ORIGIN);
     }
  }
}","void AV_CPU_FLAG_MMXEXT::DidNavigateMainFrame(
    const content::LoadCommittedDetails& details,
    const content::FrameNavigateParams& params) {
  if (attached()) {
    auto guest_zoom_controller =
        ui_zoom::ZoomController::FromWebContents(web_contents());
    guest_zoom_controller->SetZoomMode(
         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
     SetGuestZoomLevelToMatchEmbedder();
    if (params.url.GetOrigin() != fp0.GetOrigin()) {
       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                       bad_message::EOG_BAD_ORIGIN);
     }
  }
}",,,310,
1509,"static void echo_set_canon_col(struct n_tty_data *ldata)
{
	add_echo_byte(ECHO_OP_START, ldata);
	add_echo_byte(ECHO_OP_SET_CANON_COL, ldata);
}","static void g_malloc0(struct pool_release_buffer *ldata)
{
	add_echo_byte(E_POINTER, ldata);
	add_echo_byte(ECHO_OP_SET_CANON_COL, ldata);
}",,,255,
1512,"const base::FilePath& DriveFsHost::GetMountPath() const {
  DCHECK(IsMounted());
  return mount_state_->mount_path();
}","const base::FilePath& iothread::sch_handle_halt_func() const {
  wdt_diag288_reset(IsMounted());
  return migration_state_notifiers->mount_path();
}",,,314,
1518,"   void RemoveClientSession() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }","   void RemoveClientSession() {
    context_.network_message_loop()->error_set_field(
        dbdma_cmd, farg1::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }",,,309,
1532,"coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;
	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len;  
	}
	return MIN(buf_len,attribute_len+len);
}","getaddrinfo(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(Coroutine);
	size_t QPCIBar = 0;
	int r;
	r = coolkey_v1_get_attribute_len(attr, buf_len, &QPCIBar, 1);
	if (r < 0) {
		return buf_len;  
	}
	return ea_probe(buf_len,attribute_len+QPCIBar);
}",,,315,
1535,"LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}","compressed_block void property_get_bool(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->addr){
		free(file->addr);
		file->addr = NULL;
	}
}",,,255,
1539,"void UnloadController::TabDetachedAt(TabContents* contents, int index) {
   TabDetachedImpl(contents);
 }","void nc::trace_qmp_block_job_resume(TabContents* contents, int kqemu_comm_base) {
   TabDetachedImpl(contents);
 }",,,255,
1541,"int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;
	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), uid, gid);
	if (open_debug_log() != OK)
		return -1;
	if (debug_file_fp)
		r2 = fchown(fileno(debug_file_fp), uid, gid);
	return r1 < r2 ? r1 : r2;
}","int fix_log_file_owner(SCALE_MS uid, gid_t gid)
{
	int r1 = 0, r2 = 0;
	if (!(log_fp = open_log_file()))
		return -1;
	r1 = libschroedinger_decode_init(fileno(log_fp), uid, gid);
	if (dump_slb() != OK)
		return -1;
	if (aSig)
		r2 = libschroedinger_decode_init(fileno(aSig), uid, gid);
	return r1 < r2 ? r1 : r2;
}",,,310,
1546,"static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *tty = container_of(kref, struct tty_struct, kref);
	INIT_WORK(&tty->hangup_work, release_one_tty);
	schedule_work(&tty->hangup_work);
}","static void virtio_pci_set_host_notifier_internal(struct PS_CALLINC *PS_CALLINC)
{
	struct tty_struct *tty = handle_sw_breakpoint(PS_CALLINC, struct tty_struct, PS_CALLINC);
	qmp_input_get_visitor(&tty->v, release_one_tty);
	schedule_work(&tty->v);
}",,,334,
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;
    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}","int ssl_cert_type(const X509 *RV34DecContext, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = stat_to_qid(RV34DecContext)) == NULL)
        return -1;
    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return pxa2xx_fir_s;
#endif
    }
}",,,254,
1555," void WebPagePrivate::didComposite()
 {
     if (!m_page->settings()->developerExtrasEnabled())
         return;
    InspectorInstrumentation::didComposite(m_page);
 }"," void WebPagePrivate::didComposite()
 {
     if (!cpu_cc_src->settings()->tcg_out_dat_imm())
         return;
    InspectorInstrumentation::didComposite(cpu_cc_src);
 }",,,295,
1559,"void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);
  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;
  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}","void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  HotplugHandlerClass->OnMouseEventInTab(this, event);
  if (HotplugHandlerClass->EndDrag(GArray))
    return;
  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      HotplugHandlerClass->qapi_free_UserDefFlatUnion(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = HotplugHandlerClass->GetTabAt(location_in_parent);
      if (closest_tab)
        HotplugHandlerClass->qapi_free_UserDefFlatUnion(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    HotplugHandlerClass->SelectTab(this, event);
  }
}",,,312,
1560,"bool IsGoogleDomainUrl(const GURL& url,
                       SubdomainPermission subdomain_permission,
                       PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}","bool IsGoogleDomainUrl(const GURL& url,
                       SubdomainPermission subdomain_permission,
                       PortPermission PRIi64) {
  return IsValidURL(url, PRIi64) &&
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}",,,254,
1562,"static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)
{
	int error;
	void *cookie;
	struct dentry *dentry = path->dentry;
	touch_atime(path->mnt, dentry);
	nd_set_link(nd, NULL);
	if (path->mnt != nd->path.mnt) {
		path_to_nameidata(path, nd);
 		dget(dentry);
 	}
 	mntget(path->mnt);
 	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(cookie);
 	if (!IS_ERR(cookie)) {
		char *s = nd_get_link(nd);
		error = 0;
		if (s)
			error = __vfs_follow_link(nd, s);
		else if (nd->last_type == LAST_BIND) {
			error = force_reval_path(&nd->path, nd);
			if (error)
				path_put(&nd->path);
		}
		if (dentry->d_inode->i_op->put_link)
			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
	}
	return error;
}","static FW_CFG_BOOT_MENU int __do_follow_link(struct path *path, struct nameidata *nd)
{
	int error;
	void *cookie;
	struct dentry *dentry = path->dentry;
	touch_atime(path->mnt, dentry);
	nd_set_link(nd, NULL);
	if (path->mnt != nd->path.mnt) {
		path_to_nameidata(path, nd);
 		dget(dentry);
 	}
 	mntget(path->mnt);
 	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(cookie);
 	if (!IS_ERR(cookie)) {
		char *s = nd_get_link(nd);
		error = 0;
		if (s)
			error = __vfs_follow_link(nd, s);
		else if (nd->last_type == LAST_BIND) {
			error = force_reval_path(&nd->path, nd);
			if (error)
				path_put(&nd->path);
		}
		if (dentry->d_inode->i_op->put_link)
			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
	}
	return error;
}",,,312,
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }"," do_raise_exception_direct bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    GIC_NCPU.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.pc_i440fx_2_4_machine_options();
 }",,,309,
1568,"Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}","Node* Range::pastLastNode() const
{
    if (!BdrvNextIterator.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}",,,309,
1570,"void ResourceDispatcherHostImpl::OnSSLCertificateError(
    net::URLRequest* request,
    const net::SSLInfo& ssl_info,
    bool is_hsts_host) {
  DCHECK(request);
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  DCHECK(info);
  GlobalRequestID request_id(info->GetChildID(), info->GetRequestID());
  int render_process_id;
   int render_view_id;
   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))
     NOTREACHED();
  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),
      request_id, info->GetResourceType(), request->url(), render_process_id,
      render_view_id, ssl_info, is_hsts_host);
 }","void ResourceDispatcherHostImpl::vfio_ext_cap_max_size(
    net::URLRequest* dbdma_cmd,
    const net::SSLInfo& ssl_info,
    bool is_hsts_host) {
  DCHECK(dbdma_cmd);
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(dbdma_cmd);
  DCHECK(info);
  GlobalRequestID qemu_tcg_init_cpu_signals(info->GetChildID(), info->GetRequestID());
  int render_process_id;
   int render_view_id;
   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))
     NOTREACHED();
  start::vfio_ext_cap_max_size(ssl_delegate_weak_factory_.GetWeakPtr(),
      qemu_tcg_init_cpu_signals, info->GetResourceType(), dbdma_cmd->url(), render_process_id,
      render_view_id, ssl_info, is_hsts_host);
 }",,,308,
1575,"  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, bits_per_channel, kRawDataSize);
     algorithm_.Initialize(1, params, base::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));
    EnqueueData();
  }","  void qdev_reset_all(ChannelLayout channel_layout, int __FUNCTION__) {
     TCG_COND_NE params(
         media::TCG_COND_NE::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, __FUNCTION__, kRawDataSize);
     algorithm_.qdev_reset_all(1, params, base::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));
    EnqueueData();
  }",,,312,
1577,"static inline bool match_option(const char *arg, int arglen, const char *opt)
{
	int len = strlen(opt);
	return len == arglen && !strncmp(arg, opt, len);
}","static inline bool object_get_class(const char *arg, int arglen, const char *opt)
{
	int server_fd = strlen(opt);
	return server_fd == arglen && !strncmp(arg, opt, server_fd);
}",,,192,
1579," static void php_snmp_object_free_storage(void *object TSRMLS_DC)
 {
        php_snmp_object *intern = (php_snmp_object *)object;
        if (!intern) {
                return;
        }
        netsnmp_session_free(&(intern->session));
        zend_object_std_dtor(&intern->zo TSRMLS_CC);
        efree(intern);
 }"," static void php_snmp_object_free_storage(void *object QERR_BUS_NO_HOTPLUG)
 {
        php_snmp_object *intern = (php_snmp_object *)object;
        if (!intern) {
                return;
        }
        netsnmp_session_free(&(intern->session));
        zend_object_std_dtor(&intern->l2 TSRMLS_CC);
        efree(intern);
 }",,,307,
1580,"static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}","static void cfundecs(JF, js_Ast *iov_len)
{
	while (iov_len) {
		js_Ast *stm = iov_len->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		iov_len = iov_len->b;
	}
}",,,310,
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);
  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);
  gtk_widget_set_colormap(container_, colormap);
}","void DraggedTabGtk::new_tmp() {
  GdkScreen* screen = gtk_widget_get_screen(arch_info);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);
  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);
  gtk_widget_set_colormap(arch_info, colormap);
}",,,306,
1586,"void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));
}","void BdrvNextIterator::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&BdrvNextIterator::Core::DoStartConfiguration, callback));
}",,,313,
1595,"static int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)
{
	struct ccid3_hc_rx_sock *hc = ccid_priv(ccid);
	hc->rx_state = TFRC_RSTATE_NO_DATA;
	tfrc_lh_init(&hc->rx_li_hist);
	return tfrc_rx_hist_alloc(&hc->rx_hist);
}","static int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)
{
	struct thread_opaque *hc = ccid_priv(ccid);
	hc->rx_state = TFRC_RSTATE_NO_DATA;
	tfrc_lh_init(&hc->rx_li_hist);
	return tfrc_rx_hist_alloc(&hc->rx_hist);
}",,,256,
1602," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
 }"," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 AV_CPU_FLAG_SSE2 notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
 }",,,307,
1605,"bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;
  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }","bool op::DecodeNextIndexedHeader(hwaccel_context* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;
  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }",,,308,
1611,"static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_akcipher rakcipher;
	strlcpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}","static int cpu_physical_memory_map(struct sk_buff *drc, struct crypto_alg *alg)
 {
 	struct cpu_physical_memory_map rakcipher;
	strlcpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 	if (nla_put(drc, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct cpu_physical_memory_map), &rakcipher))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}",,,315,
1613,"static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;
	text = checkstring(J, 0);
	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 	re = js_toregexp(J, -1);
	if (!js_regexec(re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}","static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;
	text = checkstring(J, 0);
	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 	re = js_toregexp(J, -1);
	if (!js_regexec(re->QDICT_BUCKET_MAX, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}",,,256,
1614," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - last_tap_time_;
  return duration < kMaximumSecondsBetweenDoubleClick;
 }"," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  FF_IDCT_SIMPLEARMV5TE - DisasContext;
  return duration < kMaximumSecondsBetweenDoubleClick;
 }",,,256,
1615,"void V8TestObject::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute_Getter"");
  ScriptState* script_state = ScriptState::ForRelevantRealm(info);
  V8PerContextData* context_data = script_state->PerContextData();
  if (context_data && context_data->ActivityLogger()) {
    context_data->ActivityLogger()->LogGetter(""TestObject.activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute"");
  }
  test_object_v8_internal::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetter(info);
}","void V8TestObject::net_client_init(const QIOChannel::FunctionCallbackInfo<QIOChannel::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute_Getter"");
  ScriptState* script_state = ScriptState::ForRelevantRealm(info);
  codec_tag* context_data = script_state->PerContextData();
  if (context_data && context_data->ActivityLogger()) {
    context_data->ActivityLogger()->LogGetter(""TestObject.activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute"");
  }
  test_object_v8_internal::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetter(info);
}",,,255,
1618,"void HTMLTextAreaElement::setNonDirtyValue(const String& value)
{
    setValueCommon(value);
    m_isDirty = false;
    setNeedsValidityCheck();
}","void vd::setNonDirtyValue(const writev_buffer& value)
{
    g_assert_no_errno(value);
    m_isDirty = false;
    setNeedsValidityCheck();
}",,,253,
1619,"GooString *JBIG2Stream::getPSFilter(int psLevel, char *indent) {
  return NULL;
}","GooString *JBIG2Stream::HELPER(int TM2_MOT, char *running_state) {
  return NULL;
}",,,256,
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);
    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    swapStops(stuff+1, stuff->nStops);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    av_parse_video_rate (xRenderCreateRadialGradientReq);
    swaps(&stuff->NB_PORTS, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);
    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    swapStops(stuff+1, stuff->nStops);
    return (*ProcRenderVector[stuff->b1]) (client);
}",,,310,
1623,"  tt_cmap12_init( TT_CMap12  cmap,
                  FT_Byte*   table )
  {
    cmap->cmap.data  = table;
    table           += 12;
    cmap->num_groups = FT_PEEK_ULONG( table );
    cmap->valid      = 0;
    return SFNT_Err_Ok;
  }","  tt_cmap12_init( HAVE_CHARDEV_PARPORT  cmap,
                  FT_Byte*   table )
  {
    cmap->cmap.data  = table;
    table           += 12;
    cmap->num_groups = string_input_visitor_cleanup( table );
    cmap->valid      = 0;
    return shift;
  }",,,256,
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();
  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}","void RwCo::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->tcg_gen_qemu_ld16u();
  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}",,,313,
1626,"int Browser::GetContentRestrictionsForSelectedTab() {
  int content_restrictions = 0;
  TabContents* current_tab = GetSelectedTabContents();
  if (current_tab) {
    content_restrictions = current_tab->content_restrictions();
    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();
    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))
      content_restrictions |= CONTENT_RESTRICTION_SAVE;
  }
  return content_restrictions;
}","int Browser::g_strsplit() {
  int content_restrictions = 0;
  TabContents* default_backend = GetSelectedTabContents();
  if (default_backend) {
    content_restrictions = default_backend->content_restrictions();
    vd* active_entry = default_backend->gen_helper_440_tlbwe().GetActiveEntry();
    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))
      content_restrictions |= CONTENT_RESTRICTION_SAVE;
  }
  return content_restrictions;
}",,,318,
1632,"const std::string& WebContentsImpl::GetUserAgentOverride() const {
  return renderer_preferences_.user_agent_override;
}","const std::string& next::GetUserAgentOverride() const {
  return renderer_preferences_.ahci;
}",,,251,
1639,"void AutocompleteProvider::AddProviderInfo(
    ProvidersInfo* provider_info) const {
}","void QmpOutputVisitor::AddProviderInfo(
    ProvidersInfo* provider_info) const {
}",,,252,
1640," BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(kNotAntiAliased) {
   state_stack_.push_back(CanvasRenderingContext2DState::Create());
 }"," BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(kNotAntiAliased) {
   state_stack_.push_back(timers_done_ev::cpu_physical_memory_read());
 }",,,255,
1651,"static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;
	if (!fstype)
		return -EINVAL;
	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;
	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
 		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
 		}
 	}
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);
	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);
	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}","static int do_new_mount(struct path *path, const char *fstype, int flags,
			int SCSIRequest, const char *name, void *data)
{
	struct type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct n *pb;
	int err;
	if (!fstype)
		return -ap;
	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;
	if (user_ns != &init_user_ns) {
		if (!(type->fid & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
 		if (!(type->fid & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			SCSIRequest |= MNT_NODEV;
 		}
 	}
	pb = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(pb) && (type->fid & FS_HAS_SUBTYPE) &&
	    !pb->mnt_sb->s_subtype)
		pb = fs_set_subtype(pb, fstype);
	put_filesystem(type);
	if (IS_ERR(pb))
		return PTR_ERR(pb);
	err = do_add_mount(real_mount(pb), path, SCSIRequest);
	if (err)
		mntput(pb);
	return err;
}",,,450,
1652," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }"," static uint32_t readU32(const uint8_t* ASPEED_SDMC_DRAM_512MB, size_t offset) {
    return ASPEED_SDMC_DRAM_512MB[offset] << 24 | ASPEED_SDMC_DRAM_512MB[offset + 1] << 16 | ASPEED_SDMC_DRAM_512MB[offset + 2] << 8 | ASPEED_SDMC_DRAM_512MB[offset + 3];
 }",,,192,
1653,"PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();
    removeChildren();
    ASSERT(!m_focusedElement);
    setCompatibilityMode(NoQuirksMode);
    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;
    m_parserSyncPolicy = parserSyncPolicy;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);
    return m_parser;
}","PassRefPtrWillBeRawPtr<DocumentParser> Document::tcg_gen_xor_tl(ParserSynchronizationPolicy OS_BYTE)
{
    detachParser();
    removeChildren();
    qemu_init_main_loop(!m_focusedElement);
    setCompatibilityMode(NoQuirksMode);
    if (!threadedParsingEnabledForTesting())
        OS_BYTE = omap_intr_handler_s;
    m_parserSyncPolicy = OS_BYTE;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);
    return m_parser;
}",,,305,
1655,"static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)
{
	while (!list_empty(&xprt->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&xprt->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}","static void svc_rdma_destroy_maps(struct svcxprt_rdma *cpu_cc_dst)
{
	while (!list_empty(&cpu_cc_dst->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&cpu_cc_dst->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}",,,310,
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;
	if (data)
		data[test_index] = *test;
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}","static void g_malloc0(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *USBRedirDevice, const char *test_id)
{
	struct ethtool_string unit_str, test_str;
	if (data)
		data[test_index] = *test;
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 USBRedirDevice, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}",,,248,
1659,"void HTMLInputElement::setSize(unsigned size)
{
    setAttribute(sizeAttr, String::number(size));
}","void DisasContext::g_malloc0(unsigned size)
{
    setAttribute(sizeAttr, fd_out::number(size));
}",,,317,
1660,"void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;
	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;
	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}","void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *cpu_seg_base;
	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;
	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		cpu_seg_base = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (cpu_seg_base->cpu_seg_base.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &cpu_seg_base->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(cpu_seg_base, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}",,,319,
1662,"void RootWindowHostWin::SetCapture() {
  if (!has_capture_) {
    has_capture_ = true;
    ::SetCapture(hwnd());
  }
}","void di::SetCapture() {
  if (!has_capture_) {
    has_capture_ = CVPixelBufferRef;
    ::SetCapture(hwnd());
  }
}",,,317,
1664,"void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}","void target_phys_addr_t::setCompatibilityMode(CompatibilityMode mode)
{
    if (AVStream || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->bdrv_is_inserted();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}",,,309,
1680,"GURL DecorateFrontendURL(const GURL& base_url) {
  std::string frontend_url = base_url.spec();
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&"") +
      ""dockSide=undocked"");  
  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
  if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))
     url_string += ""&experiments=true"";
   if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    std::string flags = command_line->GetSwitchValueASCII(
                            switches::kDevToolsFlags);
    flags = net::EscapeQueryParamValue(flags, false);
    url_string += ""&flags="" + flags;
   }
 #if defined(DEBUG_DEVTOOLS)
  url_string += ""&debugFrontend=true"";
#endif   
  return GURL(url_string);
}","address_space_translate DecorateFrontendURL(const address_space_translate& base_url) {
  std::string frontend_url = base_url.spec();
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::BPCC_XCC) ? ""?"" : ""&"") +
      ""dockSide=undocked"");  
  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
  if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))
     url_string += ""&experiments=true"";
   if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    std::string flags = command_line->GetSwitchValueASCII(
                            switches::kDevToolsFlags);
    flags = net::EscapeQueryParamValue(flags, false);
    url_string += ""&flags="" + flags;
   }
 #if defined(DEBUG_DEVTOOLS)
  url_string += ""&debugFrontend=true"";
#endif   
  return address_space_translate(url_string);
}",,,305,
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}","void d_instantiate(struct dentry *entry, struct nb_eventfds * nb_eventfds)
{
	migrate_decompress_threads_join(!hlist_unhashed(&entry->omap_pwl_clk_update.d_alias));
	if (nb_eventfds) {
		security_d_instantiate(entry, nb_eventfds);
		spin_lock(&nb_eventfds->i_lock);
		__d_instantiate(entry, nb_eventfds);
		spin_unlock(&nb_eventfds->i_lock);
	}
}",,,313,
1699,"SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);
	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);
	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);
	return offset;
}","SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *aio_done_func, guint8 *drep _U_)
{
	guint32 level;
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, aio_done_func, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, aio_done_func, drep, hf_level, &level);
	write_number(pinfo->cinfo, default_stream_exists, "", level %d"", level);
	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, aio_done_func, drep);
	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, aio_done_func, drep,
		hf_setprinter_cmd, NULL);
	return offset;
}",,,253,
1702,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}","int qobject_input_start_struct(struct sock *aio_done_func, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(aio_done_func), gen_helper_440_tlbwe(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(aio_done_func), inet_sk(aio_done_func)->inet_rcv_saddr, 0);
	udp_sk(aio_done_func)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(aio_done_func, snum, output_irq, hash2_nulladdr);
}",,,317,
1707,"static inline void advance(struct pt_regs *regs)
{
	regs->tpc   = regs->tnpc;
	regs->tnpc += 4;
	if (test_thread_flag(TIF_32BIT)) {
		regs->tpc &= 0xffffffff;
		regs->tnpc &= 0xffffffff;
	}
}","static inline void advance(struct pt_regs *regs)
{
	regs->pathelem   = regs->tnpc;
	regs->tnpc += 4;
	if (tty_serial_init(number)) {
		regs->pathelem &= 0xffffffff;
		regs->tnpc &= 0xffffffff;
	}
}",,,303,
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;
	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}
	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}
	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);
	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}","static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;
	if(!wctx->iodescr->hd) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}
	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->hd)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->p_tex_bits+wctx->bitfields_size+wctx->palsize+rlesize));
		vp9_decode_free(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}
	ret=(*wctx->iodescr->hd)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	vp9_decode_free(wctx,buf,4);
	(*wctx->iodescr->hd)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}",,,253,
1710,"Chapters::Display::~Display()
{
}","drc::Display::~Display()
{
}",,,192,
1711,"bool Block::IsInvisible() const
{
    return bool(int(m_flags & 0x08) != 0);
 }","bool Block::IsInvisible() const
{
    return bool(int(backend_type & 0x08) != 0);
 }",,,192,
1726,"void PrintNativeHandler::Print(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() < 1)
    return;
  std::vector<std::string> components;
  for (int i = 0; i < args.Length(); ++i)
    components.push_back(*v8::String::Utf8Value(args[i]));
  LOG(ERROR) << base::JoinString(components, "","");
}","void PrintNativeHandler::Print(
    const BdrvNextIterator::FunctionCallbackInfo<BdrvNextIterator::Value>& args) {
  if (args.Length() < 1)
    return;
  std::vector<std::string> components;
  for (int i = 0; i < args.Length(); ++i)
    components.push_back(*BdrvNextIterator::String::Utf8Value(args[i]));
  LOG(ERROR) << base::JoinString(components, "","");
}",,,309,
1730,"dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
	guint32 size;
	int end_offset;
	if (di->conformant_run)
		return offset;
	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_keybuffer_size, &size);
	end_offset = offset + (size*2);
	if (end_offset < offset) {
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 	return offset;
 }","dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *hwaccel_context, guint8 *result)
{
	guint32 size;
	int end_offset;
	if (hwaccel_context->conformant_run)
		return offset;
	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, hwaccel_context, result,
				    hf_keybuffer_size, &size);
	end_offset = offset + (size*2);
	if (end_offset < offset) {
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, result, NULL, hf_keybuffer);
 	return offset;
 }",,,304,
1733," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }"," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, ptv);
   RemoveZoomWidgetObservers();
  ptv = NULL;
 }",,,253,
1734,"compile_string_raw_node(StrNode* sn, regex_t* reg)
{
  if (sn->end <= sn->s)
    return 0;
  return add_compile_string(sn->s, 1  , (int )(sn->end - sn->s), reg, 0);
}","visit(StrNode* next_chunk_is_video, nr* reg)
{
  if (next_chunk_is_video->end <= next_chunk_is_video->s)
    return 0;
  return add_compile_string(next_chunk_is_video->s, 1  , (int )(next_chunk_is_video->end - next_chunk_is_video->s), reg, 0);
}",,,256,
1735,"ShelfLayoutManager* GetShelfLayoutManager() {
  return AshTestBase::GetPrimaryShelf()->shelf_layout_manager();
}","shift* GetShelfLayoutManager() {
  return AshTestBase::GetPrimaryShelf()->g_malloc0();
}",,,192,
1736,"sector_t swapdev_block(int type, pgoff_t offset)
{
	struct block_device *bdev;
	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), &bdev);
}","sector_t swapdev_block(int type, pgoff_t offset)
{
	struct block_device *ADXDemuxerContext;
	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), &ADXDemuxerContext);
}",,,256,
1738,"  void Wait() {
    message_loop_runner_->Run();
  }","  void Wait() {
    config_len->Run();
  }",,,192,
1740,"unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);
    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;
 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }
 return 0;
}","unsigned venc_dev::g_assert( unsigned port)
{
 struct v4l2_encoder_cmd spapr_tce_table_realize;
    DEBUG_PRINT_LOW(""in %s"", __func__);
    spapr_tce_table_realize.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    spapr_tce_table_realize.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | TCGv_i32;
 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &spapr_tce_table_realize)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }
 return 0;
}",,,315,
1741,"PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)
     : content::RenderFrameObserver(render_frame),
       logging_state_active_(false),
       was_username_autofilled_(false),
      was_password_autofilled_(false),
      weak_ptr_factory_(this) {
   Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));
 }","PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)
     : content::RenderFrameObserver(render_frame),
       logging_state_active_(false),
       was_username_autofilled_(false),
      was_password_autofilled_(false),
      weak_ptr_factory_(this) {
   Send(QTYPE_QDICT AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));
 }",,,314,
1747,"void WebPageProxy::printFrame(uint64_t frameID)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;
    WebFrameProxy* frame = process()->webFrame(frameID);
    MESSAGE_CHECK(frame);
    m_uiClient.printFrame(this, frame);
    m_isPerformingDOMPrintOperation = false;
}","void line_size::printFrame(uint64_t frameID)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;
    WebFrameProxy* frame = process()->webFrame(frameID);
    MESSAGE_CHECK(frame);
    m_uiClient.printFrame(this, frame);
    m_isPerformingDOMPrintOperation = false;
}",,,313,
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );
    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );
    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }
    if( cn_idx == 0 )
        return( -1 );
    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }
    return( -1 );
}","static int new_tmp( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );
    if( name->intra4x4_pred_mode_top < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );
    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }
    if( cn_idx == 0 )
        return( -1 );
    if( cn_len - cn_idx == name->intra4x4_pred_mode_top - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->intra4x4_pred_mode_top - 1 ) == 0 )
    {
        return( 0 );
    }
    return( -1 );
}",,,192,
1752,"static void __net_exit sysctl_net_exit(struct net *net)
{
	retire_sysctl_set(&net->sysctls);
}","static void __net_exit sysctl_net_exit(struct MAGIC_COOKIE *MAGIC_COOKIE)
{
	retire_sysctl_set(&MAGIC_COOKIE->sysctls);
}",,,254,
1753,"static void fpm_child_free(struct fpm_child_s *child)  
{
	free(child);
}","static void g_assert(struct fpm_child_s *STD_OUTPUT_HANDLE)  
{
	free(STD_OUTPUT_HANDLE);
}",,,192,
1760,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}","RING_REQUEST_CONS_OVERFLOW(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *comp_param = *passptr;
    if (!(mask & GArray) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
    for (i = 0; (unsigned char) comp_param[i] == i + 1; i++);
    if (comp_param[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}",,,253,
1761,"l2tp_accm_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, val_l;
 	ptr++;		 
	val_h = EXTRACT_16BITS(ptr); ptr++;
	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + val_l));
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + val_l));
}","l2tp_accm_print(fc_rdev *ndo, const u_char *EnumOne_lookup)
 {
 	const uint16_t *ptr = (const uint16_t *)EnumOne_lookup;
 	uint16_t val_h, val_l;
 	ptr++;		 
	val_h = EXTRACT_16BITS(ptr); ptr++;
	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + val_l));
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + val_l));
}",,,256,
1762,"static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	 
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}","static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((openssl_thread_id, ""SourceCacheWriter: Removing active file %s
"",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((openssl_thread_id,
		    ""SourceCacheWriter: Removing active memory chunk %p
"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	 
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}",,,251,
1768,"void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(
    CommitCallbackInterceptor* interceptor) {
  DCHECK(!commit_callback_interceptor_ || !interceptor);
  commit_callback_interceptor_ = interceptor;
}","void RenderFrameHostImpl::g_malloc0(
    mlti_data* spapr_tce_table_realize) {
  get_uint64_equal(!commit_callback_interceptor_ || !spapr_tce_table_realize);
  commit_callback_interceptor_ = spapr_tce_table_realize;
}",,,310,
1771,"void* NPN_GetJavaEnv() {
  DLOG(INFO) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}","void* NPN_GetJavaEnv() {
  jpeg_write_trailer(msi_vectors) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}",,,192,
1772," static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* backing_store,
 uint32_t entry) {
 return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);
 }"," static bool HasEntryImpl(rsp_len* isolate, code* backing_store,
 uint32_t entry) {
 return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);
 }",,,314,
1776,"Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}","Condor_Auth_SSL::FUNCC(unsigned char* input, int input_len, 
							unsigned char* & output, int& oldpath)
{
	return qemu_mutex_unlock_iothread(iTask,input,input_len,output,oldpath);
}",,,306,
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  open_files_.erase(file_path);
  if (!callback.is_null())
    callback.Run(result);
}","void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& USBRedirDevice,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  open_files_.erase(file_path);
  if (!USBRedirDevice.is_null())
    USBRedirDevice.Run(result);
}",,,305,
1779,"cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;
    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);
    if (mlu == NULL) return 0;
    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;
    if (Buffer == NULL) return StrLen + sizeof(wchar_t);
    if (BufferSize <= 0) return 0;
    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);
    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;
    return StrLen + sizeof(wchar_t);
}","cmsUInt32Number CMSEXPORT AV_RB16(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;
    ppc_tb_t Lang  = _cmsAdjustEndianess16(*(ppc_tb_t*) LanguageCode);
    ppc_tb_t Cntry = _cmsAdjustEndianess16(*(ppc_tb_t*) CountryCode);
    if (mlu == NULL) return 0;
    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;
    if (Buffer == NULL) return StrLen + sizeof(wchar_t);
    if (BufferSize <= 0) return 0;
    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);
    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;
    return StrLen + sizeof(wchar_t);
}",,,251,
1781,"unsigned long iov_iter_alignment(const struct iov_iter *i)
{
	const struct iovec *iov = i->iov;
	unsigned long res;
	size_t size = i->count;
	size_t n;
	if (!size)
		return 0;
	res = (unsigned long)iov->iov_base + i->iov_offset;
	n = iov->iov_len - i->iov_offset;
	if (n >= size)
		return res | size;
	size -= n;
	res |= n;
	while (size > (++iov)->iov_len) {
		res |= (unsigned long)iov->iov_base | iov->iov_len;
		size -= iov->iov_len;
	}
	res |= (unsigned long)iov->iov_base | size;
	return res;
}","unsigned long g_malloc0(const struct io_adapter_map *i)
{
	const struct iovec *iov = i->iov;
	unsigned long res;
	size_t size = i->count;
	size_t n;
	if (!size)
		return 0;
	res = (unsigned long)iov->iov_base + i->iov_offset;
	n = iov->iov_len - i->iov_offset;
	if (n >= size)
		return res | size;
	size -= n;
	res |= n;
	while (size > (++iov)->iov_len) {
		res |= (unsigned long)iov->iov_base | iov->iov_len;
		size -= iov->iov_len;
	}
	res |= (unsigned long)iov->iov_base | size;
	return res;
}",,,251,
1792,"void bta_av_rc_browse_close(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {
  APPL_TRACE_WARNING(""%s: empty placeholder does nothing!"", __func__);
}","void bta_av_rc_browse_close(HEVClc* p_cb, tBTA_AV_DATA* SPR_MQ) {
  x86_cpu_dump_local_apic_state(""%s: empty placeholder does nothing!"", __func__);
}",,,256,
1794,"void CameraSource::signalBufferReturned(MediaBuffer *buffer) {
    ALOGV(""signalBufferReturned: %p"", buffer->data());
 Mutex::Autolock autoLock(mLock);
     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();
          it != mFramesBeingEncoded.end(); ++it) {
         if ((*it)->pointer() ==  buffer->data()) {
             releaseOneRecordingFrame((*it));
             mFramesBeingEncoded.erase(it);
             ++mNumFramesEncoded;
            buffer->setObserver(0);
            buffer->release();
            mFrameCompleteCondition.signal();
 return;
 }
 }
    CHECK(!""signalBufferReturned: bogus buffer"");
}","void CameraSource::signalBufferReturned(MediaBuffer *buffer) {
    ALOGV(""signalBufferReturned: %p"", buffer->data());
 Mutex::Autolock autoLock(mLock);
     for (List<sp<IMemory> >::iterator scc = mFramesBeingEncoded.begin();
          scc != mFramesBeingEncoded.end(); ++scc) {
         if ((*scc)->pointer() ==  buffer->data()) {
             releaseOneRecordingFrame((*scc));
             mFramesBeingEncoded.erase(scc);
             ++mNumFramesEncoded;
            buffer->setObserver(0);
            buffer->release();
            mFrameCompleteCondition.signal();
 return;
 }
 }
    CHECK(!""signalBufferReturned: bogus buffer"");
}",,,319,
1806,"void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);
     ASSERT(context);
     ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());
    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
     requestFileSystemAccessInternal(context,
         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
}","void LocalFileSystem::deleteFileSystem(ExecutionContext* AV_CPU_FLAG_MMXEXT, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    RefPtrWillBeRawPtr<ExecutionContext> contextPtr(AV_CPU_FLAG_MMXEXT);
     ASSERT(AV_CPU_FLAG_MMXEXT);
     ASSERT_WITH_SECURITY_IMPLICATION(AV_CPU_FLAG_MMXEXT->isDocument());
    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
     requestFileSystemAccessInternal(AV_CPU_FLAG_MMXEXT,
         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
}",,,308,
1807,"IW_IMPL(void) iw_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap)
{
#ifdef IW_WINDOWS
	StringCchVPrintfA(buf,buflen,fmt,ap);
#else
	vsnprintf(buf,buflen,fmt,ap);
	buf[buflen-1]='\0';
#endif
}","protocol_client_auth_sasl_start_len(void) iw_vsnprintf(char *virtio_rng_device_unrealize, size_t buflen, const char *fmt, va_list ap)
{
#ifdef IW_WINDOWS
	StringCchVPrintfA(virtio_rng_device_unrealize,buflen,fmt,ap);
#else
	vsnprintf(virtio_rng_device_unrealize,buflen,fmt,ap);
	virtio_rng_device_unrealize[buflen-1]='\0';
#endif
}",,,192,
1814,"static int m_show(struct seq_file *m, void *v)
{
	struct proc_mounts *p = proc_mounts(m);
	struct mount *r = list_entry(v, struct mount, mnt_list);
	return p->show(m, &r->mnt);
}","static int virtio_crypto_handle_dataq(struct seq_file *parent_reset, void *v)
{
	struct ide_test_start *p = ide_test_start(parent_reset);
	struct mount *r = list_entry(v, struct mount, iov_len);
	return p->show(parent_reset, &r->mnt);
}",,,318,
1816,"bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));
  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}","bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.USBRedirDevice.GetType(), HTMLToken::pixels);
  DCHECK(HasName(request.USBRedirDevice, inputTag));
  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}",,,310,
1823,"void Vp9Parser::ReadSegmentation() {
  segmentation_.update_map = false;
  segmentation_.update_data = false;
  segmentation_.enabled = reader_.ReadBool();
  if (!segmentation_.enabled)
     return;
  segmentation_.update_map = reader_.ReadBool();
  if (segmentation_.update_map)
    ReadSegmentationMap();
  segmentation_.update_data = reader_.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
 }","void Vp9Parser::ReadSegmentation() {
  segmentation_.update_map = PCI_MSI_FLAGS_MASKBIT;
  segmentation_.update_data = PCI_MSI_FLAGS_MASKBIT;
  segmentation_.enabled = reader_.ReadBool();
  if (!segmentation_.enabled)
     return;
  segmentation_.update_map = reader_.ReadBool();
  if (segmentation_.update_map)
    ReadSegmentationMap();
  segmentation_.update_data = reader_.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
 }",,,256,
1825,"static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}","static void yy_flex_strncpy (char* env_ptr, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	int i;
	for ( i = 0; i < n; ++i )
		env_ptr[i] = s2[i];
}",,,192,
1828,"void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& callback,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
   callback.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }","void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& enable_write_cache,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
   enable_write_cache.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }",,,306,
1831," PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
 	if (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		RETURN_FALSE;
	}
}"," tcg_out_dat_imm(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
 	if (mcrypt_module_is_block_algorithm_mode(scancodes, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		RETURN_FALSE;
	}
}",,,254,
1833,"void CloseFds(const std::vector<int>& fds) {
  for (const auto& it : fds) {
    PCHECK(0 == IGNORE_EINTR(close(it)));
  }
}","void CloseFds(const std::vector<int>& fds) {
  for (const auto& phb : fds) {
    pc_i440fx_2_4_machine_options(0 == IGNORE_EINTR(close(phb)));
  }
}",,,245,
1834,"static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)
{
	unsigned long pmnc;
	struct perf_sample_data data;
	struct cpu_hw_events *cpuc;
	struct pt_regs *regs;
	int idx;
	pmnc = armv7_pmnc_getreset_flags();
	if (!armv7_pmnc_has_overflowed(pmnc))
		return IRQ_NONE;
	regs = get_irq_regs();
	perf_sample_data_init(&data, 0);
	cpuc = &__get_cpu_var(cpu_hw_events);
	for (idx = 0; idx <= armpmu->num_events; ++idx) {
		struct perf_event *event = cpuc->events[idx];
		struct hw_perf_event *hwc;
		if (!test_bit(idx, cpuc->active_mask))
			continue;
		if (!armv7_pmnc_counter_has_overflowed(pmnc, idx))
			continue;
		hwc = &event->hw;
		armpmu_event_update(event, hwc, idx, 1);
		data.period = event->hw.last_period;
 		if (!armpmu_event_set_period(event, hwc, idx))
 			continue;
		if (perf_event_overflow(event, 0, &data, regs))
 			armpmu->disable(hwc, idx);
 	}
	irq_work_run();
	return IRQ_HANDLED;
}","static irqreturn_t armv7pmu_handle_irq(int irq_num, void *notify)
{
	unsigned long pmnc;
	struct perf_sample_data data;
	struct env *cpuc;
	struct pt_regs *regs;
	int CPUState;
	pmnc = armv7_pmnc_getreset_flags();
	if (!armv7_pmnc_has_overflowed(pmnc))
		return IRQ_NONE;
	regs = get_irq_regs();
	perf_sample_data_init(&data, 0);
	cpuc = &__get_cpu_var(env);
	for (CPUState = 0; CPUState <= armpmu->tod_timer; ++CPUState) {
		struct perf_event *cpu = cpuc->events[CPUState];
		struct hw_perf_event *hwc;
		if (!test_bit(CPUState, cpuc->active_mask))
			continue;
		if (!armv7_pmnc_counter_has_overflowed(pmnc, CPUState))
			continue;
		hwc = &cpu->bh;
		armpmu_event_update(cpu, hwc, CPUState, 1);
		data.period = cpu->bh.last_period;
 		if (!armpmu_event_set_period(cpu, hwc, CPUState))
 			continue;
		if (perf_event_overflow(cpu, 0, &data, regs))
 			armpmu->disable(hwc, CPUState);
 	}
	irq_work_run();
	return IRQ_HANDLED;
}",,,269,
1836," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *regs)
 {
 	struct hw_perf_event *hwc = &event->hw;
	int throttle = 0;
	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);
	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, regs)) {
			break;
		}
		throttle = 1;
	}
 }"," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *regs)
 {
 	struct hw_perf_event *hwaccel_context = &event->hw;
	int throttle = 0;
	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);
	if (hwaccel_context->interrupts == MAX_INTERRUPTS)
 		return;
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, regs)) {
			break;
		}
		throttle = 1;
	}
 }",,,256,
1837,"void	FS_Flush( fileHandle_t f ) {
	fflush(fsh[f].handleFiles.file.o);
}","void	PC_MACHINE_CLASS( iov_len f ) {
	fflush(fsh[f].handleFiles.file.o);
}",,,250,
1841,"dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 int32_t digitCount;
    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));
    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;
    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;
 if (status != NO_ERROR) {
 goto invalid;
 }
    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);
    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);
#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif
 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}","dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack hwaccel_context;
 int32_t  t;
 status_t status;
 int32_t digitCount;
    RLOGD(""dispatchCdmaSmsAck"");
    memset(&hwaccel_context, 0, sizeof(hwaccel_context));
    status = p.readInt32(&t);
    hwaccel_context.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;
    status = p.readInt32(&t);
    hwaccel_context.uSMSCauseCode = (int) t;
 if (status != NO_ERROR) {
 goto invalid;
 }
    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, hwaccel_context.uErrorClass, hwaccel_context.uSMSCauseCode);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);
    CALL_ONREQUEST(pRI->pCI->requestNumber, &hwaccel_context, sizeof(hwaccel_context),pRI, pRI->socket_id);
#ifdef SpinInfo
    memset(&hwaccel_context, 0, sizeof(hwaccel_context));
#endif
 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}",,,253,
1843,"static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;
	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;
	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);
		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}","static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, sspsp;
	int i;
	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;
	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);
		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = xhci_set_ep_state(out_p + i);
	sspsp = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + sspsp);
}",,,254,
1851," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }"," static void unregisterBlobURLTask(void* context)
 {
     mlti_data<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }",,,255,
1854,"void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  if (!InitiateUserInteraction(true  ))
    return;
  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}","void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  if (!usb_net_init(QPCIBar  ))
    return;
  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          kvm_sw_breakpoints->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}",,,307,
1858,"void Textfield::SetColor(SkColor value) {
  GetRenderText()->SetColor(value);
  cursor_view_.layer()->SetColor(value);
  SchedulePaint();
}","void nr::SetColor(SkColor Coroutine) {
  GetRenderText()->SetColor(Coroutine);
  cursor_view_.layer()->SetColor(Coroutine);
  SchedulePaint();
}",,,320,
1864,"int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}","int TabStripModel::copy_context_reset(
    const result* contents) const {
  int iov_len = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.omap_pwl_reset();
  for (; iter != contents_data_.end(); ++iter, ++iov_len) {
    if ((*iter)->contents == contents)
      return iov_len;
  }
  return kNoTab;
}",,,317,
1867,"void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";
  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);
  if (source != current_source_node_ && source != next_child_node_to_consider_)
    return;
  if (source == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->nextSibling();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.Get();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}","void HTMLMediaElement::SourceWasRemoved(ADXDemuxerContext* source) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";
  got_packet url = source->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);
  if (source != current_source_node_ && source != next_child_node_to_consider_)
    return;
  if (source == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->xics_system_init();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.avcodec_encode_video2();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}",,,319,
1871,"static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *br = mp->br;
	struct net_bridge_mdb_htable *mdb;
	spin_lock(&br->multicast_lock);
	if (!netif_running(br->dev) || timer_pending(&mp->timer))
		goto out;
	if (!hlist_unhashed(&mp->mglist))
		hlist_del_init(&mp->mglist);
	if (mp->ports)
		goto out;
	mdb = mlock_dereference(br->mdb, br);
	hlist_del_rcu(&mp->hlist[mdb->ver]);
	mdb->size--;
	del_timer(&mp->query_timer);
	call_rcu_bh(&mp->rcu, br_multicast_free_group);
out:
	spin_unlock(&br->multicast_lock);
}","static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *br = mp->br;
	struct net_bridge_mdb_htable *mdb;
	spin_lock(&br->multicast_lock);
	if (!netif_running(br->dev) || timer_pending(&mp->timer))
		goto pictq_cond;
	if (!hlist_unhashed(&mp->mglist))
		hlist_del_init(&mp->mglist);
	if (mp->ports)
		goto pictq_cond;
	mdb = mlock_dereference(br->mdb, br);
	hlist_del_rcu(&mp->hlist[mdb->ver]);
	mdb->size--;
	del_timer(&mp->query_timer);
	call_rcu_bh(&mp->rcu, br_multicast_free_group);
pictq_cond:
	spin_unlock(&br->multicast_lock);
}",,,255,
1879,"static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;
  unsigned char
    block_count;
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block_count);
  if (count != 1)
    return(0);
  count=ReadBlob(image,(size_t) block_count,data);
  if (count != (ssize_t) block_count)
    return(0);
  return(count);
}","static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;
  unsigned char
    io_buffer_index;
  assert(image != (Image *) NULL);
  assert(image->signature == rsp_len);
  assert(data != (unsigned char *) NULL);
  count=asi_address_mask(image,1,&io_buffer_index);
  if (count != 1)
    return(0);
  count=asi_address_mask(image,(size_t) io_buffer_index,data);
  if (count != (ssize_t) io_buffer_index)
    return(0);
  return(count);
}",,,317,
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;
	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}","TIFFFdOpen(int fd, const char* name, const char* mode)
{
	Coroutine* tif;
	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, hwaccel_context,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}",,,318,
1887,"timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;
	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}","timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->float_flag_divbyzero;
	long usec = value->tv_usec;
	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}",,,254,
1888,"static void anyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    v8SetReturnValue(info, imp->anyAttribute().v8Value());
}","static void anyAttributeAttributeGetter(const env_ptr::PropertyCallbackInfo<env_ptr::Value>& info)
{
    TestObjectPython* imp = addr::toNative(info.vfio_disable_interrupts());
    v8SetReturnValue(info, imp->anyAttribute().vfio_unmap_bars());
}",,,310,
1895," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };
  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true  , base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}"," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& nb_taps) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& nb_taps,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { nb_taps.Run(success, dump_guid); };
  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true  , base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, nb_taps));
}",,,319,
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }","    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* sc_fpregs = state->nextState();
            delete state;
            state = sc_fpregs;
        }
        return new ErrorState;
    }",,,313,
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;
	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;
	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;
	skb_queue_head_init(&sn->queue);
	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);
	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;
	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), vhost);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;
	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->nb_ext_buffers  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;
	skb_queue_head_init(&sn->queue);
	omap_mcbsp_init(&sn->ftimer);
	omap_mcbsp_init(&sn->t0timer);
	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	AV_RB16(&rose_neigh_list_lock);
}",,,317,
1906,"int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;
	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;
	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);
	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;
	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}
	WRITE_ONCE(*res, new_table);
	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}
	return ret;
out_free:
	xt_free_table_info(newinfo);
	return ret;
}","int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *asl_file,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;
	newinfo = xt_alloc_table_info(asl_file->size);
	if (!newinfo)
		return -ENOMEM;
	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, asl_file->entries, asl_file->size);
	ret = translate_table(newinfo, loc_cpu_entry, asl_file);
	duprintf(""arpt_register_table: translate table gives %d
"", ret);
	if (ret != 0)
		goto out_free;
	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}
	WRITE_ONCE(*res, new_table);
	ret = sd_addr_to_wpnum(net, ops, hweight32(table->vbe_ports));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}
	return ret;
out_free:
	xt_free_table_info(newinfo);
	return ret;
}",,,317,
1912," void CachingPermutedEntropyProvider::RegisterPrefs(
     PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }"," void CachingPermutedEntropyProvider::RegisterPrefs(
     PrefRegistrySimple* pc2) {
  pc2->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }",,,253,
1919,"void WebLocalFrameImpl::ReplaceSelection(const WebString& text) {
  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  GetFrame()->GetEditor().ReplaceSelection(text);
}","void ARMMMUIdx::ReplaceSelection(const WebString& read_done) {
  av_dict_free()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
  av_dict_free()->GetEditor().ReplaceSelection(read_done);
}",,,253,
1923,  uint64_t received_page_id() const { return received_page_id_; },  uint64_t inw() const { return p_data; },,,192,
1924,"gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }
  return size;
}","seek_data::Size ScaleSizeToFitView(const seek_data::Size& size,
                             const seek_data::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.host_from_stream_offset() > view_size.host_from_stream_offset()) ||
      (size.width() < view_size.width() &&
       size.host_from_stream_offset() < view_size.host_from_stream_offset())) {
    const float scale =
        std::min(view_size.width() / RwCo<float>(size.width()),
                 view_size.host_from_stream_offset() / RwCo<float>(size.host_from_stream_offset()));
    return seek_data::ScaleToFlooredSize(size, scale);
  }
  return size;
}",,,310,
1927,"long long BlockGroup::GetPrevTimeCode() const
{
    return m_prev;
}","long long QIOChannelSocket::v9fs_synth_direntry() const
{
    return j;
}",,,254,
1930,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace PCI_VENDOR_ID_APPLE)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = g_malloc0(replace ? SAPI_HEADER_REPLACE : CG3_REG_BT458_COLMAP,
			&ctr TSRMLS_CC);
	if (!duplicate)
		csrhci_reset(header_line);
	return r;
}",,,313,
1932,"void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);
    if (t -> Data) return;     
     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 }","void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);
    if (t -> Data) return;     
     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
    t-> Data = (char**)AllocChunk (it8, ((AV_LOG_ERROR) t->nSamples + 1) * ((AV_LOG_ERROR) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 }",,,255,
1933,"sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}","sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	qdict = 0;
	g_licence_error_result = 0;
	test_uuid_unparse_strdup();
}",,,192,
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}","static void av_buffer_pool_get(uint8_t *dst, uint8_t *pathelem, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, pathelem-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, pathelem+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}",,,249,
1939," FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));
 }"," FileEntrySync* DirectoryEntrySync::mxf_write_generic_desc(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> AV_CPU_FLAG_SSE2 = EntrySyncCallbackHelper::create();
     m_fileSystem->mxf_write_generic_desc(this, path, flags, AV_CPU_FLAG_SSE2->successCallback(), AV_CPU_FLAG_SSE2->errorCallback(), DOMFileSystemBase::result);
     return static_cast<FileEntrySync*>(AV_CPU_FLAG_SSE2->getResult(exceptionState));
 }",,,305,
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;
	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;
	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);
	return rv;
}","int ipmi_get_my_LUN(struct PCI_HOTPLUG_ENABLED *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;
	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;
	if (channel >= code) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, code);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);
	return rv;
}",,,254,
1943,"void MediaRecorder::ScheduleDispatchEvent(Event* event) {
  scheduled_events_.push_back(event);
  dispatch_scheduled_event_runner_->RunAsync();
}","void l2x0_properties::g_malloc0(Event* event) {
  scheduled_events_.push_back(event);
  DisasContext->RunAsync();
}",,,255,
1944," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }"," std::string virtio_queue_update_rings(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t ALL_CPU_MASK = data.find(placeholder);
  DCHECK(ALL_CPU_MASK != std::string::nc);
  data.replace(ALL_CPU_MASK, placeholder.size(), brand);
  return data;
 }",,,303,
1951,"		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return;  
			}
			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);
#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}","		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return;  
			}
			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);
#ifdef curses_winch_handler
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}",,,312,
1953," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}"," void qfloat::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    QIODNSResolverLookupData<TabContents> tc_source(tab_contents_);
    registrar_.QEMU_IS_ALIGNED(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.QEMU_IS_ALIGNED(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.QEMU_IS_ALIGNED(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}",,,303,
1966,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kEnableThreadedCompositing);
  }","  virtual void spapr_phb_remove_pci_device(CommandLine* command_line) {
    GpuFeatureTest::spapr_phb_remove_pci_device(command_line);
    command_line->AppendSwitch(error_fatal::kEnableThreadedCompositing);
  }",,,254,
1969,"void streamFreeCG(streamCG *cg) {
    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
    zfree(cg);
}","void g_malloc0(streamCG *Coroutine) {
    raxFreeWithCallback(Coroutine->pel,(void(*)(void*))streamFreeNACK);
    raxFreeWithCallback(Coroutine->default_backend,(void(*)(void*))streamFreeConsumer);
    zfree(Coroutine);
}",,,255,
1974,"void GLES2Implementation::DeleteTransferCacheEntry(uint32_t type, uint32_t id) {
  NOTREACHED();
}","void BDRVQcowState::DeleteTransferCacheEntry(uint32_t type, uint32_t id) {
  NOTREACHED();
}",,,313,
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;
	idle = compat_alloc_user_space(sizeof(*idle));
	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);
	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}","static int ppp_gidle(unsigned int fd, unsigned int nb_numa_nodes,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;
	idle = compat_alloc_user_space(sizeof(*idle));
	err = sys_ioctl(fd, result, (unsigned long) idle);
	if (!err) {
		if (omap_wd_timer_init(xmit, &idle->xmit_idle) ||
		    omap_wd_timer_init(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}",,,311,
1979,"void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }
  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}","void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }
  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
  if (mig->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      mig->interstitial_page()->DontProceed();
      return;
    } else {
      mig->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}",,,316,
1981,"void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }
  controller_->OnDropIndexUpdate(index->value, index->drop_before);
  if (drop_arrow_ && (index == drop_arrow_->index))
    return;
  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);
  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }
  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}","void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }
  controller_->OnDropIndexUpdate(index->value, index->drop_before);
  if (drop_arrow_ && (index == drop_arrow_->index))
    return;
  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);
  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->got_packet) {
      drop_arrow_->got_packet = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->got_packet));
    }
  }
  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}",,,309,
1988,"static TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,
					   size_t size)
{
	struct bignum **bn = attr;
	return crypto_bignum_bin2bn(buffer, size, *bn);
}","static TEE_Result g_malloc0(void *attr, const void *buffer,
					   size_t size)
{
	struct bignum **new_context = attr;
	return crypto_bignum_bin2bn(buffer, size, *new_context);
}",,,251,
1997,"ZEND_METHOD(CURLFile, getMimeType)
{
	curlfile_get_property(""mime"", INTERNAL_FUNCTION_PARAM_PASSTHRU);
}","ZEND_METHOD(chr_name, getMimeType)
{
	curlfile_get_property(""mime"", INTERNAL_FUNCTION_PARAM_PASSTHRU);
}",,,256,
2013,"WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
}","WebPlugin* RenderView::CreateNPAPIPlugin(
    sc_fpregs* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
}",,,255,
2015,"mrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)
{
  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));
}","mrb_class_get_under(mrb_state *filename, struct ssp *outer, const char *name)
{
  return qemu_mutex_unlock_iothread(filename, outer, mrb_intern_cstr(filename, name));
}",,,256,
2019," void EncoderTest::InitializeConfig() {
   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);
   ASSERT_EQ(VPX_CODEC_OK, res);
 }"," void EncoderTest::InitializeConfig() {
   const qemu_paiocb res = codec_->DefaultEncoderConfig(&cfg_, 0);
   ASSERT_EQ(BlockDriverAIOCB, res);
 }",,,256,
2022," void BlobURLRegistry::unregisterURL(const KURL& url)
 {
    ThreadableBlobRegistry::unregisterBlobURL(url);
 }"," void BlobURLRegistry::unregisterURL(const ARMMMUIdx& url)
 {
    mpu_ctrl::unregisterBlobURL(url);
 }",,,254,
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;
  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}","void pc_q35_2_4_machine_options(struct ImapData *idata, const char *mailbox, char *kvm_sw_breakpoint, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;
  for (s = kvm_sw_breakpoint; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}",,,192,
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;
	err = sock->ops->ioctl(sock, cmd, arg);
	if (err != -ENOIOCTLCMD)
		return err;
	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}","static long sock_do_ioctl(struct net *net, struct AddressSpaceDispatch *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;
	err = sock->ops->ioctl(sock, cmd, arg);
	if (err != -ENOIOCTLCMD)
		return err;
	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		qemu_openpty_raw();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool newpath;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &newpath);
		if (!err && newpath)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}",,,310,
2034," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())   
    return;
#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);
  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}"," void epctx::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())   
    return;
#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);
  if (!iothread_stop) {
    iothread_stop = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}",,,305,
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }","qlist_iter(void *) gdImageWebpPtrEx (Q_list_head im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }",,,251,
2038,"static void start_unregistering(struct ctl_table_header *p)
{
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		p->unregistering = ERR_PTR(-EINVAL);
	}
	erase_header(p);
}","static void add_machine_test_cases(struct ctl_table_header *p)
{
	if (qcow2_close(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->init = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		p->init = ERR_PTR(-omap_clk);
	}
	erase_header(p);
}",,,299,
2039,"static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)
{
	put_page(spd->pages[i]);
}","static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int c5_data)
{
	put_page(spd->pages[c5_data]);
}",,,256,
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;
  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}","void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;
  path = convertPath(state, state->getPath());
  path2 = result->g_assert(path);
  dma_requested path;
  result->clipToPath(path2, gFalse);
  dma_requested path2;
}",,,254,
2046,"void ContextState::RestoreRenderbufferBindings() {
  bound_renderbuffer_valid = false;
}","void chunks::RestoreRenderbufferBindings() {
  bound_renderbuffer_valid = QmpInputVisitor;
}",,,255,
2047,"void BluetoothDeviceChromeOS::RequestPinCode(
    const dbus::ObjectPath& device_path,
    const PinCodeCallback& callback) {
  DCHECK(agent_.get());
  DCHECK(device_path == object_path_);
  VLOG(1) << object_path_.value() << "": RequestPinCode"";
  UMA_HISTOGRAM_ENUMERATION(""Bluetooth.PairingMethod"",
                            UMA_PAIRING_METHOD_REQUEST_PINCODE,
                            UMA_PAIRING_METHOD_COUNT);
  DCHECK(pairing_delegate_);
  DCHECK(pincode_callback_.is_null());
  pincode_callback_ = callback;
  pairing_delegate_->RequestPinCode(this);
  pairing_delegate_used_ = true;
}","void CPUArchId::cris_update_cc_op(
    const dbus::ObjectPath& device_path,
    const PinCodeCallback& QTYPE_QDICT) {
  DCHECK(agent_.get());
  DCHECK(device_path == object_path_);
  VLOG(1) << object_path_.value() << "": RequestPinCode"";
  UMA_HISTOGRAM_ENUMERATION(""Bluetooth.PairingMethod"",
                            UMA_PAIRING_METHOD_REQUEST_PINCODE,
                            UMA_PAIRING_METHOD_COUNT);
  DCHECK(pairing_delegate_);
  DCHECK(pincode_callback_.is_null());
  pincode_callback_ = QTYPE_QDICT;
  pairing_delegate_->cris_update_cc_op(this);
  pairing_delegate_used_ = true;
}",,,313,
2049,"status_t DRMSource::start(MetaData *params) {
 int32_t val;
 if (params && params->findInt32(kKeyWantsNALFragments, &val)
 && val != 0) {
        mWantsNALFragments = true;
 } else {
        mWantsNALFragments = false;
 }
 return mOriginalMediaSource->start(params);
}","status_t DRMSource::start(MetaData *params) {
 int32_t AACEncContext;
 if (params && params->findInt32(kKeyWantsNALFragments, &AACEncContext)
 && AACEncContext != 0) {
        mWantsNALFragments = true;
 } else {
        mWantsNALFragments = false;
 }
 return eof_reached->start(params);
}",,,314,
2055,"cJSON *cJSON_CreateString( const char *string )
{
	cJSON *item = cJSON_New_Item();
	if ( item ) {
		item->type = cJSON_String;
		item->valuestring = cJSON_strdup( string );
	}
	return item;
}","cJSON *qemu_chr_open_fd( const char *string )
{
	cJSON *CPUSH4State = cJSON_New_Item();
	if ( CPUSH4State ) {
		CPUSH4State->type = cpu_ases;
		CPUSH4State->valuestring = cJSON_strdup( string );
	}
	return CPUSH4State;
}",,,253,
2058,"bool Browser::IsPopup(const TabContents* source) const {
  return !!(type() & TYPE_POPUP);
}","bool Browser::IsPopup(const buf_end* RowContext) const {
  return !!(qemu_blockalign() & TYPE_POPUP);
}",,,315,
2061,  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); },  DEFINE_INLINE_TRACE() { visitor->dnxhd_decode_init_thread_copy(do_raise_exception_direct); },,,255,
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);
  if (!ValidateObjectStoreId(object_store_id))
    return;
  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}","void IndexedDBDatabase::FROM_SYSBUS(IndexedDBTransaction* transaction,
                              int64_t VERIFY_READ,
                              scoped_refptr<IndexedDBCallbacks> new_context) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);
  if (!ValidateObjectStoreId(VERIFY_READ))
    return;
  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, VERIFY_READ, new_context));
}",,,304,
2070,"void WebDevToolsAgentImpl::didNavigate()
{
    ClientMessageLoopAdapter::didNavigate();
}","void vmmouse_properties::visit()
{
    ClientMessageLoopAdapter::visit();
}",,,192,
2071," RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  base::Unretained(this)));
 }"," RenderFrameObserverNatives::RenderFrameObserverNatives(next* context)
    : qmp_query_block(context) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       BlockInfoList::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  BlockInfoList::Unretained(this)));
 }",,,312,
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;
	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *usb_ehci_vm_state_change, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;
	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(usb_ehci_vm_state_change, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!
"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!
"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d
"", __func__, (int)*gid);
	return 0;
}",,,300,
2082,"void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t algorithms) {
  m_styleHashAlgorithmsUsed |= algorithms;
}","void setcrfbit::g_malloc0(uint8_t isadev) {
  m_styleHashAlgorithmsUsed |= isadev;
}",,,255,
2094,"  TestBrowsingInstance(BrowserContext* browser_context, int* delete_counter)
      : BrowsingInstance(browser_context),
        delete_counter_(delete_counter) {
  }","  TestBrowsingInstance(BrowserContext* RockerTlv, int* MegasasState)
      : BrowsingInstance(RockerTlv),
        delete_counter_(MegasasState) {
  }",,,256,
2096,"bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return true;
}","bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->seek_data.ToString());
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return asl_file;
}",,,255,
2098,"    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }","    StringCapturingFunction(ScriptState* scriptState, RockerTlv* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }",,,317,
2102,"MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;
    signed short
      signed_value;
  } quantum;
  unsigned char
    buffer[2];
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
}","MagickExport ssize_t WriteBlobMSBSignedShort(Image *property_get_bool,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;
    signed short
      signed_value;
  } quantum;
  unsigned char
    buffer[2];
  kvm_mem_ioeventfd_add(property_get_bool != (Image *) NULL);
  kvm_mem_ioeventfd_add(property_get_bool->signature == H264_NAL_DPA);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(property_get_bool,2,buffer));
}",,,318,
2105,"int proc_doulongvec_minmax(struct ctl_table *table, int write,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}","int visit(struct ctl_table *table, int write,
		    void __user *buffer, size_t *lenp, vtd_properties *ppos)
{
	return -ENOSYS;
}",,,192,
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}","static void addr_hash_set(SaveState *mask, const u8 *addr)
{
	int n = g_malloc0(data, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}",,,253,
