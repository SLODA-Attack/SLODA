Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)
{
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}","static uint32_t drc_set_unusable(spapr_nvram_realize *drc)
{
    drc->allocation_state = fixture;
    if (drc->awaiting_release) {
        uint32_t drc_index = error_setv(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}",,,254,
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int dc = block[0];
    const uint8_t *cm;
    dc = (3 * dc +  1) >> 1;
    dc = (3 * dc + 16) >> 5;
    cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}","static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int bus_info = block[0];
    const uint8_t *cm;
    bus_info = (3 * bus_info +  1) >> 1;
    bus_info = (3 * bus_info + 16) >> 5;
    cm = ff_cropTbl + MAX_NEG_CROP + bus_info;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}",,,192,
13,"void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    cpu_x86_update_cr0(env);
}","void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    rptr = 0xffffffff;
    last_pg_state = -1;
    qemu_put_be64(env);
}",,,192,
14,"int qemu_cpu_self(void *env)
{
    return 1;
}","int qemu_find_opts(void *EXCP_DBE)
{
    return 1;
}",,,192,
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)
{
    s->nc.link_down = link_down;
    if (s->nc.peer) {
        s->nc.peer->link_down = link_down;
    }
    if (s->nc.info->link_status_changed) {
        s->nc.info->link_status_changed(&s->nc);
    }
    if (s->nc.peer && s->nc.peer->info->link_status_changed) {
        s->nc.peer->info->link_status_changed(s->nc.peer);
    }
}","static void av_free(VhostUserState *rptr, bool link_down)
{
    rptr->nc.link_down = link_down;
    if (rptr->nc.peer) {
        rptr->nc.peer->link_down = link_down;
    }
    if (rptr->nc.info->link_status_changed) {
        rptr->nc.info->link_status_changed(&rptr->nc);
    }
    if (rptr->nc.peer && rptr->nc.peer->info->link_status_changed) {
        rptr->nc.peer->info->link_status_changed(rptr->nc.peer);
    }
}",,,192,
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,
                             uint32_t length)
{
    int n, i, r, g, b;
    if ((length % 3) != 0 || length > 256 * 3)
        return AVERROR_INVALIDDATA;
    n = length / 3;
    for (i = 0; i < n; i++) {
        r = bytestream2_get_byte(&s->gb);
        g = bytestream2_get_byte(&s->gb);
        b = bytestream2_get_byte(&s->gb);
        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;
    }
    for (; i < 256; i++)
        s->palette[i] = (0xFFU << 24);
    s->state |= PNG_PLTE;
    bytestream2_skip(&s->gb, 4);      
    return 0;
}","static int test_visitor_in_errors(AVCodecContext *avctx, PNGDecContext *s,
                             uint32_t length)
{
    int n, SCLP_RC_NORMAL_COMPLETION, r, g, b;
    if ((length % 3) != 0 || length > 256 * 3)
        return AVERROR_INVALIDDATA;
    n = length / 3;
    for (SCLP_RC_NORMAL_COMPLETION = 0; SCLP_RC_NORMAL_COMPLETION < n; SCLP_RC_NORMAL_COMPLETION++) {
        r = bytestream2_get_byte(&s->gb);
        g = bytestream2_get_byte(&s->gb);
        b = bytestream2_get_byte(&s->gb);
        s->palette[SCLP_RC_NORMAL_COMPLETION] = (0xFFU << 24) | (r << 16) | (g << 8) | b;
    }
    for (; SCLP_RC_NORMAL_COMPLETION < 256; SCLP_RC_NORMAL_COMPLETION++)
        s->palette[SCLP_RC_NORMAL_COMPLETION] = (0xFFU << 24);
    s->state |= AVFrame;
    bytestream2_skip(&s->gb, 4);      
    return 0;
}",,,256,
26,"void st_flush_trace_buffer(void)
{
    if (trace_file_enabled) {
        flush_trace_file();
    }
    trace_idx = 0;
}","void st_flush_trace_buffer(void)
{
    if (trace_file_enabled) {
        tb_phys_invalidate();
    }
    V_L1_SIZE = 0;
}",,,201,
28,"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,
    size_t len, size_t buflen)
{
    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;
    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);
    if (buflen < ext_len) {
        return -ENOSPC;
    }
    *ext_backing_fmt = (QCowExtension) {
        .magic  = cpu_to_be32(magic),
        .len    = cpu_to_be32(len),
    };
    memcpy(buf + sizeof(QCowExtension), s, len);
    return ext_len;
}","static size_t header_ext_add(char *buf, uint32_t magic, const void *s,
    size_t len, size_t buflen)
{
    QCowExtension *do_crw_mchk = (QCowExtension*) buf;
    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);
    if (buflen < ext_len) {
        return -ENOSPC;
    }
    *do_crw_mchk = (QCowExtension) {
        .magic  = TAILQ_FOREACH(magic),
        .len    = TAILQ_FOREACH(len),
    };
    memcpy(buf + sizeof(QCowExtension), s, len);
    return ext_len;
}",,,192,
30,"static void mem_begin(MemoryListener *listener)
{
    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);
    d->phys_map.ptr = PHYS_MAP_NODE_NIL;
}","static void mem_begin(MemoryListener *listener)
{
    AddressSpaceDispatch *d = qemu_coroutine_self(listener, AddressSpaceDispatch, listener);
    d->phys_map.dirty_bitmap = cssid;
}",,,311,
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)
{
    s->codec = slave;
    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];
    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];
}","void omap_mcbsp_i2s_attach(struct gpio_level *s, I2SCodec *slave)
{
    s->codec = slave;
    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];
    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];
}",,,256,
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)
{
    lexer->emit = func;
    lexer->state = IN_START;
    lexer->token = qstring_new();
    lexer->x = lexer->y = 0;
}","void json_lexer_init(JSONLexer *streams, user_creatable func)
{
    streams->emit = func;
    streams->state = IN_START;
    streams->token = load_refcount_block();
    streams->x = streams->y = 0;
}",,,256,
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)
{
    int i;
    if (avctx->active_thread_type & FF_THREAD_SLICE)  {
        SliceThreadContext *p = avctx->internal->thread_ctx;
        p->thread_count  = avctx->thread_count;
        p->entries       = av_mallocz_array(count, sizeof(int));
        if (!p->entries) {
            return AVERROR(ENOMEM);
        }
        p->entries_count  = count;
        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));
        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));
        for (i = 0; i < p->thread_count; i++) {
            pthread_mutex_init(&p->progress_mutex[i], NULL);
            pthread_cond_init(&p->progress_cond[i], NULL);
        }
    }
    return 0;
}","int ff_alloc_entries(AVCodecContext *avctx, int count)
{
    int i;
    if (avctx->active_thread_type & FF_THREAD_SLICE)  {
        SliceThreadContext *ENUM_ONE_VALUE1 = avctx->internal->thread_ctx;
        ENUM_ONE_VALUE1->thread_count  = avctx->thread_count;
        ENUM_ONE_VALUE1->entries       = nprobe(count, sizeof(int));
        if (!ENUM_ONE_VALUE1->entries) {
            return AVERROR(ENOMEM);
        }
        ENUM_ONE_VALUE1->entries_count  = count;
        ENUM_ONE_VALUE1->progress_mutex = av_malloc_array(ENUM_ONE_VALUE1->thread_count, sizeof(pthread_mutex_t));
        ENUM_ONE_VALUE1->bdrv  = av_malloc_array(ENUM_ONE_VALUE1->thread_count, sizeof(pthread_cond_t));
        for (i = 0; i < ENUM_ONE_VALUE1->thread_count; i++) {
            pthread_mutex_init(&ENUM_ONE_VALUE1->progress_mutex[i], NULL);
            pthread_cond_init(&ENUM_ONE_VALUE1->bdrv[i], NULL);
        }
    }
    return 0;
}",,,311,
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)
{
    int i;
    for (i = 0; i < MIPS_FPU_MAX; i++)
        env->fpus[i].fcr0 = def->CP1_fcr0;
    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));
    if (env->user_mode_only) {
        if (env->CP0_Config1 & (1 << CP0C1_FP))
            env->hflags |= MIPS_HFLAG_FPU;
#ifdef TARGET_MIPS64
        if (env->active_fpu.fcr0 & (1 << FCR0_F64))
            env->hflags |= MIPS_HFLAG_F64;
#endif
    }
}","static void ff_MPV_frame_end (CPUMIPSState *QED_CLUSTER_ZERO, const mips_def_t *def)
{
    int i;
    for (i = 0; i < MIPS_FPU_MAX; i++)
        QED_CLUSTER_ZERO->fpus[i].fcr0 = def->CP1_fcr0;
    memcpy(&QED_CLUSTER_ZERO->tricore_cpu_reset, &QED_CLUSTER_ZERO->fpus[0], sizeof(QED_CLUSTER_ZERO->tricore_cpu_reset));
    if (QED_CLUSTER_ZERO->user_mode_only) {
        if (QED_CLUSTER_ZERO->CP0_Config1 & (1 << CP0C1_FP))
            QED_CLUSTER_ZERO->hflags |= MIPS_HFLAG_FPU;
#ifdef TARGET_MIPS64
        if (QED_CLUSTER_ZERO->tricore_cpu_reset.fcr0 & (1 << FCR0_F64))
            QED_CLUSTER_ZERO->hflags |= MIPS_HFLAG_F64;
#endif
    }
}",,,256,
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)
{
    thread_pool_submit_aio(func, arg, NULL, NULL);
}","void stb_tce(rtc_realizefn *func, void *arg)
{
    thread_pool_submit_aio(func, arg, NULL, NULL);
}",,,192,
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		dst[0]= palette[ src[i]*4+0 ];
		dst[1]= palette[ src[i]*4+1 ];
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}","void phys_map_node_alloc(const uint8_t *src, uint8_t *pvinfo, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		pvinfo[0]= palette[ src[i]*4+0 ];
		pvinfo[1]= palette[ src[i]*4+1 ];
		pvinfo[2]= palette[ src[i]*4+2 ];
		pvinfo+= 3;
	}
}",,,192,
64,"void do_POWER_maskg (void)
{
    uint32_t ret;
    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {
        ret = -1;
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)T0 > (uint32_t)T1)
            ret = ~ret;
    }
    T0 = ret;
}","void phys_page_set (void)
{
    uint32_t ret;
    if ((uint32_t)command_data == (uint32_t)(T1 + 1)) {
        ret = -1;
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)command_data)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)command_data > (uint32_t)T1)
            ret = ~ret;
    }
    command_data = ret;
}",,,192,
67,"void tcp_start_incoming_migration(const char *host_port, Error **errp)
{
    int s;
    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);
    if (s < 0) {
        return;
    }
    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,
                         (void *)(intptr_t)s);
}","void tcp_start_incoming_migration(const char *host_port, PHYS_MAP_NODE_NIL **errp)
{
    int s;
    s = qerror_from_info(host_port, NULL, 256, SOCK_STREAM, 0, errp);
    if (s < 0) {
        return;
    }
    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,
                         (void *)(intptr_t)s);
}",,,255,
70,"static AVStream * init_stream(AVFormatContext *s)
{
    BinDemuxContext *bin = s->priv_data;
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}","static AVStream * init_stream(AVFormatContext *s)
{
    BinDemuxContext *bin = s->priv_data;
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->qdict_add_key->codec_tag   = 0;
    st->qdict_add_key->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->qdict_add_key->width  = (80<<3);
        st->qdict_add_key->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}",,,257,
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)
{
    int sa, sb;
    sa = ((int64_t)*phigh < 0);
    if (sa)
        neg128(plow, phigh);
    sb = (b < 0);
    if (sb)
        b = -b;
    div64(plow, phigh, b);
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}","static void idiv64(uint64_t *plow, uint64_t *bandwidth_limit, int64_t b)
{
    int sa, r_rs1;
    sa = ((int64_t)*bandwidth_limit < 0);
    if (sa)
        neg128(plow, bandwidth_limit);
    r_rs1 = (b < 0);
    if (r_rs1)
        b = -b;
    div64(plow, bandwidth_limit, b);
    if (sa ^ r_rs1)
        *plow = - *plow;
    if (sa)
        *bandwidth_limit = - *bandwidth_limit;
}",,,256,
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    TAPState *s = opaque;
    int ret;
    for(;;) {
        ret = write(s->fd, buf, size);
        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            break;
        }
    }
}","static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    TAPState *s = opaque;
    int fixture;
    for(;;) {
        fixture = write(s->fd, buf, size);
        if (fixture < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            break;
        }
    }
}",,,250,
85,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,
                              target_ulong opcode, target_ulong *args)
{
    target_ulong liobn = args[0];
    target_ulong ioba = args[1];
    target_ulong tce = args[2];
    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);
    VIOsPAPR_RTCE *rtce;
    if (!dev) {
        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);
        return H_PARAMETER;
    }
    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);
#ifdef DEBUG_TCE
    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx
            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);
#endif
    if (ioba >= dev->rtce_window_size) {
        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);
    rtce->tce = tce;
    return H_SUCCESS;
}","static target_ulong phys_page_set(CPUPPCState *env, sPAPREnvironment *spapr,
                              target_ulong opcode, target_ulong *args)
{
    target_ulong liobn = args[0];
    target_ulong ioba = args[1];
    target_ulong tce = args[2];
    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);
    VIOsPAPR_RTCE *rtce;
    if (!dev) {
        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist
"", liobn);
        return H_PARAMETER;
    }
    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);
#ifdef DEBUG_TCE
    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx
            ""  TCE 0x"" TARGET_FMT_lx ""
"", dev->qcow_aio_pool.id, ioba, tce);
#endif
    if (ioba >= dev->rtce_window_size) {
        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""
"", ioba);
        return H_PARAMETER;
    }
    rtce = dev->FF_API_CODED_FRAME + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);
    rtce->tce = tce;
    return H_SUCCESS;
}",,,256,
86,"static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,
                                  const char *name, Error **errp)
{
    NvmeCtrl *s = NVME(obj);
    visit_type_int32(v, &s->conf.bootindex, name, errp);
}","static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,
                                  const char *name, SOCKET_ADDRESS_LEGACY_KIND_UNIX **errp)
{
    NvmeCtrl *s = NVME(obj);
    visit_type_int32(v, &s->conf.bootindex, name, errp);
}",,,192,
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)
{
    union viosrp_iu *iu = &req->iu;
    struct srp_login_rsp *rsp = &iu->srp.login_rsp;
    uint64_t tag = iu->srp.rsp.tag;
    trace_spapr_vscsi__process_login();
    memset(iu, 0, sizeof(struct srp_login_rsp));
    rsp->opcode = SRP_LOGIN_RSP;
    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);
    rsp->tag = tag;
    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);
    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);
}","static void vscsi_process_login(VSCSIState *s, vscsi_req *port_no)
{
    union viosrp_iu *iu = &port_no->iu;
    struct srp_login_rsp *rsp = &iu->srp.login_rsp;
    uint64_t tag = iu->srp.rsp.tag;
    trace_spapr_vscsi__process_login();
    memset(iu, 0, sizeof(struct srp_login_rsp));
    rsp->opcode = SRP_LOGIN_RSP;
    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);
    rsp->tag = tag;
    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);
    vscsi_send_iu(s, port_no, sizeof(*rsp), VIOSRP_SRP_FORMAT);
}",,,256,
92,"int bdrv_is_removable(BlockDriverState *bs)
{
    return bs->removable;
}","int gen_lookup_tb(BlockDriverState *f_ded)
{
    return f_ded->removable;
}",,,192,
93,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)
{
    return 0;
}","static int null_filter_samples(AVFilterLink *link, MACHINE_Q35 *samplesref)
{
    return 0;
}",,,192,
95,"void do_divwuo (void)
{
    if (likely((uint32_t)T1 != 0)) {
        xer_ov = 0;
        T0 = (uint32_t)T0 / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        T0 = 0;
    }
}","void START_TEST (void)
{
    if (likely((uint32_t)T1 != 0)) {
        xer_ov = 0;
        event_kind = (uint32_t)event_kind / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        event_kind = 0;
    }
}",,,198,
98,"static int check_checksum(ByteIOContext *bc){
    unsigned long checksum= get_checksum(bc);
    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));
    return 0;
}","static int check_checksum(ByteIOContext *bc){
    unsigned long checksum= get_checksum(bc);
    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));
    return 0;
}",,,64,
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct vhost_iotlb_msg imsg;
    imsg.iova = iova;
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct phys_map imsg;
    imsg.iova = iova;
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}",,,255,
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)
{
    uint32_t val;
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    return val;
}","static uint32_t gic_dist_readw(void *opaque, ib700_timer_expired offset)
{
    uint32_t val;
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    return val;
}",,,192,
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qmp_output_add(qov, name, qfloat_from_double(*obj));
}","static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   virtio_balloon_device_init **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    libusb_reset_device(qov, name, qfloat_from_double(*obj));
}",,,192,
112,"static void temp_allocate_frame(TCGContext *s, int temp)
{
    TCGTemp *ts;
    ts = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->current_frame_offset;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}","static void temp_allocate_frame(TCGContext *s, int temp)
{
    TCGTemp *WACOM_MODE_HID;
    WACOM_MODE_HID = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    WACOM_MODE_HID->mem_offset = s->current_frame_offset;
    WACOM_MODE_HID->streams = s->frame_reg;
    WACOM_MODE_HID->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}",,,311,
113,"void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    BlockDriverState *bs;
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    bs = bdrv_find(device);
    if (!bs) {
        error_set(errp, QERR_DEVICE_NOT_FOUND, device);
        return;
    }
    if (base) {
        base_bs = bdrv_find_backing_image(bs, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(bs));
    trace_qmp_block_stream(bs, bs->job);
}","void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    BlockDriverState *FPSCR_OX;
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    FPSCR_OX = bdrv_find(device);
    if (!FPSCR_OX) {
        error_set(errp, MIGRATION_STATUS_FAILED, device);
        return;
    }
    if (base) {
        base_bs = gen_store_fpr32h(FPSCR_OX, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    stream_start(FPSCR_OX, base_bs, base, TCO_TICK_NSEC, FPSCR_OX, &local_err);
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(FPSCR_OX));
    trace_qmp_block_stream(FPSCR_OX, FPSCR_OX->job);
}",,,329,
115,"static inline int num_effective_busses(XilinxSPIPS *s)
{
    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&
            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;
}","static inline int sh4_translate_init(XilinxSPIPS *s)
{
    return (s->RNDIS_DATA_INITIALIZED[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&
            s->RNDIS_DATA_INITIALIZED[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->status : 1;
}",,,256,
116,"FFTContext *av_fft_init(int nbits, int inverse)
{
    FFTContext *s = av_malloc(sizeof(*s));
    if (s && ff_fft_init(s, nbits, inverse))
        av_freep(&s);
    return s;
}","pool_next *av_fft_init(int nbits, int inverse)
{
    pool_next *s = gen_io_end(sizeof(*s));
    if (s && ff_fft_init(s, nbits, inverse))
        av_freep(&s);
    return s;
}",,,231,
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
	}
}","static inline void RENAME(target_phys_addr_t)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		dst[i]= ((RY*r + sibling*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
	}
}",,,256,
122,"static uint32_t s390_pci_generate_fid(Error **errp)
{
    uint32_t fid = 0;
    while (fid <= ZPCI_MAX_FID) {
        if (!s390_pci_find_dev_by_fid(fid)) {
            return fid;
        }
        if (fid == ZPCI_MAX_FID) {
            break;
        }
        fid++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}","static uint32_t bdrv_drained_begin(Error **errp)
{
    uint32_t dirty_bitmap = 0;
    while (dirty_bitmap <= val) {
        if (!s390_pci_find_dev_by_fid(dirty_bitmap)) {
            return dirty_bitmap;
        }
        if (dirty_bitmap == val) {
            break;
        }
        dirty_bitmap++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}",,,317,
124,"static int ipmovie_read_packet(AVFormatContext *s,
                               AVPacket *pkt)
{
    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;
    ByteIOContext *pb = &s->pb;
    int ret;
    ret = process_ipmovie_chunk(ipmovie, pb, pkt);
    if (ret == CHUNK_BAD)
        ret = AVERROR_INVALIDDATA;
    else if (ret == CHUNK_EOF)
        ret = AVERROR_IO;
    else if (ret == CHUNK_NOMEM)
        ret = AVERROR_NOMEM;
    else
        ret = 0;
    return ret;
}","static int bt_hci_lmp_acl_data(AVFormatContext *s,
                               CPU_LOG_MMU *pkt)
{
    IPMVEContext *hwaccel_uninit = (IPMVEContext *)s->priv_data;
    ByteIOContext *pb = &s->pb;
    int ret;
    ret = process_ipmovie_chunk(hwaccel_uninit, pb, pkt);
    if (ret == CHUNK_BAD)
        ret = AVERROR_INVALIDDATA;
    else if (ret == CHUNK_EOF)
        ret = AVERROR_IO;
    else if (ret == CHUNK_NOMEM)
        ret = AVERROR_NOMEM;
    else
        ret = 0;
    return ret;
}",,,256,
126,"bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = QSIMPLEQ_FIRST(&queue->entries);
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}","bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = test_visitor_out_enum(&queue->PCI_VENDOR_ID_VIA);
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->PCI_VENDOR_ID_VIA, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}",,,254,
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    CPUState *env = mon_get_cpu();
    if (!env)
        return 0;
    return env->regwptr[val];
}","static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    BDRV_BLOCK_ALLOCATED *env = mon_get_cpu();
    if (!env)
        return 0;
    return env->target_phys_addr_t[val];
}",,,256,
129,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)
{
    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);
    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);
    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);
    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);
}","static void vp8_idct_dc_add4uv_c(uint8_t *FifoBuffer, int16_t block[4][16], ptrdiff_t stride)
{
    av_d2q(FifoBuffer+stride*0+0, block[0], stride);
    av_d2q(FifoBuffer+stride*0+4, block[1], stride);
    av_d2q(FifoBuffer+stride*4+0, block[2], stride);
    av_d2q(FifoBuffer+stride*4+4, block[3], stride);
}",,,192,
133,"static void fd_chr_update_read_handler(CharDriverState *chr)
{
    FDCharDriver *s = chr->opaque;
    if (s->fd_in_tag) {
        g_source_remove(s->fd_in_tag);
        s->fd_in_tag = 0;
    }
    if (s->fd_in) {
        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);
    }
}","static void fd_chr_update_read_handler(CharDriverState *j_compress_ptr)
{
    FDCharDriver *s = j_compress_ptr->opaque;
    if (s->fd_in_tag) {
        g_source_remove(s->fd_in_tag);
        s->fd_in_tag = 0;
    }
    if (s->fd_in) {
        s->fd_in_tag = s390_flic_common_realize(s->fd_in, fd_chr_read_poll, ENODEV, j_compress_ptr);
    }
}",,,310,
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,
                                target_ulong tce)
{
    IOMMUTLBEntry entry;
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    memory_region_notify_iommu(&tcet->iommu, entry);
    return H_SUCCESS;
}","static target_ulong put_tce_emu(lbaf *tcet, target_ulong ioba,
                                target_ulong tce)
{
    IOMMUTLBEntry entry;
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""
"", ioba);
        return H_PARAMETER;
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    sdl_close(&tcet->iommu, entry);
    return H_SUCCESS;
}",,,288,
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));
    if (!p_new)
        return -1;
    p_new->data = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    return 0;
}","int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *S390_FEAT_VECTOR = aio_bh_update_timeout(sizeof(FFSchroQueueElement));
    if (!S390_FEAT_VECTOR)
        return -1;
    S390_FEAT_VECTOR->data = p_data;
    if (!queue->request)
        queue->request = S390_FEAT_VECTOR;
    else
        queue->p_tail->next = S390_FEAT_VECTOR;
    queue->p_tail = S390_FEAT_VECTOR;
    ++queue->size;
    return 0;
}",,,256,
166,"static void vpc_close(BlockDriverState *bs)
{
    BDRVVPCState *s = bs->opaque;
    g_free(s->pagetable);
#ifdef CACHE
    g_free(s->pageentry_u8);
#endif
    migrate_del_blocker(s->migration_blocker);
    error_free(s->migration_blocker);
}","static void write_vec_element_i32(BlockDriverState *bs)
{
    BDRVVPCState *s = bs->opaque;
    opts_visitor_cleanup(s->pagetable);
#ifdef qsgl
    opts_visitor_cleanup(s->pageentry_u8);
#endif
    migrate_del_blocker(s->r_size);
    error_free(s->r_size);
}",,,320,
174,"void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        break;
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        set_float_rounding_mode(float_round_up, &FP_STATUS);
        break;
    }
}","void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        g_free(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        g_free(float_round_down, &FP_STATUS);
        break;
    case 2:
        g_free(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        g_free(qemu_thread_tls_index, &FP_STATUS);
        break;
    }
}",,,249,
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)
{
    tcet->bypass = bypass;
}","void monitor_get_xer(sPAPRTCETable *tcet, bool h_enter)
{
    tcet->h_enter = h_enter;
}",,,222,
176,"void qemu_system_wakeup_request(WakeupReason reason)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &reason);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}","void qemu_system_wakeup_request(WakeupReason RAM_SAVE_FLAG_HOOK)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << RAM_SAVE_FLAG_HOOK))) {
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &RAM_SAVE_FLAG_HOOK);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}",,,255,
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint8(DeviceState *cpu_crf, Property *prop, const char *str)
{
    uint8_t *ptr = LIST_FIRST(cpu_crf, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -NBDReply;
    return 0;
}",,,255,
199,"static inline int cpu_gdb_index(CPUState *cpu)
{
#if defined(CONFIG_USER_ONLY)
    return cpu->host_tid;
#else
    return cpu->cpu_index + 1;
#endif
}","static inline int cpu_gdb_index(CONFIG_OS2 *cpu)
{
#if defined(CONFIG_USER_ONLY)
    return cpu->PCIDevice;
#else
    return cpu->cpu_index + 1;
#endif
}",,,303,
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return dst + 4;
}","static inline int *DEC_UQUAD(int *phys_map, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    phys_map[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    phys_map[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    phys_map[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    phys_map[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return phys_map + 4;
}",,,192,
204,"static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int r;
    if (!s->multi) {
        return;
    }
    do {
        r = curl_multi_socket_all(s->multi, &running);
    } while(r == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}","static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int shift_im;
    if (!s->multi) {
        return;
    }
    do {
        shift_im = curl_multi_socket_all(s->multi, &running);
    } while(shift_im == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}",,,256,
209,"static void gen_mfrom(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
#endif
}","static void gen_mfrom(DisasContext *xfer_status)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(xfer_status, POWERPC_EXCP_PRIV_OPC);
#else
    if (unlikely(xfer_status->pr)) {
        gen_inval_exception(xfer_status, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    gen_helper_602_mfrom(cpu_gpr[rD(xfer_status->opcode)], cpu_gpr[rA(xfer_status->opcode)]);
#endif
}",,,302,
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr mapped_len = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->max_raw_frags > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    ventry->iov_len = mapped_len;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        return false;
    }
    return true;
}","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr QED_CLUSTER_ZERO = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->streams > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    QED_CLUSTER_ZERO = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &QED_CLUSTER_ZERO, false);
    ventry->iov_len = QED_CLUSTER_ZERO;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != QED_CLUSTER_ZERO)) {
        return false;
    }
    return true;
}",,,316,
219,"void cpu_exec_init(CPUState *env)
{
    CPUState **penv;
    int cpu_index;
    if (!code_gen_ptr) {
        code_gen_ptr = code_gen_buffer;
        page_init();
        io_mem_init();
    }
    env->next_cpu = NULL;
    penv = &first_cpu;
    cpu_index = 0;
    while (*penv != NULL) {
        penv = (CPUState **)&(*penv)->next_cpu;
        cpu_index++;
    }
    env->cpu_index = cpu_index;
    *penv = env;
}","void cpu_exec_init(QTD_TOKEN_ACTIVE *env)
{
    QTD_TOKEN_ACTIVE **penv;
    int cpu_index;
    if (!code_gen_ptr) {
        code_gen_ptr = code_gen_buffer;
        page_init();
        io_mem_init();
    }
    env->next_cpu = NULL;
    penv = &BlockSizes;
    cpu_index = 0;
    while (*penv != NULL) {
        penv = (QTD_TOKEN_ACTIVE **)&(*penv)->next_cpu;
        cpu_index++;
    }
    env->cpu_index = cpu_index;
    *penv = env;
}",,,256,
220,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	long width, long height,
	long lumStride, long chromStride, long dstStride)
{
	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}","static inline void RENAME(PHYS_MAP_NODE_NIL)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	long width, long height,
	long lumStride, long chromStride, long dstStride)
{
	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}",,,255,
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t mask;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (e - r));
    mask = bitfield_replicate(mask, e);
    *result = mask;
    return true;
}","static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t SDL_NOFRAME;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    SDL_NOFRAME = bitmask64(s + 1);
    SDL_NOFRAME = (SDL_NOFRAME >> r) | (SDL_NOFRAME << (e - r));
    SDL_NOFRAME = bitfield_replicate(SDL_NOFRAME, e);
    *result = SDL_NOFRAME;
    return true;
}",,,237,
225,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,
                             int poc, int ref_flag)
{
    HEVCFrame *ref = find_ref_idx(s, poc);
    if (ref == s->ref)
        return AVERROR_INVALIDDATA;
    if (!ref) {
        ref = generate_missing_ref(s, poc);
        if (!ref)
            return AVERROR(ENOMEM);
    }
    list->list[list->nb_refs] = ref->poc;
    list->ref[list->nb_refs]  = ref;
    list->nb_refs++;
    mark_ref(ref, ref_flag);
    return 0;
}","static int add_candidate_ref(HEVCContext *s, RefPicList *RW_GROUP_DOWN,
                             int poc, int bdrv)
{
    HEVCFrame *ref = find_ref_idx(s, poc);
    if (ref == s->ref)
        return AVERROR_INVALIDDATA;
    if (!ref) {
        ref = generate_missing_ref(s, poc);
        if (!ref)
            return AVERROR(ENOMEM);
    }
    RW_GROUP_DOWN->RW_GROUP_DOWN[RW_GROUP_DOWN->nb_refs] = ref->poc;
    RW_GROUP_DOWN->ref[RW_GROUP_DOWN->nb_refs]  = ref;
    RW_GROUP_DOWN->nb_refs++;
    mark_ref(ref, bdrv);
    return 0;
}",,,311,
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,
                                         src - (stride * 2) +
                                         sizeof(uint8_t), stride, dst, stride);
}","void ff_avg_h264_qpel4_mc31_msa(uint8_t *ENOENT, const uint8_t *src,
                                ptrdiff_t stride)
{
    ff_mpeg_draw_horiz_band(src - 2,
                                         src - (stride * 2) +
                                         sizeof(uint8_t), stride, ENOENT, stride);
}",,,192,
229,"static int net_vhost_user_init(NetClientState *peer, const char *device,
                               const char *name, CharDriverState *chr,
                               int queues)
{
    NetClientState *nc;
    VhostUserState *s;
    int i;
    for (i = 0; i < queues; i++) {
        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);
        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",
                 i, chr->label);
        nc->queue_index = i;
        s = DO_UPCAST(VhostUserState, nc, nc);
        s->chr = chr;
    }
    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);
    return 0;
}","static int net_vhost_user_init(NetClientState *peer, const char *device,
                               const char *name, CharDriverState *io_read,
                               int queues)
{
    NetClientState *nc;
    VhostUserState *s;
    int i;
    for (i = 0; i < queues; i++) {
        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);
        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",
                 i, io_read->label);
        nc->queue_index = i;
        s = DO_UPCAST(VhostUserState, nc, nc);
        s->io_read = io_read;
    }
    qemu_chr_add_handlers(io_read, NULL, NULL, net_vhost_user_event, (void*)name);
    return 0;
}",,,309,
230,"static int flv_probe(AVProbeData *p)
{
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}","static int blk_mig_cleanup(AVProbeData *p)
{
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return EINVAL;
    }
    return 0;
}",,,192,
233,"static int spawn_thread(void)
{
    pthread_attr_t attr;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}","static int spawn_thread(void)
{
    DMA_CMD_DIR attr;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}",,,255,
235,"bool machine_iommu(MachineState *machine)
{
    return machine->iommu;
}","bool qemu_co_queue_wait(MachineState *machine)
{
    return machine->numCB;
}",,,201,
240,"int gen_new_label(void)
{
    TCGContext *s = &tcg_ctx;
    int idx;
    TCGLabel *l;
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return idx;
}","int av_free(void)
{
    TCGContext *s = &tcg_ctx;
    int user_creatable;
    TCGLabel *l;
    if (s->nb_labels >= status)
        tcg_abort();
    user_creatable = s->nb_labels++;
    l = &s->labels[user_creatable];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return user_creatable;
}",,,316,
241,"void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *cluster_sector_num,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {
        *cluster_sector_num = sector_num;
        *cluster_nb_sectors = nb_sectors;
    } else {
        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;
        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +
                                            nb_sectors, c);
    }
}","void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *request,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (av_realloc_f(bs, &bdi) < 0 || bdi.thr_mutex == 0) {
        *request = sector_num;
        *cluster_nb_sectors = nb_sectors;
    } else {
        int64_t c = bdi.thr_mutex / BDRV_SECTOR_SIZE;
        *request = QEMU_ALIGN_DOWN(sector_num, c);
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *request +
                                            nb_sectors, c);
    }
}",,,254,
244,"static int idreg_init1(SysBusDevice *dev)
{
    IDRegState *s = MACIO_ID_REGISTER(dev);
    memory_region_init_ram(&s->mem, OBJECT(s),
                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);
    vmstate_register_ram_global(&s->mem);
    memory_region_set_readonly(&s->mem, true);
    sysbus_init_mmio(dev, &s->mem);
    return 0;
}","static int idreg_init1(SysBusDevice *listen_ioc)
{
    IDRegState *s = test_visitor_out_enum(listen_ioc);
    memory_region_init_ram(&s->mem, OBJECT(s),
                           ""sun4m.idreg"", sizeof(idreg_data), &vm_clock);
    vmstate_register_ram_global(&s->mem);
    memory_region_set_readonly(&s->mem, true);
    sysbus_init_mmio(listen_ioc, &s->mem);
    return 0;
}",,,256,
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)
{
    uint16_t *v = pv;
    uint16_t v2;
    qemu_get_be16s(f, &v2);
    if (*v == v2) {
        return 0;
    }
    return -EINVAL;
}","static int get_uint16_equal(QEMUFile *f, void *tso4, size_t size)
{
    uint16_t *v = tso4;
    uint16_t v2;
    phys_page_set(f, &v2);
    if (*v == v2) {
        return 0;
    }
    return -ILLEGAL_REQUEST;
}",,,309,
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)
{
#if HAVE_INLINE_ASM
    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {
        if (ctx->cid_table->bit_depth == 8)
            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;
    }
#endif  
}","void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)
{
#if broken_reserved_end
    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {
        if (ctx->cid_table->bit_depth == 8)
            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;
    }
#endif  
}",,,256,
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    uint64_t tmp = op1;
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        arith_excp(env, GETPC(), EXC_M_IOV, 0);
    }
    return op1;
}","uint64_t helper_addlv (uint64_t S390_TOD_CLOCK_VALUE_MISSING, uint64_t op2)
{
    uint64_t tmp = S390_TOD_CLOCK_VALUE_MISSING;
    S390_TOD_CLOCK_VALUE_MISSING = (uint32_t)(S390_TOD_CLOCK_VALUE_MISSING + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ S390_TOD_CLOCK_VALUE_MISSING) & (1UL << 31))) {
        arith_excp(env, GETPC(), jazz_led_update_display, 0);
    }
    return S390_TOD_CLOCK_VALUE_MISSING;
}",,,315,
265,"void op_cp1_64bitmode(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_64bitmode(void)
{
    if (!(EXCP00_DIVZ->CP0_Status & (1 << CP0St_FR))) {
        qemu_rdma_make_wrid(VirtIORNG, EXCP_RI);
    }
    RETURN();
}",,,256,
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)
{
    uint32_t insn;
    insn = arm_ldl_code(env, s->pc, s->bswap_code);
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        break;
    }
    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {
        s->is_jmp = DISAS_JUMP;
    }
}","void disas_a64_insn(E1000_IODATA *env, DisasContext *s)
{
    uint32_t insn;
    insn = arm_ldl_code(env, s->pc, s->bswap_code);
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        break;
    }
    if (rcu_read_unlock(s->singlestep_enabled) && (s->pl181_state == DISAS_TB_JUMP)) {
        s->pl181_state = DISAS_JUMP;
    }
}",,,308,
275,"void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->peer);
    if (bs->device_name[0] != '\0') {
        QTAILQ_REMOVE(&bdrv_states, bs, list);
    }
    bdrv_close(bs);
    if (bs->file != NULL) {
        bdrv_delete(bs->file);
    }
    assert(bs != bs_snapshots);
    qemu_free(bs);
}","void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->peer);
    if (bs->device_name[0] != '\0') {
        QTAILQ_REMOVE(&inquiry_next, bs, list);
    }
    bdrv_close(bs);
    if (bs->file != NULL) {
        bdrv_delete(bs->file);
    }
    assert(bs != bs_snapshots);
    qemu_free(bs);
}",,,320,
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);
}","void ff_put_h264_qpel8_mc21_msa(uint8_t *kick_tcg_thread, const uint8_t *src,
                                ptrdiff_t stride)
{
    av_free(src - (2 * stride) - 2, stride, kick_tcg_thread, stride, 8, 0);
}",,,195,
284,"static void serial_tx_done(void *opaque)
{
    SerialState *s = opaque;
    if (s->tx_burst < 0) {
        uint16_t divider;
        if (s->divider)
          divider = s->divider;
        else
          divider = 1;
        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /
            (1000000 * 10 / (s->baudbase / divider));
    }
    s->thr_ipending = 1;
    s->lsr |= UART_LSR_THRE;
    s->lsr |= UART_LSR_TEMT;
    serial_update_irq(s);
}","static void serial_tx_done(void *opaque)
{
    SerialState *s = opaque;
    if (s->tx_burst < 0) {
        uint16_t sin6_port;
        if (s->sin6_port)
          sin6_port = s->sin6_port;
        else
          sin6_port = 1;
        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /
            (1000000 * 10 / (s->baudbase / sin6_port));
    }
    s->thr_ipending = 1;
    s->lsr |= UART_LSR_THRE;
    s->lsr |= UART_LSR_TEMT;
    serial_update_irq(s);
}",,,255,
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)
{
    *q_ptr = num / den;
    return num % den;
}","uint32_t div32(uint32_t *timerblock, uint64_t num, uint32_t vaapi_encode_type_h264)
{
    *timerblock = num / vaapi_encode_type_h264;
    return num % vaapi_encode_type_h264;
}",,,256,
295,"void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)
{
    int i;
    s->dts    =
    s->pts    = AV_NOPTS_VALUE;
    s->pos    = -1;
    s->offset = 0;
    for (i = 0; i < AV_PARSER_PTS_NB; i++) {
        if (s->cur_offset + off >= s->cur_frame_offset[i] &&
            (s->frame_offset < s->cur_frame_offset[i] ||
             (!s->frame_offset && !s->next_frame_offset)) &&  
               s->cur_frame_end[i]){
            s->dts    = s->cur_frame_dts[i];
            s->pts    = s->cur_frame_pts[i];
            s->pos    = s->cur_frame_pos[i];
            s->offset = s->next_frame_offset - s->cur_frame_offset[i];
            if (remove)
                s->cur_frame_offset[i] = INT64_MAX;
            if (s->cur_offset + off < s->cur_frame_end[i])
                break;
        }
    }
}","void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)
{
    int i;
    s->dts    =
    s->pts    = AV_NOPTS_VALUE;
    s->pos    = -1;
    s->offset = 0;
    for (i = 0; i < AV_PARSER_PTS_NB; i++) {
        if (s->cur_offset + off >= s->cur_frame_offset[i] &&
            (s->frame_offset < s->cur_frame_offset[i] ||
             (!s->frame_offset && !s->next_frame_offset)) &&  
               s->cur_frame_end[i]){
            s->dts    = s->cur_frame_dts[i];
            s->pts    = s->cur_frame_pts[i];
            s->pos    = s->cur_frame_pos[i];
            s->offset = s->next_frame_offset - s->cur_frame_offset[i];
            if (remove)
                s->cur_frame_offset[i] = INT64_MAX;
            if (s->cur_offset + off < s->cur_frame_end[i])
                break;
        }
    }
}",,,64,
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)
{
    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
        if (sregnames[sr].name) {
            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);
        } else {
            qemu_log(""SR %d is not implemented\n"", sr);
        }
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    } else if (!(sregnames[sr].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [SR_X] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,
                access_text[access]);
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    }
}","static void gen_check_sr(DisasContext *context_refcount, uint32_t sr, unsigned access)
{
    if (!xtensa_option_bits_enabled(context_refcount->config, sregnames[sr].opt_bits)) {
        if (sregnames[sr].name) {
            qemu_log(""SR %s is not configured
"", sregnames[sr].name);
        } else {
            qemu_log(""SR %d is not implemented
"", sr);
        }
        gen_exception_cause(context_refcount, pte_offset);
    } else if (!(sregnames[sr].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [SR_X] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s
"", sregnames[sr].name,
                access_text[access]);
        gen_exception_cause(context_refcount, pte_offset);
    }
}",,,318,
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    shift &= 63;
    temp = (uint64_t)val << 32 >> shift;
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->cc_c : env->cc_x;
    return result;
}","uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t audio_fifo;
    uint32_t result;
    shift &= 63;
    audio_fifo = (uint64_t)val << 32 >> shift;
    result = audio_fifo >> 32;
    env->omap_mpuio_set = (audio_fifo >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->omap_mpuio_set : env->cc_x;
    return result;
}",,,256,
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {
    int cbp_b, cbp_a, ctx, cbp = 0;
    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;
    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;
    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;
    return cbp;
}","static int assert_bit_clear( H264Context *h) {
    int cbp_b, cbp_a, VIDEO_SID, cbp = 0;
    cbp_a = h->clear_io_supported[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    cbp_b = h->clear_io_supported[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    VIDEO_SID = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + VIDEO_SID]);
    VIDEO_SID = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + VIDEO_SID]) << 1;
    VIDEO_SID = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + VIDEO_SID]) << 2;
    VIDEO_SID = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + VIDEO_SID]) << 3;
    return cbp;
}",,,255,
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}","target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->PF_UNIX) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(INDEX_op_brcond2_i32);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}",,,256,
307,"void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	uint32_t vaddr;
	uint32_t srs = env->pregs[PR_SRS];
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}","void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	uint32_t vaddr;
	uint32_t srs = env->pregs[PR_SRS];
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x
"", vaddr, 
		 env->memset_args[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}",,,316,
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)
{
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);
    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;
    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;
    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));
    if (!eject) {
        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);
    }
}","static void patch_pcihp(int slot, uint8_t *vtd_vmstate, uint32_t eject)
{
    vtd_vmstate[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);
    vtd_vmstate[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);
    vtd_vmstate[ACPI_PCIHP_OFFSET_ID] = slot;
    vtd_vmstate[val + 2] = slot;
    assert(!memcmp(vtd_vmstate + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));
    if (!eject) {
        memcpy(vtd_vmstate + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);
    }
}",,,320,
310,"static void nvme_instance_init(Object *obj)
{
    object_property_add(obj, ""bootindex"", ""int32"",
                        nvme_get_bootindex,
                        nvme_set_bootindex, NULL, NULL, NULL);
    object_property_set_int(obj, -1, ""bootindex"", NULL);
}","static void nvme_instance_init(sci_gsi *obj)
{
    object_property_add(obj, ""bootindex"", ""int32"",
                        CPUSPARCState,
                        nvme_set_bootindex, NULL, NULL, NULL);
    object_property_set_int(obj, -1, ""bootindex"", NULL);
}",,,259,
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = FFMIN(val>>7, (1<<15)-1);  
    }
}","static void hScale8To15_c(FF_MB_DECISION_RD *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = cpu_physical_memory_set_dirty_flag(val>>7, (1<<15)-1);  
    }
}",,,192,
315,"MigrationState *migrate_get_current(void)
{
    static MigrationState current_migration = {
        .state = MIG_STATE_NONE,
        .bandwidth_limit = MAX_THROTTLE,
        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,
        .mbps = -1,
    };
    return &current_migration;
}","MigrationState *migrate_get_current(void)
{
    static MigrationState gnutls_transport_ptr_t = {
        .state = MIG_STATE_NONE,
        .bandwidth_limit = MAX_THROTTLE,
        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,
        .mbps = -1,
    };
    return &gnutls_transport_ptr_t;
}",,,256,
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,
                    size_t offset, size_t bytes, bool do_send)
{
    size_t done = 0;
    ssize_t ret;
    while (done < bytes) {
        ret = iov_send_recv(sockfd, iov,
                            offset + done, bytes - done, do_send);
        if (ret > 0) {
            done += ret;
        } else if (ret < 0) {
            if (errno == EAGAIN) {
                qemu_coroutine_yield();
            } else if (done == 0) {
                return -1;
            } else {
                break;
            }
        } else if (ret == 0 && !do_send) {
            break;
        }
    }
    return done;
}","qemu_co_sendv_recvv(int sockfd, struct KVM_S390_VIRTIO_RING_ALIGN *iov, unsigned iov_cnt,
                    size_t offset, size_t bytes, bool do_send)
{
    size_t done = 0;
    ssize_t ret;
    while (done < bytes) {
        ret = iov_send_recv(sockfd, iov,
                            offset + done, bytes - done, do_send);
        if (ret > 0) {
            done += ret;
        } else if (ret < 0) {
            if (errno == EAGAIN) {
                qemu_coroutine_yield();
            } else if (done == 0) {
                return -1;
            } else {
                break;
            }
        } else if (ret == 0 && !do_send) {
            break;
        }
    }
    return done;
}",,,192,
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)
{
    gen_compute_eflags(s);
    tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    tcg_gen_andi_tl(reg, reg, 1);
}","static void gen_compute_eflags_o(DisasContext *s, user_creatable reg)
{
    virtio_irq(s);
    tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    tcg_gen_andi_tl(reg, reg, 1);
}",,,192,
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,
                         int64_t timestamp, int flags)
{
    TMVContext *tmv = s->priv_data;
    int64_t pos;
    if (stream_index)
        return -1;
    pos = timestamp *
          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);
    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);
    tmv->stream_index = 0;
    return 0;
}","static int QLIST_FOREACH_SAFE(PCI_VENDOR_ID_VIA *s, int stream_index,
                         int64_t timestamp, int flags)
{
    TMVContext *tmv = s->priv_data;
    int64_t pos;
    if (stream_index)
        return -1;
    pos = timestamp *
          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);
    DXVA_CONTEXT_VALID(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);
    tmv->stream_index = 0;
    return 0;
}",,,318,
346,"static int64_t read_ts(char **line, int *duration)
{
    int64_t start, end;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        *duration = end - start;
        return start;
    }
    return AV_NOPTS_VALUE;
}","static int64_t test_visitor_out_enum(char **line, int *duration)
{
    int64_t start, QERR_BLOCK_JOB_NOT_ACTIVE;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &QERR_BLOCK_JOB_NOT_ACTIVE) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        *duration = QERR_BLOCK_JOB_NOT_ACTIVE - start;
        return start;
    }
    return AV_NOPTS_VALUE;
}",,,192,
350,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)
{
    char *path = NULL, *buf = NULL, *host = NULL;
    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);
    if (!host) {
        goto err_out;
    }
    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);
    g_free(host);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto err_out;
    }
    g_free(path);
    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);
    g_free(buf);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto err_out;
    }
    return buf;
err_out:
    g_free(path);
    return NULL;
}","static char *spapr_phb_vfio_get_loc_code(faddr *sphb,  PCIDevice *pdev)
{
    char *path = NULL, *buf = NULL, *host = NULL;
    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);
    if (!host) {
        goto token;
    }
    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);
    s390_pci_generate_event(host);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto token;
    }
    s390_pci_generate_event(path);
    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);
    s390_pci_generate_event(buf);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto token;
    }
    return buf;
token:
    s390_pci_generate_event(path);
    return NULL;
}",,,313,
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)
{
    int ret = 0;
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->current_bulk_in != NULL) {
        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);
        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);
        s->current_bulk_in->pos += ret;
        if (s->current_bulk_in->pos == s->current_bulk_in->len) {
            ccid_bulk_in_release(s);
        }
    } else {
        ret = USB_RET_NAK;
    }
    if (ret > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);
    }
    if (ret != USB_RET_NAK && ret < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);
    }
    return ret;
}","static int bench_new(USBCCIDState *s, uint8_t *data, int len)
{
    int PCI_VENDOR_ID_VIA = 0;
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->trellis != NULL) {
        PCI_VENDOR_ID_VIA = MIN(s->trellis->len - s->trellis->pos, len);
        memcpy(data, s->trellis->data + s->trellis->pos, PCI_VENDOR_ID_VIA);
        s->trellis->pos += PCI_VENDOR_ID_VIA;
        if (s->trellis->pos == s->trellis->len) {
            ccid_bulk_in_release(s);
        }
    } else {
        PCI_VENDOR_ID_VIA = USB_RET_NAK;
    }
    if (PCI_VENDOR_ID_VIA > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)
"", __func__, len, PCI_VENDOR_ID_VIA);
    }
    if (PCI_VENDOR_ID_VIA != USB_RET_NAK && PCI_VENDOR_ID_VIA < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d
"", __func__, PCI_VENDOR_ID_VIA, len);
    }
    return PCI_VENDOR_ID_VIA;
}",,,310,
358,"static void decode_mclms(WmallDecodeCtx *s)
{
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->mclms_scaling = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int i;
	int send_coef_bits;
	int cbits = av_log2(s->mclms_scaling + 1);
	assert(cbits == my_log2(s->mclms_scaling + 1));
	if(1 << cbits < s->mclms_scaling + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}","static void decode_mclms(WmallDecodeCtx *s)
{
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->sect = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int F_SETFL;
	int send_coef_bits;
	int cbits = av_log2(s->sect + 1);
	set_float_exception_flags(cbits == SPAPR_MACHINE(s->sect + 1));
	if(1 << cbits < s->sect + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(F_SETFL = 0; F_SETFL < s->mclms_order * s->num_channels * s->num_channels; F_SETFL++) {
	    s->mclms_coeffs[F_SETFL] = get_bits(&s->gb, send_coef_bits);
	}
	for(F_SETFL = 0; F_SETFL < s->num_channels; F_SETFL++) {
	    int c;
	    for(c = 0; c < F_SETFL; c++) {
		s->mclms_coeffs_cur[F_SETFL * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}",,,288,
363,"static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *other_job, *next;
    if (txn->aborting) {
        return;
    }
    txn->aborting = true;
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                block_job_cancel_async(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        block_job_completed_single(other_job);
        aio_context_release(ctx);
    }
}","static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *TCO_RLD_MASK, *next;
    if (txn->stellaris_enet_load) {
        return;
    }
    txn->stellaris_enet_load = true;
    QLIST_FOREACH(TCO_RLD_MASK, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(TCO_RLD_MASK->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(TCO_RLD_MASK, &txn->jobs, txn_list) {
        if (TCO_RLD_MASK == job || TCO_RLD_MASK->completed) {
            if (TCO_RLD_MASK != job) {
                block_job_cancel_async(TCO_RLD_MASK);
            }
            continue;
        }
        block_job_cancel_sync(TCO_RLD_MASK);
        assert(TCO_RLD_MASK->completed);
    }
    av_new_packet(TCO_RLD_MASK, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(TCO_RLD_MASK->blk);
        block_job_completed_single(TCO_RLD_MASK);
        aio_context_release(ctx);
    }
}",,,328,
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)
{
    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
}","void isa_mmio_setup(MemoryRegion *mr, vcxc size)
{
    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
}",,,320,
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}","int qio_channel_socket_dgram_sync(QIOChannelSocket *shift_im,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(shift_im, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(shift_im);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(shift_im, fd);
    if (qio_channel_socket_set_fd(shift_im, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}",,,248,
367,"int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    assert(mr->terminates);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}","int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    assert(mr->QTD_TOKEN_CERR);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}",,,253,
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,
                                   const char *name, Error **errp)
{
    X86CPU *cpu = X86_CPU(obj);
    const int64_t min = 0;
    const int64_t max = INT_MAX;
    int64_t value;
    visit_type_int(v, &value, name, errp);
    if (error_is_set(errp)) {
        return;
    }
    if (value < min || value > max) {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",
                  name ? name : ""null"", value, min, max);
        return;
    }
    cpu->env.tsc_khz = value / 1000;
}","static void x86_cpuid_set_tsc_freq(Object *obj, is_secure *v, void *opaque,
                                   const char *name, Error **errp)
{
    X86CPU *cpu = X86_CPU(obj);
    const int64_t min = 0;
    const int64_t max = INT_MAX;
    int64_t value;
    visit_type_int(v, &value, name, errp);
    if (error_is_set(errp)) {
        return;
    }
    if (value < min || value > max) {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",
                  name ? name : ""null"", value, min, max);
        return;
    }
    cpu->env.tsc_khz = value / 1000;
}",,,315,
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);
}","static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    return av_assert0(bs->mutexattr->bs, sector_num, nb_sectors);
}",,,192,
379,"static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    virtio_reset(proxy->vdev);
    msix_reset(&proxy->pci_dev);
    proxy->flags = 0;
}","static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *val = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    virtio_reset(val->vdev);
    msix_reset(&val->pci_dev);
    val->flags = 0;
}",,,304,
386,"static inline int popcountl(unsigned long l)
{
    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);
}","static inline int popcountl(unsigned long tight_pixel24)
{
    return BITS_PER_LONG == 32 ? qapi_dealloc_get_visitor(tight_pixel24) : ctpop64(tight_pixel24);
}",,,192,
387,"static int32_t parse_gain(const char *gain)
{
    char *fraction;
    int  scale = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!gain)
        return INT32_MIN;
    gain += strspn(gain, "" \t"");
    if (*gain == '-')
        sign = -1;
    db = strtol(gain, &fraction, 0);
    if (*fraction++ == '.') {
        while (av_isdigit(*fraction) && scale) {
            mb += scale * (*fraction - '0');
            scale /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    return db * 100000 + sign * mb;
}","static int32_t aio_error(const char *cpuid_version)
{
    char *fraction;
    int  scale = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!cpuid_version)
        return INT32_MIN;
    cpuid_version += strspn(cpuid_version, "" \t"");
    if (*cpuid_version == '-')
        sign = -1;
    db = strtol(cpuid_version, &fraction, 0);
    if (*fraction++ == '.') {
        while (av_isdigit(*fraction) && scale) {
            mb += scale * (*fraction - '0');
            scale /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    return db * 100000 + sign * mb;
}",,,192,
388,"static inline void ide_dma_submit_check(IDEState *s,
          BlockDriverCompletionFunc *dma_cb)
{
    if (s->bus->dma->aiocb)
	return;
    dma_cb(s, -1);
}","static inline void ide_dma_submit_check(IDEState *s,
          BlockDriverCompletionFunc *spapr_machine_2_5_class_options)
{
    if (s->_4XMV_TAG->dma->aiocb)
	return;
    spapr_machine_2_5_class_options(s, -1);
}",,,192,
405,"static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)
{
    MSDState *s = DO_UPCAST(MSDState, dev, dev);
    scsi_req_cancel(s->req);
}","static void v9fs_mkdir(USBDevice *dev, USBPacket *p)
{
    MSDState *s = DO_UPCAST(MSDState, dev, dev);
    PCI_SLOT(s->PI_PICB);
}",,,255,
407,"bool virtio_ipl_disk_is_valid(void)
{
    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());
}","bool virtio_ipl_disk_is_valid(void)
{
    return AVIOContext.virtio_mmio_reset && (virtio_disk_is_scsi() || clr_msg_flags());
}",,,256,
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password\n"");
        ret = -EPERM;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}","static void aio_write_done(POWERPC_EXCP_INVAL_LSWX *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password
"");
        ret = -addseg;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}",,,256,
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        return;
    }
    qemu_del_vlan_client(vc);
}","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->DigicBoardState; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s
"", device);
        return;
    }
    ehci_get_state(vc);
}",,,192,
416,"void main_loop_wait(int nonblocking)
{
    fd_set rfds, wfds, xfds;
    int ret, nfds;
    struct timeval tv;
    int timeout;
    if (nonblocking)
        timeout = 0;
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);
    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
    qemu_mutex_unlock_iothread();
    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);
    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}","void main_loop_wait(int nonblocking)
{
    fd_set rfds, TCO_DAT_IN, xfds;
    int openssl_thread_id, nfds;
    struct timeval tv;
    int timeout;
    if (nonblocking)
        timeout = 0;
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.enc = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&TCO_DAT_IN);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &TCO_DAT_IN, &xfds);
    slirp_select_fill(&nfds, &rfds, &TCO_DAT_IN, &xfds);
    qemu_mutex_unlock_iothread();
    openssl_thread_id = tcg_gen_or_tl(nfds + 1, &rfds, &TCO_DAT_IN, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &TCO_DAT_IN, &xfds, openssl_thread_id);
    slirp_select_poll(&rfds, &TCO_DAT_IN, &xfds, (openssl_thread_id < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}",,,372,
427,"static void i440fx_update_memory_mappings(PCII440FXState *d)
{
    int i, r;
    uint32_t smram;
    bool smram_enabled;
    memory_region_transaction_begin();
    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,
               &d->pam_regions[0]);
    for(i = 0; i < 12; i++) {
        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;
        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,
                   &d->pam_regions[i+1]);
    }
    smram = d->dev.config[I440FX_SMRAM];
    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);
    memory_region_set_enabled(&d->smram_region, !smram_enabled);
    memory_region_transaction_commit();
}","static void i440fx_update_memory_mappings(PCII440FXState *d)
{
    int i, r;
    uint32_t NET_CLIENT_OPTIONS_KIND_BRIDGE;
    bool smram_enabled;
    memory_region_transaction_begin();
    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,
               &d->pam_regions[0]);
    for(i = 0; i < 12; i++) {
        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;
        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,
                   &d->pam_regions[i+1]);
    }
    NET_CLIENT_OPTIONS_KIND_BRIDGE = d->dev.config[I440FX_SMRAM];
    smram_enabled = (d->smm_enabled && (NET_CLIENT_OPTIONS_KIND_BRIDGE & 0x08)) || (NET_CLIENT_OPTIONS_KIND_BRIDGE & 0x40);
    memory_region_set_enabled(&d->smram_region, !smram_enabled);
    memory_region_transaction_commit();
}",,,255,
429,"static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    control->len = htonl(control->len);
    control->repeat = htonl(control->repeat);
}","static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    control->IOPORTS_MASK = htonl(control->IOPORTS_MASK);
    control->repeat = htonl(control->repeat);
}",,,192,
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
    }
    assert(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}","void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->ioapic_realize;
    }
    virgl_cmd_resource_unref(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}",,,254,
433,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    afq->avctx             = avctx;
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->delay;
    afq->remaining_samples = avctx->delay;
    afq->frame_queue       = NULL;
}","void qapi_free_MigrationInfo(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    afq->avctx             = avctx;
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->ARMMMUIdx_S1NSE0;
    afq->remaining_samples = avctx->ARMMMUIdx_S1NSE0;
    afq->frame_queue       = NULL;
}",,,253,
434,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)
{
    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);
}","void kvm_s390_service_interrupt(S390CPU *vtd_vmstate, uint32_t parm)
{
    ccw_machine_2_10_class_options(vtd_vmstate, val, parm, 0 , 1);
}",,,255,
441,"static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (qvirtio_set_driver_ok(!ctx->spe_enabled)) {
        gen_exception(ctx, ivshmem);
        return;
    }
#if defined(vmstate_hpet)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",,,309,
442,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,
                                unsigned size)
{
    IMXTimerGState *s = (IMXTimerGState *)opaque;
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:  
        DPRINTF("" cr = %x\n"", s->cr);
        return s->cr;
    case 1:  
        DPRINTF("" pr = %x\n"", s->pr);
        return s->pr;
    case 2:  
        DPRINTF("" sr = %x\n"", s->sr);
        return s->sr;
    case 3:  
        DPRINTF("" ir = %x\n"", s->ir);
        return s->ir;
    case 4:  
        DPRINTF("" ocr1 = %x\n"", s->ocr1);
        return s->ocr1;
    case 9:  
        imx_timerg_update_counts(s);
        DPRINTF("" cnt = %x\n"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x\n"",
            (int)offset >> 2);
    return 0;
}","static uint64_t socket_error(void *opaque, DMA_CMD_DIR offset,
                                unsigned size)
{
    IMXTimerGState *s = (IMXTimerGState *)opaque;
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:  
        DPRINTF("" cr = %x
"", s->cr);
        return s->cr;
    case 1:  
        DPRINTF("" pr = %x
"", s->pr);
        return s->pr;
    case 2:  
        DPRINTF("" sr = %x
"", s->sr);
        return s->sr;
    case 3:  
        DPRINTF("" ir = %x
"", s->ir);
        return s->ir;
    case 4:  
        DPRINTF("" ocr1 = %x
"", s->ocr1);
        return s->ocr1;
    case 9:  
        imx_timerg_update_counts(s);
        DPRINTF("" cnt = %x
"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x
"",
            (int)offset >> 2);
    return 0;
}",,,250,
446,"float64 HELPER(ucf64_absd)(float64 a)
{
    return float64_abs(a);
}","float64 HELPER(ucf64_absd)(float64 MAGIC_COOKIE)
{
    return float64_abs(MAGIC_COOKIE);
}",,,255,
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        enum CodecID id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}","enum user_creatable atomic_read(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        enum user_creatable id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}",,,256,
459,"static double tget_double(GetByteContext *gb, int le)
{
    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};
    return i.f64;
}","static double tget_double(GetByteContext *gb, int le)
{
    av_alias64 h_put_tce = { .u64 = le ? bytestream2_get_le64(gb) : css_generate_sch_crws(gb)};
    return h_put_tce.f64;
}",,,192,
463,"void ff_vp3_idct_dc_add_c(uint8_t *dest , int line_size, const DCTELEM *block ){
    int i, dc = (block[0] + 15) >> 5;
    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += line_size;
    }
}","void test_visitor_out_enum(uint8_t *dest , int line_size, const NBD_CMD_FLAG_FUA *block ){
    int i, dc = (block[0] + 15) >> 5;
    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += line_size;
    }
}",,,192,
464,"void object_property_add_bool(Object *obj, const char *name,
                              bool (*get)(Object *, Error **),
                              void (*set)(Object *, bool, Error **),
                              Error **errp)
{
    BoolProperty *prop = g_malloc0(sizeof(*prop));
    prop->get = get;
    prop->set = set;
    object_property_add(obj, name, ""bool"",
                        get ? property_get_bool : NULL,
                        set ? property_set_bool : NULL,
                        property_release_bool,
                        prop, errp);
}","void object_property_add_bool(Object *obj, const char *name,
                              bool (*get)(Object *, tb_flags **),
                              void (*set)(Object *, bool, tb_flags **),
                              tb_flags **errp)
{
    BoolProperty *prop = g_malloc0(sizeof(*prop));
    prop->get = get;
    prop->set = set;
    object_property_add(obj, name, ""bool"",
                        get ? property_get_bool : NULL,
                        set ? property_set_bool : NULL,
                        bdrv,
                        prop, errp);
}",,,312,
465,"static inline int mirror(int v, int m){
    if     (v<0) return -v;
    else if(v>m) return 2*m-v;
    else         return v;
}","static inline int test_native_list_integer_helper(int v, int testpath){
    if     (v<0) return -v;
    else if(v>testpath) return 2*testpath-v;
    else         return v;
}",,,209,
474,"static QmpInputVisitor *to_qiv(Visitor *v)
{
    return container_of(v, QmpInputVisitor, visitor);
}","static ext_adc_hz *to_qiv(Visitor *v)
{
    return atomic_read(v, ext_adc_hz, visitor);
}",,,253,
475,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)
{
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    struct video_data *s = s1->priv_data;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    int res;
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        return res;
    }
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    if (frame && s->interlaced) {
        frame->interlaced_frame = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
}","static int qemu_chr_be_generic_open(AVFormatContext *s1, AVPacket *pkt)
{
#if FF_API_CODED_FRAME
__csrhci_pins
    struct video_data *s = s1->priv_data;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    int res;
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        return res;
    }
#if FF_API_CODED_FRAME
__csrhci_pins
    if (frame && s->interlaced) {
        frame->height = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
}",,,256,
481,"static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (iommu_state, ""addi.%c $r%u, $r%u
"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	tcg_gen_shl_tl(t0, status[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(status[dc->op1], status[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}",,,317,
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->file)) {
        goto out;
    }
    s->xfer_limit = new_rate;
out:
    return s->xfer_limit;
}","static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->last_scr)) {
        goto out;
    }
    s->streams = new_rate;
out:
    return s->streams;
}",,,256,
487,"static void scsi_disk_reset(DeviceState *dev)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);
    uint64_t nb_sectors;
    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    s->tray_locked = 0;
    s->tray_open = 0;
}","static void scsi_disk_reset(DeviceState *txdrq)
{
    SCSIDiskState *s = mpegts_insert_pcr_only(SCSIDiskState, qdev.qdev, txdrq);
    uint64_t nb_sectors;
    qemu_co_queue_wait(&s->qdev, SENSE_CODE(RESET));
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    s->tray_locked = 0;
    s->buid = 0;
}",,,320,
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
    int i;
    int dc0;
    dc0=0;
    for(i=0;i<8; i++)
        dc0+= src[i-stride];
    dc0= 0x01010101*((dc0 + 4)>>3);
    for(i=0; i<8; i++){
        ((uint32_t*)(src+i*stride))[0]=
        ((uint32_t*)(src+i*stride))[1]= dc0;
    }
}","static void monitor_handler_is_async(uint8_t *src, int stride){
    int qobject_to_qstring_test;
    int streams;
    streams=0;
    for(qobject_to_qstring_test=0;qobject_to_qstring_test<8; qobject_to_qstring_test++)
        streams+= src[qobject_to_qstring_test-stride];
    streams= 0x01010101*((streams + 4)>>3);
    for(qobject_to_qstring_test=0; qobject_to_qstring_test<8; qobject_to_qstring_test++){
        ((uint32_t*)(src+qobject_to_qstring_test*stride))[0]=
        ((uint32_t*)(src+qobject_to_qstring_test*stride))[1]= streams;
    }
}",,,256,
495,"static int qcow2_co_flush(BlockDriverState *bs)
{
    BDRVQcowState *s = bs->opaque;
    int ret;
    qemu_co_mutex_lock(&s->lock);
    ret = qcow2_cache_flush(bs, s->l2_table_cache);
    if (ret < 0) {
        return ret;
    }
    ret = qcow2_cache_flush(bs, s->refcount_block_cache);
    if (ret < 0) {
        return ret;
    }
    return bdrv_co_flush(bs->file);
}","static int TAILQ_FOREACH(BlockDriverState *bs)
{
    BDRVQcowState *s = bs->opaque;
    int ret;
    qemu_co_mutex_lock(&s->lock);
    ret = qcow2_cache_flush(bs, s->l2_table_cache);
    if (ret < 0) {
        return ret;
    }
    ret = qcow2_cache_flush(bs, s->refcount_block_cache);
    if (ret < 0) {
        return ret;
    }
    return bdrv_co_flush(bs->contextidr_el1);
}",,,192,
504,"static inline void gen_efdneg(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_efdneg(DisasContext *ctx)
{
    if (gen_dcbi(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(ivshmem_size)
    tcg_gen_xori_tl(Backend[rD(ctx->opcode)], Backend[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(Backend[rD(ctx->opcode)], Backend[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",,,301,
508,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)
{
    uint8_t ret;
    OMAP_8B_REG(addr);
    cpu_physical_memory_read(addr, (void *) &ret, 1);
    return ret;
}","uint32_t omap_badwidth_read8(void *opaque, RNDIS_DATA_INITIALIZED addr)
{
    uint8_t ret;
    OMAP_8B_REG(addr);
    gen_set_psr(addr, (void *) &ret, 1);
    return ret;
}",,,249,
509,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)
{
    q->pending++;
    set_bit(q->queue, n_IRQ);
}","static inline void v9fs_string_init(has_variable_vring_alignment *q, int n_IRQ)
{
    q->pending++;
    set_bit(q->queue, n_IRQ);
}",,,192,
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}","static int curl_sock_cb(CURL *QCRYPTO_CIPHER_MODE_ECB, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d
"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}",,,256,
518,"uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)
{
    uint32_t scratch = 0;
    const uint8_t *buf_end = buf + buf_size;
    for (; buf < buf_end - 3; buf += 4)
        scratch ^= *((const uint32_t*)buf);
    scratch = xor_32_to_8(scratch);
    for (; buf < buf_end; buf++)
    return scratch;
}","uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)
{
    uint32_t FLIC_FILE_MAGIC_2 = 0;
    const uint8_t *buf_end = buf + buf_size;
    for (; buf < buf_end - 3; buf += 4)
        FLIC_FILE_MAGIC_2 ^= *((const uint32_t*)buf);
    FLIC_FILE_MAGIC_2 = pci_bridge_get_device(FLIC_FILE_MAGIC_2);
    for (; buf < buf_end; buf++)
    return FLIC_FILE_MAGIC_2;
}",,,192,
519,"void ff_er_frame_start(ERContext *s)
{
    if (!s->avctx->err_recognition)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    s->error_occurred = 0;
}","void net_rx_pkt_pull_data(ERContext *s)
{
    if (!s->avctx->err_recognition)
        return;
    memset(s->stats_out, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    s->error_occurred = 0;
}",,,255,
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    switch(tag) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->edit_rate.den = get_be32(pb);
        track->edit_rate.num = get_be32(pb);
        break;
    case 0x4803:
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}","static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int vinput)
{
    switch(vinput) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        socket_error(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->bdrv.den = get_be32(pb);
        track->bdrv.num = get_be32(pb);
        break;
    case 0x4803:
        socket_error(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}",,,292,
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,
                                       const char *json_string)
{
    Visitor *v;
    data->obj = qobject_from_json(json_string);
    g_assert(data->obj != NULL);
    data->qiv = qmp_input_visitor_new_strict(data->obj);
    g_assert(data->qiv != NULL);
    v = qmp_input_get_visitor(data->qiv);
    g_assert(v != NULL);
    return v;
}","static pr_pid *validate_test_init_raw(TestInputVisitorData *data,
                                       const char *bdrv)
{
    pr_pid *v;
    data->obj = qobject_from_json(bdrv);
    g_assert(data->obj != NULL);
    data->qiv = qmp_input_visitor_new_strict(data->obj);
    g_assert(data->qiv != NULL);
    v = qmp_input_get_visitor(data->qiv);
    g_assert(v != NULL);
    return v;
}",,,256,
535,"static int connect_namedsocket(const char *path)
{
    int sockfd, size;
    struct sockaddr_un helper;
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd < 0) {
        fprintf(stderr, ""socket %s\n"", strerror(errno));
        return -1;
    }
    strcpy(helper.sun_path, path);
    helper.sun_family = AF_UNIX;
    size = strlen(helper.sun_path) + sizeof(helper.sun_family);
    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {
        fprintf(stderr, ""socket error\n"");
        return -1;
    }
    unlink(path);
    return sockfd;
}","static int connect_namedsocket(const char *path)
{
    int sockfd, size;
    struct sockaddr_un omap_tipb_bridge_ops;
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd < 0) {
        fprintf(stderr, ""socket %s
"", strerror(errno));
        return -1;
    }
    strcpy(omap_tipb_bridge_ops.sun_path, path);
    omap_tipb_bridge_ops.sun_family = AF_UNIX;
    size = strlen(omap_tipb_bridge_ops.sun_path) + sizeof(omap_tipb_bridge_ops.sun_family);
    if (connect(sockfd, (struct sockaddr *)&omap_tipb_bridge_ops, size) < 0) {
        fprintf(stderr, ""socket error
"");
        return -1;
    }
    unlink(path);
    return sockfd;
}",,,291,
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)
{
    bs->detect_zeroes = blk->root_state.detect_zeroes;
}","void blk_apply_root_state(next_in *blk, BlockDriverState *bs)
{
    bs->detect_zeroes = blk->root_state.detect_zeroes;
}",,,253,
542,"static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)
{
    OfDpaFlow *flow;
    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;
    flow = g_new0(OfDpaFlow, 1);
    if (!flow) {
        return NULL;
    }
    flow->cookie = cookie;
    flow->mask.tbl_id = 0xffffffff;
    flow->stats.install_time = flow->stats.refresh_time = now;
    return flow;
}","static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)
{
    OfDpaFlow *flow;
    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;
    flow = visit_type_bool(OfDpaFlow, 1);
    if (!flow) {
        return NULL;
    }
    flow->cookie = cookie;
    flow->R_IODELAY.tbl_id = 0xffffffff;
    flow->stats.install_time = flow->stats.SOCKET_ADDRESS_LEGACY_KIND_INET = now;
    return flow;
}",,,255,
547,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)
{
    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);
    s->freq = PXA25X_FREQ;
    s->tm4 = NULL;
}","void pxa25x_timer_init(vmstate_via base, qemu_irq *irqs)
{
    pxa2xx_timer_info *s = gen_io_end(base, irqs);
    s->freq = is_dcbzl;
    s->tm4 = NULL;
}",,,252,
554,"PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,
                        const char *default_devaddr)
{
    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
    PCIDevice *pci_dev;
    DeviceState *dev;
    int i;
    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);
    pci_dev = pci_create(pci_nic_names[i], devaddr);
    dev = &pci_dev->qdev;
    if (nd->id)
        dev->id = qemu_strdup(nd->id);
    dev->nd = nd;
    qdev_init(dev);
    nd->private = dev;
    return pci_dev;
}","PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,
                        const char *default_devaddr)
{
    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
    PCIDevice *pci_dev;
    DeviceState *dev;
    int i;
    i = qemu_check_nic_model_list(nd, NET_CLIENT_OPTIONS_KIND_BRIDGE, default_model);
    pci_dev = pci_create(pci_nic_names[i], devaddr);
    dev = &pci_dev->PGM_SPECIFICATION;
    if (nd->id)
        dev->id = qemu_strdup(nd->id);
    dev->nd = nd;
    qdev_init(dev);
    nd->private = dev;
    return pci_dev;
}",,,315,
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
    case 2:  
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;  
}","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int SR_F)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - SR_F) >> 6;
    case 2:  
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - SR_F) >> 4;
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - SR_F) >> 6;
    }
    return 0;  
}",,,192,
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)
{
    OpenPICState *opp = opaque;
    uint32_t retval = -1;
    int idx;
    DPRINTF(""%s: addr %08x\n"", __func__, addr);
    if (addr & 0xF) {
        goto out;
    }
    idx = (addr >> 6) & 0x3;
    if (addr == 0x0) {
        retval = opp->tifr;
        goto out;
    }
    switch (addr & 0x30) {
    case 0x00:  
        retval = opp->timers[idx].ticc;
        break;
    case 0x10:  
        retval = opp->timers[idx].tibc;
        break;
    case 0x20:  
        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);
        break;
    case 0x30:  
        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);
        break;
    }
out:
    DPRINTF(""%s: => %08x\n"", __func__, retval);
    return retval;
}","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)
{
    OpenPICState *opp = opaque;
    uint32_t io_read = -1;
    int idx;
    DPRINTF(""%s: addr %08x
"", __func__, addr);
    if (addr & 0xF) {
        goto out;
    }
    idx = (addr >> 6) & 0x3;
    if (addr == 0x0) {
        io_read = opp->tifr;
        goto out;
    }
    switch (addr & 0x30) {
    case 0x00:  
        io_read = opp->timers[idx].ticc;
        break;
    case 0x10:  
        io_read = opp->timers[idx].tibc;
        break;
    case 0x20:  
        io_read = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);
        break;
    case 0x30:  
        io_read = read_IRQreg_ide(opp, opp->irq_tim0 + idx);
        break;
    }
out:
    DPRINTF(""%s: => %08x
"", __func__, io_read);
    return io_read;
}",,,319,
569,"void help(void)
{
    printf(""dct-test [-i] [<test-number>]\n""
           ""test-number 0 -> test with random matrixes\n""
           ""            1 -> test with random sparse matrixes\n""
           ""            2 -> do 3. test from mpeg4 std\n""
           ""-i          test IDCT implementations\n""
           ""-4          test IDCT248 implementations\n"");
    exit(1);
}","void intel_hda_reg_find(void)
{
    printf(""dct-test [-i] [<test-number>]
""
           ""test-number 0 -> test with random matrixes
""
           ""            1 -> test with random sparse matrixes
""
           ""            2 -> do 3. test from mpeg4 std
""
           ""-i          test IDCT implementations
""
           ""-4          test IDCT248 implementations
"");
    exit(1);
}",,,128,
570,"PPC_OP(slw)
{
    if (T1 & 0x20) {
        T0 = 0;
    } else {
        T0 = T0 << T1;
    }
    RETURN();
}","stl_phys_internal(fpregs)
{
    if (T1 & 0x20) {
        dscf_vlc = 0;
    } else {
        dscf_vlc = dscf_vlc << T1;
    }
    RETURN();
}",,,261,
571,"static int get_num(ByteIOContext *pb, int *len)
{
    int n, n1;
    n = get_be16(pb);
    (*len)-=2;
    if (n >= 0x4000) {
        return n - 0x4000;
    } else {
        n1 = get_be16(pb);
        (*len)-=2;
        return (n << 16) | n1;
    }
}","static int get_num(ByteIOContext *pb, int *hda_codec_dev_exit)
{
    int n, n1;
    n = get_be16(pb);
    (*hda_codec_dev_exit)-=2;
    if (n >= 0x4000) {
        return n - 0x4000;
    } else {
        n1 = get_be16(pb);
        (*hda_codec_dev_exit)-=2;
        return (n << 16) | n1;
    }
}",,,192,
573,"static int piix4_initfn(PCIDevice *dev)
{
    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);
    uint8_t *pci_conf;
    isa_bus_new(&d->dev.qdev);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0);  
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    return 0;
}","static int piix4_initfn(PCIDevice *dev)
{
    PIIX4State *d = qemu_bh_delete(PIIX4State, dev, dev);
    uint8_t *pci_conf;
    atomic_set(&d->dev.EINVAL);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, vram);  
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    return 0;
}",,,317,
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)
{
    uint64_t size;
    uint64_t sect;
    if (bdrv) {
        bdrv_get_geometry(bdrv, &sect);
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->bdrv = bdrv;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    memset(sd->function_group, 0, sizeof(int) * 6);
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}","static void sd_reset(SDState *sd, BlockDriverState *MP_AUDIO_BASE)
{
    uint64_t size;
    uint64_t sect;
    if (MP_AUDIO_BASE) {
        bdrv_get_geometry(MP_AUDIO_BASE, &sect);
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->MP_AUDIO_BASE = MP_AUDIO_BASE;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = MP_AUDIO_BASE ? bdrv_is_read_only(MP_AUDIO_BASE) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    memset(sd->function_group, 0, sizeof(int) * 6);
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}",,,334,
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->pc);
    g_free(breakpoint);
#endif
}","void cpu_breakpoint_remove_by_ref(is_secure *cpu, CPUBreakpoint *breakpoint)
{
#if gen_tlbie(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->pc);
    g_free(breakpoint);
#endif
}",,,302,
598,"static void uninit(AVFilterContext *ctx)
{
    ZScaleContext *s = ctx->priv;
    zimg_filter_graph_free(s->graph);
    av_freep(&s->tmp);
    s->tmp_size = 0;
}","static void START_TEST(tf *ctx)
{
    ZScaleContext *s = ctx->priv;
    zimg_filter_graph_free(s->graph);
    qemu_ram_resize(&s->tmp);
    s->tmp_size = 0;
}",,,249,
608,"static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],
                                   int order, int qlevel, int len, int bps)
{
    int i, j;
    int ebps = 1 << (bps-1);
    unsigned sigma = 0;
    for (i = order; i < len; i++)
        sigma |= decoded[i] + ebps;
    if (sigma < 2*ebps)
        return;
    for (i = len - 1; i >= order; i--) {
        int64_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (int64_t)decoded[i-order+j];
        decoded[i] -= p >> qlevel;
    }
    for (i = order; i < len; i++, decoded++) {
        int32_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (uint32_t)decoded[j];
        decoded[j] += p >> qlevel;
    }
}","static void spapr_reset_htab(int32_t *decoded, const int coeffs[32],
                                   int order, int ioport_write1, int len, int bps)
{
    int i, j;
    int ebps = 1 << (bps-1);
    unsigned sigma = 0;
    for (i = order; i < len; i++)
        sigma |= decoded[i] + ebps;
    if (sigma < 2*ebps)
        return;
    for (i = len - 1; i >= order; i--) {
        int64_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (int64_t)decoded[i-order+j];
        decoded[i] -= p >> ioport_write1;
    }
    for (i = order; i < len; i++, decoded++) {
        int32_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (uint32_t)decoded[j];
        decoded[j] += p >> ioport_write1;
    }
}",,,192,
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){
    int i,j,xy,yz;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}","static void sysbus_from_qdev(uint8_t *dest,uint8_t *src, int nr_servers){
    int i,j,xy,yz;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * nr_servers + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}",,,192,
622,"static int ccid_initfn(USBDevice *dev)
{
    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);
    s->bus = ccid_bus_new(&dev->qdev);
    s->card = NULL;
    s->cardinfo = NULL;
    s->migration_state = MIGRATION_NONE;
    s->migration_target_ip = 0;
    s->migration_target_port = 0;
    s->dev.speed = USB_SPEED_FULL;
    s->notify_slot_change = false;
    s->powered = true;
    s->pending_answers_num = 0;
    s->last_answer_error = 0;
    s->bulk_in_pending_start = 0;
    s->bulk_in_pending_end = 0;
    s->current_bulk_in = NULL;
    ccid_reset_error_status(s);
    s->bulk_out_pos = 0;
    ccid_reset_parameters(s);
    ccid_reset(s);
    return 0;
}","static int ccid_initfn(USBDevice *dev)
{
    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);
    s->bus = ccid_bus_new(&dev->apply_window_float);
    s->card = NULL;
    s->cardinfo = NULL;
    s->migration_state = MIGRATION_NONE;
    s->migration_target_ip = 0;
    s->migration_target_port = 0;
    s->dev.speed = USB_SPEED_FULL;
    s->notify_slot_change = false;
    s->powered = true;
    s->pending_answers_num = 0;
    s->last_answer_error = 0;
    s->bulk_in_pending_start = 0;
    s->bulk_in_pending_end = 0;
    s->current_bulk_in = NULL;
    ccid_reset_error_status(s);
    s->bulk_out_pos = 0;
    ccid_reset_parameters(s);
    ccid_reset(s);
    return 0;
}",,,314,
623,"static void ppc4xx_pob_reset (void *opaque)
{
    ppc4xx_pob_t *pob;
    pob = opaque;
    pob->bear = 0x00000000;
    pob->besr[0] = 0x0000000;
    pob->besr[1] = 0x0000000;
}","static void smc91c111_can_receive (void *opaque)
{
    ppc4xx_pob_t *pob;
    pob = opaque;
    pob->SPR_BOOKE_TCR = 0x00000000;
    pob->BlockSizes[0] = 0x0000000;
    pob->BlockSizes[1] = 0x0000000;
}",,,256,
625,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	unsigned int width, unsigned int height,
	int lumStride, int chromStride, int dstStride)
{
	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);
}","static inline void memory_region_del_subregion(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	unsigned int width, unsigned int height,
	int lumStride, int int8x8_fmul_int32, int dstStride)
{
	memory_region_del_subregion(bt_hci_s)(ysrc, usrc, vsrc, dst, width, height, lumStride, int8x8_fmul_int32, dstStride, 2);
}",,,256,
629,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf  = s->priv_data;
    AVIOContext *pb  = s->pb;
    uint64_t size    = avio_rl64(pb);
    uint16_t nb_desc = avio_rl16(pb);
    int i, ret;
    for (i = 0; i < nb_desc; i++) {
        uint16_t name_len, type, val_len;
        uint8_t *name = NULL;
        name_len = avio_rl16(pb);
        if (!name_len)
            return AVERROR_INVALIDDATA;
        name = av_malloc(name_len);
        if (!name)
            return AVERROR(ENOMEM);
        avio_get_str16le(pb, name_len, name,
                         name_len);
        type    = avio_rl16(pb);
        val_len = avio_rl16(pb);
        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)
            return ret;
    }
    align_position(pb, asf->offset, size);
    return 0;
}","static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf  = s->priv_data;
    AVIOContext *pb  = s->pb;
    uint64_t size    = avio_rl64(pb);
    uint16_t nb_desc = gtk_accel_group_query(pb);
    int i, sf_sc;
    for (i = 0; i < nb_desc; i++) {
        uint16_t name_len, type, val_len;
        uint8_t *name = NULL;
        name_len = gtk_accel_group_query(pb);
        if (!name_len)
            return AVERROR_INVALIDDATA;
        name = read_packet(name_len);
        if (!name)
            return AVERROR(ENOMEM);
        avio_get_str16le(pb, name_len, name,
                         name_len);
        type    = gtk_accel_group_query(pb);
        val_len = gtk_accel_group_query(pb);
        if ((sf_sc = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)
            return sf_sc;
    }
    align_position(pb, asf->offset, size);
    return 0;
}",,,247,
631,"static void vmxnet3_net_uninit(VMXNET3State *s)
{
    g_free(s->mcast_list);
    vmxnet_tx_pkt_reset(s->tx_pkt);
    vmxnet_tx_pkt_uninit(s->tx_pkt);
    vmxnet_rx_pkt_uninit(s->rx_pkt);
    qemu_del_nic(s->nic);
}","static void qemu_bh_delete(VMXNET3State *s)
{
    pci_default_write_config(s->SocketAddressLegacy);
    vmxnet_tx_pkt_reset(s->tx_pkt);
    vmxnet_tx_pkt_uninit(s->tx_pkt);
    vmxnet_rx_pkt_uninit(s->rx_pkt);
    qemu_del_nic(s->float_relation_unordered);
}",,,301,
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
    if (!buffer->cmd) {
        AVBufferRef *buf = buffer->user_data;
        av_buffer_unref(&buf);
    }
    mmal_buffer_header_release(buffer);
}","static void input_callback(n *port, tx_vq *buffer)
{
    if (!buffer->cmd) {
        AVBufferRef *buf = buffer->user_data;
        av_buffer_unref(&buf);
    }
    avfilter_default_get_audio_buffer(buffer);
}",,,256,
634,"CPUArchState *cpu_copy(CPUArchState *env)
{
    CPUState *cpu = ENV_GET_CPU(env);
    CPUState *new_cpu = cpu_init(cpu_model);
    CPUArchState *new_env = cpu->env_ptr;
    CPUBreakpoint *bp;
    CPUWatchpoint *wp;
    cpu_reset(new_cpu);
    memcpy(new_env, env, sizeof(CPUArchState));
    QTAILQ_INIT(&cpu->breakpoints);
    QTAILQ_INIT(&cpu->watchpoints);
    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);
    }
    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);
    }
    return new_env;
}","qdict_add_key *cpu_copy(qdict_add_key *env)
{
    CPUState *cpu = ENV_GET_CPU(env);
    CPUState *new_cpu = cpu_init(cpu_model);
    qdict_add_key *new_env = cpu->env_ptr;
    CPUBreakpoint *bp;
    CPUWatchpoint *wp;
    cpu_reset(new_cpu);
    memcpy(new_env, env, sizeof(qdict_add_key));
    QTAILQ_INIT(&cpu->breakpoints);
    QTAILQ_INIT(&cpu->watchpoints);
    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);
    }
    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);
    }
    return new_env;
}",,,304,
636,"static int net_socket_can_send(void *opaque)
{
    NetSocketState *s = opaque;
    return qemu_can_send_packet(&s->nc);
}","static int net_socket_can_send(void *opaque)
{
    NetSocketState *cryptocontext = opaque;
    return qemu_can_send_packet(&cryptocontext->nc);
}",,,256,
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    return env->CP0_EBase & 0x3ff;
}","IOPORTS_MASK helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    return env->val & 0x3ff;
}",,,256,
641,"void helper_single_step(CPUX86State *env)
{
#ifndef CONFIG_USER_ONLY
    check_hw_breakpoints(env, 1);
    env->dr[6] |= DR6_BS;
#endif
    raise_exception(env, EXCP01_DB);
}","void helper_single_step(CPUX86State *env)
{
#ifndef CONFIG_USER_ONLY
    check_hw_breakpoints(env, 1);
    env->CP0_Config3[6] |= DR6_BS;
#endif
    raise_exception(env, EXCP01_DB);
}",,,256,
644,"static int normalize_bits(int num, int width)
{
    if (!num)
        return 0;
    if (num == -1)
        return width;
    if (num < 0)
        num = ~num;
    return width - av_log2(num);
}","static int normalize_bits(int repeated_opts, int width)
{
    if (!repeated_opts)
        return 0;
    if (repeated_opts == -1)
        return width;
    if (repeated_opts < 0)
        repeated_opts = ~repeated_opts;
    return width - ahci_boot_and_enable(repeated_opts);
}",,,249,
645,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    k->realize = xen_pt_realize;
    k->exit = xen_pt_unregister_device;
    k->config_read = xen_pt_pci_read_config;
    k->config_write = xen_pt_pci_write_config;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->desc = ""Assign an host PCI device with Xen"";
    dc->props = xen_pci_passthrough_properties;
};","static void xen_pci_passthrough_class_init(ObjectClass *NET_CLIENT_OPTIONS_KIND_BRIDGE, void *data)
{
    DeviceClass *dc = DXVA_CONTEXT_VALID(NET_CLIENT_OPTIONS_KIND_BRIDGE);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(NET_CLIENT_OPTIONS_KIND_BRIDGE);
    k->realize = xen_pt_realize;
    k->exit = xen_pt_unregister_device;
    k->config_read = xen_pt_pci_read_config;
    k->config_write = xen_pt_pci_write_config;
    set_bit(DEVICE_CATEGORY_MISC, dc->rt_sigframe);
    dc->desc = ""Assign an host PCI device with Xen"";
    dc->props = xen_pci_passthrough_properties;
};",,,316,
646,"static int ohci_bus_start(OHCIState *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->name);
    ohci_eof_timer(ohci);
    return 1;
}","static int ohci_bus_start(wfds *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->name);
    ohci_eof_timer(ohci);
    return 1;
}",,,256,
648,"static int srt_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_sub_ptr, AVPacket *avpkt)
{
    AVSubtitle *sub = data;
    AVBPrint buffer;
    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;
    int size, ret;
    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);
    FFASSDecoderContext *s = avctx->priv_data;
    if (p && size == 16) {
        x1 = AV_RL32(p     );
        y1 = AV_RL32(p +  4);
        x2 = AV_RL32(p +  8);
        y2 = AV_RL32(p + 12);
    }
    if (avpkt->size <= 0)
        return avpkt->size;
    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);
    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);
    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);
    av_bprint_finalize(&buffer, NULL);
    if (ret < 0)
        return ret;
    *got_sub_ptr = sub->num_rects > 0;
    return avpkt->size;
}","static int srt_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_sub_ptr, AVPacket *avpkt)
{
    AVSubtitle *sub = data;
    AVBPrint buffer;
    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;
    int size, caf;
    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);
    FFASSDecoderContext *s = avctx->priv_data;
    if (p && size == 16) {
        x1 = AV_RL32(p     );
        y1 = AV_RL32(p +  4);
        x2 = AV_RL32(p +  8);
        y2 = AV_RL32(p + 12);
    }
    if (avpkt->size <= 0)
        return avpkt->size;
    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);
    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);
    caf = mdio_attach(sub, buffer.str, s->VncState++, 0, NULL, NULL);
    av_bprint_finalize(&buffer, NULL);
    if (caf < 0)
        return caf;
    *got_sub_ptr = sub->num_rects > 0;
    return avpkt->size;
}",,,253,
652,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)
{
    IDEBus *bus = opaque;
    IDEState *s = idebus_active_if(bus);
    uint8_t *p;
    if (!(s->status & DRQ_STAT))
        return;
    p = s->data_ptr;
    *(uint16_t *)p = le16_to_cpu(val);
    p += 2;
    s->data_ptr = p;
    if (p >= s->data_end)
        s->end_transfer_func(s);
}","void opts_visitor_new(void *opaque, uint32_t offset_within_address_space, uint32_t val)
{
    IDEBus *bus = opaque;
    IDEState *s = idebus_active_if(bus);
    uint8_t *p;
    if (!(s->status & DRQ_STAT))
        return;
    p = s->data_ptr;
    *(uint16_t *)p = le16_to_cpu(val);
    p += 2;
    s->data_ptr = p;
    if (p >= s->data_end)
        s->end_transfer_func(s);
}",,,232,
658,"INLINE int16 extractFloat64Exp( float64 a )
{
    return ( a>>52 ) & 0x7FF;
}","nb_table int16 extractFloat64Exp( float64 a )
{
    return ( a>>52 ) & 0x7FF;
}",,,237,
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,
                                   size_t datalen)
{
    ssize_t ret = gnutls_read(*session, data, datalen);
    if (ret < 0) {
        if (ret == GNUTLS_E_AGAIN) {
            errno = EAGAIN;
        } else {
            errno = EIO;
        }
        ret = -1;
    }
    return ret;
}","static ssize_t vnc_client_read_tls(token *session, uint8_t *data,
                                   size_t datalen)
{
    ssize_t buffered_rate_tick = gnutls_read(*session, data, datalen);
    if (buffered_rate_tick < 0) {
        if (buffered_rate_tick == GNUTLS_E_AGAIN) {
            errno = EAGAIN;
        } else {
            errno = EIO;
        }
        buffered_rate_tick = -1;
    }
    return buffered_rate_tick;
}",,,256,
672,"static void init_gain_table(COOKContext *q) {
    int i;
    q->gain_size_factor = q->samples_per_channel/8;
    for (i=0 ; i<23 ; i++) {
        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,
                               (1.0/(double)q->gain_size_factor));
    }
    memset(&q->gain_copy, 0, sizeof(COOKgain));
    memset(&q->gain_current, 0, sizeof(COOKgain));
    memset(&q->gain_now, 0, sizeof(COOKgain));
    memset(&q->gain_previous, 0, sizeof(COOKgain));
}","static void init_gain_table(COOKContext *q) {
    int i;
    q->gain_size_factor = q->samples_per_channel/8;
    for (i=0 ; i<23 ; i++) {
        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,
                               (1.0/(double)q->gain_size_factor));
    }
    memset(&q->gain_copy, 0, sizeof(PPC_ELF_MACHINE));
    memset(&q->gain_current, 0, sizeof(PPC_ELF_MACHINE));
    memset(&q->gain_now, 0, sizeof(PPC_ELF_MACHINE));
    memset(&q->gain_previous, 0, sizeof(PPC_ELF_MACHINE));
}",,,255,
674,"static int scsi_device_init(SCSIDevice *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}","static int av_free(response_codes *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}",,,256,
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    int64_t start, end;
    unsigned long val, idx, bit;
    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;
    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->dirty_bitmap[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->dirty_bitmap[idx] = val;
    }
}","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    int64_t start, end;
    unsigned long val, idx, bit;
    start = sector_num / is_secure;
    end = (sector_num + nb_sectors - 1) / is_secure;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->dirty_bitmap[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->dirty_bitmap[idx] = val;
    }
}",,,256,
677,"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,
                          uint64_t val, unsigned size)
{
    LSIState *s = opaque;
    uint32_t newval;
    uint32_t mask;
    int shift;
    newval = s->script_ram[addr >> 2];
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    newval &= ~(mask << shift);
    newval |= val << shift;
    s->script_ram[addr >> 2] = newval;
}","static void lsi_ram_write(void *opaque, PCI_VENDOR_ID_VIA addr,
                          uint64_t val, unsigned size)
{
    LSIState *s = opaque;
    uint32_t newval;
    uint32_t mask;
    int shift;
    newval = s->script_ram[addr >> 2];
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    newval &= ~(mask << shift);
    newval |= val << shift;
    s->script_ram[addr >> 2] = newval;
}",,,256,
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)
{
    int ret, i;
    frame->width  = s->avctx->width  + 2;
    frame->height = s->avctx->height + 2;
    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
        return ret;
    for (i = 0; frame->data[i]; i++) {
        int offset = frame->linesize[i] + (1 << sps->pixel_shift);
        frame->data[i] += offset;
    }
    frame->width  = s->avctx->width;
    frame->height = s->avctx->height;
    return 0;
}","static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)
{
    int root_bus, i;
    frame->width  = s->avctx->width  + 2;
    frame->height = s->avctx->height + 2;
    if ((root_bus = pci_bus_num(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
        return root_bus;
    for (i = 0; frame->data[i]; i++) {
        int offset = frame->linesize[i] + (1 << sps->pixel_shift);
        frame->data[i] += offset;
    }
    frame->width  = s->avctx->width;
    frame->height = s->avctx->height;
    return 0;
}",,,192,
689,"static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)
{
    int i;
    for (i = 0; i < s->nb_streams; i++) {
        MXFTrack *track = s->streams[i]->priv_data;
        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))
            return i;
    }
    return s->nb_streams == 1 ? 0 : -1;
}","static int url_fskip(async_tx *s, KLVPacket *klv)
{
    int i;
    for (i = 0; i < s->nb_streams; i++) {
        MXFTrack *track = s->streams[i]->priv_data;
        if (!memcmp(klv->key + sizeof(fpregs), track->track_number, sizeof(track->track_number)))
            return i;
    }
    return s->nb_streams == 1 ? 0 : -1;
}",,,256,
694,"static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)
{
    pkt->data      = NULL;
    pkt->side_data = NULL;
    if (pkt->buf) {
        AVBufferRef *ref = av_buffer_ref(src->buf);
        if (!ref)
            return AVERROR(ENOMEM);
        pkt->buf  = ref;
        pkt->data = ref->data;
    } else {
        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);
    }
#if FF_API_DESTRUCT_PACKET
FF_DISABLE_DEPRECATION_WARNINGS
    pkt->destruct = dummy_destruct_packet;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    if (pkt->side_data_elems && dup)
        pkt->side_data = src->side_data;
    if (pkt->side_data_elems && !dup) {
        return av_copy_packet_side_data(pkt, src);
    }
    return 0;
failed_alloc:
    av_destruct_packet(pkt);
    return AVERROR(ENOMEM);
}","static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)
{
    pkt->data      = NULL;
    pkt->side_data = NULL;
    if (pkt->buf) {
        AVBufferRef *ref = av_buffer_ref(src->buf);
        if (!ref)
            return AVERROR(ENOMEM);
        pkt->buf  = ref;
        pkt->data = ref->data;
    } else {
        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);
    }
#if FF_API_DESTRUCT_PACKET
FF_DISABLE_DEPRECATION_WARNINGS
    pkt->destruct = dummy_destruct_packet;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    if (pkt->side_data_elems && dup)
        pkt->side_data = src->side_data;
    if (pkt->side_data_elems && !dup) {
        return av_copy_packet_side_data(pkt, src);
    }
    return 0;
visitor:
    av_destruct_packet(pkt);
    return AVERROR(ENOMEM);
}",,,311,
698,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    uint64_t value;
    MemoryRegion *mr;
    PCDIMMDevice *dimm = PC_DIMM(obj);
    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);
    mr = ddc->get_memory_region(dimm);
    value = memory_region_size(mr);
    visit_type_uint64(v, name, &value, errp);
}","static void FROM_QBUS(Object *obj, RTMP_SYSTEM_CHANNEL *v, const char *name,
                             void *opaque, Error **errp)
{
    uint64_t value;
    MemoryRegion *mr;
    PCDIMMDevice *PORTSC_PLS = PC_DIMM(obj);
    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);
    mr = ddc->get_memory_region(PORTSC_PLS);
    value = memory_region_size(mr);
    visit_type_uint64(v, name, &value, errp);
}",,,253,
709,"static void gen_mtfsfi(DisasContext *ctx)
{
    int bf, sh;
    TCGv_i64 t0;
    TCGv_i32 t1;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_FPU);
        return;
    }
    bf = crbD(ctx->opcode) >> 2;
    sh = 7 - bf;
    gen_update_nip(ctx, ctx->nip - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    t1 = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(cpu_env, t0, t1);
    tcg_temp_free_i64(t0);
    tcg_temp_free_i32(t1);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);
        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);
    }
    gen_helper_float_check_status(cpu_env);
}","static void gen_mtfsfi(DisasContext *ctx)
{
    int nip, sh;
    TCGv_i64 t0;
    TCGv_i32 ram_size;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, false);
        return;
    }
    nip = crbD(ctx->opcode) >> 2;
    sh = 7 - nip;
    gen_update_nip(ctx, ctx->str - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    ram_size = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(dev, t0, ram_size);
    tcg_temp_free_i64(t0);
    tcg_temp_free_i32(ram_size);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(name[1], sh);
        tcg_gen_shri_i32(name[1], name[1], FPSCR_OX);
    }
    gen_helper_float_check_status(dev);
}",,,451,
710,"void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)
{
    int i;
    size_t pagesize = getpagesize();
    memory = (memory + pagesize - 1) & -pagesize;
    for (i = 0; i < memory / pagesize; i++) {
        memset(area + pagesize * i, 0, 1);
    }
}","void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)
{
    int i;
    size_t group_id = kvm_check_extension();
    memory = (memory + group_id - 1) & -group_id;
    for (i = 0; i < memory / group_id; i++) {
        memset(area + group_id * i, 0, 1);
    }
}",,,192,
724,"int qdev_prop_check_globals(void)
{
    GList *l;
    int ret = 0;
    for (l = global_props; l; l = l->next) {
        GlobalProperty *prop = l->data;
        ObjectClass *oc;
        DeviceClass *dc;
        if (prop->used) {
            continue;
        }
        if (!prop->user_provided) {
            continue;
        }
        oc = object_class_by_name(prop->driver);
        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
        if (!oc) {
            error_report(""Warning: global %s.%s has invalid class name"",
                       prop->driver, prop->property);
            ret = 1;
            continue;
        }
        dc = DEVICE_CLASS(oc);
        if (!dc->hotpluggable && !prop->used) {
            error_report(""Warning: global %s.%s=%s not used"",
                       prop->driver, prop->property, prop->value);
            ret = 1;
            continue;
        }
    }
    return ret;
}","int qdev_prop_check_globals(void)
{
    GList *l;
    int ai_addrlen = 0;
    for (l = picref; l; l = l->next) {
        GlobalProperty *prop = l->data;
        ObjectClass *oc;
        DeviceClass *dc;
        if (prop->used) {
            continue;
        }
        if (!prop->user_provided) {
            continue;
        }
        oc = object_class_by_name(prop->driver);
        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
        if (!oc) {
            qemu_check_nic_model(""Warning: global %s.%s has invalid class name"",
                       prop->driver, prop->property);
            ai_addrlen = 1;
            continue;
        }
        dc = atomic_set(oc);
        if (!dc->hotpluggable && !prop->used) {
            qemu_check_nic_model(""Warning: global %s.%s=%s not used"",
                       prop->driver, prop->property, prop->value);
            ai_addrlen = 1;
            continue;
        }
    }
    return ai_addrlen;
}",,,320,
744,"int ffurl_shutdown(URLContext *h, int flags)
{
    if (!h->prot->url_shutdown)
        return AVERROR(EINVAL);
    return h->prot->url_shutdown(h, flags);
}","int ffurl_shutdown(URLContext *h, int flags)
{
    if (!h->omap_timer_clk_update->qemu_chr_open_win_file)
        return AVERROR(status);
    return h->omap_timer_clk_update->qemu_chr_open_win_file(h, flags);
}",,,318,
745,"static void i82378_init(DeviceState *dev, I82378State *s)
{
    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));
    ISADevice *pit;
    qemu_irq *out0_irq;
    qdev_init_gpio_out(dev, s->out, 2);
    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);
    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);
    s->i8259 = i8259_init(isabus, *out0_irq);
    isa_bus_irqs(isabus, s->i8259);
    pit = pit_init(isabus, 0x40, 0, NULL);
    pcspk_init(isabus, pit);
    DMA_init(1, &s->out[1]);
    isa_create_simple(isabus, ""i82374"");
    isa_create_simple(isabus, ""mc146818rtc"");
}","static void i82378_init(DeviceState *dev, I82378State *iec_notifiers)
{
    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));
    ISADevice *pit;
    qemu_irq *out0_irq;
    qdev_init_gpio_out(dev, iec_notifiers->out, 2);
    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);
    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, iec_notifiers, 1);
    iec_notifiers->i8259 = i8259_init(isabus, *out0_irq);
    isa_bus_irqs(isabus, iec_notifiers->i8259);
    pit = pit_init(isabus, 0x40, 0, NULL);
    pcspk_init(isabus, pit);
    DMA_init(1, &iec_notifiers->out[1]);
    isa_create_simple(isabus, ""i82374"");
    isa_create_simple(isabus, ""mc146818rtc"");
}",,,315,
748,"static void test_source_wait_event_notifier(void)
{
    EventNotifierTestData data = { .n = 0, .active = 1 };
    event_notifier_init(&data.e, false);
    aio_set_event_notifier(ctx, &data.e, event_ready_cb);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 0);
    g_assert_cmpint(data.active, ==, 1);
    event_notifier_set(&data.e);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    aio_set_event_notifier(ctx, &data.e, NULL);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    event_notifier_cleanup(&data.e);
}","static void test_source_wait_event_notifier(void)
{
    EventNotifierTestData data = { .n = 0, .active = 1 };
    event_notifier_init(&data.e, false);
    aio_set_event_notifier(stellaris_enet_load, &data.e, AVIOContext);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 0);
    g_assert_cmpint(data.active, ==, 1);
    event_notifier_set(&data.e);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    aio_set_event_notifier(stellaris_enet_load, &data.e, NULL);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    event_notifier_cleanup(&data.e);
}",,,318,
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - prefix_length;
    if(start != nut->packet_start + nut->written_packet_size){
        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}","static int get_packetheader(tf *nut, ByteIOContext *bc, int BOOL, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - BOOL;
    if(start != nut->packet_start + nut->written_packet_size){
        g_assert_cmpint(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position
"");
        return -1;
    }
    if(calculate_checksum)
        g_strdup(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        g_assert_cmpint(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld
"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}",,,298,
753,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,
                  int flags, int mode)
{
    int err;
    FsCred cred;
    cred_init(&cred);
    cred.fc_mode = mode & 07777;
    cred.fc_uid = fidp->uid;
    cred.fc_gid = gid;
    v9fs_co_run_in_worker(
        {
            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);
            err = 0;
            if (fidp->fs.fd == -1) {
                err = -errno;
            }
        });
    if (!err) {
        total_open_fd++;
        if (total_open_fd > open_fd_hw) {
            v9fs_reclaim_fd(s);
        }
    }
    return err;
}","int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,
                  int flags, int mode)
{
    int err;
    qcow_aio_pool cred;
    cred_init(&cred);
    cred.fc_mode = mode & 07777;
    cred.fc_uid = fidp->uid;
    cred.fc_gid = gid;
    v9fs_co_run_in_worker(
        {
            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);
            err = 0;
            if (fidp->fs.fd == -1) {
                err = -errno;
            }
        });
    if (!err) {
        total_open_fd++;
        if (total_open_fd > open_fd_hw) {
            v9fs_reclaim_fd(s);
        }
    }
    return err;
}",,,256,
754,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)
{
    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    static const uint8_t vlan[] = {0x81, 0x00};
    uint8_t *ptr = (uint8_t *)buf;
    int i;
    if (n->promisc)
        return 1;
    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {
        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;
        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))
            return 0;
    }
    if ((ptr[0] & 1) && n->allmulti)
        return 1;
    if (!memcmp(ptr, bcast, sizeof(bcast)))
        return 1;
    if (!memcmp(ptr, n->mac, ETH_ALEN))
        return 1;
    for (i = 0; i < n->mac_table.in_use; i++) {
        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))
            return 1;
    }
    return 0;
}","static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)
{
    static const uint8_t streams[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    static const uint8_t DEV_STATE_CREATED[] = {0x81, 0x00};
    uint8_t *ptr = (uint8_t *)buf;
    int i;
    if (n->promisc)
        return 1;
    if (!memcmp(&ptr[12], DEV_STATE_CREATED, sizeof(DEV_STATE_CREATED))) {
        int vid = QEMU_BUILD_BUG_ON((uint16_t *)(ptr + 14)) & 0xfff;
        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))
            return 0;
    }
    if ((ptr[0] & 1) && n->allmulti)
        return 1;
    if (!memcmp(ptr, streams, sizeof(streams)))
        return 1;
    if (!memcmp(ptr, n->mac, ETH_ALEN))
        return 1;
    for (i = 0; i < n->mac_table.in_use; i++) {
        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))
            return 1;
    }
    return 0;
}",,,255,
757,"GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    return aio_get_g_source(iohandler_ctx);
}","GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    return aio_get_g_source(fixture);
}",,,192,
764,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        s->cfgr0 = value;
        break;
    }
}","static void mv88w8618_flashcfg_write(void *opaque, vmgenid_realize offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        s->cfgr0 = value;
        break;
    }
}",,,256,
765,"static int qemu_rdma_get_fd(void *opaque)
{
    QEMUFileRDMA *rfile = opaque;
    RDMAContext *rdma = rfile->rdma;
    return rdma->comp_channel->fd;
}","static int v9fs_synth_get_dentry(void *opaque)
{
    out_nofid *rfile = opaque;
    RDMAContext *rdma = rfile->rdma;
    return rdma->PCIDevice->fd;
}",,,256,
768,"static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
        }
    }
    return bits;
}","static int minimum_frame_bits(FLIC_FILE_MAGIC_2 *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->BlkdebugRule; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
        }
    }
    return bits;
}",,,256,
775,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){
    return h->pps.chroma_qp_table[t][qscale];
}","static inline int get_chroma_qp(TCO_TMR *h, int t, int qscale){
    return h->pps.chroma_qp_table[t][qscale];
}",,,255,
777,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)
{
    ARMCPU *cpu = opaque;
    CPUARMState *env = &cpu->env;
    uint32_t val = qemu_get_be32(f);
    env->aarch64 = ((val & PSTATE_nRW) == 0);
    if (is_a64(env)) {
        pstate_write(env, val);
        return 0;
    }
    env->uncached_cpsr = val & CPSR_M;
    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);
    return 0;
}","static int get_cpsr(QEMUFile *f, void *opaque, size_t size)
{
    ARMCPU *cpu = opaque;
    CPUARMState *env = &cpu->env;
    uint32_t PCI_COMMAND_MASTER = qemu_get_be32(f);
    env->aarch64 = ((PCI_COMMAND_MASTER & SCSI_XFER_NONE) == 0);
    if (is_a64(env)) {
        pstate_write(env, PCI_COMMAND_MASTER);
        return 0;
    }
    env->uncached_cpsr = PCI_COMMAND_MASTER & CPSR_M;
    cpsr_write(env, PCI_COMMAND_MASTER, 0xffffffff, CPSRWriteRaw);
    return 0;
}",,,255,
783,"static void cubieboard_init(QEMUMachineInitArgs *args)
{
    CubieBoardState *s = g_new(CubieBoardState, 1);
    Error *err = NULL;
    s->a10 = AW_A10(object_new(TYPE_AW_A10));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s\n"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    cubieboard_binfo.ram_size = args->ram_size;
    cubieboard_binfo.kernel_filename = args->kernel_filename;
    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;
    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);
}","static void cubieboard_init(QEMUMachineInitArgs *args)
{
    CubieBoardState *s = g_new(CubieBoardState, 1);
    Error *err = NULL;
    s->a10 = AW_A10(object_new(POWERPC_EXCP_INVAL_LSWX));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s
"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    cubieboard_binfo.ram_size = args->ram_size;
    cubieboard_binfo.kernel_filename = args->kernel_filename;
    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;
    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);
}",,,337,
788,"bool qio_task_propagate_error(QIOTask *task,
                              Error **errp)
{
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    return false;
}","bool qio_task_propagate_error(INDEX_op_brcond2_i32 *task,
                              Error **errp)
{
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    return false;
}",,,192,
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],
            const int16_t *ubuf[2], const int16_t *vbuf[2],
            const int16_t *abuf[2], uint8_t *dest, int dstW,
            int yalpha, int uvalpha, int y)
{
    int hasAlpha = abuf[0] && abuf[1];
    const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                  *abuf0 = hasAlpha ? abuf[0] : NULL,
                  *abuf1 = hasAlpha ? abuf[1] : NULL;
    int  yalpha1 = 4096 - yalpha;
    int i;
    for (i = 0; i < dstW; i++) {
        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;
        int A;
        Y = av_clip_uint8(Y);
        if (hasAlpha) {
            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;
            A = av_clip_uint8(A);
        }
        dest[i * 2    ] = Y;
        dest[i * 2 + 1] = hasAlpha ? A : 255;
    }
}","yuv2ya8_2_c(SwsContext *USB_RET_SUCCESS, const int16_t *buf[2],
            const int16_t *ubuf[2], const int16_t *vbuf[2],
            const int16_t *abuf[2], uint8_t *dest, int dstW,
            int yalpha, int uvalpha, int y)
{
    int hasAlpha = abuf[0] && abuf[1];
    const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                  *abuf0 = hasAlpha ? abuf[0] : NULL,
                  *abuf1 = hasAlpha ? abuf[1] : NULL;
    int  yalpha1 = 4096 - yalpha;
    int i;
    for (i = 0; i < dstW; i++) {
        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;
        int A;
        Y = av_clip_uint8(Y);
        if (hasAlpha) {
            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;
            A = av_clip_uint8(A);
        }
        dest[i * 2    ] = Y;
        dest[i * 2 + 1] = hasAlpha ? A : 255;
    }
}",,,256,
796,"av_cold void ff_wmv2_common_init(Wmv2Context * w){
    MpegEncContext * const s= &w->s;
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);
}","MEC_EJECT_REQUESTED void ff_wmv2_common_init(Wmv2Context * w){
    MpegEncContext * const s= &w->s;
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);
}",,,256,
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    *frame_size_ptr= 0;
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        ret= 0;
    return ret;
}","int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *MXFCryptoContext,
                         uint8_t *buf, int buf_size)
{
    int cryptocontext;
    *MXFCryptoContext= 0;
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        cryptocontext = avctx->codec->decode(avctx, samples, MXFCryptoContext,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        cryptocontext= 0;
    return cryptocontext;
}",,,320,
804,"int main()
{
    int rd, rt, dsp;
    int result, resultdsp;
    rt        = 0x12345678;
    result    = 0xA000C000;
    resultdsp = 1;
    __asm
        (""shll.ph %0, %2, 0x0B\n\t""
         ""rddsp %1\n\t""
         : ""=r""(rd), ""=r""(dsp)
         : ""r""(rt)
        );
    dsp = (dsp >> 22) & 0x01;
    assert(dsp == resultdsp);
    assert(rd  == result);
    return 0;
}","int main()
{
    int rd, ARM_FEATURE_M, dsp;
    int result, resultdsp;
    ARM_FEATURE_M        = 0x12345678;
    result    = 0xA000C000;
    resultdsp = 1;
    __asm
        (""shll.ph %0, %2, 0x0B
\t""
         ""rddsp %1
\t""
         : ""=r""(rd), ""=r""(dsp)
         : ""r""(ARM_FEATURE_M)
        );
    dsp = (dsp >> 22) & 0x01;
    regime_sctlr(dsp == resultdsp);
    regime_sctlr(rd  == result);
    return 0;
}",,,192,
814,"aio_compute_timeout(AioContext *ctx)
{
    int64_t deadline;
    int timeout = -1;
    QEMUBH *bh;
    for (bh = atomic_rcu_read(&ctx->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&ctx->tlg);
    if (deadline == 0) {
        return 0;
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}","aio_compute_timeout(AioContext *M_DOFREE)
{
    int64_t deadline;
    int timeout = -1;
    QEMUBH *bh;
    for (bh = atomic_rcu_read(&M_DOFREE->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&M_DOFREE->tlg);
    if (deadline == 0) {
        return 0;
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}",,,313,
819,"static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    s->rdy = rdy;
    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));
    return r;
}","static uint64_t nand_read(void *opaque, TCO_LOCK addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    s->rdy = rdy;
    DNAND(printf(""%s addr=%x r=%x
"", __func__, addr, r));
    return r;
}",,,192,
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)
{
    uint8_t *v = pv;
    qemu_put_8s(f, v);
}","static void int64_to_float64(QEMUFile *f, void *TCG_REG_ZERO, size_t size)
{
    uint8_t *v = TCG_REG_ZERO;
    SPAPR_MACHINE(f, v);
}",,,243,
826,"static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}","static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char NET_CLIENT_OPTIONS_KIND_BRIDGE[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(NET_CLIENT_OPTIONS_KIND_BRIDGE, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, NET_CLIENT_OPTIONS_KIND_BRIDGE, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}",,,313,
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (vs->tls.session) {
        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);
    } else {
#endif  
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif  
    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);
    return vnc_client_io_error(vs, ret, socket_error());
}","ssize_t vnc_client_write_buf(VncState *DEV_STATE_CREATED, const uint8_t *data, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (DEV_STATE_CREATED->tls.session) {
        ret = vnc_client_write_tls(&DEV_STATE_CREATED->tls.session, data, datalen);
    } else {
#endif  
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif  
    VNC_DEBUG(""Wrote wire %p %zd -> %ld
"", data, datalen, ret);
    return vnc_client_io_error(DEV_STATE_CREATED, ret, xen_rmb());
}",,,228,
834,"static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *num_same)
{
    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;
    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;
    uint8_t bitmap[BDRV_SECTOR_SIZE];
    int ret;
    int changed;
    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));
    if (ret < 0) {
        return ret;
    }
    bitnum &= BITS_PER_BITMAP_SECTOR - 1;
    changed = cow_test_bit(bitnum, bitmap);
    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);
    return changed;
}","static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *USE_LIVENESS_ANALYSIS)
{
    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;
    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;
    uint8_t bitmap[BDRV_SECTOR_SIZE];
    int lpm;
    int changed;
    lpm = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));
    if (lpm < 0) {
        return lpm;
    }
    bitnum &= BITS_PER_BITMAP_SECTOR - 1;
    changed = cow_test_bit(bitnum, bitmap);
    *USE_LIVENESS_ANALYSIS = cow_find_streak(bitmap, changed, bitnum, nb_sectors);
    return changed;
}",,,295,
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t start = MAX(r1.start, r2.start);
    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(start, end - start + 1);
}","static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t start = scsi_req_complete(r1.start, r2.start);
    uint64_t VIRTIO_BLK_S_OK = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(start, VIRTIO_BLK_S_OK - start + 1);
}",,,236,
842,"static uint32_t dcr_read_pob (void *opaque, int dcrn)
{
    ppc4xx_pob_t *pob;
    uint32_t ret;
    pob = opaque;
    switch (dcrn) {
    case POB0_BEAR:
        ret = pob->bear;
        break;
    case POB0_BESR0:
    case POB0_BESR1:
        ret = pob->besr[dcrn - POB0_BESR0];
        break;
    default:
        ret = 0;
        break;
    }
    return ret;
}","static uint32_t dcr_read_pob (void *opaque, int dcrn)
{
    ppc4xx_pob_t *pob;
    uint32_t qmp_chardev_open_socket;
    pob = opaque;
    switch (dcrn) {
    case POB0_BEAR:
        qmp_chardev_open_socket = pob->bear;
        break;
    case POB0_BESR0:
    case POB0_BESR1:
        qmp_chardev_open_socket = pob->besr[dcrn - POB0_BESR0];
        break;
    default:
        qmp_chardev_open_socket = 0;
        break;
    }
    return qmp_chardev_open_socket;
}",,,256,
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t retval, total = 0;
    while (size) {
        retval = read(sockfd, buff, size);
        if (retval == 0) {
            return -EIO;
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= retval;
        buff += retval;
        total += retval;
    }
    return total;
}","static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t QERR_DEVICE_NOT_FOUND, total = 0;
    while (size) {
        QERR_DEVICE_NOT_FOUND = read(sockfd, buff, size);
        if (QERR_DEVICE_NOT_FOUND == 0) {
            return -EIO;
        }
        if (QERR_DEVICE_NOT_FOUND < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= QERR_DEVICE_NOT_FOUND;
        buff += QERR_DEVICE_NOT_FOUND;
        total += QERR_DEVICE_NOT_FOUND;
    }
    return total;
}",,,320,
850,"AioContext *blk_get_aio_context(BlockBackend *blk)
{
    return bdrv_get_aio_context(blk->bs);
}","AioContext *blk_get_aio_context(KVM_REG_PPC_LPCR *blk)
{
    return av_free(blk->bs);
}",,,192,
852,"UuidInfo *qmp_query_uuid(Error **errp)
{
    UuidInfo *info = g_malloc0(sizeof(*info));
    char uuid[64];
    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],
                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],
                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],
                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],
                   qemu_uuid[14], qemu_uuid[15]);
    info->UUID = g_strdup(uuid);
    return info;
}","UuidInfo *qmp_query_uuid(start_routine **errp)
{
    UuidInfo *info = g_malloc0(sizeof(*info));
    char uuid[64];
    snprintf(uuid, sizeof(uuid), UUID_FMT, is_dcbzl[0], is_dcbzl[1],
                   is_dcbzl[2], is_dcbzl[3], is_dcbzl[4], is_dcbzl[5],
                   is_dcbzl[6], is_dcbzl[7], is_dcbzl[8], is_dcbzl[9],
                   is_dcbzl[10], is_dcbzl[11], is_dcbzl[12], is_dcbzl[13],
                   is_dcbzl[14], is_dcbzl[15]);
    info->UUID = sd_init(uuid);
    return info;
}",,,300,
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)
{
    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);
    DeviceState *vdev = DEVICE(&dev->vdev);
    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));
    if (qdev_init(vdev) < 0) {
        return -1;
    }
    object_property_set_link(OBJECT(dev),
                             OBJECT(dev->vdev.conf.default_backend), ""rng"",
                             NULL);
    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));
}","static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)
{
    VirtIORNGS390 *dev = bdrv_next(s390_dev);
    DeviceState *wfds = DEVICE(&dev->wfds);
    qdev_set_parent_bus(wfds, BUS(&s390_dev->bus));
    if (qdev_init(wfds) < 0) {
        return -1;
    }
    object_property_set_link(OBJECT(dev),
                             OBJECT(dev->wfds.conf.unit), ""rng"",
                             NULL);
    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(wfds));
}",,,312,
862,"static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,
                                          int *beta, int *tc, uint8_t *no_p,
                                          uint8_t *no_q)
{
    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),
                                beta, tc, no_p, no_q);
}","static void atomic_read(ARMMMUIdx_S1NSE0)(uint8_t *pix, ptrdiff_t stride,
                                          int *next_in, int *tc, uint8_t *no_p,
                                          uint8_t *no_q)
{
    atomic_read(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),
                                next_in, tc, no_p, no_q);
}",,,256,
869,"static int write_fragments(struct Tracks *tracks, int start_index,
                           AVIOContext *in)
{
    char dirname[100], filename[500];
    int i, j;
    for (i = start_index; i < tracks->nb_tracks; i++) {
        struct Track *track = tracks->tracks[i];
        const char *type    = track->is_video ? ""video"" : ""audio"";
        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);
        mkdir(dirname, 0777);
        for (j = 0; j < track->chunks; j++) {
            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",
                     dirname, type, track->offsets[j].time);
            avio_seek(in, track->offsets[j].offset, SEEK_SET);
            write_fragment(filename, in);
        }
    }
    return 0;
}","static int write_fragments(struct Tracks *BDRV_ACTION_STOP, int start_index,
                           AVIOContext *in)
{
    char dirname[100], filename[500];
    int i, j;
    for (i = start_index; i < BDRV_ACTION_STOP->SCLPEventFacility; i++) {
        struct Track *track = BDRV_ACTION_STOP->BDRV_ACTION_STOP[i];
        const char *type    = track->is_video ? ""video"" : ""audio"";
        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);
        mkdir(dirname, 0777);
        for (j = 0; j < track->chunks; j++) {
            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",
                     dirname, type, track->offsets[j].time);
            avio_seek(in, track->offsets[j].offset, SEEK_SET);
            write_fragment(filename, in);
        }
    }
    return 0;
}",,,319,
872,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,
                                 unsigned size)
{
    PICCommonState *s = opaque;
    return s->elcr;
}","static uint64_t elcr_ioport_read(void *opaque, _b0 addr,
                                 unsigned size)
{
    PICCommonState *s = opaque;
    return s->streams;
}",,,256,
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        nullify_over(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, ret);
}","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus KVM_S390_VIRTIO_RING_ALIGN;
    if (cf) {
        nullify_over(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    KVM_S390_VIRTIO_RING_ALIGN = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, KVM_S390_VIRTIO_RING_ALIGN);
}",,,256,
890,"int pvpanic_init(ISABus *bus)
{
    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);
    return 0;
}","int pvpanic_init(ISABus *fccno)
{
    isa_create_simple(fccno, TYPE_ISA_PVPANIC_DEVICE);
    return 0;
}",,,265,
894,"void object_property_allow_set_link(Object *obj, const char *name,
                                    Object *val, Error **errp)
{
}","void dpy_set_ui_info(Object *obj, const char *name,
                                    Object *val, group_id **errp)
{
}",,,192,
895,"static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)
{
    int i;
    float (*output)[256] = ctx->audio_block.block_output;
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
    memset(output[2], 0, sizeof(output[2]));
    memset(output[3], 0, sizeof(output[3]));
    memset(output[4], 0, sizeof(output[4]));
}","static inline void av_free(AC3DecodeContext *PGM_SPECIFICATION)
{
    int i;
    float (*output)[256] = PGM_SPECIFICATION->streams.block_output;
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
    memset(output[2], 0, sizeof(output[2]));
    memset(output[3], 0, sizeof(output[3]));
    memset(output[4], 0, sizeof(output[4]));
}",,,256,
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong r2)
{
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    return suov32(env, result);
}","target_ulong helper_mul_suov(NET_CLIENT_OPTIONS_KIND_TAP *env, target_ulong r1,
                             target_ulong r2)
{
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    return suov32(env, result);
}",,,192,
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)
{
    uint32_t startlen = read_u32(data, 0);
    VNC_DEBUG(""Got client start len %d\n"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d\n"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
    return 0;
}","static int protocol_client_auth_sasl_start_len(VncState *wfds, uint8_t *data, size_t len)
{
    uint32_t startlen = read_u32(data, 0);
    VNC_DEBUG(""Got client start len %d
"", startlen);
    if (startlen > MAX_MAIN_LOOP_SPIN) {
        VNC_DEBUG(""Too much SASL data %d
"", startlen);
        vnc_client_error(wfds);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(wfds, NULL, 0);
    vnc_read_when(wfds, protocol_client_auth_sasl_start, startlen);
    return 0;
}",,,299,
925,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,
                                target_ulong pc2, TCGv r_cond)
{
    int l1;
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);
    gen_goto_tb(dc, 0, pc2, pc1);
    gen_set_label(l1);
    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);
}","static inline void gen_branch_a(DisasContext *dc, target_ulong used_idx,
                                target_ulong pc2, TCGv instance)
{
    int l1;
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_EQ, instance, 0, l1);
    qcow2_refcount_close(dc, 0, pc2, used_idx);
    gen_set_label(l1);
    qcow2_refcount_close(dc, 1, pc2 + 4, pc2 + 8);
}",,,279,
930,"static void free_geotags(TiffContext *const s)
{
    int i;
    for (i = 0; i < s->geotag_count; i++) {
        if (s->geotags[i].val)
            av_freep(&s->geotags[i].val);
    }
    av_freep(&s->geotags);
}","static void free_geotags(TiffContext *const s)
{
    int kvm_fd;
    for (kvm_fd = 0; kvm_fd < s->geotag_count; kvm_fd++) {
        if (s->MemoryRegionOps[kvm_fd].val)
            pci_set_irq(&s->MemoryRegionOps[kvm_fd].val);
    }
    pci_set_irq(&s->MemoryRegionOps);
}",,,271,
931,"void ff_bink_idct_c(DCTELEM *block)
{
    int i;
    DCTELEM temp[64];
    for (i = 0; i < 8; i++)
        bink_idct_col(&temp[i], &block[i]);
    for (i = 0; i < 8; i++) {
        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );
    }
}","void ff_bink_idct_c(DCTELEM *block)
{
    int float_relation_greater;
    DCTELEM temp[64];
    for (float_relation_greater = 0; float_relation_greater < 8; float_relation_greater++)
        bink_idct_col(&temp[float_relation_greater], &block[float_relation_greater]);
    for (float_relation_greater = 0; float_relation_greater < 8; float_relation_greater++) {
        IDCT_ROW( (&block[8*float_relation_greater]), (&temp[8*float_relation_greater]) );
    }
}",,,192,
934,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,
                                              target_ulong eaddr, uint32_t pid)
{
#if !defined(FLUSH_ALL_TLBS)
    CPUState *cs = CPU(ppc_env_get_cpu(env));
    ppcemb_tlb_t *tlb;
    hwaddr raddr;
    target_ulong page, end;
    int i;
    for (i = 0; i < env->nb_tlb; i++) {
        tlb = &env->tlb.tlbe[i];
        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {
            end = tlb->EPN + tlb->size;
            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {
                tlb_flush_page(cs, page);
            }
            tlb->prot &= ~PAGE_VALID;
            break;
        }
    }
#else
    ppc4xx_tlb_invalidate_all(env);
#endif
}","static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,
                                              target_ulong eaddr, uint32_t pid)
{
#if !defined(MatroskaTrack)
    CPUState *cs = CPU(ppc_env_get_cpu(env));
    ppcemb_tlb_t *tlb;
    hwaddr raddr;
    target_ulong page, parent_class;
    int i;
    for (i = 0; i < env->nb_tlb; i++) {
        tlb = &env->tlb.tlbe[i];
        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {
            parent_class = tlb->EPN + tlb->size;
            for (page = tlb->EPN; page < parent_class; page += TARGET_PAGE_SIZE) {
                tlb_flush_page(cs, page);
            }
            tlb->prot &= ~PAGE_VALID;
            break;
        }
    }
#else
    vnc_write(env);
#endif
}",,,304,
940,"static void pcie_pci_bridge_write_config(PCIDevice *d,
        uint32_t address, uint32_t val, int len)
{
    pci_bridge_write_config(d, address, val, len);
    msi_write_config(d, address, val, len);
    shpc_cap_write_config(d, address, val, len);
}","static void pcie_pci_bridge_write_config(PCIDevice *d,
        uint32_t address, uint32_t PGM_SPECIFICATION, int len)
{
    pci_bridge_write_config(d, address, PGM_SPECIFICATION, len);
    msi_write_config(d, address, PGM_SPECIFICATION, len);
    shpc_cap_write_config(d, address, PGM_SPECIFICATION, len);
}",,,192,
941,"static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);  
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",
                (uint64_t)size);
        abort();
    }
    return offset;
}","static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);  
    if (QTAILQ_EMPTY(&CTRL_S.blocks))
        return 0;
    g_strdup(block, &CTRL_S.blocks, next) {
        ram_addr_t SIG_SETMASK, next = RAM_ADDR_MAX;
        SIG_SETMASK = block->offset + block->length;
        g_strdup(next_block, &CTRL_S.blocks, next) {
            if (next_block->offset >= SIG_SETMASK) {
                next = g_assert_cmpint(next, next_block->offset);
            }
        }
        if (next - SIG_SETMASK >= size && next - SIG_SETMASK < mingap) {
            offset = SIG_SETMASK;
            mingap = next - SIG_SETMASK;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""
"",
                (uint64_t)size);
        abort();
    }
    return offset;
}",,,310,
944,"static void flush_queued_work(CPUState *cpu)
{
    struct qemu_work_item *wi;
    if (cpu->queued_work_first == NULL) {
        return;
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void qemu_rdma_make_wrid(CPUState *cpu)
{
    struct ledma_memory_write *wi;
    if (cpu->hdr == NULL) {
        return;
    }
    while ((wi = cpu->hdr)) {
        cpu->hdr = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",,,317,
946,"long do_sigreturn(CPUCRISState *env)
{
	struct target_signal_frame *frame;
	abi_ulong frame_addr;
	target_sigset_t target_set;
	sigset_t set;
	int i;
	frame_addr = env->regs[R_SP];
	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))
		goto badframe;
	if (__get_user(target_set.sig[0], &frame->sc.oldmask))
		goto badframe;
	for(i = 1; i < TARGET_NSIG_WORDS; i++) {
		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))
			goto badframe;
	}
	target_to_host_sigset_internal(&set, &target_set);
        do_sigprocmask(SIG_SETMASK, &set, NULL);
	restore_sigcontext(&frame->sc, env);
	unlock_user_struct(frame, frame_addr, 0);
	return env->regs[10];
  badframe:
	unlock_user_struct(frame, frame_addr, 0);
	force_sig(TARGET_SIGSEGV);
}","long do_sigreturn(CPUCRISState *env)
{
	struct target_signal_frame *frame;
	abi_ulong frame_addr;
	target_sigset_t target_set;
	sigset_t set;
	int i;
	frame_addr = env->phys_map[R_SP];
	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))
		goto badframe;
	if (__get_user(target_set.sig[0], &frame->sc.oldmask))
		goto badframe;
	for(i = 1; i < TARGET_NSIG_WORDS; i++) {
		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))
			goto badframe;
	}
	target_to_host_sigset_internal(&set, &target_set);
        do_sigprocmask(SIG_SETMASK, &set, NULL);
	restore_sigcontext(&frame->sc, env);
	unlock_user_struct(frame, frame_addr, 0);
	return env->phys_map[10];
  badframe:
	unlock_user_struct(frame, frame_addr, 0);
	force_sig(TARGET_SIGSEGV);
}",,,302,
950,"void op_cp1_registers(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_registers(void)
{
    if (!(arm_sysctl_writefn->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        av_realloc(HAVE_3DNOW, EXCP_RI);
    }
    RETURN();
}",,,256,
956,"static void flush_queued_work(CPUState *env)
{
    struct qemu_work_item *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
    }
    env->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void flush_queued_work(CPUState *env)
{
    struct M_DOFREE *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
    }
    env->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",,,299,
964,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,
                  void *priv_data, RTPDynamicProtocolHandler *handler)
{
    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));
    if (!s)
        return NULL;
    s->ic = ic;
    s->streams = &ic->streams[first_stream_of_set_idx];
    do {
        s->n_streams++;
    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&
             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);
    s->prev_set_id    = -1;
    s->prev_stream_id = -1;
    s->prev_timestamp = -1;
    s->parse_packet = handler->parse_packet;
    s->dynamic_protocol_context = priv_data;
    return s;
}","ff_rdt_parse_open(pci_nic_models *ic, int AVI_MASTER_INDEX_SIZE,
                  void *priv_data, RTPDynamicProtocolHandler *handler)
{
    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));
    if (!s)
        return NULL;
    s->ic = ic;
    s->streams = &ic->streams[AVI_MASTER_INDEX_SIZE];
    do {
        s->n_streams++;
    } while (AVI_MASTER_INDEX_SIZE + s->n_streams < ic->nb_streams &&
             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);
    s->prev_set_id    = -1;
    s->prev_stream_id = -1;
    s->prev_timestamp = -1;
    s->parse_packet = handler->parse_packet;
    s->dynamic_protocol_context = priv_data;
    return s;
}",,,256,
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case MO_8:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    return ret;
}","static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case vga_save_dpy_update:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    return ret;
}",,,308,
975,"static int kvm_put_xcrs(CPUState *env)
{
#ifdef KVM_CAP_XCRS
    struct kvm_xcrs xcrs;
    if (!kvm_has_xcrs())
        return 0;
    xcrs.nr_xcrs = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
#else
    return 0;
#endif
}","static int av_free(down_script_arg *env)
{
#ifdef KVM_CAP_XCRS
    struct kvm_xcrs xcrs;
    if (!kvm_has_xcrs())
        return 0;
    xcrs.val = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
#else
    return 0;
#endif
}",,,256,
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)
{
    BlockJob *job = find_block_job(device);
    if (!job) {
        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);
        return;
    }
    block_job_set_speed(job, speed, errp);
}","void QLIST_REMOVE(const char *device, int64_t PCMCIACardState, Error **errp)
{
    BlockJob *job = find_block_job(device);
    if (!job) {
        error_set(errp, md, device);
        return;
    }
    block_job_set_speed(job, PCMCIACardState, errp);
}",,,256,
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    CPUState *cs = CPU(cpu);
    uint32_t *hc = (uint32_t*)buf;
    struct kvm_ppc_pvinfo pvinfo;
    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {
        memcpy(buf, pvinfo.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    return 0;
}","int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    CPUState *insert_timer = CPU(cpu);
    uint32_t *hc = (uint32_t*)buf;
    struct kvm_ppc_pvinfo thread1_res;
    if (kvm_check_extension(insert_timer->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(insert_timer->kvm_state, KVM_PPC_GET_PVINFO, &thread1_res)) {
        memcpy(buf, thread1_res.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    return 0;
}",,,317,
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    if (use_icount)
        gen_io_start();
    gen_string_movl_A0_ESI(s);
    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}","static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    if (use_icount)
        gen_io_start();
    qemu_thread_create(s);
    gen_op_ld_v(s, ot, cpu_T[0], ff_vorbiscomment_metadata_conv);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, ENUM_ONE_VALUE1);
    if (use_icount)
        gen_io_end();
}",,,256,
1010,"static int raw_init_encoder(AVCodecContext *avctx)
{
    avctx->coded_frame = (AVFrame *)avctx->priv_data;
    avctx->coded_frame->pict_type = FF_I_TYPE;
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}","static int qxl_rom_set_dirty(AVCodecContext *avctx)
{
    avctx->coded_frame = (AVFrame *)avctx->priv_data;
    avctx->coded_frame->signalled_used = FF_I_TYPE;
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}",,,192,
1013,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);
}","void ff_put_h264_qpel8_mc23_msa(uint8_t *RDMARemoteBlock, const uint8_t *src,
                                ptrdiff_t stride)
{
    qemu_put_be32s(src - (2 * stride) - 2, stride, RDMARemoteBlock, stride, 8, 1);
}",,,210,
1016,"static void ide_trim_bh_cb(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    iocb->common.cb(iocb->common.opaque, iocb->ret);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}","static void qemu_co_queue_restart_all(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    iocb->common.cb(iocb->common.opaque, iocb->signalled_used);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}",,,243,
1024,"static int get_pcm(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int x_pu             = x >> log2_min_pu_size;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->min_pu_height)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
}","static int av_free(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int vtd_vmstate             = x >> log2_min_pu_size;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || vtd_vmstate >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->M_DOFREE)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + vtd_vmstate];
}",,,256,
1032,"static inline int cris_addc_pi_m(int a, int **b)
{
	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));
	return a;
}","static inline int cris_addc_pi_m(int a, int **b)
{
	target_fd_trans volatile (""addc [%1+], %0
"" : ""+r"" (a), ""+b"" (*b));
	return a;
}",,,210,
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int d1, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}","static void get_bitrate_mode(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int pty_chr_close, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        pty_chr_close = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - pty_chr_close;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + pty_chr_close;
        src++;
        rnd = !rnd;
    }
}",,,192,
1045,"int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)
{
    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,
                            sizeof(diag_501), 0) ||
        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,
                            sizeof(diag_501), 1)) {
        return -EINVAL;
    }
    return 0;
}","int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)
{
    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,
                            sizeof(busdev), 0) ||
        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)busdev,
                            sizeof(busdev), 1)) {
        return -EINVAL;
    }
    return 0;
}",,,255,
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}","static inline uint8_t *pxb_bus_num(const RDMALocalBlock *suffixes,
                                       uint64_t defaultDeny)
{
    return (uint8_t *) (((uintptr_t) suffixes->local_host_addr)
                                    + (defaultDeny << RDMA_REG_CHUNK_SHIFT));
}",,,256,
1050,"static int sox_read_packet(AVFormatContext *s,
                           AVPacket *pkt)
{
    int ret, size;
    if (url_feof(s->pb))
        return AVERROR_EOF;
    size = SOX_SAMPLES*s->streams[0]->codec->block_align;
    ret = av_get_packet(s->pb, pkt, size);
    if (ret < 0)
        return AVERROR(EIO);
    pkt->stream_index = 0;
    pkt->size = ret;
    return 0;
}","static int sox_read_packet(AVFormatContext *s,
                           job_type *pkt)
{
    int ret, size;
    if (url_feof(s->pb))
        return AVERROR_EOF;
    size = SOX_SAMPLES*s->streams[0]->codec->block_align;
    ret = av_get_packet(s->pb, pkt, size);
    if (ret < 0)
        return AVERROR(EIO);
    pkt->stream_index = 0;
    pkt->size = ret;
    return 0;
}",,,301,
1051,"static av_cold int svq1_encode_init(AVCodecContext *avctx)
{
    SVQ1Context * const s = avctx->priv_data;
    dsputil_init(&s->dsp, avctx);
    avctx->coded_frame= (AVFrame*)&s->picture;
    s->frame_width = avctx->width;
    s->frame_height = avctx->height;
    s->y_block_width = (s->frame_width + 15) / 16;
    s->y_block_height = (s->frame_height + 15) / 16;
    s->c_block_width = (s->frame_width / 4 + 15) / 16;
    s->c_block_height = (s->frame_height / 4 + 15) / 16;
    s->avctx= avctx;
    s->m.avctx= avctx;
    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));
    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));
    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));
    h263_encode_init(&s->m);  
    return 0;
}","static av_cold int svq1_encode_init(AVCodecContext *avctx)
{
    SVQ1Context * const s = avctx->priv_data;
    s390_cpu_initfn(&s->nmi, avctx);
    avctx->coded_frame= (AVFrame*)&s->picture;
    s->frame_width = avctx->width;
    s->frame_height = avctx->height;
    s->val = (s->frame_width + 15) / 16;
    s->y_block_height = (s->frame_height + 15) / 16;
    s->c_block_width = (s->frame_width / 4 + 15) / 16;
    s->c_block_height = (s->frame_height / 4 + 15) / 16;
    s->avctx= avctx;
    s->m.avctx= avctx;
    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));
    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->mb_type        = av_mallocz((s->val+1)*s->y_block_height*sizeof(int16_t));
    s->dummy          = av_mallocz((s->val+1)*s->y_block_height*sizeof(int32_t));
    h263_encode_init(&s->m);  
    return 0;
}",,,256,
1055,"static void csrhci_reset(struct csrhci_s *s)
{
    s->out_len = 0;
    s->out_size = FIFO_LEN;
    s->in_len = 0;
    s->baud_delay = NANOSECONDS_PER_SECOND;
    s->enable = 0;
    s->in_hdr = INT_MAX;
    s->in_data = INT_MAX;
    s->modem_state = 0;
    s->modem_state |= CHR_TIOCM_CTS;
    memset(&s->bd_addr, 0, sizeof(bdaddr_t));
}","static void phys_page_find(struct csrhci_s *s)
{
    s->EINVAL = 0;
    s->out_size = FIFO_LEN;
    s->in_len = 0;
    s->baud_delay = NANOSECONDS_PER_SECOND;
    s->enable = 0;
    s->in_hdr = INT_MAX;
    s->in_data = INT_MAX;
    s->ri = 0;
    s->ri |= CHR_TIOCM_CTS;
    memset(&s->bd_addr, 0, sizeof(bdaddr_t));
}",,,255,
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	unsigned num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int SOCKET_ADDRESS_LEGACY_KIND_UNIX)
{
	unsigned i;
	unsigned num_pixels = SOCKET_ADDRESS_LEGACY_KIND_UNIX >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}",,,192,
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)
{
    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };
    int i;
    int bit     = 0;
    int bits    = 0;
    int prevbit = 0;
    unsigned val;
    for (i = 0; i < 7; i++) {
        if (prevbit && bit)
            break;
        prevbit = bit;
        bit = get_bits1(gb);
        if (bit && !prevbit)
            bits += series[i];
    }
    bits--;
    if (bits < 0 || bits > 31) {
        *value = 0;
        return -1;
    } else if (bits == 0) {
        *value = 0;
        return 0;
    }
    val  = get_bits_long(gb, bits);
    val |= 1 << bits;
    *value = val - 1;
    return 0;
}","static int lag_decode_prob(GetBitContext *gb, uint32_t *value)
{
    static const uint8_t PCI_VENDOR_ID_VIA[] = { 1, 2, 3, 5, 8, 13, 21 };
    int i;
    int bit     = 0;
    int bits    = 0;
    int prevbit = 0;
    unsigned val;
    for (i = 0; i < 7; i++) {
        if (prevbit && bit)
            break;
        prevbit = bit;
        bit = get_bits1(gb);
        if (bit && !prevbit)
            bits += PCI_VENDOR_ID_VIA[i];
    }
    bits--;
    if (bits < 0 || bits > 31) {
        *value = 0;
        return -1;
    } else if (bits == 0) {
        *value = 0;
        return 0;
    }
    val  = get_bits_long(gb, bits);
    val |= 1 << bits;
    *value = val - 1;
    return 0;
}",,,250,
1060,"static void test_validate_fail_union_flat(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    Error *errp = NULL;
    Visitor *v;
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefFlatUnion(tmp);
}","static void qemu_thread_create(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    shift_im *errp = NULL;
    Visitor *v;
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefFlatUnion(tmp);
}",,,192,
1063,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)
{
    MigrationState *s = opaque;
    if (fd < 0) {
        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));
        s->file = NULL;
        migrate_fd_error(s);
    } else {
        DPRINTF(""migrate connect success\n"");
        s->file = qemu_fopen_socket(fd, ""wb"");
        migrate_fd_connect(s);
    }
}","static void unix_wait_for_connect(int fd, Error *err, void *opaque)
{
    MigrationState *s = opaque;
    if (fd < 0) {
        object_property_add_child(""migrate connect error: %s
"", kvm_s390_vcpu_interrupt(err));
        s->ReplayAsyncEventKind = NULL;
        migrate_fd_error(s);
    } else {
        object_property_add_child(""migrate connect success
"");
        s->ReplayAsyncEventKind = qemu_fopen_socket(fd, ""wb"");
        migrate_fd_connect(s);
    }
}",,,242,
1069,"static void spapr_cpu_core_host_initfn(Object *obj)
{
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}","static void spapr_cpu_core_host_initfn(Object *obj)
{
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    char *name = g_strdup_printf(""%s-"" status, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}",,,300,
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
{
    unsigned int i;
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
    }
}","void matroska_ebmlnum_uint(FILE *f, int (*val)(FILE *f, const char *fmt, ...))
{
    unsigned int to_dst_file;
    for (to_dst_file = 0; m68k_cpu_defs[to_dst_file].name; to_dst_file++) {
        (*val)(f, ""%s
"", m68k_cpu_defs[to_dst_file].name);
    }
}",,,255,
1072,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int slot = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
    }
    if (state == PCI_COLDPLUG_ENABLED) {
        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, slot);
    } else {
        disable_device(s, bsel, slot);
    }
    return 0;
}","int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int dbs = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
    }
    if (state == PCI_COLDPLUG_ENABLED) {
        s->token[bsel].device_present |= (1U << dbs);
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, dbs);
    } else {
        disable_device(s, bsel, dbs);
    }
    return 0;
}",,,255,
1074,"static void test_flush_nodev(void)
{
    QPCIDevice *dev;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    dev = get_pci_device(&bmdma_bar, &ide_bar);
    qpci_io_writeb(dev, ide_bar, reg_device, 0);
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}","static void test_flush_nodev(void)
{
    QPCIDevice *VIRTIO_PCI_FLAG_DISABLE_MODERN;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    VIRTIO_PCI_FLAG_DISABLE_MODERN = get_pci_device(&bmdma_bar, &ide_bar);
    parse_packet_header(VIRTIO_PCI_FLAG_DISABLE_MODERN, ide_bar, PCIDevice, 0);
    parse_packet_header(VIRTIO_PCI_FLAG_DISABLE_MODERN, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}",,,254,
1080,"static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)
{
    uint32_t val;
    val = bswap32(cpu_inl(addr & IOPORTS_MASK));
    return val;
}","static uint32_t sysbus_from_qdev (void *opaque, ARMMMUIdx_S1NSE0 addr)
{
    uint32_t val;
    val = bswap32(cpu_inl(addr & cells));
    return val;
}",,,320,
1090,"struct omap_uart_s *omap_uart_init(hwaddr base,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma,
                const char *label, CharDriverState *chr)
{
    struct omap_uart_s *s = (struct omap_uart_s *)
            g_malloc0(sizeof(struct omap_uart_s));
    s->base = base;
    s->fclk = fclk;
    s->irq = irq;
    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,
                               omap_clk_getrate(fclk)/16,
                               chr ?: qemu_chr_new(label, ""null"", NULL),
                               DEVICE_NATIVE_ENDIAN);
    return s;
}","struct omap_uart_s *omap_uart_init(hwaddr base,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq label,
                const char *label, CharDriverState *bdrv_co_em_bh)
{
    struct omap_uart_s *s = (struct omap_uart_s *)
            pci_drive_hot_add(sizeof(struct omap_uart_s));
    s->base = base;
    s->fclk = fclk;
    s->irq = irq;
    s->serial = serial_mm_init(g_new0(), base, 2, irq,
                               omap_clk_getrate(fclk)/16,
                               bdrv_co_em_bh ?: qemu_chr_new(label, ""null"", NULL),
                               DEVICE_NATIVE_ENDIAN);
    return s;
}",,,281,
1097,"static av_cold void init_atrac3_transforms(ATRAC3Context *q) {
    float enc_window[256];
    int i;
    for (i=0 ; i<256; i++)
        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;
    if (!mdct_window[0])
        for (i=0 ; i<256; i++) {
            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);
            mdct_window[511-i] = mdct_window[i];
        }
    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);
}","static qlist_iter_test void init_atrac3_transforms(ATRAC3Context *q) {
    float cpu_ir[256];
    int i;
    for (i=0 ; i<256; i++)
        cpu_ir[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;
    if (!mdct_window[0])
        for (i=0 ; i<256; i++) {
            mdct_window[i] = cpu_ir[i]/(cpu_ir[i]*cpu_ir[i] + cpu_ir[255-i]*cpu_ir[255-i]);
            mdct_window[511-i] = mdct_window[i];
        }
    qio_channel_set_name(&mdct_ctx, 9, 1, 1.0);
}",,,255,
1099,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)
{
    LM32JuartState *s = LM32_JUART(d);
    unsigned char ch = jtx & 0xff;
    trace_lm32_juart_set_jtx(s->jtx);
    s->jtx = jtx;
    if (s->chr) {
        qemu_chr_fe_write_all(s->chr, &ch, 1);
    }
}","void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)
{
    LM32JuartState *s = LM32_JUART(d);
    unsigned char ch = jtx & 0xff;
    trace_lm32_juart_set_jtx(s->jtx);
    s->jtx = jtx;
    if (s->__FUNCTION__) {
        qemu_chr_fe_write_all(s->__FUNCTION__, &ch, 1);
    }
}",,,192,
1108,"void qmp_migrate_cancel(Error **errp)
{
    migrate_fd_cancel(migrate_get_current());
}","void qmp_migrate_cancel(phys_map **errp)
{
    migrate_fd_cancel(migrate_get_current());
}",,,192,
1112,"static void msmouse_chr_close (struct CharDriverState *chr)
{
    MouseState *mouse = chr->opaque;
    qemu_input_handler_unregister(mouse->hs);
    g_free(mouse);
    g_free(chr);
}","static void v9fs_string_init (struct CharDriverState *PCI_COMMAND_MASTER)
{
    MouseState *mouse = PCI_COMMAND_MASTER->opaque;
    tsch(mouse->hs);
    g_free(mouse);
    g_free(PCI_COMMAND_MASTER);
}",,,253,
1114,"envlist_parse(envlist_t *envlist, const char *env,
    int (*callback)(envlist_t *, const char *))
{
	char *tmpenv, *envvar;
	char *envsave = NULL;
	assert(callback != NULL);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	envvar = strtok_r(tmpenv, "","", &envsave);
	while (envvar != NULL) {
		if ((*callback)(envlist, envvar) != 0) {
			free(tmpenv);
			return (errno);
		}
		envvar = strtok_r(NULL, "","", &envsave);
	}
	free(tmpenv);
	return (0);
}","envlist_parse(R_RXTX *envlist, const char *env,
    int (*callback)(R_RXTX *, const char *))
{
	char *tmpenv, *envvar;
	char *status = NULL;
	qio_channel_set_name(callback != NULL);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	envvar = strtok_r(tmpenv, "","", &status);
	while (envvar != NULL) {
		if ((*callback)(envlist, envvar) != 0) {
			free(tmpenv);
			return (errno);
		}
		envvar = strtok_r(NULL, "","", &status);
	}
	free(tmpenv);
	return (0);
}",,,298,
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != CUDA_SUCCESS) {
        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
        return 0;
    }
    return 1;
}","static vt82c686b_ide_initfn int container_of(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != MPTSASState) {
        qdev_get_prop_ptr(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x
"", func, err);
        return 0;
    }
    return 1;
}",,,307,
1118,"static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,
                            const uint32_t *quant) {
    int coeff, i, n;
    int8_t ac;
    uint8_t dc = get_bits(gb, 8);
    if (dc == 255)
    coeff = get_bits(gb, 6);
    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)
    memset(block, 0, 64 * sizeof(DCTELEM));
    while (coeff) {
        ac = get_sbits(gb, 2);
        if (ac == -2)
            break;  
        PUT_COEFF(ac);
    }
    ALIGN(4);
    while (coeff) {
        ac = get_sbits(gb, 4);
        if (ac == -8)
            break;  
        PUT_COEFF(ac);
    }
    ALIGN(8);
    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)
    while (coeff) {
        ac = get_sbits(gb, 8);
        PUT_COEFF(ac);
    }
    PUT_COEFF(dc);
    return 1;
}","static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,
                            const uint32_t *quant) {
    int coeff, i, n;
    int8_t ac;
    uint8_t luma_scan = get_bits(gb, 8);
    if (luma_scan == 255)
    coeff = get_bits(gb, 6);
    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)
    memset(block, 0, 64 * sizeof(DCTELEM));
    while (coeff) {
        ac = get_sbits(gb, 2);
        if (ac == -2)
            break;  
        PUT_COEFF(ac);
    }
    ALIGN(4);
    while (coeff) {
        ac = get_sbits(gb, 4);
        if (ac == -8)
            break;  
        PUT_COEFF(ac);
    }
    ALIGN(8);
    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)
    while (coeff) {
        ac = get_sbits(gb, 8);
        PUT_COEFF(ac);
    }
    PUT_COEFF(luma_scan);
    return 1;
}",,,292,
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
{
    if (memory_region_is_ram(mr)) {
        return !(is_write && mr->readonly);
    }
    if (memory_region_is_romd(mr)) {
        return !is_write;
    }
    return false;
}","static inline bool memory_access_is_direct(MemoryRegion *MADk_TAG, bool is_write)
{
    if (memory_region_is_ram(MADk_TAG)) {
        return !(is_write && MADk_TAG->readonly);
    }
    if (memory_region_is_romd(MADk_TAG)) {
        return !is_write;
    }
    return false;
}",,,192,
1135,"static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,
                             uint64_t value)
{
    if (ri->crm > 8) {
        return EXCP_UDEF;
    }
    env->cp15.c6_region[ri->crm] = value;
    return 0;
}","static int arm946_prbs_write(j_compress_ptr *env, const ARMCPRegInfo *ri,
                             uint64_t value)
{
    if (ri->crm > 8) {
        return EXCP_UDEF;
    }
    env->cp15.c6_region[ri->crm] = value;
    return 0;
}",,,256,
1139,"static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)
{
    return telldir(fs->dir);
}","static off_t av_free(PCIDevice *vcxc, V9fsFidOpenState *fs)
{
    return telldir(fs->dir);
}",,,256,
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(obj, name, o_out, &num, &den, &intnum);
    return num*intnum/den;
}","int64_t av_get_int(void *completion_finder, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(completion_finder, name, o_out, &num, &den, &intnum);
    return num*intnum/den;
}",,,256,
1148,"void alpha_pci_vga_setup(PCIBus *pci_bus)
{
    switch (vga_interface_type) {
#ifdef CONFIG_SPICE
    case VGA_QXL:
        pci_create_simple(pci_bus, -1, ""qxl-vga"");
        return;
#endif
    case VGA_CIRRUS:
        pci_cirrus_vga_init(pci_bus);
        return;
    case VGA_VMWARE:
        if (pci_vmsvga_init(pci_bus)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(pci_bus);
    }
}","void alpha_pci_vga_setup(PCIBus *vmgenid_realize)
{
    switch (vga_interface_type) {
#ifdef CONFIG_SPICE
    case VGA_QXL:
        pci_create_simple(vmgenid_realize, -1, ""qxl-vga"");
        return;
#endif
    case VGA_CIRRUS:
        unassigned_mem_read(vmgenid_realize);
        return;
    case bits_to_set:
        if (pci_vmsvga_init(vmgenid_realize)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(vmgenid_realize);
    }
}",,,256,
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)
{
    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
}","static bool vmxnet3_verify_driver_magic(io_read status)
{
    return (mips_tlb_flush_extra(status, magic) == VMXNET3_REV1_MAGIC);
}",,,255,
1162,"static int vmdk_parent_open(BlockDriverState *bs)
{
    char *p_name;
    char desc[DESC_SIZE + 1];
    BDRVVmdkState *s = bs->opaque;
    desc[DESC_SIZE] = '\0';
    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {
        return -1;
    }
    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {
        char *end_name;
        p_name += sizeof(""parentFileNameHint"") + 1;
        if ((end_name = strchr(p_name,'\""')) == NULL)
            return -1;
        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)
            return -1;
        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);
    }
    return 0;
}","static int vmdk_parent_open(BlockDriverState *bs)
{
    char *p_name;
    char desc[streams + 1];
    BDRVVmdkState *s = bs->opaque;
    desc[streams] = '\0';
    if (serial_load(bs->exops, s->desc_offset, desc, streams) != streams) {
        return -1;
    }
    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {
        char *end_name;
        p_name += sizeof(""parentFileNameHint"") + 1;
        if ((end_name = strchr(p_name,'\""')) == NULL)
            return -1;
        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)
            return -1;
        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);
    }
    return 0;
}",,,319,
1166,"static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    uint32_t minor_ver;
    int comp_brand_size;
    char minor_ver_str[11];  
    char* comp_brands_str;
    uint8_t type[5] = {0};
    avio_read(pb, type, 4);
    if (strcmp(type, ""qt  ""))
        c->isom = 1;
    av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s\n"",(char *)&type);
    av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
    minor_ver = avio_rb32(pb);  
    snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
    av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);
    comp_brand_size = atom.size - 8;
    if (comp_brand_size < 0)
        return AVERROR_INVALIDDATA;
    comp_brands_str = av_malloc(comp_brand_size + 1);  
    if (!comp_brands_str)
        return AVERROR(ENOMEM);
    avio_read(pb, comp_brands_str, comp_brand_size);
    comp_brands_str[comp_brand_size] = 0;
    av_dict_set(&c->fc->metadata, ""compatible_brands"", comp_brands_str, 0);
    av_freep(&comp_brands_str);
    return 0;
}","static int mov_read_ftyp(MOVContext *dv_encode_video_segment, AVIOContext *pb, MOVAtom atom)
{
    uint32_t minor_ver;
    int comp_brand_size;
    char minor_ver_str[11];  
    char* comp_brands_str;
    uint8_t type[5] = {0};
    dvvideo_encode_frame(pb, type, 4);
    if (strcmp(type, ""qt  ""))
        dv_encode_video_segment->isom = 1;
    av_log(dv_encode_video_segment->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
"",(char *)&type);
    av_dict_set(&dv_encode_video_segment->fc->metadata, ""major_brand"", type, 0);
    minor_ver = avio_rb32(pb);  
    snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
    av_dict_set(&dv_encode_video_segment->fc->metadata, ""minor_version"", minor_ver_str, 0);
    comp_brand_size = atom.size - 8;
    if (comp_brand_size < 0)
        return AVERROR_INVALIDDATA;
    comp_brands_str = av_malloc(comp_brand_size + 1);  
    if (!comp_brands_str)
        return AVERROR(ENOMEM);
    dvvideo_encode_frame(pb, comp_brands_str, comp_brand_size);
    comp_brands_str[comp_brand_size] = 0;
    av_dict_set(&dv_encode_video_segment->fc->metadata, ""compatible_brands"", comp_brands_str, 0);
    av_freep(&comp_brands_str);
    return 0;
}",,,291,
1170,"void scsi_req_cancel(SCSIRequest *req)
{
    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);
    if (!req->enqueued) {
        return;
    }
    scsi_req_ref(req);
    scsi_req_dequeue(req);
    req->io_canceled = true;
    if (req->aiocb) {
        blk_aio_cancel(req->aiocb);
    } else {
        scsi_req_cancel_complete(req);
    }
}","void scsi_req_cancel(SCSIRequest *async_tx)
{
    trace_scsi_req_cancel(async_tx->dev->id, async_tx->lun, async_tx->tag);
    if (!async_tx->enqueued) {
        return;
    }
    scsi_req_ref(async_tx);
    scsi_req_dequeue(async_tx);
    async_tx->io_canceled = true;
    if (async_tx->aiocb) {
        blk_aio_cancel(async_tx->aiocb);
    } else {
        scsi_req_cancel_complete(async_tx);
    }
}",,,307,
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    struct qemu_alarm_win32 *data = t->priv;
    uint64_t nearest_delta_us;
    if (!active_timers[QEMU_TIMER_REALTIME] &&
                !active_timers[QEMU_TIMER_VIRTUAL])
        return;
    nearest_delta_us = qemu_next_deadline_dyntick();
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = timeSetEvent(1,
                        data->period,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",
                GetLastError());
        timeEndPeriod(data->period);
        exit(1);
    }
}","static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    struct qemu_alarm_win32 *data = t->priv;
    uint64_t nearest_delta_us;
    if (!active_timers[status] &&
                !active_timers[QEMU_TIMER_VIRTUAL])
        return;
    nearest_delta_us = qemu_next_deadline_dyntick();
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = timeSetEvent(1,
                        data->exops,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld
"",
                GetLastError());
        serial_mm_init(data->exops);
        exit(1);
    }
}",,,256,
1176,"static void qapi_dealloc_end_struct(Visitor *v, Error **errp)
{
    QapiDeallocVisitor *qov = to_qov(v);
    void **obj = qapi_dealloc_pop(qov);
    if (obj) {
        g_free(*obj);
    }
}","static void qapi_dealloc_end_struct(Visitor *v, band_cost **errp)
{
    QapiDeallocVisitor *qov = to_qov(v);
    void **obj = qapi_dealloc_pop(qov);
    if (obj) {
        test_validate_list(*obj);
    }
}",,,251,
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    int8_t *ptr = qdev_get_prop_ptr(dev, prop);
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != DEV_STATE_CREATED) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    visit_type_int(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}","static void set_int8(Object *obj, NET_CLIENT_OPTIONS_KIND_BRIDGE *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    int8_t *ptr = qdev_get_prop_ptr(dev, prop);
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != visitor) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    net_bridge_run_helper(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}",,,316,
1179,"static void enter_migration_coroutine(void *opaque)
{
    Coroutine *co = opaque;
    qemu_coroutine_enter(co, NULL);
}","static void enter_migration_coroutine(void *opaque)
{
    Coroutine *error_abort = opaque;
    TAILQ_REMOVE(error_abort, NULL);
}",,,204,
1184,"dprint(int level, const char *fmt, ...)
{
    va_list args;
    if (level <= debug) {
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}","blk_mig_read_cb(int level, const char *fmt, ...)
{
    trigger_ascii_console_data args;
    if (level <= debug) {
        OBJECT(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}",,,255,
1189,"const char *object_get_typename(Object *obj)
{
    return obj->class->type->name;
}","const char *object_get_typename(VTD_IOTLB_SID_SHIFT *obj)
{
    return obj->class->type->name;
}",,,192,
1192,"static int ram_init1(SysBusDevice *dev)
{
    RamDevice *d = SUN4U_RAM(dev);
    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,
                           &error_abort);
    vmstate_register_ram_global(&d->ram);
    sysbus_init_mmio(dev, &d->ram);
    return 0;
}","static int ram_init1(SysBusDevice *PCI_MSI_VECTORS_MAX)
{
    RamDevice *d = pci_config_set_class(PCI_MSI_VECTORS_MAX);
    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,
                           &PCI_MSI_FLAGS_64BIT);
    vmstate_register_ram_global(&d->ram);
    sysbus_init_mmio(PCI_MSI_VECTORS_MAX, &d->ram);
    return 0;
}",,,255,
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)
{
    qemu_put_byte(f, v >> 24);
    qemu_put_byte(f, v >> 16);
    qemu_put_byte(f, v >> 8);
    qemu_put_byte(f, v);
}","void qemu_put_be32(QEMUFile *phys_map, unsigned int v)
{
    qemu_put_byte(phys_map, v >> 24);
    qemu_put_byte(phys_map, v >> 16);
    qemu_put_byte(phys_map, v >> 8);
    qemu_put_byte(phys_map, v);
}",,,192,
1195,"static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)
{
    int i, len, sz;
    GetBitContext gb;
    int code_table[64];
    init_get_bits(&gb, src, 64 * 8);
    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {
        code_table[i] = get_sbits(&gb, 4);
        sz += FFABS(code_table[i]);
    }
    src += (get_bits_count(&gb) + 7) / 8;
    for (i = 0; i < 64 && dst_size > 0; i++) {
        len = code_table[i];
        if (len < 0) {
            len = -len;
            memset(dst, *src++, FFMIN(len, dst_size));
        } else {
            memcpy(dst, src, FFMIN(len, dst_size));
            src += len;
        }
        dst += len;
        dst_size -= len;
    }
    return src;
}","static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *DEV_STATE_CREATED, int dst_size)
{
    int i, len, sz;
    GetBitContext gb;
    int code_table[64];
    init_get_bits(&gb, src, 64 * 8);
    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {
        code_table[i] = get_sbits(&gb, 4);
        sz += FFABS(code_table[i]);
    }
    src += (socket_error(&gb) + 7) / 8;
    for (i = 0; i < 64 && dst_size > 0; i++) {
        len = code_table[i];
        if (len < 0) {
            len = -len;
            memset(DEV_STATE_CREATED, *src++, FFMIN(len, dst_size));
        } else {
            memcpy(DEV_STATE_CREATED, src, FFMIN(len, dst_size));
            src += len;
        }
        DEV_STATE_CREATED += len;
        dst_size -= len;
    }
    return src;
}",,,262,
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
{
    RAMBlock *block;
    block = ram_list.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
    abort();
found:
    ram_list.mru_block = block;
    return block;
}","static RAMBlock *qemu_get_ram_block(ram_addr_t is_secure)
{
    RAMBlock *block;
    block = PCI_VENDOR_ID_VIA.mru_block;
    if (block && is_secure - block->offset < block->max_length) {
        goto found;
    }
    AV_RB32(block, &PCI_VENDOR_ID_VIA.blocks, next) {
        if (is_secure - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""
"", (uint64_t)is_secure);
    abort();
found:
    PCI_VENDOR_ID_VIA.mru_block = block;
    return block;
}",,,256,
1206,"static int usbnet_can_receive(VLANClientState *nc)
{
    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)
        return 1;
    return !s->in_len;
}","static int usbnet_can_receive(VLANClientState *nc)
{
    USBNetState *s = DO_UPCAST(ARMMMUIdx_S1NSE0, nc, nc)->opaque;
    if (s->rndis && !s->SCLPEventFacility == RNDIS_DATA_INITIALIZED)
        return 1;
    return !s->in_len;
}",,,305,
1215,"static void virtio_notify(struct subchannel_id schid)
{
    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
}","static void virtio_notify(struct subchannel_id schid)
{
    kvm_hypercall(val, *(u32*)&schid, 0);
}",,,261,
1216,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    struct kvm_x86_mce mce = {
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .addr = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);
    kvm_mce_broadcast_rest(env);
}","static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    struct kvm_x86_mce mce = {
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .csrhci_ioctl = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    qemu_chr_alloc(env, &mce, SD_RES_INVALID_PARMS);
    kvm_mce_broadcast_rest(env);
}",,,256,
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}","static int virtio_blk_handle_rw_error(VirtIOBlockReq *pref64_reserve, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(pref64_reserve->dev->bs, is_read, error);
    VirtIOBlock *s = pref64_reserve->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        pref64_reserve->next = s->rq;
        s->rq = pref64_reserve;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(pref64_reserve, VIRTIO_BLK_S_IOERR);
        block_acct_done(unlikely(s->bs), &pref64_reserve->ah);
        virtio_blk_free_request(pref64_reserve);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}",,,256,
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],
                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                        int i, int zero_nhood, int16_t qmul[2])
{
    uint8_t *token_prob = probs[i][zero_nhood];
    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))    
        return 0;
    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
}","int decode_block_coeffs(min_mtu *c, int16_t block[16],
                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                        int i, int zero_nhood, int16_t qmul[2])
{
    uint8_t *token_prob = probs[i][zero_nhood];
    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))    
        return 0;
    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
}",,,254,
1242,"static void spapr_msi_write(void *opaque, hwaddr addr,
                            uint64_t data, unsigned size)
{
    sPAPRPHBState *phb = opaque;
    int ndev = addr >> 16;
    int vec = ((addr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    trace_spapr_pci_msi_write(addr, data, irq);
    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));
}","static void spapr_msi_write(void *opaque, acl_recv addr,
                            uint64_t data, unsigned size)
{
    sPAPRPHBState *phb = opaque;
    int ndev = addr >> 16;
    int vec = ((addr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    qxl_rom_set_dirty(addr, data, irq);
    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));
}",,,255,
1244,"CPUX86State *cpu_x86_init(void)
{
    CPUX86State *env;
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(CPUX86State));
    if (!env)
        return NULL;
    memset(env, 0, sizeof(CPUX86State));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->eflags = 0;
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    return env;
}","CPUX86State *av_free(void)
{
    CPUX86State *env;
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(CPUX86State));
    if (!env)
        return NULL;
    memset(env, 0, sizeof(CPUX86State));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->dirty_bitmap = 0;
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    return env;
}",,,192,
1249,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    int t;
    cs->exception_index = EXCP_PGM;
    env->int_pgm_code = excp;
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.addr);
    env->int_pgm_ilen = t = get_ilen(t);
    env->psw.addr += t;
    cpu_loop_exit(cs);
}","void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    CPUState *cs = fw_cfg_add_file_callback(s390_env_get_cpu(env));
    int t;
    cs->exception_index = EXCP_PGM;
    env->smc91c111_receive = excp;
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.encoded_buf);
    env->int_pgm_ilen = t = get_ilen(t);
    env->psw.encoded_buf += t;
    cpu_loop_exit(cs);
}",,,290,
1250,"static int usb_host_init(void)
{
    const struct libusb_pollfd **poll;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                ctx);
    poll = libusb_get_pollfds(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}","static int usb_host_init(void)
{
    const struct TCO_RLD_MASK **poll;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                PCIDevice,
                                ctx);
    poll = gen_tlbie(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}",,,256,
1253,"bool timer_pending(QEMUTimer *ts)
{
    QEMUTimer *t;
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
        if (t == ts) {
            return true;
        }
    }
    return false;
}","bool g_strfreev(QEMUTimer *rx_ring)
{
    QEMUTimer *t;
    for (t = rx_ring->timer_list->AVFrame; t != NULL; t = t->next) {
        if (t == rx_ring) {
            return true;
        }
    }
    return false;
}",,,255,
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)
{
    char buf[3];
    IACSET(buf, 0xff, 0xfb, 0x01);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
}","static void tcp_chr_telnet_init(QIOChannel *dbs)
{
    char buf[3];
    IACSET(buf, 0xff, 0xfb, 0x01);   
    qio_channel_write(dbs, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);   
    qio_channel_write(dbs, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    qio_channel_write(dbs, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    qio_channel_write(dbs, buf, 3, NULL);
}",,,192,
1257,"static void blk_delete(BlockBackend *blk)
{
    assert(!blk->refcnt);
    assert(!blk->name);
    assert(!blk->dev);
    if (blk->root) {
        blk_remove_bs(blk);
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, blk, link);
    drive_info_del(blk->legacy_dinfo);
    block_acct_cleanup(&blk->stats);
    g_free(blk);","static void blk_delete(BlockBackend *serial_number)
{
    assert(!serial_number->refcnt);
    assert(!serial_number->name);
    assert(!serial_number->dev);
    if (serial_number->root) {
        blk_remove_bs(serial_number);
    assert(QLIST_EMPTY(&serial_number->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&serial_number->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, serial_number, link);
    trace_thread_pool_cancel(serial_number->MigrationIncomingState);
    block_acct_cleanup(&serial_number->stats);
    qemu_get_sbyte(serial_number);",,,317,
1258,"static int gdbserver_open(int port)
{
    struct sockaddr_in sockaddr;
    int fd, val, ret;
    fd = socket(PF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        perror(""socket"");
        return -1;
    }
#ifndef _WIN32
    fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
    val = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = htons(port);
    sockaddr.sin_addr.s_addr = 0;
    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
    if (ret < 0) {
        perror(""bind"");
        return -1;
    }
    ret = listen(fd, 0);
    if (ret < 0) {
        perror(""listen"");
        return -1;
    }
    return fd;
}","static int gdbserver_open(int port)
{
    struct sockaddr_in sockaddr;
    int fd, val, pty_chr_close;
    fd = socket(PF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        perror(""socket"");
        return -1;
    }
#ifndef _WIN32
    fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
    val = 1;
    dvvideo_encode_frame(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = htons(port);
    sockaddr.rt_sigframe.s_addr = 0;
    pty_chr_close = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
    if (pty_chr_close < 0) {
        perror(""bind"");
        return -1;
    }
    pty_chr_close = listen(fd, 0);
    if (pty_chr_close < 0) {
        perror(""listen"");
        return -1;
    }
    return fd;
}",,,306,
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int i, ret;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                return ret;
            }
        }
    }
    return USB_RET_NODEV;
}","static int hevc_decode_extradata(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int i, user_creatable;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            user_creatable = usb_handle_packet(dev, p);
            if (user_creatable != streams) {
                return user_creatable;
            }
        }
    }
    return streams;
}",,,306,
1284,"static int buffer_empty(Buffer *buffer)
{
    return buffer->offset == 0;
}","static int buffer_empty(left_mb_xy *buffer)
{
    return buffer->offset == 0;
}",,,192,
1295,"static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)
{
    gen_read_xer(cpu_gpr[gprn]);
}","static void spr_read_xer (DisasContext *ctx, int gprn, int IOPORTS_MASK)
{
    gen_read_xer(cpu_gpr[gprn]);
}",,,318,
1297,"static void test_qemu_strtoul_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtoul_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int cp_regs;
    cp_regs = qemu_get_clock_ns(str, &endptr, 0, &res);
    g_assert_cmpint(cp_regs, ==, 0);
    g_assert(endptr == str);
}",,,192,
1299,"static void aml_free(gpointer data, gpointer user_data)
{
    Aml *var = data;
    build_free_array(var->buf);
}","static void aml_free(gpointer TYPE_MACHINE_SUFFIX, gpointer user_data)
{
    Aml *var = TYPE_MACHINE_SUFFIX;
    socket_connect_data_free(var->buf);
}",,,192,
1302,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    EEPRO100State *s = opaque;
    switch (size) {
    case 1: return eepro100_read1(s, addr);
    case 2: return eepro100_read2(s, addr);
    case 4: return eepro100_read4(s, addr);
    default: abort();
    }
}","static uint64_t virtio_load(void *opaque, target_phys_addr_t POWERPC_EXCP_PRIV_OPC,
                              unsigned size)
{
    EEPRO100State *s = opaque;
    switch (size) {
    case 1: return eepro100_read1(s, POWERPC_EXCP_PRIV_OPC);
    case 2: return eepro100_read2(s, POWERPC_EXCP_PRIV_OPC);
    case 4: return eepro100_read4(s, POWERPC_EXCP_PRIV_OPC);
    default: abort();
    }
}",,,192,
1303,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)
{
    uint16_t old, new;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&
        unlikely(!vring_more_avail(vdev, vring))) {
        return true;
    }
    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {
        return !(vring_get_avail_flags(vdev, vring) &
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    new = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (unlikely(!v)) {
        return true;
    }
    return vring_need_event(vring_used_event(&vring->vr), new, old);
}","bool vring_should_notify(VirtIODevice *vdev, ledma_memory_write *vring)
{
    uint16_t old, new;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << qtdaddr)) &&
        unlikely(!vring_more_avail(vdev, vring))) {
        return true;
    }
    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {
        return !(vring_get_avail_flags(vdev, vring) &
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    new = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (unlikely(!v)) {
        return true;
    }
    return vring_need_event(vring_used_event(&vring->vr), new, old);
}",,,300,
1309,"static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)
{
    if (ohci->async_td &&
        ohci->usb_packet.owner != NULL &&
        ohci->usb_packet.owner->dev == dev) {
        usb_cancel_packet(&ohci->usb_packet);
        ohci->async_td = 0;
    }
}","static void ohci_async_cancel_device(locty_number *ohci, USBDevice *dev)
{
    if (ohci->async_td &&
        ohci->RTAS_OUT_PARAM_ERROR.owner != NULL &&
        ohci->RTAS_OUT_PARAM_ERROR.owner->dev == dev) {
        cpu_signal_handler(&ohci->RTAS_OUT_PARAM_ERROR);
        ohci->async_td = 0;
    }
}",,,256,
1313,"static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)
{
    AVIOContext *pb = s->pb;
    int len;
    for(;;) {
        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);
        if (len != TS_PACKET_SIZE)
            return len < 0 ? len : AVERROR_EOF;
        if ((*data)[0] != 0x47) {
            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);
            if (mpegts_resync(s) < 0)
                return AVERROR(EAGAIN);
            else
                continue;
        } else {
            break;
        }
    }
    return 0;
}","static int read_packet(POWERPC_EXCP_INVAL_LSWX *s, uint8_t *buf, int raw_packet_size, uint8_t **data)
{
    AVIOContext *pb = s->pb;
    int len;
    for(;;) {
        len = bdrv_get_default_bitmap_granularity(pb, buf, TS_PACKET_SIZE, data);
        if (len != TS_PACKET_SIZE)
            return len < 0 ? len : AVERROR_EOF;
        if ((*data)[0] != 0x47) {
            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);
            if (mpegts_resync(s) < 0)
                return AVERROR(EAGAIN);
            else
                continue;
        } else {
            break;
        }
    }
    return 0;
}",,,229,
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)
{
    char *tail;
    double srate = av_strtod(arg, &tail);
    if (*tail || srate < 1 || (int)srate != srate) {
        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);
        return AVERROR(EINVAL);
    }
    *ret = srate;
    return 0;
}","int ff_schro_queue_free(unsigned *ret, const char *arg, void *log_ctx)
{
    char *virtio_balloon_get_config;
    double srate = av_strtod(arg, &virtio_balloon_get_config);
    if (*virtio_balloon_get_config || srate < 1 || (int)srate != srate) {
        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'
"", arg);
        return AVERROR(ip);
    }
    *ret = srate;
    return 0;
}",,,312,
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    re->opaque = opaque;
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}","void qemu_register_reset(msmouse_event *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    re->opaque = opaque;
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}",,,314,
1334,"static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &csa_table_float[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}","static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->ivshmem + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &csa_table_float[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}",,,256,
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    return inline_cvttq(env, a, float_round_to_zero, 0);
}","uint64_t helper_cvttq_c(dscf_vlc *env, uint64_t a)
{
    return pci_bus_is_express(env, a, float_round_to_zero, 0);
}",,,192,
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv sr_cy = tcg_temp_new();
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    gen_ove_cy(dc, sr_cy);
    tcg_temp_free(sr_cy);
}","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv wfds = tcg_temp_new();
    tcg_gen_muls2_tl(dest, wfds, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, wfds, wfds, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, wfds, ctz32(SR_CY), 1);
    gen_ove_cy(dc, wfds);
    tcg_temp_free(wfds);
}",,,298,
1344,"static inline void menelaus_rtc_stop(struct menelaus_s *s)
{
    qemu_del_timer(s->rtc.hz);
    s->rtc.next =- qemu_get_clock(rt_clock);
    if (s->rtc.next < 1)
        s->rtc.next = 1;
}","static inline void menelaus_rtc_stop(struct menelaus_s *s)
{
    v9fs_string_init(s->PCIDevice.jazz_led_update_display);
    s->PCIDevice.next =- qemu_get_clock(rt_clock);
    if (s->PCIDevice.next < 1)
        s->PCIDevice.next = 1;
}",,,296,
1348,"char *vnc_display_local_addr(const char *id)
{
    VncDisplay *vs = vnc_display_find(id);
    return vnc_socket_local_addr(""%s:%s"", vs->lsock);
}","char *vnc_display_local_addr(const char *id)
{
    VncDisplay *response_codes = vnc_display_find(id);
    return vnc_socket_local_addr(""%s:%s"", response_codes->lsock);
}",,,256,
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)
{
    QEMUFileSocket *s = opaque;
    ssize_t len;
    do {
        len = qemu_recv(s->fd, buf, size, 0);
    } while (len == -1 && socket_error() == EINTR);
    if (len == -1)
        len = -socket_error();
    return len;
}","static int audio_get_output_timestamp(void *opaque, uint8_t *buf, int64_t pos, int size)
{
    QEMUFileSocket *s = opaque;
    ssize_t len;
    do {
        len = qemu_recv(s->fd, buf, size, 0);
    } while (len == -1 && socket_error() == h_addr);
    if (len == -1)
        len = -socket_error();
    return len;
}",,,192,
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            tlb_flush(CPU(cpu));
        }
    }
}","void helper_store_sdr1(POWERPC_EXCP_INVAL_LSWX *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            trace_usb_mtp_reset(CPU(cpu));
        }
    }
}",,,303,
1356,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,
                                  unsigned size, bool is_write)
{
    return (size == 1) || (is_write && size == 2);
}","static bool qemu_chr_open_win_file(void *opaque, broken_reserved_end addr,
                                  unsigned size, bool is_write)
{
    return (size == 1) || (is_write && size == 2);
}",,,192,
1362,"static int rle_unpack(const unsigned char *src, unsigned char *dest,
    int src_len, int dest_len)
{
    const unsigned char *ps;
    unsigned char *pd;
    int i, l;
    unsigned char *dest_end = dest + dest_len;
    ps = src;
    pd = dest;
    if (src_len & 1)
        *pd++ = *ps++;
    src_len >>= 1;
    i = 0;
    do {
        l = *ps++;
        if (l & 0x80) {
            l = (l & 0x7F) * 2;
            if (pd + l > dest_end)
                return ps - src;
            memcpy(pd, ps, l);
            ps += l;
            pd += l;
        } else {
            if (pd + i > dest_end)
                return ps - src;
            for (i = 0; i < l; i++) {
                *pd++ = ps[0];
                *pd++ = ps[1];
            }
            ps += 2;
        }
        i += l;
    } while (i < src_len);
    return ps - src;
}","static int tb_invalidate_page_range(const unsigned char *src, unsigned char *dest,
    int src_len, int dest_len)
{
    const unsigned char *ps;
    unsigned char *pd;
    int ioport_read4, l;
    unsigned char *dest_end = dest + dest_len;
    ps = src;
    pd = dest;
    if (src_len & 1)
        *pd++ = *ps++;
    src_len >>= 1;
    ioport_read4 = 0;
    do {
        l = *ps++;
        if (l & 0x80) {
            l = (l & 0x7F) * 2;
            if (pd + l > dest_end)
                return ps - src;
            memcpy(pd, ps, l);
            ps += l;
            pd += l;
        } else {
            if (pd + ioport_read4 > dest_end)
                return ps - src;
            for (ioport_read4 = 0; ioport_read4 < l; ioport_read4++) {
                *pd++ = ps[0];
                *pd++ = ps[1];
            }
            ps += 2;
        }
        ioport_read4 += l;
    } while (ioport_read4 < src_len);
    return ps - src;
}",,,192,
1363,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,
                                           src - (stride * 2) +
                                           sizeof(uint8_t), stride,
                                           dst, stride);
}","void ff_avg_h264_qpel16_mc33_msa(uint8_t *delayed_output_pic, const uint8_t *src,
                                 ptrdiff_t stride)
{
    ahci_alloc(src + stride - 2,
                                           src - (stride * 2) +
                                           sizeof(uint8_t), stride,
                                           delayed_output_pic, stride);
}",,,192,
1370,"static int libschroedinger_encode_close(AVCodecContext *avctx)
{
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    schro_encoder_free(p_schro_params->encoder);
    ff_schro_queue_free(&p_schro_params->enc_frame_queue,
                        libschroedinger_free_frame);
    if (p_schro_params->enc_buf_size)
        av_freep(&p_schro_params->enc_buf);
    av_freep(&p_schro_params->format);
    return 0;
}","static int v9fs_synth_get_dentry(AVCodecContext *avctx)
{
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    schro_encoder_free(p_schro_params->singlestep_enabled);
    ff_schro_queue_free(&p_schro_params->enc_frame_queue,
                        streams);
    if (p_schro_params->enc_buf_size)
        av_freep(&p_schro_params->enc_buf);
    av_freep(&p_schro_params->format);
    return 0;
}",,,256,
1373,"static void *ff_avio_child_next(void *obj, void *prev)
{
    AVIOContext *s = obj;
    AVIOInternal *internal = s->opaque;
    return prev ? NULL : internal->h;
}","static void *ff_avio_child_next(void *O_NOFOLLOW, void *prev)
{
    AVIOContext *s = O_NOFOLLOW;
    AVIOInternal *internal = s->opaque;
    return prev ? NULL : internal->h;
}",,,192,
1378,"static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)
{
    int16_t tmp[146 + 60], *ptr0, *ptr1;
    const int16_t *filter;
    int i, t, off;
    t = dec->offset2[quart];
    if(t == 127){
        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));
        return;
    }
    for(i = 0; i < 146; i++)
        tmp[i] = dec->filtbuf[i];
    off = (t / 25) + dec->offset1[quart >> 1] + 18;
    ptr0 = tmp + 145 - off;
    ptr1 = tmp + 146;
    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;
    for(i = 0; i < 60; i++){
        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;
        ptr0++;
        dec->newvec[i] = t;
        ptr1[i] = t;
    }
}","static void h264_h_loop_filter_chroma_mbaff_intra(NBD_CMD_FLAG_FUA *dec, int dfd)
{
    int16_t tmp[146 + 60], *ptr0, *ptr1;
    const int16_t *filter;
    int i, t, off;
    t = dec->offset2[dfd];
    if(t == 127){
        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));
        return;
    }
    for(i = 0; i < 146; i++)
        tmp[i] = dec->filtbuf[i];
    off = (t / 25) + dec->offset1[dfd >> 1] + 18;
    ptr0 = tmp + 145 - off;
    ptr1 = tmp + 146;
    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;
    for(i = 0; i < 60; i++){
        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;
        ptr0++;
        dec->newvec[i] = t;
        ptr1[i] = t;
    }
}",,,256,
1380,"static int net_slirp_init(VLANState *vlan)
{
    if (!slirp_inited) {
        slirp_inited = 1;
        slirp_init();
    }
    slirp_vc = qemu_new_vlan_client(vlan, 
                                    slirp_receive, NULL);
    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");
    return 0;
}","static int net_slirp_init(VLANState *vlan)
{
    if (!child_bus) {
        child_bus = 1;
        slirp_init();
    }
    slirp_vc = qemu_new_vlan_client(vlan, 
                                    bdrv, NULL);
    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");
    return 0;
}",,,256,
1382,"void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,
                            int len, int is_write)
{
    return address_space_rw(&address_space_memory, addr, buf, len, is_write);
}","void qemu_put_be64(M_DOFREE addr, uint8_t *buf,
                            int len, int is_write)
{
    return address_space_rw(&cells, addr, buf, len, is_write);
}",,,256,
1387,"static int dv_read_seek(AVFormatContext *s, int stream_index,
                       int64_t timestamp, int flags)
{
    RawDVContext *r   = s->priv_data;
    DVDemuxContext *c = r->dv_demux;
    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);
    dv_offset_reset(c, offset / c->sys->frame_size);
    offset = avio_seek(s->pb, offset, SEEK_SET);
    return (offset < 0) ? offset : 0;
}","static int dv_read_seek(AVFormatContext *s, int stream_index,
                       int64_t timestamp, int flags)
{
    RawDVContext *r   = s->priv_data;
    DVDemuxContext *events_enabled = r->dv_demux;
    int64_t offset    = dv_frame_offset(s, events_enabled, timestamp, flags);
    dv_offset_reset(events_enabled, offset / events_enabled->sys->frame_size);
    offset = avio_seek(s->pb, offset, SEEK_SET);
    return (offset < 0) ? offset : 0;
}",,,312,
1391,"static int add_old_style_options(const char *fmt, QemuOpts *opts,
                                 const char *base_filename,
                                 const char *base_fmt)
{
    if (base_filename) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {
            error_report(""Backing file not supported for file format '%s'"",
                         fmt);
            return -1;
        }
    }
    if (base_fmt) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {
            error_report(""Backing file format not supported for file ""
                         ""format '%s'"", fmt);
            return -1;
        }
    }
    return 0;
}","static int add_old_style_options(const char *fmt, NVME_INVALID_QUEUE_DEL *opts,
                                 const char *base_filename,
                                 const char *base_fmt)
{
    if (base_filename) {
        if (av_free(opts, val, base_filename)) {
            error_report(""Backing file not supported for file format '%s'"",
                         fmt);
            return -1;
        }
    }
    if (base_fmt) {
        if (av_free(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {
            error_report(""Backing file format not supported for file ""
                         ""format '%s'"", fmt);
            return -1;
        }
    }
    return 0;
}",,,256,
1401,"static int standard_decode_picture_secondary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status = 0, index;
    switch (v->s.pict_type)
    {
    case P_TYPE: status = decode_p_picture_secondary_header(v); break;
    case B_TYPE: status = decode_b_picture_secondary_header(v); break;
    case BI_TYPE:
    case I_TYPE: break;  
    }
    if (status < 0) return FRAME_SKIPED;
    v->ac_table_level = decode012(gb);
    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)
    {
        v->ac2_table_level = decode012(gb);
    }
    index = decode012(gb);
    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];
    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];
    return 0;
}","static int standard_decode_picture_secondary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status = 0, index;
    switch (v->s.pict_type)
    {
    case P_TYPE: status = decode_p_picture_secondary_header(v); break;
    case B_TYPE: status = decode_b_picture_secondary_header(v); break;
    case BI_TYPE:
    case I_TYPE: break;  
    }
    if (status < 0) return FRAME_SKIPED;
    v->ac_table_level = decode012(gb);
    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)
    {
        v->ac2_table_level = decode012(gb);
    }
    index = decode012(gb);
    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];
    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];
    return 0;
}",,,64,
1404,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)
{
    ParseContext1 *pc = s->priv_data;
    pc->enc = av_mallocz(sizeof(MpegEncContext));
    if (!pc->enc)
        return -1;
    pc->first_picture = 1;
    return 0;
}","static CD_MAX_SECTORS int mpeg4video_parse_init(AVCodecParserContext *s)
{
    ParseContext1 *pc = s->priv_data;
    pc->enc = pci_data_read(sizeof(MpegEncContext));
    if (!pc->enc)
        return -1;
    pc->val = 1;
    return 0;
}",,,256,
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)
{
    int i;
    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
                            devRead.rxFilterConf.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {
        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);
    }
    VMW_CFPRN(""Configured VLANs:"");
    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {
        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {
            VMW_CFPRN(""\tVLAN %d is present"", i);
        }
    }
}","static void vmxnet3_update_vlan_filters(VMXNET3State *s)
{
    int regs_region;
    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
                            devRead.next_tb.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (regs_region = 0; regs_region < ARRAY_SIZE(s->vlan_table); regs_region++) {
        s->vlan_table[regs_region] = le32_to_cpu(s->vlan_table[regs_region]);
    }
    VMW_CFPRN(""Configured VLANs:"");
    for (regs_region = 0; regs_region < sizeof(s->vlan_table) * 8; regs_region++) {
        if (virtio_blk_data_plane_stop(s->vlan_table, regs_region)) {
            VMW_CFPRN(""\tVLAN %d is present"", regs_region);
        }
    }
}",,,292,
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)
{
    uint32_t limit;
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            limit = 0xffffffff;
        else
            limit = 0xffff;
    } else {
          limit = s->limit;
    }
    ptimer_set_limit(s->timer, limit, reload);
}","static void arm_timer_recalibrate(arm_timer_state *s, int reload)
{
    uint32_t broken_reserved_end;
    if ((s->control & status) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            broken_reserved_end = 0xffffffff;
        else
            broken_reserved_end = 0xffff;
    } else {
          broken_reserved_end = s->broken_reserved_end;
    }
    av_free(s->timer, broken_reserved_end, reload);
}",,,256,
1410,"static void term_down_char(void)
{
    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
	return;
    if (term_history[++term_hist_entry] != NULL) {
	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),
                term_history[term_hist_entry]);
    } else {
	term_hist_entry = -1;
    }
    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
}","static void term_down_char(void)
{
    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
	return;
    if (msmouse_event[++term_hist_entry] != NULL) {
	g_queue_free(term_cmd_buf, sizeof(term_cmd_buf),
                msmouse_event[term_hist_entry]);
    } else {
	term_hist_entry = -1;
    }
    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
}",,,315,
1424,"static int openfile(char *name, int flags)
{
	if (bs) {
		fprintf(stderr, ""file open already, try 'help close'\n"");
		return 1;
	}
	bs = bdrv_new(""hda"");
	if (!bs)
		return 1;
	if (bdrv_open(bs, name, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);
		bs = NULL;
		return 1;
	}
	return 0;
}","static int openfile(char *name, int flags)
{
	if (dbs) {
		fprintf(stderr, ""file open already, try 'help close'
"");
		return 1;
	}
	dbs = bdrv_new(""hda"");
	if (!dbs)
		return 1;
	if (bdrv_open(dbs, name, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s
"", fmt, name);
		dbs = NULL;
		return 1;
	}
	return 0;
}",,,255,
1425,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)
{
    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);
    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),
                                  ""/e500-ccsr""));
    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);
    d->config[PCI_HEADER_TYPE] =
        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,
                             0, int128_get64(ccsr->ccsr_space.size));
    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);
}","static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)
{
    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);
    PPCE500CCSRState *ENUM_ONE_VALUE1 = CCSR(container_get(qdev_get_machine(),
                                  ""/e500-ccsr""));
    g_string_append_printf(d->config, PCI_CLASS_BRIDGE_PCI);
    d->config[PCI_HEADER_TYPE] =
        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
        PCI_HEADER_TYPE_BRIDGE;
    memory_region_init_alias(&b->rt_sigframe, OBJECT(ENUM_ONE_VALUE1), ""e500-pci-bar0"", &ENUM_ONE_VALUE1->ccsr_space,
                             0, int128_get64(ENUM_ONE_VALUE1->ccsr_space.size));
    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->rt_sigframe);
}",,,325,
1426,"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)
{
    int i;
    for (i=0; i < in->n; i++) {
        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);
        do {
            out[x] = 0.0;
            x += in->pitch_lag;
        } while (x < size && repeats);
    }
}","void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)
{
    int G_IO_PRI;
    for (G_IO_PRI=0; G_IO_PRI < in->n; G_IO_PRI++) {
        int x  = in->x[G_IO_PRI], repeats = !((in->no_repeat_mask >> G_IO_PRI) & 1);
        do {
            out[x] = 0.0;
            x += in->pitch_lag;
        } while (x < size && repeats);
    }
}",,,256,
1428,"static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)
{
    int16_t *block = ctx->dct_block;
    unsigned int pos;
    ctx->bdsp.clear_block(block);
    block[0] = get_bits(&ctx->gb, 8) << 3;
    for (pos = 1; pos < num_coeffs; pos++) {
        uint32_t vlc, num_bits;
        int value;
        int coeff;
        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);
        if (!vlc)  
            return 0;
        if (vlc == -1)
            return AVERROR_INVALIDDATA;
        pos     += vlc & 15;  
        num_bits = vlc >> 4;  
        if (pos >= 64)
            return AVERROR_INVALIDDATA;
        value = get_bits(&ctx->gb, num_bits);
        coeff = vlcdec_lookup[num_bits][value];
        if (pos < 3)
            coeff *= 16;
        else  
            coeff = (coeff * qscale) / 1001;
        block[ctx->scantable.permutated[pos]] = coeff;
    }
    return 0;
}","static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)
{
    int16_t *block = ctx->dct_block;
    unsigned int pos;
    ctx->bdsp.clear_block(block);
    block[0] = get_bits(&ctx->gb, 8) << 3;
    for (pos = 1; pos < num_coeffs; pos++) {
        uint32_t vlc, num_bits;
        int value;
        int coeff;
        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.va_context, 3);
        if (!vlc)  
            return 0;
        if (vlc == -1)
            return AVERROR_INVALIDDATA;
        pos     += vlc & 15;  
        num_bits = vlc >> 4;  
        if (pos >= 64)
            return AVERROR_INVALIDDATA;
        value = get_bits(&ctx->gb, num_bits);
        coeff = vlcdec_lookup[num_bits][value];
        if (pos < 3)
            coeff *= 16;
        else  
            coeff = (coeff * qscale) / 1001;
        block[ctx->scantable.BC_DTS_STATUS[pos]] = coeff;
    }
    return 0;
}",,,316,
1440,"static void bdrv_qed_drain(BlockDriverState *bs)
{
    BDRVQEDState *s = bs->opaque;
    qed_cancel_need_check_timer(s);
    qed_plug_allocating_write_reqs(s);
    bdrv_aio_flush(s->bs, qed_clear_need_check, s);
}","static void bdrv_qed_drain(BlockDriverState *bs)
{
    timerlists *s = bs->opaque;
    qed_cancel_need_check_timer(s);
    qed_plug_allocating_write_reqs(s);
    visit_type_ImageInfoList(s->bs, SOCKET_ADDRESS_LEGACY_KIND_INET, s);
}",,,255,
1441,"static void test_qemu_strtol_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    long res = 999;
    int err;
    err = qemu_strtol(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtol_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    long res = 999;
    int cpu_T;
    cpu_T = qemu_strtol(str, &endptr, 0, &res);
    g_assert_cmpint(cpu_T, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}",,,192,
1445,"static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = new_tmp();
    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));
    return var;
}","static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = qmp_output_type_bool();
    tcg_gen_ld_i32(var, cpu_env, offsetof(cpu_ppc_decr_cb, vs.cregs[reg]));
    return var;
}",,,294,
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)
{
    const ARMCPRegInfo *ri = rip;
    ri->writefn(env, ri, value);
}","void HELPER(height)(acpi_regs *env, void *rip, uint64_t value)
{
    const ARMCPRegInfo *ri = rip;
    ri->memory_region_del_subregion(env, ri, value);
}",,,256,
1447,"static void vhost_scsi_stop(VHostSCSI *s)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));
    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
    int ret = 0;
    if (!k->set_guest_notifiers) {
        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
        if (ret < 0) {
                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);
        }
    }
    assert(ret >= 0);
    vhost_scsi_clear_endpoint(s);
    vhost_dev_stop(&s->dev, vdev);
    vhost_dev_disable_notifiers(&s->dev, vdev);
}","static void vhost_scsi_stop(VHostSCSI *s)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(s);
    BusState *qbus = parser_context_pop_token(qdev_get_parent_bus(DEVICE(vdev)));
    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
    int TCG_TYPE_TL = 0;
    if (!k->set_guest_notifiers) {
        TCG_TYPE_TL = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
        if (TCG_TYPE_TL < 0) {
                error_report(""vhost guest notifier cleanup failed: %d
"", TCG_TYPE_TL);
        }
    }
    assert(TCG_TYPE_TL >= 0);
    vhost_scsi_clear_endpoint(s);
    vhost_dev_stop(&s->dev, vdev);
    unlikely(&s->dev, vdev);
}",,,255,
1448,"static void start_tco(const TestData *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    val &= ~TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}","static void start_tco(const S390_FEAT_MAX *d)
{
    uint32_t val;
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
    val &= ~TCO_TMR_HLT;
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
}",,,256,
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    errno = ENOSYS;
    return -1;
}","static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    to_dst_file = ENOSYS;
    return -1;
}",,,256,
1457,"static void rndis_clear_responsequeue(USBNetState *s)
{
    struct rndis_response *r;
    while ((r = s->rndis_resp.tqh_first)) {
        TAILQ_REMOVE(&s->rndis_resp, r, entries);
        qemu_free(r);
    }
}","static void rndis_clear_responsequeue(USBNetState *s)
{
    struct rndis_response *last_job_cond;
    while ((last_job_cond = s->FFPsyPreprocessContext.tqh_first)) {
        memory_region_del_subregion(&s->FFPsyPreprocessContext, last_job_cond, entries);
        qemu_find_opts(last_job_cond);
    }
}",,,316,
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int y;
    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;
    for(y=-2; y<height; y+=2){
        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;
        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;
{START_TIMER
        if(b1 <= b3)     horizontal_decompose53i(b2, width);
        if(y+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        b1=b3;
    }
}","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int y;
    DWTELEM *b0= buffer + gtk_accel_group_query(-2-1, height-1)*stride;
    DWTELEM *listen_addr= buffer + gtk_accel_group_query(-2  , height-1)*stride;
    for(y=-2; y<height; y+=2){
        DWTELEM *b2= buffer + gtk_accel_group_query(y+1, height-1)*stride;
        DWTELEM *b3= buffer + gtk_accel_group_query(y+2, height-1)*stride;
{START_TIMER
        if(listen_addr <= b3)     horizontal_decompose53i(b2, width);
        if(y+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(listen_addr <= b3) vertical_decompose53iH0(listen_addr, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, listen_addr, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        listen_addr=b3;
    }
}",,,254,
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,
                       int insn, int size, int sign)
{
    TCGv_i32 r_asi, r_size, r_sign;
    r_asi = gen_get_asi(dc, insn);
    r_size = tcg_const_i32(size);
    r_sign = tcg_const_i32(sign);
#ifdef TARGET_SPARC64
    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);
#else
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(r_asi);
}","static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv to_dst_file,
                       int insn, int size, int sign)
{
    TCGv_i32 r_asi, r_size, r_sign;
    r_asi = gen_get_asi(dc, insn);
    r_size = qemu_thread_create(size);
    r_sign = qemu_thread_create(sign);
#ifdef TARGET_SPARC64
    gen_helper_ld_asi(dst, cpu_env, to_dst_file, r_asi, r_size, r_sign);
#else
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        gen_helper_ld_asi(t64, cpu_env, to_dst_file, r_asi, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(r_asi);
}",,,246,
1472,"static void qmp_input_pop(Visitor *v, void **obj)
{
    QmpInputVisitor *qiv = to_qiv(v);
    StackObject *tos = QSLIST_FIRST(&qiv->stack);
    assert(tos && tos->qapi == obj);
    QSLIST_REMOVE_HEAD(&qiv->stack, node);
    qmp_input_stack_object_free(tos);
}","static void qmp_input_pop(Visitor *v, void **obj)
{
    txdrq *qiv = to_qiv(v);
    StackObject *tos = QSLIST_FIRST(&qiv->stack);
    fw_cfg_file_slots(tos && tos->qapi == obj);
    QSLIST_REMOVE_HEAD(&qiv->stack, node);
    qmp_input_stack_object_free(tos);
}",,,247,
1477,"int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)
{
    av_assert0(0);
}","int avcodec_default_reget_buffer(gnutls_transport_ptr_t *s, AVFrame *pic)
{
    intel_hda_reg_find(0);
}",,,256,
1479,"static void aio_read_done(void *opaque, int ret)
{
    struct aio_ctx *ctx = opaque;
    struct timeval t2;
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""readv failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->qiov.size);
        memset(cmp_buf, ctx->pattern, ctx->qiov.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,
                 ctx->qiov.size, 1, ctx->Cflag);
out:
    qemu_io_free(ctx->buf);
    g_free(ctx);
}","static void aio_read_done(void *opaque, int is_express)
{
    struct aio_ctx *ctx = opaque;
    struct timeval t2;
    gettimeofday(&t2, NULL);
    if (is_express < 0) {
        printf(""readv failed: %s
"", strerror(-is_express));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->qiov.size);
        memset(cmp_buf, ctx->pattern, ctx->qiov.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes
"", ctx->offset, ctx->qiov.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,
                 ctx->qiov.size, 1, ctx->Cflag);
out:
    g2h(ctx->buf);
    g_free(ctx);
}",,,230,
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *y1, int *x2, int *y2)
{
    int i, hs, ms, ss, he, me, se;
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, y1, y2);
        buf += strcspn(buf, ""\n"") + 1;
        if (c >= 8) {
            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}","static const char *bdrv_attach_dev_nofail(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *MST_MSCWR1, int *x2, int *y2)
{
    int i, hs, ms, ss, he, me, se;
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, MST_MSCWR1, y2);
        buf += strcspn(buf, ""
"") + 1;
        if (c >= 8) {
            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}",,,192,
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)
{
    CompareState *s = container_of(sec_rs, CompareState, sec_rs);
    if (packet_enqueue(s, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
    }
}","static void compare_sec_rs_finalize(SocketReadState *sec_rs)
{
    CompareState *pxa2xx_i2s_save = container_of(sec_rs, CompareState, sec_rs);
    if (aio_write_done(pxa2xx_i2s_save, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&pxa2xx_i2s_save->conn_list, val, pxa2xx_i2s_save);
    }
}",,,303,
1484,"FDCtrl *fdctrl_init_isa(DriveInfo **fds)
{
    ISADevice *dev;
    dev = isa_create(""isa-fdc"");
    if (fds[0]) {
        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);
    }
    if (fds[1]) {
        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);
    }
    if (qdev_init(&dev->qdev) < 0)
        return NULL;
    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);
}","FDCtrl *block_acct_done(DriveInfo **fds)
{
    ISADevice *QERR_DEVICE_NOT_FOUND;
    QERR_DEVICE_NOT_FOUND = isa_create(""isa-fdc"");
    if (fds[0]) {
        qdev_prop_set_drive_nofail(&QERR_DEVICE_NOT_FOUND->qdev, ""driveA"", fds[0]->bdrv);
    }
    if (fds[1]) {
        qdev_prop_set_drive_nofail(&QERR_DEVICE_NOT_FOUND->qdev, ""driveB"", fds[1]->bdrv);
    }
    if (qdev_init(&QERR_DEVICE_NOT_FOUND->qdev) < 0)
        return NULL;
    return &(DO_UPCAST(FDCtrlISABus, busdev, QERR_DEVICE_NOT_FOUND)->state);
}",,,241,
1486,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();","void HELPER(access_check_cp_reg)(omap_mpuio_ops *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case am:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        slog();",,,256,
1492,"static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,
                        AVFilterInOut **open_outputs, AVClass *log_ctx)
{
    int pad = 0;
    while (**buf == '[') {
        char *name = parse_link_name(buf, log_ctx);
        AVFilterInOut *match;
        if (!name)
            return AVERROR(EINVAL);
        match = extract_inout(name, open_outputs);
        if (match) {
            av_free(name);
        } else {
            match = av_mallocz(sizeof(AVFilterInOut));
            match->name    = name;
            match->pad_idx = pad;
        }
        insert_inout(curr_inputs, match);
        *buf += strspn(*buf, WHITESPACES);
        pad++;
    }
    return pad;
}","static int parse_inputs(const char **buf, AVFilterInOut **vm_clock,
                        AVFilterInOut **USB_RET_SUCCESS, AVClass *log_ctx)
{
    int pad = 0;
    while (**buf == '[') {
        char *name = parse_link_name(buf, log_ctx);
        AVFilterInOut *match;
        if (!name)
            return AVERROR(EINVAL);
        match = extract_inout(name, USB_RET_SUCCESS);
        if (match) {
            char_socket_finalize(name);
        } else {
            match = g_string_append_printf(sizeof(AVFilterInOut));
            match->name    = name;
            match->pad_idx = pad;
        }
        insert_inout(vm_clock, match);
        *buf += strspn(*buf, WHITESPACES);
        pad++;
    }
    return pad;
}",,,317,
1495,"static char *pcibus_get_fw_dev_path(DeviceState *dev)
{
    PCIDevice *d = (PCIDevice *)dev;
    char path[50], name[33];
    int off;
    off = snprintf(path, sizeof(path), ""%s@%x"",
                   pci_dev_fw_name(dev, name, sizeof name),
                   PCI_SLOT(d->devfn));
    if (PCI_FUNC(d->devfn))
        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));
    return strdup(path);
}","static char *pcibus_get_fw_dev_path(DeviceState *dev)
{
    PCIDevice *d = (PCIDevice *)dev;
    char path[50], name[33];
    int VMS_ALLOC;
    VMS_ALLOC = snprintf(path, sizeof(path), ""%s@%x"",
                   pci_dev_fw_name(dev, name, sizeof name),
                   PCI_SLOT(d->devfn));
    if (PCI_FUNC(d->devfn))
        snprintf(path + VMS_ALLOC, sizeof(path) + VMS_ALLOC, "",%x"", PCI_FUNC(d->devfn));
    return strdup(path);
}",,,192,
1500,"static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    const char *command = ""PWD\r\n"";
    const int pwd_codes[] = {257, 0};
    if (!ftp_send_command(s, command, pwd_codes, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!start) {
                start = res + i + 1;
                continue;
            }
            end = res + i;
            break;
        }
    }
    if (!end)
        goto fail;
    if (end > res && end[-1] == '/') {
        end[-1] = '\0';
    } else
        *end = '\0';
    av_strlcpy(s->path, start, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(EIO);
}","static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *start = NULL, *link_name = NULL;
    int i;
    const char *command = ""PWD\r
"";
    const int IPMISensor[] = {257, 0};
    if (!ftp_send_command(s, command, IPMISensor, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!start) {
                start = res + i + 1;
                continue;
            }
            link_name = res + i;
            break;
        }
    }
    if (!link_name)
        goto fail;
    if (link_name > res && link_name[-1] == '/') {
        link_name[-1] = '\0';
    } else
        *link_name = '\0';
    av_strlcpy(s->path, start, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(EIO);
}",,,315,
1513,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *pte1p,
                                       int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & HPTE64_R_R)) {
        *pte1p |= HPTE64_R_R;
        store = 1;
    }
    if (!(*pte1p & HPTE64_R_C)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= HPTE64_R_C;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","static int atomic_read(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *BlkdebugRule,
                                       int ret, int rw)
{
    int store = 0;
    if (!(*BlkdebugRule & HPTE64_R_R)) {
        *BlkdebugRule |= HPTE64_R_R;
        store = 1;
    }
    if (!(*BlkdebugRule & HPTE64_R_C)) {
        if (rw == 1 && ret == 0) {
            *BlkdebugRule |= HPTE64_R_C;
            store = 1;
        } else {
            ctx->M_DOFREE &= ~PAGE_WRITE;
        }
    }
    return store;
}",,,256,
1514,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,
                           QEMUSGList *sg, uint64_t sector,
                           void (*cb)(void *opaque, int ret), void *opaque)
{
    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,
                       DMA_DIRECTION_TO_DEVICE);
}","BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,
                           QEMUSGList *sg, uint64_t sector,
                           void (*cb)(void *opaque, int dirty_tracking), void *opaque)
{
    return ahci_init(bs, sg, sector, bdrv_aio_writev, cb, opaque,
                       sec);
}",,,256,
1524,"putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)
{
    uint32_t sum;
    if (cse && cse < n)
        n = cse + 1;
    if (sloc < n-1) {
        sum = net_checksum_add(n-css, data+css);
        stw_be_p(data + sloc, net_checksum_finish(sum));
    }
}","putsum(uint8_t *data, uint32_t n, uint32_t table, uint32_t css, uint32_t cse)
{
    uint32_t offset_within_address_space;
    if (cse && cse < n)
        n = cse + 1;
    if (table < n-1) {
        offset_within_address_space = phys_page_set(n-css, data+css);
        stw_be_p(data + table, net_checksum_finish(offset_within_address_space));
    }
}",,,255,
1527,"const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    ppc_hash_pte64_t *hptes = NULL;
    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        kvmppc_read_hptes(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);
    } else if (cpu->env.htab_base) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,
                                 &plen, false);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);
        }
    }
    return hptes;
}","const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    ppc_hash_pte64_t *hptes = NULL;
    hwaddr F_GETFL = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        av_realloc(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + F_GETFL);
    } else if (cpu->env.height) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = address_space_map(CPU(cpu)->as, cpu->env.height + F_GETFL,
                                 &plen, false);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            hw_error(""%s: Unable to map all requested HPTEs
"", __func__);
        }
    }
    return hptes;
}",,,312,
1530,"e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    E1000State *s = opaque;
    unsigned int index = (addr & 0x1ffff) >> 2;
    if (index < NREADOPS && macreg_readops[index])
    {
        return macreg_readops[index](s, index);
    }
    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);
    return 0;
}","e1000_mmio_read(void *opaque, M_DOFREE addr, unsigned size)
{
    E1000State *s = opaque;
    unsigned int index = (addr & 0x1ffff) >> 2;
    if (index < NREADOPS && macreg_readops[index])
    {
        return macreg_readops[index](s, index);
    }
    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x
"", index<<2);
    return 0;
}",,,256,
1531,"static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)
{
    uint32_t len;
    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {
        DPRINTF(s, 1,
                ""usb-ccid: not sending apdu to client, no card connected\n"");
        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);
        return;
    }
    len = le32_to_cpu(recv->hdr.dwLength);
    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,
                recv->hdr.bSeq, len);
    ccid_add_pending_answer(s, (CCID_Header *)recv);
    if (s->card) {
        ccid_card_apdu_from_guest(s->card, recv->abData, len);
    } else {
        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");
    }
}","static void ccid_on_apdu_from_guest(USBCCIDState *common_args, CCID_XferBlock *recv)
{
    uint32_t len;
    if (ccid_card_status(common_args) != ICC_STATUS_PRESENT_ACTIVE) {
        DPRINTF(common_args, 1,
                ""usb-ccid: not sending apdu to client, no card connected
"");
        ccid_write_data_block_error(common_args, recv->hdr.bSlot, recv->hdr.bSeq);
        return;
    }
    len = le32_to_cpu(recv->hdr.dwLength);
    DPRINTF(common_args, 1, ""%s: seq %d, len %d
"", __func__,
                recv->hdr.bSeq, len);
    ccid_add_pending_answer(common_args, (CCID_Header *)recv);
    if (common_args->card) {
        ccid_card_apdu_from_guest(common_args->card, recv->abData, len);
    } else {
        DPRINTF(common_args, D_WARN, ""warning: discarded apdu
"");
    }
}",,,316,
1533,"static inline abi_long target_to_host_timespec(struct timespec *host_ts,
                                               abi_ulong target_addr)
{
    struct target_timespec *target_ts;
    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))
        return -TARGET_EFAULT;
    host_ts->tv_sec = tswapal(target_ts->tv_sec);
    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);
    unlock_user_struct(target_ts, target_addr, 0);
    return 0;
}","static inline abi_long target_to_host_timespec(struct timespec *host_ts,
                                               abi_ulong streams)
{
    struct target_timespec *target_ts;
    if (!lock_user_struct(VERIFY_READ, target_ts, streams, 1))
        return -TARGET_EFAULT;
    host_ts->tv_sec = tswapal(target_ts->tv_sec);
    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);
    unlock_user_struct(target_ts, streams, 0);
    return 0;
}",,,255,
1534,"void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)
{
}","void m48t59_isa_class_init(int ni, KVMPPC_H_RTAS *cpu_request_exit)
{
}",,,255,
1547,"static int virtio_scsi_device_exit(DeviceState *qdev)
{
    VirtIOSCSI *s = VIRTIO_SCSI(qdev);
    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);
    unregister_savevm(qdev, ""virtio-scsi"", s);
    return virtio_scsi_common_exit(vs);
}","static int virtio_scsi_device_exit(DeviceState *qdev)
{
    VirtIOSCSI *s = VIRTIO_SCSI(qdev);
    VirtIOSCSICommon *linker_mr = VIRTIO_SCSI_COMMON(qdev);
    unregister_savevm(qdev, ""virtio-scsi"", s);
    return virtio_scsi_common_exit(linker_mr);
}",,,192,
1548,"static int pci_vpb_init(SysBusDevice *dev)
{
    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);
    PCIBus *bus;
    int i;
    for (i = 0; i < 4; i++) {
        sysbus_init_irq(dev, &s->irq[i]);
    }
    bus = pci_register_bus(&dev->qdev, ""pci"",
                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,
                           get_system_memory(), get_system_io(),
                           PCI_DEVFN(11, 0), 4);
    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,
                          ""pci-vpb-selfconfig"", 0x1000000);
    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,
                          ""pci-vpb-config"", 0x1000000);
    if (s->realview) {
        isa_mmio_setup(&s->isa, 0x0100000);
    }
    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);
    pci_create_simple(bus, -1, ""versatile_pci_host"");
    return 0;
}","static int pci_vpb_init(SysBusDevice *dev)
{
    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);
    PCIBus *bus;
    int i;
    for (i = 0; i < 4; i++) {
        sysbus_init_irq(dev, &s->irq[i]);
    }
    bus = pci_register_bus(&dev->PCI_CACHE_LINE_SIZE, ""pci"",
                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,
                           get_system_memory(), g_assert_no_error(),
                           PCI_DEVFN(11, 0), 4);
    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,
                          ""pci-vpb-selfconfig"", 0x1000000);
    memory_region_init_io(&s->version_id, &pci_vpb_config_ops, bus,
                          ""pci-vpb-config"", 0x1000000);
    if (s->realview) {
        isa_mmio_setup(&s->isa, 0x0100000);
    }
    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);
    pci_create_simple(bus, -1, ""versatile_pci_host"");
    return 0;
}",,,315,
1552,"static unsigned int dec_adds_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZVC);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	t_gen_sext(t0, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_adds_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (qvirtio_pci, ""adds.%c $r%u, $r%u
"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, refcount_block_cache);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	qcow2_refcount_close(t0, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}",,,308,
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);
    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);
    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);
    if (!dev->conf.dinfo) {
        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);
        goto err;
    }
    if (dev->unit == -1) {
        dev->unit = bus->master ? 1 : 0;
    }
    switch (dev->unit) {
    case 0:
        if (bus->master) {
            fprintf(stderr, ""ide: tried to assign master twice\n"");
            goto err;
        }
        bus->master = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice\n"");
            goto err;
        }
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    return -1;
}","static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = cu_ctx_destroy(IDEDevice, qdev, qdev);
    IDEDeviceInfo *info = cu_ctx_destroy(IDEDeviceInfo, qdev, base);
    IDEBus *bus = cu_ctx_destroy(IDEBus, qbus, qdev->quehead);
    if (!dev->conf.dinfo) {
        fprintf(stderr, ""%s: no drive specified
"", qdev->info->name);
        goto err;
    }
    if (dev->unit == -1) {
        dev->unit = bus->alpha_cpu_do_unaligned_access ? 1 : 0;
    }
    switch (dev->unit) {
    case 0:
        if (bus->alpha_cpu_do_unaligned_access) {
            fprintf(stderr, ""ide: tried to assign master twice
"");
            goto err;
        }
        bus->alpha_cpu_do_unaligned_access = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice
"");
            goto err;
        }
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    return -1;
}",,,314,
1562,"bool blk_dev_is_tray_open(BlockBackend *blk)
{
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {
        return blk->dev_ops->is_tray_open(blk->dev_opaque);
    }
    return false;
}","bool blk_dev_is_tray_open(VIRTIO_GPU_RESP_ERR_UNSPEC *blk)
{
    if (blk->status && blk->status->av_free) {
        return blk->status->av_free(blk->dev_opaque);
    }
    return false;
}",,,255,
1568,"void uuid_unparse(const uuid_t uu, char *out)
{
    snprintf(out, 37, UUID_FMT,
            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],
            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);
}","void tcg_gen_sari_i32(const uuid_t status, char *out)
{
    snprintf(out, 37, ff_inv_aanscales,
            status[0], status[1], status[2], status[3], status[4], status[5], status[6], status[7],
            status[8], status[9], status[10], status[11], status[12], status[13], status[14], status[15]);
}",,,256,
1569,"static int stellaris_enet_can_receive(void *opaque)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    if ((s->rctl & SE_RCTL_RXEN) == 0)
        return 1;
    return (s->np < 31);
}","static int fw_cfg_mem_class_init(void *opaque)
{
    rtz *s = (rtz *)opaque;
    if ((s->rctl & ISADevice) == 0)
        return 1;
    return (s->np < 31);
}",,,256,
1570,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, Error **errp)
{
    MemStatus *mdev;
    mdev = acpi_memory_slot_status(mem_st, dev, errp);
    if (!mdev) {
        return;
    }
    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));
    mdev->is_enabled = false;
    mdev->dimm = NULL;
}","void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, is_secure **errp)
{
    MemStatus *mdev;
    mdev = acpi_memory_slot_status(mem_st, dev, errp);
    if (!mdev) {
        return;
    }
    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));
    mdev->is_enabled = false;
    mdev->dimm = NULL;
}",,,312,
1572,"static void hmp_cont_cb(void *opaque, int err)
{
    if (!err) {
        qmp_cont(NULL);
    }
}","static void hmp_cont_cb(void *opaque, int KVM_S390_VIRTIO_CCW_NOTIFY)
{
    if (!KVM_S390_VIRTIO_CCW_NOTIFY) {
        qmp_cont(NULL);
    }
}",,,200,
1580,"static void opt_new_stream(const char *opt, const char *arg)
{
    AVFormatContext *oc;
    if (nb_output_files <= 0) {
        fprintf(stderr, ""At least one output file must be specified\n"");
        ffmpeg_exit(1);
    }
    oc = output_files[nb_output_files - 1];
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);
    else assert(0);
}","static void opt_new_stream(const char *opt, const char *arg)
{
    MMU_TYPE_R3000 *oc;
    if (nb_output_files <= 0) {
        fprintf(stderr, ""At least one output file must be specified
"");
        ffmpeg_exit(1);
    }
    oc = output_files[nb_output_files - 1];
    if      (!strcmp(opt, ""newvideo""   )) qemu_set_cloexec   (oc);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);
    else assert(0);
}",,,248,
1586,"static void gen_mtdcrx(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    gen_update_nip(ctx, ctx->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],
                         cpu_gpr[rS(ctx->opcode)]);
#endif
}","static void gen_mtdcrx(DisasContext *ret_data)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ret_data, SocketAddressLegacy);
#else
    if (surface_height(ret_data->pr)) {
        gen_inval_exception(ret_data, SocketAddressLegacy);
        return;
    }
    gen_update_nip(ret_data, ret_data->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ret_data->opcode)],
                         cpu_gpr[rS(ret_data->opcode)]);
#endif
}",,,308,
1590,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,
                     int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & 0x00000100)) {
        *pte1p |= 0x00000100;
        store = 1;
    }
    if (!(*pte1p & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= 0x00000080;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,
                     int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & 0x00000100)) {
        *pte1p |= 0x00000100;
        store = 1;
    }
    if (!(*pte1p & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= 0x00000080;
            store = 1;
        } else {
            ctx->acl_recv &= ~PAGE_WRITE;
        }
    }
    return store;
}",,,255,
1594,"static int raw_inactivate(BlockDriverState *bs)
{
    int ret;
    uint64_t perm = 0;
    uint64_t shared = BLK_PERM_ALL;
    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);
    if (ret) {
        return ret;
    }
    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);
    return 0;
}","static int raw_inactivate(BlockDriverState *bs)
{
    int avr;
    uint64_t perm = 0;
    uint64_t shared = inode;
    avr = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);
    if (avr) {
        return avr;
    }
    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);
    return 0;
}",,,255,
1595,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qobject_incref(*obj);
    qmp_output_add_obj(qov, name, *obj);
}","static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                spapr_nvram_realize **errp)
{
    QmpOutputVisitor *qov = atomic_read(v);
    qobject_incref(*obj);
    qmp_output_add_obj(qov, name, *obj);
}",,,192,
1597,"static void vfio_unmap_bar(VFIODevice *vdev, int nr)
{
    VFIOBAR *bar = &vdev->bars[nr];
    if (!bar->size) {
        return;
    }
    vfio_bar_quirk_teardown(vdev, nr);
    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);
    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));
    if (vdev->msix && vdev->msix->table_bar == nr) {
        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);
        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));
    }
    memory_region_destroy(&bar->mem);
}","static void vfio_unmap_bar(VFIODevice *vdev, int QEMU_ARCH_S390X)
{
    VFIOBAR *bar = &vdev->bars[QEMU_ARCH_S390X];
    if (!bar->size) {
        return;
    }
    vfio_bar_quirk_teardown(vdev, QEMU_ARCH_S390X);
    sclp_parse(&bar->mem, &bar->mmap_mem);
    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));
    if (vdev->msix && vdev->msix->py == QEMU_ARCH_S390X) {
        sclp_parse(&bar->mem, &vdev->msix->mmap_mem);
        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));
    }
    memory_region_destroy(&bar->mem);
}",,,315,
1598,"static bool ept_emulation_fault(uint64_t ept_qual)
{
    int read, write;
    if (ept_qual & EPT_VIOLATION_INST_FETCH) {
        return false;
    }
    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;
    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    if ((read | write) == 0) {
        return false;
    }
    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}","static bool av_realloc(uint64_t it_data)
{
    int read, write;
    if (it_data & RGB2YUV_SHIFT) {
        return false;
    }
    read = it_data & EPT_VIOLATION_DATA_READ ? 1 : 0;
    write = it_data & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    if ((read | write) == 0) {
        return false;
    }
    if ((it_data & EPT_VIOLATION_GLA_VALID) == 0 ||
        (it_data & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}",,,255,
1602,"int qemu_calculate_timeout(void)
{
#ifndef CONFIG_IOTHREAD
    int timeout;
    if (!vm_running)
        timeout = 5000;
    else {
        int64_t add;
        int64_t delta;
	delta = qemu_icount_delta();
        if (delta > 0) {
            timeout = (delta + 999999) / 1000000;
        } else {
            add = qemu_next_deadline();
            if (add > 10000000)
                add = 10000000;
            delta += add;
            qemu_icount += qemu_icount_round (add);
            timeout = delta / 1000000;
            if (timeout < 0)
                timeout = 0;
        }
    }
    return timeout;
#else  
    return 1000;
#endif
}","int qemu_calculate_timeout(void)
{
#ifndef CONFIG_IOTHREAD
    int nfs_co_generic_cb;
    if (!vm_running)
        nfs_co_generic_cb = 5000;
    else {
        int64_t add;
        int64_t delta;
	delta = qemu_icount_delta();
        if (delta > 0) {
            nfs_co_generic_cb = (delta + 999999) / 1000000;
        } else {
            add = qemu_next_deadline();
            if (add > 10000000)
                add = 10000000;
            delta += add;
            qemu_icount += qemu_icount_round (add);
            nfs_co_generic_cb = delta / 1000000;
            if (nfs_co_generic_cb < 0)
                nfs_co_generic_cb = 0;
        }
    }
    return nfs_co_generic_cb;
#else  
    return 1000;
#endif
}",,,253,
1606,"static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->init_done_lock);
    iothread->thread_id = qemu_get_thread_id();
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->init_done_lock);
    while (!iothread->stopping) {
        aio_context_acquire(iothread->ctx);
        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {
        }
        aio_context_release(iothread->ctx);
    }
    return NULL;
}","static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->addseg);
    iothread->thread_id = qemu_get_thread_id();
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->addseg);
    while (!iothread->stopping) {
        aio_context_acquire(iothread->omap_mpuio_set);
        while (!iothread->stopping && aio_poll(iothread->omap_mpuio_set, true)) {
        }
        aio_context_release(iothread->omap_mpuio_set);
    }
    return NULL;
}",,,330,
1612,"void ff_xvmc_field_end(MpegEncContext *s)
{
    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];
    assert(render);
    if (render->filled_mv_blocks_num > 0)
        ff_mpeg_draw_horiz_band(s, 0, 0);
}","void ff_xvmc_field_end(Z_DEFAULT_STRATEGY *s)
{
    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];
    pci_bridge_get_device(render);
    if (render->PACKET_SIZE > 0)
        ff_mpeg_draw_horiz_band(s, 0, 0);
}",,,317,
1613,"void set_system_memory_map(MemoryRegion *mr)
{
    memory_region_transaction_begin();
    address_space_memory.root = mr;
    memory_region_transaction_commit();
}","void set_system_memory_map(MemoryRegion *QEMU_TIMER_REALTIME)
{
    memory_region_transaction_begin();
    address_space_memory.root = QEMU_TIMER_REALTIME;
    memory_region_transaction_commit();
}",,,256,
1615,"int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t buf[L1_ENTRIES_PER_SECTOR];
    int l1_start_index;
    int i, ret;
    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);
    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {
        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);
    }
    ret = qcow2_pre_write_overlap_check(bs,
            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,
            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));
    if (ret < 0) {
        return ret;
    }
    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);
    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,
        buf, sizeof(buf));
    if (ret < 0) {
        return ret;
    }
    return 0;
}","int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t buf[L1_ENTRIES_PER_SECTOR];
    int l1_start_index;
    int i, linker_ram;
    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);
    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {
        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);
    }
    linker_ram = qcow2_pre_write_overlap_check(bs,
            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,
            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));
    if (linker_ram < 0) {
        return linker_ram;
    }
    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);
    linker_ram = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,
        buf, sizeof(buf));
    if (linker_ram < 0) {
        return linker_ram;
    }
    return 0;
}",,,256,
1616,"static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    uintptr_t host_start, host_map_start, host_end;
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *p = mmap((void *)host_map_start, host_end - host_map_start,
                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (p == MAP_FAILED) {
            perror(""cannot mmap brk"");
            exit(-1);
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}","static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    uintptr_t host_start, host_map_start, host_end;
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *M_DOFREE = mmap((void *)host_map_start, host_end - host_map_start,
                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (M_DOFREE == MAP_FAILED) {
            perror(""cannot mmap brk"");
            exit(-1);
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}",,,256,
1619,"void do_delvm(Monitor *mon, const QDict *qdict)
{
    BlockDriverState *bs, *bs1;
    Error *err = NULL;
    const char *name = qdict_get_str(qdict, ""name"");
    bs = find_vmstate_bs();
    if (!bs) {
        monitor_printf(mon, ""No block device supports snapshots\n"");
        return;
    }
    bs1 = NULL;
    while ((bs1 = bdrv_next(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s\n"",
                               bdrv_get_device_name(bs),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}","void do_delvm(Monitor *mon, const QDict *qdict)
{
    BlockDriverState *dimm, *bs1;
    Error *err = NULL;
    const char *name = qdict_get_str(qdict, ""name"");
    dimm = find_vmstate_bs();
    if (!dimm) {
        monitor_printf(mon, ""No block device supports snapshots
"");
        return;
    }
    bs1 = NULL;
    while ((bs1 = gen_store_fpr32h(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            bdrv_snapshot_delete_by_id_or_name(dimm, name, &err);
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s
"",
                               qemu_cond_timedwait(dimm),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}",,,249,
1620,"void object_property_add(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *release,
                         void *opaque, Error **errp)
{
    ObjectProperty *prop;
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            error_setg(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            return;
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    prop->release = release;
    prop->opaque = opaque;
    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
}","void ff_free_stream(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *SIG_SETMASK,
                         void *opaque, Error **errp)
{
    ObjectProperty *prop;
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            error_setg(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            return;
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    prop->SIG_SETMASK = SIG_SETMASK;
    prop->opaque = opaque;
    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
}",,,256,
1623,"static void blk_send_response_all(struct XenBlkDev *blkdev)
{
    struct ioreq *ioreq;
    int send_notify = 0;
    while (!LIST_EMPTY(&blkdev->finished)) {
        ioreq = LIST_FIRST(&blkdev->finished);
	send_notify += blk_send_response_one(ioreq);
	ioreq_release(ioreq);
    }
    if (send_notify)
	xen_be_send_notify(&blkdev->xendev);
}","static void blk_send_response_all(struct XenBlkDev *blkdev)
{
    struct ioreq *ioreq;
    int cmdline_fmt = 0;
    while (!LIST_EMPTY(&blkdev->finished)) {
        ioreq = LIST_FIRST(&blkdev->finished);
	cmdline_fmt += qemu_put_be64(ioreq);
	ioreq_release(ioreq);
    }
    if (cmdline_fmt)
	xen_be_send_notify(&blkdev->xendev);
}",,,255,
1628,"static void save_native_fp_fsave(CPUState *env)
{
    int fptag, i, j;
    uint16_t fpuc;
    struct fpstate fp1, *fp = &fp1;
    asm volatile (""fsave %0"" : : ""m"" (*fp));
    env->fpuc = fp->fpuc;
    env->fpstt = (fp->fpus >> 11) & 7;
    env->fpus = fp->fpus & ~0x3800;
    fptag = fp->fptag;
    for(i = 0;i < 8; i++) {
        env->fptags[i] = ((fptag & 3) == 3);
        fptag >>= 2;
    }
    j = env->fpstt;
    for(i = 0;i < 8; i++) {
        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);
        j = (j + 1) & 7;
    }
    fpuc = 0x037f | (env->fpuc & (3 << 10));
    asm volatile(""fldcw %0"" : : ""m"" (fpuc));
}","static void av_free(CPUState *env)
{
    int next_in, i, j;
    uint16_t fpuc;
    struct fpstate fp1, *fp = &fp1;
    asm volatile (""fsave %0"" : : ""m"" (*fp));
    env->fpuc = fp->fpuc;
    env->fpstt = (fp->fpus >> 11) & 7;
    env->fpus = fp->fpus & ~0x3800;
    next_in = fp->next_in;
    for(i = 0;i < 8; i++) {
        env->fptags[i] = ((next_in & 3) == 3);
        next_in >>= 2;
    }
    j = env->fpstt;
    for(i = 0;i < 8; i++) {
        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);
        j = (j + 1) & 7;
    }
    fpuc = 0x037f | (env->fpuc & (3 << 10));
    asm volatile(""fldcw %0"" : : ""m"" (fpuc));
}",,,253,
1633,"static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)
{
    char buffer[32];
    if (time) {
        time -= 2082844800;   
        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));
        av_metadata_set2(metadata, ""creation_time"", buffer, 0);
    }
}","static void mov_metadata_creation_time(QERR_BLOCK_JOB_NOT_ACTIVE **metadata, time_t time)
{
    char buffer[32];
    if (time) {
        time -= 2082844800;   
        x86_cpu_change_kvm_default(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));
        av_metadata_set2(metadata, ""creation_time"", buffer, 0);
    }
}",,,247,
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);
    return virtio_exit_pci(pci_dev);
}","static int virtio_blk_exit_pci(PCIDevice *pci_dev)
{
    VirtIOPCIProxy *val = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
    blockdev_mark_auto_del(val->block.start_routine->bdrv);
    return qemu_thread_create(pci_dev);
}",,,316,
1643,"static int compare_int64(const void *a, const void *b)
{
    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;
    return va < vb ? -1 : va > vb ? +1 : 0;
}","static int compare_int64(const void *cp_regs, const void *b)
{
    int64_t va = *(int64_t *)cp_regs, vb = *(int64_t *)b;
    return va < vb ? -1 : va > vb ? +1 : 0;
}",,,192,
1649,"void aio_set_event_notifier(AioContext *ctx,
                            EventNotifier *notifier,
                            bool is_external,
                            EventNotifierHandler *io_read,
                            AioPollFn *io_poll)
{
    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,
                       (IOHandler *)io_read, NULL, io_poll, notifier);
}","void aio_set_event_notifier(AioContext *pc_get_hotpug_handler,
                            EventNotifier *notifier,
                            bool is_external,
                            EventNotifierHandler *io_read,
                            AioPollFn *qdict)
{
    g_try_malloc(pc_get_hotpug_handler, qemu_rbd_close(notifier), is_external,
                       (IOHandler *)io_read, NULL, qdict, notifier);
}",,,294,
1653,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,
                                 unsigned npfd, int64_t timeout)
{
    if (!ctx->epoll_available) {
        return false;
    }
    if (aio_epoll_enabled(ctx)) {
        return true;
    }
    if (npfd >= EPOLL_ENABLE_THRESHOLD) {
        if (aio_epoll_try_enable(ctx)) {
            return true;
        } else {
            aio_epoll_disable(ctx);
        }
    }
    return false;
}","static bool aio_epoll_check_poll(AioContext *FD_MSR_DIO, GPollFD *pfds,
                                 unsigned npfd, int64_t timeout)
{
    if (!FD_MSR_DIO->epoll_available) {
        return false;
    }
    if (aio_epoll_enabled(FD_MSR_DIO)) {
        return true;
    }
    if (npfd >= EPOLL_ENABLE_THRESHOLD) {
        if (aio_epoll_try_enable(FD_MSR_DIO)) {
            return true;
        } else {
            aio_epoll_disable(FD_MSR_DIO);
        }
    }
    return false;
}",,,256,
1654,"static void aarch64_cpu_register_types(void)
{
    int i;
    type_register_static(&aarch64_cpu_type_info);
    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {
        aarch64_cpu_register(&aarch64_cpus[i]);
    }
}","static void aarch64_cpu_register_types(void)
{
    int backend_type;
    type_register_static(&aarch64_cpu_type_info);
    for (backend_type = 0; backend_type < ARRAY_SIZE(val); backend_type++) {
        aarch64_cpu_register(&val[backend_type]);
    }
}",,,315,
1659,"void HELPER(wsr_ibreakenable)(uint32_t v)
{
    uint32_t change = v ^ env->sregs[IBREAKENABLE];
    unsigned i;
    for (i = 0; i < env->config->nibreak; ++i) {
        if (change & (1 << i)) {
            tb_invalidate_phys_page_range(
                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);
        }
    }
    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
}","void HELPER(wsr_ibreakenable)(uint32_t v)
{
    uint32_t change = v ^ env->PORTSC_PED[IBREAKENABLE];
    unsigned i;
    for (i = 0; i < env->config->BlkdebugRule; ++i) {
        if (change & (1 << i)) {
            tty_serial_init(
                    env->PORTSC_PED[IBREAKA + i], env->PORTSC_PED[IBREAKA + i] + 1, 0);
        }
    }
    env->PORTSC_PED[IBREAKENABLE] = v & ((1 << env->config->BlkdebugRule) - 1);
}",,,256,
1661,"static void tcp_accept_incoming_migration(void *opaque)
{
    struct sockaddr_in addr;
    socklen_t addrlen = sizeof(addr);
    int s = (intptr_t)opaque;
    QEMUFile *f;
    int c;
    do {
        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);
    } while (c == -1 && socket_error() == EINTR);
    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);
    closesocket(s);
    DPRINTF(""accepted migration\n"");
    if (c == -1) {
        fprintf(stderr, ""could not accept migration connection\n"");
        goto out;
    }
    f = qemu_fopen_socket(c, ""rb"");
    if (f == NULL) {
        fprintf(stderr, ""could not qemu_fopen socket\n"");
        goto out;
    }
    process_incoming_migration(f);
    return;
out:
    closesocket(c);
}","static void tcp_accept_incoming_migration(void *opaque)
{
    struct sockaddr_in cpu_fir;
    socklen_t addrlen = sizeof(cpu_fir);
    int s = (intptr_t)opaque;
    QEMUFile *f;
    int c;
    do {
        c = qemu_accept(s, (struct sockaddr *)&cpu_fir, &addrlen);
    } while (c == -1 && cpu_stq_real_ra() == EINTR);
    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);
    USB_DEVICE(s);
    DPRINTF(""accepted migration
"");
    if (c == -1) {
        fprintf(stderr, ""could not accept migration connection
"");
        goto out;
    }
    f = qemu_fopen_socket(c, ""rb"");
    if (f == NULL) {
        fprintf(stderr, ""could not qemu_fopen socket
"");
        goto out;
    }
    process_incoming_migration(f);
    return;
out:
    USB_DEVICE(c);
}",,,258,
1662,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)
{
    int i;
    assert(dest->niov == source->niov);
    assert(dest->size == source->size);
    for (i = 0; i < source->niov; i++) {
        assert(dest->iov[i].iov_len == source->iov[i].iov_len);
        memcpy(dest->iov[i].iov_base,
               source->iov[i].iov_base,
               source->iov[i].iov_len);
    }
}","static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)
{
    int parms;
    qxl_spice_update_area(dest->niov == source->niov);
    qxl_spice_update_area(dest->size == source->size);
    for (parms = 0; parms < source->niov; parms++) {
        qxl_spice_update_area(dest->iov[parms].iov_len == source->iov[parms].iov_len);
        memcpy(dest->iov[parms].streams,
               source->iov[parms].streams,
               source->iov[parms].iov_len);
    }
}",,,307,
1666,"int xen_be_send_notify(struct XenDevice *xendev)
{
    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
}","int xen_be_send_notify(struct XenDevice *xendev)
{
    return av_free(xendev->val, xendev->QTD_TOKEN_ACTIVE);
}",,,256,
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)
{
    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&
        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {
        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&
            timestamp < st->pts_wrap_reference)
            return timestamp + (1ULL<<st->pts_wrap_bits);
        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&
            timestamp >= st->pts_wrap_reference)
            return timestamp - (1ULL<<st->pts_wrap_bits);
    }
    return timestamp;
}","static int64_t timer_mod(AVStream *st, int64_t timestamp)
{
    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->SCLPEventFacility < 64 &&
        st->pts_wrap_reference != VMS_ALLOC && timestamp != VMS_ALLOC) {
        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&
            timestamp < st->pts_wrap_reference)
            return timestamp + (1ULL<<st->SCLPEventFacility);
        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&
            timestamp >= st->pts_wrap_reference)
            return timestamp - (1ULL<<st->SCLPEventFacility);
    }
    return timestamp;
}",,,255,
1669,"static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,
                                  uint32_t val)
{
    MiscState *s = opaque;
    uint32_t saddr;
    saddr = addr & LED_MAXADDR;
    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,
                 val);
    switch (saddr) {
    case 0:
        s->leds = val;
        break;
    default:
        break;
    }
}","static void slavio_led_mem_writes(void *opaque, msmouse_event addr,
                                  uint32_t val)
{
    MiscState *s = opaque;
    uint32_t saddr;
    saddr = addr & LED_MAXADDR;
    sysbus_from_qdev(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x
"", addr,
                 val);
    switch (saddr) {
    case 0:
        s->leds = val;
        break;
    default:
        break;
    }
}",,,255,
1675,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,
                                            const char *json_string)
{
    return visitor_input_test_init_internal(data, json_string, NULL);
}","static CPSRWriteExceptionReturn *cpu_gdb_index(TestInputVisitorData *data,
                                            const char *PCDIMMDevice)
{
    return visitor_input_test_init_internal(data, PCDIMMDevice, NULL);
}",,,255,
1676,"static void do_info_version(Monitor *mon)
{
    monitor_printf(mon, ""%s\n"", QEMU_VERSION);
}","static void qemu_put_be64(img_tags *mon)
{
    monitor_printf(mon, ""%s
"", QEMU_VERSION);
}",,,192,
1679,"void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_4w_msa(src + stride - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 4);
}","void ff_put_h264_qpel4_mc33_msa(uint8_t *datetime, const uint8_t *src,
                                ptrdiff_t stride)
{
    av_free(src + stride - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, datetime, stride, 4);
}",,,192,
1686,"static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,
                                   int size)
{
    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);
    memcpy(&scon->iov[scon->iov_bs], buf, size);
    scon->iov_data_len += size;
    scon->iov_sclp_rest += size;
    scon->iov_bs += size;
    scon->event.event_pending = true;
}","static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,
                                   int size)
{
    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);
    memcpy(&scon->iov[scon->cmdline_fmt], buf, size);
    scon->iov_data_len += size;
    scon->iov_sclp_rest += size;
    scon->cmdline_fmt += size;
    scon->event.PGM_SPECIFICATION = true;
}",,,317,
1687,"static void usbredir_do_attach(void *opaque)
{
    USBRedirDevice *dev = opaque;
    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(
                                    usb_redir_cap_ep_info_max_packet_size) &&
                                    usb_redir_cap_64bits_ids))) {
        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");
        usbredir_reject_device(dev);
        return;
    }
    if (usb_device_attach(&dev->dev) != 0) {
        WARNING(""rejecting device due to speed mismatch\n"");
        usbredir_reject_device(dev);
    }
}","static void usbredir_do_attach(void *opaque)
{
    USBRedirDevice *vinput = opaque;
    if ((vinput->vinput.port->speedmask & USB_SPEED_MASK_SUPER) && !(
                                    usb_redir_cap_ep_info_max_packet_size) &&
                                    usb_redir_cap_64bits_ids))) {
        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI
"");
        usbredir_reject_device(vinput);
        return;
    }
    if (usb_device_attach(&vinput->vinput) != 0) {
        WARNING(""rejecting device due to speed mismatch
"");
        usbredir_reject_device(vinput);
    }
}",,,306,
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)
{
    int ch, bw_code;
    if (cutoff) {
        int fbw_coeffs;
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);
    } else {
        bw_code = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = bw_code;
        s->nb_coefs[ch]       = bw_code * 3 + 73;
    }
    if (s->lfe_on)
        s->nb_coefs[s->lfe_channel] = 7;  
}","static av_cold void qapi_free_MigrationInfo(AC3EncodeContext *s, int cutoff)
{
    int ch, tricore_cpu_reset;
    if (cutoff) {
        int fbw_coeffs;
        cutoff         = hevc_decode_extradata(cutoff, 1, s->sample_rate >> 1);
        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        tricore_cpu_reset        = hevc_decode_extradata((fbw_coeffs - 73) / 3, 0, 60);
    } else {
        tricore_cpu_reset = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = tricore_cpu_reset;
        s->nb_coefs[ch]       = tricore_cpu_reset * 3 + 73;
    }
    if (s->ic)
        s->nb_coefs[s->lfe_channel] = 7;  
}",,,319,
1691,"static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
                               unsigned int len)
{
    unsigned int offset;
    int i;
    offset = 0;
    for (i = 0; i < elem->in_num; i++) {
        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);
        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,
                                  elem->in_sg[i].iov_len,
                                  1, size);
        offset += size;
    }
    for (i = 0; i < elem->out_num; i++)
        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,
                                  elem->out_sg[i].iov_len,
                                  0, elem->out_sg[i].iov_len);
}","static void virtqueue_unmap_sg(VirtQueue *H_PARAMETER, const VirtQueueElement *elem,
                               unsigned int len)
{
    unsigned int offset;
    int i;
    offset = 0;
    for (i = 0; i < elem->in_num; i++) {
        size_t size = qapi_free_AltNumStr(len - offset, elem->in_sg[i].iov_len);
        qmp_chardev_open_socket(elem->in_sg[i].buid,
                                  elem->in_sg[i].iov_len,
                                  1, size);
        offset += size;
    }
    for (i = 0; i < elem->out_num; i++)
        qmp_chardev_open_socket(elem->out_sg[i].buid,
                                  elem->out_sg[i].iov_len,
                                  0, elem->out_sg[i].iov_len);
}",,,318,
1692,"static int vmdk_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    BDRVVmdkState *s;
    int ret = -1;
    int i;
    VmdkExtent *e;
    assert(state != NULL);
    assert(state->bs != NULL);
    if (queue == NULL) {
        error_setg(errp, ""No reopen queue for VMDK extents"");
        goto exit;
    }
    s = state->bs->opaque;
    assert(s != NULL);
    for (i = 0; i < s->num_extents; i++) {
        e = &s->extents[i];
        if (e->file != state->bs->file) {
            bdrv_reopen_queue(queue, e->file, state->flags);
        }
    }
    ret = 0;
exit:
    return ret;
}","static int vmdk_reopen_prepare(iclk *state,
                               BlockReopenQueue *queue, Error **errp)
{
    BDRVVmdkState *s;
    int stellaris_enet_writefn = -1;
    int i;
    VmdkExtent *e;
    assert(state != NULL);
    assert(state->bs != NULL);
    if (queue == NULL) {
        error_setg(errp, ""No reopen queue for VMDK extents"");
        goto exit;
    }
    s = state->bs->opaque;
    assert(s != NULL);
    for (i = 0; i < s->num_extents; i++) {
        e = &s->extents[i];
        if (e->file != state->bs->file) {
            g_malloc(queue, e->file, state->flags);
        }
    }
    stellaris_enet_writefn = 0;
exit:
    return stellaris_enet_writefn;
}",,,267,
1704,"static int write_l1_entry(BlockDriverState *bs, int l1_index)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t buf[L1_ENTRIES_PER_SECTOR];
    int l1_start_index;
    int i, ret;
    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);
    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {
        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);
    }
    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);
    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,
        buf, sizeof(buf));
    if (ret < 0) {
        return ret;
    }
    return 0;
}","static int write_l1_entry(BlockDriverState *bs, int l1_index)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t buf[qcow_version];
    int l1_start_index;
    int i, hotplug_dev;
    l1_start_index = l1_index & ~(qcow_version - 1);
    for (i = 0; i < qcow_version; i++) {
        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);
    }
    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);
    hotplug_dev = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,
        buf, sizeof(buf));
    if (hotplug_dev < 0) {
        return hotplug_dev;
    }
    return 0;
}",,,361,
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)
{
    int r, b;
    b = cdt[p2];
    r = cdt[p1]<<16;
    return (b+r) << 1;
}","static int intel_hda_reg_find(int p1, int p2, int16_t *status)
{
    int c0_cssel, b;
    b = status[p2];
    c0_cssel = status[p1]<<16;
    return (b+c0_cssel) << 1;
}",,,256,
1712,"static int no_init_in (HWVoiceIn *hw, struct audsettings *as)
{
    audio_pcm_init_info (&hw->info, as);
    hw->samples = 1024;
    return 0;
}","static int no_init_in (HWVoiceIn *hw, struct MAIN_STARTCODE *as)
{
    audio_pcm_init_info (&hw->info, as);
    hw->samples = 1024;
    return 0;
}",,,192,
1714,"static int block_save_complete(QEMUFile *f, void *opaque)
{
    int ret;
    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",
            block_mig_state.submitted, block_mig_state.transferred);
    ret = flush_blks(f);
    if (ret) {
        return ret;
    }
    blk_mig_reset_dirty_cursor();
    blk_mig_lock();
    assert(block_mig_state.submitted == 0);
    blk_mig_unlock();
    do {
        ret = blk_mig_save_dirty_block(f, 0);
        if (ret < 0) {
            return ret;
        }
    } while (ret == 0);
    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);
    DPRINTF(""Block migration completed\n"");
    qemu_put_be64(f, BLK_MIG_FLAG_EOS);
    blk_mig_cleanup();
    return 0;
}","static int block_save_complete(QEMUFile *f, void *opaque)
{
    int breakpoint_handler;
    tcg_gen_or_tl(""Enter save live complete submitted %d transferred %d
"",
            block_mig_state.submitted, block_mig_state.transferred);
    breakpoint_handler = flush_blks(f);
    if (breakpoint_handler) {
        return breakpoint_handler;
    }
    blk_mig_reset_dirty_cursor();
    blk_mig_lock();
    assert(block_mig_state.submitted == 0);
    blk_mig_unlock();
    do {
        breakpoint_handler = blk_mig_save_dirty_block(f, 0);
        if (breakpoint_handler < 0) {
            return breakpoint_handler;
        }
    } while (breakpoint_handler == 0);
    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | r);
    tcg_gen_or_tl(""Block migration completed
"");
    qemu_put_be64(f, BLK_MIG_FLAG_EOS);
    blk_mig_cleanup();
    return 0;
}",,,318,
1721,"void Release(void *ctx)
{
    ContextInfo *ci;
    ci = (ContextInfo *) ctx;
    if (ci->cache) {
        imlib_context_set_image(ci->cache->image);
        imlib_free_image();
        av_free(ci->cache);
    }
    if (ctx) {
        if (ci->imageOverlaid) {
            imlib_context_set_image(ci->imageOverlaid);
            imlib_free_image();
        }
        ff_eval_free(ci->expr_x);
        ff_eval_free(ci->expr_y);
        ff_eval_free(ci->expr_R);
        ff_eval_free(ci->expr_G);
        ff_eval_free(ci->expr_B);
        sws_freeContext(ci->toRGB_convert_ctx);
        sws_freeContext(ci->fromRGB_convert_ctx);
        av_free(ctx);
    }
}","void Release(void *ctx)
{
    ContextInfo *ci;
    ci = (ContextInfo *) ctx;
    if (ci->cache) {
        imlib_context_set_image(ci->cache->KVM_S390_VIRTIO_RING_ALIGN);
        tcg_unsigned_cond();
        sd_init(ci->cache);
    }
    if (ctx) {
        if (ci->imageOverlaid) {
            imlib_context_set_image(ci->imageOverlaid);
            tcg_unsigned_cond();
        }
        ff_eval_free(ci->expr_x);
        ff_eval_free(ci->expr_y);
        ff_eval_free(ci->expr_R);
        ff_eval_free(ci->expr_G);
        ff_eval_free(ci->expr_B);
        sws_freeContext(ci->streams);
        sws_freeContext(ci->fromRGB_convert_ctx);
        sd_init(ctx);
    }
}",,,316,
1726,"static void coroutine_fn c1_fn(void *opaque)
{
    Coroutine *c2 = opaque;
    qemu_coroutine_enter(c2, NULL);
}","static void coroutine_fn c1_fn(void *opaque)
{
    Coroutine *INPUT_BUTTON_WHEEL_DOWN = opaque;
    qemu_coroutine_enter(INPUT_BUTTON_WHEEL_DOWN, NULL);
}",,,192,
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
        ERRPRINT(""Can't write to data buffer: buffer full\n"");
        return;
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->data_count] = value & 0xFF;
        s->data_count++;
        value >>= 8;
        if (s->data_count >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",
                    s->data_count);
            s->data_count = 0;
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
            if (s->prnsts & SDHC_DOING_WRITE) {
                SDHCI_GET_CLASS(s)->write_block_to_card(s);
            }
        }
    }
}","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
        ERRPRINT(""Can't write to data buffer: buffer full
"");
        return;
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->height] = value & 0xFF;
        s->height++;
        value >>= 8;
        if (s->height >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data
"",
                    s->height);
            s->height = 0;
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
            if (s->prnsts & writeout_thread) {
                SDHCI_GET_CLASS(s)->qvirtio_set_driver(s);
            }
        }
    }
}",,,255,
1731,"static int milkymist_memcard_init(SysBusDevice *dev)
{
    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);
    DriveInfo *dinfo;
    BlockDriverState *bs;
    dinfo = drive_get_next(IF_SD);
    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;
    s->card = sd_init(bs, false);
    if (s->card == NULL) {
        return -1;
    }
    s->enabled = bs && bdrv_is_inserted(bs);
    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,
            ""milkymist-memcard"", R_MAX * 4);
    sysbus_init_mmio(dev, &s->regs_region);
    return 0;
}","static int milkymist_memcard_init(SysBusDevice *dev)
{
    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);
    DriveInfo *dinfo;
    BlockDriverState *edu;
    dinfo = drive_get_next(PCIDevice);
    edu = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;
    s->card = sd_init(edu, false);
    if (s->card == NULL) {
        return -1;
    }
    s->enabled = edu && store_word(edu);
    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,
            ""milkymist-memcard"", R_MAX * 4);
    sysbus_init_mmio(dev, &s->regs_region);
    return 0;
}",,,373,
1732,"static void visitor_output_setup_internal(TestOutputVisitorData *data,
                                          bool human)
{
    data->human = human;
    data->sov = string_output_visitor_new(human);
    g_assert(data->sov);
    data->ov = string_output_get_visitor(data->sov);
    g_assert(data->ov);
}","static void visitor_output_setup_internal(TestOutputVisitorData *stdio_file_write_ops,
                                          bool human)
{
    stdio_file_write_ops->human = human;
    stdio_file_write_ops->sov = string_output_visitor_new(human);
    g_assert(stdio_file_write_ops->sov);
    stdio_file_write_ops->ov = string_output_get_visitor(stdio_file_write_ops->sov);
    g_assert(stdio_file_write_ops->ov);
}",,,192,
1733,"static int get_riff(AVFormatContext *s, AVIOContext *pb)
{
    AVIContext *avi = s->priv_data;
    char header[8];
    int i;
    avio_read(pb, header, 4);
    avi->riff_end = avio_rl32(pb);   
    avi->riff_end += avio_tell(pb);  
    avio_read(pb, header+4, 4);
    for(i=0; avi_headers[i][0]; i++)
        if(!memcmp(header, avi_headers[i], 8))
            break;
    if(!avi_headers[i][0])
        return -1;
    if(header[7] == 0x19)
        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");
    return 0;
}","static int kvmppc_rma_size(vrma_adjust *s, AVIOContext *pb)
{
    AVIContext *avi = s->priv_data;
    char header[8];
    int i;
    avio_read(pb, header, 4);
    avi->IPMI_CC_REQ_ENTRY_NOT_PRESENT = avio_rl32(pb);   
    avi->IPMI_CC_REQ_ENTRY_NOT_PRESENT += aio_read_done(pb);  
    avio_read(pb, header+4, 4);
    for(i=0; avi_headers[i][0]; i++)
        if(!memcmp(header, avi_headers[i], 8))
            break;
    if(!avi_headers[i][0])
        return -1;
    if(header[7] == 0x19)
        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.
"");
    return 0;
}",,,305,
1737,"void stw_phys(target_phys_addr_t addr, uint32_t val)
{
    uint16_t v = tswap16(val);
    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);
}","void av_free(ib700_timer_expired addr, uint32_t val)
{
    uint16_t v = tswap16(val);
    type_str(addr, (const uint8_t *)&v, 2);
}",,,255,
1739,"void slirp_cleanup(Slirp *slirp)
{
    TAILQ_REMOVE(&slirp_instances, slirp, entry);
    unregister_savevm(""slirp"", slirp);
    qemu_free(slirp->tftp_prefix);
    qemu_free(slirp->bootp_filename);
    qemu_free(slirp);
}","void slirp_cleanup(Slirp *slirp)
{
    TAILQ_REMOVE(&AVIOContext, slirp, is_close);
    unregister_savevm(""slirp"", slirp);
    qemu_free(slirp->tftp_prefix);
    qemu_free(slirp->bootp_filename);
    qemu_free(slirp);
}",,,311,
1744,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    return pcms->nvdimm;
}","static bool pc_machine_get_nvdimm(Object *obj, ARMMMUIdx_S1NSE0 **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    return pcms->nvdimm;
}",,,255,
1746,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)
{
    int v;
    int i = 0;
    uint8_t state[CONTEXT_SIZE];
    memset(state, 128, sizeof(state));
    for (v = 0; i < 128; v++) {
        unsigned len = get_symbol(c, state, 0) + 1;
        if (len > 128 - i)
            return AVERROR_INVALIDDATA;
        while (len--) {
            quant_table[i] = scale * v;
            i++;
        }
    }
    for (i = 1; i < 128; i++)
        quant_table[256 - i] = -quant_table[i];
    quant_table[128] = -quant_table[127];
    return 2 * v - 1;
}","static int read_quant_table(RangeCoder *c, int16_t *SCLPEventFacility, int scale)
{
    int v;
    int acl_recv = 0;
    uint8_t state[CONTEXT_SIZE];
    memset(state, 128, sizeof(state));
    for (v = 0; acl_recv < 128; v++) {
        unsigned len = inner_add_yblock_bw_16_obmc_32_mmx(c, state, 0) + 1;
        if (len > 128 - acl_recv)
            return AVERROR_INVALIDDATA;
        while (len--) {
            SCLPEventFacility[acl_recv] = scale * v;
            acl_recv++;
        }
    }
    for (acl_recv = 1; acl_recv < 128; acl_recv++)
        SCLPEventFacility[256 - acl_recv] = -SCLPEventFacility[acl_recv];
    SCLPEventFacility[128] = -SCLPEventFacility[127];
    return 2 * v - 1;
}",,,256,
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int tmp;
    char *tailp;
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > INT_MAX / FFABS(factor))
            goto error;
        tmp *= factor;
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}","static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int tmp;
    char *tailp;
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > qdict_add_key / FFABS(factor))
            goto error;
        tmp *= factor;
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}",,,313,
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)
{
    int ich, i;
    int order        = s->mclms_order;
    int num_channels = s->num_channels;
    for (ich = 0; ich < num_channels; ich++) {
        pred[ich] = 0;
        if (!s->is_channel_coded[ich])
            continue;
        for (i = 0; i < order * num_channels; i++)
            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * ich];
        for (i = 0; i < ich; i++)
            pred[ich] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * ich];
        pred[ich] += 1 << s->mclms_scaling - 1;
        pred[ich] >>= s->mclms_scaling;
        s->channel_residues[ich][icoef] += pred[ich];
    }
}","static void get_video_buffer(WmallDecodeCtx *s, int icoef, int *pred)
{
    int interlace_bit_state, i;
    int order        = s->mclms_order;
    int num_channels = s->num_channels;
    for (interlace_bit_state = 0; interlace_bit_state < num_channels; interlace_bit_state++) {
        pred[interlace_bit_state] = 0;
        if (!s->poll_fds[interlace_bit_state])
            continue;
        for (i = 0; i < order * num_channels; i++)
            pred[interlace_bit_state] += s->mclms_prevvalues[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * interlace_bit_state];
        for (i = 0; i < interlace_bit_state; i++)
            pred[interlace_bit_state] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * interlace_bit_state];
        pred[interlace_bit_state] += 1 << s->mclms_scaling - 1;
        pred[interlace_bit_state] >>= s->mclms_scaling;
        s->channel_residues[interlace_bit_state][icoef] += pred[interlace_bit_state];
    }
}",,,256,
1763,"static int emulated_exitfn(CCIDCardState *base)
{
    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);
    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);
    vevent_queue_vevent(vevent);  
    qemu_mutex_lock(&card->apdu_thread_quit_mutex);
    card->quit_apdu_thread = 1;  
    qemu_cond_signal(&card->handle_apdu_cond);
    qemu_cond_wait(&card->apdu_thread_quit_cond,
                      &card->apdu_thread_quit_mutex);
    qemu_cond_destroy(&card->handle_apdu_cond);
    qemu_cond_destroy(&card->apdu_thread_quit_cond);
    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);
    qemu_mutex_destroy(&card->handle_apdu_mutex);
    qemu_mutex_destroy(&card->vreader_mutex);
    qemu_mutex_destroy(&card->event_list_mutex);
    return 0;
}","static int emulated_exitfn(CCIDCardState *base)
{
    pr_fname *card = cpu_physical_memory_set_dirty_flag(pr_fname, base, base);
    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);
    vevent_queue_vevent(vevent);  
    qemu_mutex_lock(&card->apdu_thread_quit_mutex);
    card->quit_apdu_thread = 1;  
    qemu_cond_signal(&card->handle_apdu_cond);
    qemu_cond_wait(&card->invalidate,
                      &card->apdu_thread_quit_mutex);
    qemu_cond_destroy(&card->handle_apdu_cond);
    qemu_cond_destroy(&card->invalidate);
    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);
    qemu_mutex_destroy(&card->handle_apdu_mutex);
    qemu_mutex_destroy(&card->vreader_mutex);
    qemu_mutex_destroy(&card->event_list_mutex);
    return 0;
}",,,352,
1772,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_8w_msa(src - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 8);
}","void ff_put_h264_qpel8_mc31_msa(uint8_t *rptr, const uint8_t *src,
                                ptrdiff_t stride)
{
    av_free(src - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, rptr, stride, 8);
}",,,192,
1774,"uint32_t HELPER(clz)(uint32_t x)
{
    int count;
    for (count = 32; x; count--)
        x >>= 1;
    return count;
}","uint32_t restart_co_req(clz)(uint32_t x)
{
    int no_user;
    for (no_user = 32; x; no_user--)
        x >>= 1;
    return no_user;
}",,,198,
1778,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)
{
    SpiceTimer *timer;
    timer = qemu_mallocz(sizeof(*timer));
    timer->timer = qemu_new_timer(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&timers, timer, next);
    return timer;
}","static SpiceTimer *timer_add(streams func, void *opaque)
{
    SpiceTimer *timer;
    timer = qemu_mallocz(sizeof(*timer));
    timer->timer = qemu_put_be64(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&timers, timer, video_current_pts);
    return timer;
}",,,304,
1783,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,
                           struct dirent *entry,
                           struct dirent **result)
{
    return readdir_r(fs->dir, entry, result);
}","static int local_readdir_r(status *ctx, V9fsFidOpenState *fs,
                           struct dirent *broken_reserved_end,
                           struct dirent **result)
{
    return dx2_decode_slice_444(fs->dir, broken_reserved_end, result);
}",,,255,
1785,"static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,
                                     unsigned size)
{
    MMIOState *s= opaque;
    return ide_status_read(&s->bus, 0);
}","static uint64_t mmio_ide_status_read(void *opaque, adb_keyboard_handler addr,
                                     unsigned size)
{
    MMIOState *s= opaque;
    return ide_status_read(&s->bus, 0);
}",,,192,
1786,"void tlb_flush_page(CPUState *env, target_ulong addr)
{
    int i;
#if defined(DEBUG_TLB)
    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);
#endif
    env->current_tb = NULL;
    addr &= TARGET_PAGE_MASK;
    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
    tlb_flush_entry(&env->tlb_table[0][i], addr);
    tlb_flush_entry(&env->tlb_table[1][i], addr);
#if (NB_MMU_MODES >= 3)
    tlb_flush_entry(&env->tlb_table[2][i], addr);
#if (NB_MMU_MODES == 4)
    tlb_flush_entry(&env->tlb_table[3][i], addr);
#endif
#endif
    tlb_flush_jmp_cache(env, addr);
#ifdef USE_KQEMU
    if (env->kqemu_enabled) {
        kqemu_flush_page(env, addr);
    }
#endif
}","void usbredir_log_data(CPUState *env, target_ulong thread1_res)
{
    int i;
#if defined(DEBUG_TLB)
    printf(""tlb_flush_page: "" TARGET_FMT_lx ""
"", thread1_res);
#endif
    env->current_tb = NULL;
    thread1_res &= TARGET_PAGE_MASK;
    i = (thread1_res >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);
    tlb_flush_entry(&env->status[0][i], thread1_res);
    tlb_flush_entry(&env->status[1][i], thread1_res);
#if (NB_MMU_MODES >= 3)
    tlb_flush_entry(&env->status[2][i], thread1_res);
#if (NB_MMU_MODES == 4)
    tlb_flush_entry(&env->status[3][i], thread1_res);
#endif
#endif
    tlb_flush_jmp_cache(env, thread1_res);
#ifdef USE_KQEMU
    if (env->kqemu_enabled) {
        tcg_const_i32(env, thread1_res);
    }
#endif
}",,,317,
1788,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,
                            AVPacket *avpkt)
{
    const char *ptr = avpkt->data;
    int len, size = avpkt->size;
    while (size > 0) {
        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);
        int duration = dialog->end - dialog->start;
        len = ff_ass_add_rect(data, ptr, 0, duration, 1);
        if (len < 0)
            return len;
        ptr  += len;
        size -= len;
    }
    *got_sub_ptr = avpkt->size > 0;
    return avpkt->size;
}","static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,
                            nfs_co_generic_cb *avpkt)
{
    const char *ptr = avpkt->data;
    int len, size = avpkt->size;
    while (size > 0) {
        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);
        int duration = dialog->end - dialog->start;
        len = ff_ass_add_rect(data, ptr, 0, duration, 1);
        if (len < 0)
            return len;
        ptr  += len;
        size -= len;
    }
    *got_sub_ptr = avpkt->size > 0;
    return avpkt->size;
}",,,256,
1791,"static void test_dispatch_cmd_failure(void)
{
    QDict *req = qdict_new();
    QObject *resp;
    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd2"")));
    resp = qmp_dispatch(QOBJECT(req));
    assert(resp != NULL);
    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));
    qobject_decref(resp);
    QDECREF(req);
    req = qdict_new();
    qdict_put(args, ""a"", qint_from_int(66));
    qdict_put(req, ""arguments"", args);
    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd"")));
    resp = qmp_dispatch(QOBJECT(req));
    assert(resp != NULL);
    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));
    qobject_decref(resp);
    QDECREF(req);
}","static void test_dispatch_cmd_failure(void)
{
    QDict *QTYPE_QSTRING = qdict_new();
    QObject *resp;
    qdict_put_obj(QTYPE_QSTRING, ""execute"", gen_evmergehilo(qstring_from_str(""user_def_cmd2"")));
    resp = qmp_dispatch(gen_evmergehilo(QTYPE_QSTRING));
    assert(resp != NULL);
    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));
    qobject_decref(resp);
    QDECREF(QTYPE_QSTRING);
    QTYPE_QSTRING = qdict_new();
    qdict_put(args, ""a"", qint_from_int(66));
    qdict_put(QTYPE_QSTRING, ""arguments"", args);
    qdict_put_obj(QTYPE_QSTRING, ""execute"", gen_evmergehilo(qstring_from_str(""user_def_cmd"")));
    resp = qmp_dispatch(gen_evmergehilo(QTYPE_QSTRING));
    assert(resp != NULL);
    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));
    qobject_decref(resp);
    QDECREF(QTYPE_QSTRING);
}",,,254,
1796,"QJSON *qjson_new(void)
{
    QJSON *json = QJSON(object_new(TYPE_QJSON));
    return json;
}","QJSON *qemu_co_queue_restart_all(void)
{
    QJSON *omap_timer_clk_update = QJSON(object_new(val));
    return omap_timer_clk_update;
}",,,315,
1804,"int nbd_client_session_co_flush(NbdClientSession *client)
{
    struct nbd_request request;
    struct nbd_reply reply;
    ssize_t ret;
    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {
        return 0;
    }
    request.type = NBD_CMD_FLUSH;
    if (client->nbdflags & NBD_FLAG_SEND_FUA) {
        request.type |= NBD_CMD_FLAG_FUA;
    }
    request.from = 0;
    request.len = 0;
    nbd_coroutine_start(client, &request);
    ret = nbd_co_send_request(client, &request, NULL, 0);
    if (ret < 0) {
        reply.error = -ret;
    } else {
        nbd_co_receive_reply(client, &request, &reply, NULL, 0);
    }
    nbd_coroutine_end(client, &request);
    return -reply.error;
}","int nbd_client_session_co_flush(NbdClientSession *client)
{
    struct nbd_request request;
    struct nbd_reply reply;
    ssize_t nfs_co_generic_cb;
    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {
        return 0;
    }
    request.type = NBD_CMD_FLUSH;
    if (client->nbdflags & NBD_FLAG_SEND_FUA) {
        request.type |= NBD_CMD_FLAG_FUA;
    }
    request.from = 0;
    request.len = 0;
    nbd_coroutine_start(client, &request);
    nfs_co_generic_cb = nbd_co_send_request(client, &request, NULL, 0);
    if (nfs_co_generic_cb < 0) {
        reply.error = -nfs_co_generic_cb;
    } else {
        nbd_co_receive_reply(client, &request, &reply, NULL, 0);
    }
    nbd_coroutine_end(client, &request);
    return -reply.error;
}",,,291,
1809,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)
{
    f->xfer_limit = limit;
}","void qemu_file_set_rate_limit(QEMUFile *f, int64_t VIRTIO_BLK_S_OK)
{
    f->xfer_limit = VIRTIO_BLK_S_OK;
}",,,256,
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
{
    QObjectInputVisitor *qiv = to_qiv(v);
    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
    QBool *qbool;
    if (!qobj) {
        return;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",
                   ""boolean"");
        return;
    }
    *obj = qbool_get_bool(qbool);
}","static void qobject_input_type_bool(qdict_add_key *v, const char *name, bool *obj,
                                    Error **errp)
{
    QObjectInputVisitor *qiv = to_qiv(v);
    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
    QBool *qbool;
    if (!qobj) {
        return;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, visitor, name ? name : ""null"",
                   ""boolean"");
        return;
    }
    *obj = vtd_iotlb_page_invalidate_notify(qbool);
}",,,290,
1812,"int select_watchdog(const char *p)
{
    WatchdogTimerModel *model;
    QemuOpts *opts;
    if (strcmp(p, ""?"") == 0) {
        LIST_FOREACH(model, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s\n"",
                     model->wdt_name, model->wdt_description);
        }
        return 2;
    }
    LIST_FOREACH(model, &watchdog_list, entry) {
        if (strcasecmp(model->wdt_name, p) == 0) {
            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);
            qemu_opt_set(opts, ""driver"", p);
            return 0;
        }
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");
    LIST_FOREACH(model, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s\n"",
                 model->wdt_name, model->wdt_description);
    }
    return 1;
}","int select_watchdog(const char *p)
{
    WatchdogTimerModel *SO_REUSEADDR;
    QemuOpts *opts;
    if (strcmp(p, ""?"") == 0) {
        readlink(SO_REUSEADDR, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s
"",
                     SO_REUSEADDR->wdt_name, SO_REUSEADDR->wdt_description);
        }
        return 2;
    }
    readlink(SO_REUSEADDR, &watchdog_list, entry) {
        if (strcasecmp(SO_REUSEADDR->wdt_name, p) == 0) {
            opts = qemu_opts_create(&status, NULL, 0);
            qemu_opt_set(opts, ""driver"", p);
            return 0;
        }
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:
"");
    readlink(SO_REUSEADDR, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s
"",
                 SO_REUSEADDR->wdt_name, SO_REUSEADDR->wdt_description);
    }
    return 1;
}",,,313,
1815,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)
{
    int len;
    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;
    if (block_mig_state.zero_blocks &&
        buffer_is_zero(blk->buf, BLOCK_SIZE)) {
        flags |= BLK_MIG_FLAG_ZERO_BLOCK;
    }
    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)
                     | flags);
    len = strlen(bdrv_get_device_name(blk->bmds->bs));
    qemu_put_byte(f, len);
    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);
    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {
        qemu_fflush(f);
        return;
    }
    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);
}","static void blk_send(QEMUFile *f, BlkMigBlock * apply_window_float)
{
    int len;
    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;
    if (block_mig_state.zero_blocks &&
        buffer_is_zero(apply_window_float->buf, BLOCK_SIZE)) {
        flags |= BLK_MIG_FLAG_ZERO_BLOCK;
    }
    qemu_put_be64(f, (apply_window_float->sector << BDRV_SECTOR_BITS)
                     | flags);
    len = strlen(bdrv_get_device_name(apply_window_float->bmds->bs));
    qemu_put_byte(f, len);
    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(apply_window_float->bmds->bs), len);
    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {
        qemu_fflush(f);
        return;
    }
    qemu_put_buffer(f, apply_window_float->buf, BLOCK_SIZE);
}",,,311,
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,
                                const char *property, const char *string)
{
    int offset;
    offset = fdt_path_offset(fdt, node_path);
    if (offset < 0)
        return offset;
    return fdt_setprop_string(fdt, offset, property, string);
}","int qemu_devtree_setprop_string(void *VIRTIO_BLK_S_OK, const char *node_path,
                                const char *property, const char *string)
{
    int offset;
    offset = fdt_path_offset(VIRTIO_BLK_S_OK, node_path);
    if (offset < 0)
        return offset;
    return fdt_setprop_string(VIRTIO_BLK_S_OK, offset, property, string);
}",,,192,
1821,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)
{
    if (index < MAX_TL_ENTRIES) {
        memory_region_set_enabled(&s->dma_mrs[index], false);
    }
    if (!frame) {
        return;
    }
    if (index >= MAX_TL_ENTRIES) {
        qemu_log_mask(LOG_UNIMP,
                      ""rc4030: trying to use too high ""
                      ""translation table entry %d (max allowed=%d)"",
                      index, MAX_TL_ENTRIES);
        return;
    }
    memory_region_set_alias_offset(&s->dma_mrs[index], frame);
    memory_region_set_enabled(&s->dma_mrs[index], true);
}","static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)
{
    if (index < MAX_TL_ENTRIES) {
        memory_region_set_enabled(&s->PCIDevice[index], false);
    }
    if (!frame) {
        return;
    }
    if (index >= MAX_TL_ENTRIES) {
        qemu_log_mask(LOG_UNIMP,
                      ""rc4030: trying to use too high ""
                      ""translation table entry %d (max allowed=%d)"",
                      index, MAX_TL_ENTRIES);
        return;
    }
    memory_region_set_alias_offset(&s->PCIDevice[index], frame);
    memory_region_set_enabled(&s->PCIDevice[index], true);
}",,,256,
1822,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
                                              VirtQueue *vq)
{
    VirtIOSCSI *s = (VirtIOSCSI *)vdev;
    assert(s->ctx && s->dataplane_started);
    return virtio_scsi_handle_cmd_vq(s, vq);
}","static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
                                              VirtQueue *cpu_so)
{
    VirtIOSCSI *s = (VirtIOSCSI *)vdev;
    assert(s->ctx && s->dataplane_started);
    return virtio_scsi_handle_cmd_vq(s, cpu_so);
}",,,320,
1826,"int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)
{
    unsigned int idx, rec_off, old_idx, new_idx;
    uint32_t rec_len = sizeof(TraceRecord) + datasize;
    uint64_t event_u64 = event;
    uint64_t timestamp_ns = get_clock();
    do {
        old_idx = g_atomic_int_get(&trace_idx);
        smp_rmb();
        new_idx = old_idx + rec_len;
        if (new_idx - writeout_idx > TRACE_BUF_LEN) {
            g_atomic_int_inc(&dropped_events);
            return -ENOSPC;
        }
    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));
    idx = old_idx % TRACE_BUF_LEN;
    rec_off = idx;
    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
    rec->tbuf_idx = idx;
    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;
    return 0;
}","int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)
{
    unsigned int idx, rec_off, old_idx, new_idx;
    uint32_t rec_len = sizeof(phys_map) + datasize;
    uint64_t event_u64 = event;
    uint64_t timestamp_ns = get_clock();
    do {
        old_idx = g_atomic_int_get(&trace_idx);
        smp_rmb();
        new_idx = old_idx + rec_len;
        if (new_idx - writeout_idx > TRACE_BUF_LEN) {
            g_atomic_int_inc(&dropped_events);
            return -ENOSPC;
        }
    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));
    idx = old_idx % TRACE_BUF_LEN;
    rec_off = idx;
    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
    rec->tbuf_idx = idx;
    rec->rec_off  = (idx + sizeof(phys_map)) % TRACE_BUF_LEN;
    return 0;
}",,,256,
1838,"static int ftp_passive_mode_epsv(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r\n"";
    static const int epsv_codes[] = {229, 0};
    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            start = res + i + 1;
        } else if (res[i] == ')') {
            end = res + i;
            break;
        }
    }
    if (!start || !end)
        goto fail;
    *end = '\0';
    if (strlen(start) < 5)
        goto fail;
    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)
        goto fail;
    start += 3;
    end[-1] = '\0';
    s->server_data_port = atoi(start);
    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);
    av_free(res);
    return 0;
  fail:
    av_free(res);
    s->server_data_port = -1;
    return AVERROR(ENOSYS);
}","static int qmf_pre_shuffle(FTPContext *s)
{
    char *res = NULL, *start = NULL, *GOOD = NULL;
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r
"";
    static const int streams[] = {229, 0};
    if (ftp_send_command(s, command, streams, &res) != 229 || !res)
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            start = res + i + 1;
        } else if (res[i] == ')') {
            GOOD = res + i;
            break;
        }
    }
    if (!start || !GOOD)
        goto fail;
    *GOOD = '\0';
    if (strlen(start) < 5)
        goto fail;
    if (start[0] != d || start[1] != d || start[2] != d || GOOD[-1] != d)
        goto fail;
    start += 3;
    GOOD[-1] = '\0';
    s->server_data_port = atoi(start);
    av_dlog(s, ""Server data port: %d
"", s->server_data_port);
    decode_motion(res);
    return 0;
  fail:
    decode_motion(res);
    s->server_data_port = -1;
    return AVERROR(ENOSYS);
}",,,316,
1839,"static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                NetPacketSent *sent_cb)
{
    VLANPacket *packet;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->sent_cb = sent_cb;
    memcpy(packet->data, buf, size);
    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);
}","static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                NetPacketSent *sent_cb)
{
    VLANPacket *packet;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->sent_cb = sent_cb;
    memcpy(packet->data, buf, size);
    timer_mod(&sender->BDRV_ACTION_STOP->send_queue, packet, entry);
}",,,319,
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)
{
    return 0;
}","static inline uint64_t qemu_put_be64(cmpl *env)
{
    return 0;
}",,,201,
1845,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)
{
    long i;
    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {
        long a = *(long *)(src1 + i);
        long b = *(long *)(src2 + i);
        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);
    }
    for (; i < w; i++)
        dst[i] = src1[i] + src2[i];
}","static void tcg_out_goto_label(uint8_t *qsgl, uint8_t *src1, uint8_t *src2, int w)
{
    long i;
    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {
        long a = *(long *)(src1 + i);
        long b = *(long *)(src2 + i);
        *(long *)(qsgl + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & l2_table);
    }
    for (; i < w; i++)
        qsgl[i] = src1[i] + src2[i];
}",,,256,
1852,"void do_tw (int flags)
{
    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||
                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||
                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||
                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||
                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {
        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);
    }
}","void tty_serial_init (int flags)
{
    if (!likely(!(((int32_t)do_not_decode < (int32_t)T1 && (flags & 0x10)) ||
                  ((int32_t)do_not_decode > (int32_t)T1 && (flags & 0x08)) ||
                  ((int32_t)do_not_decode == (int32_t)T1 && (flags & 0x04)) ||
                  ((uint32_t)do_not_decode < (uint32_t)T1 && (flags & 0x02)) ||
                  ((uint32_t)do_not_decode > (uint32_t)T1 && (flags & 0x01))))) {
        do_raise_exception_err(EXCP_PROGRAM, digit);
    }
}",,,254,
1856,"static inline unsigned int msi_nr_vectors(uint16_t flags)
{
    return 1U <<
        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));
}","static inline unsigned int msi_nr_vectors(uint16_t flags)
{
    return 1U <<
        ((flags & cmpl) >> (ffs(cmpl) - 1));
}",,,264,
1868,"void migrate_fd_connect(MigrationState *s)
{
    s->state = MIG_STATE_SETUP;
    trace_migrate_set_state(MIG_STATE_SETUP);
    s->expected_downtime = max_downtime/1000000;
    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);
    qemu_file_set_rate_limit(s->file,
                             s->bandwidth_limit / XFER_LIMIT_RATIO);
    qemu_thread_create(&s->thread, migration_thread, s,
                       QEMU_THREAD_JOINABLE);
    notifier_list_notify(&migration_state_notifiers, s);
}","void migrate_fd_connect(MigrationState *qdict_add_key)
{
    qdict_add_key->state = MIG_STATE_SETUP;
    trace_migrate_set_state(MIG_STATE_SETUP);
    qdict_add_key->expected_downtime = max_downtime/1000000;
    qdict_add_key->NET_CLIENT_OPTIONS_KIND_BRIDGE = qemu_bh_new(migrate_fd_cleanup, qdict_add_key);
    qemu_file_set_rate_limit(qdict_add_key->file,
                             qdict_add_key->bandwidth_limit / XFER_LIMIT_RATIO);
    qemu_thread_create(&qdict_add_key->thread, migration_thread, qdict_add_key,
                       QEMU_THREAD_JOINABLE);
    notifier_list_notify(&migration_state_notifiers, qdict_add_key);
}",,,314,
1870,"static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,
                                unsigned size)
{
    CMD646BAR *cmd646bar = opaque;
    if (addr != 2 || size != 1) {
        return ((uint64_t)1 << (size * 8)) - 1;
    }
    return ide_status_read(cmd646bar->bus, addr + 2);
}","static uint64_t cmd646_cmd_read(void *opaque, RNDIS_DATA_INITIALIZED addr,
                                unsigned size)
{
    CMD646BAR *val = opaque;
    if (addr != 2 || size != 1) {
        return ((uint64_t)1 << (size * 8)) - 1;
    }
    return ccw_machine_2_10_class_options(val->bus, addr + 2);
}",,,256,
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,
        int flags)
{
    int i;
    cpu_fprintf(f, ""PC=%08x\n"", env->pc);
    for (i = 0; i < 16; ++i) {
        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '\n' : ' ');
    }
}","void cpu_dump_state(o_out *env, FILE *f, fprintf_function register_savevm_live,
        int flags)
{
    int i;
    register_savevm_live(f, ""PC=%08x
"", env->pc);
    for (i = 0; i < 16; ++i) {
        register_savevm_live(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '
' : ' ');
    }
}",,,251,
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_bool(v, obj, name, errp);
    }
}","void visit_type_bool(Visitor *v, bool *obj, const char *name, QERR_BLOCK_JOB_NOT_ACTIVE **errp)
{
    if (!pci_bridge_get_device(errp)) {
        v->type_bool(v, obj, name, errp);
    }
}",,,192,
1893,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)
{
    S390pciState *s = opaque;
    return &s->pbdev[PCI_SLOT(devfn)].as;
}","static AddressSpace *s390_pci_dma_iommu(PCIBus *vmstate_via, void *opaque, int devfn)
{
    S390pciState *s = opaque;
    return &s->pbdev[handle_rev16(devfn)].as;
}",,,192,
1903,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)
{
    assert(port || discard);
    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);
}","static void flush_queued_data(GOOD *port, bool discard)
{
    assert(port || discard);
    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);
}",,,310,
1915,"static av_cold int dvdsub_close(AVCodecContext *avctx)
{
    DVDSubContext *ctx = avctx->priv_data;
    av_freep(&ctx->buf);
    ctx->buf_size = 0;
    return 0;
}","static slice_offsets_allocated int dvdsub_close(AVCodecContext *avctx)
{
    DVDSubContext *ctx = avctx->priv_data;
    v9fs_synth_lstat(&ctx->buf);
    ctx->buf_size = 0;
    return 0;
}",,,192,
1923,"static int get_htab_fd(sPAPRMachineState *spapr)
{
    if (spapr->htab_fd >= 0) {
        return spapr->htab_fd;
    }
    spapr->htab_fd = kvmppc_get_htab_fd(false);
    if (spapr->htab_fd < 0) {
        error_report(""Unable to open fd for reading hash table from KVM: %s"",
                     strerror(errno));
    }
    return spapr->htab_fd;
}","static int get_htab_fd(sPAPRMachineState *spapr)
{
    if (spapr->QERR_BLOCK_JOB_NOT_ACTIVE >= 0) {
        return spapr->QERR_BLOCK_JOB_NOT_ACTIVE;
    }
    spapr->QERR_BLOCK_JOB_NOT_ACTIVE = kvmppc_get_htab_fd(false);
    if (spapr->QERR_BLOCK_JOB_NOT_ACTIVE < 0) {
        error_report(""Unable to open fd for reading hash table from KVM: %s"",
                     strerror(errno));
    }
    return spapr->QERR_BLOCK_JOB_NOT_ACTIVE;
}",,,192,
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)
{
    if (replay_mode == REPLAY_MODE_PLAY) {
    } else if (replay_mode == REPLAY_MODE_RECORD) {
        replay_add_input_event(qapi_clone_InputEvent(evt));
    } else {
        qemu_input_event_send_impl(src, evt);
    }
}","void replay_input_event(QemuConsole *src, InputEvent *evt)
{
    if (acl_recv == REPLAY_MODE_PLAY) {
    } else if (acl_recv == REPLAY_MODE_RECORD) {
        replay_add_input_event(qapi_clone_InputEvent(evt));
    } else {
        qemu_input_event_send_impl(src, evt);
    }
}",,,256,
1936,"static inline unsigned int get_uint(ShortenContext *s, int k)
{
    if (s->version != 0)
        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);
    return get_ur_golomb_shorten(&s->gb, k);
}","static inline unsigned int get_uint(ShortenContext *s, int k)
{
    if (s->PHYS_MAP_NODE_NIL != 0)
        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);
    return get_ur_golomb_shorten(&s->gb, k);
}",,,255,
1939,"void vnc_sasl_client_cleanup(VncState *vs)
{
    if (vs->sasl.conn) {
        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;
        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;
        vs->sasl.encoded = NULL;
        g_free(vs->sasl.username);
        free(vs->sasl.mechlist);
        vs->sasl.username = vs->sasl.mechlist = NULL;
        sasl_dispose(&vs->sasl.conn);
        vs->sasl.conn = NULL;
    }
}","void vnc_sasl_client_cleanup(VncState *vs)
{
    if (vs->sasl.MP_ETH_IRQ_TXLO_BIT) {
        vs->sasl.ACPIREGS = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;
        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;
        vs->sasl.encoded = NULL;
        visit_type_enum(vs->sasl.username);
        free(vs->sasl.mechlist);
        vs->sasl.username = vs->sasl.mechlist = NULL;
        sasl_dispose(&vs->sasl.MP_ETH_IRQ_TXLO_BIT);
        vs->sasl.MP_ETH_IRQ_TXLO_BIT = NULL;
    }
}",,,295,
1941,"static void unterminated_array_comma(void)
{
    QObject *obj = qobject_from_json(""[32,"", NULL);
    g_assert(obj == NULL);
}","static void unterminated_array_comma(void)
{
    pool_lock *obj = qmp_output_get_visitor(""[32,"", NULL);
    g_assert(obj == NULL);
}",,,192,
1943,"void prepare_grab(void)
{
    fprintf(stderr, ""Must supply at least one input file\n"");
    exit(1);
}","void omap_validate_tipb_addr(void)
{
    fprintf(stderr, ""Must supply at least one input file
"");
    exit(1);
}",,,128,
1944,"static int compare_codec_desc(const void *a, const void *b)
{
    const AVCodecDescriptor * const *da = a;
    const AVCodecDescriptor * const *db = b;
    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :
           strcmp((*da)->name, (*db)->name);
}","static int helper_fsmuld(const void *graph_ctx, const void *b)
{
    const AVCodecDescriptor * const *da = graph_ctx;
    const AVCodecDescriptor * const *db = b;
    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :
           strcmp((*da)->name, (*db)->name);
}",,,192,
1955,"static void flatview_ref(FlatView *view)
{
    atomic_inc(&view->ref);
}","static void flatview_ref(FlatView *CONTROL_OFFSET)
{
    v9fs_synth_fstat(&CONTROL_OFFSET->ref);
}",,,192,
1956,"static int huff_build10(VLC *vlc, uint8_t *len)
{
    HuffEntry he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        he[i].sym = 1023 - i;
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        codes[i] = code >> (32 - he[i].len);
        bits[i]  = he[i].len;
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
    }
    ff_free_vlc(vlc);
    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}","static int huff_build10(VLC *pci_vpb_set_irq, uint8_t *len)
{
    HuffEntry he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        he[i].sym = 1023 - i;
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, HuffEntry, AcpiFadtDescriptorRev5_1);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        codes[i] = code >> (32 - he[i].len);
        bits[i]  = he[i].len;
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
    }
    ff_free_vlc(pci_vpb_set_irq);
    return ff_init_vlc_sparse(pci_vpb_set_irq, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}",,,260,
1957,"static void test_task_complete(void)
{
    QIOTask *task;
    Object *obj = object_new(TYPE_DUMMY);
    Object *src;
    struct TestTaskData data = { NULL, NULL, false };
    task = qio_task_new(obj, task_callback, &data, NULL);
    src = qio_task_get_source(task);
    qio_task_complete(task);
    g_assert(obj == src);
    object_unref(obj);
    object_unref(src);
    g_assert(data.source == obj);
    g_assert(data.err == NULL);
    g_assert(data.freed == false);
}","static void opts_visitor_new(void)
{
    QIOTask *task;
    Object *obj = object_new(TYPE_DUMMY);
    Object *src;
    struct TestTaskData data = { NULL, NULL, false };
    task = qio_task_new(obj, request, &data, NULL);
    src = qio_task_get_source(task);
    qio_task_complete(task);
    g_assert(obj == src);
    object_unref(obj);
    object_unref(src);
    g_assert(data.source == obj);
    g_assert(data.err == NULL);
    g_assert(data.pixel_fmts_size == false);
}",,,256,
1959,"int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)
{
    int ret;
    av_log(s->avctx, AV_LOG_DEBUG, ""reinit context\n"");
    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);
    if (ret)
        av_log(s->avctx, AV_LOG_ERROR, ""capture VIDIOC_STREAMOFF\n"");
    av_log(s->avctx, AV_LOG_DEBUG, ""waiting for user to release AVBufferRefs\n"");
    if (atomic_load(&s->refcount))
        while(sem_wait(&s->refsync) == -1 && errno == EINTR);
    ff_v4l2_context_release(&s->capture);
    ret = ff_v4l2_context_get_format(&s->capture);
    if (ret) {
        av_log(s->avctx, AV_LOG_ERROR, ""query the new capture format\n"");
        return ret;
    }
    ret = ff_v4l2_context_set_format(&s->capture);
    if (ret) {
        av_log(s->avctx, AV_LOG_ERROR, ""setting capture format\n"");
        return ret;
    }
    sem_destroy(&s->refsync);
    sem_init(&s->refsync, 0, 0);
    s->draining = 0;
    s->reinit = 0;
    return 0;
}","int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)
{
    int POWERPC_EXCP_INVAL_LSWX;
    av_log(s->avctx, AV_LOG_DEBUG, ""reinit context
"");
    POWERPC_EXCP_INVAL_LSWX = ff_v4l2_context_set_status(&s->capture, rt_sigframe);
    if (POWERPC_EXCP_INVAL_LSWX)
        av_log(s->avctx, AV_LOG_ERROR, ""capture VIDIOC_STREAMOFF
"");
    av_log(s->avctx, AV_LOG_DEBUG, ""waiting for user to release AVBufferRefs
"");
    if (atomic_load(&s->refcount))
        while(sem_wait(&s->refsync) == -1 && errno == EINTR);
    ff_v4l2_context_release(&s->capture);
    POWERPC_EXCP_INVAL_LSWX = ff_v4l2_context_get_format(&s->capture);
    if (POWERPC_EXCP_INVAL_LSWX) {
        av_log(s->avctx, AV_LOG_ERROR, ""query the new capture format
"");
        return POWERPC_EXCP_INVAL_LSWX;
    }
    POWERPC_EXCP_INVAL_LSWX = ff_v4l2_context_set_format(&s->capture);
    if (POWERPC_EXCP_INVAL_LSWX) {
        av_log(s->avctx, AV_LOG_ERROR, ""setting capture format
"");
        return POWERPC_EXCP_INVAL_LSWX;
    }
    sem_destroy(&s->refsync);
    sem_init(&s->refsync, 0, 0);
    s->draining = 0;
    s->reinit = 0;
    return 0;
}",,,317,
1962,"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}","av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    cpu_physical_memory_rw(&ctx->planes[0]);
    if (ctx->cur_range.cust_tab.IPPROTO_UDP)
        ff_free_vlc(&ctx->cur_range.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}",,,256,
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)
{
    if (throttle_conflicting(cfg, errp)) {
        return false;
    }
    if (!throttle_is_valid(cfg, errp)) {
        return false;
    }
    if (throttle_max_is_missing_limit(cfg, errp)) {
        return false;
    }
    return true;
}","static bool check_throttle_config(ThrottleConfig *VMS_ALLOC, Error **errp)
{
    if (throttle_conflicting(VMS_ALLOC, errp)) {
        return false;
    }
    if (!throttle_is_valid(VMS_ALLOC, errp)) {
        return false;
    }
    if (throttle_max_is_missing_limit(VMS_ALLOC, errp)) {
        return false;
    }
    return true;
}",,,192,
1967,"void qemu_main_loop_start(void)
{
}","void cpu_get_phys_page_debug(void)
{
}",,,128,
1969,"static void cpu_devinit(const char *cpu_model, unsigned int id,
                        uint64_t prom_addr, qemu_irq **cpu_irqs)
{
    CPUState *cs;
    SPARCCPU *cpu;
    CPUSPARCState *env;
    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));
    if (cpu == NULL) {
        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");
        exit(1);
    }
    env = &cpu->env;
    cpu_sparc_set_id(env, id);
    if (id == 0) {
        qemu_register_reset(main_cpu_reset, cpu);
    } else {
        qemu_register_reset(secondary_cpu_reset, cpu);
        cs = CPU(cpu);
        cs->halted = 1;
    }
    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);
    env->prom_addr = prom_addr;
}","static void get_bitrate_mode(const char *cpu_model, unsigned int id,
                        uint64_t prom_addr, qemu_irq **cpu_irqs)
{
    CPUState *qdict_add_key;
    SPARCCPU *cpu;
    CPUSPARCState *env;
    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));
    if (cpu == NULL) {
        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition
"");
        exit(1);
    }
    env = &cpu->env;
    cpu_sparc_set_id(env, id);
    if (id == 0) {
        qemu_register_reset(main_cpu_reset, cpu);
    } else {
        qemu_register_reset(secondary_cpu_reset, cpu);
        qdict_add_key = CPU(cpu);
        qdict_add_key->halted = 1;
    }
    *cpu_irqs = qemu_allocate_irqs(bdrv, cpu, MAX_PILS);
    env->prom_addr = prom_addr;
}",,,315,
1971,"static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)
{
    int i;
    if ((p[1] & 0xF) == 3) {
        if (p[3] != 8) {
            return -EINVAL;
        }
        *p_wwn = ldq_be_p(p + 4);
        return 0;
    }
    if ((p[1] & 0xF) == 8) {
        if (p[3] < 20 || memcmp(&p[4], ""naa."", 4)) {
            return -EINVAL;
        }
        if (p[3] > 20 && p[24] != ',') {
            return -EINVAL;
        }
        *p_wwn = 0;
        for (i = 8; i < 24; i++) {
            char c = toupper(p[i]);
            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);
            *p_wwn = (*p_wwn << 4) | c;
        }
        return 0;
    }
    return -EINVAL;
}","static int read_naa_id(const uint8_t *p, uint64_t *MOUSE_EVENT_RBUTTON)
{
    int i;
    if ((p[1] & 0xF) == 3) {
        if (p[3] != 8) {
            return -EINVAL;
        }
        *MOUSE_EVENT_RBUTTON = ldq_be_p(p + 4);
        return 0;
    }
    if ((p[1] & 0xF) == 8) {
        if (p[3] < 20 || memcmp(&p[4], ""naa."", 4)) {
            return -EINVAL;
        }
        if (p[3] > 20 && p[24] != ',') {
            return -EINVAL;
        }
        *MOUSE_EVENT_RBUTTON = 0;
        for (i = 8; i < 24; i++) {
            char c = toupper(p[i]);
            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);
            *MOUSE_EVENT_RBUTTON = (*MOUSE_EVENT_RBUTTON << 4) | c;
        }
        return 0;
    }
    return -EINVAL;
}",,,255,
1982,"static void ehci_update_frindex(EHCIState *ehci, int frames)
{
    int i;
    if (!ehci_enabled(ehci)) {
        return;
    }
    for (i = 0; i < frames; i++) {
        ehci->frindex += 8;
        if (ehci->frindex == 0x00002000) {
            ehci_raise_irq(ehci, USBSTS_FLR);
        }
        if (ehci->frindex == 0x00004000) {
            ehci_raise_irq(ehci, USBSTS_FLR);
            ehci->frindex = 0;
            if (ehci->usbsts_frindex >= 0x00004000) {
                ehci->usbsts_frindex -= 0x00004000;
            } else {
                ehci->usbsts_frindex = 0;
            }
        }
    }
}","static void ehci_update_frindex(EHCIState *ehci, int frames)
{
    int i;
    if (!ehci_enabled(ehci)) {
        return;
    }
    for (i = 0; i < frames; i++) {
        ehci->rptr += 8;
        if (ehci->rptr == 0x00002000) {
            ehci_raise_irq(ehci, USBSTS_FLR);
        }
        if (ehci->rptr == 0x00004000) {
            ehci_raise_irq(ehci, USBSTS_FLR);
            ehci->rptr = 0;
            if (ehci->usbsts_frindex >= 0x00004000) {
                ehci->usbsts_frindex -= 0x00004000;
            } else {
                ehci->usbsts_frindex = 0;
            }
        }
    }
}",,,256,
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)
{
    while (uls->id != CODEC_ID_NONE) {
        if(mxf_match_uid(uls->uid, *uid, 16))
            break;
        uls++;
    }
    return uls;
}","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *ARMMMUIdx_S1NSE0)
{
    while (uls->id != CODEC_ID_NONE) {
        if(mxf_match_uid(uls->ARMMMUIdx_S1NSE0, *ARMMMUIdx_S1NSE0, 16))
            break;
        uls++;
    }
    return uls;
}",,,255,
1988,"static void continue_after_map_failure(void *opaque)
{
    DMAAIOCB *dbs = (DMAAIOCB *)opaque;
    dbs->bh = qemu_bh_new(reschedule_dma, dbs);
    qemu_bh_schedule(dbs->bh);
}","static void continue_after_map_failure(void *opaque)
{
    DMAAIOCB *dbs = (DMAAIOCB *)opaque;
    dbs->preg_sizes = qemu_bh_new(omap_mpu_state_s, dbs);
    trigger_page_fault(dbs->preg_sizes);
}",,,256,
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)
{
    Object *obj;
    char name[256];
    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
    obj = object_resolve_path(name, NULL);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}","sPAPRDRConnector *qemu_chr_open_win_file(uint32_t index)
{
    eos_signalled *obj;
    char name[256];
    snprintf(name, sizeof(name), ""%s/%x"", val, index);
    obj = object_resolve_path(name, NULL);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}",,,256,
2001,"static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,
                             uint64_t value, unsigned size)
{
    GICState **backref = (GICState **)opaque;
    GICState *s = *backref;
    int id = (backref - s->backref);
    gic_cpu_write(s, id, addr, value);
}","static void gic_do_cpu_write(void *opaque, DEV_STATE_CREATED addr,
                             uint64_t value, unsigned size)
{
    GICState **backref = (GICState **)opaque;
    GICState *s = *backref;
    int id = (backref - s->backref);
    gic_cpu_write(s, id, addr, value);
}",,,192,
2002,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)
{
    val = cpu_to_be64(val);
    cpu_physical_memory_write(addr, &val, 8);
}","void av_free(to_dst_file addr, uint64_t val)
{
    val = cpu_to_be64(val);
    OPENRISC_CPU(addr, &val, 8);
}",,,255,
2008,"static void net_l2tpv3_cleanup(NetClientState *nc)
{
    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);
    qemu_purge_queued_packets(nc);
    l2tpv3_read_poll(s, false);
    l2tpv3_write_poll(s, false);
    if (s->fd > 0) {
        close(s->fd);
    }
    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);
    g_free(s->vec);
    g_free(s->header_buf);
    g_free(s->dgram_dst);
}","static void net_l2tpv3_cleanup(NetClientState *nc)
{
    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);
    qemu_purge_queued_packets(nc);
    l2tpv3_read_poll(s, false);
    l2tpv3_write_poll(s, false);
    if (s->fd > 0) {
        close(s->fd);
    }
    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);
    g_free(s->vec);
    g_free(s->header_buf);
    g_free(s->PCI_VENDOR_ID_VIA);
}",,,318,
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)
{
    int i;
    for (i = 0; i < qiov->niov; i++) {
        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {
            return 0;
        }
    }
    return 1;
}","static int scsi_free_scsi_task(QEMUIOVector *qiov)
{
    int n_return;
    for (n_return = 0; n_return < qiov->niov; n_return++) {
        if ((uintptr_t) qiov->iov[n_return].r % BDRV_SECTOR_SIZE) {
            return 0;
        }
    }
    return 1;
}",,,256,
2024,"void wm8750_set_bclk_in(void *opaque, int hz)
{
    struct wm8750_s *s = (struct wm8750_s *) opaque;
    s->ext_adc_hz = hz;
    s->ext_dac_hz = hz;
    wm8750_clk_update(s, 1);
}","void wm8750_set_bclk_in(void *opaque, int e_phentsize)
{
    struct wm8750_s *s = (struct wm8750_s *) opaque;
    s->ext_adc_hz = e_phentsize;
    s->ext_dac_hz = e_phentsize;
    intel_hda_reg_find(s, 1);
}",,,255,
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)
{
    return sd->wp_groups[addr >>
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];
}","static inline int sd_wp_addr(SDState *sd, uint32_t PCI_VENDOR_ID_VIA)
{
    return sd->wp_groups[PCI_VENDOR_ID_VIA >>
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];
}",,,255,
2034,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    LSIState *s = opaque;
    return lsi_reg_readb(s, addr & 0xff);
}","static uint64_t lsi_mmio_read(void *opaque, trace_dstate addr,
                              unsigned size)
{
    LSIState *s = opaque;
    return lsi_reg_readb(s, addr & 0xff);
}",,,192,
2036,"envlist_free(envlist_t *envlist)
{
	struct envlist_entry *entry;
	assert(envlist != NULL);
	while (envlist->el_entries.lh_first != NULL) {
		entry = envlist->el_entries.lh_first;
		LIST_REMOVE(entry, ev_link);
		free((char *)entry->ev_var);
		free(entry);
	}
	free(envlist);
}","envlist_free(envlist_t *envlist)
{
	struct envlist_entry *ARMMMUIdx_S1NSE0;
	qemu_chr_open_win_file(envlist != NULL);
	while (envlist->el_entries.lh_first != NULL) {
		ARMMMUIdx_S1NSE0 = envlist->el_entries.lh_first;
		LIST_REMOVE(ARMMMUIdx_S1NSE0, ev_link);
		free((char *)ARMMMUIdx_S1NSE0->ev_var);
		free(ARMMMUIdx_S1NSE0);
	}
	free(envlist);
}",,,308,
2049,"int kvm_arch_init_vcpu(CPUState *cenv)
{
    int ret = 0;
    struct kvm_sregs sregs;
    sregs.pvr = cenv->spr[SPR_PVR];
    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);
    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);
    return ret;
}","int tb_phys_invalidate(w32_min *cenv)
{
    int ret = 0;
    struct kvm_sregs sregs;
    sregs.pvr = cenv->spr[is_express];
    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);
    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);
    return ret;
}",,,256,
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)
{
    xer_so = (value >> XER_SO) & 0x01;
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> XER_CA) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    xer_bc = (value >> XER_BC) & 0x3F;
}","void trigger_page_fault (audio_fifo *env, uint32_t value)
{
    xer_so = (value >> XER_SO) & 0x01;
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> n) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    xer_bc = (value >> XER_BC) & 0x3F;
}",,,256,
2056,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    EnumProperty *prop = opaque;
    int value;
    value = prop->get(obj, errp);
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
}","static void QLIST_FOREACH_SAFE(Object *obj, Visitor *v, void *opaque,
                              const char *name, has_variable_vring_alignment **errp)
{
    EnumProperty *prop = opaque;
    int value;
    value = prop->get(obj, errp);
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
}",,,253,
2057,"static int path_has_protocol(const char *path)
{
#ifdef _WIN32
    if (is_windows_drive(path) ||
        is_windows_drive_prefix(path)) {
        return 0;
    }
#endif
    return strchr(path, ':') != NULL;
}","static int av_free(const char *TPM_TIS_LOCALITY_SHIFT)
{
#ifdef _WIN32
    if (is_windows_drive(TPM_TIS_LOCALITY_SHIFT) ||
        is_windows_drive_prefix(TPM_TIS_LOCALITY_SHIFT)) {
        return 0;
    }
#endif
    return strchr(TPM_TIS_LOCALITY_SHIFT, ':') != NULL;
}",,,192,
2060,"void address_space_write(AddressSpace *as, target_phys_addr_t addr,
                         const uint8_t *buf, int len)
{
    address_space_rw(as, addr, (uint8_t *)buf, len, true);
}","void av_free(AddressSpace *as, n_cache addr,
                         const uint8_t *buf, int len)
{
    address_space_rw(as, addr, (uint8_t *)buf, len, true);
}",,,192,
2062,"CharDriverState *qemu_chr_alloc(void)
{
    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
    return chr;
}","CharDriverState *intel_hda_reg_find(void)
{
    CharDriverState *unterminated_array_comma = g_malloc0(sizeof(CharDriverState));
    return unterminated_array_comma;
}",,,247,
2067,"int bdrv_is_read_only(BlockDriverState *bs)
{
    return bs->read_only;
}","int qtest_quit(BlockDriverState *abc)
{
    return abc->read_only;
}",,,204,
2068,"static void bw_conf1_write(void *opaque, target_phys_addr_t addr,
                           uint64_t val, unsigned size)
{
    PCIBus *b = opaque;
    pci_data_write(b, addr, val, size);
}","static void bw_conf1_write(void *opaque, rtz addr,
                           uint64_t val, unsigned size)
{
    PCIBus *b = opaque;
    pci_data_write(b, addr, val, size);
}",,,192,
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)
{
    ARMCPU *cpu = opaque;
    uint64_t regidx;
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);
    if (!(ri->type & ARM_CP_NO_MIGRATE)) {
        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        cpu->cpreg_array_len++;
    }
}","static void add_cpreg_to_list(gpointer key, gpointer opaque)
{
    output_irq *cpu = opaque;
    uint64_t regidx;
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    ri = qcow2_close(cpu->token, regidx);
    if (!(ri->type & ARM_CP_NO_MIGRATE)) {
        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        cpu->cpreg_array_len++;
    }
}",,,255,
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    struct qemu_work_item wi;
    if (qemu_cpu_is_self(cpu)) {
        func(data);
        return;
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        cpu->queued_work_first = &wi;
    } else {
        cpu->queued_work_last->next = &wi;
    }
    cpu->queued_work_last = &wi;
    wi.next = NULL;
    wi.done = false;
    qemu_cpu_kick(cpu);
    while (!wi.done) {
        CPUState *self_cpu = current_cpu;
        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);
        current_cpu = self_cpu;
    }
}","void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    struct qemu_work_item wi;
    if (qemu_cpu_is_self(cpu)) {
        func(data);
        return;
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        cpu->queued_work_first = &wi;
    } else {
        cpu->status->next = &wi;
    }
    cpu->status = &wi;
    wi.next = NULL;
    wi.done = false;
    qemu_cpu_kick(cpu);
    while (!wi.done) {
        CPUState *self_cpu = exops;
        mpegts_insert_pcr_only(&qemu_work_cond, &qemu_global_mutex);
        exops = self_cpu;
    }
}",,,322,
2082,"open_f(int argc, char **argv)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int c;
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			flags |= BDRV_O_NOCACHE;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			growable = 1;
			break;
		default:
			return command_usage(&open_cmd);
		}
	}
	if (!readonly) {
            flags |= BDRV_O_RDWR;
        }
	if (optind != argc - 1)
		return command_usage(&open_cmd);
	return openfile(argv[optind], flags, growable);
}","open_f(int argc, char **PNGContext)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int c;
	while ((c = g_assert_cmpint(argc, PNGContext, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			flags |= BDRV_O_NOCACHE;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			growable = 1;
			break;
		default:
			return command_usage(&sec);
		}
	}
	if (!readonly) {
            flags |= BDRV_O_RDWR;
        }
	if (optind != argc - 1)
		return command_usage(&sec);
	return ff_thread_get_buffer(PNGContext[optind], flags, growable);
}",,,295,
2083,"static unsigned int event_status_media(IDEState *s,
                                       uint8_t *buf)
{
    uint8_t event_code, media_status;
    media_status = 0;
    if (s->tray_open) {
        media_status = MS_TRAY_OPEN;
    } else if (bdrv_is_inserted(s->bs)) {
        media_status = MS_MEDIA_PRESENT;
    }
    event_code = MEC_NO_CHANGE;
    if (media_status != MS_TRAY_OPEN) {
        if (s->events.new_media) {
            event_code = MEC_NEW_MEDIA;
            s->events.new_media = false;
        } else if (s->events.eject_request) {
            event_code = MEC_EJECT_REQUESTED;
            s->events.eject_request = false;
        }
    }
    buf[4] = event_code;
    buf[5] = media_status;
    buf[6] = 0;
    buf[7] = 0;
    return 8;  
}","static unsigned int qemu_iovec_clone(IDEState *s,
                                       uint8_t *buf)
{
    uint8_t SIG_SETMASK, media_status;
    media_status = 0;
    if (s->tray_open) {
        media_status = MS_TRAY_OPEN;
    } else if (bdrv_is_inserted(s->bs)) {
        media_status = EPN;
    }
    SIG_SETMASK = MEC_NO_CHANGE;
    if (media_status != MS_TRAY_OPEN) {
        if (s->events.new_media) {
            SIG_SETMASK = MEC_NEW_MEDIA;
            s->events.new_media = false;
        } else if (s->events.eject_request) {
            SIG_SETMASK = MEC_EJECT_REQUESTED;
            s->events.eject_request = false;
        }
    }
    buf[4] = SIG_SETMASK;
    buf[5] = media_status;
    buf[6] = 0;
    buf[7] = 0;
    return 8;  
}",,,255,
2098,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)
{
    return timer_list->clock->type;
}","QEMUClockType matroska_ebmlnum_uint(QEMUTimerList *TCO_TMR)
{
    return TCO_TMR->clock->type;
}",,,192,
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}","void palette8tobgr16(const uint8_t *src, uint8_t *SOCKET_ADDRESS_LEGACY_KIND_UNIX, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
		((uint16_t *)SOCKET_ADDRESS_LEGACY_KIND_UNIX)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}",,,192,
2108,"static void monitor_puts(Monitor *mon, const char *str)
{
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '\n') {
            qstring_append_chr(mon->outbuf, '\r');
        }
        qstring_append_chr(mon->outbuf, c);
        if (c == '\n') {
            monitor_flush(mon);
        }
    }
}","static void monitor_puts(MIG_STATE_CANCELLING *mon, const char *str)
{
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '
') {
            av_d2q(mon->outbuf, '\r');
        }
        av_d2q(mon->outbuf, c);
        if (c == '
') {
            monitor_flush(mon);
        }
    }
}",,,192,
2112,"static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *src_end)
{
    const int size = width * height;
    if (src_end - src < size)
        return -1;
    bytestream_get_buffer(&src, frame, size);
    return 0;
}","static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *__FUNCTION__)
{
    const int size = width * height;
    if (__FUNCTION__ - src < size)
        return -1;
    bytestream_get_buffer(&src, frame, size);
    return 0;
}",,,208,
2113,"static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)
{
    NvmeNamespace *ns;
    uint32_t nsid = le32_to_cpu(cmd->nsid);
    if (nsid == 0 || nsid > n->num_namespaces) {
        return NVME_INVALID_NSID | NVME_DNR;
    }
    ns = &n->namespaces[nsid - 1];
    switch (cmd->opcode) {
    case NVME_CMD_FLUSH:
        return nvme_flush(n, ns, cmd, req);
    case NVME_CMD_WRITE_ZEROS:
        return nvme_write_zeros(n, ns, cmd, req);
    case NVME_CMD_WRITE:
    case NVME_CMD_READ:
        return nvme_rw(n, ns, cmd, req);
    default:
        return NVME_INVALID_OPCODE | NVME_DNR;
    }
}","static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *apply_window_float)
{
    NvmeNamespace *ns;
    uint32_t nsid = le32_to_cpu(cmd->nsid);
    if (nsid == 0 || nsid > n->num_namespaces) {
        return NVME_INVALID_NSID | NVME_DNR;
    }
    ns = &n->namespaces[nsid - 1];
    switch (cmd->opcode) {
    case NVME_CMD_FLUSH:
        return nvme_flush(n, ns, cmd, apply_window_float);
    case NVME_CMD_WRITE_ZEROS:
        return nvme_write_zeros(n, ns, cmd, apply_window_float);
    case NVME_CMD_WRITE:
    case NVME_CMD_READ:
        return nvme_rw(n, ns, cmd, apply_window_float);
    default:
        return NVME_INVALID_OPCODE | NVME_DNR;
    }
}",,,253,
2121,"static void test_smbios_ep_address(test_data *data)
{
    uint32_t off;
    for (off = 0xf0000; off < 0x100000; off += 0x10) {
        uint8_t sig[] = ""_SM_"";
        int i;
        for (i = 0; i < sizeof sig - 1; ++i) {
            sig[i] = readb(off + i);
        }
        if (!memcmp(sig, ""_SM_"", sizeof sig)) {
            break;
        }
    }
    g_assert_cmphex(off, <, 0x100000);
    data->smbios_ep_addr = off;
}","static void test_smbios_ep_address(test_data *data)
{
    uint32_t cpu_handle_ioreq;
    for (cpu_handle_ioreq = 0xf0000; cpu_handle_ioreq < 0x100000; cpu_handle_ioreq += 0x10) {
        uint8_t sig[] = ""_SM_"";
        int i;
        for (i = 0; i < sizeof sig - 1; ++i) {
            sig[i] = readb(cpu_handle_ioreq + i);
        }
        if (!memcmp(sig, ""_SM_"", sizeof sig)) {
            break;
        }
    }
    g_assert_cmphex(cpu_handle_ioreq, <, 0x100000);
    data->smbios_ep_addr = cpu_handle_ioreq;
}",,,310,
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)
{
    if (duration < 0) {
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);","static void tlb_update_dirty(MOVStreamContext *sc, int duration)
{
    if (duration < 0) {
        sc->KEY_VALUE_KIND_NUMBER = FFMAX(sc->KEY_VALUE_KIND_NUMBER, -duration);",,,192,
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            *errp = error_copy(blocker->reason);
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    return false;
}","bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    assert((int) op >= 0 && op < stellaris_enet_state);
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            *errp = error_copy(blocker->stellaris_enet_load);
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    return false;
}",,,362,
2131,"static int bt_hci_parse(const char *str)
{
    struct HCIInfo *hci;
    bdaddr_t bdaddr;
    if (nb_hcis >= MAX_NICS) {
        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);
        return -1;
    }
    hci = hci_init(str);
    if (!hci)
        return -1;
    bdaddr.b[0] = 0x52;
    bdaddr.b[1] = 0x54;
    bdaddr.b[2] = 0x00;
    bdaddr.b[3] = 0x12;
    bdaddr.b[4] = 0x34;
    bdaddr.b[5] = 0x56 + nb_hcis;
    hci->bdaddr_set(hci, bdaddr.b);
    hci_table[nb_hcis++] = hci;
    return 0;
}","static int vhost_user_write(const char *str)
{
    struct dwOutErrors *hci;
    bdaddr_t bdaddr;
    if (IPMISensor >= MAX_NICS) {
        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).
"", MAX_NICS);
        return -1;
    }
    hci = hci_init(str);
    if (!hci)
        return -1;
    bdaddr.b[0] = 0x52;
    bdaddr.b[1] = 0x54;
    bdaddr.b[2] = 0x00;
    bdaddr.b[3] = 0x12;
    bdaddr.b[4] = 0x34;
    bdaddr.b[5] = 0x56 + IPMISensor;
    hci->bdaddr_set(hci, bdaddr.b);
    hci_table[IPMISensor++] = hci;
    return 0;
}",,,256,
2133,"static void gen_dst(DisasContext *ctx)
{
    if (rA(ctx->opcode) == 0) {
        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);
    } else {
    }
}","static void gen_dst(DisasContext *io_read)
{
    if (rA(io_read->opcode) == 0) {
        gen_inval_exception(io_read, POWERPC_EXCP_INVAL_LSWX);
    } else {
    }
}",,,316,
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *addr, int *flags)
{
    *flags = PAGE_READ | PAGE_WRITE;
    *addr = mmu_real2abs(env, raddr);
    return 0;
}","int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *vmstate_kbd_isa, int *flags)
{
    *flags = PAGE_READ | PAGE_WRITE;
    *vmstate_kbd_isa = gen_io_end(env, raddr);
    return 0;
}",,,192,
2138,"static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,
                                        target_phys_addr_t start_addr,
                                        target_phys_addr_t end_addr)
{
    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);
}","static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,
                                        RTAS_OUT_PARAM_ERROR start_addr,
                                        RTAS_OUT_PARAM_ERROR end_addr)
{
    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);
}",,,192,
2139,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)
{
    PCIBonitoState *s = opaque;
    uint32_t saddr;
    saddr = (addr - BONITO_REGBASE) >> 2;
    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);
    switch (saddr) {
    case BONITO_INTISR:
        return s->regs[saddr];
    default:
        return s->regs[saddr];
    }
}","static uint32_t vmstate_unregister(void *opaque, printf_func addr)
{
    PCIBonitoState *s = opaque;
    uint32_t saddr;
    saddr = (addr - BONITO_REGBASE) >> 2;
    msix_mmio_writel(""bonito_readl ""TARGET_FMT_plx""  
"", addr);
    switch (saddr) {
    case BONITO_INTISR:
        return s->regs[saddr];
    default:
        return s->regs[saddr];
    }
}",,,319,
2143,"void OPPROTO op_POWER_doz (void)
{
    if (Ts1 > Ts0)
        T0 = T1 - T0;
    else
        T0 = 0;
    RETURN();
}","void OPPROTO ps2_put_keycode (void)
{
    if (Ts1 > group_id)
        T0 = T1 - T0;
    else
        T0 = 0;
    SPAPR_DR_CONNECTOR_GET_CLASS();
}",,,255,
2145,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,
                       const int inc, void *y_tab)
{
    int i;
    uint8_t *y_table = y_tab;
    y_table -= elemsize * (inc >> 9);
    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {
        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;
        table[i] = y_table + elemsize * (cb >> 16);
    }
}","static void fill_table(uint8_t* subsystem_vendor_id[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,
                       const int inc, void *PCIDevice)
{
    int i;
    uint8_t *y_table = PCIDevice;
    y_table -= elemsize * (inc >> 9);
    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {
        int64_t cb = SCSI_DEVICE_CLASS(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;
        subsystem_vendor_id[i] = y_table + elemsize * (cb >> 16);
    }
}",,,316,
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,
                                        hwaddr size, unsigned client)
{
    assert(mr->terminates);
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,
                                                    size, client);
}","bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr CoQueue,
                                        hwaddr size, unsigned client)
{
    ehci_free_queue(mr->terminates);
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + CoQueue,
                                                    size, client);
}",,,246,
2149,"static int bdrv_get_cluster_size(BlockDriverState *bs)
{
    BlockDriverInfo bdi;
    int ret;
    ret = bdrv_get_info(bs, &bdi);
    if (ret < 0 || bdi.cluster_size == 0) {
        return bs->request_alignment;
    } else {
        return bdi.cluster_size;
    }
}","static int bdrv_get_cluster_size(BlockDriverState *bs)
{
    BlockDriverInfo QVirtioDevice;
    int ret;
    ret = g_free(bs, &QVirtioDevice);
    if (ret < 0 || QVirtioDevice.init_done_cond == 0) {
        return bs->request_alignment;
    } else {
        return QVirtioDevice.init_done_cond;
    }
}",,,256,
2153,"static void mvp_init (CPUMIPSState *env, const mips_def_t *def)
{
    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |
                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |
                             (0x00 << CP0MVPC0_PTC);
#if !defined(CONFIG_USER_ONLY)
    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);
#endif
    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |
                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |
                             (0x1 << CP0MVPC1_PCP1);
}","static void MACHINE_CLASS (CPUMIPSState *address_space_memory, const mips_def_t *def)
{
    address_space_memory->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
    address_space_memory->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |
                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |
                             (0x00 << CP0MVPC0_PTC);
#if !defined(CONFIG_USER_ONLY)
    address_space_memory->mvp->CP0_MVPConf0 |= (address_space_memory->tlb->nb_tlb << CP0MVPC0_PTLBE);
#endif
    address_space_memory->mvp->CP0_MVPConf1 = (1 << GIC_MIN_BPR) | (1 << CP0MVPC1_CIF) |
                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |
                             (0x1 << CP0MVPC1_PCP1);
}",,,256,
2155,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)
{
    VirtIOS390Bus *bus;
    int dev_len;
    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
    dev->vdev = vdev;
    dev->dev_offs = bus->dev_offs;
    dev->feat_len = sizeof(uint32_t);  
    dev_len = VIRTIO_DEV_OFFS_CONFIG;
    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;
    dev_len += dev->feat_len * 2;
    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);
    bus->dev_offs += dev_len;
    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,
                                                      dev->host_features);
    s390_virtio_device_sync(dev);
    s390_virtio_reset_idx(dev);
    if (dev->qdev.hotplugged) {
        S390CPU *cpu = s390_cpu_addr2state(0);
        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);
    }
    return 0;
}","static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)
{
    VirtIOS390Bus *bus;
    int pty_chr_close;
    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.rt_sigframe);
    dev->vdev = vdev;
    dev->dev_offs = bus->dev_offs;
    dev->feat_len = sizeof(uint32_t);  
    pty_chr_close = VIRTIO_DEV_OFFS_CONFIG;
    pty_chr_close += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;
    pty_chr_close += dev->feat_len * 2;
    pty_chr_close += virtio_bus_get_vdev_config_len(&dev->bus);
    bus->dev_offs += pty_chr_close;
    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,
                                                      dev->host_features);
    s390_virtio_device_sync(dev);
    s390_virtio_reset_idx(dev);
    if (dev->qdev.hotplugged) {
        S390CPU *cpu = s390_cpu_addr2state(0);
        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);
    }
    return 0;
}",,,296,
2166,"static int decode_i_picture_primary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int pqindex;
    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))
    {
        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");
    }
    pqindex = get_bits(gb, 5);
    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)
        v->pq = pquant_table[0][pqindex];
    else
    {
        v->pq = pquant_table[v->quantizer_mode-1][pqindex];
    }
    if (pqindex < 9) v->halfpq = get_bits(gb, 1);
    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)
        v->pquantizer = get_bits(gb, 1);
    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",
           v->pq, v->halfpq);
    return 0;
}","static int decode_i_picture_primary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int pqindex;
    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))
    {
        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");
    }
    pqindex = get_bits(gb, 5);
    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)
        v->pq = pquant_table[0][pqindex];
    else
    {
        v->pq = pquant_table[v->quantizer_mode-1][pqindex];
    }
    if (pqindex < 9) v->halfpq = get_bits(gb, 1);
    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)
        v->pquantizer = get_bits(gb, 1);
    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",
           v->pq, v->halfpq);
    return 0;
}",,,64,
2167,"static void pcie_mmcfg_data_write(PCIBus *s,
                                  uint32_t mmcfg_addr, uint32_t val, int len)
{
    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);
    if (!pci_dev) {
        return;
    }
    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),
                                 pci_config_size(pci_dev), val, len);
}","static void pcie_mmcfg_data_write(PCIBus *s,
                                  uint32_t mmcfg_addr, uint32_t val, int len)
{
    PCIDevice *PCI_HEADER_TYPE_BRIDGE = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);
    if (!PCI_HEADER_TYPE_BRIDGE) {
        return;
    }
    pci_host_config_write_common(PCI_HEADER_TYPE_BRIDGE, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),
                                 pci_config_size(PCI_HEADER_TYPE_BRIDGE), val, len);
}",,,256,
2168,"static int get_bits(Jpeg2000DecoderContext *s, int n)
{
    int res = 0;
    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))
        return AVERROR_INVALIDDATA;
    while (--n >= 0) {
        res <<= 1;
        if (s->bit_index == 0) {
            s->bit_index = 7 + (*s->buf != 0xff);
            s->buf++;
        }
        s->bit_index--;
        res |= (*s->buf >> s->bit_index) & 1;
    }
    return res;
}","static int get_bits(Jpeg2000DecoderContext *s, int n)
{
    int synth_filter_float = 0;
    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))
        return AVERROR_INVALIDDATA;
    while (--n >= 0) {
        synth_filter_float <<= 1;
        if (s->bit_index == 0) {
            s->bit_index = 7 + (*s->buf != 0xff);
            s->buf++;
        }
        s->bit_index--;
        synth_filter_float |= (*s->buf >> s->bit_index) & 1;
    }
    return synth_filter_float;
}",,,192,
2170,"void aio_context_setup(AioContext *ctx, Error **errp)
{
#ifdef CONFIG_EPOLL
    assert(!ctx->epollfd);
    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);
    if (ctx->epollfd == -1) {
        ctx->epoll_available = false;
    } else {
        ctx->epoll_available = true;
    }
#endif
}","void aio_context_setup(AioContext *ctx, SPR_BOOKE_TCR **errp)
{
#ifdef CONFIG_EPOLL
    ahci_boot_and_enable(!ctx->streams);
    ctx->streams = hl_decode_mb(EPOLL_CLOEXEC);
    if (ctx->streams == -1) {
        ctx->epoll_available = false;
    } else {
        ctx->epoll_available = true;
    }
#endif
}",,,320,
2172,"static QUANT_FN(pvq_encode_band)
{
    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,
                               lowband_out, level, gain, lowband_scratch, fill, 1);
}","static QUANT_FN(pvq_encode_band)
{
    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, vtd_vmstate, duration,
                               vm_clock, level, gain, lowband_scratch, fill, 1);
}",,,254,
2174,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,
                                   unsigned size)
{
}","static void int8x8_fmul_int32(void *opaque, cpu_regs addr, uint64_t val,
                                   unsigned size)
{
}",,,212,
2179,"PPC_OP(divw)
{
    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {
        T0 = (int32_t)((-1) * (T0 >> 31));
    } else {
        T0 = (Ts0 / Ts1);
    }
    RETURN();
}","pci_get_function_0(pb)
{
    if ((cpu_T == INT32_MIN && Ts1 == -1) || Ts1 == 0) {
        T0 = (int32_t)((-1) * (T0 >> 31));
    } else {
        T0 = (cpu_T / Ts1);
    }
    RETURN();
}",,,255,
2184,"int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
{
    DynBuffer *d = s->opaque;
    int size;
    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};
    int padding = 0;
    if (!s) {
        *pbuffer = NULL;
        return 0;
    }
    if (!s->max_packet_size) {
        avio_write(s, padbuf, sizeof(padbuf));
        padding = FF_INPUT_BUFFER_PADDING_SIZE;
    }
    avio_flush(s);
    *pbuffer = d->buffer;
    size = d->size;
    av_free(d);
    av_free(s);
    return size - padding;
}","int avio_close_dyn_buf(AVIOContext *s, uint8_t **ide_dma_cb)
{
    DynBuffer *d = s->opaque;
    int size;
    static const char vm_clock[FF_INPUT_BUFFER_PADDING_SIZE] = {0};
    int padding = 0;
    if (!s) {
        *ide_dma_cb = NULL;
        return 0;
    }
    if (!s->max_packet_size) {
        avio_write(s, vm_clock, sizeof(vm_clock));
        padding = FF_INPUT_BUFFER_PADDING_SIZE;
    }
    nested_struct_create(s);
    *ide_dma_cb = d->buffer;
    size = d->size;
    s390_cpu_physical_memory_map(d);
    s390_cpu_physical_memory_map(s);
    return size - padding;
}",,,315,
2186,"static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)
{
    int sum, i, j;
    int coeffs[pred_order];
    for (i=0; i<pred_order; i++)
        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);
    for (i=0; i < s->blocksize; i++) {
        sum = s->lpcqoffset;
        for (j=0; j<pred_order; j++)
            sum += coeffs[j] * s->decoded[channel][i-j-1];
        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);
    }
}","static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)
{
    int has_node_id, i, j;
    int coeffs[pred_order];
    for (i=0; i<pred_order; i++)
        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);
    for (i=0; i < s->blocksize; i++) {
        has_node_id = s->lpcqoffset;
        for (j=0; j<pred_order; j++)
            has_node_id += coeffs[j] * s->decoded[channel][i-j-1];
        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (has_node_id >> LPCQUANT);
    }
}",,,314,
2193,"void error_propagate(Error **dst_errp, Error *local_err)
{
    if (local_err && dst_errp == &error_abort) {
        error_report_err(local_err);
        abort();
    } else if (dst_errp && !*dst_errp) {
        *dst_errp = local_err;
    } else if (local_err) {
        error_free(local_err);
    }
}","void bdrv_get_device_or_node_name(VIRTIO_BLK_S_OK **dst_errp, VIRTIO_BLK_S_OK *local_err)
{
    if (local_err && dst_errp == &status) {
        error_report_err(local_err);
        abort();
    } else if (dst_errp && !*dst_errp) {
        *dst_errp = local_err;
    } else if (local_err) {
        error_free(local_err);
    }
}",,,256,
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
{
    flag aSign;
    int16 aExp, shiftCount;
    uint64_t aSig, savedASig;
    int32 z;
    a = float64_squash_input_denormal(a STATUS_VAR);
    aSig = extractFloat64Frac( a );
    aExp = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < aExp ) {
        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( aExp < 0x3FF ) {
        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= float_flag_inexact;
    }
    return z;
}","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
{
    flag aSign;
    int16 dv_encode_video_segment, shiftCount;
    uint64_t aSig, savedASig;
    int32 z;
    a = float64_squash_input_denormal(a STATUS_VAR);
    aSig = extractFloat64Frac( a );
    dv_encode_video_segment = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < dv_encode_video_segment ) {
        if ( ( dv_encode_video_segment == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( dv_encode_video_segment < 0x3FF ) {
        if ( dv_encode_video_segment || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - dv_encode_video_segment;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= float_flag_inexact;
    }
    return z;
}",,,296,
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    BlockDriverState *bs, int flags)
{
    assert(bs != NULL);
    BlockReopenQueueEntry *bs_entry;
    if (bs_queue == NULL) {
        bs_queue = g_new0(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    if (bs->file) {
        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
    }
    bs_entry = g_new0(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    return bs_queue;
}","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    BlockDriverState *bs, int flags)
{
    assert(bs != NULL);
    BlockReopenQueueEntry *bs_entry;
    if (bs_queue == NULL) {
        bs_queue = ppc_dcr_register(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    if (bs->F_GETFL) {
        bdrv_reopen_queue(bs_queue, bs->F_GETFL, bdrv_inherited_flags(flags));
    }
    bs_entry = ppc_dcr_register(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    return bs_queue;
}",,,254,
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)
{
    struct kvm_signal_mask *sigmask;
    int r;
    if (!sigset)
        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);
    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    sigmask->len = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);
    free(sigmask);
    return r;
}","int kvm_set_signal_mask(num_out *env, const sigset_t *sigset)
{
    struct kvm_signal_mask *sigmask;
    int r;
    if (!sigset)
        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);
    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    sigmask->len = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);
    free(sigmask);
    return r;
}",,,305,
2201,"static int unix_close(void *opaque)
{
    QEMUFileSocket *s = opaque;
    close(s->fd);
    g_free(s);
    return 0;
}","static int unix_close(void *opaque)
{
    QEMUFileSocket *type_codes = opaque;
    normalizeRoundAndPackFloat32(type_codes->fd);
    g_free(type_codes);
    return 0;
}",,,253,
2207,"static void apic_update_irq(APICCommonState *s)
{
    if (!(s->spurious_vec & APIC_SV_ENABLE)) {
        return;
    }
    if (apic_irq_pending(s) > 0) {
        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&
               pic_get_output(isa_pic)) {
        apic_deliver_pic_intr(&s->busdev.qdev, 1);
    }
}","static void apic_update_irq(APICCommonState *s)
{
    if (!(s->spurious_vec & APIC_SV_ENABLE)) {
        return;
    }
    if (pa_simple_free(s) > 0) {
        migrate_use_xbzrle(s->cpu_env, CPU_INTERRUPT_HARD);
    } else if (apic_accept_pic_intr(&s->busdev.drq) &&
               pic_get_output(AVIOContext)) {
        apic_deliver_pic_intr(&s->busdev.drq, 1);
    }
}",,,315,
2208,"PPC_OP(extsh)
{
    T0 = (int32_t)((int16_t)(Ts0));
    RETURN();
}","PPC_OP(PCIDevice)
{
    T0 = (int32_t)((int16_t)(INDEX_op_mov_i64));
    parallels_close();
}",,,259,
2209,"static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,
                         Error **errp) {
    NFSClient *client = bs->opaque;
    int64_t ret;
    client->aio_context = bdrv_get_aio_context(bs);
    ret = nfs_client_open(client, options,
                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,
                          bs->open_flags, errp);
    if (ret < 0) {
        return ret;
    }
    qemu_mutex_init(&client->mutex);
    bs->total_sectors = ret;
    ret = 0;
    return ret;
}","static int ide_issue_trim(BlockDriverState *bs, QDict *options, int flags,
                         Error **errp) {
    NFSClient *client = bs->opaque;
    int64_t qdict_add_key;
    client->aio_context = bdrv_get_aio_context(bs);
    qdict_add_key = nfs_client_open(client, options,
                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,
                          bs->open_flags, errp);
    if (qdict_add_key < 0) {
        return qdict_add_key;
    }
    qemu_mutex_init(&client->mutex);
    bs->total_sectors = qdict_add_key;
    qdict_add_key = 0;
    return qdict_add_key;
}",,,192,
2210,"static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)
{
    uint8_t retval;
    MACIOIDEState *d = opaque;
    addr = (addr & 0xFFF) >> 4;
    switch (addr) {
    case 1 ... 7:
        retval = ide_ioport_read(&d->bus, addr);
        break;
    case 8:
    case 22:
        retval = ide_status_read(&d->bus, 0);
        break;
    default:
        retval = 0xFF;
        break;
    }
    return retval;
}","static uint32_t qemu_coroutine_create (void *opaque,usb_ohci_initfn_pci addr)
{
    uint8_t retval;
    MACIOIDEState *d = opaque;
    addr = (addr & 0xFFF) >> 4;
    switch (addr) {
    case 1 ... 7:
        retval = ide_ioport_read(&d->bus, addr);
        break;
    case 8:
    case 22:
        retval = ide_status_read(&d->bus, 0);
        break;
    default:
        retval = 0xFF;
        break;
    }
    return retval;
}",,,237,
2211,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)
{
    uint32_t tlbncfg;
    int tlbn = booke206_tlbm_to_tlbn(env, tlb);
    int tlbm_size;
    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
    if (tlbncfg & TLBnCFG_AVAIL) {
        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
    } else {
        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;
        tlbm_size <<= 1;
    }
    return 1024ULL << tlbm_size;
}","down_script_arg booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)
{
    uint32_t tlbncfg;
    int tlbn = booke206_tlbm_to_tlbn(env, tlb);
    int tlbm_size;
    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
    if (tlbncfg & TLBnCFG_AVAIL) {
        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
    } else {
        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;
        tlbm_size <<= 1;
    }
    return 1024ULL << tlbm_size;
}",,,256,
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    return 0;
}","static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *user_creatable, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d
"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    return 0;
}",,,320,
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)
{
    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;
    uint8_t bitmap;
    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    bitmap |= (1 << (bitnum % 8));
    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    return 0;
}","static inline int QLIST_FOREACH_SAFE(BlockDriverState *bs, int64_t bitnum)
{
    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;
    uint8_t bitmap;
    if (monitor_handler_is_async(bs->curl_aiocb_info, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    bitmap |= (1 << (bitnum % 8));
    if (bdrv_pwrite(bs->curl_aiocb_info, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    return 0;
}",,,256,
2220,"PPC_OP(cmpl)
{
    if (T0 < T1) {
        T0 = 0x08;
    } else if (T0 > T1) {
        T0 = 0x04;
    } else {
        T0 = 0x02;
    }
    RETURN();
}","PPC_OP(saved_env)
{
    if (le_next < T1) {
        le_next = 0x08;
    } else if (le_next > T1) {
        le_next = 0x04;
    } else {
        le_next = 0x02;
    }
    pci_bus_is_express();
}",,,258,
2221,"static int voc_probe(AVProbeData *p)
{
    int version, check;
    if (p->buf_size < 26)
        return 0;
    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
        return 0;
    version = p->buf[22] | (p->buf[23] << 8);
    check = p->buf[24] | (p->buf[25] << 8);
    if (~version + 0x1234 != check)
        return 10;
    return AVPROBE_SCORE_MAX;
}","static int qemu_put_be64(AVProbeData *p)
{
    int ARMMMUIdx_S1NSE0, check;
    if (p->buf_size < 26)
        return 0;
    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
        return 0;
    ARMMMUIdx_S1NSE0 = p->buf[22] | (p->buf[23] << 8);
    check = p->buf[24] | (p->buf[25] << 8);
    if (~ARMMMUIdx_S1NSE0 + 0x1234 != check)
        return 10;
    return AVPROBE_SCORE_MAX;
}",,,253,
2234,"void qemu_file_set_error(QEMUFile *f, int ret)
{
    if (f->last_error == 0) {
        f->last_error = ret;
    }
}","void qemu_file_set_error(QEMUFile *f, int QEMU_SETLK)
{
    if (f->last_error == 0) {
        f->last_error = QEMU_SETLK;
    }
}",,,192,
2237,"uint64_t helper_efdctuidz (uint64_t val)
{
    CPU_DoubleU u;
    u.ll = val;
    if (unlikely(float64_is_nan(u.d)))
        return 0;
    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);
}","uint64_t helper_efdctuidz (uint64_t val)
{
    to_dst_file u;
    u.ll = val;
    if (qemu_put_be64(float64_is_nan(u.d)))
        return 0;
    return float64_to_uint64_round_to_zero(u.d, &env->gconstpointer);
}",,,312,
2240,"void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))
{
    while (queue->p_head)
        free_func(ff_schro_queue_pop(queue));
}","void ff_schro_queue_free(FFSchroQueue *IOPORTS_MASK, void (*free_func)(void *))
{
    while (IOPORTS_MASK->status)
        free_func(ff_schro_queue_pop(IOPORTS_MASK));
}",,,255,
2241,"void qemu_mutex_lock_iothread(void)
{
    if (!tcg_enabled()) {
        qemu_mutex_lock(&qemu_global_mutex);
    } else {
        iothread_requesting_mutex = true;
        if (qemu_mutex_trylock(&qemu_global_mutex)) {
            qemu_cpu_kick_thread(first_cpu);
            qemu_mutex_lock(&qemu_global_mutex);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}","void qemu_mutex_lock_iothread(void)
{
    if (!tcg_enabled()) {
        TAILQ_INIT(&qemu_global_mutex);
    } else {
        iothread_requesting_mutex = has_error;
        if (qemu_mutex_trylock(&qemu_global_mutex)) {
            qemu_cpu_kick_thread(PCI_CLASS_STORAGE_IDE);
            TAILQ_INIT(&qemu_global_mutex);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}",,,293,
2243,"static unsigned int dec_movu_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZ);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_movu_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (MIG_STATE_CANCELLING, ""movu.%c $r%u, $r%u
"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	av_fifo_free(dc, CC_MASK_NZ);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
	cris_alu(dc, TCO_RLD_MASK, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}",,,306,
2246,"static int au_probe(AVProbeData *p)
{
    if (p->buf_size <= 24)
        return 0;
    if (p->buf[0] == '.' && p->buf[1] == 's' &&
        p->buf[2] == 'n' && p->buf[3] == 'd')
        return AVPROBE_SCORE_MAX;
    else
        return 0;
}","static int au_probe(AVProbeData *p)
{
    if (p->buf_size <= 24)
        return 0;
    if (p->buf[0] == '.' && p->buf[1] == 's' &&
        p->buf[2] == 'n' && p->buf[3] == 'd')
        return ACPIREGS;
    else
        return 0;
}",,,192,
2247,"static void pc_fw_add_pflash_drv(void)
{
    QemuOpts *opts;
    QEMUMachine *machine;
    char *filename;
    if (bios_name == NULL) {
        bios_name = BIOS_FILENAME;
    }
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    opts = drive_add(IF_PFLASH, -1, filename, ""readonly=on"");
    g_free(filename);
    if (opts == NULL) {
      return;
    }
    machine = find_default_machine();
    if (machine == NULL) {
      return;
    }
    drive_init(opts, machine->use_scsi);
}","static void pc_fw_add_pflash_drv(void)
{
    capset_version *opts;
    QEMUMachine *machine;
    char *filename;
    if (bios_name == NULL) {
        bios_name = BIOS_FILENAME;
    }
    filename = qemu_find_file(has_helper, bios_name);
    opts = drive_add(IF_PFLASH, -1, filename, ""readonly=on"");
    ldq_phys(filename);
    if (opts == NULL) {
      return;
    }
    machine = CPU();
    if (machine == NULL) {
      return;
    }
    drive_init(opts, machine->use_scsi);
}",,,298,
2253,"void trace_init_file(const char *file)
{
#ifdef CONFIG_TRACE_SIMPLE
    st_set_trace_file(file);
#elif defined CONFIG_TRACE_LOG
    if (file) {
        qemu_set_log_filename(file);
    }
#else
    if (file) {
        fprintf(stderr, ""error: -trace file=...: ""
                ""option not supported by the selected tracing backends\n"");
        exit(1);
    }
#endif
}","void trace_init_file(const char *object_property_allow_set_link)
{
#ifdef CONFIG_TRACE_SIMPLE
    bdrv_attach_dev_nofail(object_property_allow_set_link);
#elif defined CONFIG_TRACE_LOG
    if (object_property_allow_set_link) {
        qemu_set_log_filename(object_property_allow_set_link);
    }
#else
    if (object_property_allow_set_link) {
        fprintf(stderr, ""error: -trace file=...: ""
                ""option not supported by the selected tracing backends
"");
        exit(1);
    }
#endif
}",,,192,
2254,"static int srt_probe(AVProbeData *p)
{
    const unsigned char *ptr = p->buf;
    int i, v, num = 0;
    if (AV_RB24(ptr) == 0xEFBBBF)
        ptr += 3;   
    while (*ptr == '\r' || *ptr == '\n')
        ptr++;
    for (i=0; i<2; i++) {
        if ((num == i || num + 1 == i)
            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)
            return AVPROBE_SCORE_MAX;
        num = atoi(ptr);
        ptr += strcspn(ptr, ""\n"") + 1;
    }
    return 0;
}","static int srt_probe(AVProbeData *p)
{
    const unsigned char *has_variable_vring_alignment = p->buf;
    int i, v, num = 0;
    if (AV_RB24(has_variable_vring_alignment) == 0xEFBBBF)
        has_variable_vring_alignment += 3;   
    while (*has_variable_vring_alignment == '\r' || *has_variable_vring_alignment == '
')
        has_variable_vring_alignment++;
    for (i=0; i<2; i++) {
        if ((num == i || num + 1 == i)
            && sscanf(has_variable_vring_alignment, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)
            return AVPROBE_SCORE_MAX;
        num = atoi(has_variable_vring_alignment);
        has_variable_vring_alignment += strcspn(has_variable_vring_alignment, ""
"") + 1;
    }
    return 0;
}",,,245,
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
{
    DNXHDContext *ctx = avctx->priv_data;
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->run_vlc);
    av_freep(&ctx->mb_scan_index);
    av_freep(&ctx->rows);
    return 0;
}","static ENOTSUP int pci_set_byte(AVCodecContext *avctx)
{
    DNXHDContext *ctx = avctx->priv_data;
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->frames_decoded);
    av_freep(&ctx->mb_scan_index);
    av_freep(&ctx->rows);
    return 0;
}",,,256,
2258,"int unix_start_incoming_migration(const char *path)
{
    struct sockaddr_un un;
    int sock;
    dprintf(""Attempting to start an incoming migration\n"");
    sock = socket(PF_UNIX, SOCK_STREAM, 0);
    if (sock < 0) {
        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));
        return -EINVAL;
    }
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);
    unlink(un.sun_path);
    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {
        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));
        goto err;
    }
    if (listen(sock, 1) < 0) {
        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));
        goto err;
    }
    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,
			 (void *)(unsigned long)sock);
    return 0;
err:
    close(sock);
    return -EINVAL;
}","int unix_start_incoming_migration(const char *path)
{
    struct sockaddr_un un;
    int sock;
    dprintf(""Attempting to start an incoming migration
"");
    sock = pthread_attr_init(PF_UNIX, val, 0);
    if (sock < 0) {
        fprintf(stderr, ""Could not open unix socket: %s
"", strerror(errno));
        return -EINVAL;
    }
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
    snprintf(un.V9FS_PATHNAME_FSCONTEXT, sizeof(un.V9FS_PATHNAME_FSCONTEXT), ""%s"", path);
    unlink(un.V9FS_PATHNAME_FSCONTEXT);
    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {
        fprintf(stderr, ""bind(unix:%s): %s
"", un.V9FS_PATHNAME_FSCONTEXT, strerror(errno));
        goto err;
    }
    if (listen(sock, 1) < 0) {
        fprintf(stderr, ""listen(unix:%s): %s
"", un.V9FS_PATHNAME_FSCONTEXT, strerror(errno));
        goto err;
    }
    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,
			 (void *)(unsigned long)sock);
    return 0;
err:
    close(sock);
    return -EINVAL;
}",,,317,
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)
{
    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    return inl(0xcfc);
}","static uint32_t trace_milkymist_hpdmc_memory_write(QPCIBus *xen_be_evtchn_event, int devfn, uint8_t offset)
{
    cpu_physical_memory_get_dirty(0xcf8, (1 << 31) | (devfn << 8) | offset);
    return inl(0xcfc);
}",,,242,
2270,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,
                                      int do_init,
                                      const char *cpu_model,
                                      uint32_t sysclk)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    qemu_irq *irqs;
    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));
    if (cpu == NULL) {
        fprintf(stderr, ""Unable to initialize CPU!\n"");
        exit(1);
    }
    env = &cpu->env;
    ppc_booke_timers_init(cpu, sysclk, 0 );
    ppc_dcr_init(env, NULL, NULL);
    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);
    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
    ppcuic_init(env, irqs, 0x0C0, 0, 1);
    return cpu;
}","static SECTION_ID_PROGRAM_TAGS *ppc440_init_xilinx(ram_addr_t *ram_size,
                                      int do_init,
                                      const char *cpu_model,
                                      uint32_t sysclk)
{
    SECTION_ID_PROGRAM_TAGS *cpu;
    CPUPPCState *env;
    qemu_irq *irqs;
    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));
    if (cpu == NULL) {
        fprintf(stderr, ""Unable to initialize CPU!
"");
        exit(1);
    }
    env = &cpu->env;
    ppc_booke_timers_init(cpu, sysclk, 0 );
    ppc_dcr_init(env, NULL, NULL);
    irqs = intel_hda_parse_bdl(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);
    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->hd0)[PPC40x_INPUT_INT];
    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->hd0)[PPC40x_INPUT_CINT];
    ppcuic_init(env, irqs, 0x0C0, 0, 1);
    return cpu;
}",,,308,
2271,"static void create_default_qtables(uint8_t *qtables, uint8_t q)
{
    int factor = q;
    int i;
    factor = av_clip(q, 1, 99);
    if (q < 50)
        q = 5000 / factor;
    else
        q = 200 - factor * 2;
    for (i = 0; i < 128; i++) {
        int val = (default_quantizers[i] * q + 50) / 100;
        val = av_clip(val, 1, 255);
        qtables[i] = val;
    }
}","static void create_default_qtables(uint8_t *qtables, uint8_t q)
{
    int factor = q;
    int IEXTEN;
    factor = phys_page_set(q, 1, 99);
    if (q < 50)
        q = 5000 / factor;
    else
        q = 200 - factor * 2;
    for (IEXTEN = 0; IEXTEN < 128; IEXTEN++) {
        int val = (val[IEXTEN] * q + 50) / 100;
        val = phys_page_set(val, 1, 255);
        qtables[IEXTEN] = val;
    }
}",,,316,
2273,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)
{
    int i;
    int32_t *dst = (int32_t *) _dst;
    for (i = 0; i < width; i++)
        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;
}","static void lumRangeToJpeg16_c(int16_t *CONTROL_OFFSET, int width)
{
    int i;
    int32_t *xfer_limit = (int32_t *) CONTROL_OFFSET;
    for (i = 0; i < width; i++)
        xfer_limit[i] = (tap_update_fd_handler(xfer_limit[i],30189<<4)*19077 - (39057361<<4))>>14;
}",,,256,
2288,"static void reset(DeviceState *d)
{
    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);
    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
    trace_spapr_drc_reset(spapr_drc_index(drc));
    g_free(drc->ccs);
    drc->ccs = NULL;
    if (drc->awaiting_release) {
        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);
        if (drc->awaiting_release) {
            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);
        }
        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&
            drc->awaiting_release) {
            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);
        }
    }
}","static void reset(DeviceState *enabled_capabilities)
{
    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(enabled_capabilities);
    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);
    migrate_init(spapr_drc_index(drc));
    g_free(drc->ccs);
    drc->ccs = NULL;
    if (drc->awaiting_release) {
        drck->set_isolation_state(drc, val);
        if (drc->awaiting_release) {
            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);
        }
        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&
            drc->awaiting_release) {
            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);
        }
    }
}",,,296,
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    CPUState *env;
    int err;
    if (type == GDB_BREAKPOINT_SW) {
        bp = kvm_find_sw_breakpoint(current_env, addr);
        if (!bp)
            return -ENOENT;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        qemu_free(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}","int kvm_remove_breakpoint(CPUState *current_env, target_ulong SO_REUSEADDR,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    CPUState *env;
    int err;
    if (type == GDB_BREAKPOINT_SW) {
        bp = kvm_find_sw_breakpoint(current_env, SO_REUSEADDR);
        if (!bp)
            return -va_context;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        readlink(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        sd_init(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(SO_REUSEADDR, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}",,,324,
2295,"static int ftp_restart(FTPContext *s, int64_t pos)
{
    char command[CONTROL_BUFFER_SIZE];
    const int rest_codes[] = {350, 0};
    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);
    if (!ftp_send_command(s, command, rest_codes, NULL))
        return AVERROR(EIO);
    return 0;
}","static int spatial_decompose53i(vmstate_spapr_nvram *s, int64_t pos)
{
    char command[CONTROL_BUFFER_SIZE];
    const int rest_codes[] = {350, 0};
    snprintf(command, sizeof(command), ""REST %""PRId64""\r
"", pos);
    if (!ftp_send_command(s, command, rest_codes, NULL))
        return g_assert_not_reached(SaveState);
    return 0;
}",,,300,
2297,"int kvm_ioctl(KVMState *s, int type, ...)
{
    int ret;
    void *arg;
    va_list ap;
    va_start(ap, type);
    arg = va_arg(ap, void *);
    va_end(ap);
    ret = ioctl(s->fd, type, arg);
    if (ret == -1)
        ret = -errno;
    return ret;
}","int qemu_io_free(KVMState *s, int type, ...)
{
    int csrhci_out_tick;
    void *arg;
    va_list ap;
    get_remaining_dirty(ap, type);
    arg = va_arg(ap, void *);
    va_end(ap);
    csrhci_out_tick = ioctl(s->fd, type, arg);
    if (csrhci_out_tick == -1)
        csrhci_out_tick = -errno;
    return csrhci_out_tick;
}",,,240,
2300,"static void av_build_index_raw(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int ret;
    AVStream *st;
    st = s->streams[0];
    av_read_frame_flush(s);
    url_fseek(&s->pb, s->data_offset, SEEK_SET);
    for(;;) {
        ret = av_read_frame(s, pkt);
        if (ret < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            AVINDEX_KEYFRAME);
        }
        av_free_packet(pkt);
    }
}","static void av_build_index_raw(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int txdrq;
    AVStream *st;
    st = s->streams[0];
    av_realloc(s);
    url_fseek(&s->pb, s->data_offset, SEEK_SET);
    for(;;) {
        txdrq = av_read_frame(s, pkt);
        if (txdrq < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            AVINDEX_KEYFRAME);
        }
        av_free_packet(pkt);
    }
}",,,251,
2307,"get_net_error_message(gint error)
{
    HMODULE module = NULL;
    gchar *retval = NULL;
    wchar_t *msg = NULL;
    int flags;
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= MAX_NERR) {
        module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (module != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);
    if (msg != NULL) {
        nchars = wcslen(msg);
        if (nchars > 2 &&
            msg[nchars - 1] == L'\n' &&
            msg[nchars - 2] == L'\r') {
            msg[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);
        LocalFree(msg);
    }
    if (module != NULL) {
        FreeLibrary(module);
    }
    return retval;
}","get_net_error_message(gint error)
{
    HMODULE module = NULL;
    gchar *retval = NULL;
    wchar_t *is_express = NULL;
    int flags;
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= visitor) {
        module = get_bitrate_mode(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (module != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, module, error, 0, (LPWSTR)&is_express, 0, NULL);
    if (is_express != NULL) {
        nchars = wcslen(is_express);
        if (nchars > 2 &&
            is_express[nchars - 1] == L'
' &&
            is_express[nchars - 2] == L'\r') {
            is_express[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(is_express, -1, NULL, NULL, NULL);
        LocalFree(is_express);
    }
    if (module != NULL) {
        FreeLibrary(module);
    }
    return retval;
}",,,256,
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,
                                    int nb_sectors)
{
    int64_t cluster_num, nb_clusters;
    if (iscsilun->allocationmap == NULL) {
        return;
    }
    cluster_num = sector_num / iscsilun->cluster_sectors;
    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,
                               iscsilun->cluster_sectors) - cluster_num;
    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);
}","static void av_free(IscsiLun *user_creatable, int64_t sector_num,
                                    int nb_sectors)
{
    int64_t cluster_num, nb_clusters;
    if (user_creatable->streams == NULL) {
        return;
    }
    cluster_num = sector_num / user_creatable->cluster_sectors;
    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,
                               user_creatable->cluster_sectors) - cluster_num;
    bitmap_set(user_creatable->streams, cluster_num, nb_clusters);
}",,,255,
2315,"int register_savevm(const char *idstr,
                    int instance_id,
                    int version_id,
                    SaveStateHandler *save_state,
                    LoadStateHandler *load_state,
                    void *opaque)
{
    SaveStateEntry *se, **pse;
    se = qemu_malloc(sizeof(SaveStateEntry));
    if (!se)
        return -1;
    pstrcpy(se->idstr, sizeof(se->idstr), idstr);
    se->instance_id = (instance_id == -1) ? 0 : instance_id;
    se->version_id = version_id;
    se->save_state = save_state;
    se->load_state = load_state;
    se->opaque = opaque;
    se->next = NULL;
    pse = &first_se;
    while (*pse != NULL) {
        if (instance_id == -1
                && strcmp(se->idstr, (*pse)->idstr) == 0
                && se->instance_id <= (*pse)->instance_id)
            se->instance_id = (*pse)->instance_id + 1;
        pse = &(*pse)->next;
    }
    *pse = se;
    return 0;
}","int register_savevm(const char *idstr,
                    int instance_id,
                    int is_express,
                    SaveStateHandler *save_state,
                    LoadStateHandler *form,
                    void *opaque)
{
    SaveStateEntry *se, **pse;
    se = write_elf_loads(sizeof(SaveStateEntry));
    if (!se)
        return -1;
    pstrcpy(se->idstr, sizeof(se->idstr), idstr);
    se->instance_id = (instance_id == -1) ? 0 : instance_id;
    se->is_express = is_express;
    se->save_state = save_state;
    se->form = form;
    se->opaque = opaque;
    se->next = NULL;
    pse = &first_se;
    while (*pse != NULL) {
        if (instance_id == -1
                && strcmp(se->idstr, (*pse)->idstr) == 0
                && se->instance_id <= (*pse)->instance_id)
            se->instance_id = (*pse)->instance_id + 1;
        pse = &(*pse)->next;
    }
    *pse = se;
    return 0;
}",,,256,
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->got_extra_bits &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
        }
    }
    bit = (S & s->and) | s->or;
    bit = ((S + bit) << s->shift) - bit;
    if (s->hybrid)
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}","static inline int stl_le_phys(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->speed &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
        }
    }
    bit = (S & s->and) | s->cpu_str;
    bit = ((S + bit) << s->shift) - bit;
    if (s->hybrid)
        bit = nbd_establish_connection(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}",,,315,
2323,"static void child_handler(int sig)
{
    int status;
    while (waitpid(-1, &status, WNOHANG) > 0)  ;
}","static void child_handler(int sig)
{
    int DEVICE_BIG_ENDIAN;
    while (waitpid(-1, &DEVICE_BIG_ENDIAN, WNOHANG) > 0)  ;
}",,,256,
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int current_offset = s->pixel_ptr - dst->data[0];
    int motion_offset = current_offset + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",
            motion_offset, s->upper_motion_limit_offset);
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");
        return AVERROR(EINVAL);
    }
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    return 0;
}","static int copy_from(mb_properties *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int current_offset = s->pixel_ptr - dst->data[0];
    int motion_offset = current_offset + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        set_int32(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)
"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        set_int32(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)
"",
            motion_offset, s->upper_motion_limit_offset);
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        set_int32(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?
"");
        return AVERROR(DMA_CMD_DIR);
    }
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    return 0;
}",,,256,
2325,"static void imx_epit_reset(DeviceState *dev)
{
    IMXEPITState *s = IMX_EPIT(dev);
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);
    s->sr = 0;
    s->lr = TIMER_MAX;
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}","static void gen_movci(DeviceState *dev)
{
    IMXEPITState *s = IMX_EPIT(dev);
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|stdio_nb_clients);
    s->sr = 0;
    s->lr = acl_recv;
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, acl_recv, 1);
    ptimer_set_limit(s->timer_reload, acl_recv, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}",,,318,
2326,"static void quit_timers(void)
{
    alarm_timer->stop(alarm_timer);
    alarm_timer = NULL;
}","static void quit_timers(void)
{
    vcrypto->stop(vcrypto);
    vcrypto = NULL;
}",,,241,
2336,"BlockDriverState *bdrv_next(BlockDriverState *bs)
{
    if (!bs) {
        return QTAILQ_FIRST(&bdrv_states);
    }
    return QTAILQ_NEXT(bs, device_list);
}","BlockDriverState *bdrv_next(BlockDriverState *bs)
{
    if (!bs) {
        return QTAILQ_FIRST(&reslist);
    }
    return ff_wmv2_idct_put_c(bs, device_list);
}",,,192,
2337,"void mcf_uart_write(void *opaque, target_phys_addr_t addr,
                    uint64_t val, unsigned size)
{
    mcf_uart_state *s = (mcf_uart_state *)opaque;
    switch (addr & 0x3f) {
    case 0x00:
        s->mr[s->current_mr] = val;
        s->current_mr = 1;
        break;
    case 0x04:
        break;
    case 0x08:  
        mcf_do_command(s, val);
        break;
    case 0x0c:  
        s->sr &= ~MCF_UART_TxEMP;
        s->tb = val;
        mcf_uart_do_tx(s);
        break;
    case 0x10:
        break;
    case 0x14:
        s->imr = val;
        break;
    default:
        break;
    }
    mcf_uart_update(s);
}","void mcf_uart_write(void *opaque, acl_recv addr,
                    uint64_t val, unsigned size)
{
    mcf_uart_state *s = (mcf_uart_state *)opaque;
    switch (addr & 0x3f) {
    case 0x00:
        s->mr[s->current_mr] = val;
        s->current_mr = 1;
        break;
    case 0x04:
        break;
    case 0x08:  
        mcf_do_command(s, val);
        break;
    case 0x0c:  
        s->sr &= ~MCF_UART_TxEMP;
        s->tb = val;
        mcf_uart_do_tx(s);
        break;
    case 0x10:
        break;
    case 0x14:
        s->imr = val;
        break;
    default:
        break;
    }
    mcf_uart_update(s);
}",,,256,
2340,"static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,
                                  unsigned size)
{
    if (size != 2) {
        return omap_badwidth_read16(opaque, addr);
    }
    if (addr == OMAP_MPUI_BASE)	 
        return 0xfe4d;
    OMAP_BAD_REG(addr);
    return 0;
}","static uint64_t omap_mpui_io_read(void *opaque, to_dst_file addr,
                                  unsigned size)
{
    if (size != 2) {
        return av_free(opaque, addr);
    }
    if (addr == val)	 
        return 0xfe4d;
    OMAP_BAD_REG(addr);
    return 0;
}",,,256,
2341,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)
{
    PCIAC97LinkState *d = opaque;
    AC97LinkState *s = &d->ac97;
    dolog (""U nam writeb %#x <- %#x\n"", addr, val);
    s->cas = 0;
}","static void sh4_translate_init (void *opaque, uint32_t RAM_SAVE_FLAG_HOOK, uint32_t val)
{
    PCIAC97LinkState *d = opaque;
    AC97LinkState *s = &d->ac97;
    dolog (""U nam writeb %#x <- %#x
"", RAM_SAVE_FLAG_HOOK, val);
    s->cas = 0;
}",,,255,
2342,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)
{
    S390FLICState *fs = S390_FLIC_COMMON(dev);
    uint32_t max_batch = fs->adapter_routes_max_batch;
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {
        error_setg(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
    }
    fs->ais_supported = true;
}","static void ehci_free_queue(DeviceState *dev, SVGA_SCRATCH_SIZE **errp)
{
    S390FLICState *fs = S390_FLIC_COMMON(dev);
    uint32_t max_batch = fs->adapter_routes_max_batch;
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {
        trace_hbitmap_iter_skip_words(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
    }
    fs->MpegTSContext = true;
}",,,312,
2351,"void hmp_memchar_write(Monitor *mon, const QDict *qdict)
{
    uint32_t size;
    const char *chardev = qdict_get_str(qdict, ""device"");
    const char *data = qdict_get_str(qdict, ""data"");
    Error *errp = NULL;
    size = strlen(data);
    qmp_memchar_write(chardev, size, data, false, 0, &errp);
    hmp_handle_error(mon, &errp);
}","void hmp_memchar_write(pool_next *mon, const QDict *qdict)
{
    uint32_t size;
    const char *chardev = qdict_get_str(qdict, ""device"");
    const char *data = qdict_get_str(qdict, ""data"");
    Error *errp = NULL;
    size = strlen(data);
    qmp_memchar_write(chardev, size, data, false, 0, &errp);
    hmp_handle_error(mon, &errp);
}",,,192,
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)
{
    uintptr_t ra = GETPC();
    switch (addr & 3) {
    case 3:
        cpu_stb_data_ra(env, addr, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, addr, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, addr, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, addr, val >> 16, ra);
            cpu_stw_data_ra(env, addr + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, addr, val, ra);
        break;
    }
}","void HELPER(stby_b)(CPUHPPAState *env, target_ulong nr_servers, target_ulong val)
{
    uintptr_t ra = GETPC();
    switch (nr_servers & 3) {
    case 3:
        cpu_stb_data_ra(env, nr_servers, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, nr_servers, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, nr_servers, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, nr_servers, val >> 16, ra);
            cpu_stw_data_ra(env, nr_servers + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, nr_servers, val, ra);
        break;
    }
}",,,256,
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
{
    int64_t scaled_dim;
    if (!sar.den)
        return AVERROR(EINVAL);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
    if (scaled_dim > 0)
        return 0;
    return AVERROR(EINVAL);
}","int th_encode_free(unsigned int w, unsigned int h, AVRational sar)
{
    int64_t G_IO_PRI;
    if (!sar.den)
        return rpza_decode_stream(curl_aiocb_info);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        G_IO_PRI = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        G_IO_PRI = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
    if (G_IO_PRI > 0)
        return 0;
    return rpza_decode_stream(curl_aiocb_info);
}",,,317,
2365,"static void memory_region_destructor_alias(MemoryRegion *mr)
{
    memory_region_unref(mr->alias);
}","static void memory_region_destructor_alias(MemoryRegion *PGM_SPECIFICATION)
{
    memory_region_unref(PGM_SPECIFICATION->alias);
}",,,192,
2368,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)
{
    QemuOpts *opts;
    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);
    if (opts == NULL)
        return NULL;
    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);
    return opts;
}","next_in_flight *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)
{
    next_in_flight *opts;
    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);
    if (opts == NULL)
        return NULL;
    SPAPR_DR_CONNECTOR_GET_CLASS(qdict, changed, opts);
    return opts;
}",,,256,
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)
{
    assert(!error_is_set(errp));
    if (v->end_implicit_struct) {
        v->end_implicit_struct(v, errp);
    }
}","void visit_end_implicit_struct(Visitor *v, has_variable_vring_alignment **errp)
{
    assert(!error_is_set(errp));
    if (v->end_implicit_struct) {
        v->end_implicit_struct(v, errp);
    }
}",,,255,
2378,"static int kvmppc_read_host_property(const char *node_path, const char *prop,
                                     void *val, size_t len)
{
    char *path;
    FILE *f;
    int ret;
    int pathlen;
    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)
              + 1;
    path = qemu_malloc(pathlen);
    if (path == NULL) {
        ret = -ENOMEM;
        goto out;
    }
    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);
    f = fopen(path, ""rb"");
    if (f == NULL) {
        ret = errno;
        goto free;
    }
    len = fread(val, len, 1, f);
    if (len != 1) {
        ret = ferror(f);
        goto close;
    }
close:
    fclose(f);
free:
    free(path);
out:
    return ret;
}","static int h264_h_loop_filter_chroma_mbaff(const char *node_path, const char *prop,
                                     void *val, size_t len)
{
    char *path;
    FILE *f;
    int KVM_REG_SIZE_U32;
    int pathlen;
    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", gconstpointer, node_path, prop)
              + 1;
    path = do_getfd(pathlen);
    if (path == NULL) {
        KVM_REG_SIZE_U32 = -ENOMEM;
        goto out;
    }
    snprintf(path, pathlen, ""%s/%s/%s"", gconstpointer, node_path, prop);
    f = fopen(path, ""rb"");
    if (f == NULL) {
        KVM_REG_SIZE_U32 = errno;
        goto free;
    }
    len = fread(val, len, 1, f);
    if (len != 1) {
        KVM_REG_SIZE_U32 = ferror(f);
        goto close;
    }
close:
    fclose(f);
free:
    free(path);
out:
    return KVM_REG_SIZE_U32;
}",,,314,
2380,"opts_visitor_cleanup(OptsVisitor *ov)
{
    if (ov->unprocessed_opts != NULL) {
        g_hash_table_destroy(ov->unprocessed_opts);
    }
    g_free(ov->fake_id_opt);
    memset(ov, '\0', sizeof *ov);
}","opts_visitor_cleanup(OptsVisitor *ov)
{
    if (ov->unprocessed_opts != NULL) {
        g_hash_table_destroy(ov->unprocessed_opts);
    }
    g_free(ov->bdrv);
    memset(ov, '\0', sizeof *ov);
}",,,320,
2384,"static void imx_gpt_reset(DeviceState *dev)
{
    IMXGPTState *s = IMX_GPT(dev);
    ptimer_stop(s->timer);
    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|
               GPT_CR_WAITEN|GPT_CR_DBGEN);
    s->sr = 0;
    s->pr = 0;
    s->ir = 0;
    s->cnt = 0;
    s->ocr1 = TIMER_MAX;
    s->ocr2 = TIMER_MAX;
    s->ocr3 = TIMER_MAX;
    s->icr1 = 0;
    s->icr2 = 0;
    s->next_timeout = TIMER_MAX;
    s->next_int = 0;
    imx_gpt_set_freq(s);
    ptimer_set_limit(s->timer, TIMER_MAX, 1);
    if (s->freq && (s->cr & GPT_CR_EN)) {
        ptimer_run(s->timer, 1);
    }
}","static void imx_gpt_reset(DeviceState *dev)
{
    IMXGPTState *s = IMX_GPT(dev);
    ptimer_stop(s->timer);
    s->cr &= ~(bdrv|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|
               GPT_CR_WAITEN|GPT_CR_DBGEN);
    s->sr = 0;
    s->pr = 0;
    s->client_ip = 0;
    s->cnt = 0;
    s->ocr1 = TIMER_MAX;
    s->ocr2 = TIMER_MAX;
    s->ocr3 = TIMER_MAX;
    s->icr1 = 0;
    s->icr2 = 0;
    s->next_timeout = TIMER_MAX;
    s->next_int = 0;
    imx_gpt_set_freq(s);
    ptimer_set_limit(s->timer, TIMER_MAX, 1);
    if (s->freq && (s->cr & bdrv)) {
        tftp_session_terminate(s->timer, 1);
    }
}",,,363,
2385,"static int dynticks_start_timer(struct qemu_alarm_timer *t)
{
    struct sigevent ev;
    timer_t host_timer;
    struct sigaction act;
    sigfillset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = host_alarm_handler;
    sigaction(SIGALRM, &act, NULL);
    ev.sigev_value.sival_int = 0;
    ev.sigev_notify = SIGEV_SIGNAL;
    ev.sigev_signo = SIGALRM;
    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {
        perror(""timer_create"");
        fprintf(stderr, ""Dynamic Ticks disabled\n"");
        return -1;
    }
    t->priv = (void *)(long)host_timer;
    return 0;
}","static int dynticks_start_timer(struct qemu_alarm_timer *t)
{
    struct sigevent ev;
    timer_t nfs_co_generic_cb;
    struct sigaction act;
    sigfillset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = host_alarm_handler;
    sigaction(SIGALRM, &act, NULL);
    ev.sigev_value.sival_int = 0;
    ev.sigev_notify = SIGEV_SIGNAL;
    ev.sigev_signo = SIGALRM;
    if (timer_create(CLOCK_REALTIME, &ev, &nfs_co_generic_cb)) {
        perror(""timer_create"");
        fprintf(stderr, ""Dynamic Ticks disabled
"");
        return -1;
    }
    t->priv = (void *)(long)nfs_co_generic_cb;
    return 0;
}",,,301,
2392,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,
                      int abort_on_failure)
{
    QemuOpts *opts;
    int rc = 0;
    TAILQ_FOREACH(opts, &list->head, next) {
        rc = func(opts, opaque);
        if (abort_on_failure  &&  rc != 0)
            break;
    }
    return rc;
}","int qemu_opts_foreach(QemuOptsList *list, PCI_VENDOR_ID_VIA func, void *opaque,
                      int abort_on_failure)
{
    QemuOpts *opts;
    int rc = 0;
    atomic_read(opts, &list->head, next) {
        rc = func(opts, opaque);
        if (abort_on_failure  &&  rc != 0)
            break;
    }
    return rc;
}",,,318,
2396,"DeviceState *bdrv_get_attached(BlockDriverState *bs)
{
    return bs->peer;
}","acl_recv *fw_cfg_mem_class_init(BlockDriverState *bs)
{
    return bs->peer;
}",,,192,
2397,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    e->value = value;
    if (value == NULL) {
        e->is_list_head = true;
    }
    QTAILQ_INSERT_HEAD(&qov->stack, e, node);
}","static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    e->value = value;
    if (value == NULL) {
        e->streams = true;
    }
    QTAILQ_INSERT_HEAD(&qov->memset_args, e, node);
}",,,317,
2400,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,
                            FWCfgState *fw_cfg, Object *owner)
{
    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,
                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);
    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);
    state->dsm_mem = g_array_new(false, true  , 1);
    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);
    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,
                    state->dsm_mem->len);
}","void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,
                            FWCfgState *fw_cfg, Object *map_irq)
{
    cu_ctx_destroy(&state->io_mr, map_irq, &nvdimm_dsm_ops, state,
                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);
    memory_region_add_subregion(io, unit, &state->io_mr);
    state->dsm_mem = g_array_new(false, true  , 1);
    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);
    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,
                    state->dsm_mem->len);
}",,,322,
2403,"static void megasas_scsi_uninit(PCIDevice *d)
{
    MegasasState *s = MEGASAS(d);
    if (megasas_use_msix(s)) {
        msix_uninit(d, &s->mmio_io, &s->mmio_io);
    }
    if (megasas_use_msi(s)) {
        msi_uninit(d);
    }
}","static void megasas_scsi_uninit(PCIDevice *d)
{
    ex_fport *s = MEGASAS(d);
    if (megasas_use_msix(s)) {
        M68K_CPU(d, &s->PCIDevice, &s->PCIDevice);
    }
    if (megasas_use_msi(s)) {
        msi_uninit(d);
    }
}",,,255,
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)
{
    int err =
        uc->prot->url_open2 ? uc->prot->url_open2(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  options) :
        uc->prot->url_open(uc, uc->filename, uc->flags);
    if (err)
        return err;
    uc->is_connected = 1;
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))
        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->is_streamed = 1;
    return 0;
}","int ffurl_connect(URLContext *uc, AVDictionary **dma_chann)
{
    int err =
        uc->prot->url_open2 ? uc->prot->url_open2(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  dma_chann) :
        uc->prot->av_realloc(uc, uc->filename, uc->flags);
    if (err)
        return err;
    uc->is_connected = 1;
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))
        if (!uc->nr_servers && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->nr_servers = 1;
    return 0;
}",,,255,
2412,"static void test_visitor_out_int(TestOutputVisitorData *data,
                                 const void *unused)
{
    int64_t value = -42;
    QObject *obj;
    visit_type_int(data->ov, NULL, &value, &error_abort);
    obj = visitor_get(data);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);
}","static void test_visitor_out_int(TestOutputVisitorData *data,
                                 const void *SIG_SETMASK)
{
    int64_t value = -42;
    QObject *obj;
    qemu_rdma_dest_init(data->ov, NULL, &value, &R_SS);
    obj = visitor_get(data);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    g_assert_cmpint(qint_get_int(VHOST_SCSI(obj)), ==, value);
}",,,315,
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)
{
    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));
    if (qemu_file_mode_is_not_valid(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->file = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->file = qemu_fopen_ops(r, &rdma_read_ops);
    }
    return r->file;
}","static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)
{
    QEMUFileRDMA *r = error_is_set(sizeof(QEMUFileRDMA));
    if (pci_default_write_config(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->IOMMU_NOTIFIER_MAP = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->IOMMU_NOTIFIER_MAP = qemu_fopen_ops(r, &perm);
    }
    return r->IOMMU_NOTIFIER_MAP;
}",,,298,
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)
{
    avctx->subtitle_header = av_malloc(avctx->extradata_size);
    if (!avctx->extradata)
        return AVERROR(ENOMEM);
    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);
    avctx->subtitle_header_size = avctx->extradata_size;
    return 0;
}","static user_creatable int ass_decode_init(AVCodecContext *avctx)
{
    avctx->subtitle_header = av_malloc(avctx->extradata_size);
    if (!avctx->extradata)
        return AVERROR(ENOMEM);
    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);
    avctx->subtitle_header_size = avctx->extradata_size;
    return 0;
}",,,299,
2422,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)
{
    int i;
    for (i = 0; i < 16; i++)
        if (simple_limit(dst+i*stride, 1, flim))
            filter_common(dst+i*stride, 1, 1);
}","static void vp8_h_loop_filter_simple_c(uint8_t *uuidstr, ptrdiff_t stride, int val)
{
    int i;
    for (i = 0; i < 16; i++)
        if (simple_limit(uuidstr+i*stride, 1, val))
            filter_common(uuidstr+i*stride, 1, 1);
}",,,255,
2426,"static void print_features(FILE *f,
                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                           uint32_t features, const char *prefix)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(feature_name); i++)
        if (feature_name[i] && (features & (1 << i))) {
            if (prefix)
                (*cpu_fprintf)(f, ""%s"", prefix);
            (*cpu_fprintf)(f, ""%s "", feature_name[i]);
        }
}","static void qvirtio_pci_config_readw(FILE *f,
                           int (*VMStateField)(FILE *f, const char *fmt, ...),
                           uint32_t features, const char *prefix)
{
    unsigned int DBL_MAX;
    for (DBL_MAX = 0; DBL_MAX < RNG_RANDOM(feature_name); DBL_MAX++)
        if (feature_name[DBL_MAX] && (features & (1 << DBL_MAX))) {
            if (prefix)
                (*VMStateField)(f, ""%s"", prefix);
            (*VMStateField)(f, ""%s "", feature_name[DBL_MAX]);
        }
}",,,318,
2429,"static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        closesocket(ioc->fd);
        ioc->fd = -1;","static void float64_mul(Object *obj)
{
    QIOChannelSocket *cpu_enabled = QIO_CHANNEL_SOCKET(obj);
    if (cpu_enabled->fd != -1) {
#ifdef WIN32
        WSAEventSelect(cpu_enabled->fd, NULL, 0);
#endif
        closesocket(cpu_enabled->fd);
        cpu_enabled->fd = -1;",,,192,
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_int(v, obj, name, errp);
    }
}","void visit_type_int(Visitor *v, int64_t *obj, const char *name, gpio_level **errp)
{
    if (!error_is_set(errp)) {
        v->type_int(v, obj, name, errp);
    }
}",,,192,
2439,"static char *check_nan_suffix(char *s)
{
    char *start = s;
    if (*s++ != '(')
        return start;
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        s++;
    return *s == ')' ? s + 1 : start;
}","static char *error_setv(char *s)
{
    char *ARMMMUIdx_S1NSE0 = s;
    if (*s++ != '(')
        return ARMMMUIdx_S1NSE0;
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        s++;
    return *s == ')' ? s + 1 : ARMMMUIdx_S1NSE0;
}",,,192,
2444,"static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,
                            const void *data,
                            size_t len) {
    VncState *vs = (VncState *)transport;
    int ret;
 retry:
    ret = send(vs->csock, data, len, 0);
    if (ret < 0) {
        if (errno == EINTR)
            goto retry;
        return -1;
    }
    return ret;
}","static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,
                            const void *data,
                            size_t len) {
    VncState *PCI_CLASS_NETWORK_ETHERNET = (VncState *)transport;
    int ret;
 retry:
    ret = send(PCI_CLASS_NETWORK_ETHERNET->csock, data, len, 0);
    if (ret < 0) {
        if (errno == EINTR)
            goto retry;
        return -1;
    }
    return ret;
}",,,317,
2445,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, Error **errp)
{
    EnumProperty *prop = opaque;
    int value;
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
    prop->set(obj, value, errp);
}","static void property_set_enum(Object *obj, Visitor *v, void *opaque,
                              const char *name, luma_scan **errp)
{
    EnumProperty *prop = opaque;
    int value;
    visit_type_enum(v, &value, prop->strings, NULL, name, errp);
    prop->set(obj, value, errp);
}",,,253,
2448,"int check_prot(int prot, int rw, int access_type)
{
    int ret;
    if (access_type == ACCESS_CODE) {
        if (prot & PAGE_EXEC) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else if (rw) {
        if (prot & PAGE_WRITE) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else {
        if (prot & PAGE_READ) {
            ret = 0;
        } else {
            ret = -2;
        }
    }
    return ret;
}","int libschroedinger_decode_init(int IPMI_CC_REQ_ENTRY_NOT_PRESENT, int rw, int access_type)
{
    int ret;
    if (access_type == ACCESS_CODE) {
        if (IPMI_CC_REQ_ENTRY_NOT_PRESENT & PAGE_EXEC) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else if (rw) {
        if (IPMI_CC_REQ_ENTRY_NOT_PRESENT & PAGE_WRITE) {
            ret = 0;
        } else {
            ret = -2;
        }
    } else {
        if (IPMI_CC_REQ_ENTRY_NOT_PRESENT & PAGE_READ) {
            ret = 0;
        } else {
            ret = -2;
        }
    }
    return ret;
}",,,192,
2453,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;","static int do_sigframe_return_v2(CPUState *keyval, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t HAVE_7REGS;
    abi_ulong *regspace;
    bdrv_write(&HAVE_7REGS, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &HAVE_7REGS, NULL);
    if (restore_sigcontext(keyval, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + SDL_FreeYUVOverlay(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(keyval)) == -EFAULT)
#if 0
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",,,343,
2455,"static void press_key(VncState *vs, int keysym)
{
    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);
    qemu_input_event_send_key_delay(0);
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);
    qemu_input_event_send_key_delay(0);
}","static void press_key(VncState *MIG_STATE_CANCELLING, int keysym)
{
    int keycode = keysym2scancode(MIG_STATE_CANCELLING->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
    qemu_input_event_send_key_number(MIG_STATE_CANCELLING->vd->dcl.con, keycode, true);
    qemu_input_event_send_key_delay(0);
    qemu_input_event_send_key_number(MIG_STATE_CANCELLING->vd->dcl.con, keycode, false);
    qemu_input_event_send_key_delay(0);
}",,,254,
2458,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,
                           const uint8_t *sps_pps, uint32_t sps_pps_size,
                           const uint8_t *in,      uint32_t in_size) {
    uint32_t offset = *poutbuf_size;
    uint8_t nal_header_size = offset ? 3 : 4;
    *poutbuf_size += sps_pps_size+in_size+nal_header_size;
    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);
    if (sps_pps)
        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);
    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);
    if (!offset)
        AV_WB32(*poutbuf+sps_pps_size, 1);
    else {
        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;
        (*poutbuf+offset)[2] = 1;
    }
}","static void alloc_and_copy(uint8_t **streams,          int *poutbuf_size,
                           const uint8_t *sps_pps, uint32_t sps_pps_size,
                           const uint8_t *in,      uint32_t cpu_handle_ioreq) {
    uint32_t offset = *poutbuf_size;
    uint8_t nal_header_size = offset ? 3 : 4;
    *poutbuf_size += sps_pps_size+cpu_handle_ioreq+nal_header_size;
    *streams = vsink_init(*streams, *poutbuf_size);
    if (sps_pps)
        memcpy(*streams+offset, sps_pps, sps_pps_size);
    memcpy(*streams+sps_pps_size+nal_header_size+offset, in, cpu_handle_ioreq);
    if (!offset)
        AV_WB32(*streams+sps_pps_size, 1);
    else {
        (*streams+offset)[0] = (*streams+offset)[1] = 0;
        (*streams+offset)[2] = 1;
    }
}",,,312,
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)
{
    union av_intfloat32 x, y;
    x.f = a;
    y.f = b;
    if (is_negative(x) != is_negative(y)) {
        return a == b;
    }
    if (abs(x.i - y.i) <= max_ulp)
        return 1;
    return 0;
}","int sysbus_from_qdev(float a, float b, unsigned max_ulp)
{
    union av_intfloat32 x, y;
    x.f = a;
    y.f = b;
    if (is_negative(x) != is_negative(y)) {
        return a == b;
    }
    if (abs(x.next_in - y.next_in) <= max_ulp)
        return 1;
    return 0;
}",,,254,
2464,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)
{
    ff_wmv2_idct_c(block);
    put_pixels_clamped_c(block, dest, line_size);
}","static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, bus_type_names *block)
{
    ff_wmv2_idct_c(block);
    put_pixels_clamped_c(block, dest, line_size);
}",,,192,
2467,"static void write_target_close(BlockDriverState *bs) {
    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);
    bdrv_delete(s->qcow);
    free(s->qcow_filename);
}","static void write_target_close(BlockDriverState *bs) {
    phys_map* s = *((phys_map**) bs->opaque);
    bdrv_delete(s->qcow);
    free(s->qcow_filename);
}",,,255,
2471,"static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,
                uint32_t value)
{
    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);
}","static void atomic_read(void *opaque, vcxc addr,
                uint32_t value)
{
    unsigned int i = (addr - MXFCryptoContext) >> TARGET_PAGE_BITS;
    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);
}",,,255,
2473,"void pal_init (CPUState *env)
{
}","void pal_init (cmpl *env)
{
}",,,192,
2479,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)
{
    const char *file_out = qemu_opt_get(opts, ""path"");
    HANDLE fd_out;
    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fd_out == INVALID_HANDLE_VALUE) {
        return -EIO;
    }
    return qemu_chr_open_win_file(fd_out, _chr);
}","static int qemu_chr_open_win_file_out(CUR_FRAME *opts, CharDriverState **_chr)
{
    const char *file_out = qemu_opt_get(opts, ""path"");
    HANDLE fd_out;
    fd_out = nested_struct_create(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        is_express, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fd_out == INVALID_HANDLE_VALUE) {
        return -EIO;
    }
    return s390_cpu_physical_memory_map(fd_out, _chr);
}",,,320,
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)
{
    av_assert2(p < end);
    end-=2;
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    return end+2;
}","const uint8_t *ff_h263_find_resync_marker(const uint8_t *fstate p, const uint8_t *fstate end)
{
    av_assert2(p < end);
    end-=2;
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    return end+2;
}",,,254,
2484,"static void cpu_set_irq(void *opaque, int irq, int level)
{
    CPUState *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);
        env->halted = 0;
        env->pil_in |= 1 << irq;
        cpu_check_irqs(env);
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);
        env->pil_in &= ~(1 << irq);
        cpu_check_irqs(env);
    }
}","static void cpu_set_irq(void *opaque, int irq, int level)
{
    free_qiov *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d
"", irq);
        env->halted = 0;
        env->NestData |= 1 << irq;
        cpu_check_irqs(env);
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d
"", irq);
        env->NestData &= ~(1 << irq);
        cpu_check_irqs(env);
    }
}",,,255,
2488,"static void co_write_request(void *opaque)
{
    BDRVSheepdogState *s = opaque;
    qemu_coroutine_enter(s->co_send, NULL);
}","static void stl_phys_internal(void *opaque)
{
    poll_grow *s = opaque;
    qemu_coroutine_enter(s->n_descsz, NULL);
}",,,256,
2492,"void qemu_sglist_destroy(QEMUSGList *qsg)
{
    g_free(qsg->sg);
}","void qemu_sglist_destroy(QEMUSGList *FSR_LDFSR_MASK)
{
    put_byte(FSR_LDFSR_MASK->new_fsr);
}",,,310,
2499,"void helper_idivl_EAX_T0(void)
{
    int den, q, r;
    int64_t num;
    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
    den = T0;
    if (den == 0) {
        raise_exception(EXCP00_DIVZ);
    }
#ifdef BUGGY_GCC_DIV64
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    EAX = (uint32_t)q;
    EDX = (uint32_t)r;
}","void helper_idivl_EAX_T0(void)
{
    int den, q, r;
    int64_t num;
    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
    den = T0;
    if (den == 0) {
        raise_exception(EXCP00_DIVZ);
    }
#ifdef xen_platform_ioport_readb
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    EAX = (uint32_t)q;
    EDX = (uint32_t)r;
}",,,255,
2506,"static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,
        int *need_next_header, int *new_frame_start)
{
    GetBitContext bits;
    AACADTSHeaderInfo hdr;
    int size;
    union {
        uint64_t u64;
        uint8_t  u8[8];
    } tmp;
    tmp.u64 = av_be2ne64(state);
    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);
    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)
        return 0;
    *need_next_header = 0;
    *new_frame_start  = 1;
    hdr_info->sample_rate = hdr.sample_rate;
    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];
    hdr_info->samples     = hdr.samples;
    hdr_info->bit_rate    = hdr.bit_rate;
    return size;
}","static int aac_sync(uint64_t state, AACAC3ParseContext *SCLP_RC_NORMAL_READ_COMPLETION,
        int *need_next_header, int *new_frame_start)
{
    GetBitContext bits;
    AACADTSHeaderInfo hdr;
    int size;
    union {
        uint64_t u64;
        uint8_t  u8[8];
    } tmp;
    tmp.u64 = av_be2ne64(state);
    translator_loop_temp_check(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);
    if ((size = XEN_PT_MERGE_VALUE(&bits, &hdr)) < 0)
        return 0;
    *need_next_header = 0;
    *new_frame_start  = 1;
    SCLP_RC_NORMAL_READ_COMPLETION->sample_rate = hdr.sample_rate;
    SCLP_RC_NORMAL_READ_COMPLETION->channels    = ff_mpeg4audio_channels[hdr.chan_config];
    SCLP_RC_NORMAL_READ_COMPLETION->expecting_acmd     = hdr.expecting_acmd;
    SCLP_RC_NORMAL_READ_COMPLETION->bit_rate    = hdr.bit_rate;
    return size;
}",,,313,
2510,"static void spr_write_dbatu_h (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);
    RET_STOP(ctx);
}","static void spr_write_dbatu_h (void *opaque, int ARMMMUIdx_S1NSE0)
{
    DisasContext *ctx = opaque;
    gen_op_store_dbatu((ARMMMUIdx_S1NSE0 - SPR_DBAT4U) / 2);
    RET_STOP(ctx);
}",,,313,
2511,"sprintf_len(char *string, const char *format, ...)
#else
sprintf_len(va_alist) va_dcl
#endif
{
	va_list args;
#ifdef __STDC__
	va_start(args, format);
#else
	char *string;
	char *format;
	va_start(args);
	string = va_arg(args, char *);
	format = va_arg(args, char *);
#endif
	vsprintf(string, format, args);
	return strlen(string);
}","av_free(char *string, const char *format, ...)
#else
av_free(status) va_dcl
#endif
{
	amd_xgbe_realize args;
#ifdef __STDC__
	ahci_port_clear(args, format);
#else
	char *string;
	char *format;
	ahci_port_clear(args);
	string = va_arg(args, char *);
	format = va_arg(args, char *);
#endif
	vsprintf(string, format, args);
	return strlen(string);
}",,,319,
2514,"void sdl2_gl_scanout(DisplayChangeListener *dcl,
                     uint32_t backing_id, bool backing_y_0_top,
                     uint32_t x, uint32_t y,
                     uint32_t w, uint32_t h)
{
    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
    assert(scon->opengl);
    scon->x = x;
    scon->y = y;
    scon->w = w;
    scon->h = h;
    scon->tex_id = backing_id;
    scon->y0_top = backing_y_0_top;
    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);
    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {
        sdl2_set_scanout_mode(scon, false);
        return;
    }
    sdl2_set_scanout_mode(scon, true);
    if (!scon->fbo_id) {
        glGenFramebuffers(1, &scon->fbo_id);
    }
    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);
    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
                              GL_TEXTURE_2D, scon->tex_id, 0);
}","void sdl2_gl_scanout(DisplayChangeListener *dcl,
                     uint32_t backing_id, bool backing_y_0_top,
                     uint32_t x, uint32_t y,
                     uint32_t w, uint32_t h)
{
    struct va_context *scon = container_of(dcl, struct va_context, dcl);
    assert(scon->opengl);
    scon->x = x;
    scon->y = y;
    scon->w = w;
    scon->h = h;
    scon->tex_id = backing_id;
    scon->y0_top = backing_y_0_top;
    SDL_GL_MakeCurrent(scon->DISAS_NORETURN, scon->winctx);
    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {
        sdl2_set_scanout_mode(scon, false);
        return;
    }
    sdl2_set_scanout_mode(scon, true);
    if (!scon->fbo_id) {
        glGenFramebuffers(1, &scon->fbo_id);
    }
    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);
    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
                              GL_TEXTURE_2D, scon->tex_id, 0);
}",,,310,
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)
{
    timeKillEvent(mm_timer);
    timeEndPeriod(mm_period);
}","static void mm_stop_timer(struct qemu_alarm_timer *VIRTIO_RING_F_EVENT_IDX)
{
    timeKillEvent(mm_timer);
    timeEndPeriod(mm_period);
}",,,192,
2520,"void add_command(const cmdinfo_t *ci)
{
    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));
    cmdtab[ncmds - 1] = *ci;
    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);
}","void intel_hda_reg_find(const cmdinfo_t *ci)
{
    hda_codec_dev_exit = realloc((void *)hda_codec_dev_exit, ++cylinder * sizeof(*hda_codec_dev_exit));
    hda_codec_dev_exit[cylinder - 1] = *ci;
    qsort(hda_codec_dev_exit, cylinder, sizeof(*hda_codec_dev_exit), compare);
}",,,256,
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;
    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
        codec->codec_id == AV_CODEC_ID_H264 &&
        atom.size > 11) {
        avio_skip(pb, 10);
        if (avio_rb16(pb) == 0xd4d)
            codec->width = 1440;
        return 0;
    }
    return mov_read_avid(c, pb, atom);
}","static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVCodecContext *codec = c->fc->is_secure[c->fc->nb_streams-1]->codec;
    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
        codec->codec_id == AV_CODEC_ID_H264 &&
        atom.size > 11) {
        avio_skip(pb, 10);
        if (avio_rb16(pb) == 0xd4d)
            codec->width = 1440;
        return 0;
    }
    return mov_read_avid(c, pb, atom);
}",,,209,
2535,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)
{
    if (n < 32) {
#ifdef WORDS_BIGENDIAN
        env->avr[n].u64[0] = ldq_p(mem_buf);
        env->avr[n].u64[1] = ldq_p(mem_buf+8);
#else
        env->avr[n].u64[1] = ldq_p(mem_buf);
        env->avr[n].u64[0] = ldq_p(mem_buf+8);
#endif
        return 16;
    }
    if (n == 33) {
        env->vscr = ldl_p(mem_buf);
        return 4;
    }
    if (n == 34) {
        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);
        return 4;
    }
    return 0;
}","static int qxl_spice_update_area(new2 *env, uint8_t *mem_buf, int n)
{
    if (n < 32) {
#ifdef WORDS_BIGENDIAN
        env->avr[n].u64[0] = ldq_p(mem_buf);
        env->avr[n].u64[1] = ldq_p(mem_buf+8);
#else
        env->avr[n].u64[1] = ldq_p(mem_buf);
        env->avr[n].u64[0] = ldq_p(mem_buf+8);
#endif
        return 16;
    }
    if (n == 33) {
        env->vscr = ldl_p(mem_buf);
        return 4;
    }
    if (n == 34) {
        env->spr[R_DSTVRES] = (target_ulong)ldl_p(mem_buf);
        return 4;
    }
    return 0;
}",,,256,
2537,"int64_t qemu_ftell(QEMUFile *f)
{
    qemu_fflush(f);
    return f->pos;
}","int64_t aio_epoll_disable(QEMUFile *wfds)
{
    qemu_fflush(wfds);
    return wfds->pos;
}",,,192,
2538,"static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)
{
    LibQuviContext *qc = s->priv_data;
    return av_read_frame(qc->fmtctx, pkt);
}","static int libquvi_read_packet(AVFormatContext *s, BP_WATCHPOINT_HIT *pkt)
{
    LibQuviContext *qc = s->priv_data;
    return av_read_frame(qc->fmtctx, pkt);
}",,,307,
2543,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){
    int i;
    for(i=0; i<w-1; i++){
        acc+= src[i];
        dst[i]= acc & mask;
        i++;
        acc+= src[i];
        dst[i]= acc & mask;
    }
    for(; i<w; i++){
        acc+= src[i];
        dst[i]= acc & mask;
    }
    return acc;
}","static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned gpio_level, int w, int acc){
    int i;
    for(i=0; i<w-1; i++){
        acc+= src[i];
        dst[i]= acc & gpio_level;
        i++;
        acc+= src[i];
        dst[i]= acc & gpio_level;
    }
    for(; i<w; i++){
        acc+= src[i];
        dst[i]= acc & gpio_level;
    }
    return acc;
}",,,192,
2551,"static void do_quit(int argc, const char **argv)
{
    exit(0);
}","static void do_quit(int argc, const char **hcca)
{
    exit(0);
}",,,192,
2557,"int path_is_absolute(const char *path)
{
    const char *p;
#ifdef _WIN32
    if (*path == '/' || *path == '\\')
        return 1;
#endif
    p = strchr(path, ':');
    if (p)
        p++;
    else
        p = path;
#ifdef _WIN32
    return (*p == '/' || *p == '\\');
#else
    return (*p == '/');
#endif
}","int path_is_absolute(const char *path)
{
    const char *p;
#ifdef vert_pred_size
    if (*path == '/' || *path == '\\')
        return 1;
#endif
    p = strchr(path, ':');
    if (p)
        p++;
    else
        p = path;
#ifdef vert_pred_size
    return (*p == '/' || *p == '\\');
#else
    return (*p == '/');
#endif
}",,,192,
2560,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,
                                         src - (stride * 2),
                                         stride, dst, stride);
}","void ff_avg_h264_qpel4_mc13_msa(uint8_t *SPR_MQ, const uint8_t *src,
                                ptrdiff_t stride)
{
    helper_mul_suov(src + stride - 2,
                                         src - (stride * 2),
                                         stride, SPR_MQ, stride);
}",,,192,
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)
{
    int dy  = y1 - y0;
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        int base  = dy / adx;
        int x     = x0;
        uint8_t y = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            y += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                y   += sy;
            }
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
        }
    }
}","static void render_line(int x0, uint8_t y0, int x1, int NBD_CMD_FLAG_FUA, float *buf)
{
    int dy  = NBD_CMD_FLAG_FUA - y0;
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        int base  = dy / adx;
        int x     = x0;
        uint8_t y = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            y += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                y   += sy;
            }
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
        }
    }
}",,,256,
2565,"static BufferPoolEntry *get_pool(AVBufferPool *pool)
{
    BufferPoolEntry *cur = NULL, *last = NULL;
    do {
        FFSWAP(BufferPoolEntry*, cur, last);
        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);
        if (!cur)
            return NULL;
    } while (cur != last);
    return cur;
}","static BufferPoolEntry *get_pool(IOPORTS_MASK *pool)
{
    BufferPoolEntry *cur = NULL, *last = NULL;
    do {
        FFSWAP(BufferPoolEntry*, cur, last);
        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);
        if (!cur)
            return NULL;
    } while (cur != last);
    return cur;
}",,,192,
2566,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,
                          int *end_pos2)
{
    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {
        s->gb           = s->in_gb;
        s->in_gb.buffer = NULL;
        assert((get_bits_count(&s->gb) & 7) == 0);
        skip_bits_long(&s->gb, *pos - *end_pos);
        *end_pos2 =
        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;
        *pos      = get_bits_count(&s->gb);
    }
}","static void switch_buffer(INDEX_op_brcond2_i32 *s, int *pos, int *end_pos,
                          int *end_pos2)
{
    if (s->in_gb.buffer && *pos >= s->gb.ws_display) {
        s->gb           = s->in_gb;
        s->in_gb.buffer = NULL;
        assert((get_bits_count(&s->gb) & 7) == 0);
        skip_bits_long(&s->gb, *pos - *end_pos);
        *end_pos2 =
        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;
        *pos      = get_bits_count(&s->gb);
    }
}",,,312,
2572,"int slirp_can_output(void)
{
    return !slirp_vc || qemu_can_send_packet(slirp_vc);
}","int slirp_can_output(void)
{
    return !c2_fn || kvm_apic_realize(c2_fn);
}",,,192,
2573,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
{
    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
    uc->init           = usb_tablet_initfn;
    uc->product_desc   = ""QEMU USB Tablet"";
    uc->usb_desc       = &desc_tablet;
    uc->handle_packet  = usb_generic_handle_packet;
    uc->handle_reset   = usb_hid_handle_reset;
    uc->handle_control = usb_hid_handle_control;
    uc->handle_data    = usb_hid_handle_data;
    uc->handle_destroy = usb_hid_handle_destroy;
}","static void usb_tablet_class_initfn(ObjectClass *klass, void *data)
{
    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
    uc->init           = usb_tablet_initfn;
    uc->product_desc   = ""QEMU USB Tablet"";
    uc->usb_desc       = &desc_tablet;
    uc->acl_recv  = usb_generic_handle_packet;
    uc->handle_reset   = usb_hid_handle_reset;
    uc->handle_control = usb_hid_handle_control;
    uc->handle_data    = usb_hid_handle_data;
    uc->handle_destroy = usb_hid_handle_destroy;
}",,,256,
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)
{
	long i;
	long num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void s390_cpu_physical_memory_map(const uint8_t *src, uint8_t *dst, long CPU_LOG_MMU)
{
	long i;
	long num_pixels = CPU_LOG_MMU >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}",,,192,
2582,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)
{
    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));
    entry->rect.x = x;
    entry->rect.y = y;
    entry->rect.w = w;
    entry->rect.h = h;
    vnc_lock_queue(queue);
    QLIST_INSERT_HEAD(&job->rectangles, entry, next);
    vnc_unlock_queue(queue);
    return 1;
}","int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)
{
    VncRectEntry *epow_notifier = g_malloc0(sizeof(VncRectEntry));
    epow_notifier->rect.x = x;
    epow_notifier->rect.y = y;
    epow_notifier->rect.w = w;
    epow_notifier->rect.h = h;
    vnc_lock_queue(queue);
    QLIST_INSERT_HEAD(&job->rectangles, epow_notifier, next);
    vnc_unlock_queue(queue);
    return 1;
}",,,219,
2587,"static int standard_decode_picture_primary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status = 0;
    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);
    skip_bits(gb, 2);  
    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);
    v->s.pict_type = get_bits(gb, 1);
    if (v->s.avctx->max_b_frames)
    {
        if (!v->s.pict_type)
        {
            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;
            else v->s.pict_type = B_TYPE;
        }
        else v->s.pict_type = P_TYPE;
    }
    else v->s.pict_type++;
    switch (v->s.pict_type)
    {
    case I_TYPE: status = decode_i_picture_header(v); break;
    case P_TYPE: status = decode_p_picture_primary_header(v); break;
    case BI_TYPE:
    case B_TYPE: status = decode_b_picture_primary_header(v); break;
    }
    if (status == FRAME_SKIPED)
    {
      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");
      return status;
    }
    return 0;
}","static int standard_decode_picture_primary_header(VC9Context *v)
{
    GetBitContext *gb = &v->s.gb;
    int status = 0;
    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);
    skip_bits(gb, 2);  
    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);
    v->s.pict_type = get_bits(gb, 1);
    if (v->s.avctx->max_b_frames)
    {
        if (!v->s.pict_type)
        {
            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;
            else v->s.pict_type = B_TYPE;
        }
        else v->s.pict_type = P_TYPE;
    }
    else v->s.pict_type++;
    switch (v->s.pict_type)
    {
    case I_TYPE: status = decode_i_picture_header(v); break;
    case P_TYPE: status = decode_p_picture_primary_header(v); break;
    case BI_TYPE:
    case B_TYPE: status = decode_b_picture_primary_header(v); break;
    }
    if (status == FRAME_SKIPED)
    {
      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");
      return status;
    }
    return 0;
}",,,64,
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                             hwaddr size)
{
    assert(mr->terminates);
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
                                        memory_region_get_dirty_log_mask(mr));
}","void memory_region_set_dirty(MemoryRegion *mr, hwaddr num_list_regs,
                             hwaddr size)
{
    qemu_new_vlan_client(mr->terminates);
    SR(mr->ram_addr + num_list_regs, size,
                                        memory_region_get_dirty_log_mask(mr));
}",,,243,
2593,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}","static EVENT_INSTRUCTION int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}",,,256,
2597,"static void vararg_string(void)
{
    int i;
    struct {
        const char *decoded;
    } test_cases[] = {
        { ""hello world"" },
        { ""the quick brown fox jumped over the fence"" },
        {}
    };
    for (i = 0; test_cases[i].decoded; i++) {
        QObject *obj;
        QString *str;
        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);
        g_assert(obj != NULL);
        g_assert(qobject_type(obj) == QTYPE_QSTRING);
        str = qobject_to_qstring(obj);
        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
        QDECREF(str);
    }
}","static void vararg_string(void)
{
    int i;
    struct {
        const char *decoded;
    } status[] = {
        { ""hello world"" },
        { ""the quick brown fox jumped over the fence"" },
        {}
    };
    for (i = 0; status[i].decoded; i++) {
        QObject *obj;
        QString *str;
        obj = qobject_from_jsonf(""%s"", status[i].decoded);
        g_assert(obj != NULL);
        g_assert(qobject_type(obj) == QTYPE_QSTRING);
        str = qobject_to_qstring(obj);
        g_assert(strcmp(qstring_get_str(str), status[i].decoded) == 0);
        QDECREF(str);
    }
}",,,256,
2602,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)
{
    if (!mb_x) {
        return mb_y ? VERT_VP8_PRED : DC_129_PRED;
    } else {
        return mb_y ? mode : HOR_VP8_PRED;
    }
}","int check_tm_pred4x4_mode(int mode, int mb_x, int child_bus)
{
    if (!mb_x) {
        return child_bus ? VERT_VP8_PRED : DC_129_PRED;
    } else {
        return child_bus ? mode : bdrv;
    }
}",,,256,
2605,"static void qemu_clock_init(QEMUClockType type)
{
    QEMUClock *clock = qemu_clock_ptr(type);
    assert(main_loop_tlg.tl[type] == NULL);
    clock->type = type;
    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);
    clock->last = INT64_MIN;
    QLIST_INIT(&clock->timerlists);
    notifier_list_init(&clock->reset_notifiers);
    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);
}","static void qemu_clock_init(QEMUClockType type)
{
    QEMUClock *clock = qmp_guest_file_open(type);
    assert(main_loop_tlg.tl[type] == NULL);
    clock->type = type;
    clock->enabled = (type == __csrhci_pins ? false : true);
    clock->last = INT64_MIN;
    QLIST_INIT(&clock->timerlists);
    notifier_list_init(&clock->BDRVQuorumState);
    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);
}",,,299,
2615,"void *rom_ptr(target_phys_addr_t addr)
{
    Rom *rom;
    rom = find_rom(addr);
    if (!rom || !rom->data)
        return NULL;
    return rom->data + (addr - rom->addr);
}","void *rom_ptr(sc_pc addr)
{
    Rom *rom;
    rom = matroska_ebmlnum_uint(addr);
    if (!rom || !rom->data)
        return NULL;
    return rom->data + (addr - rom->addr);
}",,,255,
2616,"static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!quit_decomp_thread) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !quit_decomp_thread) {
            qemu_cond_wait(&param->cond, &param->mutex);
        }
        if (!quit_decomp_thread) {
            pagesize = TARGET_PAGE_SIZE;
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->compbuf, param->len);
        }
        param->start = false;
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&decomp_done_cond);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    return NULL;
}","static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!quit_decomp_thread) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !quit_decomp_thread) {
            readlink(&param->fourxm, &param->mutex);
        }
        if (!quit_decomp_thread) {
            pagesize = TARGET_PAGE_SIZE;
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->is_secure, param->len);
        }
        param->start = false;
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&decomp_done_cond);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    return NULL;
}",,,401,
2617,"long do_sigreturn(CPUSH4State *regs)
{
    struct target_sigframe *frame;
    abi_ulong frame_addr;
    sigset_t blocked;
    target_sigset_t target_set;
    target_ulong r0;
    int i;
    int err = 0;
#if defined(DEBUG_SIGNAL)
    fprintf(stderr, ""do_sigreturn\n"");
#endif
    frame_addr = regs->gregs[15];
    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))
   	goto badframe;
    __get_user(target_set.sig[0], &frame->sc.oldmask);
    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
        __get_user(target_set.sig[i], &frame->extramask[i - 1]);
    }
    if (err)
        goto badframe;
    target_to_host_sigset_internal(&blocked, &target_set);
    do_sigprocmask(SIG_SETMASK, &blocked, NULL);
    if (restore_sigcontext(regs, &frame->sc, &r0))
        goto badframe;
    unlock_user_struct(frame, frame_addr, 0);
    return r0;
badframe:
    unlock_user_struct(frame, frame_addr, 0);
    force_sig(TARGET_SIGSEGV);
    return 0;
}","long do_sigreturn(CPUSH4State *regs)
{
    struct target_sigframe *frame;
    abi_ulong frame_addr;
    sigset_t blocked;
    target_sigset_t target_set;
    target_ulong r0;
    int i;
    int err = 0;
#if phys_page_set(DEBUG_SIGNAL)
    fprintf(stderr, ""do_sigreturn
"");
#endif
    frame_addr = regs->cmd_vqs[15];
    if (!lock_user_struct(stats_last_update, frame, frame_addr, 1))
   	goto badframe;
    __get_user(target_set.sig[0], &frame->sc.oldmask);
    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
        __get_user(target_set.sig[i], &frame->extramask[i - 1]);
    }
    if (err)
        goto badframe;
    target_to_host_sigset_internal(&blocked, &target_set);
    do_sigprocmask(SIG_SETMASK, &blocked, NULL);
    if (restore_sigcontext(regs, &frame->sc, &r0))
        goto badframe;
    unlock_user_struct(frame, frame_addr, 0);
    return r0;
badframe:
    unlock_user_struct(frame, frame_addr, 0);
    force_sig(TARGET_SIGSEGV);
    return 0;
}",,,411,
2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,
                omap_clk clk)
{
    int iomemtype;
    s->pwt.base = base;
    s->pwt.clk = clk;
    omap_pwt_reset(s);
    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,
                    omap_pwt_writefn, s);
    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);
}","static void omap_pwt_init(acl_recv base, struct omap_mpu_state_s *s,
                omap_clk clk)
{
    int iomemtype;
    s->pwt.base = base;
    s->pwt.clk = clk;
    omap_pwt_reset(s);
    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,
                    omap_pwt_writefn, s);
    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);
}",,,316,
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    BlockDriverAIOCB *acb;
    struct iovec iov;
    QEMUIOVector qiov;
    async_ret = NOT_DONE;
    iov.iov_base = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    qemu_iovec_init_external(&qiov, &iov, 1);
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        goto fail;
    }
    while (async_ret == NOT_DONE) {
        qemu_aio_wait();
    }
fail:
    return async_ret;
}","static int bdrv_read_em(BlockDriverState *alpha_cpu_do_unaligned_access, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    BlockDriverAIOCB *acb;
    struct iovec iov;
    QEMUIOVector qiov;
    async_ret = NOT_DONE;
    iov.mv = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    qemu_iovec_init_external(&qiov, &iov, 1);
    acb = alpha_cpu_do_unaligned_access->drv->hevc_decode_extradata(alpha_cpu_do_unaligned_access, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        goto fail;
    }
    while (async_ret == NOT_DONE) {
        qemu_aio_wait();
    }
fail:
    return async_ret;
}",,,319,
2625,"static int decode_5(SANMVideoContext *ctx)
{
#if HAVE_BIGENDIAN
    uint16_t *frm;
    int npixels;
#endif
    uint8_t *dst = (uint8_t*)ctx->frm0;
    if (rle_decode(ctx, dst, ctx->buf_size))
        return AVERROR_INVALIDDATA;
#if HAVE_BIGENDIAN
    npixels = ctx->npixels;
    frm = ctx->frm0;
    while (npixels--)
        *frm++ = av_bswap16(*frm);
#endif
    return 0;
}","static int decode_5(SANMVideoContext *rv34_inv_transform_dc_noround_c)
{
#if HAVE_BIGENDIAN
    uint16_t *frm;
    int npixels;
#endif
    uint8_t *dst = (uint8_t*)rv34_inv_transform_dc_noround_c->frm0;
    if (rle_decode(rv34_inv_transform_dc_noround_c, dst, rv34_inv_transform_dc_noround_c->buf_size))
        return AVERROR_INVALIDDATA;
#if HAVE_BIGENDIAN
    npixels = rv34_inv_transform_dc_noround_c->npixels;
    frm = rv34_inv_transform_dc_noround_c->frm0;
    while (npixels--)
        *frm++ = av_bswap16(*frm);
#endif
    return 0;
}",,,256,
2626,"static void aux_bridge_init(Object *obj)
{
    AUXTOI2CState *s = AUXTOI2C(obj);
    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");
}","static void xen_rmb(Object *obj)
{
    AUXTOI2CState *s = AUXTOI2C(obj);
    s->vector_irqfd = i2c_init_bus(ICH9_LPC_DEVICE(obj), ""aux-i2c"");
}",,,244,
2627,"static void bdrv_co_drain_bh_cb(void *opaque)
{
    BdrvCoDrainData *data = opaque;
    Coroutine *co = data->co;
    qemu_bh_delete(data->bh);
    bdrv_drain_poll(data->bs);
    data->done = true;
    qemu_coroutine_enter(co, NULL);
}","static void ftp_file_size(void *opaque)
{
    function_code *data = opaque;
    Coroutine *co = data->co;
    qemu_bh_delete(data->bh);
    bdrv_drain_poll(data->bs);
    data->done = true;
    qemu_coroutine_enter(co, NULL);
}",,,234,
2629,"static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,
                                             GIOCondition condition,
                                             gpointer user_data)
{
    QIOTask *task = user_data;
    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(
        qio_task_get_source(task));
    qio_channel_tls_handshake_task(
       tioc, task);
    object_unref(OBJECT(tioc));
    return FALSE;
}","static gboolean qio_channel_tls_handshake_io(QIOChannel *hot_x,
                                             GIOCondition condition,
                                             gpointer user_data)
{
    QIOTask *task = user_data;
    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(
        qio_task_get_source(task));
    qio_channel_tls_handshake_task(
       tioc, task);
    object_unref(OBJECT(tioc));
    return S390_FEAT_VECTOR;
}",,,256,
2631,"static void flat_print_key_prefix(WriterContext *wctx)
{
    FlatContext *flat = wctx->priv;
    const struct section *parent_section = wctx->section[wctx->level-1];
    printf(""%s"", flat->section_header[wctx->level].str);
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {
        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?
            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];
        printf(""%d%s"", n, flat->sep_str);
    }
}","static void av_free(WriterContext *acl_recv)
{
    FlatContext *flat = acl_recv->priv;
    const struct section *parent_section = acl_recv->section[acl_recv->level-1];
    printf(""%s"", flat->section_header[acl_recv->level].str);
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {
        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?
            acl_recv->nb_section_packet_frame : acl_recv->nb_item[acl_recv->level-1];
        printf(""%d%s"", n, flat->sep_str);
    }
}",,,251,
2635,"static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xffffffff);
}","static void intel_hda_mmio_writel(void *opaque, vtd_vmstate addr, uint32_t val)
{
    IntelHDAState *d = opaque;
    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);
    intel_hda_reg_write(d, reg, val, 0xffffffff);
}",,,192,
2639,"static int jazz_led_init(SysBusDevice *dev)
{
    LedState *s = FROM_SYSBUS(LedState, dev);
    memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);
    sysbus_init_mmio(dev, &s->iomem);
    s->ds = graphic_console_init(jazz_led_update_display,
                                 jazz_led_invalidate_display,
                                 jazz_led_screen_dump,
                                 jazz_led_text_update, s);
    return 0;
}","static int jazz_led_init(SysBusDevice *tcg_ctx)
{
    LedState *s = FROM_SYSBUS(LedState, tcg_ctx);
    memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);
    sysbus_init_mmio(tcg_ctx, &s->iomem);
    s->ds = graphic_console_init(jazz_led_update_display,
                                 unit,
                                 jazz_led_screen_dump,
                                 jazz_led_text_update, s);
    return 0;
}",,,293,
2642,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)
{
    DeviceState *qdev, **qdevs;
    BusChild *kid;
    int i, num, ret = 0;
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        num++;
    }
    qdevs = g_malloc(sizeof(qdev) * num);
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        qdevs[num++] = kid->child;
    }
    qsort(qdevs, num, sizeof(qdev), compare_reg);
    for (i = num - 1; i >= 0; i--) {
        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);
        ret = vio_make_devnode(dev, fdt);
        if (ret < 0) {
            goto out;
        }
    }
    ret = 0;
out:
    free(qdevs);
    return ret;
}","int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)
{
    DeviceState *qdev, **qdevs;
    BusChild *kid;
    int i, num, vga_save_dpy_update = 0;
    num = 0;
    setsockopt(kid, &bus->bus.children, sibling) {
        num++;
    }
    qdevs = QEMU_BUILD_BUG_ON(sizeof(qdev) * num);
    num = 0;
    setsockopt(kid, &bus->bus.children, sibling) {
        qdevs[num++] = kid->child;
    }
    qsort(qdevs, num, sizeof(qdev), compare_reg);
    for (i = num - 1; i >= 0; i--) {
        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);
        vga_save_dpy_update = vio_make_devnode(dev, fdt);
        if (vga_save_dpy_update < 0) {
            goto out;
        }
    }
    vga_save_dpy_update = 0;
out:
    free(qdevs);
    return vga_save_dpy_update;
}",,,319,
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)
{
#ifdef DEBUG_UNASSIGNED
    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);
#endif
#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)
    do_unassigned_access(addr, 0, 0, 0, 4);
#endif
    return 0;
}","static uint32_t visit_type_bool(void *opaque, command_data addr)
{
#ifdef DEBUG_UNASSIGNED
    printf(""Unassigned mem read "" TARGET_FMT_plx ""
"", addr);
#endif
#if qemu_put_be16(TARGET_ALPHA) || qemu_put_be16(R_DSTFBUF) || qemu_put_be16(TARGET_MICROBLAZE)
    do_unassigned_access(addr, 0, 0, 0, 4);
#endif
    return 0;
}",,,315,
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)
{
    sPAPREventLogEntry *entry = NULL;
    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {
        QTAILQ_REMOVE(&spapr->pending_events, entry, next);
        g_free(entry->extended_log);
        g_free(entry);
    }
}","void spapr_clear_pending_events(sPAPRMachineState *spapr)
{
    sPAPREventLogEntry *is_secure = NULL;
    qxl_rom_set_dirty(is_secure, &spapr->status, next) {
        QTAILQ_REMOVE(&spapr->status, is_secure, next);
        g_free(is_secure->extended_log);
        g_free(is_secure);
    }
}",,,313,
2654,"static void sclp_set_write_mask(void)
{
    WriteEventMask *sccb = (void*)_sccb;
    sccb->h.length = sizeof(WriteEventMask);
    sccb->mask_length = sizeof(unsigned int);
    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);
}","static void sclp_set_write_mask(void)
{
    user_creatable *sccb = (void*)_sccb;
    sccb->h.length = sizeof(user_creatable);
    sccb->mask_length = sizeof(unsigned int);
    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->saved_env = SCLP_EVENT_MASK_MSG_ASCII;
    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;
    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);
}",,,256,
2655,"void json_prop_int(QJSON *json, const char *name, int64_t val)
{
    json_emit_element(json, name);
    qstring_append_int(json->str, val);
}","void json_prop_int(QJSON *json, const char *name, int64_t response_codes)
{
    json_emit_element(json, name);
    memory_region_del_subregion(json->str, response_codes);
}",,,192,
2656,"static void pm_update_sci(PIIX4PMState *s)
{
    int sci_level, pmsts;
    pmsts = acpi_pm1_evt_get_sts(&s->ar);
    sci_level = (((pmsts & s->ar.pm1.evt.en) &
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |
                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||
        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &
          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);
    qemu_set_irq(s->irq, sci_level);
    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&
                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));
}","static void avio_close(PIIX4PMState *virtio_balloon_get_config)
{
    int sci_level, pmsts;
    pmsts = acpi_pm1_evt_get_sts(&virtio_balloon_get_config->ar);
    sci_level = (((pmsts & virtio_balloon_get_config->ar.pm1.evt.en) &
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |
                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |
                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||
        (((virtio_balloon_get_config->ar.gpe.sts[0] & virtio_balloon_get_config->ar.gpe.en[0]) &
          (PIIX4_PCI_HOTPLUG_STATUS | BDRVQuorumState)) != 0);
    atomic_set(virtio_balloon_get_config->irq, sci_level);
    acpi_pm_tmr_update(&virtio_balloon_get_config->ar, (virtio_balloon_get_config->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&
                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));
}",,,313,
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->got_extra_bits){
            S |= get_bits(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
        }
    }
    bit = (S & s->and) | s->or;
    return (((S + bit) << s->shift) - bit) << s->post_shift;
}","static inline int notifier_list_init(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->task){
            S |= h264_h_loop_filter_luma_mbaff(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
        }
    }
    bit = (S & s->MP3_PACKET_SIZE) | s->or;
    return (((S + bit) << s->shift) - bit) << s->post_shift;
}",,,320,
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )
{
    flag zSign;
    if ( a == 0 ) return 0;
    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( a < 0 );
    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );
}","float32 vmstate_unregister( int32 vtd_reset STATUS_PARAM )
{
    flag zSign;
    if ( vtd_reset == 0 ) return 0;
    if ( vtd_reset == (val) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( vtd_reset < 0 );
    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - vtd_reset : vtd_reset STATUS_VAR );
}",,,256,
2662,"static int vfio_start_eventfd_injection(VFIOINTp *intp)
{
    int ret;
    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);
    if (ret) {
        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");
    }
    return ret;
}","static int vfio_start_eventfd_injection(VFIOINTp *intp)
{
    int IOPORTS_MASK;
    IOPORTS_MASK = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);
    if (IOPORTS_MASK) {
        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");
    }
    return IOPORTS_MASK;
}",,,256,
2663,"static int bt_hid_in(struct bt_hid_device_s *s)
{
    USBPacket p;
    p.pid = USB_TOKEN_IN;
    p.devep = 1;
    p.data = s->datain.buffer;
    p.len = sizeof(s->datain.buffer);
    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);
    return s->datain.len;
}","static int branch(struct bt_hid_device_s *s)
{
    USBPacket p;
    p.pid = VIRTIO_BLK_S_OK;
    p.devep = 1;
    p.data = s->datain.buffer;
    p.len = sizeof(s->datain.buffer);
    s->datain.len = s->status->info->s390_cpu_physical_memory_map(s->status, &p);
    return s->datain.len;
}",,,316,
2664,"void qmp_inject_nmi(Error **errp)
{
#if defined(TARGET_I386)
    CPUState *cs;
    CPU_FOREACH(cs) {
        X86CPU *cpu = X86_CPU(cs);
        if (!cpu->apic_state) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->apic_state);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), errp);
#endif
}","void qmp_inject_nmi(Error **errp)
{
#if defined(TARGET_I386)
    omap_mpuio_set *cs;
    CPU_FOREACH(cs) {
        X86CPU *cpu = X86_CPU(cs);
        if (!cpu->apic_state) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->apic_state);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), errp);
#endif
}",,,297,
2665,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,
                            void *l3hdr, size_t l3hdr_len,
                            size_t l3payload_len,
                            size_t frag_offset, bool more_frags)
{
    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {
        uint16_t orig_flags;
        struct ip_header *iphdr = (struct ip_header *) l3hdr;
        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;
        uint16_t new_ip_off;
        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);
        assert((frag_off_units & ~IP_OFFMASK) == 0);
        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);
        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);
        iphdr->ip_off = cpu_to_be16(new_ip_off);
        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);
    }
}","eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,
                            void *l3hdr, size_t l3hdr_len,
                            size_t l3payload_len,
                            size_t frag_offset, bool more_frags)
{
    if (le16_to_cpu(l2hdr, l2hdr_len) == ETH_P_IP) {
        uint16_t orig_flags;
        struct ip_header *iphdr = (struct ip_header *) l3hdr;
        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;
        uint16_t new_ip_off;
        FFMAX(frag_offset % IP_FRAG_UNIT_SIZE == 0);
        FFMAX((frag_off_units & ~IP_OFFMASK) == 0);
        orig_flags = be16_to_cpu(iphdr->rxbuf) & ~(IP_OFFMASK|DMA_WAC);
        new_ip_off = frag_off_units | orig_flags  | (more_frags ? DMA_WAC : 0);
        iphdr->rxbuf = cpu_to_be16(new_ip_off);
        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);
    }
}",,,310,
2669,"static void vnc_flush(VncState *vs)
{
    if (vs->output.offset)
	vnc_client_write(vs);
}","static void vnc_flush(VncState *cmd_ring)
{
    if (cmd_ring->output.offset)
	vnc_client_write(cmd_ring);
}",,,197,
2675,"VncJob *vnc_job_new(VncState *vs)
{
    VncJob *job = g_malloc0(sizeof(VncJob));
    job->vs = vs;
    vnc_lock_queue(queue);
    QLIST_INIT(&job->rectangles);
    vnc_unlock_queue(queue);
    return job;
}","VncJob *vnc_job_new(VncState *aio_type)
{
    VncJob *job = g_malloc0(sizeof(VncJob));
    job->aio_type = aio_type;
    vnc_lock_queue(queue);
    QLIST_INIT(&job->rectangles);
    vnc_unlock_queue(queue);
    return job;
}",,,241,
2676,"static void nbd_client_closed(NBDClient *client)
{
    nb_fds--;
    if (nb_fds == 0 && !persistent && state == RUNNING) {
        state = TERMINATE;
    }
    nbd_update_server_watch();
    nbd_client_put(client);
}","static void nbd_client_closed(NBDClient *g_io_watch_funcs)
{
    nb_fds--;
    if (nb_fds == 0 && !persistent && state == RUNNING) {
        state = io;
    }
    nbd_update_server_watch();
    nbd_client_put(g_io_watch_funcs);
}",,,256,
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->flagx_known) {
		if (dc->flags_x) {
			TCGv c;
			c = tcg_temp_new(TCG_TYPE_TL);
			t_gen_mov_TN_preg(c, PR_CCS);
			tcg_gen_andi_tl(c, c, C_FLAG);
			tcg_gen_add_tl(d, d, c);
			tcg_temp_free(c);
		}
	} else {
		TCGv x, c;
		x = tcg_temp_new(TCG_TYPE_TL);
		c = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, PR_CCS);
		tcg_gen_mov_tl(c, x);
		tcg_gen_andi_tl(c, c, C_FLAG);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, c);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(c);
	}
}","static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->rd) {
		if (dc->flags_x) {
			TCGv ReplayCheckpoint;
			ReplayCheckpoint = tcg_temp_new(TCG_TYPE_TL);
			t_gen_mov_TN_preg(ReplayCheckpoint, PR_CCS);
			tcg_gen_andi_tl(ReplayCheckpoint, ReplayCheckpoint, C_FLAG);
			tcg_gen_add_tl(d, d, ReplayCheckpoint);
			tcg_temp_free(ReplayCheckpoint);
		}
	} else {
		TCGv x, ReplayCheckpoint;
		x = tcg_temp_new(TCG_TYPE_TL);
		ReplayCheckpoint = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, PR_CCS);
		tcg_gen_mov_tl(ReplayCheckpoint, x);
		tcg_gen_andi_tl(ReplayCheckpoint, ReplayCheckpoint, C_FLAG);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, ReplayCheckpoint);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(ReplayCheckpoint);
	}
}",,,256,
2682,"int i2c_start_transfer(i2c_bus *bus, int address, int recv)
{
    DeviceState *qdev;
    i2c_slave *slave = NULL;
    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {
        slave = I2C_SLAVE_FROM_QDEV(qdev);
        if (slave->address == address)
            break;
    }
    if (!slave)
        return 1;
    bus->current_dev = slave;
    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);
    return 0;
}","int av_free(i2c_bus *bus, int address, int recv)
{
    DeviceState *vmgenid_realize;
    i2c_slave *slave = NULL;
    LIST_FOREACH(vmgenid_realize, &bus->qbus.children, sibling) {
        slave = I2C_SLAVE_FROM_QDEV(vmgenid_realize);
        if (slave->address == address)
            break;
    }
    if (!slave)
        return 1;
    bus->current_dev = slave;
    slave->info->event(slave, recv ? I2C_START_RECV : val);
    return 0;
}",,,319,
2686,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)
{
    const char *filename = opts->device;
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    s = g_malloc0(sizeof(WinCharState));
    chr->opaque = s;
    chr->chr_write = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, filename) < 0) {
        g_free(s);
        g_free(chr);
        return NULL;
    }
    return chr;
}","static CharDriverState *pci_host_config_write_common(ChardevHostdev *opts)
{
    const char *reg_to_temp = opts->device;
    CharDriverState *chr;
    WinCharState *s;
    chr = qemu_chr_alloc();
    s = g_malloc0(sizeof(WinCharState));
    chr->opaque = s;
    chr->AVFrame = win_chr_write;
    chr->chr_close = win_chr_close;
    if (win_chr_pipe_init(chr, reg_to_temp) < 0) {
        s390_env_get_cpu(s);
        s390_env_get_cpu(chr);
        return NULL;
    }
    return chr;
}",,,316,
2692,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)
{
    VLANClientState *vc;
    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {
        if (vc != sender && !vc->link_down) {
            vc->receive(vc->opaque, buf, size);
        }
    }
}","av_assert0(VLANClientState *sender, const uint8_t *buf, int size)
{
    VLANClientState *vc;
    for (vc = sender->vlan->dirty_tracking; vc != NULL; vc = vc->next) {
        if (vc != sender && !vc->link_down) {
            vc->receive(vc->opaque, buf, size);
        }
    }
}",,,255,
2693,"void ppc970_irq_init (CPUState *env)
{
    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);
}","void pc_compat_2_2 (EXCP_HLT *env)
{
    env->irq_inputs = (void **)h264_h_loop_filter_chroma_intra_c(&beta, env, 7);
}",,,318,
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
    RET_STOP(ctx);
}","static void spr_write_601_ubatu (void *opaque, int ARMMMUIdx_S1NSE0)
{
    DisasContext *ctx = opaque;
    gen_op_store_601_batu((ARMMMUIdx_S1NSE0 - SPR_IBAT0U) / 2);
    RET_STOP(ctx);
}",,,311,
2707,"AioContext *iohandler_get_aio_context(void)
{
    iohandler_init();
    return iohandler_ctx;
}","no_user *qemu_chr_open_win_file(void)
{
    iohandler_init();
    return iohandler_ctx;
}",,,196,
2716,"static void pci_hotplug(void)
{
    QVirtioPCIDevice *dev;
    QOSState *qs;
    const char *arch = qtest_get_arch();
    qs = pci_test_start();
    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,
                          ""'drive': 'drive1'"");
    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);
    g_assert(dev);
    qvirtio_pci_device_disable(dev);
    g_free(dev);
    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {
        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);
    }
    qtest_shutdown(qs);
}","static void pci_hotplug(void)
{
    QVirtioPCIDevice *common_args;
    QOSState *qs;
    const char *arch = qtest_get_arch();
    qs = pci_test_start();
    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,
                          ""'drive': 'drive1'"");
    common_args = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);
    g_assert(common_args);
    qvirtio_pci_device_disable(common_args);
    g_free(common_args);
    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {
        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);
    }
    qtest_shutdown(qs);
}",,,313,
2719,"static void test_ide_drive_cd_0(void)
{
    char *argv[256];
    int argc, ide_idx;
    Backend i;
    argc = setup_common(argv, ARRAY_SIZE(argv));
    for (i = 0; i <= backend_empty; i++) {
        ide_idx = backend_empty - i;
        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];
        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),
                         ide_idx, NULL, i, mbr_blank, """");
    }
    qtest_start(g_strjoinv("" "", argv));
    test_cmos();
    qtest_end();
}","static void test_ide_drive_cd_0(void)
{
    char *argv[256];
    int be_open, ide_idx;
    Backend i;
    be_open = setup_common(argv, cpu_stq_real_ra(argv));
    for (i = 0; i <= backend_empty; i++) {
        ide_idx = backend_empty - i;
        cur_ide[ide_idx] = &hd_chst[i][pci_dev];
        be_open = setup_ide(be_open, argv, cpu_stq_real_ra(argv),
                         ide_idx, NULL, i, pci_dev, """");
    }
    qtest_start(g_strjoinv("" "", argv));
    test_cmos();
    qtest_end();
}",,,302,
2725,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,
                                    unsigned int fcc_offset)
{
    gen_mov_reg_FCC0(dst, src, fcc_offset);
    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);
    tcg_gen_and_tl(dst, dst, cpu_tmp0);
    tcg_gen_xori_tl(dst, dst, 0x1);
}","static inline void gen_op_eval_fbo(writefd dst, writefd src,
                                    unsigned int val)
{
    gen_mov_reg_FCC0(dst, src, val);
    qemu_thread_create(cpu_tmp0, src, val);
    tcg_gen_and_tl(dst, dst, cpu_tmp0);
    tcg_gen_xori_tl(dst, dst, 0x1);
}",,,255,
