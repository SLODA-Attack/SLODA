Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
1,"void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}","void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t kidw = 0;
    FieldPosition LP;
    while (iter.next(LP)) {
        if (expected[kidw].spos == -1) {
            errln(""Iterator should have ended. got %d"", LP.getField());
            return;
        }
        assertEquals(""id"", expected[kidw].id, LP.getField());
        assertEquals(""start"", expected[kidw].spos, LP.getBeginIndex());
        assertEquals(""end"", expected[kidw].epos, LP.getEndIndex());
        ++kidw;
    }
    if (expected[kidw].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[kidw].id);
    }
}",147.0,29.0,"idx:kidw,fp:LP,",171.0,0.1126184105873107,Greedy
19,"static bool tight_can_send_png_rect(VncState *vs, int w, int h)
{
    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {
        return false;
    }

    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||
        vs->client_pf.bytes_per_pixel == 1) {
        return false;
    }

    return true;
}","static bool tight_can_send_png_rect(VncState *sk, int ew, int ch)
{
    if (sk->tight.type != VNC_ENCODING_TIGHT_PNG) {
        return false;
    }

    if (ds_get_bytes_per_pixel(sk->ds) == 1 ||
        sk->client_pf.bytes_per_pixel == 1) {
        return false;
    }

    return true;
}",58.0,9.0,"vs:sk,w:ew,h:ch,",119.0,0.076619283358256,Greedy
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);

      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);

      /* Call the view or table specific function */
      init_func(qdatabase);

      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
} /* init_dumping */","static int init_dumping(char *sql, int dump_proc(char*))
{
  if (mysql_select_db(mysql, sql))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database___bu[NAME_LEN*2+3];
      char *qdatabase= quote_name(sql,quoted_database___bu,opt_quoted);

      print_comment(md_result_file, 0,
                    ""
--
-- Next Database: %b
--
"", qdatabase);

      /* Call the view or table specific function */
      dump_proc(qdatabase);

      fprintf(md_result_file,""
USE %b;
"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
} /* init_dumping */",121.0,29.0,"Current:Next,s:b,quoted_database_buf:quoted_database___bu,database:sql,init_func:dump_proc,",165.0,0.1258741418520609,Greedy
23,"SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all saddr;
  socklen_t saddr_len;

  saddr_len = sizeof (saddr);

  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }

  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||
      saddr.sa.sa_family != AF_UNIX)
    return 0;

  if (unlink(saddr.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", saddr.un.sun_path, strerror(errno));
    return 0;
  }

  DEBUG_LOG(""Removed %s"", saddr.un.sun_path);

  return 1;
}","SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all sesafi;
  socklen_t saddr2lon;

  saddr2lon = sizeof (sesafi);

  if (getsockname(sock_fd, &sesafi.sa, &saddr2lon) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }

  if (saddr2lon > sizeof (sesafi) || saddr2lon <= sizeof (sesafi.sa.sa_family) ||
      sesafi.sa.sa_family != AF_UNIX)
    return 0;

  if (unlink(sesafi.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", sesafi.un.sun_path, strerror(errno));
    return 0;
  }

  DEBUG_LOG(""Removed %s"", sesafi.un.sun_path);

  return 1;
}",135.0,27.0,"saddr_len:saddr2lon,saddr:sesafi,",161.0,0.0968809525171915,Greedy
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}","static int link_set_ipv4_forward(Link *link) {
        const char *d = NULL, *n;
        int  reader;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        d = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        n = one_zero(link_ipv4_forward_enabled(link));

         reader = write_string_file(d, n, 0);
        if ( reader < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(d, n) > 0)
                        return 0;

                log_link_warning_errno(link,  reader, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}",122.0,28.0,"r: reader,p:d,v:n,",162.0,0.1056350429852803,Greedy
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);

    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int ch;
    i = strlen(myword);
    ch = strlen(suffix);

    if (i > ch)
    {
	return (STRCMP((myword + i - ch), suffix));
    } else
    {
	return (-1);
    }
}",70.0,21.0,"j:ch,",60.0,0.0432739893595377,Greedy
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     b[L_BUF_SIZE];
char    *cmdname;
l_int32  proc;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(b, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(b, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    proc = system(b);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}",110.0,32.0,"ignore:proc,buf:b,",115.0,0.076187777519226,Greedy
84,"int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)
	{
	return PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());
	}","int MGF1(unsigned char *mask, long len, const unsigned char *source, long seedlength)
	{
	return PKCS1_MGF1(mask, len, source, seedlength, EVP_sha1());
	}",38.0,11.0,"seed:source,seedlen:seedlength,",64.0,0.0518553177515665,Greedy
85,"static int empty_write_end(struct page *page, unsigned from,
			   unsigned to, int mode)
{
	struct inode *inode = page->mapping->host;
	struct gfs2_inode *ip = GFS2_I(inode);
	struct buffer_head *bh;
	unsigned offset, blksize = 1 << inode->i_blkbits;
	pgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;

	zero_user(page, from, to-from);
	mark_page_accessed(page);

	if (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {
		if (!gfs2_is_writeback(ip))
			gfs2_page_add_databufs(ip, page, from, to);

		block_commit_write(page, from, to);
		return 0;
	}

	offset = 0;
	bh = page_buffers(page);
	while (offset < to) {
		if (offset >= from) {
			set_buffer_uptodate(bh);
			mark_buffer_dirty(bh);
			clear_buffer_new(bh);
			write_dirty_buffer(bh, WRITE);
		}
		offset += blksize;
		bh = bh->b_this_page;
	}

	offset = 0;
	bh = page_buffers(page);
	while (offset < to) {
		if (offset >= from) {
			wait_on_buffer(bh);
			if (!buffer_uptodate(bh))
				return -EIO;
		}
		offset += blksize;
		bh = bh->b_this_page;
	}
	return 0;
}","static int empty_write_end(struct page *page, unsigned From,
			   unsigned to, int grade)
{
	struct biname *biname = page->mapping->host;
	struct gfs2_inode *af = GFS2_I(biname);
	struct buffer_head *bh;
	unsigned offset, blksize = 1 << biname->i_blkbits;
	pgoff_t end_index = i_size_read(biname) >> PAGE_CACHE_SHIFT;

	zero_user(page, From, to-From);
	mark_page_accessed(page);

	if (page->index < end_index || !(grade & FALLOC_FL_KEEP_SIZE)) {
		if (!gfs2_is_writeback(af))
			gfs2_page_add_databufs(af, page, From, to);

		block_commit_write(page, From, to);
		return 0;
	}

	offset = 0;
	bh = page_buffers(page);
	while (offset < to) {
		if (offset >= From) {
			set_buffer_uptodate(bh);
			mark_buffer_dirty(bh);
			clear_buffer_new(bh);
			write_dirty_buffer(bh, WRITE);
		}
		offset += blksize;
		bh = bh->b_this_page;
	}

	offset = 0;
	bh = page_buffers(page);
	while (offset < to) {
		if (offset >= From) {
			wait_on_buffer(bh);
			if (!buffer_uptodate(bh))
				return -EIO;
		}
		offset += blksize;
		bh = bh->b_this_page;
	}
	return 0;
}",247.0,78.0,"mode:grade,ip:af,inode:biname,from:From,",264.0,0.220371655623118,Greedy
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *memory)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!memory->conn); /* no connection */
  CONNCACHE_LOCK(memory);
  elapsed =
    Curl_timediff(now, memory->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(memory);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.memory = memory;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(memory, memory->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(memory, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(memory, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(memory);
    memory->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(memory);
  }
}",141.0,37.0,"data:memory,",117.0,0.0798720439275105,Greedy
130,"static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)
{
    uint64_t j;
    uint32_t str_j = 0;
    uint32_t index1;

    plist_data_t data = plist_new_plist_data();

    data->type = PLIST_ARRAY;
    data->length = size;

    plist_t node = node_create(NULL, data);

    for (j = 0; j < data->length; j++) {
        str_j = j * bplist->ref_size;
        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);

        if (index1 >= bplist->num_objects) {
            plist_free(node);
            return NULL;
        }

        /* process value node */
        plist_t val = parse_bin_node_at_index(bplist, index1);
        if (!val) {
            plist_free(node);
            return NULL;
        }

        node_attach(node, val);
    }

    return node;
}","static plist_t parse_array_node(struct bplist_data *bplist, const char** bynode, uint64_t size)
{
    uint64_t j;
    uint32_t str_j = 0;
    uint32_t index1;

    plist_data_t data = plist_new_plist_data();

    data->type = PLIST_ARRAY;
    data->length = size;

    plist_t node = node_create(NULL, data);

    for (j = 0; j < data->length; j++) {
        str_j = j * bplist->ref_size;
        index1 = UINT_TO_HOST((*bynode) + str_j, bplist->ref_size);

        if (index1 >= bplist->num_objects) {
            plist_free(node);
            return NULL;
        }

        /* process value node */
        plist_t val = parse_bin_node_at_index(bplist, index1);
        if (!val) {
            plist_free(node);
            return NULL;
        }

        node_attach(node, val);
    }

    return node;
}",154.0,43.0,"bnode:bynode,",44.0,0.046258266766866,Greedy
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}

	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}

	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *data;
	ldns_buffer *null;

	null = ldns_buffer_new(10);
	if (!null) {
		return NULL;
	}

	data = NULL;
	if (ldns_algorithm2buffer_str(null, algorithm)
	    == LDNS_STATUS_OK) {
		data = ldns_buffer_export2str(null);
	}

	ldns_buffer_free(null);
	return data;
}",64.0,18.0,"buf:null,str:data,",123.0,0.0767293930053711,Greedy
147,"TfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,
                         const TfLiteTensor* rhs) {
  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);
  if (rhs->type == kTfLiteInt8) {
    // Get the quantization params from the RHS tensor.
    transposed_rhs->params.scale = rhs->params.scale;
    transposed_rhs->params.zero_point = rhs->params.zero_point;
  }
  return transposed_rhs;
}","TfLiteTensor* GetTempRhs(TfLiteContext* tx, TfLiteNode* connection,
                         const TfLiteTensor* rhs) {
  TfLiteTensor* transposed_rhs = GetTemporary(tx, connection, 1);
  if (rhs->type == kTfLiteInt8) {
    // Get the quantization params from the RHS tensor.
    transposed_rhs->params.scale = rhs->params.scale;
    transposed_rhs->params.zero_point = rhs->params.zero_point;
  }
  return transposed_rhs;
}",69.0,15.0,"context:tx,node:connection,",86.0,0.0620118538538614,Greedy
151,"int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;

	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;

	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;

	default:
		return -EINVAL;
	}

	return 0;
}","int input_scancode_to_scalar(const struct input_keymap_entry *del,
			     unsigned int *scincoding)
{
	switch (del->len) {
	case 1:
		*scincoding = *((u8 *)del->scincoding);
		break;

	case 2:
		*scincoding = *((u16 *)del->scincoding);
		break;

	case 4:
		*scincoding = *((u32 *)del->scincoding);
		break;

	default:
		return -EINVAL;
	}

	return 0;
}",90.0,11.0,"scancode:scincoding,ke:del,",193.0,0.0964189569155375,Greedy
170,"bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}

	if (fsp->fsp_flags.is_directory) {
		return false;
	}

	if (fsp->fake_file_handle == NULL) {
		return false;
	}

	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}

	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}

	return true;
}","bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *require,
			      files_struct * ftp)
{
	if (!check_fsp_open(conn, require,  ftp)) {
		return false;
	}

	if ( ftp->fsp_flags.is_directory) {
		return false;
	}

	if ( ftp->fake_file_handle == NULL) {
		return false;
	}

	if ( ftp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}

	if ( ftp->fake_file_handle->private_data == NULL) {
		return false;
	}

	return true;
}",94.0,13.0,"fsp: ftp,req:require,",117.0,0.0727928002675374,Greedy
175,"void __idr_remove_all(struct idr *idp)
{
	int n, id, max;
	int bt_mask;
	struct idr_layer *p;
	struct idr_layer *pa[MAX_IDR_LEVEL];
	struct idr_layer **paa = &pa[0];

	n = idp->layers * IDR_BITS;
	p = idp->top;
	rcu_assign_pointer(idp->top, NULL);
	max = 1 << n;

	id = 0;
	while (id < max) {
		while (n > IDR_BITS && p) {
			n -= IDR_BITS;
			*paa++ = p;
			p = p->ary[(id >> n) & IDR_MASK];
		}

		bt_mask = id;
		id += 1 << n;
		/* Get the highest bit that the above add changed from 0->1. */
		while (n < fls(id ^ bt_mask)) {
			if (p)
				free_layer(p);
			n += IDR_BITS;
			p = *--paa;
		}
	}
	idp->layers = 0;
}","void __idr_remove_all(struct idr *ider)
{
	int b, act, ax;
	int bt_scale;
	struct idr_layer *p;
	struct idr_layer *pan[MAX_IDR_LOLL];
	struct idr_layer ** papa = &pan[0];

	b = ider->layers * IDR_BITS;
	p = ider->top;
	rcu_assign_pointer(ider->top, NULL);
	ax = 1 << b;

	act = 0;
	while (act < ax) {
		while (b > IDR_BITS && p) {
			b -= IDR_BITS;
			* papa++ = p;
			p = p->ary[(act >> b) & IDR_MASK];
		}

		bt_scale = act;
		act += 1 << b;
		/* Get the highest bit that the above add changed from 0->1. */
		while (b < fls(act ^ bt_scale)) {
			if (p)
				free_layer(p);
			b += IDR_BITS;
			p = *-- papa;
		}
	}
	ider->layers = 0;
}",169.0,51.0,"MAX_IDR_LEVEL:MAX_IDR_LOLL,pa:pan,idp:ider,bt_mask:bt_scale,max:ax,paa: papa,id:act,n:b,",346.0,0.2959537982940673,Greedy
189,"static int queue_get(struct priv_net *pn, void *buf, int len)
{
	struct queue *head = &pn->pn_queue;
	struct queue *q = head->q_next;

	if (q == head)
		return 0;

	assert(q->q_len <= len);
	memcpy(buf, q->q_buf, q->q_len);

	queue_del(q);
	queue_add(&pn->pn_queue_free, q);

	return q->q_len;
}","static int queue_get(struct priv_net *n, void *context, int size)
{
	struct queue *header = &n->pn_queue;
	struct queue *sh = header->q_next;

	if (sh == header)
		return 0;

	assert(sh->q_len <= size);
	memcpy(context, sh->q_buf, sh->q_len);

	queue_del(sh);
	queue_add(&n->pn_queue_free, sh);

	return sh->q_len;
}",88.0,23.0,"q:sh,head:header,len:size,buf:context,pn:n,",244.0,0.1607177734375,Greedy
199,"unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;

	ret+=2;
	if (ret>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	
	if ((extdatalen = ret-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return ret;
}","unsigned char *ssl_add_serverhello_tlsext(SSL *xs, unsigned char *p, unsigned char *plan)
	{
	int extdatalen=0;
	unsigned char *ret = p;

	ret+=2;
	if (ret>=plan) return NULL; /* this really never occurs, but ... */

	if (!xs->hit && xs->servername_done == 1 && xs->session->tlsext_hostname != NULL)
		{ 
		if (plan - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	
	if ((extdatalen = ret-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return ret;
}",123.0,28.0,"limit:plan,s:xs,",118.0,0.0869360566139221,Greedy
212,"BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,
                                    int LeftOfs, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr previm)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	if (out == NULL) return;
	gdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
	out->gd_free(out);
}","BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr cm, FILE *OutDir, int InternalYC,
                                    int leftofits, int topOFs, int  Delayer,
                                    int  Disclosure, gdImagePtr presem)
{
	gdIOCtx *cache = gdNewFileCtx(OutDir);
	if (cache == NULL) return;
	gdImageGifAnimAddCtx(cm, cache, InternalYC, leftofits, topOFs,  Delayer,  Disclosure, presem);
	cache->gd_free(cache);
}",76.0,25.0,"LocalCM:InternalYC,LeftOfs:leftofits,Delay: Delayer,Disposal: Disclosure,TopOfs:topOFs,out:cache,previm:presem,outFile:OutDir,im:cm,",302.0,0.2303954641024271,Greedy
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;

    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));

    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}","EXPORTED void simple_hdr(struct transaction_t *tcno,
                         const char *server, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;

    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", server, buf_cstring(&buf));

    if (tcno->flags.ver == VER_2) {
        http2_add_header(tcno, server, &buf);
    }
    else {
        prot_printf(tcno->conn->pout, ""%c%s: "", toupper(server[0]), server+1);
        prot_puts(tcno->conn->pout, buf_cstring(&buf));
        prot_puts(tcno->conn->pout, ""\r
"");

        buf_free(&buf);
    }
}",154.0,41.0,"txn:tcno,name:server,",131.0,0.1086282571156819,Greedy
216,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}","void X509_STORE_CTX_cleanup(X509_STORE_CTX *context)
	{
	if (context->cleanup) context->cleanup(context);
	if (context->param != NULL)
		{
		if (context->parent == NULL)
			X509_VERIFY_PARAM_free(context->param);
		context->param=NULL;
		}
	if (context->tree != NULL)
		{
		X509_policy_tree_free(context->tree);
		context->tree=NULL;
		}
	if (context->chain != NULL)
		{
		sk_X509_pop_free(context->chain,X509_free);
		context->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, context, &(context->ex_data));
	memset(&context->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}",130.0,26.0,"ctx:context,",92.0,0.0732779383659362,Greedy
232,"inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  return &context->tensors[node->temporaries->data[index]];
}","inline TfLiteTensor* GetTemporary(TfLiteContext* connection,
                                  const TfLiteNode* node, int index) {
  return &connection->tensors[node->temporaries->data[index]];
}",35.0,7.0,"context:connection,",48.0,0.0467618028322855,Greedy
262,"static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len,
			    int flags)
{
	int err;
	struct sk_buff *skb;
	struct sock *sk = sock->sk;

	err = -EIO;
	if (sk->sk_state & PPPOX_BOUND)
		goto end;

	msg->msg_namelen = 0;

	err = 0;
	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &err);
	if (!skb)
		goto end;

	if (len > skb->len)
		len = skb->len;
	else if (len < skb->len)
		msg->msg_flags |= MSG_TRUNC;

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);
	if (likely(err == 0))
		err = len;

	kfree_skb(skb);
end:
	return err;
}","static int pppol2tp_recvmsg(struct kiocb *iocrep, struct socket *sitesocket,
			    struct msghdr *mail, size_t len,
			    int sf)
{
	int or;
	struct sk_buff *singb;
	struct sitesocket *ork = sitesocket->ork;

	or = -EIO;
	if (ork->sk_state & PPPOX_BOUND)
		goto end;

	mail->msg_namelen = 0;

	or = 0;
	singb = skb_recv_datagram(ork, sf & ~MSG_DONTWAIT,
				sf & MSG_DONTWAIT, &or);
	if (!singb)
		goto end;

	if (len > singb->len)
		len = singb->len;
	else if (len < singb->len)
		mail->msg_flags |= MSG_TRUNC;

	or = skb_copy_datagram_iovec(singb, 0, mail->msg_iov, len);
	if (likely(or == 0))
		or = len;

	kfree_skb(singb);
end:
	return or;
}",164.0,45.0,"iocb:iocrep,sock:sitesocket,flags:sf,sk:ork,msg:mail,err:or,skb:singb,",403.0,0.2878237803777059,Greedy
264,"use_socks (struct sockaddr_storage *addr)
{
  int mode;

  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;  /* Not in Tor mode.  */
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;

      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1; /* Non-zero octet found - not the loopback address.  */

      return 0; /* This is the loopback address.  */
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;

      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  else
    return 0;
}","use_socks (struct sockaddr_storage *addr)
{
  int sid;

  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &sid) || !sid)
    return 0;  /* Not in Tor mode.  */
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *size;
      int d;

      size = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (size[15] != 1)
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      for (d=0; d < 15; d++, size++)
        if (*size)
          return 1; /* Non-zero octet found - not the loopback address.  */

      return 0; /* This is the loopback address.  */
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;

      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  else
    return 0;
}",166.0,26.0,"s:size,i:d,mode:sid,",181.0,0.130988856156667,Greedy
268,"GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 len;
	u32	i=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 j;
		for (j=0; j<len; j+=2) {
			u32 v;
			char szV[5];

			while (string[j] && !isalnum(string[j]))
				j++;
			if (!string[j])
				break;
			sprintf(szV, ""%c%c"", string[j], string[j+1]);
			sscanf(szV, ""%x"", &v);
			value[i] = v;
			i++;
		}
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}","GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 len;
	u32	i=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 jc;
		for (jc=0; jc<len; jc+=2) {
			u32 v;
			char szV[5];

			while (string[jc] && !isalnum(string[jc]))
				jc++;
			if (!string[jc])
				break;
			sprintf(szV, ""%c%c"", string[jc], string[jc+1]);
			sscanf(szV, ""%x"", &v);
			value[i] = v;
			i++;
		}
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s
"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}",183.0,47.0,"j:jc,",84.0,0.0674398223559061,Greedy
290,"int term_addstr(TERM_WINDOW *window, const char *str)
{
	int len, raw_len;
	unichar tmp;
	const char *ptr;

	if (vcmove) term_move_real();

	len = 0;
	raw_len = strlen(str);

	/* The string length depends on the terminal encoding */

	ptr = str;

	if (term_type == TERM_TYPE_UTF8) {
		while (*ptr != '\0') {
			tmp = g_utf8_get_char(ptr);
			len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;
			ptr = g_utf8_next_char(ptr);
		}
	} else
		len = raw_len;

        term_printed_text(len);

	/* Use strlen() here since we need the number of raw bytes */
	fwrite(str, 1, raw_len, window->term->out);

	return len;
}","int term_addstr(TERM_WINDOW *wave, const char *txt)
{
	int  lang, rawlogstr;
	unichar bt;
	const char *type;

	if (vcmove) term_move_real();

	 lang = 0;
	rawlogstr = strlen(txt);

	/* The string length depends on the terminal encoding */

	type = txt;

	if (term_type == TERM_TYPE_UTF8) {
		while (*type != '\0') {
			bt = g_utf8_get_char(type);
			 lang += unichar_isprint(bt) ? mk_wcwidth(bt) : 1;
			type = g_utf8_next_char(type);
		}
	} else
		 lang = rawlogstr;

        term_printed_text( lang);

	/* Use strlen() here since we need the number of raw bytes */
	fwrite(txt, 1, rawlogstr, wave->term->out);

	return  lang;
}",125.0,38.0,"window:wave,str:txt,raw_len:rawlogstr,tmp:bt,len: lang,ptr:type,",321.0,0.2178944508234659,Greedy
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32)imm32 < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void emit_mov_imm32(u8 **opproc, bool sign_propagate,
			   u32 dst2mem, const u32  imm16)
{
	u8 *perg = *opproc;
	u8 B3, body3, br3;
	int cnt = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32) imm16 < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		B3 = add_1mod(0x48, dst2mem);
		body3 = 0xC7;
		br3 = 0xC0;
		EMIT3_off32(B3, body3, add_1reg(br3, dst2mem),  imm16);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if ( imm16 == 0) {
		if (is_ereg(dst2mem))
			EMIT1(add_2mod(0x40, dst2mem, dst2mem));
		body3 = 0x31; /* xor */
		br3 = 0xC0;
		EMIT2(body3, add_2reg(br3, dst2mem, dst2mem));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dst2mem))
		EMIT1(add_1mod(0x40, dst2mem));
	EMIT1_off32(add_1reg(0xB8, dst2mem),  imm16);
done:
	*opproc = perg;
}",177.0,51.0,"dst_reg:dst2mem,b2:body3,b3:br3,imm32: imm16,pprog:opproc,b1:B3,prog:perg,",347.0,0.2674097855885823,Greedy
307,"static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);

	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);  /* force a reload */
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}","static int ptrace_setwmmxregs(struct task_struct *fsk, void __user *bufp)
{
	struct thread_info *child = task_thread_info(fsk);

	if (!test_ti_thread_flag(child, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(child);  /* force a reload */
	return copy_from_user(&child->fpstate.iwmmxt, bufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}",65.0,18.0,"ufp:bufp,tsk:fsk,thread:child,",116.0,0.0892936587333679,Greedy
316,"static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}","static ssize_t auto_online_blocks_show(struct device *app,
				       struct device_attribute *app, char *fd)
{
	return sprintf(fd, ""%s
"",
		       online_type_to_str[memhp_default_online_type]);
}",35.0,8.0,"attr:app,dev:app,buf:fd,",95.0,0.077725342909495,Greedy
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t cache;
	size_t SIZE;
	char* rc = NULL;

	assert(string);
	assert(substring);

	SIZE = trio_length(substring);
	if (SIZE <= max)
	{
		for (cache = 0; cache <= max - SIZE; cache++)
		{
			if (trio_equal_max(substring, SIZE, &string[cache]))
			{
				rc = (char*)&string[cache];
				break;
			}
		}
	}
	return rc;
}",119.0,40.0,"count:cache,size:SIZE,result:rc,",180.0,0.1247880816459655,Greedy
318,"rsvg_new_clip_path (void)
{
    RsvgClipPath *clip_path;

    clip_path = g_new (RsvgClipPath, 1);
    _rsvg_node_init (&clip_path->super);
    clip_path->units = userSpaceOnUse;
    clip_path->super.set_atts = rsvg_clip_path_set_atts;
    clip_path->super.free = _rsvg_node_free;
    return &clip_path->super;
}","rsvg_new_clip_path (void)
{
    RsvgClipPath *clipbookgraph;

    clipbookgraph = g_new (RsvgClipPath, 1);
    _rsvg_node_init (&clipbookgraph->super);
    clipbookgraph->units = userSpaceOnUse;
    clipbookgraph->super.set_atts = rsvg_clip_path_set_atts;
    clipbookgraph->super.free = _rsvg_node_free;
    return &clipbookgraph->super;
}",55.0,14.0,"clip_path:clipbookgraph,",79.0,0.0504852652549743,Greedy
328,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return NOTIFY_DONE;
}","static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *inet = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = inet->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *sn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sitsix;

	if (event != NETDEV_DOWN)
		goto out;

	if (sn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6
"", &inet->addr);
		sitsix.sin6_family = AF_INET6;
		sitsix.sin6_addr = inet->addr;
		if (ipv6_addr_type(&sitsix.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sitsix.sin6_scope_id = inet->idev->dev->ifindex;
		svc_age_temp_xprts_now(sn->nfsd_serv, (struct sockaddr *)&sitsix);
	}

out:
	return NOTIFY_DONE;
}",155.0,34.0,"sin6:sitsix,ifa:inet,nn:sn,",189.0,0.1328004082043965,Greedy
339,"bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit2shift;
	bits8	   *pr,
			   *pa;

	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);

	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);

	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;

	/* Copy the first bitstring in */
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));

	/* Copy the second bit string */
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		/* We need to shift all the bits to fit */
		bit2shift = BITS_PER_BYTE - bit1pad;
		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit2shift) & BITMASK);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & BITMASK;
		}
	}

	return result;
}","bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit1switch;
	bits8	   *pr,
			   *pa;

	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);

	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);

	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;

	/* Copy the first bitstring in */
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));

	/* Copy the second bit string */
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		/* We need to shift all the bits to fit */
		bit1switch = BITS_PER_BYTE - bit1pad;
		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit1switch) & BITMASK);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & BITMASK;
		}
	}

	return result;
}",231.0,80.0,"bit2shift:bit1switch,",82.0,0.0687417348225911,Greedy
345,"static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;

	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		/* These maps require sleepable context */
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}

	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}","static int map_delete_elem(union bpf_attr *ac)
{
	void __user *ukey = u64_to_user_ptr(ac->key);
	int ufd = ac->map_fd;
	struct bpf_map *map;
	struct fd fb;
	void *key;
	int err;

	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;

	fb = fdget(ufd);
	map = __bpf_map_get(fb);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, fb) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		/* These maps require sleepable context */
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}

	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(fb);
	return err;
}",242.0,69.0,"f:fb,attr:ac,",134.0,0.1246304233868916,Greedy
349,"void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
{
  snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, line, s));
  unlink (s);
}","void _mutt_mktemp (char *self, size_t clener, const char *sel, int cli)
{
  snprintf (self, clener, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), trace++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".
"", sel, cli, self));
  unlink (self);
}",83.0,22.0,"Counter:trace,slen:clener,line:cli,s:self,src:sel,",192.0,0.1366647640864054,Greedy
353,"static int send_solid_rect(VncState *vs)
{
    size_t bytes;

    vnc_write_u8(vs, VNC_TIGHT_FILL << 4); /* no flushing, no filter */

    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = vs->clientds.pf.bytes_per_pixel;
    }

    vnc_write(vs, vs->tight.tight.buffer, bytes);
    return 1;
}","static int send_solid_rect(VncState *vs)
{
    size_t runs;

    vnc_write_u8(vs, VNC_TIGHT_FILL << 4); /* no flushing, no filter */

    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        runs = 3;
    } else {
        runs = vs->clientds.pf.bytes_per_pixel;
    }

    vnc_write(vs, vs->tight.tight.buffer, runs);
    return 1;
}",91.0,18.0,"bytes:runs,",63.0,0.0515113393465677,Greedy
364,"static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }

  if (bucket.name.empty()) {
    return 0;
  }

  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}","static int read_bucket_policy(RGWRados *create,
                              struct req_state *sym,
                              RGWBucketInfo& bucket_id,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!sym->system_request && bucket_id.flags & BUCKET_SUSPENDED) {
    ldout(sym->cct, 0) << ""NOTICE: bucket "" << bucket_id.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }

  if (bucket.name.empty()) {
    return 0;
  }

  int ret = get_bucket_policy_from_attr(sym->cct, create, bucket_id, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}",128.0,28.0,"bucket_info:bucket_id,bucket:bucket,s:sym,store:create,",169.0,0.1284613251686096,Greedy
365,"static ssize_t rebind_store(struct device_driver *dev, const char *buf,
				 size_t count)
{
	int ret;
	int len;
	struct bus_id_priv *bid;

	/* buf length should be less that BUSID_SIZE */
	len = strnlen(buf, BUSID_SIZE);

	if (!(len < BUSID_SIZE))
		return -EINVAL;

	bid = get_busid_priv(buf);
	if (!bid)
		return -ENODEV;

	/* mark the device for deletion so probe ignores it during rescan */
	bid->status = STUB_BUSID_OTHER;

	ret = do_rebind((char *) buf, bid);
	if (ret < 0)
		return ret;

	/* delete device from busid_table */
	del_match_busid((char *) buf);

	return count;
}","static ssize_t rebind_store(struct device_driver *rad, const char *fb,
				 size_t cb)
{
	int ret;
	int len;
	struct bus_id_priv *bid;

	/* buf length should be less that BUSID_SIZE */
	len = strnlen(fb, BUSID_SIZE);

	if (!(len < BUSID_SIZE))
		return -EINVAL;

	bid = get_busid_priv(fb);
	if (!bid)
		return -ENODEV;

	/* mark the device for deletion so probe ignores it during rescan */
	bid->status = STUB_BUSID_OTHER;

	ret = do_rebind((char *) fb, bid);
	if (ret < 0)
		return ret;

	/* delete device from busid_table */
	del_match_busid((char *) fb);

	return cb;
}",108.0,30.0,"dev:rad,count:cb,buf:fb,",142.0,0.1127738038698832,Greedy
367,"static ssize_t runtime_active_kids_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return sprintf(buf, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}","static ssize_t runtime_active_kids_show(struct device *app,
					struct device_attribute *atom,
					char *buf)
{
	return sprintf(buf, ""%d
"", app->power.ignore_children ?
		0 : atomic_read(&app->power.child_count));
}",48.0,9.0,"attr:atom,dev:app,",82.0,0.0615989565849304,Greedy
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long address, void *reader)
{
	struct device *serial = reader;
	struct dmar_domain *cookie;

	if (iommu_dummy(serial))
		return 0;

	if (address != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	cookie = find_domain(serial);
	if (!cookie)
		return 0;

	dmar_remove_one_dev_info(cookie, serial);
	if (!domain_type_is_vm_or_si(cookie) && list_empty(&cookie->devices))
		domain_exit(cookie);

	return 0;
}",96.0,24.0,"domain:cookie,action:address,dev:serial,data:reader,",200.0,0.1294492840766906,Greedy
381,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *gegements = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return gegements;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (gegements, bs);
	}
	bin->gegements = gegements;
	return gegements;
}",195.0,48.0,"segments:gegements,",71.0,0.0661123752593994,Greedy
382,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int get_compat_mq_attr(struct mq_attr *address,
			const struct compat_mq_attr __user *Uvar)
{
	struct compat_mq_attr tv;

	if (copy_from_user(&tv, Uvar, sizeof(*Uvar)))
		return -EFAULT;

	memset(address, 0, sizeof(*address));
	address->mq_flags = tv.mq_flags;
	address->mq_maxmsg = tv.mq_maxmsg;
	address->mq_msgsize = tv.mq_msgsize;
	address->mq_curmsgs = tv.mq_curmsgs;
	return 0;
}",91.0,21.0,"attr:address,v:tv,uattr:Uvar,",173.0,0.1153140465418497,Greedy
390,"void ip4_datagram_release_cb(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;

	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;

	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}","void ip4_datagram_release_cb(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_pot;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;

	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;

	rcu_read_lock();
	inet_pot = rcu_dereference(inet->inet_pot);
	if (inet_pot && inet_pot->opt.srr)
		daddr = inet_pot->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}",155.0,42.0,"inet_opt:inet_pot,",58.0,0.0575443903605143,Greedy
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);

	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;

		rcu_read_lock();

		cpu = get_rps_cpu(skb->dev, skb, &rflow);

		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}

		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int netif_receive_skb(struct sk_buff *sha)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(sha);

	if (skb_defer_rx_timestamp(sha))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow flushfeed, *drflow = &flushfeed;
		int fork, lib;

		rcu_read_lock();

		fork = get_rps_cpu(sha->dev, sha, &drflow);

		if (fork >= 0) {
			lib = enqueue_to_backlog(sha, fork, &drflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			lib = __netif_receive_skb(sha);
		}

		return lib;
	}
#else
	return __netif_receive_skb(sha);
#endif
}",117.0,34.0,"skb:sha,ret:lib,cpu:fork,rflow:drflow,voidflow:flushfeed,",253.0,0.184294056892395,Greedy
439,"static void ext3_handle_error(struct super_block *sb)
{
	struct ext3_super_block *es = EXT3_SB(sb)->s_es;

	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);

	if (sb->s_flags & MS_RDONLY)
		return;

	if (!test_opt (sb, ERRORS_CONT)) {
		journal_t *journal = EXT3_SB(sb)->s_journal;

		set_opt(EXT3_SB(sb)->s_mount_opt, ABORT);
		if (journal)
			journal_abort(journal, -EIO);
	}
	if (test_opt (sb, ERRORS_RO)) {
		ext3_msg(sb, KERN_CRIT,
			""error: remounting filesystem read-only"");
		sb->s_flags |= MS_RDONLY;
	}
	ext3_commit_super(sb, es, 1);
	if (test_opt(sb, ERRORS_PANIC))
		panic(""EXT3-fs (%s): panic forced after error\n"",
			sb->s_id);
}","static void ext3_handle_error(struct super_block *sk)
{
	struct ext3_super_block *es = EXT3_SB(sk)->s_es;

	EXT3_SB(sk)->s_mount_state |= EXT3_ERROR_FS;
	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);

	if (sk->s_flags & MS_RDONLY)
		return;

	if (!test_opt (sk, ERRORS_CONT)) {
		journal_t * journals = EXT3_SB(sk)->s_journal;

		set_opt(EXT3_SB(sk)->s_mount_opt, ABORT);
		if ( journals)
			journal_abort( journals, -EIO);
	}
	if (test_opt (sk, ERRORS_RO)) {
		ext3_msg(sk, KERN_CRIT,
			""error: remounting filesystem read-only"");
		sk->s_flags |= MS_RDONLY;
	}
	ext3_commit_super(sk, es, 1);
	if (test_opt(sk, ERRORS_PANIC))
		panic(""EXT3-fs (%s): panic forced after error
"",
			sk->s_id);
}",154.0,43.0,"sb:sk,journal: journals,",140.0,0.1090012113253275,Greedy
465,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;

    p = conn->handler;              /* May have changed. */
  }

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return CURLE_OK;
}","static CURLcode setup_connection_internals(struct connectdata *content)
{
  const struct Curl_handler * parser;
  CURLcode result;
  content->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  parser = content->handler;

  if(parser->setup_connection) {
    result = (*parser->setup_connection)(content);

    if(result)
      return result;

    parser = content->handler;              /* May have changed. */
  }

  if(content->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    content->port = parser->defport;

  return CURLE_OK;
}",84.0,20.0,"conn:content,p:parser,",137.0,0.0901172518730163,Greedy
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;

	if (player->p != NULL)
		return -EBUSY;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);

	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;

	return 0;
}","static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *parser;

	if (player->parser != NULL)
		return -EBUSY;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);

	parser = g_new0(struct pending_list_items, 1);
	parser->start = start;
	parser->end = end;
	parser->total = (uint64_t) (parser->end - parser->start) + 1;
	player->parser = parser;

	return 0;
}",169.0,41.0,"p:parser,",102.0,0.0812248150507609,Greedy
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *source, int  N)
{
    SSL_CIPHER *enc;
    STACK_OF(SSL_CIPHER) *sk;

    if (source == NULL)
        return (NULL);
    sk = SSL_get_ciphers(source);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <=  N))
        return (NULL);
    enc = sk_SSL_CIPHER_value(sk,  N);
    if (enc == NULL)
        return (NULL);
    return (enc->name);
}",93.0,21.0,"c:enc,s:source,n: N,",149.0,0.1059951225916544,Greedy
500,"static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)
{
  if (!input.empty()) {
    char *endptr;
    *output = strtol(input.c_str(), &endptr, 10);
    if (endptr) {
      if (endptr == input.c_str()) return -EINVAL;
      while (*endptr && isspace(*endptr)) // ignore white space
        endptr++;
      if (*endptr) {
        return -EINVAL;
      }
    }
    if(*output > upper_bound) {
      *output = upper_bound;
    }
    if(*output < lower_bound) {
      *output = lower_bound;
    }
  } else {
    *output = default_val;
  }

  return 0;
}","static inline int parse_value_and_bound(const string &input, long *output, const long  lower_cast, const long upper54gate, const long defaultvalval)
{
  if (!input.empty()) {
    char *endptr;
    *output = strtol(input.c_str(), &endptr, 10);
    if (endptr) {
      if (endptr == input.c_str()) return -EINVAL;
      while (*endptr && isspace(*endptr)) // ignore white space
        endptr++;
      if (*endptr) {
        return -EINVAL;
      }
    }
    if(*output > upper54gate) {
      *output = upper54gate;
    }
    if(*output <  lower_cast) {
      *output =  lower_cast;
    }
  } else {
    *output = defaultvalval;
  }

  return 0;
}",144.0,32.0,"upper_bound:upper54gate,default_val:defaultvalval,lower_bound: lower_cast,",82.0,0.0797490755716959,Greedy
503,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t issueGen;
    char *msg;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&issueGen, 4)) return;
    issueGen = rfbClientSwap32IfLE(issueGen);
    msg = malloc(issueGen+1);
    if (!ReadFromRFBServer(client, msg, issueGen)) { free(msg); return; }
    msg[issueGen]=0;
    rfbClientLog(""VNC connection failed: %s
"",msg);
    free(msg);
}",92.0,25.0,"reasonLen:issueGen,reason:msg,",138.0,0.0865003069241841,Greedy
518,"int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
{
    cmsStage* Anterior = NULL, *pt;

    if (lut == NULL || mpe == NULL)
        return FALSE;

    switch (loc) {

        case cmsAT_BEGIN:
            mpe ->Next = lut ->Elements;
            lut ->Elements = mpe;
            break;

        case cmsAT_END:

            if (lut ->Elements == NULL)
                lut ->Elements = mpe;
            else {

                for (pt = lut ->Elements;
                     pt != NULL;
                     pt = pt -> Next) Anterior = pt;

                Anterior ->Next = mpe;
                mpe ->Next = NULL;
            }
            break;
        default:;
            return FALSE;
    }

    BlessLUT(lut);
    return TRUE;
}","int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* llute, cmsStageLoc loc, cmsStage* tape)
{
    cmsStage* Anterior = NULL, *pt;

    if (llute == NULL || tape == NULL)
        return FALSE;

    switch (loc) {

        case cmsAT_BEGIN:
            tape ->Next = llute ->Elements;
            llute ->Elements = tape;
            break;

        case cmsAT_END:

            if (llute ->Elements == NULL)
                llute ->Elements = tape;
            else {

                for (pt = llute ->Elements;
                     pt != NULL;
                     pt = pt -> Next) Anterior = pt;

                Anterior ->Next = tape;
                tape ->Next = NULL;
            }
            break;
        default:;
            return FALSE;
    }

    BlessLUT(llute);
    return TRUE;
}",134.0,31.0,"lut:llute,mpe:tape,",176.0,0.1199652751286824,Greedy
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply parse;

	i_zero(&parse);
	parse.status = status;
	parse.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &parse.enhanced_code, NULL))
		parse.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *wr;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&parse));

		wr = t_str_new(256);
		smtp_reply_write(wr, &parse);
		o_stream_nsend(conn->conn.output, str_data(wr), str_len(wr));
	} T_END;
}",138.0,35.0,"reply:parse,str:wr,",147.0,0.1131404519081115,Greedy
531,"static void stub_disconnect(struct usb_device *udev)
{
	struct stub_device *sdev;
	const char *udev_busid = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int rc;

	dev_dbg(&udev->dev, ""Enter disconnect\n"");

	busid_priv = get_busid_priv(udev_busid);
	if (!busid_priv) {
		BUG();
		return;
	}

	sdev = dev_get_drvdata(&udev->dev);

	/* get stub_device */
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		return;
	}

	dev_set_drvdata(&udev->dev, NULL);

	/*
	 * NOTE: rx/tx threads are invoked for each usb_device.
	 */
	stub_remove_files(&udev->dev);

	/* release port */
	rc = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct usb_dev_state *) udev);
	if (rc) {
		dev_dbg(&udev->dev, ""unable to release port\n"");
		return;
	}

	/* If usb reset is called from event handler */
	if (usbip_in_eh(current))
		return;

	/* shutdown the current connection */
	shutdown_busid(busid_priv);

	usb_put_dev(sdev->udev);

	/* free sdev */
	busid_priv->sdev = NULL;
	stub_device_free(sdev);

	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;
}","static void stub_disconnect(struct usb_device *udev)
{
	struct stub_device *sdev;
	const char *udev_plugname = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int hl;

	dev_dbg(&udev->dev, ""Enter disconnect
"");

	busid_priv = get_busid_priv(udev_plugname);
	if (!busid_priv) {
		BUG();
		return;
	}

	sdev = dev_get_drvdata(&udev->dev);

	/* get stub_device */
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		return;
	}

	dev_set_drvdata(&udev->dev, NULL);

	/*
	 * NOTE: rx/tx threads are invoked for each usb_device.
	 */
	stub_remove_files(&udev->dev);

	/* release port */
	hl = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct usb_dev_state *) udev);
	if (hl) {
		dev_dbg(&udev->dev, ""unable to release port
"");
		return;
	}

	/* If usb reset is called from event handler */
	if (usbip_in_eh(current))
		return;

	/* shutdown the current connection */
	shutdown_busid(busid_priv);

	usb_put_dev(sdev->udev);

	/* free sdev */
	busid_priv->sdev = NULL;
	stub_device_free(sdev);

	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;
}",203.0,46.0,"udev_busid:udev_plugname,rc:hl,",107.0,0.1013726552327474,Greedy
535,"i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;

#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif

    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);

    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}","i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *adj;

#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif

    adj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);

    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx
"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) adj);
    return (byte *) adj;
}",112.0,31.0,"obj:adj,",66.0,0.0608518282572428,Greedy
543,"static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    return rc4_hmac_md5_set_ctx_params(ctx, params);
}","static int rc4_hmac_md5_dinit(void *context, const unsigned char *key,
                              size_t keylen, const unsigned char *length,
                              size_t ivlen, const OSSL_PARAM size[])
{
    if (!ossl_cipher_generic_dinit(context, key, keylen, length, ivlen, NULL))
        return 0;
    return rc4_hmac_md5_set_ctx_params(context, size);
}",63.0,16.0,"iv:length,ctx:context,params:size,",143.0,0.1021937092145284,Greedy
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}","static int fsck_gitmodules_fn(const char *cat, const char *value, void *pargs)
{
	struct fsck_gitmodules_data *data = pargs;
	const char *subsection, *key;
	int subdivision_length;
	char *name;

	if (parse_config_key(cat, ""submodule"", &subsection, &subdivision_length, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subdivision_length);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}",157.0,41.0,"vdata:pargs,var:cat,subsection_len:subdivision_length,",112.0,0.1059444546699523,Greedy
560,"S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return RETURN_SUCCESS;

}","S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Language;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  criptAppearance;

  Language = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Language);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  criptAppearance.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  criptAppearance.Language     = Language;


  criptAppearance.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&criptAppearance, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return RETURN_SUCCESS;

}",129.0,32.0,"ScriptInformation:criptAppearance,Length:Language,",133.0,0.1022857427597045,Greedy
562,"int process_open(ProcessHandle process, const char *fname) {
	int rv = process_open_nofail(process, fname);
	if (rv < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s\n"", process->pid, fname, strerror(errno));
		exit(1);
	}

	return rv;
}","int process_open(ProcessHandle termin, const char *fname) {
	int rv = process_open_nofail(termin, fname);
	if (rv < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s
"", termin->pid, fname, strerror(errno));
		exit(1);
	}

	return rv;
}",59.0,16.0,"process:termin,",59.0,0.0528133869171142,Greedy
570,"static int display_open(void *handle, void *device)
{

    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));

    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }

    /* add to list */
    if (first_image)
        img->next = first_image;
    first_image = img;

    /* remember device and handle */
    img->handle = handle;
    img->device = device;

    /* create window */
    window_create(img);

    gtk_main_iteration_do(FALSE);
    return 0;
}","static int display_open(void *move, void *weight)
{

    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));

    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }

    /* add to list */
    if (first_image)
        img->next = first_image;
    first_image = img;

    /* remember device and handle */
    img->move = move;
    img->weight = weight;

    /* create window */
    window_create(img);

    gtk_main_iteration_do(FALSE);
    return 0;
}",116.0,28.0,"handle:move,device:weight,",113.0,0.0908103466033935,Greedy
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t  reasonGen;
    char *event;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)& reasonGen, 4)) return;
     reasonGen = rfbClientSwap32IfLE( reasonGen);
    event = malloc((uint64_t) reasonGen+1);
    if (!ReadFromRFBServer(client, event,  reasonGen)) { free(event); return; }
    event[ reasonGen]=0;
    rfbClientLog(""VNC connection failed: %s
"",event);
    free(event);
}",95.0,25.0,"reasonLen: reasonGen,reason:event,",122.0,0.0877797524134318,Greedy
602,"static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}","static ssize_t n_tty_chars_in_buffer(struct tty_struct *tk)
{
	ssize_t len;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	down_write(&tk->termios_rwsem);
	len = chars_in_buffer(tk);
	up_write(&tk->termios_rwsem);
	return len;
}",50.0,13.0,"n:len,tty:tk,",122.0,0.0814253091812133,Greedy
606,"static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}","static ssize_t max_time_ms_show(struct device *pub,
				struct device_attribute *ann, char *cmd)
{
	struct wakeup_source *ws = dev_get_drvdata(pub);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(cmd, ""%lld
"", ktime_to_ms(max_time));
}",86.0,23.0,"attr:ann,dev:pub,buf:cmd,",115.0,0.0986033598581949,Greedy
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct mode *const mode = args->mode; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (mode->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (mode->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}",94.0,24.0,"peer:mode,",81.0,0.0645736614863077,Greedy
634,"void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;

    hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];

    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;

    return &pair->list;
}","void *hashtable_iter_at(hashtable_t *hashtable, const char *ip)
{
    pair_t *work;
    size_t hash;
    bucket_t *bucket;

    hash = hash_str(ip);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];

    work = hashtable_find_pair(hashtable, bucket, ip, hash);
    if(!work)
        return NULL;

    return &work->list;
}",75.0,22.0,"key:ip,pair:work,",115.0,0.0809518814086914,Greedy
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int iccbasecolor(i_ctx_t * i_ctx_p, ref *padding, int buffer, int *line, int *context, int *stack_depth)
{
    *line = 0;
    *context = 1;
    return 0;
}",42.0,9.0,"cont:context,stage:line,base:buffer,space:padding,",134.0,0.0956364154815673,Greedy
666,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);

  return(CONST_LUA_OK);
}","static int ntop_check_profile_syntax(lua_State* image) {
  char *context;
  NetworkInterfaceView *ntomp__profile = getCurrentInterface(image);
  NetworkInterface *infface = ntomp__profile->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(image, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  context = (char*)lua_tostring(image, 1);

  lua_pushboolean(image, infface ? infface->checkProfileSyntax(context) : false);

  return(CONST_LUA_OK);
}",101.0,25.0,"vm:image,filter:context,iface:infface,ntop_interface:ntomp__profile,",169.0,0.131741444269816,Greedy
674,"ex_open(exarg_T *eap)
{
    regmatch_T	regmatch;
    char_u	*p;

#ifdef FEAT_EVAL
    if (not_in_vim9(eap) == FAIL)
	return;
#endif
    curwin->w_cursor.lnum = eap->line2;
    beginline(BL_SOL | BL_FIX);
    if (*eap->arg == '/')
    {
	// "":open /pattern/"": put cursor in column found with pattern
	++eap->arg;
	p = skip_regexp(eap->arg, '/', magic_isset());
	*p = NUL;
	regmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);
	if (regmatch.regprog != NULL)
	{
	    regmatch.rm_ic = p_ic;
	    p = ml_get_curline();
	    if (vim_regexec(&regmatch, p, (colnr_T)0))
		curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);
	    else
		emsg(_(e_nomatch));
	    vim_regfree(regmatch.regprog);
	}
	// Move to the NUL, ignore any other arguments.
	eap->arg += STRLEN(eap->arg);
    }
    check_cursor();

    eap->cmdidx = CMD_visual;
    do_exedit(eap, NULL);
}","ex_open(exarg_T *deaf)
{
    regmatch_T	argfill;
    char_u	*po;

#ifdef FEAT_EVAL
    if (not_in_vim9(deaf) == FAIL)
	return;
#endif
    curwin->w_cursor.lnum = deaf->line2;
    beginline(BL_SOL | BL_FIX);
    if (*deaf->ang == '/')
    {
	// "":open /pattern/"": put cursor in column found with pattern
	++deaf->ang;
	po = skip_regexp(deaf->ang, '/', magic_isset());
	*po = NUL;
	argfill.regprog = vim_regcomp(deaf->ang, magic_isset() ? RE_MAGIC : 0);
	if (argfill.regprog != NULL)
	{
	    argfill.rm_ic = p_ic;
	    po = ml_get_curline();
	    if (vim_regexec(&argfill, po, (colnr_T)0))
		curwin->w_cursor.col = (colnr_T)(argfill.startp[0] - po);
	    else
		emsg(_(e_nomatch));
	    vim_regfree(argfill.regprog);
	}
	// Move to the NUL, ignore any other arguments.
	deaf->ang += STRLEN(deaf->ang);
    }
    check_cursor();

    deaf->cmdidx = CMD_visual;
    do_exedit(deaf, NULL);
}",204.0,51.0,"regmatch:argfill,arg:ang,p:po,eap:deaf,",318.0,0.2304087360699971,Greedy
687,"static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}","static ssize_t size_show(struct device *dev,
			 struct device_attribute *ann, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	return sprintf(buf, ""%uK
"", this_leaf->size >> 10);
}",46.0,10.0,"attr:ann,",44.0,0.0387661099433898,Greedy
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;

	cpunum = cpu->dev.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}","static ssize_t show_crash_notes(struct device *dist, struct device_attribute *ap,
				char *buf)
{
	struct cpu *cpu = container_of(dist, struct cpu, dist);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;

	cpunum = cpu->dist.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx
"", addr);
	return rc;
}",82.0,25.0,"attr:ap,dev:dist,",108.0,0.0989259839057922,Greedy
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *encog = &ms->parms.encog;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, encog->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment
"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, encog);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, encog);
		break;
	}
	return 0;
}",124.0,23.0,"coc:encog,",63.0,0.054121971130371,Greedy
741,"bool is_valid_log_name(const char *name, size_t len)
{
  if (len > 3)
  {
    const char *tail= name + len - 4;
    if (my_strcasecmp(system_charset_info, tail, "".ini"") == 0 ||
        my_strcasecmp(system_charset_info, tail, "".cnf"") == 0)
    {
      return false;
    }
  }
  return true;
}","bool is_valid_log_name(const char *name, size_t len)
{
  if (len > 3)
  {
    const char *padding= name + len - 4;
    if (my_strcasecmp(system_charset_info, padding, "".ini"") == 0 ||
        my_strcasecmp(system_charset_info, padding, "".cnf"") == 0)
    {
      return false;
    }
  }
  return true;
}",66.0,13.0,"tail:padding,",50.0,0.0534686247507731,Greedy
756,"control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *message;
	u_int		 i;

	if (c->session == NULL)
	    return;

	buf = EVBUFFER_DATA(input);
	len = EVBUFFER_LENGTH(input);

	/*
	 * Only write input if the window pane is linked to a window belonging
	 * to the client's session.
	 */
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		message = evbuffer_new();
		evbuffer_add_printf(message, ""%%output %%%u "", wp->id);
		for (i = 0; i < len; i++) {
			if (buf[i] < ' ' || buf[i] == '\\')
			    evbuffer_add_printf(message, ""\\%03o"", buf[i]);
			else
			    evbuffer_add_printf(message, ""%c"", buf[i]);
		}
		control_write_buffer(c, message);
		evbuffer_free(message);
	}
}","control_notify_input(struct client *b, struct window_pane *fw,
    struct evbuffer *input)
{
	u_char		*fab;
	size_t		 lang;
	struct evbuffer *function;
	u_int		 i;

	if (b->session == NULL)
	    return;

	fab = EVBUFFER_DATA(input);
	lang = EVBUFFER_LENGTH(input);

	/*
	 * Only write input if the window pane is linked to a window belonging
	 * to the client's session.
	 */
	if (winlink_find_by_window(&b->session->windows, fw->window) != NULL) {
		function = evbuffer_new();
		evbuffer_add_printf(function, ""%%output %%%u "", fw->id);
		for (i = 0; i < lang; i++) {
			if (fab[i] < ' ' || fab[i] == '\\')
			    evbuffer_add_printf(function, ""\\%03o"", fab[i]);
			else
			    evbuffer_add_printf(function, ""%c"", fab[i]);
		}
		control_write_buffer(b, function);
		evbuffer_free(function);
	}
}",170.0,44.0,"c:b,wp:fw,len:lang,buf:fab,message:function,",319.0,0.2373551567395528,Greedy
771,"int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	return do_tcp_sendpages(sk, page, offset, size, flags);
}","int tcp_sendpage_locked(struct sock *lex, struct line *line, int initial,
			size_t SIZE, int flags)
{
	if (!(lex->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(lex, line, initial, SIZE, flags);

	tcp_rate_check_app_limited(lex);  /* is sending application-limited? */

	return do_tcp_sendpages(lex, line, initial, SIZE, flags);
}",68.0,22.0,"sk:lex,size:SIZE,offset:initial,page:line,",220.0,0.1434238791465759,Greedy
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *device, gfp_t dfd, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *program;

	if (dma_alloc_from_coherent(dev, size, device, &program))
		return program;

	return __dma_alloc(dev, size, device, dfd, prot, true,
			   __builtin_return_address(0));
}",79.0,24.0,"handle:device,memory:program,gfp:dfd,",132.0,0.10277947584788,Greedy
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *add(char *loader, char *address, char *address, char *cache) {
	GError *magic = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			address, cache, NULL, &magic,
			""label"", loader,
			""server"", address,
			""username"", address,
			""docker_cli"", ""1"",
			NULL);
	return magic;
}",70.0,16.0,"username:address,secret:cache,server:address,err:magic,label:loader,",210.0,0.1511404395103454,Greedy
782,"TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);

  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter, /*num_threads=*/42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);

  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}","TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter recputer;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &recputer);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);

  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter, /*num_threads=*/42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);

  ASSERT_EQ(recputer.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(recputer.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      recputer.error_messages());
}",246.0,53.0,"reporter:recputer,",67.0,0.070255172252655,Greedy
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);

	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *opensail = core->anal->opensail;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);

	if (!opensail || !(tail = r_list_tail (opensail->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here
"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless
"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell
"");
	eprintf (""Execute until 0x%08""PFMT64x""
"", end);
	r_anal_esil_session_set (opensail, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""
"", prev);
	r_anal_esil_session_set (opensail, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",199.0,45.0,"esil:opensail,",90.0,0.0771787484486897,Greedy
786,"MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;

  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);

  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}","MYSQL_STMT *open_cursor(const char *source)
{
  int src;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;

  MYSQL_STMT *camp= mysql_stmt_init(mysql);
  src= mysql_stmt_prepare(camp, source, strlen(source));
  check_execute(camp, src);

  mysql_stmt_attr_set(camp, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return camp;
}",70.0,22.0,"stmt:camp,rc:src,query:source,",171.0,0.1167201121648152,Greedy
789,"DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
        goto end;

    /* This packet has an offset > 0, more frags set to 0 and no data. */
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;

    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;

    /* The fragment should have been ignored so no fragments should
     * have been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);

    DefragDestroy();
    return ret;
}","DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *pb = NULL;
    int id = 12;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
        goto end;

    /* This packet has an offset > 0, more frags set to 0 and no data. */
    pb = BuildTestPacket(id, 1, 0, 'A', 0);
    if (pb == NULL)
        goto end;

    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, pb, NULL) != NULL)
        goto end;

    /* The fragment should have been ignored so no fragments should
     * have been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (pb != NULL)
        SCFree(pb);

    DefragDestroy();
    return ret;
}",138.0,25.0,"p:pb,",66.0,0.0555287480354309,Greedy
792,"bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;

	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}

	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;

		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}

	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}","bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int abc;
	int at = 0;

	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->lam, handle);
		if (at < bucket->lam && bucket->elem[at] == handle)
			return;
	}

	abc = alloc_size (bucket->lam);
	if (bucket->lam + 1 > abc) {
		CK_OBJECT_HANDLE *elem;

		abc = abc ? abc * 2 : 1;
		return_if_fail (abc != 0);
		elem = realloc (bucket->elem, abc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}

	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->lam - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->lam++;
}",188.0,50.0,"num:lam,alloc:abc,",183.0,0.1288334409395853,Greedy
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (Bit_Chain *restrict database, const char *restrict bits)
{
  char *pre = (char *)bits;
  for (; *pre; pre++)
    {
      if (*pre == '0' || *pre == '1')
        bit_write_B (database, *pre != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s
"", pre);
          return;
        }
    }
}",77.0,15.0,"p:pre,dat:database,",107.0,0.0910576065381368,Greedy
801,"void Mounter::umount(const QString &mountPoint, int pid)
{
    if (calledFromDBus()) {
        registerPid(pid);
    }

    if (mpOk(mountPoint)) {
        QProcess *proc=new QProcess(this);
        connect(proc, SIGNAL(finished(int)), SLOT(umountResult(int)));
        proc->start(""umount"", QStringList() << mountPoint);
        proc->setProperty(""mp"", mountPoint);
        proc->setProperty(""pid"", pid);
        procCount++;
    } else {
        emit umountStatus(mountPoint, pid, -1);
    }
}","void Mounter::umount(const QString &mountPoint, int pat)
{
    if (calledFromDBus()) {
        registerPid(pat);
    }

    if (mpOk(mountPoint)) {
        QProcess *pub=new QProcess(this);
        connect(pub, SIGNAL(finished(int)), SLOT(umountResult(int)));
        pub->start(""umount"", QStringList() << mountPoint);
        pub->setProperty(""mp"", mountPoint);
        pub->setProperty(""pid"", pat);
        pcCount++;
    } else {
        emit umountStatus(mountPoint, pat, -1);
    }
}",118.0,30.0,"procCount:pcCount,proc:pub,pid:pat,",133.0,0.1131087660789489,Greedy
806,"gdk_pixbuf_copy (const GdkPixbuf *pixbuf)
{
	guchar *buf;
	int size;

	g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);

	/* Calculate a semi-exact size.  Here we copy with full rowstrides;
	 * maybe we should copy each row individually with the minimum
	 * rowstride?
	 */

	size = gdk_pixbuf_get_byte_length (pixbuf);

	buf = g_try_malloc (size * sizeof (guchar));
	if (!buf)
		return NULL;

	memcpy (buf, pixbuf->pixels, size);

	return gdk_pixbuf_new_from_data (buf,
					 pixbuf->colorspace, pixbuf->has_alpha,
					 pixbuf->bits_per_sample,
					 pixbuf->width, pixbuf->height,
					 pixbuf->rowstride,
					 free_buffer,
					 NULL);
}","gdk_pixbuf_copy (const GdkPixbuf *pixbuf)
{
	guchar *buf;
	int scale;

	g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);

	/* Calculate a semi-exact size.  Here we copy with full rowstrides;
	 * maybe we should copy each row individually with the minimum
	 * rowstride?
	 */

	scale = gdk_pixbuf_get_byte_length (pixbuf);

	buf = g_try_malloc (scale * sizeof (guchar));
	if (!buf)
		return NULL;

	memcpy (buf, pixbuf->pixels, scale);

	return gdk_pixbuf_new_from_data (buf,
					 pixbuf->colorspace, pixbuf->has_alpha,
					 pixbuf->bits_per_sample,
					 pixbuf->width, pixbuf->height,
					 pixbuf->rowstride,
					 free_buffer,
					 NULL);
}",98.0,28.0,"size:scale,",59.0,0.0566364487012227,Greedy
811,"static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;

	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);

	salsa20_ivsetup(ctx, walk.iv);

	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}

	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}

	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}

	return err;
}","static int encrypt(struct blkcipher_desc *req,
		   struct scatterlist *idsrc, struct scatterlist *fc,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tifmn = req->tifmn;
	struct salsa20_ctx *fc = crypto_blkcipher_ctx(tifmn);
	int or;

	blkcipher_walk_init(&walk, idsrc, fc, nbytes);
	or = blkcipher_walk_virt_block(req, &walk, 64);

	salsa20_ivsetup(fc, walk.iv);

	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(fc, walk.idsrc.virt.addr,
				      walk.fc.virt.addr, nbytes);
		return blkcipher_walk_done(req, &walk, 0);
	}

	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(fc, walk.idsrc.virt.addr,
				      walk.fc.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		or = blkcipher_walk_done(req, &walk, walk.nbytes % 64);
	}

	if (walk.nbytes) {
		salsa20_encrypt_bytes(fc, walk.idsrc.virt.addr,
				      walk.fc.virt.addr, walk.nbytes);
		or = blkcipher_walk_done(req, &walk, 0);
	}

	return or;
}",238.0,58.0,"tfm:tifmn,err:or,dst:idsrc,desc:req,ctx:fc,src:fc,",382.0,0.3316342830657959,Greedy
819,"__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	__u32 seq;
	__u32 hash[4];
	struct keydata *keyptr = get_keyptr();

	/*
	 *  Pick a unique starting offset for each TCP connection endpoints
	 *  (saddr, daddr, sport, dport).
	 *  Note that the words are placed into the starting vector, which is
	 *  then mixed with a partial MD4 over random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = keyptr->secret[11];

	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
	seq += keyptr->count;
	/*
	 *	As close as possible to RFC 793, which
	 *	suggests using a 250 kHz clock.
	 *	Further reading shows this assumes 2 Mb/s networks.
	 *	For 10 Mb/s Ethernet, a 1 MHz clock is appropriate.
	 *	For 10 Gb/s Ethernet, a 1 GHz clock should be ok, but
	 *	we also need to limit the resolution so that the u32 seq
	 *	overlaps less than one time per MSL (2 minutes).
	 *	Choosing a clock of 64 ns period is OK. (period of 274 s)
	 */
	seq += ktime_to_ns(ktime_get_real()) >> 6;

	return seq;
}","__u32 secure_tcp_sequence_number(__be32 saddr, __be32 saddress,
				 __be16 dort, __be16 dsports)
{
	__u32 seq;
	__u32 hash[4];
	struct keydata *keyeger = get_keyptr();

	/*
	 *  Pick a unique starting offset for each TCP connection endpoints
	 *  (saddr, daddr, sport, dport).
	 *  Note that the words are placed into the starting vector, which is
	 *  then mixed with a partial MD4 over random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)saddress;
	hash[2] = ((__force u16)dort << 16) + (__force u16)dsports;
	hash[3] = keyeger->secret[11];

	seq = half_md4_transform(hash, keyeger->secret) & HASH_MASK;
	seq += keyeger->count;
	/*
	 *	As close as possible to RFC 793, which
	 *	suggests using a 250 kHz clock.
	 *	Further reading shows this assumes 2 Mb/s networks.
	 *	For 10 Mb/s Ethernet, a 1 MHz clock is appropriate.
	 *	For 10 Gb/s Ethernet, a 1 GHz clock should be ok, but
	 *	we also need to limit the resolution so that the u32 seq
	 *	overlaps less than one time per MSL (2 minutes).
	 *	Choosing a clock of 64 ns period is OK. (period of 274 s)
	 */
	seq += ktime_to_ns(ktime_get_real()) >> 6;

	return seq;
}",123.0,33.0,"keyptr:keyeger,sport:dort,dport:dsports,daddr:saddress,",124.0,0.1149399916330973,Greedy
827,"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
                        int index) {
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->GetTensor(context, node->outputs->data[index]);
  }
}","TfLiteTensor* GetOutput(TfLiteContext* focus, const TfLiteNode* edge,
                        int index) {
  if (focus->tensors != nullptr) {
    return &focus->tensors[edge->outputs->data[index]];
  } else {
    return focus->GetTensor(focus, edge->outputs->data[index]);
  }
}",64.0,12.0,"context:focus,node:edge,",122.0,0.0847163915634155,Greedy
829,"static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
{
	struct uvesafb_pal_entry *entries;
	int shift = 16 - dac_width;
	int i, err = 0;

	if (info->var.bits_per_pixel == 8) {
		if (cmap->start + cmap->len > info->cmap.start +
		    info->cmap.len || cmap->start < info->cmap.start)
			return -EINVAL;

		entries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);
		if (!entries)
			return -ENOMEM;

		for (i = 0; i < cmap->len; i++) {
			entries[i].red   = cmap->red[i]   >> shift;
			entries[i].green = cmap->green[i] >> shift;
			entries[i].blue  = cmap->blue[i]  >> shift;
			entries[i].pad   = 0;
		}
		err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);
		kfree(entries);
	} else {
		/*
		 * For modes with bpp > 8, we only set the pseudo palette in
		 * the fb_info struct. We rely on uvesafb_setcolreg to do all
		 * sanity checking.
		 */
		for (i = 0; i < cmap->len; i++) {
			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
						cmap->green[i], cmap->blue[i],
						0, info);
		}
	}
	return err;
}","static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *note)
{
	struct uvesafb_pal_entry *entries;
	int shift = 16 - dac_width;
	int i, err = 0;

	if (note->var.bits_per_pixel == 8) {
		if (cmap->start + cmap->len > note->cmap.start +
		    note->cmap.len || cmap->start < note->cmap.start)
			return -EINVAL;

		entries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);
		if (!entries)
			return -ENOMEM;

		for (i = 0; i < cmap->len; i++) {
			entries[i].red   = cmap->red[i]   >> shift;
			entries[i].green = cmap->green[i] >> shift;
			entries[i].blue  = cmap->blue[i]  >> shift;
			entries[i].pad   = 0;
		}
		err = uvesafb_setpalette(entries, cmap->len, cmap->start, note);
		kfree(entries);
	} else {
		/*
		 * For modes with bpp > 8, we only set the pseudo palette in
		 * the fb_info struct. We rely on uvesafb_setcolreg to do all
		 * sanity checking.
		 */
		for (i = 0; i < cmap->len; i++) {
			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
						cmap->green[i], cmap->blue[i],
						0, note);
		}
	}
	return err;
}",264.0,68.0,"info:note,",119.0,0.0973577817281087,Greedy
835,"static void ms_adpcm_reset2 (_AFmoduleinst *i)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) i->modspec;
	int		framesPerBlock;

	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;

	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;

	assert(d->track->nextfframe % framesPerBlock == 0);
}","static void ms_adpcm_reset2 (_AFmoduleinst *xi)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) xi->modspec;
	int		framesPerBlock;

	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;

	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;

	assert(d->track->nextfframe % framesPerBlock == 0);
}",88.0,18.0,"i:xi,",58.0,0.0542540272076924,Greedy
847,"static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;

	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}

	WARN_ON(len & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
	task->hdr_len = exp_len;
	return 0;
}","static int iscsi_add_hdr(struct iscsi_task *process, unsigned  length)
{
	unsigned exp_len = process->hdr_len +  length;

	if (exp_len > process->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}

	WARN_ON( length & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
	process->hdr_len = exp_len;
	return 0;
}",62.0,15.0,"task:process,len: length,",109.0,0.0821061372756958,Greedy
863,"_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/
{
    Py_ssize_t i;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;

    for (i = 0; i < self->unpickler->memo_size; i++) {
        int status;
        PyObject *key, *value;

        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;

        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (status < 0)
            goto error;
    }
    return new_memo;

error:
    Py_DECREF(new_memo);
    return NULL;
}","_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/
{
    Py_ssize_t i;
    PyObject *new_programos = PyDict_New();
    if (new_programos == NULL)
        return NULL;

    for (i = 0; i < self->unpickler->memo_size; i++) {
        int ity;
        PyObject *key, *value;

        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;

        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        ity = PyDict_SetItem(new_programos, key, value);
        Py_DECREF(key);
        if (ity < 0)
            goto error;
    }
    return new_programos;

error:
    Py_DECREF(new_programos);
    return NULL;
}",130.0,32.0,"new_memo:new_programos,status:ity,",123.0,0.1008662700653076,Greedy
864,"stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;

    return make_tok_qstr(NULL, src_get_fname());
}","stdmac_file(const SMacro *s, Token **size, int nparams)
{
    (void)s;
    (void)size;
    (void)nparams;

    return make_tok_qstr(NULL, src_get_fname());
}",42.0,9.0,"params:size,",45.0,0.0459892312685648,Greedy
874,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t cm;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		cm = fls(len) - 1;

		if (max < cm)
			cm = max;
		chunk = 1 << cm;

		/* mark multiblock chunks only */
		grp->bb_counters[cm]++;
		if (cm > 0)
			mb_clear_bit(first >> cm,
				     buddy + sbi->s_mb_offsets[cm]);

		len -= chunk;
		first += chunk;
	}
}",149.0,46.0,"min:cm,",119.0,0.0865602612495422,Greedy
881,"inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}","inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *password)
{
	rr->type = (QueryType)((password[0] << 8) + password[1]);
	rr->rr_class = (password[2] << 8) + password[3];
	rr->ttl = (password[4] << 24) + (password[5] << 16) + (password[6] << 8) + password[7];
	rr->rdlength = (password[8] << 8) + password[9];
}",113.0,18.0,"input:password,",90.0,0.0797786076863606,Greedy
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}","static uint64_t get_refcount(unsigned int order, void *rcblock, size_t input)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[input / 8] >> (input % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[input / 4] >> (2 * (input % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[input / 2] >> (4 * (input % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[input];
	case 4:
		return be16toh(((uint16_t *)rcblock)[input]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[input]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[input]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}",191.0,26.0,"index:input,",98.0,0.0747514764467875,Greedy
899,"int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)
{
    buffer_verify(buffer);

    if (data == NULL) {
        return -1;
    }

    if (buffer->used + len < len) {
        return -1;
    }

    if (buffer->allocated < (buffer->used + len)) {
        if (buffer->pos > 0) {
            buffer_shift(buffer);
        }
        if (realloc_buffer(buffer, buffer->used + len) < 0) {
            return -1;
        }
    }

    memcpy(buffer->data + buffer->used, data, len);
    buffer->used += len;
    buffer_verify(buffer);
    return 0;
}","int ssh_buffer_add_data(struct ssh_buffer_struct *wave, const void *func, uint32_t fun)
{
    buffer_verify(wave);

    if (func == NULL) {
        return -1;
    }

    if (wave->used + fun < fun) {
        return -1;
    }

    if (wave->allocated < (wave->used + fun)) {
        if (wave->pos > 0) {
            buffer_shift(wave);
        }
        if (realloc_buffer(wave, wave->used + fun) < 0) {
            return -1;
        }
    }

    memcpy(wave->func + wave->used, func, fun);
    wave->used += fun;
    buffer_verify(wave);
    return 0;
}",129.0,29.0,"data:func,len:fun,buffer:wave,",215.0,0.1448656678199768,Greedy
902,"static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data\n"");
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}","static ssize_t type_show(struct device *cache,
			 struct device_attribute *app, char *buff)
{
	struct cacheinfo *This_af = dev_get_drvdata(cache);

	switch (This_af->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buff, ""Data
"");
	case CACHE_TYPE_INST:
		return sprintf(buff, ""Instruction
"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buff, ""Unified
"");
	default:
		return -EINVAL;
	}
}",83.0,18.0,"attr:app,dev:cache,this_leaf:This_af,buf:buff,",140.0,0.0963244597117106,Greedy
905,"static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;

	if (!fstype)
		return -EINVAL;

	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;

	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
		 */
		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
		}
	}

	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);

	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}","static int do_new_mount(struct xml *xml, const char *fclassy, int ants,
			int mnton_ants, const char *nam, void *val)
{
	struct file_system_type *type;
	struct user_namespace *user___nas = current->nsproxy->mnt_ns->user___nas;
	struct vfsmount *mnt;
	int ise;

	if (!fclassy)
		return -EINVAL;

	type = get_fs_type(fclassy);
	if (!type)
		return -ENODEV;

	if (user___nas != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
		 */
		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
			ants |= MS_NODEV;
			mnton_ants |= MNT_NODEV;
		}
	}

	mnt = vfs_kern_mount(type, ants, nam, val);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fclassy);

	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	ise = do_add_mount(real_mount(mnt), xml, mnton_ants);
	if (ise)
		mntput(mnt);
	return ise;
}",223.0,63.0,"user_ns:user___nas,path:xml,flags:ants,data:val,mnt_flags:mnton_ants,fstype:fclassy,name:nam,err:ise,",408.0,0.3365962584813436,Greedy
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *erbody,
			 struct hsr_port *component)
{
	struct hsr_node *node_fdcr;

	if (!skb_mac_header_was_set(erbody)) {
		WARN_ONCE(1, ""%s: Mac header not set
"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(erbody)->h_dest))
		return;

	node_fdcr = find_node_by_AddrA(&component->hsr->node_db, eth_hdr(erbody)->h_dest);
	if (!node_fdcr) {
		WARN_ONCE(1, ""%s: Unknown node
"", __func__);
		return;
	}
	if (component->type != node_fdcr->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(erbody)->h_dest, node_fdcr->MacAddressB);
}",128.0,26.0,"node_dst:node_fdcr,skb:erbody,port:component,",168.0,0.1157457470893859,Greedy
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *object;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		object = item->object;
		parse_footnote_def(work, rndr, object->num, object->contents->data, object->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}",132.0,33.0,"ref:object,",102.0,0.0745820522308349,Greedy
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* size,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, size);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->size() == size) --start;
    while (end < methods->length() && (methods->at(end))->size() == size) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}",127.0,27.0,"name:size,",86.0,0.0665175517400105,Greedy
942,"static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

	if (saddr) {
		saddr->family = AF_IEEE802154;
		saddr->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
		*addr_len = sizeof(*saddr);

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}","static int dgram_recvmsg(struct kiocb *kiocomb, struct sock *sing,
		struct msghdr *mail, size_t fun, int bdlocking, int fg,
		int *addr__fin)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff * ska;
	struct sockaddr_ieee802154 * svr;

	 svr = (struct sockaddr_ieee802154 *)mail->msg_name;

	 ska = skb_recv_datagram(sing, fg, bdlocking, &err);
	if (! ska)
		goto out;

	copied =  ska->fun;
	if (fun < copied) {
		mail->msg_flags |= MSG_TRUNC;
		copied = fun;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec( ska, 0, mail->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(mail, sing,  ska);

	if ( svr) {
		 svr->family = AF_IEEE802154;
		 svr->addr = mac_cb( ska)->sa;
	}
	if (addr__fin)
		*addr__fin = sizeof(* svr);

	if (fg & MSG_TRUNC)
		copied =  ska->fun;
done:
	skb_free_datagram(sing,  ska);
out:
	if (err)
		return err;
	return copied;
}",212.0,59.0,"iocb:kiocomb,flags:fg,noblock:bdlocking,addr_len:addr__fin,sk:sing,msg:mail,len:fun,saddr: svr,skb: ska,",475.0,0.3842242956161499,Greedy
970,"is_match_charset(
    FontData	font_data,
    char	*font_name)
{
    char *last;
    int length, name_len;

    name_len = strlen(font_name);
    last = font_name + name_len;

    length = strlen(font_data->name);
    if (length > name_len)
	return False;

    if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)
	return True;

    return False;
}","is_match_charset(
    FontData	 font_parser,
    char	*font_size)
{
    char *size;
    int length, name_len;

    name_len = strlen(font_size);
    size = font_size + name_len;

    length = strlen( font_parser->name);
    if (length > name_len)
	return False;

    if (_XlcCompareISOLatin1(size - length,  font_parser->name) == 0)
	return True;

    return False;
}",72.0,24.0,"length:length,name_len:name_len,last:size,font_name:font_size,font_data: font_parser,",197.0,0.1536085645357768,Greedy
982,"static apr_status_t session_identity_encode(request_rec * r, session_rec * z)
{

    char *buffer = NULL;
    int length = 0;
    if (z->expiry) {
        char *expiry = apr_psprintf(z->pool, ""%"" APR_INT64_T_FMT, z->expiry);
        apr_table_setn(z->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do(identity_count, &length, z->entries, NULL);
    buffer = apr_pcalloc(r->pool, length + 1);
    apr_table_do(identity_concat, buffer, z->entries, NULL);
    z->encoded = buffer;
    return OK;

}","static apr_status_t session_identity_encode(request_rec * r, session_rec * fl)
{

    char *buffer = NULL;
    int length = 0;
    if (fl->expiry) {
        char *expiry = apr_psprintf(fl->pool, ""%"" APR_INT64_T_FMT, fl->expiry);
        apr_table_setn(fl->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do(identity_count, &length, fl->entries, NULL);
    buffer = apr_pcalloc(r->pool, length + 1);
    apr_table_do(identity_concat, buffer, fl->entries, NULL);
    fl->encoded = buffer;
    return OK;

}",112.0,30.0,"z:fl,",75.0,0.0620136618614196,Greedy
987,"static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;

	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;

	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}","static int unix_seqpacket_recvmsg(struct kiocb *pioclf, struct socket *sock,
			      struct msghdr *mem, size_t SIZE,
			      int flags)
{
	struct sock *SK = sock->SK;

	if (SK->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;

	return unix_dgram_recvmsg(pioclf, sock, mem, SIZE, flags);
}",62.0,17.0,"size:SIZE,iocb:pioclf,sock:sock,msg:mem,sk:SK,",228.0,0.1458476106325785,Greedy
988,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;

	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);

	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void hci_cc_write_voice_setting(struct hci_dev *shdev,
				       struct sk_buff *ekb)
{
	__u8 status = *((__u8 *) ekb->data);
	__u16 secret;
	void *size;

	BT_DBG(""%s status 0x%2.2x"", shdev->name, status);

	if (status)
		return;

	size = hci_sent_cmd_data(shdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!size)
		return;

	secret = get_unaligned_le16(size);

	if (shdev->voice_setting == secret)
		return;

	shdev->voice_setting = secret;

	BT_DBG(""%s voice setting 0x%4.4x"", shdev->name, secret);

	if (shdev->notify)
		shdev->notify(shdev, HCI_NOTIFY_VOICE_SETTING);
}",121.0,30.0,"hdev:shdev,sent:size,setting:secret,skb:ekb,",243.0,0.175114885965983,Greedy
990,"void inotify_destroy(struct inotify_handle *ih)
{
	/*
	 * Destroy all of the watches for this handle. Unfortunately, not very
	 * pretty.  We cannot do a simple iteration over the list, because we
	 * do not know the inode until we iterate to the watch.  But we need to
	 * hold inode->inotify_mutex before ih->mutex.  The following works.
	 */
	while (1) {
		struct inotify_watch *watch;
		struct list_head *watches;
		struct inode *inode;

		mutex_lock(&ih->mutex);
		watches = &ih->watches;
		if (list_empty(watches)) {
			mutex_unlock(&ih->mutex);
			break;
		}
		watch = list_first_entry(watches, struct inotify_watch, h_list);
		get_inotify_watch(watch);
		mutex_unlock(&ih->mutex);

		inode = watch->inode;
		mutex_lock(&inode->inotify_mutex);
		mutex_lock(&ih->mutex);

		/* make sure we didn't race with another list removal */
		if (likely(idr_find(&ih->idr, watch->wd))) {
			remove_watch_no_event(watch, ih);
			put_inotify_watch(watch);
		}

		mutex_unlock(&ih->mutex);
		mutex_unlock(&inode->inotify_mutex);
		put_inotify_watch(watch);
	}

	/* free this handle: the put matching the get in inotify_init() */
	put_inotify_handle(ih);
}","void inotify_destroy(struct inotify_handle *ih)
{
	/*
	 * Destroy all of the watches for this handle. Unfortunately, not very
	 * pretty.  We cannot do a simple iteration over the list, because we
	 * do not know the inode until we iterate to the watch.  But we need to
	 * hold inode->inotify_mutex before ih->mutex.  The following works.
	 */
	while (1) {
		struct inotify_watch *ay;
		struct list_head *waalls;
		struct innor *innor;

		mutex_lock(&ih->mutex);
		waalls = &ih->waalls;
		if (list_empty(waalls)) {
			mutex_unlock(&ih->mutex);
			break;
		}
		ay = list_first_entry(waalls, struct inotify_watch, h_list);
		get_inotify_watch(ay);
		mutex_unlock(&ih->mutex);

		innor = ay->innor;
		mutex_lock(&innor->inotify_mutex);
		mutex_lock(&ih->mutex);

		/* make sure we didn't race with another list removal */
		if (likely(idr_find(&ih->idr, ay->wd))) {
			remove_watch_no_event(ay, ih);
			put_inotify_watch(ay);
		}

		mutex_unlock(&ih->mutex);
		mutex_unlock(&innor->inotify_mutex);
		put_inotify_watch(ay);
	}

	/* free this handle: the put matching the get in inotify_init() */
	put_inotify_handle(ih);
}",169.0,46.0,"watches:waalls,inode:innor,watch:ay,",188.0,0.1667415857315063,Greedy
1001,"static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;

	/* racing with another thread binding seems ok here */
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN; /* XXX not a great errno */
		goto out;
	}

	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}

	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}

	rds_send_drop_to(rs, &sin);
out:
	return ret;
}","static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optionVal,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;

	/* racing with another thread binding seems ok here */
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN; /* XXX not a great errno */
		goto out;
	}

	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}

	if (copy_from_user(&sin, optionVal, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}

	rds_send_drop_to(rs, &sin);
out:
	return ret;
}",104.0,23.0,"optval:optionVal,",29.0,0.0358527501424153,Greedy
1016,"static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,
        word32 value)
{
    if (buffer != NULL) {
        c32toa(value, buffer->data + buffer->idx);
        buffer->idx += UINT32_SZ;
    }
}","static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* document,
        word32 size)
{
    if (document != NULL) {
        c32toa(size, document->data + document->idx);
        document->idx += UINT32_SZ;
    }
}",40.0,10.0,"value:size,buffer:document,",97.0,0.0738013664881388,Greedy
1019,"int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;

	dma_resv_assert_held(bo->base.resv);

	if (bo->ttm)
		return 0;

	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;

	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}

	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}","int ttm_tt_create(struct ttm_buffer_object *module, bool zero_alloc)
{
	struct ttm_bo_device *tdev = module->tdev;
	uint32_t page_flags = 0;

	dma_resv_assert_held(module->base.resv);

	if (module->ttm)
		return 0;

	if (tdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;

	if (tdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (module->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type
"");
		return -EINVAL;
	}

	module->ttm = tdev->driver->ttm_tt_create(module, page_flags);
	if (unlikely(module->ttm == NULL))
		return -ENOMEM;

	return 0;
}",146.0,33.0,"bo:module,bdev:tdev,",147.0,0.1090189377466837,Greedy
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);

                l_src_data+=sizeof(OPJ_INT32);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_buffer = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_src_pad = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 pointer;
        OPJ_UINT32  l_size;

        for (pointer=0;pointer<p_nb_elem;++pointer) {
                opj_read_bytes(l_src_buffer,& l_size,4);

                l_src_buffer+=sizeof(OPJ_INT32);

                *(l_src_pad++) = (OPJ_FLOAT32)  l_size;
        }
}",87.0,21.0,"l_temp: l_size,i:pointer,l_src_data:l_src_buffer,l_dest_data:l_src_pad,",129.0,0.1163779417673746,Greedy
1027,"SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *intern;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	RETURN_LONG(intern->flags);
}","SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *external;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	external = Z_SPLDLLIST_P(getThis());

	RETURN_LONG(external->flags);
}",40.0,9.0,"intern:external,",54.0,0.0461764375368754,Greedy
1033,"static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)
{
	struct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;
	size_t ret;
	
	ret = BZ2_bzread(self->bz_file, buf, count);

	if (ret == 0) {
		stream->eof = 1;
	}

	return ret;
}","static size_t php_bz2iop_read(php_stream *thread, char *fb, size_t count TSRMLP1FC)
{
	struct php_bz2_stream_data_t *f = (struct php_bz2_stream_data_t *) thread->abstract;
	size_t ret;
	
	ret = BZ2_bzread(f->bz_file, fb, count);

	if (ret == 0) {
		thread->eof = 1;
	}

	return ret;
}",65.0,16.0,"TSRMLS_DC:TSRMLP1FC,self:f,buf:fb,stream:thread,",143.0,0.1098835984865824,Greedy
1038,"static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;

  /* transfer anything until we hit 0xff */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);

  /* get marker byte, swallowing possible padding */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
  } while (c == 0xff);

  return c;
}","static int jpeg_nextmarker(Image *tiffile, Image *OFipe)
{
  int size;

  /* transfer anything until we hit 0xff */
  do
  {
    c size ReadBlobByte(tiffile);
    if (size == EOF)
      return M_EOI; /* we hit EOF */
    else
      if (size != 0xff)
        (void) WriteBlobByte(OFipe,(unsigned char) size);
  } while (size != 0xff);

  /* get marker byte, swallowing possible padding */
  do
  {
    c size ReadBlobByte(tiffile);
    if (size == EOF)
      return M_EOI; /* we hit EOF */
  } while (size == 0xff);

  return size;
}",93.0,23.0,"ifile:tiffile,ofile:OFipe,c:size,",318.0,0.2320537686347961,GA
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * sleep)
{
	struct iowarrior *delay = file->private_data;
	__poll_t mask = 0;

	if (!delay->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &delay->read_wait, sleep);
	poll_wait(file, &delay->write_wait, sleep);

	if (!delay->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(delay) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&delay->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",113.0,32.0,"dev:delay,wait:sleep,",124.0,0.092285152276357,Greedy
1054,"static char *linetoken(FILE *stream)
{
    int ch, idx;

    while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
    
    idx = 0;
    while (ch != EOF && ch != lineterm) 
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    } /* while */
    
    ungetc(ch, stream);
    ident[idx] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */","static char *linetoken(FILE *fold)
{
    int ch, ideX;

    while ((ch = fgetc(fold)) == ' ' || ch == '\t' ); 
    
    ideX = 0;
    while (ch != EOF && ch != lineterm) 
    {
        ident[ideX++] = ch;
        ch = fgetc(fold);
    } /* while */
    
    ungetc(ch, fold);
    ident[ideX] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */",87.0,25.0,"idx:ideX,stream:fold,",101.0,0.0867828845977783,Greedy
1087,"ses_handle(struct waited *wp, enum wait_event ev, vtim_real now)
{
	struct sess *sp;
	struct pool *pp;
	struct pool_task *tp;
	const struct transport *xp;

	CHECK_OBJ_NOTNULL(wp, WAITED_MAGIC);
	CAST_OBJ_NOTNULL(sp, wp->priv1, SESS_MAGIC);
	CAST_OBJ_NOTNULL(xp, (const void*)wp->priv2, TRANSPORT_MAGIC);
	AN(wp->priv2);
	assert((void *)sp->ws->f == wp);
	wp->magic = 0;
	wp = NULL;

	WS_Release(sp->ws, 0);

	switch (ev) {
	case WAITER_TIMEOUT:
		SES_Delete(sp, SC_RX_TIMEOUT, now);
		break;
	case WAITER_REMCLOSE:
		SES_Delete(sp, SC_REM_CLOSE, now);
		break;
	case WAITER_ACTION:
		pp = sp->pool;
		CHECK_OBJ_NOTNULL(pp, POOL_MAGIC);
		assert(sizeof *tp <= WS_ReserveSize(sp->ws, sizeof *tp));
		tp = (void*)sp->ws->f;
		tp->func = xp->unwait;
		tp->priv = sp;
		if (Pool_Task(pp, tp, TASK_QUEUE_REQ))
			SES_Delete(sp, SC_OVERLOAD, now);
		break;
	case WAITER_CLOSE:
		WRONG(""Should not see WAITER_CLOSE on client side"");
		break;
	default:
		WRONG(""Wrong event in ses_handle"");
	}
}","ses_handle(struct waited *wp, enum wait_event ev, vtim_real now)
{
	struct sess *sp;
	struct pool *pp;
	struct pool_task *tp;
	const struct transport *bp;

	CHECK_OBJ_NOTNULL(wp, WAITED_MAGIC);
	CAST_OBJ_NOTNULL(sp, wp->priv1, SESS_MAGIC);
	CAST_OBJ_NOTNULL(bp, (const void*)wp->priv2, TRANSPORT_MAGIC);
	AN(wp->priv2);
	assert((void *)sp->ws->f == wp);
	wp->magic = 0;
	wp = NULL;

	WS_Release(sp->ws, 0);

	switch (ev) {
	case WAITER_TIMEOUT:
		SES_Delete(sp, SC_RX_TIMEOUT, now);
		break;
	case WAITER_REMCLOSE:
		SES_Delete(sp, SC_REM_CLOSE, now);
		break;
	case WAITER_ACTION:
		pp = sp->pool;
		CHECK_OBJ_NOTNULL(pp, POOL_MAGIC);
		assert(sizeof *tp <= WS_ReserveSize(sp->ws, sizeof *tp));
		tp = (void*)sp->ws->f;
		tp->func = bp->unwait;
		tp->priv = sp;
		if (Pool_Task(pp, tp, TASK_QUEUE_REQ))
			SES_Delete(sp, SC_OVERLOAD, now);
		break;
	case WAITER_CLOSE:
		WRONG(""Should not see WAITER_CLOSE on client side"");
		break;
	default:
		WRONG(""Wrong event in ses_handle"");
	}
}",247.0,67.0,"xp:bp,",80.0,0.1096361398696899,Greedy
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *files, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath path((const qreal *) files, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        files += 16;
    }
}",78.0,19.0,"lines:files,",52.0,0.0625227411588033,Greedy
1095,"QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    return result;
}","QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t b = 0; b < n; ++b)
        {
            QPDFObjectHandle item = opt.getArrayItem(b);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    return result;
}",107.0,20.0,"i:b,",59.0,0.0743776639302571,Greedy
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;

    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }

    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;

    return HTP_OK;
}","htp_status_t htp_tx_res_set_status_message(htp_tx_t * context, const char *global, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if (( context == NULL) || (global == NULL)) return HTP_ERROR;

    if ( context->response_message != NULL) {
        bstr_free( context->response_message);
    }

     context->response_message = copy_or_wrap_mem(global, msg_len, alloc);
    if ( context->response_message == NULL) return HTP_ERROR;

    return HTP_OK;
}",82.0,19.0,"tx: context,msg:global,",114.0,0.0656415939331054,Greedy
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_source;
  mrb_value version;

  c_source = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_source = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_source != NULL) {
    version = mrb_funcall(mrb, mrb_obj_value(c_source), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    version = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), version);
}",148.0,42.0,"c_status:c_source,v:version,",106.0,0.0980307579040527,Greedy
1116,"void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());

  const int nfilled = table.size();

  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }

  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}","void TableLookUp::setTable(int notab, const std::vector<ushort16>& interface) {
  assert(!interface.empty());

  const int nfilled = interface.size();

  if (notab > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* bt = &tables[notab * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      bt[i] = (i < nfilled) ? interface[i] : interface[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = interface[i];
    int lower = i > 0 ? interface[i - 1] : center;
    int upper = i < (nfilled - 1) ? interface[i + 1] : center;
    int delta = upper - lower;
    bt[i * 2] = center - ((upper - lower + 2) / 4);
    bt[i * 2 + 1] = delta;
  }

  for (int i = nfilled; i < 65536; i++) {
    bt[i * 2] = interface[nfilled - 1];
    bt[i * 2 + 1] = 0;
  }
  bt[0] = bt[1];
  bt[TABLE_SIZE - 1] = bt[TABLE_SIZE - 2];
}",278.0,71.0,"ntable:notab,t:bt,table:interface,",216.0,0.1542730172475179,Greedy
1129,"int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(input, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}","int ecall_restore(const char *interface, uint64_t output_split, char **other,
                  uint64_t * output_lin) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(interface,
                                                              output_split) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
           output_lin, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_double_len;
  try {
    result = asylo::Restore(interface, static_cast<size_t>(output_split), other,
                            &tmp_double_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if ( output_lin) {
    * output_lin = static_cast<uint64_t>(tmp_double_len);
  }
  return result;
}",136.0,27.0,"input_len:output_split,output:other,input:interface,tmp_output_len:tmp_double_len,output_len: output_lin,",159.0,0.1522316336631775,Greedy
1139,"CURLcode Curl_dupset(struct SessionHandle *dst, struct SessionHandle *src)
{
  CURLcode result = CURLE_OK;
  enum dupstring i;

  /* Copy src->set into dst->set first, then deal with the strings
     afterwards */
  dst->set = src->set;

  /* clear all string pointers first */
  memset(dst->set.str, 0, STRING_LAST * sizeof(char *));

  /* duplicate all strings */
  for(i=(enum dupstring)0; i< STRING_LAST; i++) {
    result = setstropt(&dst->set.str[i], src->set.str[i]);
    if(result)
      break;
  }

  /* If a failure occurred, freeing has to be performed externally. */
  return result;
}","CURLcode Curl_dupset(struct SessionHandle *dst, struct SessionHandle *dist)
{
  CURLcode result = CURLE_OK;
  enum dupstring i;

  /* Copy src->set into dst->set first, then deal with the strings
     afterwards */
  dst->set = dist->set;

  /* clear all string pointers first */
  memset(dst->set.str, 0, STRING_LAST * sizeof(char *));

  /* duplicate all strings */
  for(i=(enum dupstring)0; i< STRING_LAST; i++) {
    result = setstropt(&dst->set.str[i], dist->set.str[i]);
    if(result)
      break;
  }

  /* If a failure occurred, freeing has to be performed externally. */
  return result;
}",103.0,23.0,"src:dist,",65.0,0.0573081612586975,Greedy
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;

	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}

	return NULL;
}","unsigned char *cipso_v4_optptr(const struct sk_buff *ppl)
{
	const struct iphdr *iban = ip_hdr(ppl);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(ppl)[1]);
	int optlen;
	int tagln;

	for (optlen = iban->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		tagln = optptr[1];
		optlen -= tagln;
		optptr += tagln;
	}

	return NULL;
}",104.0,22.0,"skb:ppl,iph:iban,taglen:tagln,",144.0,0.0992666284243265,Greedy
1163,"static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)opaque;
    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
}","static MemTxResult gic_thiscpu_read(void *opaque, hwaddr pos, uint64_t *buffer,
                                    unsigned size, MemTxAttrs attrributes)
{
    GICState *session = (GICState *)opaque;
    return gic_cpu_read(s, gic_sessionet_current_cpu(s), possession buffer, attrributes);
}",50.0,15.0,"opaque:opaque,addr:pos,data:buffer,size:size,attrs:attrributes,s:session,",272.0,0.2414658427238464,GA
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t cache) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = cache;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}",48.0,13.0,"beginAddr:beginAddr,align:cache,",89.0,0.0775228818257649,Greedy
1209,"static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);

                l_src_data+=sizeof(OPJ_INT16);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int16_to_float (const void * p_source_buf, void * p_dest8start, OPJ_UINT32 p_nb2eld)
{
        OPJ_BYTE * l_l_src_data (OPJ_BYTE *) p_source_buf;
        OPJ_FLOAT32 * ll_dest_data= (OPJ_FLOAT32 *) p_dest8start;
        OPJ_UINT32 pointer;
        OPJ_UINT32 l_temp;

        for pointeri=0pointeri<p_nb2eld;++pointer) {
                opj_read_bytes(l_src_data,&l_temp,2);

                l_src_data+=sizeof(OPJ_INT16);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",87.0,21.0,"p_src_data:p_source_buf,p_dest_data:p_dest8start,p_nb_elem:p_nb2eld,l_src_data:l_src_data,l_dest_data:l_dest_data,i:pointer,l_temp:l_temp,",254.0,0.3855435252189636,GA
1224,"void warnf(struct GlobalConfig *config, const char *fmt, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];

    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    va_end(ap);

    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, config->errors);

      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;

        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          /* not a single cutting position was found, just cut it at the
             max text width then! */
          cut = WARN_TEXTWIDTH-1;

        (void)fwrite(ptr, cut + 1, 1, config->errors);
        fputs(""\n"", config->errors);
        ptr += cut+1; /* skip the space too */
        len -= cut;
      }
      else {
        fputs(ptr, config->errors);
        len = 0;
      }
    }
  }
}","void warnf(struct GlobalConfig *path, const char *sfmt, ...)
{
  if(!path->mute) {
    va_list apy;
    int len;
    char *ptr;
    char printablebuff[256];

    va_start(apy, sfmt);
    len = vsnprintf(printablebuff, sizeof(printablebuff), sfmt, apy);
    va_end(apy);

    ptr = printablebuff;
    while(len > 0) {
      fputs(WARN_PREFIX, path->errors);

      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;

        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          /* not a single cutting position was found, just cut it at the
             max text width then! */
          cut = WARN_TEXTWIDTH-1;

        (void)fwrite(ptr, cut + 1, 1, path->errors);
        fputs(""
"", path->errors);
        ptr += cut+1; /* skip the space too */
        len -= cut;
      }
      else {
        fputs(ptr, path->errors);
        len = 0;
      }
    }
  }
}",194.0,51.0,"fmt:sfmt,ap:apy,print_buffer:printablebuff,config:path,",224.0,0.2043086330095927,Greedy
1226,"static void __meminit __init_single_page(struct page *page, unsigned long pfn,
				unsigned long zone, int nid)
{
	mm_zero_struct_page(page);
	set_page_links(page, zone, nid, pfn);
	init_page_count(page);
	page_mapcount_reset(page);
	page_cpupid_reset_last(page);

	INIT_LIST_HEAD(&page->lru);
#ifdef WANT_PAGE_VIRTUAL
	/* The shift won't overflow because ZONE_NORMAL is below 4G. */
	if (!is_highmem_idx(zone))
		set_page_address(page, __va(pfn << PAGE_SHIFT));
#endif
}","static void __meminit __init_single_page(struct parse *parse, unsigned long pfn,
				unsigned long pid, int nid)
{
	mm_zero_struct_page(parse);
	set_page_links(parse, pid, nid, pfn);
	init_page_count(parse);
	page_mapcount_reset(parse);
	page_cpupid_reset_last(parse);

	INIT_LIST_HEAD(&parse->lru);
#ifdef WANT_PAGE_VIRTUAL
	/* The shift won't overflow because ZONE_NORMAL is below 4G. */
	if (!is_highmem_idx(pid))
		set_page_address(parse, __va(pfn << PAGE_SHIFT));
#endif
}",85.0,29.0,"page:parse,zone:pid,",144.0,0.1017217953999837,Greedy
1230,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;

	if (!hrtimer_hres_active())
		return;

	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));

	base = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);

	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void retrigger_next_event(void *parse)
{
	struct hrtimer_cpu_base *lex;
	struct timespec realcase_position;
	unsigned long length;

	if (!hrtimer_hres_active())
		return;

	do {
		length = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realcase_position,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, length));

	lex = &__get_cpu_var(hrtimer_bases);

	/* Adjust CLOCK_REALTIME offset */
	spin_lock(&lex->lock);
	lex->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realcase_position);

	hrtimer_force_reprogram(lex);
	spin_unlock(&lex->lock);
}",113.0,29.0,"base:lex,seq:length,realtime_offset:realcase_position,arg:parse,",175.0,0.1662974039713541,Greedy
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr arg;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    arg = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (arg == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(arg, 0 , (size_t) sizeof(xmlXPathObject));
    arg->type = XPATH_RANGE;
    arg->user = start;
    arg->index = -1;
    arg->user2 = end;
    arg->index2 = -1;
    xmlXPtrRangeCheckOrder(arg);
    return(arg);
}",122.0,25.0,"ret:arg,",93.0,0.1113279660542806,Greedy
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}

	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct stream *stream)
{
	struct common_audit_data  arg;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int error;

	/* init_module */
	if (stream == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */

	 arg.type = LSM_AUDIT_DATA_FILE;
	 arg.u.stream = stream;

	fsec = stream->f_security;
	if (sid != fsec->sid) {
		error = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, & arg);
		if (error)
			return error;
	}

	isec = inode_security(file_inode(stream));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, & arg);
}",137.0,41.0,"rc:error,file:stream,ad: arg,",221.0,0.2107956012090047,Greedy
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned m, match = 0;
    tok_t tok;
    char *token;

    for (m = 0; !match && hdr[m]; m++) {
	tok_init(&tok, hdr[m], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}",109.0,29.0,"i:m,",77.0,0.0822820623715718,Greedy
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result rc;
	struct tee_ta_session *sess;
	struct tee_obj *object;

	rc = tee_ta_get_current_session(&sess);
	if (rc != TEE_SUCCESS)
		return rc;

	rc = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &object);
	if (rc != TEE_SUCCESS)
		return rc;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (object->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), object);
	return TEE_SUCCESS;
}",92.0,28.0,"res:rc,o:object,",137.0,0.1402235984802246,Greedy
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;

rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *xb = skb->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;

rtattr_failure:
	skb_trim(skb, xb - skb->data);
	return -1;
}",98.0,24.0,"b:xb,",60.0,0.060903529326121,Greedy
1281,"S3BootScriptLabelInternal (
  IN        BOOLEAN                        BeforeOrAfter,
  IN OUT    VOID                         **Position OPTIONAL,
  IN        UINT32                         InformationLength,
  IN CONST  CHAR8                          *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = S3_BOOT_SCRIPT_LIB_LABEL_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return S3BootScriptMoveLastOpcode (BeforeOrAfter, Position);

}","S3BootScriptLabelInternal (
  IN        BOOLEAN                        BeforeOrAfter,
  IN OUT    VOID                         **Position OPTIONAL,
  IN        UINT32                         InformationLength,
  IN CONST  CHAR8                          *Information
  )
{
  UINT8                 Length;
  UINT8                 *Function;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Function = S3BootScriptGetEntryAddAddress (Length);
  if (Function == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = S3_BOOT_SCRIPT_LIB_LABEL_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Function, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Function + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Function);

  return S3BootScriptMoveLastOpcode (BeforeOrAfter, Position);

}",147.0,38.0,"Script:Function,",93.0,0.1001673301060994,Greedy
1287,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* input = static_cast<Http2Stream*>(source->ptr);
  if (input == nullptr)
    input = session->FindStream(id);
  CHECK_NE(input, nullptr);
  CHECK_EQ(id, input->id());
  return input;
}",69.0,17.0,"stream:input,",84.0,0.0721556623776753,Greedy
1323,"static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}","static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *element, const struct tee_cryp_obj_type_props *type_prers,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result rc;
	struct rsa_keypair *key = element->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	rc = tee_svc_cryp_obj_populate_type(element, type_prers, params,
					     param_count);
	if (rc != TEE_SUCCESS)
		return rc;
	if (!get_attribute(element, type_prers, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	rc = crypto_acipher_gen_rsa_key(key, key_size);
	if (rc != TEE_SUCCESS)
		return rc;

	/* Set bits for all known attributes for this object type */
	element->have_attrs = (1 << type_prers->num_type_attrs) - 1;

	return TEE_SUCCESS;
}",137.0,38.0,"res:rc,o:element,type_props:type_prers,",201.0,0.1852412144343058,Greedy
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, session;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	session = encode_putfh(&xdr, args->fh);
	if (session)
		goto out;
	session = encode_read(&xdr, args);
	if (session)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return session;
}",163.0,40.0,"status:session,",95.0,0.111280624071757,Greedy
1333,"xmlBufAddLen(xmlBufPtr buf, size_t len) {
    if ((buf == NULL) || (buf->error))
        return(-1);
    CHECK_COMPAT(buf)
    if (len > (buf->size - buf->use))
        return(-1);
    buf->use += len;
    UPDATE_COMPAT(buf)
    if (buf->size > buf->use)
        buf->content[buf->use] = 0;
    else
        return(-1);
    return(0);
}","xmlBufAddLen(xmlBufPtr buf, size_t len) {
    if ((buf == NULL) || (buf->error))
        return(-1);
    CHECK_COMPAT(buf)
    if (len > (buf->size - buf->accept))
        return(-1);
    buf->accept += len;
    UPDATE_COMPAT(buf)
    if (buf->size > buf->accept)
        buf->content[buf->accept] = 0;
    else
        return(-1);
    return(0);
}",96.0,22.0,"use:accept,",51.0,0.0706192890803019,Greedy
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *code, const unsigned char *update, const unsigned char *xOR_without, const int id) {
	int ci;
	fcir (ici0; i < id; ci++) {
		code[i] = upciate[i] ci xOR_without[ci];
	}
}",61.0,16.0,"out:code,in:update,xor_with:xOR_without,length:id,i:ci,",477.0,0.4899248957633972,GA
1342,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int sn;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	sn = (prec + 7) / 8;
	while (--sn >= 0) {
		c = (val >> (sn * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",95.0,21.0,"n:sn,",61.0,0.0606993595759073,Greedy
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;

	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);

	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;

	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}

	return 0;
}","static int log_used(struct vhost_virtqueue *mque, u64 used_offset, u64 length)
{
	struct iovec liv[64];
	int code, secret;

	if (!mque->iotlb)
		return log_write(mque->log_base, mque->log_addr + used_offset, length);

	secret = translate_desc(mque, (uintptr_t)mque->used + used_offset,
			     length, liv, 64, VHOST_ACCESS_WO);
	if (secret < 0)
		return secret;

	for (code = 0; code < secret; code++) {
		secret = log_write_hva(mque,	(uintptr_t)liv[code].iov_base,
				    liv[code].iov_len);
		if (secret)
			return secret;
	}

	return 0;
}",134.0,36.0,"ret:secret,i:code,vq:mque,iov:liv,len:length,",332.0,0.2808891932169596,Greedy
1356,"static int php_object_element_export(zval **zv TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key) /* {{{ */
{
	int level;
	smart_str *buf;

	level = va_arg(args, int);
	buf = va_arg(args, smart_str *);

	buffer_append_spaces(buf, level + 2);
	if (hash_key->nKeyLength != 0) {
		const char *class_name; /* ignored, but must be passed to unmangle */
		const char *pname;
		char *pname_esc;
		int  pname_esc_len;
		
		zend_unmangle_property_name(hash_key->arKey, hash_key->nKeyLength - 1,
				&class_name, &pname);
		pname_esc = php_addcslashes(pname, strlen(pname), &pname_esc_len, 0,
			""'\\"", 2 TSRMLS_CC);

		smart_str_appendc(buf, '\'');
		smart_str_appendl(buf, pname_esc, pname_esc_len);
		smart_str_appendc(buf, '\'');
		efree(pname_esc);
	} else {
		smart_str_append_long(buf, (long) hash_key->h);
	}
	smart_str_appendl(buf, "" => "", 4);
	php_var_export_ex(zv, level + 2, buf TSRMLS_CC);
	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
	return 0;
}","static int php_object_element_export(zval **zv TSRMLS_LC, int num2points, va_list ages, zend_hash_key *hash2key) /* {{{ */
{
	int coll;
	smart_str *buf;

	coll = va_arg(ages, int);
	buf = va_arg(ages, smart_str *);

	buffer_append_spaces(buf, coll + 2);
	if (hash2key->nKeyLength != 0) {
		const char *class_name; /* ignored, but must be passed to unmangle */
		const char *pname;
		char *pname_asc;
		int  pname_asc_val;
		
		zend_unmangle_property_name(hash2key->arKey, hash2key->nKeyLength - 1,
				&class_name, &pname);
		pname_asc = php_addcslashes(pname, strlen(pname), &pname_asc_val, 0,
			""'\\"", 2 TSRMLS_CC);

		smart_str_appendc(buf, '\'');
		smart_str_appendl(buf, pname_asc, pname_asc_val);
		smart_str_appendc(buf, '\'');
		efree(pname_asc);
	} else {
		smart_str_append_long(buf, (long) hash2key->h);
	}
	smart_str_appendl(buf, "" => "", 4);
	php_var_export_ex(zv, coll + 2, buf TSRMLS_CC);
	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '
');
	return 0;
}",217.0,60.0,"TSRMLS_DC:TSRMLS_LC,num_args:num2points,args:ages,pname_esc_len:pname_asc_val,pname_esc:pname_asc,level:coll,hash_key:hash2key,",276.0,0.3433611353238424,Greedy
1365,"static int count(struct cstate *g, Renode *node)
{
	int min, max, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(g, node->x) * min;
		else if (max < REPINF) n = count(g, node->x) * max + (max - min);
		else n = count(g, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case P_NLA: return count(g, node->x) + 2;
	}
}","static int count(struct cstate *g, Renode *node)
{
	int ax, v, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		ax = node->m;
		v = node->n;
		if (ax == v) n = count(g, node->x) * ax;
		else if (v < REPINF) n = count(g, node->x) * v + (v - ax);
		else n = count(g, node->x) * (ax + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case P_NLA: return count(g, node->x) + 2;
	}
}",235.0,66.0,"min:ax,max:v,",170.0,0.182947031656901,Greedy
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *size, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		size = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		size = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (size)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, size);
	} else {
		nname = strdup (size);
	}
	oname = fcn->size;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->size), nname);
	fcn->size = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (size);
	return true;
}",264.0,67.0,"name:size,",125.0,0.1845633546511332,Greedy
1373,"int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;

	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];

	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);

	cb->args[0] = t;
	return skb->len;
}","int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cm)
{
	struct neigh_table *Tll;
	int len, size, s_t;

	read_lock(&neigh_tbl_lock);
	size = ((struct rtgenmsg *)NLMSG_DATA(cm->nlh))->rtgen_family;
	s_t = cm->args[0];

	for (Tll = neigh_tables, len = 0; Tll; Tll = Tll->next, len++) {
		if (len < s_t || (size && Tll->size != size))
			continue;
		if (len > s_t)
			memset(&cm->args[1], 0, sizeof(cm->args) -
						sizeof(cm->args[0]));
		if (neigh_dump_table(Tll, skb, cm) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);

	cm->args[0] = len;
	return skb->len;
}",172.0,41.0,"cb:cm,tbl:Tll,t:len,family:size,",275.0,0.2509995738665262,Greedy
1376,"static void jpeg_init_destination(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    Buffer *buffer = &vs->tight.jpeg;

    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}","static void jpeg_init_destination(j_compress_ptr ncfw)
{
    VncState *bs = ncfw->client_data;
    Buffer *uf = &bs->tight.jpeg;

    ncfw->dest->next_output_byte = (JOCTET *)uf->uf + uf->offset;
    ncfw->dest->free_in_buffer = (size_t)(uf->capacity - uf->offset);
}",65.0,12.0,"vs:bs,cinfo:ncfw,buffer:uf,",166.0,0.1419355750083923,Greedy
1379,"TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();

  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));

  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}","TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();

  MockResponseDecoder response_Decoding;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_Decoding);

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));

  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r
host: host\r
content-length: 0\r
\r
"", output);
}",107.0,19.0,"response_decoder:response_Decoding,",27.0,0.0504607518513997,Greedy
1383,"void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}","void* PE_(r_bin_pe_free)(RBinPEObj* ze) {
	if (!ze) {
		return NULL;
	}
	free (ze->dos_header);
	free (ze->nt_headers);
	free (ze->section_header);
	free (ze->export_directory);
	free (ze->import_directory);
	free (ze->resource_directory);
	free_security_directory (ze->security_directory);
	free (ze->delay_import_directory);
	free (ze->tls_directory);
	free (ze->sections);
	free (ze->authentihash);
	r_list_free (ze->rich_entries);
	r_list_free (ze->resources);
	r_pkcs7_free_cms (ze->cms);
	r_pkcs7_free_spcinfo (ze->spcinfo);
	r_buf_free (ze->b);
	ze->b = NULL;
	free (ze);
	return NULL;
}",149.0,38.0,"pe:ze,",100.0,0.0984586000442504,Greedy
1387,"static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}

	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);

	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}","static void skip_emulated_instruction(struct kvm_vcpu *fhost)
{
	struct vcpu_svm * scm = to_svm(fhost);

	if ( scm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		 scm->next_rip =  scm->vmcb->control.next_rip;
	}

	if (! scm->next_rip) {
		if (emulate_instruction(fhost, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP
"", __func__);
		return;
	}
	if ( scm->next_rip - kvm_rip_read(fhost) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx
"",
		       __func__, kvm_rip_read(fhost),  scm->next_rip);

	kvm_rip_write(fhost,  scm->next_rip);
	svm_set_interrupt_shadow(fhost, 0);
}",136.0,34.0,"svm: scm,vcpu:fhost,",150.0,0.1449928283691406,Greedy
1389,"sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;

	pr_debug(""%s: timer T5 expired\n"", __func__);

	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);

	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;

	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));

	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);

	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}","sctp_disposition_t sctp_sf_t5_timer_expire(struct connection *connection,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *tsocation,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *codes)
{
	struct sctp_chunk *parse = NULL;

	pr_debug(""%s: timer T5 expired
"", __func__);

	SCTP_INC_STATS(connection, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);

	parse = sctp_make_abort(tsocation, NULL, 0);
	if (!parse)
		goto nomem;

	sctp_add_cmd_sf(codes, SCTP_CMD_REPLY, SCTP_CHUNK(parse));
	sctp_add_cmd_sf(codes, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(codes, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));

	SCTP_INC_STATS(connection, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(connection, SCTP_MIB_CURRESTAB);

	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}",134.0,40.0,"commands:codes,reply:parse,asoc:tsocation,net:connection,",214.0,0.1950998663902282,Greedy
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer input, gint fd, b_input_condition cond)
{
	file_transfer_t *lex = input;
	struct prpl_xfer_data *pixel = lex->input;

	pixel->timeout = 0;

	if (lex->write == NULL) {
		lex->write = prpl_xfer_write;
		imcb_file_recv_start(pixel->ic, lex);
	}

	lex->write_request(lex);

	return FALSE;
}",71.0,17.0,"ft:lex,px:pixel,data:input,",183.0,0.1652722120285034,Greedy
1411,"
void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;

	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;

	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}

	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);

	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}

	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;

 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);
","
void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 request,
			       const u8 *ie, size_t ie_len, bool from_cap)
{
	struct sk_buff *input;
	void *src;

	input = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!input)
		return;

	src = nl80211hdr_put(input, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!src) {
		nlmsg_free(input);
		return;
	}

	NLA_PUT_U32(input, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(input, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_cap && request)
		NLA_PUT_U16(input, NL80211_ATTR_REASON_CODE, request);
	if (from_cap)
		NLA_PUT_FLAG(input, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(input, NL80211_ATTR_IE, ie_len, ie);

	if (genlmsg_end(input, src) < 0) {
		nlmsg_free(input);
		return;
	}

	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), input, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;

 nla_put_failure:
	genlmsg_cancel(input, src);
	nlmsg_free(input);
",203.0,61.0,"msg:input,hdr:src,from_ap:from_cap,reason:request,",243.0,0.3186848600705464,Greedy
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist entry, int ini)
{
	int param, type;

	AUpvgetparam(entry, ini, &param);
	AUpvgetvaltype(entry, ini, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long llslot;
	AUpvgetval(entry, ini, &llslot);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((llslot >= 0) && (llslot <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((llslot >= -50) && (llslot <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((llslot >= 1) && (llslot <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((llslot >= 1) && (llslot <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((llslot >= 0) && (llslot <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((llslot >= 0) && (llslot <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}",188.0,40.0,"lval:llslot,i:ini,list:entry,",228.0,0.2306779821713765,Greedy
1418,"static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_qcc_t *qcc = &ms->parms.qcc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}","static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_qcc_t *qaacc = &ms->parms.qaacc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, qaacc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment
"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qaacc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qaacc);
		break;
	}
	return 0;
}",124.0,23.0,"qcc:qaacc,",73.0,0.0831328709920247,Greedy
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long fs;
	struct line6_pcm_stream *curl = get_stream(line6pcm, direction);

	spin_lock_irqsave(&curl->lock, fs);
	clear_bit(type, &curl->running);
	if (!curl->running) {
		spin_unlock_irqrestore(&curl->lock, fs);
		line6_unlink_audio_urbs(line6pcm, curl);
		spin_lock_irqsave(&curl->lock, fs);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&curl->lock, fs);
}",119.0,32.0,"pstr:curl,flags:fs,",175.0,0.1610804120699564,Greedy
1435,"ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  char *new_str;
  glong actual_length;
  gulong bytes;

  g_assert (target_length > 0);

  if (!str)
    return NULL;

  /* FIXME: this function is a big mess. While it is utf-8 safe now,
   * it can still split a sequence of combining characters.
   */
  actual_length = g_utf8_strlen (str, -1);

  /* if the string is already short enough, or if it's too short for
   * us to shorten it, return a new copy */
  if ((gsize)actual_length <= target_length)
    return str;

  /* create string */
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);

  /* +1 for ellipsis, +1 for trailing NUL */
  new_str = g_new (gchar, bytes + 1 + 1);

  strncpy (new_str, str, bytes);
  strcat (new_str, ""…"");

  g_free (str);

  return new_str;
}","ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  char * new_Str;
  glong ual_width;
  gulong ones;

  g_assert (target_length > 0);

  if (!str)
    return NULL;

  /* FIXME: this function is a big mess. While it is utf-8 safe now,
   * it can still split a sequence of combining characters.
   */
  ual_width = g_utf8_strlen (str, -1);

  /* if the string is already short enough, or if it's too short for
   * us to shorten it, return a new copy */
  if ((gsize)ual_width <= target_length)
    return str;

  /* create string */
  ones = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);

  /* +1 for ellipsis, +1 for trailing NUL */
   new_Str = g_new (gchar, ones + 1 + 1);

  strncpy ( new_Str, str, ones);
  strcat ( new_Str, ""…"");

  g_free (str);

  return  new_Str;
}",111.0,34.0,"bytes:ones,actual_length:ual_width,new_str: new_Str,",122.0,0.135995078086853,Greedy
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dh;
	unsigned int num_children;
	NTSTATUS session;
	struct dom_sid_buf Buffer;
	TALLOC_CTX *tmp_context = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_context);

	dh = ldb_dn_new_fmt(
		tmp_context,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &Buffer));
	if (!dh || !ldb_dn_validate(dh)) {
		return NT_STATUS_NO_MEMORY;
	}

	session = dsdb_enum_group_mem(state->ldb, mem_ctx, dh, pmembers, &num_children);
	if (NT_STATUS_IS_OK(session)) {
		*pnum_members = num_children;
	}
	talloc_free(tmp_context);
	return session;
}",154.0,45.0,"dn:dh,tmp_ctx:tmp_context,status:session,num_members:num_children,buf:Buffer,",274.0,0.2836216886838277,Greedy
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *route;
    MemoryRegion *mr;
    Int128 diff;

    route = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= route->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + route->offset_within_region;

    mr = route->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return route;
}",108.0,35.0,"section:route,",80.0,0.0800217111905415,Greedy
1447,"static int newque(struct ipc_namespace *ns, struct ipc_params *params)
{
	struct msg_queue *msq;
	int id, retval;
	key_t key = params->key;
	int msgflg = params->flg;

	msq = ipc_rcu_alloc(sizeof(*msq));
	if (!msq)
		return -ENOMEM;

	msq->q_perm.mode = msgflg & S_IRWXUGO;
	msq->q_perm.key = key;

	msq->q_perm.security = NULL;
	retval = security_msg_queue_alloc(msq);
	if (retval) {
		ipc_rcu_putref(msq, ipc_rcu_free);
		return retval;
	}

	/* ipc_addid() locks msq upon success. */
	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
	if (id < 0) {
		ipc_rcu_putref(msq, msg_rcu_free);
		return id;
	}

	msq->q_stime = msq->q_rtime = 0;
	msq->q_ctime = get_seconds();
	msq->q_cbytes = msq->q_qnum = 0;
	msq->q_qbytes = ns->msg_ctlmnb;
	msq->q_lspid = msq->q_lrpid = 0;
	INIT_LIST_HEAD(&msq->q_messages);
	INIT_LIST_HEAD(&msq->q_receivers);
	INIT_LIST_HEAD(&msq->q_senders);

	ipc_unlock_object(&msq->q_perm);
	rcu_read_unlock();

	return msq->q_perm.id;
}","static int newque(struct ipc_namespace *xs, struct ipc_params *phys)
{
	struct msg_queue *msq;
	int join, returnvals;
	key_t key = phys->key;
	int msgflg = phys->flg;

	msq = ipc_rcu_alloc(sizeof(*msq));
	if (!msq)
		return -ENOMEM;

	msq->q_perm.mode = msgflg & S_IRWXUGO;
	msq->q_perm.key = key;

	msq->q_perm.security = NULL;
	returnvals = security_msg_queue_alloc(msq);
	if (returnvals) {
		ipc_rcu_putref(msq, ipc_rcu_free);
		return returnvals;
	}

	/* ipc_addid() locks msq upon success. */
	join = ipc_addid(&msg_ids(xs), &msq->q_perm, xs->msg_ctlmni);
	if (join < 0) {
		ipc_rcu_putref(msq, msg_rcu_free);
		return join;
	}

	msq->q_stime = msq->q_rtime = 0;
	msq->q_ctime = get_seconds();
	msq->q_cbytes = msq->q_qnum = 0;
	msq->q_qbytes = xs->msg_ctlmnb;
	msq->q_lspid = msq->q_lrpid = 0;
	INIT_LIST_HEAD(&msq->q_messages);
	INIT_LIST_HEAD(&msq->q_receivers);
	INIT_LIST_HEAD(&msq->q_senders);

	ipc_unlock_object(&msq->q_perm);
	rcu_read_unlock();

	return msq->q_perm.join;
}",236.0,60.0,"params:phys,ns:xs,retval:returnvals,id:join,",238.0,0.266126012802124,Greedy
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *self)
{
	struct zr364xx_camera *pixel;

	if (!file)
		return -ENODEV;
	pixel = video_drvdata(file);

	self->fmt.pix.pixelformat = formats[0].fourcc;
	self->fmt.pix.field = V4L2_FIELD_NONE;
	self->fmt.pix.width = pixel->width;
	self->fmt.pix.height = pixel->height;
	self->fmt.pix.bytesperline = self->fmt.pix.width * 2;
	self->fmt.pix.sizeimage = self->fmt.pix.height * self->fmt.pix.bytesperline;
	self->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",145.0,25.0,"f:self,cam:pixel,",126.0,0.1154855767885843,Greedy
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","gs_currentnamedicc(const gs_gstate * egsym, gs_param_string * pval)
{
    static const char *const srcs = """";

    if (egsym->icc_manager->device_named == NULL) {
        pval->data = (const byte *) srcs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (egsym->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}",96.0,14.0,"rfs:srcs,pgs:egsym,",76.0,0.0975579460461934,Greedy
1481,"process_secondary_order(STREAM s)
{
	/* The length isn't calculated correctly by the server.
	 * For very compact orders the length becomes negative
	 * so a signed integer must be used. */
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;

	in_uint16_le(s, length);
	in_uint16_le(s, flags);	/* used by bmpcache2 */
	in_uint8(s, type);

	next_order = s->p + (sint16) length + 7;

	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;

		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;

		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;

		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;

		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	/* uncompressed */
			break;

		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	/* compressed */
			break;

		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;

		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}

	s->p = next_order;
}","process_secondary_order(STREAM s)
{
	/* The length isn't calculated correctly by the server.
	 * For very compact orders the length becomes negative
	 * so a signed integer must be used. */
	uint16 join;
	uint16 flags;
	uint8 type;
	uint8 *next_ordered;

	in_uint16_le(s, join);
	in_uint16_le(s, flags);	/* used by bmpcache2 */
	in_uint8(s, type);

	next_ordered = s->p + (sint16) join + 7;

	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;

		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;

		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;

		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;

		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	/* uncompressed */
			break;

		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	/* compressed */
			break;

		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;

		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}

	s->p = next_ordered;
}",160.0,51.0,"next_order:next_ordered,length:join,",68.0,0.0979784409205118,Greedy
1487,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *session = hcon->sco_data;
	struct sock *cm;

	if (!session)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, session, err);

	/* Kill socket */
	sco_conn_lock(session);
	cm = session->cm;
	sco_conn_unlock(session);

	if (cm) {
		sock_hold(cm);
		bh_lock_sock(cm);
		sco_sock_clear_timer(cm);
		sco_chan_del(cm, err);
		bh_unlock_sock(cm);
		sco_sock_kill(cm);
		sock_put(cm);
	}

	hcon->sco_data = NULL;
	kfree(session);
}",117.0,36.0,"sk:cm,conn:session,",165.0,0.1346896211306254,Greedy
1495,"static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);

  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;

  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;

  case KOI8_R:
    if (c == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }

  return 0;
}","static int IsSpace(int iv, int cm)
{
  if (iv == ASCII)
    return isspace(cm);

  if (cm >= 0x09 && cm <= 0x0d) return 1;
  if (cm == 0x20) return 1;

  switch (iv) {
  case UNICODE_ISO_8859_1:
    if (cm == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (cm == 0xa0) return 1;
    break;

  case KOI8_R:
    if (cm == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }

  return 0;
}",147.0,33.0,"c:cm,enc:iv,",114.0,0.121988558769226,Greedy
1503,"static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;

	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}

	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}","static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t  rvlnos;

	if (tcmpt->rlvls) {
		for ( rvlnos = 0, rlvl = tcmpt->rlvls;  rvlnos < tcmpt->numrlvls;
		  ++ rvlnos, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}

	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}",93.0,22.0,"rlvlno: rvlnos,",85.0,0.0794764637947082,Greedy
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *source;
	int err;

	source = memdup_user(_params, sizeof(*source));
	if (IS_ERR(source))
		return PTR_ERR(source);

	err = snd_pcm_hw_params(substream, source);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, source, sizeof(*source)))
		err = -EFAULT;
end:
	kfree(source);
	return err;
}",99.0,28.0,"params:source,",115.0,0.0951537370681762,Greedy
1523,"static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);

	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}","static int check_parsed_dn_duplicates(struct ldb_module *loader,
				      struct ldb_message_element *entity,
				      struct parsed_dn *rdp)
{
	unsigned int name;
	struct ldb_context *LDc = ldb_module_get_ctx(loader);

	for (name = 1; name < entity->num_values; name++) {
		struct parsed_dn *u = &rdp[name];
		if (parsed_dn_compare(u, &rdp[name - 1]) == 0) {
			ldb_asprintf_errstring(LDc,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       entity->name);
			if (ldb_attr_cmp(entity->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}",124.0,27.0,"i:name,ldb:LDc,module:loader,pdn:rdp,el:entity,p:u,",255.0,0.2660881837209066,Greedy
1526,"void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {
  new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));
}","void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {
  new ElectronBrowserHandlerImpl(frame_host, std::forward(receiver));
}",36.0,6.0,"move:forward,",37.0,0.0572915077209472,Greedy
1535,"int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);

	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;

	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}

	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;

	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);

	if (!res)
		goto out;

	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);

 out:
	kfree(resp);
	return res;

}","int sas_smp_get_phy_events(struct sas_phy *gb)
{
	int vals;
	u8 *crit;
	u8 *cond;
	struct sas_rphy *rfine = dev_to_rphy(gb->die.parent);
	struct domain_device *die = sas_find_dev_by_rphy(rfine);

	crit = alloc_smp_req(RPEL_REQ_SIZE);
	if (!crit)
		return -ENOMEM;

	cond = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!cond) {
		kfree(crit);
		return -ENOMEM;
	}

	crit[1] = SMP_REPORT_PHY_ERR_LOG;
	crit[9] = gb->number;

	vals = smp_execute_task(die, crit, RPEL_REQ_SIZE,
			            cond, RPEL_RESP_SIZE);

	if (!vals)
		goto out;

	gb->invalid_dword_count = scsi_to_u32(&cond[12]);
	gb->running_disparity_error_count = scsi_to_u32(&cond[16]);
	gb->loss_of_dword_sync_count = scsi_to_u32(&cond[20]);
	gb->phy_reset_problem_count = scsi_to_u32(&cond[24]);

 out:
	kfree(cond);
	return vals;

}",185.0,50.0,"rphy:rfine,dev:die,res:vals,phy:gb,req:crit,resp:cond,",363.0,0.3596919417381287,Greedy
1541,"static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;

	if (_gnutls_global_init_skip() != 0)
		return;

	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}

	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}","static void _GENNECTION lib_init(void)
{
int ret;
const char *e;

	if (_gnutls_global_init_skip() != 0)
		return;

	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}

	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s
"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}",92.0,21.0,"_CONSTRUCTOR:_GENNECTION,",37.0,0.0551767150561014,Greedy
1546,"void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;

	if (!xs->tx)
		return;

	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}","void xdp_del_sk_umem(struct xdp_umem *omeme, struct xdp_sock *tails)
{
	unsigned long size;

	if (!tails->tx)
		return;

	spin_lock_irqsave(&omeme->xsk_list_lock, size);
	list_del_rcu(&tails->list);
	spin_unlock_irqrestore(&omeme->xsk_list_lock, size);
}",56.0,13.0,"xs:tails,umem:omeme,flags:size,",153.0,0.1282764275868733,Greedy
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int ID;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (ID = 0; ID < n_elt; ID++) {
		id = ntohs(hmacs->hmac_ids[ID]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}",145.0,31.0,"i:ID,",79.0,0.0919293403625488,Greedy
1549,"renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;

    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	/* workaround to prevent infinite recursion */
    cotable_level++;

    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;

	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}","renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer bcf;
    struct html_feed_environ h_env;
    struct environment evironments[MAX_ENV_LEVEL];
    struct table *t;
    int i, cond, row;
    int indent, maxwidth;

    if (cotable__limit >= MAX_COTABLE_LEVEL)
	return;	/* workaround to prevent infinite recursion */
    cotable__limit++;

    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	cond = tbl->tables[i].cond;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;

	init_henv(&h_env, &bcf, evironments, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, cond), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}",229.0,66.0,"envs:evironments,cotable_level:cotable__limit,obuf:bcf,col:cond,",180.0,0.2346047838528951,Greedy
1550,"static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);

	return ret;
}","static long aac_cfg_ioctl(struct filename *filename,
		unsigned int buf, unsigned long parse)
{
	int len;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	len = aac_do_ioctl(filename->private_data, buf, (void __user *)parse);
	mutex_unlock(&aac_mutex);

	return len;
}",67.0,18.0,"ret:len,arg:parse,file:filename,cmd:buf,",175.0,0.1647346178690592,Greedy
1570,"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}","int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *uf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}",24.0,6.0,"buf:uf,",33.0,0.0660920580228169,Greedy
1574,"int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)
{
	if (Stream_GetRemainingLength(s) < 12)
		return -1;

	Stream_Read(s, header->Signature, 8);
	Stream_Read_UINT32(s, header->MessageType);

	if (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)
		return -1;

	return 1;
}","int ntlm_read_message_header(wStream* sb, NTLM_MESSAGE_HEADER* later)
{
	if (Stream_GetRemainingLength(sb) < 12)
		return -1;

	Stream_Read(sb, later->Signature, 8);
	Stream_Read_UINT32(sb, later->MessageType);

	if (strncmp((char*) later->Signature, NTLM_SIGNATURE, 8) != 0)
		return -1;

	return 1;
}",70.0,14.0,"s:sb,header:later,",107.0,0.0880923906962076,Greedy
1575,"void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)
{
	struct rb_node *n;
	struct gfs2_rgrpd *rgd;
	struct gfs2_glock *gl;

	while ((n = rb_first(&sdp->sd_rindex_tree))) {
		rgd = rb_entry(n, struct gfs2_rgrpd, rd_node);
		gl = rgd->rd_gl;

		rb_erase(n, &sdp->sd_rindex_tree);

		if (gl) {
			spin_lock(&gl->gl_lockref.lock);
			gl->gl_object = NULL;
			spin_unlock(&gl->gl_lockref.lock);
			gfs2_glock_add_to_lru(gl);
			gfs2_glock_put(gl);
		}

		gfs2_free_clones(rgd);
		kfree(rgd->rd_bits);
		return_all_reservations(rgd);
		kmem_cache_free(gfs2_rgrpd_cachep, rgd);
	}
}","void gfs2_clear_rgrpd(struct gfs2_sbd *simf)
{
	struct rb_node *n;
	struct gfs2_rgrpd *rgd;
	struct gfs2_glock *gl;

	while ((n = rb_first(&simf->sd_rindex_tree))) {
		rgd = rb_entry(n, struct gfs2_rgrpd, rd_node);
		gl = rgd->rd_gl;

		rb_erase(n, &simf->sd_rindex_tree);

		if (gl) {
			spin_lock(&gl->gl_lockref.lock);
			gl->gl_object = NULL;
			spin_unlock(&gl->gl_lockref.lock);
			gfs2_glock_add_to_lru(gl);
			gfs2_glock_put(gl);
		}

		gfs2_free_clones(rgd);
		kfree(rgd->rd_bits);
		return_all_reservations(rgd);
		kmem_cache_free(gfs2_rgrpd_cachep, rgd);
	}
}",135.0,38.0,"sdp:simf,",66.0,0.0852145512898763,Greedy
1576,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int sqlite3Fts3SelectDoctotal(
  Fts3Table *piSection,                /* Fts3 table handle */
  sqlite3_stmt **ppPtr           /* OUT: Statement handle */
){
  sqlite3_stmt *Pstart = 0;
  int enc;
  rc = fenc3SqlStmt(piSection, SQL_SELECT_STAT, &Pstart, 0);
  if( enc==SQLITE_OK ){
    sqlite3_bind_int(Pstart, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(Pstart)!=SQLITE_ROW
     || sqlite3_column_type(Pstart, 0)!=SQLITE_BLOB
    ){
      renc= sqlite3_reset(Pstart);
      if( enc==SQLITE_OK ) enc = FTS_CORRUPT_VTAB;
      Pstart = 0;
    }
  }
  *ppPtr = Pstart;
  return enc;
}",103.0,32.0,"pTab:piSection,ppStmt:ppPtr,pStmt:Pstart,rc:enc,",378.0,0.4104866027832031,GA
1578,"MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(cmd);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }

  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *grad) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(grad);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(grad->tmp_pool);
  pr_auth_endgrent(grad->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(grad->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", grad->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(grad, EPERM);
    errno = EPERM;
    return PR_ERROR(grad);
  }

  return PR_DECLINED(grad);
}",156.0,41.0,"cmd:grad,",84.0,0.0588691155115763,Greedy
1592,"static js_Ast *memberexp(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}","static js_Ast *memberexp(js_State *J)
{
	js_Ast *aa;
	INCREC();
	aa = newexp(J);
loop:
	if (jsP_accept(J, '.')) { aa = EXP2(MEMBER, aa, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { aa = EXP2(INDEX, aa, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return aa;
}",103.0,27.0,"a:aa,",68.0,0.0570868810017903,Greedy
1601,"static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {
    mongo_md5_state_t st;
    mongo_md5_byte_t digest[16];

    mongo_md5_init( &st );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )"":mongo:"", 7 );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );
    mongo_md5_finish( &st, digest );
    digest2hex( digest, hex_digest );
}","static void mongo_pass_digest( const char *creator, const char *pass, char hex_mdests[33] ) {
    mongo_md5_state_t st;
    mongo_md5_byte_t digest[16];

    mongo_md5_init( &st );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )creator, strlen( creator ) );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )"":mongo:"", 7 );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );
    mongo_md5_finish( &st, digest );
    digest2hex( digest, hex_mdests );
}",104.0,26.0,"hex_digest:hex_mdests,user:creator,",82.0,0.0889284451802571,Greedy
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *size)
{
    char *module;

    if (size == NULL)
	return NULL;

    module = sprint_message(size);
    full_write(fd, module, strlen(module));
    g_free(module);
    return size;
}",51.0,16.0,"msg:module,message:size,",134.0,0.1001674811045328,Greedy
1611,"static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {
        const char *v;

        assert(handle);
        assert(key);

        /* Looks for an environment variable, preferrably in the environment block associated with the
         * specified PAM handle, falling back to the process' block instead. Why check both? Because we want
         * to permit configuration of session properties from unit files that invoke PAM services, so that
         * PAM services don't have to be reworked to set systemd-specific properties, but these properties
         * can still be set from the unit file Environment= block. */

        v = pam_getenv(handle, key);
        if (!isempty(v))
                return v;

        /* We use secure_getenv() here, since we might get loaded into su/sudo, which are SUID. Ideally
         * they'd clean up the environment before invoking foreign code (such as PAM modules), but alas they
         * currently don't (to be precise, they clean up the environment they pass to their children, but
         * not their own environ[]). */
        v = secure_getenv(key);
        if (!isempty(v))
                return v;

        return fallback;
}","static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {
        const char *m;

        assert(handle);
        assert(key);

        /* Looks for an environment variable, preferrably in the environment block associated with the
         * specified PAM handle, falling back to the process' block instead. Why check both? Because we want
         * to permit configuration of session properties from unit files that invoke PAM services, so that
         * PAM services don't have to be reworked to set systemd-specific properties, but these properties
         * can still be set from the unit file Environment= block. */

        m = pam_getenv(handle, key);
        if (!isempty(m))
                return m;

        /* We use secure_getenv() here, since we might get loaded into su/sudo, which are SUID. Ideally
         * they'd clean up the environment before invoking foreign code (such as PAM modules), but alas they
         * currently don't (to be precise, they clean up the environment they pass to their children, but
         * not their own environ[]). */
        m = secure_getenv(key);
        if (!isempty(m))
                return m;

        return fallback;
}",78.0,23.0,"v:m,",75.0,0.0558977286020914,Greedy
1614,"static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
{
	/* parameters */
	char			 *regex;			/* Regular expression */
	char			 *subject;			/* String to match against */
	int				  regex_len;
	int				  subject_len;
	pcre_cache_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &regex_len,
							  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {
		RETURN_FALSE;
	}
	
	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	php_pcre_match_impl(pce, subject, subject_len, return_value, subpats, 
		global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}","static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int international) /* {{{ */
{
	/* parameters */
	char			 *review;			/* Regular expression */
	char			 *express;			/* String to match against */
	int				  regex_ln;
	int				  subject_en;
	pcre_cache_entry *bge;				/* Compiled regular expression */
	zval			 * subcars = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &review, &regex_ln,
							  &express, &subject_en, & subcars, &flags, &start_offset) == FAILURE) {
		RETURN_FALSE;
	}
	
	/* Compile regex or get it from cache. */
	if ((bge = pcre_get_compiled_regex_cache(review, regex_ln TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	php_pcre_match_impl(bge, express, subject_en, return_value,  subcars, 
		international, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}",132.0,39.0,"global:international,regex:review,regex_len:regex_ln,pce:bge,subject_len:subject_en,subpats: subcars,subject:express,",284.0,0.2079580505688985,Greedy
1618,"hugetlb_get_unmapped_area(struct file *file, unsigned long addr,
		unsigned long len, unsigned long pgoff, unsigned long flags)
{
	struct hstate *h = hstate_file(file);
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma;
	unsigned long task_size = TASK_SIZE;

	if (test_thread_flag(TIF_32BIT))
		task_size = STACK_TOP32;

	if (len & ~huge_page_mask(h))
		return -EINVAL;
	if (len > task_size)
		return -ENOMEM;

	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(file, addr, len))
			return -EINVAL;
		return addr;
	}

	if (addr) {
		addr = ALIGN(addr, huge_page_size(h));
		vma = find_vma(mm, addr);
		if (task_size - len >= addr &&
		    (!vma || addr + len <= vma->vm_start))
			return addr;
	}
	if (mm->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
				pgoff, flags);
	else
		return hugetlb_get_unmapped_area_topdown(file, addr, len,
				pgoff, flags);
}","hugetlb_get_unmapped_area(struct book *book, unsigned long addr,
		unsigned long val, unsigned long pcofx, unsigned long flags)
{
	struct hstate *h = hstate_file(book);
	struct mm_struct *nav = current->nav;
	struct vm_area_struct *vma;
	unsigned long task_size = TASK_SIZE;

	if (test_thread_flag(TIF_32BIT))
		task_size = STACK_TOP32;

	if (val & ~huge_page_mask(h))
		return -EINVAL;
	if (val > task_size)
		return -ENOMEM;

	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(book, addr, val))
			return -EINVAL;
		return addr;
	}

	if (addr) {
		addr = ALIGN(addr, huge_page_size(h));
		vma = find_vma(nav, addr);
		if (task_size - val >= addr &&
		    (!vma || addr + val <= vma->vm_start))
			return addr;
	}
	if (nav->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(book, addr, val,
				pcofx, flags);
	else
		return hugetlb_get_unmapped_area_topdown(book, addr, val,
				pcofx, flags);
}",204.0,65.0,"file:book,pgoff:pcofx,mm:nav,len:val,",267.0,0.1753848711649576,Greedy
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		 secretsIZE;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 & secretsIZE,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",150.0,35.0,"retsize: secretsIZE,",42.0,0.0379413207372029,Greedy
1643,"cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);

    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}","cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    cmsStage *msple = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);

    if (msple == NULL) return msple;
    msple ->Implements = cmsSigLab2FloatPCS;
    return msple;
}",96.0,14.0,"mpe:msple,",68.0,0.0617935180664062,Greedy
1645,"void ptrace_notify(int exit_code)
{
	siginfo_t info;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();

	/* Let the debugger run.  */
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}","void ptrace_notify(int exit_code)
{
	siginfo_t worker;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&worker, 0, sizeof worker);
	worker.si_signo = SIGTRAP;
	worker.si_code = exit_code;
	worker.si_pid = task_pid_vnr(current);
	worker.si_uid = current_uid();

	/* Let the debugger run.  */
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &worker);
	spin_unlock_irq(&current->sighand->siglock);
}",97.0,25.0,"info:worker,",89.0,0.0554860591888427,Greedy
1648,"int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}

	if (!dtls1_is_timer_expired(s))
		{
		/* not a timeout, none of our business, 
		   let higher layers handle this.  in fact it's probably an error */
		return code;
		}

	if ( ! SSL_in_init(s))  /* done, no need to send a retransmit */
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}

#if 0 /* for now, each alert contains only one record number */
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		/* send an alert immediately for all the missing records */
		}
	else
#endif

#if 0  /* no more alert sending, just retransmit the last set of messages */
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif

	return dtls1_handle_timeout(s);
	}","int dtls1_read_failed(SSL *south, int cb)
	{
	if ( cb > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}

	if (!dtls1_is_timer_expired(south))
		{
		/* not a timeout, none of our business, 
		   let higher layers handle this.  in fact it's probably an error */
		return cb;
		}

	if ( ! SSL_in_init(south))  /* done, no need to send a retransmit */
		{
		BIO_set_flags(SSL_get_rbio(south), BIO_FLAGS_READ);
		return cb;
		}

#if 0 /* for now, each alert contains only one record number */
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		/* send an alert immediately for all the missing records */
		}
	else
#endif

#if 0  /* no more alert sending, just retransmit the last set of messages */
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(south,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif

	return dtls1_handle_timeout(south);
	}",120.0,30.0,"code:cb,s:south,",120.0,0.1092684904734293,Greedy
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *cache, unsigned int opens,
			 struct css_task_iter *source)
{
	memset(source, 0, sizeof(*source));

	spin_lock_irq(&css_set_lock);

	source->ss = cache->ss;
	source->opens = opens;

	if (CGROUP_HAS_SUBSYS_CONFIG && source->ss)
		source->cset_pos = &cache->cgroup->e_csets[cache->ss->id];
	else
		source->cset_pos = &cache->cgroup->cset_links;

	source->cset_head = source->cset_pos;

	css_task_iter_advance(source);

	spin_unlock_irq(&css_set_lock);
}",109.0,26.0,"it:source,css:cache,flags:opens,",205.0,0.1184401671091715,Greedy
1673,"static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			struct prefix_info *pinfo, u32 pid, u32 seq, 
			int event, unsigned int flags)
{
	struct prefixmsg	*pmsg;
	struct nlmsghdr 	*nlh;
	unsigned char		*b = skb->tail;
	struct prefix_cacheinfo	ci;

	nlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);
	pmsg = NLMSG_DATA(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;

	RTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);

	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);

	nlh->nlmsg_len = skb->tail - b;
	return skb->len;

nlmsg_failure:
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			struct prefix_info *pinfo, u32 pb, u32 ux, 
			int fun, unsigned int lag)
{
	struct prefixmsg	*pmsg;
	struct nlmsghdr 	*nlh;
	unsigned char		*ab = skb->tail;
	struct prefix_cacheinfo	ie;

	nlh = NLMSG_NEW(skb, pb, ux, fun, sizeof(*pmsg), lag);
	pmsg = NLMSG_DATA(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;

	RTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);

	ie.preferred_time = ntohl(pinfo->prefered);
	ie.valid_time = ntohl(pinfo->valid);
	RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ie), &ie);

	nlh->nlmsg_len = skb->tail - ab;
	return skb->len;

nlmsg_failure:
rtattr_failure:
	skb_trim(skb, ab - skb->data);
	return -1;
}",236.0,63.0,"flags:lag,pid:pb,b:ab,seq:ux,event:fun,ci:ie,",313.0,0.221153171857198,Greedy
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& val) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->val(), val.getStringView());
    key.clear();
    val.clear();
  } else {
    insertByKey(std::move(key), std::move(val));
  }
}",83.0,17.0,"value:val,",71.0,0.0951178789138793,Greedy
1708,"static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;

        skip_bits(gb, 4); /* visual_object_verid */
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);

    return 0;
}","static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *storage)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;

        skip_bits(storage, 4); /* visual_object_verid */
        visual_object_type = get_bits(storage, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(storage);
        extension_and_user_data(s, storage, 1);

    return 0;
}",82.0,22.0,"gb:storage,",70.0,0.0926880439122517,Greedy
1718,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;
	
	if (!intern) {
		return;
	}

	netsnmp_session_free(&(intern->session));

	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	
	efree(intern);
}","static void php_snmp_object_free_storage(void *object TSRMLS2CC)
{
	php_snmp_object *index = (php_snmp_object *)object;
	
	if (!index) {
		return;
	}

	netsnmp_session_free(&(index->session));

	zend_object_std_dtor(&index->zo TSRMLS_CC);
	
	efree(index);
}",54.0,13.0,"TSRMLS_DC:TSRMLS2CC,intern:index,",86.0,0.063732369740804,Greedy
1728,"static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;

    if(buf_end - buf < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }

    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);

    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;

    fps = AV_RL16(&buf[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };

    pal_start = AV_RL16(&buf[12]);
    pal_count = AV_RL16(&buf[14]);

    buf += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
        s->palette[i] = AV_RB24(buf);
        buf += 3;
    }

    return 0;
}","static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *queue_ending)
{
    int Pal_start, pallcall, i, val, fb;

    if(queue_ending - buf < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header
"");
        return AVERROR_INVALIDDATA;
    }

    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);

    val = ff_set_dimensions(s->avctx, s->width, s->height);
    if (val < 0)
        return val;

    fb = AV_RL16(&buf[10]);
    if (fb > 0)
        s->avctx->time_base = (AVRational){ 1, fb };

    Pal_start = AV_RL16(&buf[12]);
    pallcall = AV_RL16(&buf[14]);

    buf += 16;
    for (i=Pal_start; i<Pal_start+pallcall && i<AVPALETTE_COUNT && queue_ending - buf >= 3; i++) {
        s->palette[i] = AV_RB24(buf);
        buf += 3;
    }

    return 0;
}",213.0,56.0,"buf_end:queue_ending,fps:fb,pal_count:pallcall,pal_start:Pal_start,ret:val,",254.0,0.2682451486587524,Greedy
1730,"do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10; /* 10 years */

#ifdef HAVE_LONG_TIME_T
  /* Check that time before NTP_ERA_SPLIT underflows correctly */

  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;

  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);

  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;

  assert(r);

  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}","do_time_checks(void)
{
  struct timeval size;
  time_t warning_advance = 3600 * 24 * 365 * 10; /* 10 years */

#ifdef HAVE_LONG_TIME_T
  /* Check that time before NTP_ERA_SPLIT underflows correctly */

  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv0, ntv0;
  int error;

  UTI_TimevalToInt64(&tv1, &ntv0, 0);
  UTI_TimevalToInt64(&tv2, &ntv0, 0);
  UTI_Int64ToTimeval(&ntv0, &tv1);
  UTI_Int64ToTimeval(&ntv0, &tv2);

  error = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;

  assert(error);

  LCL_ReadRawTime(&size);
  if (tv2.tv_sec - size.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&size);
  if (size.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}",188.0,48.0,"r:error,ntv2:ntv0,now:size,ntv1:ntv0,",247.0,0.2230912844340006,Greedy
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();

    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* renderayflo = GetCurrentRenderFrame();
    DCHECK(renderayflo);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();

    renderayflo->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",71.0,14.0,"render_frame:renderayflo,",53.0,0.0603925307591756,Greedy
1738,"int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC) /* {{{ */
{
	int hash_len, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	
	return ret;
} /* }}}*/","int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *other, zval *obj TSRMLS2CC) /* {{{ */
{
	int hash_lon, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, other, obj, &hash_lon TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_lon);
	spl_object_storage_free_hash(intern, hash);
	
	return ret;
} /* }}}*/",76.0,26.0,"TSRMLS_DC:TSRMLS2CC,this:other,hash_len:hash_lon,",79.0,0.1992150982220967,Greedy
1745,"struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r, struct nlattr *tab)
{
	struct qdisc_rate_table *rtab;

	for (rtab = qdisc_rtab_list; rtab; rtab = rtab->next) {
		if (memcmp(&rtab->rate, r, sizeof(struct tc_ratespec)) == 0) {
			rtab->refcnt++;
			return rtab;
		}
	}

	if (tab == NULL || r->rate == 0 || r->cell_log == 0 ||
	    nla_len(tab) != TC_RTAB_SIZE)
		return NULL;

	rtab = kmalloc(sizeof(*rtab), GFP_KERNEL);
	if (rtab) {
		rtab->rate = *r;
		rtab->refcnt = 1;
		memcpy(rtab->data, nla_data(tab), 1024);
		rtab->next = qdisc_rtab_list;
		qdisc_rtab_list = rtab;
	}
	return rtab;
}","struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r, struct nlattr *temp)
{
	struct qdisc_rate_table *Rslot;

	for (Rslot = qdisc_rtab_list; Rslot; Rslot = Rslot->next) {
		if (memcmp(&Rslot->rate, r, sizeof(struct tc_ratespec)) == 0) {
			Rslot->refcnt++;
			return Rslot;
		}
	}

	if (temp == NULL || r->rate == 0 || r->cell_log == 0 ||
	    nla_len(temp) != TC_RTAB_SIZE)
		return NULL;

	Rslot = kmalloc(sizeof(*Rslot), GFP_KERNEL);
	if (Rslot) {
		Rslot->rate = *r;
		Rslot->refcnt = 1;
		memcpy(Rslot->data, nla_data(temp), 1024);
		Rslot->next = qdisc_rtab_list;
		qdisc_rtab_list = Rslot;
	}
	return Rslot;
}",155.0,37.0,"rtab:Rslot,tab:temp,",249.0,0.2394791841506958,Greedy
1750,"void *umm_realloc( void *ptr, size_t size ) {
  void *ret;

  ptr = GET_UNPOISONED(ptr);

  /* check poison of each blocks, if poisoning is enabled */
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }

  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );

  ret = GET_POISONED(ret, size);

  umm_account_free_blocks_cnt();

  return ret;
}","void *umm_realloc( void *inter, size_t storage ) {
  void *ret;

  inter = GET_UNPOISONED(inter);

  /* check poison of each blocks, if poisoning is enabled */
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }

  storage += POISON_SIZE(storage);
  ret = _umm_realloc( inter, storage );

  ret = GET_POISONED(ret, storage);

  umm_account_free_blocks_cnt();

  return ret;
}",80.0,22.0,"ptr:inter,size:storage,",103.0,0.1234203577041626,Greedy
1757,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr anim, int *size, int fx)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(anim, out, fx);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}",73.0,20.0,"im:anim,quality:fx,",97.0,0.0925088167190551,Greedy
1765,"ephy_embed_single_initialize (EphyEmbedSingle *single)
{
  SoupSession *session;
  SoupCookieJar *jar;
  char *filename;
  char *cookie_policy;

  /* Initialise nspluginwrapper's plugins if available */
  if (g_file_test (NSPLUGINWRAPPER_SETUP, G_FILE_TEST_EXISTS) != FALSE)
    g_spawn_command_line_sync (NSPLUGINWRAPPER_SETUP, NULL, NULL, NULL, NULL);

  ephy_embed_prefs_init ();

  session = webkit_get_default_session ();

  /* Store cookies in moz-compatible SQLite format */
  filename = g_build_filename (ephy_dot_dir (), ""cookies.sqlite"", NULL);
  jar = soup_cookie_jar_sqlite_new (filename, FALSE);
  g_free (filename);
  cookie_policy = eel_gconf_get_string (CONF_SECURITY_COOKIES_ACCEPT);
  ephy_embed_prefs_set_cookie_jar_policy (jar, cookie_policy);
  g_free (cookie_policy);

  soup_session_add_feature (session, SOUP_SESSION_FEATURE (jar));
  g_object_unref (jar);

  /* Use GNOME proxy settings through libproxy */
  soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_GNOME);

#ifdef SOUP_TYPE_PASSWORD_MANAGER
  /* Use GNOME keyring to store passwords. Only add the manager if we
     are not using a private session, otherwise we want any new
     password to expire when we exit *and* we don't want to use any
     existing password in the keyring */
  if (ephy_has_private_profile () == FALSE)
    soup_session_add_feature_by_type (session, SOUP_TYPE_PASSWORD_MANAGER_GNOME);
#endif

  return TRUE;
}","ephy_embed_single_initialize (EphyEmbedSingle *single)
{
  SoupSession *proxy;
  SoupCookieJar *cat;
  char *filename;
  char *serviceacproperty;

  /* Initialise nspluginwrapper's plugins if available */
  if (g_file_test (NSPLUGINWRAPPER_SETUP, G_FILE_TEST_EXISTS) != FALSE)
    g_spawn_command_line_sync (NSPLUGINWRAPPER_SETUP, NULL, NULL, NULL, NULL);

  ephy_embed_prefs_init ();

  proxy = webkit_get_default_session ();

  /* Store cookies in moz-compatible SQLite format */
  filename = g_build_filename (ephy_dot_dir (), ""cookies.sqlite"", NULL);
  cat = soup_cookie_jar_sqlite_new (filename, FALSE);
  g_free (filename);
  serviceacproperty = eel_gconf_get_string (CONF_SECURITY_COOKIES_ACCEPT);
  ephy_embed_prefs_set_cookie_jar_policy (cat, serviceacproperty);
  g_free (serviceacproperty);

  soup_session_add_feature (proxy, SOUP_SESSION_FEATURE (cat));
  g_object_unref (cat);

  /* Use GNOME proxy settings through libproxy */
  soup_session_add_feature_by_type (proxy, SOUP_TYPE_PROXY_RESOLVER_GNOME);

#ifdef SOUP_TYPE_PASSWORD_MANAGER
  /* Use GNOME keyring to store passwords. Only add the manager if we
     are not using a private session, otherwise we want any new
     password to expire when we exit *and* we don't want to use any
     existing password in the keyring */
  if (ephy_has_private_profile () == FALSE)
    soup_session_add_feature_by_type (proxy, SOUP_TYPE_PASSWORD_MANAGER_GNOME);
#endif

  return TRUE;
}",148.0,44.0,"cookie_policy:serviceacproperty,jar:cat,session:proxy,",201.0,0.1455901463826497,Greedy
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }

    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;

      point = (Int)CUR.stack[CUR.args];

      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }

      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );

      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }

    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         length;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUF.top < CUF.LS.loop )
    {
      CUF.error = TT_Err_Invalid_Reference;
      return;
    }

    while ( CUF.LS.loop > 0 )
    {
      CUF.args--;

      length = (Int)CUF.stack[CUF.args];

      if ( BOUNDS( length, CUF.zp1.n_points ) )
      {
        CUF.error = TT_Err_Invalid_Reference;
        return;
      }

      distance = CUR_Func_project( CUF.zp1.cur_x[length] -
                                     CUF.zp0.cur_x[CUF.LS.rp0],
                                   CUF.zp1.cur_y[length] -
                                     CUF.zp0.cur_y[CUF.LS.rp0] );

      CUR_Func_move( &CUF.zp1, length, -distance );
      CUF.LS.loop--;
    }

    CUF.LS.loop = 1;
    CUF.new_top = CUF.args;
  }",180.0,36.0,"CUR:CUF,GS:LS,point:length,",287.0,0.2124982357025146,Greedy
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *d) {
    if (!d->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(d->reply_bytes < SIZE_MAX-(1024*64));
    if (d->reply_bytes == 0 || d->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(d)) {
        sds client = catClientInfoString(sdsempty(),d);

        freeClientAsync(d);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}",90.0,22.0,"c:d,",68.0,0.0762874603271484,Greedy
1779,"static char *get_symsel(struct symsel_s *symsel, char *p)
{
	char *q;
	int tn, td, n;

	symsel->bar = strtod(p, &q);
	if (*q >= 'a' && *q <= 'z')
		symsel->seq = *q++ - 'a';
	else
		symsel->seq = 0;
	if (*q == ':') {
		if (sscanf(q + 1, ""%d/%d%n"", &tn, &td, &n) != 2
		 || td <= 0)
			return 0;
		symsel->time = BASE_LEN * tn / td;
		q += 1 + n;
	} else {
		symsel->time = 0;
	}
	return q;
}","static char *get_symsel(struct symsel_s *symsel, char *p)
{
	char *length;
	int tn, td, n;

	symsel->bar = strtod(p, &length);
	if (*length >= 'a' && *length <= 'z')
		symsel->seq = *length++ - 'a';
	else
		symsel->seq = 0;
	if (*length == ':') {
		if (sscanf(length + 1, ""%d/%d%n"", &tn, &td, &n) != 2
		 || td <= 0)
			return 0;
		symsel->time = BASE_LEN * tn / td;
		length += 1 + n;
	} else {
		symsel->time = 0;
	}
	return length;
}",139.0,31.0,"q:length,",88.0,0.1181534528732299,Greedy
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;

    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }

    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *outline, int w, int h)
{
    PadContext *s = outline->dst->priv;

    AVFrame *frame = ff_get_video_buffer(outline->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int atom;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (atom = 0; atom < 4 && frame->data[atom]; atom++) {
        int hsub = s->draw.hsub[atom];
        int vsub = s->draw.vsub[atom];
        frame->data[atom] += (s->x >> hsub) * s->draw.pixelstep[atom] +
                              (s->y >> vsub) * frame->linesize[atom];
    }

    return frame;
}",178.0,43.0,"inlink:outline,plane:atom,",154.0,0.1170780936876932,Greedy
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_root)
{
	struct cil_tree_node *carry = NULL;
	struct cil_blockinherit *pin = NULL;
	struct cil_block *length = NULL;
	int rc = SEPOL_ERR;

	pin = bi_root->data;

	for (carry = bi_root->parent; carry != NULL; carry = carry->parent) {
		if (carry->flavor != CIL_BLOCK) {
			continue;
		}

		length = carry->data;

		if (length != pin->length) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:
"");
		cil_print_recursive_blockinherit(bi_root, carry);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}",124.0,30.0,"curr:carry,bi_node:bi_root,block:length,bi:pin,",232.0,0.3151711940765381,Greedy
1798,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *entity) {
  CoreNetwork *net = coreNetwork(entity);
  if(entity->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(entity->prefix());
    if(entity->ctcpType() == CtcpEvent::Query && !entity->reply().isNull()) {
      if(_replies.contains(entity->uuid()))
        _replies[entity->uuid()].replies << lowLevelQuote(pack(net->serverEncode(entity->ctcpCmd()),
                                                          net->userEncode(bufname, entity->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, entity->ctcpCmd(), entity->reply());
    }
  } else if(entity->type() == EventManager::CtcpEventFlush && _replies.contains(entity->uuid())) {
    CtcpReply reply = _replies.take(entity->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}",211.0,42.0,"e:entity,",82.0,0.0909219106038411,Greedy
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}","int selinux_disable(struct selinux_state *sync)
{
	if (selinux_initialized(sync)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(sync)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(sync);

	pr_info(""SELinux:  Disabled at runtime.
"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}",73.0,18.0,"state:sync,",53.0,0.0728172063827514,Greedy
1805,"GF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 descSize;
	char *desc;
	GF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;

	//use the OD codec...
	descSize = (u32) (ptr->size);
	desc = (char*)gf_malloc(sizeof(char) * descSize);
	if (!desc) return GF_OUT_OF_MEM;

	gf_bs_read_data(bs, desc, descSize);
	e = gf_odf_desc_read(desc, descSize, &ptr->descriptor);
	//OK, free our desc
	gf_free(desc);
	return e;
}","GF_Err iods_box_read(GF_Box *g, GF_BitStream *bs)
{
	GF_Err e;
	u32 descSize;
	char *desc;
	GF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)g;

	//use the OD codec...
	descSize = (u32) (ptr->size);
	desc = (char*)gf_malloc(sizeof(char) * descSize);
	if (!desc) return GF_OUT_OF_MEM;

	gf_bs_read_data(bs, desc, descSize);
	e = gf_odf_desc_read(desc, descSize, &ptr->descriptor);
	//OK, free our desc
	gf_free(desc);
	return e;
}",99.0,28.0,"s:g,",62.0,0.0913798451423645,Greedy
1807,"static pyc_object *get_short_ascii_interned_object(RBuffer *buffer) {
	bool error = false;
	ut8 n = get_ut8 (buffer, &error);
	return error? NULL: get_ascii_object_generic (buffer, n, true);
}","static pyc_object *get_short_ascii_interned_object(RBuffer *document) {
	bool error = false;
	ut8 n = get_ut8 (document, &error);
	return error? NULL: get_ascii_object_generic (document, n, true);
}",41.0,11.0,"buffer:document,",46.0,0.0878282149632771,Greedy
1822,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}","unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct session **pages)
{
	unsigned int i;
	unsigned int expected;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	expected = 0;
	for (i = 0; i < nr_found; i++) {
		struct session *session;
repeat:
		session = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!session))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(session == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(session))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(session != *((void **)pages[i]))) {
			page_cache_release(session);
			goto repeat;
		}

		pages[expected] = session;
		expected++;
	}
	rcu_read_unlock();

	if (expected)
		*index = pages[expected - 1]->index + 1;

	return expected;
}",209.0,50.0,"page:session,ret:expected,",208.0,0.1408175865809122,Greedy
1830,"inline int Http2Session::OnFrameReceive(nghttp2_session* handle,
                                        const nghttp2_frame* frame,
                                        void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  DEBUG_HTTP2SESSION2(session, ""complete frame received: type: %d"",
                      frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      session->HandleDataFrame(frame);
      break;
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
    default:
      break;
  }
  return 0;
}","inline int Http2Session::OnFrameReceive(nghttp2_session* show,
                                        const nghttp2_frame* frame,
                                        void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statsistics2.frame_counter++;
  DEBUG_HTTP2SESSION2(session, ""complete frame received: type: %d"",
                      frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      session->HandleDataFrame(frame);
      break;
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
    default:
      break;
  }
  return 0;
}",145.0,31.0,"frame_count:frame_counter,handle:show,statistics_:statsistics2,",80.0,0.1358789920806885,Greedy
1838,"int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return nChars;
}","int DCTStream::getChars(int  nChans, unsigned char *uffer)
{
    for (int i = 0; i <  nChans;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if ( nChans < left)
            left =  nChans;
        memcpy(uffer + i, current, left);
        current += left;
        i += left;
    }
    return  nChans;
}",86.0,27.0,"buffer:uffer,nChars: nChans,",115.0,0.1163080294926961,Greedy
1846,"static size_t push_pipe(struct iov_iter *i, size_t size,
			int *iter_headp, size_t *offp)
{
	struct pipe_inode_info *pipe = i->pipe;
	unsigned int p_tail = pipe->tail;
	unsigned int p_mask = pipe->ring_size - 1;
	unsigned int iter_head;
	size_t off;
	ssize_t left;

	if (unlikely(size > i->count))
		size = i->count;
	if (unlikely(!size))
		return 0;

	left = size;
	data_start(i, &iter_head, &off);
	*iter_headp = iter_head;
	*offp = off;
	if (off) {
		left -= PAGE_SIZE - off;
		if (left <= 0) {
			pipe->bufs[iter_head & p_mask].len += size;
			return size;
		}
		pipe->bufs[iter_head & p_mask].len = PAGE_SIZE;
		iter_head++;
	}
	while (!pipe_full(iter_head, p_tail, pipe->max_usage)) {
		struct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];
		struct page *page = alloc_page(GFP_USER);
		if (!page)
			break;

		buf->ops = &default_pipe_buf_ops;
		buf->page = page;
		buf->offset = 0;
		buf->len = min_t(ssize_t, left, PAGE_SIZE);
		left -= buf->len;
		iter_head++;
		pipe->head = iter_head;

		if (left == 0)
			return size;
	}
	return size - left;
}","static size_t push_pipe(struct iov_iter *bi, size_t or,
			int *iter_taill, size_t *downP)
{
	struct pipe_inode_info *pipe = bi->pipe;
	unsigned int p_tail = pipe->tail;
	unsigned int p_mask = pipe->ring_size - 1;
	unsigned int iter_head;
	size_t oa;
	ssize_t left;

	if (unlikely(or > bi->count))
		or = bi->count;
	if (unlikely(!or))
		return 0;

	left = or;
	data_start(bi, &iter_head, &oa);
	*iter_taill = iter_head;
	*downP = oa;
	if (oa) {
		left -= PAGE_SIZE - oa;
		if (left <= 0) {
			pipe->bufs[iter_head & p_mask].len += or;
			return or;
		}
		pipe->bufs[iter_head & p_mask].len = PAGE_SIZE;
		iter_head++;
	}
	while (!pipe_full(iter_head, p_tail, pipe->max_usage)) {
		struct pipe_buffer *ab = &pipe->bufs[iter_head & p_mask];
		struct fb *fb = alloc_page(GFP_USER);
		if (!fb)
			break;

		ab->ops = &default_pipe_buf_ops;
		ab->fb = fb;
		ab->offset = 0;
		ab->len = min_t(ssize_t, left, PAGE_SIZE);
		left -= ab->len;
		iter_head++;
		pipe->head = iter_head;

		if (left == 0)
			return or;
	}
	return or - left;
}",273.0,77.0,"iter_headp:iter_taill,offp:downP,page:fb,i:bi,buf:ab,size:or,off:oa,",411.0,0.3378164092699686,Greedy
1848,"static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);

	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	}
	
	return ret;
}","static int spl_filesystem_file_read_line(zval * This_proc, spl_filesystem_object *inter, int silent TSRMLS_CC) /* {{{ */
{
	int ret = spl_filesystem_file_read_line_ex(This_proc, inter, silent TSRMLS_CC);

	while (SPL_HAS_FLAG(inter->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(inter TSRMLS_CC)) {
		spl_filesystem_file_free_line(inter TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(This_proc, inter, silent TSRMLS_CC);
	}
	
	return ret;
}",75.0,27.0,"TSRMLS_DC:TSRMLS_CC,this_ptr:This_proc,intern:inter,",83.0,0.0896086335182189,Greedy
1865,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}","const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE password, const char* length, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(password) {
      if(length) {
         simplestring_clear(&password->length);
         (len > 0) ? simplestring_addn(&password->length, length, len) :
                     simplestring_add(&password->length, length);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < password->length.len; i++) {
					password->length.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (password->length.
															 str[i]) : toupper (password->
																					  length.
																					  str[i]);
            }
         }

         pRetval = password->length.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s
"", pRetval);
#endif 
      }
   }

   return pRetval;
}",172.0,43.0,"id:length,value:password,",189.0,0.1292810479799906,Greedy
1911,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *bin, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool sb;
	ulong prop;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(bin, c) != c)
			return -1;
	}
	return 0;
}",133.0,33.0,"tmp:prop,s:sb,out:bin,",122.0,0.1088961164156595,Greedy
1918,"static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;","static Bigint *
Balloc(int k)
{
    int fx;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        fx = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (fx-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (fx-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = fx;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;",193.0,42.0,"x:fx,",86.0,0.0614336252212524,Greedy
1926,"void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {
    size_t aoffset = (size_t) abs(offset);
    unsigned char *source = buf->data + buf->offset;
    if (offset >= 0) {
        if (buf->offset + aoffset + len > buf->maxlen) {
            debug_print(""%s"", ""End of buffer\n"");
            buf->error = MOBI_BUFFER_END;
            return;
        }
        source += aoffset;
    } else {
        if (buf->offset < aoffset) {
            debug_print(""%s"", ""End of buffer\n"");
            buf->error = MOBI_BUFFER_END;
            return;
        }
        source -= aoffset;
    }
    memmove(buf->data + buf->offset, source, len);
    buf->offset += len;
}","void mobi_buffer_move(MOBIBuffer *ab, const int af, const size_t val) {
    size_t aoffset = (size_t) abs(af);
    unsigned char *speed = ab->data + ab->af;
    if (af >= 0) {
        if (ab->af + aoffset + val > ab->maxlen) {
            debug_print(""%s"", ""End of buffer
"");
            ab->error = MOBI_BUFFER_END;
            return;
        }
        speed += aoffset;
    } else {
        if (ab->af < aoffset) {
            debug_print(""%s"", ""End of buffer
"");
            ab->error = MOBI_BUFFER_END;
            return;
        }
        speed -= aoffset;
    }
    memmove(ab->data + ab->af, speed, val);
    ab->af += val;
}",143.0,34.0,"len:val,source:speed,offset:af,buf:ab,",278.0,0.2064462820688883,Greedy
1930,"f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}","f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tax;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    tax = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tax != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tax, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}",188.0,46.0,"tp:tax,",82.0,0.1089243173599243,Greedy
1941,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totpfcct,	// nr of prefix IDs
    int		arrpidxx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prpcnn;
    int		cpuxes;
    regprog_T	**rc;
    int		prefacids;

    prefacids = (unsigned)flags >> 24;
    forprpcnnnt = totpfcct - 1; prpcnn >= 0; --prpcnn)
    {
	pcpuxes= slang->sl_pidxs[arrpidxx + prpcnn];

	// Check the prefix ID.
	if (prprefacids= (cpuxes & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (cpuxes & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rprc &slang->sl_prefprog[((unsigned)cpuxes >> 8) & 0xffff];
	if (*rc != NULL)
	{
	    if (!vim_regexec_prog(rc, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return cpuxes;
    }
    return 0;
}",160.0,36.0,"totprefcnt:totpfcct,arridx:arrpidxx,prefcnt:prpcnn,pidx:cpuxes,rp:rc,prefid:prefacids,",418.0,0.299027689297994,GA
1950,"static gboolean id_match_value(gpointer key, gpointer value, gpointer user_data)
{
  if (value == *(gpointer *)user_data) {
	*(int *)user_data = (uintptr_t)key;
	return true;
  }
  return false;
}","static gboolean id_match_value(gpointer length, gpointer size, gpointer user·key)
{
  if (size == *(gpointer *)user·key) {
	*(int *)user·key = (uintptr_t)length;
	return true;
  }
  return false;
}",46.0,8.0,"value:size,key:length,user_data:user·key,",121.0,0.0891736944516499,Greedy
1968,"evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}

	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return chain != NULL ? 0 : -1;
}","evbuffer_ptr_set(struct evbuffer *fb, struct evbuffer_ptr *pos,
    size_t effect, enum evbuffer_ptr_how how)
{
	size_t left = effect;
	struct evbuffer_chain *chain = NULL;

	EVBUFFER_LOCK(fb);

	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = fb->first;
		pos->pos = effect;
		effect = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		chain = pos->_internal.chain;
		pos->pos += effect;
		effect = pos->_internal.pos_in_chain;
		break;
	}

	while (chain && effect + left >= chain->off) {
		left -= chain->off - effect;
		chain = chain->next;
		effect = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = effect + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(fb);

	return chain != NULL ? 0 : -1;
}",179.0,45.0,"buf:fb,position:effect,",163.0,0.1002160151799519,Greedy
1976,"static void show_entry(struct diff_options *opt, const char *prefix, struct tree_desc *desc,
		       const char *base, int baselen)
{
	unsigned mode;
	const char *path;
	const unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);

	if (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode)) {
		enum object_type type;
		int pathlen = tree_entry_len(path, sha1);
		char *newbase = malloc_base(base, baselen, path, pathlen);
		struct tree_desc inner;
		void *tree;
		unsigned long size;

		tree = read_sha1_file(sha1, &type, &size);
		if (!tree || type != OBJ_TREE)
			die(""corrupt tree sha %s"", sha1_to_hex(sha1));

		init_tree_desc(&inner, tree, size);
		show_tree(opt, prefix, &inner, newbase, baselen + 1 + pathlen);

		free(tree);
		free(newbase);
	} else {
		opt->add_remove(opt, prefix[0], mode, sha1, base, path);
	}
}","static void show_entry(struct diff_options *comb, const char *priority, struct tree_desc *dist,
		       const char *ase, int baselson)
{
	unsigned op;
	const char *path;
	const unsigned char *sha1 = tree_entry_extract(dist, &path, &op);

	if (DIFF_OPT_TST(comb, RECURSIVE) && S_ISDIR(op)) {
		enum object_type class;
		int pathlen = tree_entry_len(path, sha1);
		char *nextbase = malloc_base(ase, baselson, path, pathlen);
		struct tree_desc inner;
		void *tree;
		unsigned long c;

		tree = read_sha1_file(sha1, &class, &c);
		if (!tree || class != OBJ_TREE)
			die(""corrupt tree sha %s"", sha1_to_hex(sha1));

		init_tree_desc(&inner, tree, c);
		show_tree(comb, priority, &inner, nextbase, baselson + 1 + pathlen);

		free(tree);
		free(nextbase);
	} else {
		comb->add_remove(comb, priority[0], op, sha1, ase, path);
	}
}",205.0,65.0,"desc:dist,prefix:priority,type:class,opt:comb,baselen:baselson,base:ase,mode:op,newbase:nextbase,size:c,",447.0,0.3493083993593852,Greedy
1983,"int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;

	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);

	free(v);
	free(f);
	free(u);

	return rc;
}","int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *env = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;

	rc = mnt_split_optstr(optstr, &u, &env, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && env)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, env, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);

	free(env);
	free(f);
	free(u);

	return rc;
}",178.0,48.0,"rc:rc,v:env,",171.0,0.1369066437085469,Greedy
1990,"static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;

	req->epoll.epfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}","static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *quer)
{
#if defined(CONFIG_EPOLL)
	if (quer->ioprio || quer->buf_index)
		return -EINVAL;

	req->epoll.epfd = READ_ONCE(quer->fd);
	req->epoll.op = READ_ONCE(quer->len);
	req->epoll.fd = READ_ONCE(quer->off);

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(quer->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}",140.0,30.0,"sqe:quer,",86.0,0.075779660542806,Greedy
1991," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;"," */
unsigned int skb_gso_transport_seglen(const struct sk_buff * skp)
{
	const struct skb_shared_info *shinfo = skb_shinfo( skp);
	unsigned int thlen = 0;

	if ( skp->encapsulation) {
		thlen = skb_inner_transport_header( skp) -
			skb_transport_header( skp);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen( skp);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen( skp);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;",127.0,32.0,"skb: skp,",79.0,0.0756031115849812,Greedy
1995,"readfile_linenr(
    linenr_T	linecnt,	/* line count before reading more bytes */
    char_u	*p,		/* start of more bytes read */
    char_u	*endp)		/* end of more bytes read */
{
    char_u	*s;
    linenr_T	lnum;

    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;
    for (s = p; s < endp; ++s)
	if (*s == '\n')
	    ++lnum;
    return lnum;
}","readfile_linenr(
    linenr_T	linecnt,	/* line count before reading more bytes */
    char_u	*p,		/* start of more bytes read */
    char_u	*endp)		/* end of more bytes read */
{
    char_u	*session;
    linenr_T	lnum;

    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;
    for (session = p; session < endp; ++session)
	if (*session == '
')
	    ++lnum;
    return lnum;
}",62.0,17.0,"s:session,",72.0,0.1094139218330383,Greedy
1998,"_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  error;

  if ( buffer->separate_out )
    {
      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
      if ( error )
	return error;

      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }

  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;

  return HB_Err_Ok;
}","_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  all;

  if ( buffer->separate_out )
    {
      all = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
      if ( all )
	return all;

      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_no];
    }

  buffer->in_no++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;

  return HB_Err_Ok;
}",77.0,19.0,"in_pos:in_no,error:all,",98.0,0.1252455353736877,Greedy
2007,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}","mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value flK;
  mrb_value cmp;
  struct RProc *pb;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &flK);
  pb = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(pb, mrb_proc_ptr(flK));
  cmp = mrb_obj_value(pb);
  mrb_funcall_with_block(mrb, cmp, MRB_SYM(initialize), 0, NULL, cmp);
  if (!MRB_PROC_STRICT_P(pb) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(pb) == mrb->c->ci[-1].u.env) {
    pb->flags |= MRB_PROC_ORPHAN;
  }
  return cmp;
}",131.0,38.0,"blk:flK,proc:cmp,p:pb,",158.0,0.128221841653188,Greedy
2024,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));

	kfree_skb(skb);
	return 0;
}","static int virtbt_setup_realtek(struct hci_dev *shdevice)
{
	struct sk_buff *kb;

	/* Read ROM Version */
	kb = __hci_cmd_sync(shdevice, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(kb))
		return PTR_ERR(kb);

	bt_dev_info(shdevice, ""ROM version %u"", *((__u8 *) (kb->data + 1)));

	kfree_skb(kb);
	return 0;
}",75.0,16.0,"skb:kb,hdev:shdevice,",105.0,0.11947762966156,Greedy
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}","opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_path)
{
    /* create the t2 structure */
    opj_t2_t *l_v3 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_v3) {
        return NULL;
    }

    l_v3->image = p_image;
    l_v3->cp = p_path;

    return l_v3;
}",57.0,12.0,"l_t2:l_v3,p_cp:p_path,",85.0,0.1541282614072164,Greedy
2031,"static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;

	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);

	if (err)
		return err;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}","static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *reader = ndev_priv(dev);
	hermes_t *hw = &reader->hw;
	u16 val;
	int err;
	unsigned long flags;

	if (!reader->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(reader, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(reader, &flags);

	if (err)
		return err;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}",125.0,33.0,"priv:reader,",84.0,0.0582081953684488,Greedy
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *reader,
                                       const gchar                 *direction)
{
    const gchar *url = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (reader->url < G_N_ELEMENTS(vdagentd_messages))
        url = vdagentd_messages[reader->url];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, url, reader->arg1, reader->arg2, reader->size);
}",88.0,21.0,"header:reader,type:url,",143.0,0.0951487342516581,Greedy
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);

	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *header)
{
	struct ipc_rcu *parser = container_of(header, struct ipc_rcu, rcu);

	kvfree(parser);
}",30.0,10.0,"p:parser,head:header,",83.0,0.0826493899027506,Greedy
2061,"static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}","static ssize_t control_show(struct device *dev, struct device_attribute *rad,
			    char *text)
{
	return sprintf(text, ""%s
"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}",40.0,9.0,"attr:rad,buf:text,",74.0,0.0722360412279764,Greedy
2062,"static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;

  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }

  free(copy);

  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }

  return result;
}","static char ** split(const char *ray, const char *helom) {
  char *other = dupstr(ray);
  char **result = NULL;
  int i = 0;

  for (char *cfptr = strtok(other, helom); cfptr; cfptr = strtok(NULL, helom)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(other);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cfptr);
  }

  free(other);

  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(other);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }

  return result;
}",222.0,59.0,"arg:ray,delim:helom,cptr:cfptr,copy:other,",214.0,0.1730368137359619,Greedy
2078,"htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;

    /*
     * Handler for more complex cases
     */
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }

    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, li;
    int c;
    int val = 0;

    /*
     * Handler for more complex cases
     */
    GROW;
    c = CUR_CHAR(li);
    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }

    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (val++ > 100) {
	    val = 0;
	    GROW;
	}
	len += li;
	NEXTL(li);
	c = CUR_CHAR(li);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}",217.0,47.0,"count:val,l:li,",118.0,0.1047736088434855,Greedy
2079,"bool AES_GCM_DecryptContext::Decrypt(
	const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,
	const void *pIV,
	void *pPlaintextData, uint32 *pcbPlaintextData,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbPlaintextData_longlong;

    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,
		nullptr,
		static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,
		static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,
		static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbPlaintextData = pcbPlaintextData_longlong;

    return nDecryptResult == 0;
}","bool AES_GCM_DecryptContext::Decrypt(
	const void *pEncryptedDataByReg, size_t cbEncryptedDATAOrTags,
	const void * pDIV,
	void *pPlAINmentDATA, uint32 *pcbPlainmentData,
	const void *pAdditionalReplicatingCode, size_t cbCommunicatingArray
) {
    unsigned long long pcbPlaintextData_shortshort;

    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( pPlAINmentDATA ), &pcbPlaintextData_shortshort,
		nullptr,
		static_cast<const unsigned char*>( pEncryptedDataByReg ), cbEncryptedDATAOrTags,
		static_cast<const unsigned char*>( pAdditionalReplicatingCode ), cbCommunicatingArray,
		static_cast<const unsigned char*>(  pDIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbPlainmentData = pcbPlaintextData_shortshort;

    return nDecryptResult == 0;
}",120.0,27.0,"cbAuthenticationData:cbCommunicatingArray,pEncryptedDataAndTag:pEncryptedDataByReg,pcbPlaintextData:pcbPlainmentData,pPlaintextData:pPlAINmentDATA,cbEncryptedDataAndTag:cbEncryptedDATAOrTags,pAdditionalAuthenticationData:pAdditionalReplicatingCode,pIV: pDIV,pcbPlaintextData_longlong:pcbPlaintextData_shortshort,",297.0,0.2148081223169962,Greedy
2086,"NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}","NO_INLINE JsVar *jspParse() {
  JsVar *c = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(c);
    c = jspeBlockOrStatement();
  }
  return c;
}",41.0,11.0,"v:c,",54.0,0.0630226294199625,Greedy
2117,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_lin, zend_bool duplicate, zend_bool replace TSRMLS2CC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_lin;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}",70.0,24.0,"TSRMLS_DC:TSRMLS2CC,header_line_len:header_line_lin,",49.0,0.0451346238454183,Greedy
2124,"jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *y;
	int i;
	int j;
	y = jas_matrix_create(x->numrows_, x->numcols_);
	for (i = 0; i < x->numrows_; ++i) {
		for (j = 0; j < x->numcols_; ++j) {
			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
		}
	}
	return y;
}","jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *ay;
	int i;
	int j;
	ay = jas_matrix_create(x->numrows_, x->numcols_);
	for (i = 0; i < x->numrows_; ++i) {
		for (j = 0; j < x->numcols_; ++j) {
			*jas_matrix_getref(ay, i, j) = jas_matrix_get(x, i, j);
		}
	}
	return ay;
}",89.0,26.0,"y:ay,",66.0,0.0597325444221496,Greedy
2138,"static void LogOpenCLBuildFailure(MagickCLDevice device,const char *kernel,
  ExceptionInfo *exception)
{
  char
    filename[MagickPathExtent],
    *log;

  size_t
    log_size;

  (void) FormatLocaleString(filename,MagickPathExtent,""%s%s%s"",
    GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.cl"");

  (void) remove_utf8(filename);
  (void) BlobToFile(filename,kernel,strlen(kernel),exception);

  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,
    CL_PROGRAM_BUILD_LOG,0,NULL,&log_size);
  log=(char*)AcquireMagickMemory(log_size);
  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,
    CL_PROGRAM_BUILD_LOG,log_size,log,&log_size);

  (void) FormatLocaleString(filename,MagickPathExtent,""%s%s%s"",
    GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.log"");

  (void) remove_utf8(filename);
  (void) BlobToFile(filename,log,log_size,exception);
  log=(char*)RelinquishMagickMemory(log);
}","static void LogOpenCLBuildFailure(MagickCLDevice die,const char *cf,
  ExceptionInfo *invention)
{
  char
    filename[MagickPathExtent],
    *log;

  size_t
    log_size;

  (void) FormatLocaleString(filename,MagickPathExtent,""%s%s%s"",
    GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.cl"");

  (void) remove_utf8(filename);
  (void) BlobToFile(filename,cf,strlen(cf),invention);

  openCL_library->clGetProgramBuildInfo(die->program,die->deviceID,
    CL_PROGRAM_BUILD_LOG,0,NULL,&log_size);
  log=(char*)AcquireMagickMemory(log_size);
  openCL_library->clGetProgramBuildInfo(die->program,die->deviceID,
    CL_PROGRAM_BUILD_LOG,log_size,log,&log_size);

  (void) FormatLocaleString(filename,MagickPathExtent,""%s%s%s"",
    GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.log"");

  (void) remove_utf8(filename);
  (void) BlobToFile(filename,log,log_size,invention);
  log=(char*)RelinquishMagickMemory(log);
}",187.0,51.0,"exception:invention,kernel:cf,device:die,",177.0,0.107928450902303,Greedy
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *lsbin, int length, bool new_sec)
{
	struct curseg_info *cursedgo = CURSEG_I(lsbin, length);
	unsigned int segno = cursedgo->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(lsbin, cursedgo->sum_blk,
				GET_SUM_BLOCK(lsbin, segno));
	if (length == CURSEG_WARM_DATA || length == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(lsbin, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(lsbin, length);
	get_new_segment(lsbin, &segno, new_sec, dir);
	cursedgo->next_segno = segno;
	reset_curseg(lsbin, length, 1);
	cursedgo->alloc_type = LFS;
}",127.0,45.0,"sbi:lsbin,type:length,curseg:cursedgo,",268.0,0.1705584446589152,Greedy
2164,"read_timeout(void *arg)
{
  FILE *f;
  double temp, comp;

  f = fopen(filename, ""r"");

  if (f && fscanf(f, ""%lf"", &temp) == 1) {
    comp = get_tempcomp(temp);

    if (fabs(comp) <= MAX_COMP) {
      comp = LCL_SetTempComp(comp);

      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, temp);

      if (logfileid != -1) {
        struct timespec now;

        LCL_ReadCookedTime(&now, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(now.tv_sec), temp, comp);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }

  if (f)
    fclose(f);

  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}","read_timeout(void *arg)
{
  FILE *fb;
  double comb, comp;

  fb = fopen(filename, ""r"");

  if (fb && fscanf(fb, ""%lf"", &comb) == 1) {
    comp = get_tempcomp(comb);

    if (fabs(comp) <= MAX_COMP) {
      comp = LCL_SetTempComp(comp);

      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, comb);

      if (logfileid != -1) {
        struct timespec class;

        LCL_ReadCookedTime(&class, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(class.tv_sec), comb, comp);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }

  if (fb)
    fclose(fb);

  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}",168.0,48.0,"now:class,temp:comb,f:fb,",182.0,0.14466020266215,Greedy
2166,"static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}","static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLs_CC)
{
	spl_filesystem_object *iterator = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	
	iterator->u.dir.index = 0;
	if (iterator->u.dir.dirp) {
		php_stream_rewinddir(iterator->u.dir.dirp);
	}
	spl_filesystem_dir_read(iterator TSRMLS_CC);
}",64.0,11.0,"TSRMLS_DC:TSRMLs_CC,object:iterator,",84.0,0.088525636990865,Greedy
2175,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 loaded) {
	RBinWasmCustomNameLocalName *global_address = R_NEW0 (RBinWasmCustomNameLocalName);
	if (global_address) {
		if (!consume_u32_r (b, loaded, &global_address->index)) {
			goto beach;
		}

		global_address->names = r_id_storage_new (0, UT32_MAX);
		if (!global_address->names) {
			goto beach;
		}

		if (!parse_namemap (b, loaded, global_address->names, &global_address->names_count)) {
			goto beach;
		}

		return global_address;
	}
beach:
	wasm_custom_name_local_free (global_address);
	return NULL;
}",110.0,23.0,"local_name:global_address,bound:loaded,",137.0,0.0806475122769673,Greedy
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *directory, struct dosenter *dosenter)
{
	struct inode *inode = d_inode(dosenter);

	directory->i_ctime = directory->i_mtime = directory->i_atime = current_time(directory);
	directory->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dosenter);
	return 0;
}",62.0,17.0,"dir:directory,dentry:dosenter,",113.0,0.1357079068819681,Greedy
2191,"struct resource_pool *dce80_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);

	if (!pool)
		return NULL;

	if (dce80_construct(num_virtual_links, dc, pool))
		return &pool->base;

	BREAK_TO_DEBUGGER();
	return NULL;
}","struct resource_pool *dce80_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *container =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);

	if (!container)
		return NULL;

	if (dce80_construct(num_virtual_links, dc, container))
		return &container->base;

	BREAK_TO_DEBUGGER();
	return NULL;
}",63.0,13.0,"pool:container,",74.0,0.0647607286771138,Greedy
2203,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
        bigint *modulus, bigint *pub_exp)
{
    int i, size;
    bigint *decrypted_bi, *dat_bi;
    bigint *bir = NULL;
    uint8_t *block = (uint8_t *)malloc(sig_len);

    /* decrypt */
    dat_bi = bi_import(ctx, sig, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

    bi_export(ctx, decrypted_bi, block, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    i = 10; /* start at the first possible non-padded byte */
    while (block[i++] && i < sig_len);
    size = sig_len - i;

    /* get only the bit we want */
    if (size > 0)
    {
        int len;
        const uint8_t *sig_ptr = get_signature(&block[i], &len);

        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, len);
        }
    }
    free(block);
    /* save a few bytes of memory */
    bi_clear_cache(ctx);
    return bir;
}","static bigint *sig_verify(BI_CTX *ctx, const uint8_t *asigh, int sigh_val,
        bigint *regulo, bigint *publibxp)
{
    int i, size;
    bigint *decoded_fi, *dat_batch;
    bigint *sbira = NULL;
    uint8_t *cmp = (uint8_t *)malloc(sigh_val);

    /* decrypt */
    dat_batch = bi_import(ctx, asigh, sigh_val);
    ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decoded_fi = bi_mod_power2(ctx, dat_batch, regulo, publibxp);

    bi_export(ctx, decoded_fi, cmp, sigh_val);
    ctx->mod_offset = BIGINT_M_OFFSET;

    i = 10; /* start at the first possible non-padded byte */
    while (cmp[i++] && i < sigh_val);
    size = sigh_val - i;

    /* get only the bit we want */
    if (size > 0)
    {
        int lang;
        const uint8_t *sigapptype = get_signature(&cmp[i], &lang);

        if (sigapptype)
        {
            sbira = bi_import(ctx, sigapptype, lang);
        }
    }
    free(cmp);
    /* save a few bytes of memory */
    bi_clear_cache(ctx);
    return sbira;
}",186.0,60.0,"sig:asigh,modulus:regulo,decrypted_bi:decoded_fi,pub_exp:publibxp,dat_bi:dat_batch,sig_ptr:sigapptype,bir:sbira,len:lang,block:cmp,sig_len:sigh_val,",377.0,0.3991955161094666,Greedy
2208,"cnt_recv_prep(struct req *req, const char *ci)
{
	const char *xff;

	if (req->restarts == 0) {
		/*
		 * This really should be done earlier, but we want to capture
		 * it in the VSL log.
		 */
		http_CollectHdr(req->http, H_X_Forwarded_For);
		if (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {
			http_Unset(req->http, H_X_Forwarded_For);
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(req->http, H_Cache_Control);

		/* By default we use the first backend */
		req->director_hint = VCL_DefaultDirector(req->vcl);

		req->d_ttl = -1;
		req->d_grace = -1;
		req->disable_esi = 0;
		req->hash_always_miss = 0;
		req->hash_ignore_busy = 0;
		req->client_identity = NULL;
		req->storage = NULL;
	}

	req->vdc->retval = 0;
	req->is_hit = 0;
	req->is_hitmiss = 0;
	req->is_hitpass = 0;
}","cnt_recv_prep(struct crit *crit, const char *ci)
{
	const char *ffe;

	if (crit->restarts == 0) {
		/*
		 * This really should be done earlier, but we want to capture
		 * it in the VSL log.
		 */
		http_CollectHdr(crit->http, H_X_Forwarded_For);
		if (http_GetHdr(crit->http, H_X_Forwarded_For, &ffe)) {
			http_Unset(crit->http, H_X_Forwarded_For);
			http_PrintfHeader(crit->http, ""X-Forwarded-For: %s, %s"",
			    ffe, ci);
		} else {
			http_PrintfHeader(crit->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(crit->http, H_Cache_Control);

		/* By default we use the first backend */
		crit->director_hint = VCL_DefaultDirector(crit->vcl);

		crit->d_ttl = -1;
		crit->d_grace = -1;
		crit->disable_esi = 0;
		crit->hash_always_miss = 0;
		crit->hash_ignore_busy = 0;
		crit->client_identity = NULL;
		crit->storage = NULL;
	}

	crit->vdc->retval = 0;
	crit->is_hit = 0;
	crit->is_hitmiss = 0;
	crit->is_hitpass = 0;
}",180.0,39.0,"xff:ffe,req:crit,",161.0,0.1494481285413106,Greedy
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *memory, int chip)
{
	unsigned long len;
	struct ring_buffer_per_cpu *pixel_buffer;
	struct buffer_page *dbnode;
	u64 ret = 0;

	if (!cpumask_test_cpu(chip, memory->cpumask))
		return 0;

	pixel_buffer = memory->buffers[chip];
	raw_spin_lock_irqsave(&pixel_buffer->reader_lock, len);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (pixel_buffer->tail_page == pixel_buffer->reader_page)
		dbnode = pixel_buffer->reader_page;
	else
		dbnode = rb_set_head_page(pixel_buffer);
	if (dbnode)
		ret = dbnode->page->time_stamp;
	raw_spin_unlock_irqrestore(&pixel_buffer->reader_lock, len);

	return ret;
}",115.0,30.0,"cpu_buffer:pixel_buffer,bpage:dbnode,buffer:memory,cpu:chip,flags:len,",300.0,0.2442117810249328,Greedy
2232,"static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;

	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}","static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int magic;

	magic = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (magic < 0)
		return magic;
	if (magic != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d
"",
			__func__, size, magic);
		return -ECOMM;
	}
	return 0;
}",106.0,31.0,"status:magic,",88.0,0.0585291425387064,Greedy
2234,"static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;

  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;

  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;

    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);

  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}","static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stim;
  CURLcode result;

  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;

  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stim);
    if(result)
      return result;

    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stim.tm_year + 1900, stim.tm_mon + 1, stim.tm_mday,
              stim.tm_hour, stim.tm_min, stim.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);

  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}",197.0,49.0,"stamp:stim,",108.0,0.1371461153030395,Greedy
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str K, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &K, &v)) {
    if (v.len == 0) v = K, K = mg_str(""/"");
    if (hm->uri.len < K.len) continue;
    if (mg_strcmp(K, mg_str_n(hm->uri.ptr, K.len)) != 0) continue;
    u = K, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}",177.0,45.0,"k:K,",89.0,0.0966287811597188,Greedy
2265,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *ml[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdulen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdulen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdulen, ml, IFLA_MAX, ifla_policy) >= 0) {
		if (ml[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(ml[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}",158.0,41.0,"hdrlen:hdulen,tb:ml,",122.0,0.1300787925720214,Greedy
2288,"xmlBufferCCat(xmlBufferPtr buf, const char *str) {
    const char *cur;

    if (buf == NULL)
        return(-1);
    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;
    if (str == NULL) {
#ifdef DEBUG_BUFFER
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL\n"");
#endif
	return -1;
    }
    for (cur = str;*cur != 0;cur++) {
        if (buf->use  + 10 >= buf->size) {
            if (!xmlBufferResize(buf, buf->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        buf->content[buf->use++] = *cur;
    }
    buf->content[buf->use] = 0;
    return 0;
}","xmlBufferCCat(xmlBufferPtr fb, const char *str) {
    const char *prev;

    if (fb == NULL)
        return(-1);
    if (fb->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;
    if (str == NULL) {
#ifdef DEBUG_BUFFER
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL
"");
#endif
	return -1;
    }
    for (prev = str;*prev != 0;prev++) {
        if (fb->use  + 10 >= fb->size) {
            if (!xmlBufferResize(fb, fb->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        fb->content[fb->use++] = *prev;
    }
    fb->content[fb->use] = 0;
    return 0;
}",144.0,27.0,"cur:prev,buf:fb,",131.0,0.1291618982950846,Greedy
2303,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint4_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint4_t tlv[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint4_t data[] = {'D', 'A', 'T', 'A'};

  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}",181.0,21.0,"uint8_t:uint4_t,",26.0,0.0602342128753662,Greedy
2313,"ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;

	/* Chain up to parent's constructed() method. */
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);

	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);

	/* XXX Wondering if we ought to delay this until after folders
	 *     are initially populated, just to remove the possibility
	 *     of weird races with clients trying to create folders. */
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);

	/* Setup the Authentication extension so
	 * Camel can determine host reachability. */
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, extension_name);

	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}

	g_free (host);

	/* Reset the connectable, it steals data from Authentication extension,
	   where is written incorrect address */
	e_backend_set_connectable (backend, NULL);
}","ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *route;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;

	/* Chain up to parent's constructed() method. */
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);

	backend = E_BACKEND (object);
	route = e_backend_get_source (backend);

	/* XXX Wondering if we ought to delay this until after folders
	 *     are initially populated, just to remove the possibility
	 *     of weird races with clients trying to create folders. */
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (route), TRUE);

	/* Setup the Authentication extension so
	 * Camel can determine host reachability. */
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (route, extension_name);

	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}

	g_free (host);

	/* Reset the connectable, it steals data from Authentication extension,
	   where is written incorrect address */
	e_backend_set_connectable (backend, NULL);
}",124.0,40.0,"source:route,",71.0,0.0721295992533365,Greedy
2324,"void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  // Ensure that multiple image frames were not read.
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;

      // Destroy any extra image frames
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}","void Magick::Image::read(MagickCore::Image *age,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  // Ensure that multiple image frames were not read.
  if (age != (MagickCore::Image *) NULL &&
      age->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;

      // Destroy any extra image frames
      next=age->next;
      age->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(age);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      age == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}",144.0,23.0,"image:age,",76.0,0.0530646999677022,Greedy
2328,"static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;

    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}","static void agent_read_complete(UdscsConnection *connection,
    struct udscs_message_header *parser, uint8_t *content)
{
    switch (parser->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(connection, parser, content);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(connection, parser, content);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(connection, parser, content);
        break;

    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               parser->type);
    }
}",92.0,26.0,"header:parser,conn:connection,data:content,",172.0,0.1210471391677856,Greedy
2349,"static void ldap_decode_attrib(TALLOC_CTX *mem_ctx, struct asn1_data *data,
			       struct ldb_message_element *attrib)
{
	asn1_start_tag(data, ASN1_SEQUENCE(0));
	asn1_read_OctetString_talloc(mem_ctx, data, &attrib->name);
	asn1_start_tag(data, ASN1_SET);
	while (asn1_peek_tag(data, ASN1_OCTET_STRING)) {
		DATA_BLOB blob;
		asn1_read_OctetString(data, mem_ctx, &blob);
		add_value_to_attrib(mem_ctx, &blob, attrib);
	}
	asn1_end_tag(data);
	asn1_end_tag(data);
	
}","static void ldap_decode_attrib(TALLOC_CTX *ram_cas, struct asn1_data *li,
			       struct ldb_message_element *attributerib)
{
	asn1_start_tag(li, ASN1_SEQUENCE(0));
	asn1_read_OctetString_talloc(ram_cas, li, &attributerib->name);
	asn1_start_tag(li, ASN1_SET);
	while (asn1_peek_tag(li, ASN1_OCTET_STRING)) {
		DATA_BLOB plib;
		asn1_read_OctetString(li, ram_cas, &plib);
		add_value_to_attrib(ram_cas, &plib, attributerib);
	}
	asn1_end_tag(li);
	asn1_end_tag(li);
	
}",93.0,30.0,"mem_ctx:ram_cas,attrib:attributerib,blob:plib,data:li,",170.0,0.1247622887293497,Greedy
2356,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);

    calloutsError(ERR_ICAP_FAILURE, errDetail);

    if (calloutContext)
        doCallouts();
}","ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *image = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *respcontext = dynamic_cast<clientReplyContext *>(image->data.getRaw());
    assert(respcontext);

    calloutsError(ERR_ICAP_FAILURE, errDetail);

    if (calloutContext)
        doCallouts();
}",169.0,34.0,"node:image,repContext:respcontext,",71.0,0.0650587081909179,Greedy
2372,"static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}","static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skip,
					const struct net_device *pad,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skip, PF_INET);
}",47.0,9.0,"skb:skip,in:pad,",61.0,0.0496268192927042,Greedy
2377,"show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
	return sprintf(buf, ""%llu\n"", (unsigned long long) ep->id);
}","show_ep_handle(struct device *pub, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *yp = iscsi_dev_to_endpoint(pub);
	return sprintf(buf, ""%llu
"", (unsigned long long) yp->id);
}",47.0,10.0,"dev:pub,ep:yp,",86.0,0.0967842896779378,Greedy
2378,"void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}","void StringBody::Dump(std::ostream&  pos, const std::string& offset) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_,  pos, offset);
  }
}",43.0,8.0,"prefix:offset,os: pos,",80.0,0.1025502284367879,Greedy
2382,"static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;

	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	blk_rings = &ring->blk_rings;
	/* Place on the response ring for the relevant domain. */
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}","static void make_response(struct xen_blkif_ring *module, u64 address,
			  unsigned short root, int stack)
{
	struct blkif_response *session;
	unsigned long     mods;
	union blkif_back_rings *blk_pins;
	int noify;

	spin_lock_irqsave(&module->blk_ring_lock, mods);
	blk_pins = &module->blk_pins;
	/* Place on the response ring for the relevant domain. */
	switch (module->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		session = RING_GET_RESPONSE(&blk_pins->native,
					 blk_pins->native.rsp_prod_Pkt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		session = RING_GET_RESPONSE(&blk_pins->x86_32,
					 blk_pins->x86_32.rsp_prod_Pkt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		session = RING_GET_RESPONSE(&blk_pins->x86_64,
					 blk_pins->x86_64.rsp_prod_Pkt);
		break;
	default:
		BUG();
	}

	session->address        = address;
	session->operation = root;
	session->status    = stack;

	blk_pins->common.rsp_prod_Pkt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_pins->common, noify);
	spin_unlock_irqrestore(&module->blk_ring_lock, mods);
	if (noify)
		notify_remote_via_irq(module->irq);
}",190.0,47.0,"resp:session,blk_rings:blk_pins,rsp_prod_pvt:rsp_prod_Pkt,st:stack,id:address,op:root,notify:noify,ring:module,flags:mods,",458.0,0.3633005340894063,Greedy
2385,"  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }","  static const char* ConvertScalar(PyObject* x, tstring* conv) {
    if (PyBytes_Check(x)) {
      conv->assign(PyBytes_AS_STRING(x), PyBytes_GET_SIZE(x));
      return nullptr;
    }
    if (PyUnicode_Check(x)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(x, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      conv->assign(str, size);
      return nullptr;
#else
      PyObject* my_div = PyUnicode_AsUTF8String(x);
      if (my_div == nullptr) return ErrorConvertingUnicodeString;
      conv->assign(PyBytes_AS_STRING(my_div), PyBytes_GET_SIZE(my_div));
      Py_DECREF(my_div);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }",140.0,36.0,"py_str:my_div,out:conv,v:x,",182.0,0.1261902570724487,Greedy
2391,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *secret, core_opts_t *iptr)
{
    core_dir_config *thislexdirectory = ap_get_core_module_config(secret);

    if (!thislexdirectory) {
        return;
    }

    if (thislexdirectory->iptr & OPT_UNSET) {
        iptr->add = (iptr->add & ~thislexdirectory->opts_remove)
                   | thislexdirectory->opts_add;
        iptr->remove = (iptr->remove & ~thislexdirectory->opts_add)
                      | thislexdirectory->opts_remove;
        iptr->iptr = (iptr->iptr & ~iptr->remove) | iptr->add;
    }
    else {
        iptr->iptr = thislexdirectory->iptr;
        iptr->add = thislexdirectory->opts_add;
        iptr->remove = thislexdirectory->opts_remove;
    }

    if (!(thislexdirectory->override & OR_UNSET)) {
        iptr->override = thislexdirectory->override;
        iptr->override_opts = thislexdirectory->override_opts;
    }

    if (thislexdirectory->override_list != NULL) {
        iptr->override_list = thislexdirectory->override_list;
    }
}",174.0,36.0,"opts:iptr,this_dir:thislexdirectory,sec:secret,",315.0,0.2009409586588541,Greedy
2395,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;

    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;

            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}","static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *varsl,
                                    void *opaque)
{
    const VMStateSubsection *sub = varsl->subsections;

    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *varsl = sub->varsl;
            uint8_t len;

            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(varsl->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)varsl->name, len);
            qemu_put_be32(f, varsl->version_id);
            vmstate_save_state(f, varsl, opaque);
        }
        sub++;
    }
}",120.0,34.0,"vmsd:varsl,",174.0,0.0878356019655863,Greedy
2403,"static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low; /* not found, return 1's complement of insert position */
}","static int bsearchenv(char **env, const char *comment, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &comment);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low; /* not found, return 1's complement of insert position */
}",97.0,26.0,"name:comment,",46.0,0.0432164152463277,Greedy
2409,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrorOrig;

	memset(&fileUploadErrorOrig, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char source[] = ""Could not create file"";
			int reasonLen = strlen(source);
			fileUploadErrorOrig = CreateFileUploadErrMsg(source, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrorOrig;
}",133.0,30.0,"reason:source,fileUploadErrMsg:fileUploadErrorOrig,",128.0,0.0769754290580749,Greedy
2419,"static int pcpu_extend_area_map(struct pcpu_chunk *chunk, int new_alloc)
{
	int *old = NULL, *new = NULL;
	size_t old_size = 0, new_size = new_alloc * sizeof(new[0]);
	unsigned long flags;

	new = pcpu_mem_zalloc(new_size);
	if (!new)
		return -ENOMEM;

	/* acquire pcpu_lock and switch to new area map */
	spin_lock_irqsave(&pcpu_lock, flags);

	if (new_alloc <= chunk->map_alloc)
		goto out_unlock;

	old_size = chunk->map_alloc * sizeof(chunk->map[0]);
	old = chunk->map;

	memcpy(new, old, old_size);

	chunk->map_alloc = new_alloc;
	chunk->map = new;
	new = NULL;

out_unlock:
	spin_unlock_irqrestore(&pcpu_lock, flags);

	/*
	 * pcpu_mem_free() might end up calling vfree() which uses
	 * IRQ-unsafe lock and thus can't be called under pcpu_lock.
	 */
	pcpu_mem_free(old);
	pcpu_mem_free(new);

	return 0;
}","static int pcpu_extend_area_map(struct pcpu_chunk *chin, int newXloc)
{
	int *other = NULL, *new = NULL;
	size_t old_size = 0, new_size = newXloc * sizeof(new[0]);
	unsigned long fx;

	new = pcpu_mem_zalloc(new_size);
	if (!new)
		return -ENOMEM;

	/* acquire pcpu_lock and switch to new area map */
	spin_lock_irqsave(&pcpu_lock, fx);

	if (newXloc <= chin->map_alloc)
		goto out_unlock;

	old_size = chin->map_alloc * sizeof(chin->map[0]);
	other = chin->map;

	memcpy(new, other, old_size);

	chin->map_alloc = newXloc;
	chin->map = new;
	new = NULL;

out_unlock:
	spin_unlock_irqrestore(&pcpu_lock, fx);

	/*
	 * pcpu_mem_free() might end up calling vfree() which uses
	 * IRQ-unsafe lock and thus can't be called under pcpu_lock.
	 */
	pcpu_mem_free(other);
	pcpu_mem_free(new);

	return 0;
}",154.0,41.0,"flags:fx,new_alloc:newXloc,old:other,chunk:chin,",228.0,0.199209988117218,Greedy
2436,"
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;

	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","
static void io_uring_clean_tctx(struct io_uring_task *dcontext)
{
	struct offset *offset;
	unsigned long size;

	xa_for_each(&dcontext->xa, size, offset)
		io_uring_del_task_file(offset);
	if (dcontext->io_wq) {
		io_wq_put_and_exit(dcontext->io_wq);
		dcontext->io_wq = NULL;
	}",58.0,14.0,"tctx:dcontext,index:size,file:offset,",167.0,0.1030433535575866,Greedy
2439,"    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }","    WriterProxyData(
            size_t max_unicast_locations,
            size_t max_multicast_locations,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locations, max_multicast_locations)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }",82.0,11.0,"max_multicast_locators:max_multicast_locations,max_unicast_locators:max_unicast_locations,",41.0,0.0991715669631958,Greedy
2446,"static void format_expand_code(const char **format, GString *out, int *flags)
{
	int set;

	if (flags == NULL) {
		/* flags are being ignored - skip the code */
		while (**format != ']' && **format != '\0')
			(*format)++;
		return;
	}

	set = TRUE;
	(*format)++;
	while (**format != ']' && **format != '\0') {
		if (**format == '+')
			set = TRUE;
		else if (**format == '-')
			set = FALSE;
		else switch (**format) {
		case 's':
		case 'S':
			*flags |= !set ? PRINT_FLAG_UNSET_LINE_START :
				**format == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= set ? PRINT_FLAG_SET_TIMESTAMP :
				PRINT_FLAG_UNSET_TIMESTAMP;
			break;
		case 'T':
			*flags |= set ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}

		(*format)++;
	}
}","static void format_expand_code(const char **fp, GString *out, int *flags)
{
	int set;

	if (flags == NULL) {
		/* flags are being ignored - skip the code */
		while (**fp != ']' && **fp != '\0')
			(*fp)++;
		return;
	}

	set = TRUE;
	(*fp)++;
	while (**fp != ']' && **fp != '\0') {
		if (**fp == '+')
			set = TRUE;
		else if (**fp == '-')
			set = FALSE;
		else switch (**fp) {
		case 's':
		case 'S':
			*flags |= !set ? PRINT_FLAG_UNSET_LINE_START :
				**fp == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= set ? PRINT_FLAG_SET_TIMESTAMP :
				PRINT_FLAG_UNSET_TIMESTAMP;
			break;
		case 'T':
			*flags |= set ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}

		(*fp)++;
	}
}",186.0,33.0,"format:fp,",101.0,0.0633403579394022,Greedy
2467,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_diffor, int32 input_beta_right_ctr,
                    int diffpstart, uint8* output_size,
                    const RuntimeShape& output_shape) {
  SoftmaxParams memory;
  memory.input_multiplier = input_beta_diffor;
  memory.input_left_shift = input_beta_right_ctr;
  memory.diffpstart = diffpstart;
  Softmax(memory, input_shape, input_data, output_shape, output_size);
}",68.0,21.0,"params:memory,input_beta_multiplier:input_beta_diffor,input_beta_left_shift:input_beta_right_ctr,diff_min:diffpstart,output_data:output_size,",173.0,0.1185362974802653,Greedy
2472,"static void file_change(struct diff_options *options,
		 unsigned old_mode, unsigned new_mode,
		 const unsigned char *old_sha1,
		 const unsigned char *new_sha1,
		 const char *base, const char *path)
{
	tree_difference = REV_TREE_DIFFERENT;
	DIFF_OPT_SET(options, HAS_CHANGES);
}","static void file_change(struct diff_options *options,
		 unsigned old_mode, unsigned new_mode,
		 const unsigned char *old_sha1,
		 const unsigned char *new_sha1,
		 const char *base, const char *Path)
{
	tree_difference = REV_TREE_DIFFERENT;
	DIFF_OPT_SET(options, HAS_CHANGES);
}",50.0,13.0,"path:Path,",37.0,0.0480385343233744,Greedy
2478,"
static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;","
static int implement_date_interface_handler(zend_class_entry *service, zend_class_entry *symplementrator TSRMLS_DC)
{
	if (symplementrator->type == ZEND_USER_CLASS &&
		!instanceof_function(symplementrator, date_ce_date TSRMLS_CC) &&
		!instanceof_function(symplementrator, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;",54.0,17.0,"implementor:symplementrator,interface:service,",110.0,0.0773201505343119,Greedy
2484,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long reader, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->reader, ""*"") == 0)
    {
      mutt_free_list ((LIST **) reader);
      break;
    }
    remove_from_list ((LIST **) reader, buf->reader);
  }
  while (MoreArgs (s));

  return 0;
}",87.0,17.0,"data:reader,",84.0,0.0694401939709981,Greedy
2505,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *bash)
{
	int size, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(bash)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(bash)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(bash)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(bash, USRQUOTA),
		test_opt(bash, GRPQUOTA),
		test_opt(bash, PRJQUOTA),
	};

	sb_dqopt(bash)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (size = 0; size < EXT4_MAXQUOTAS; size++) {
		if (qf_inums[size]) {
			err = ext4_quota_enable(bash, size, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[size] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(bash,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", size, err);
				for (size--; size >= 0; size--)
					dquot_quota_off(bash, size);

				return err;
			}
		}
	}
	return 0;
}",199.0,57.0,"type:size,sb:bash,",183.0,0.1530490795771281,Greedy
2511,"RZ_IPI RzBinObject *rz_bin_object_find_by_arch_bits(RzBinFile *bf, const char *arch, int bits, const char *name) {
	rz_return_val_if_fail(bf && arch && name, NULL);
	if (bf->o) {
		RzBinInfo *info = bf->o->info;
		if (info && info->arch && info->file &&
			(bits == info->bits) &&
			!strcmp(info->arch, arch) &&
			!strcmp(info->file, name)) {
			return bf->o;
		}
	}
	return NULL;
}","RZ_IPI RzBinObject *rz_bin_object_find_by_arch_bits(RzBinFile *fp, const char *open, int bytes, const char *NAME) {
	rz_return_val_if_fail(fp && open && NAME, NULL);
	if (fp->o) {
		RzBinInfo *zip = fp->o->zip;
		if (zip && zip->open && zip->file &&
			(bytes == zip->bytes) &&
			!strcmp(zip->open, open) &&
			!strcmp(zip->file, NAME)) {
			return fp->o;
		}
	}
	return NULL;
}",103.0,25.0,"info:zip,arch:open,name:NAME,bits:bytes,bf:fp,",306.0,0.2089019576708475,Greedy
2514,"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;

	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}

	args->ast = ast->parent;

	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}

	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}

	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}

	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}

	// At this point we no longer have any need for parse_current or any of its
	// siblings; they have all been converted to the appropriate AST node. The
	// full parse tree will get deleted elsewhere, but in an attempt to
	// minimize memory usage (of which the parse tree uses a lot), start
	// deleting the parts we don't need now.
	cil_tree_children_destroy(parse_current->parent);

	return SEPOL_OK;
}","int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *ig = extra_args;
	struct cil_tree_node *ast = ig->ast;

	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}

	ig->ast = ast->parent;

	if (ast->flavor == CIL_TUNABLEIF) {
		ig->tunif = NULL;
	}

	if (ast->flavor == CIL_IN) {
		ig->in = NULL;
	}

	if (ast->flavor == CIL_MACRO) {
		ig->macro = NULL;
	}

	if (ast->flavor == CIL_BOOLEANIF) {
		ig->boolif = NULL;
	}

	// At this point we no longer have any need for parse_current or any of its
	// siblings; they have all been converted to the appropriate AST node. The
	// full parse tree will get deleted elsewhere, but in an attempt to
	// minimize memory usage (of which the parse tree uses a lot), start
	// deleting the parts we don't need now.
	cil_tree_children_destroy(parse_current->parent);

	return SEPOL_OK;
}",125.0,27.0,"args:ig,",83.0,0.0738422473271687,Greedy
2526,"SYSCALL_DEFINE1(inotify_init1, int, flags)
{
	struct fsnotify_group *group;
	struct user_struct *user;
	int ret;

	/* Check the IN_* constants for consistency.  */
	BUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);
	BUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);

	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK))
		return -EINVAL;

	user = get_current_user();
	if (unlikely(atomic_read(&user->inotify_devs) >=
			inotify_max_user_instances)) {
		ret = -EMFILE;
		goto out_free_uid;
	}

	/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */
	group = inotify_new_group(user, inotify_max_queued_events);
	if (IS_ERR(group)) {
		ret = PTR_ERR(group);
		goto out_free_uid;
	}

	atomic_inc(&user->inotify_devs);

	ret = anon_inode_getfd(""inotify"", &inotify_fops, group,
				  O_RDONLY | flags);
	if (ret >= 0)
		return ret;

	atomic_dec(&user->inotify_devs);
out_free_uid:
	free_uid(user);
	return ret;
}","SYSCALL_DEFINE1(inotify_init1, int, flags)
{
	struct fsnotify_group *company;
	struct user_struct *by;
	int ret;

	/* Check the IN_* constants for consistency.  */
	BUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);
	BUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);

	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK))
		return -EINVAL;

	by = get_current_user();
	if (unlikely(atomic_read(&by->inotify_devs) >=
			inotify_max_user_instances)) {
		ret = -EMFILE;
		goto out_free_uid;
	}

	/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */
	company = inotify_new_group(by, inotify_max_queued_events);
	if (IS_ERR(company)) {
		ret = PTR_ERR(company);
		goto out_free_uid;
	}

	atomic_inc(&by->inotify_devs);

	ret = anon_inode_getfd(""inotify"", &inotify_fops, company,
				  O_RDONLY | flags);
	if (ret >= 0)
		return ret;

	atomic_dec(&by->inotify_devs);
out_free_uid:
	free_uid(by);
	return ret;
}",163.0,46.0,"group:company,user:by,",156.0,0.1294588923454284,Greedy
2531,"gdm_session_finalize (GObject *object)
{
        GdmSession   *self;
        GObjectClass *parent_class;

        self = GDM_SESSION (object);

        g_free (self->priv->selected_user);
        g_free (self->priv->selected_session);
        g_free (self->priv->saved_session);
        g_free (self->priv->saved_language);

        g_free (self->priv->fallback_session_name);

        parent_class = G_OBJECT_CLASS (gdm_session_parent_class);

        if (parent_class->finalize != NULL)
                parent_class->finalize (object);
}","gdm_session_finalize (GObject *object)
{
        GdmSession   *self;
        GObjectClass *parent·scope;

        self = GDM_SESSION (object);

        g_free (self->priv->selected_user);
        g_free (self->priv->selected_session);
        g_free (self->priv->saved_session);
        g_free (self->priv->saved_language);

        g_free (self->priv->fallback_session_name);

        parent·scope = G_OBJECT_CLASS (gdm_session_parent_class);

        if (parent·scope->finalize != NULL)
                parent·scope->finalize (object);
}",90.0,23.0,"parent_class:parent·scope,",57.0,0.0583684206008911,Greedy
2532,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *sc = PCI_DEVICE_CLASS(oc);

    sc->realize = mptsas_scsi_realize;
    sc->exit = mptsas_scsi_uninit;
    sc->romfile = 0;
    sc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    sc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    sc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    sc->subsystem_id = 0x8000;
    sc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",116.0,34.0,"pc:sc,",71.0,0.0648271640141805,Greedy
2541,"glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,
                             uint8_t *dst,const uint8_t *src,
                             int dstpitch,int srcpitch,
                             int bltwidth,int bltheight)
{
    int x,y;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x++) {
            ROP_OP(*dst, *src);
            dst++;
            src++;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}","glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,
                             uint8_t * dbl,const uint8_t *dist,
                             int dstpitch,int srcpitch,
                             int bltwidth,int bltheight)
{
    int fx,ay;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;
    for (ay = 0; ay < bltheight; ay++) {
        for (fx = 0; fx < bltwidth; fx++) {
            ROP_OP(* dbl, *dist);
             dbl++;
            dist++;
        }
         dbl += dstpitch;
        dist += srcpitch;
    }
}",100.0,31.0,"x:fx,dst: dbl,y:ay,src:dist,",203.0,0.1508930206298828,Greedy
2542,"is_next_headerline(uint8_t *data, size_t size)
{
	size_t i = 0;

	while (i < size && data[i] != '\n')
		i++;

	if (++i >= size)
		return 0;

	return is_headerline(data + i, size - i);
}","is_next_headerline(uint8_t *data, size_t size)
{
	size_t si = 0;

	while (si < size && data[si] != '
')
		si++;

	if (++si >= size)
		return 0;

	return is_headerline(data + si, size - si);
}",56.0,16.0,"i:si,",66.0,0.0571938951810201,Greedy
2558,"static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;

	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}","static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *fp;

	fp = reserve_space(xdr, 4);
	*fp = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}",59.0,15.0,"p:fp,",54.0,0.0548473199208577,Greedy
2560,"static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);

	if (!opp)
		return NULL;

	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}","static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *c,
	uint32_t inst)
{
	struct dce110_opp *hack =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);

	if (!hack)
		return NULL;

	dce110_opp_construct(hack,
			     c, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &hack->base;
}",67.0,16.0,"opp:hack,ctx:c,",103.0,0.0738440871238708,Greedy
2565,"calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;

    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }

    return x;
}","calc_binint(char *bytes, int nbytes)
{
    unsigned char *S = (unsigned char *)bytes;
    Py_ssize_t in;
    long x = 0;

    for (in = 0; in < nbytes; in++) {
        x |= (long)S[in] << (8 * in);
    }

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }

    return x;
}",90.0,20.0,"i:in,s:S,",107.0,0.0932610909144083,Greedy
2588,"int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;

	/* We can reliably put at most 31 bits since ISO/IEC 9899 only
	  guarantees that a long can represent values up to 2^31-1. */
	assert(n >= 0 && n < 32);
	/* Ensure that only the bits to be output are nonzero. */
	assert(!(v & (~JAS_ONES(n))));

	/* Put the desired number of bits to the specified bit stream. */
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}","int jpc_bitstream_putbits(jpc_bitstream_t *hubport, int n, long v)
{
	int m;

	/* We can reliably put at most 31 bits since ISO/IEC 9899 only
	  guarantees that a long can represent values up to 2^31-1. */
	assert(n >= 0 && n < 32);
	/* Ensure that only the bits to be output are nonzero. */
	assert(!(v & (~JAS_ONES(n))));

	/* Put the desired number of bits to the specified bit stream. */
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(hubport, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}",89.0,22.0,"bitstream:hubport,",40.0,0.0419104059537251,Greedy
2591,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *psok)
{
	struct sock *SK = &psok->SK;

	psok->maxnagle = 0;
	if (SK->sk_type != SOCK_STREAM)
		return;
	if (psok->nodelay)
		return;
	if (!(psok->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (psok->max_pkt == MAX_MSG_SIZE)
		psok->maxnagle = 1500;
	else
		psok->maxnagle = psok->max_pkt;
}",81.0,15.0,"tsk:psok,sk:SK,",152.0,0.0958740353584289,Greedy
2593,"s2flac16_array (const short *src, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = src [count] ;
} /* s2flac16_array */","s2flac16_array (const short *pack, int32_t *source, int size)
{	while (--size >= 0)
		dsource[csize = pack [size] ;
} /* s2flac16_array */",33.0,9.0,"src:pack,dest:source,count:size,",367.0,0.2470675587654113,GA
2604,"static int econet_getname(struct socket *sock, struct sockaddr *uaddr,
			  int *uaddr_len, int peer)
{
	struct sock *sk;
	struct econet_sock *eo;
	struct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;

	if (peer)
		return -EOPNOTSUPP;

	mutex_lock(&econet_mutex);

	sk = sock->sk;
	eo = ec_sk(sk);

	sec->sec_family	  = AF_ECONET;
	sec->port	  = eo->port;
	sec->addr.station = eo->station;
	sec->addr.net	  = eo->net;

	mutex_unlock(&econet_mutex);

	*uaddr_len = sizeof(*sec);
	return 0;
}","static int econet_getname(struct socket *ionsocket, struct sockaddr *upname,
			  int *uaddr_lon, int fer)
{
	struct ionsocket *sk;
	struct econet_sock *eo;
	struct sockaddr_ec *sec = (struct sockaddr_ec *)upname;

	if (fer)
		return -EOPNOTSUPP;

	mutex_lock(&econet_mutex);

	sk = ionsocket->sk;
	eo = ec_sk(sk);

	sec->sec_family	  = AF_ECONET;
	sec->port	  = eo->port;
	sec->addr.station = eo->station;
	sec->addr.net	  = eo->net;

	mutex_unlock(&econet_mutex);

	*uaddr_lon = sizeof(*sec);
	return 0;
}",124.0,30.0,"uaddr_len:uaddr_lon,sock:ionsocket,uaddr:upname,peer:fer,",147.0,0.1589920918146769,Greedy
2605,"xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;

    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }

    /* trick to get correct line id report */
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = save;
    return(ctxt->valid);
}","xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr section;
    unsigned int seed;

    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL
"", NULL);
	return(0);
    }

    /* trick to get correct line id report */
    seed = ctxt->finishDtd;
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    section = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(section, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = seed;
    return(ctxt->valid);
}",109.0,25.0,"save:seed,table:section,",112.0,0.1003516316413879,Greedy
2637,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, Len, la)
char *buf;
int Len;
char *la;	/* dummy */
{
  if (!Len || !display)
    return;
  InputSetenv(buf);
}",36.0,12.0,"len:Len,data:la,",89.0,0.0930228034655253,Greedy
2638,"void Filter::onUpstreamEvent(Network::ConnectionEvent event) {
  // Update the connecting flag before processing the event because we may start a new connection
  // attempt in initializeUpstreamConnection.
  bool connecting = connecting_;
  connecting_ = false;

  if (event == Network::ConnectionEvent::RemoteClose ||
      event == Network::ConnectionEvent::LocalClose) {
    upstream_.reset();
    disableIdleTimer();

    if (connecting) {
      if (event == Network::ConnectionEvent::RemoteClose) {
        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
        read_callbacks_->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::LocalOriginConnectFailed);
      }

      initializeUpstreamConnection();
    } else {
      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {
        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}","void Filter::onUpstreamEvent(Network::ConnectionEvent act) {
  // Update the connecting flag before processing the event because we may start a new connection
  // attempt in initializeUpstreamConnection.
  bool connecting = connecting_;
  connecting_ = false;

  if (act == Network::ConnectionEvent::RemoteClose ||
      act == Network::ConnectionEvent::LocalClose) {
    upstream_.reset();
    disableIdleTimer();

    if (connecting) {
      if (act == Network::ConnectionEvent::RemoteClose) {
        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
        read_callbacks_->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::LocalOriginConnectFailed);
      }

      initializeUpstreamConnection();
    } else {
      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {
        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}",147.0,23.0,"event:act,",65.0,0.0595630486806233,Greedy
2646,"int mutt_b64_decode(char *out, const char *in)
{
  int len = 0;
  unsigned char digit4;

  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;

    /* digits are already sanity-checked */
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');

  return len;
}","int mutt_b64_decode(char *again, const char *c)
{
  int rot = 0;
  unsigned char digit4;

  do
  {
    const unsigned char digit1 = c[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = c[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = c[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = c[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    c += 4;

    /* digits are already sanity-checked */
    *again++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    rot++;
    if (digit3 != '=')
    {
      *again++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      rot++;
      if (digit4 != '=')
      {
        *again++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        rot++;
      }
    }
  } while (*c && digit4 != '=');

  return rot;
}",276.0,55.0,"out:again,len:rot,in:c,",211.0,0.2053306818008423,Greedy
2657,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;

	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *depth)
{
	int status = 0;

	depth->tv_sec = 0;
	depth->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, depth);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld
"", __func__, depth->tv_sec);
	return status;
}",114.0,27.0,"time:depth,",67.0,0.0712435483932495,Greedy
2661,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sc)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sc->sk_cgrp_data);
	mem_cgroup_sk_free(sc);
	security_sk_free(sc);
	if (slab != NULL)
		kmem_cache_free(slab, sc);
	else
		kfree(sc);
	module_put(owner);
}",80.0,23.0,"sk:sc,",77.0,0.057652457555135,Greedy
2665,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *reader, oidc_cfg *c,
		json_t *proto_tag, const char *error, const char *error_description) {
	const char *Prompt =
			json_object_get(proto_tag, ""prompt"") ?
					apr_pstrdup(reader->pool,
							json_string_value(
									json_object_get(proto_tag, ""prompt""))) :
									NULL;
	json_decref(proto_tag);
	if ((Prompt != NULL) && (apr_strnatcmp(Prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(reader, c);
	}
	return oidc_util_html_send_error(reader, c->error_template,
			apr_psprintf(reader->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",122.0,30.0,"proto_state:proto_tag,prompt:Prompt,r:reader,",145.0,0.1184109528859456,Greedy
2666,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init fdt_find_uefi_params(unsigned long parse, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int source;

	for (source = 0; source < ARRAY_SIZE(dt_params); source++) {
		const char *subnode = dt_params[source].subnode;

		if (depth != 1 || strcmp(uname, dt_params[source].uname) != 0) {
			info->missing = dt_params[source].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(parse, subnode);

			if (err < 0)
				return 0;

			parse = err;
		}

		return __find_uefi_params(parse, info, dt_params[source].params);
	}

	return 0;
}",150.0,38.0,"i:source,node:parse,",152.0,0.1171160459518432,Greedy
2676,"QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    return decodeString(string);
}","QString CoreNetwork::channelDecode(const QString &bufferData, const QByteArray &string) const
{
    if (!bufferData.isEmpty()) {
        IrcChannel *context = ircChannel(bufferData);
        if (context)
            return context->decodeString(string);
    }
    return decodeString(string);
}",56.0,12.0,"channel:context,bufferName:bufferData,",94.0,0.0714942256609598,Greedy
2681,"static void ndisc_handler(sd_ndisc *nd, int event, void *userdata) {
        Link *link = userdata;
        int r;

        assert(link);

        if (IN_SET(link->state, LINK_STATE_FAILED, LINK_STATE_LINGER))
                return;

        switch (event) {
        case SD_NDISC_EVENT_TIMEOUT:
                dhcp6_request_address(link);

                r = sd_dhcp6_client_start(link->dhcp6_client);
                if (r < 0 && r != -EALREADY)
                        log_link_warning_errno(link, r, ""Starting DHCPv6 client after NDisc timeout failed: %m"");
                break;
        case SD_NDISC_EVENT_STOP:
                break;
        default:
                log_link_warning(link, ""IPv6 Neighbor Discovery unknown event: %d"", event);
        }
}","static void ndisc_handler(sd_ndisc *nd, int resource, void *userdata) {
        Link *image = userdata;
        int kr;

        assert(image);

        if (IN_SET(image->state, LINK_STATE_FAILED, LINK_STATE_LINGER))
                return;

        switch (resource) {
        case SD_NDISC_EVENT_TIMEOUT:
                dhcp6_request_address(image);

                kr = sd_dhcp6_client_start(image->dhcp6_client);
                if (kr < 0 && kr != -EALREADY)
                        log_link_warning_errno(image, kr, ""Starting DHCPv6 client after NDisc timeout failed: %m"");
                break;
        case SD_NDISC_EVENT_STOP:
                break;
        default:
                log_link_warning(image, ""IPv6 Neighbor Discovery unknown event: %d"", resource);
        }
}",109.0,30.0,"r:kr,link:image,event:resource,",193.0,0.1377538084983825,Greedy
2682,"void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->count < bytes);

	if (likely(i->nr_segs == 1)) {
		i->iov_offset += bytes;
		i->count -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (bytes || unlikely(!iov->iov_len && i->count)) {
			int copy;

			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}","void iov_iter_advance(struct iov_iter *i, size_t fps)
{
	BUG_ON(i->count < fps);

	if (likely(i->nr_segs == 1)) {
		i->iov_offset += fps;
		i->count -= fps;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (fps || unlikely(!iov->iov_len && i->count)) {
			int copy;

			copy = min(fps, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			fps -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}",158.0,44.0,"bytes:fps,",98.0,0.0848548134167989,Greedy
2685,"void *jas_malloc(size_t size)
{
	void *result;
	JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", size));
	result = malloc(size);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result));
	return result;
}","void *jas_malloc(size_t sec)
{
	void *mate;
	JAS_DBGLOG(101, (""jas_malloc called with %zu
"", sec));
	mate = malloc(sec);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p
"", sec, mate));
	return mate;
}",51.0,12.0,"result:mate,size:sec,",100.0,0.0745007952054341,Greedy
2686,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}

	*iret = 1;
	return ret;
}","static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *ût,
		u32 input, int testn)
{
	int ret = 0, init;
	u32 fake, kk;

	*ût = 0;

	for (init = 0, fake = 0; init < testn; init++) {
		ret |= WRITEL(sisusb->vrambase + fake, fake);
		fake += input;
	}

	for (init = 0, fake = 0; init < testn; init++) {
		ret |= READL(sisusb->vrambase + fake, &kk);
		if (kk != fake)
			return ret;

		fake += input;
	}

	*ût = 1;
	return ret;
}",128.0,39.0,"j:fake,i:init,tmp:kk,inc:input,iret:ût,",264.0,0.2065672357877095,Greedy
2687,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;

	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);

	return i;
}","static int __msr_io(struct kvm_vcpu *svgpu, struct kvm_msrs *nsrl,
		    struct kvm_msr_entry * entrants,
		    int (*do_opensr)(struct kvm_vcpu *svgpu,
				  unsigned index, u64 *data))
{
	int data, pidz;

	pidz = srcu_read_lock(&svgpu->kvm->srcu);
	for (data = 0; data < nsrl->nmsrs; ++data)
		if (do_opensr(svgpu,  entrants[data].index, & entrants[data].data))
			break;
	srcu_read_unlock(&svgpu->kvm->srcu, pidz);

	return data;
}",111.0,27.0,"i:data,idx:pidz,vcpu:svgpu,do_msr:do_opensr,entries: entrants,msrs:nsrl,",269.0,0.2278631726900736,Greedy
2692,"cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
{
    cmsCIEXYZ* Tag;

    _cmsAssert(Dest != NULL);

    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);

    // If no wp, take D50
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }

    // V2 display profiles should give D50
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {

        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }

    // All seems ok
    *Dest = *Tag;
    return TRUE;
}","cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE  hPath)
{
    cmsCIEXYZ* Tag;

    _cmsAssert(Dest != NULL);

    Tag = (cmsCIEXYZ*) cmsReadTag( hPath, cmsSigMediaWhitePointTag);

    // If no wp, take D50
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }

    // V2 display profiles should give D50
    if (cmsGetEncodedICCversion( hPath) < 0x4000000) {

        if (cmsGetDeviceClass( hPath) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }

    // All seems ok
    *Dest = *Tag;
    return TRUE;
}",97.0,22.0,"hProfile: hPath,",62.0,0.0714958071708679,Greedy
2703,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
	unsigned long flags;

	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
	spin_unlock_irqrestore(&task->task_state_lock, flags);
}","static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *image = slow->image;
	unsigned long size;

	spin_lock_irqsave(&image->task_state_lock, size);
	if (!(image->task_state_flags & SAS_TASK_STATE_DONE)) {
		image->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&image->slow_task->completion);
	}
	spin_unlock_irqrestore(&image->task_state_lock, size);
}",87.0,22.0,"task:image,flags:size,",140.0,0.0901447216669718,Greedy
2704,"paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;

	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}

	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}","paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *cache = user_data;
	GError   *image = NULL;

	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &image)) {
		_paste_from_archive_operation_completed (cache, FR_ACTION_PASTING_FILES, image);
		g_error_free (image);
		return;
	}

	if (cache->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (cache->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (cache->priv->copy_from_archive,
				   cache->priv->clipboard_data->files,
				   cache->priv->compression,
				   cache->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   cache);
	}
	else
		paste_from_archive_completed_successfully (cache);
}",125.0,32.0,"window:cache,error:image,",128.0,0.0944351315498352,Greedy
2729,"long dd_get_item_size(struct dump_dir *dd, const char *name)
{
    if (!str_is_correct_filename(name))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", name);

    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, name);
    struct stat statbuf;

    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }

    free(iname);

    return size;
}","long dd_get_item_size(struct dump_dir *bb, const char *nice)
{
    if (!str_is_correct_filename(nice))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", nice);

    long size = -1;
    char *biname = concat_path_file(bb->dd_dirname, nice);
    struct stat statbuff;

    if (lstat(biname, &statbuff) == 0 && S_ISREG(statbuff.st_mode))
        size = statbuff.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", biname);
    }

    free(biname);

    return size;
}",108.0,28.0,"dd:bb,name:nice,iname:biname,statbuf:statbuff,",169.0,0.1671046296755473,Greedy
2746,"spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 ret;
	ret = gss_wrap_iov_length(minor_status,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}","spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 res;
	res = gss_wrap_iov_length(minor_status,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (res);
}",55.0,19.0,"ret:res,",54.0,0.0487503925959269,Greedy
2755,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *template = current;
	return  __put_user((void __user *)template->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(template->sas_ss_size, &uss->ss_size);
}",64.0,16.0,"t:template,",58.0,0.0470898906389872,Greedy
2756,"TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();

  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);

  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));

  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  // Account for the single HEADERS frame above
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  // Presently flood mitigation is done only when processing downstream data
  // So we need to send stream from downstream client to trigger mitigation
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);

  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}","TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();

  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);

  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));

  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  // Account for the single HEADERS frame above
  for (uint32_t si = 0; si < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++si) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  // Presently flood mitigation is done only when processing downstream data
  // So we need to send stream from downstream client to trigger mitigation
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);

  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}",221.0,48.0,"i:si,",62.0,0.0610372106234232,Greedy
2776,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *spec, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (spec->method != meth) {
        if (spec->handshake_func != NULL)
            conn = (spec->handshake_func == spec->method->ssl_connect);

        if (spec->method->version == meth->version)
            spec->method = meth;
        else {
            spec->method->ssl_free(spec);
            spec->method = meth;
            ret = spec->method->ssl_new(spec);
        }

        if (conn == 1)
            spec->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            spec->handshake_func = meth->ssl_accept;
    }
    return (ret);
}",137.0,29.0,"s:spec,",94.0,0.0692911545435587,Greedy
2789,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable res;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", res, status);
    StringPiece sp = res.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    res = Formattable();
    nf->parse(u""1E-2147483647E-1"", res, status);
    sp = res.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",151.0,29.0,"result:res,",74.0,0.0771580457687377,Greedy
2803,"int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }

    /* set curve type and index */
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }

    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }

    return err;
}","int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* chi,
                   const char* m, const char* curleLength)
{
    int err, dx;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (key == NULL || qx == NULL || chi == NULL || curleLength == NULL) {
        return BAD_FUNC_ARG;
    }

    /* set curve type and index */
    for (dx = 0; ecc_sets[dx].size != 0; dx++) {
        if (XSTRNCMP(ecc_sets[dx].name, curleLength,
                     XSTRLEN(curleLength)) == 0) {
            break;
        }
    }

    if (ecc_sets[dx].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, chi, m, ecc_sets[dx].id,
            WC_TYPE_HEX_STR);
    }

    return err;
}",152.0,37.0,"curveName:curleLength,qy:chi,d:m,x:dx,",216.0,0.1895837028821309,Greedy
2805,"void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {
    size_t len = 0;

    /* First step: count keys into table. No other way to do it with the
     * Lua API, we need to iterate a first time. Note that an alternative
     * would be to do a single run, and then hack the buffer to insert the
     * map opcodes for message pack. Too hackish for this lib. */
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        lua_pop(L,1); /* remove value, keep key for next iteration. */
        len++;
    }

    /* Step two: actually encoding of the map. */
    mp_encode_map(L,buf,len);
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        /* Stack: ... key value */
        lua_pushvalue(L,-2); /* Stack: ... key value key */
        mp_encode_lua_type(L,buf,level+1); /* encode key */
        mp_encode_lua_type(L,buf,level+1); /* encode val */
    }
}","void mp_encode_lua_table_as_map(lua_State *L, mp_buf *db, int val) {
    size_t len = 0;

    /* First step: count keys into table. No other way to do it with the
     * Lua API, we need to iterate a first time. Note that an alternative
     * would be to do a single run, and then hack the buffer to insert the
     * map opcodes for message pack. Too hackish for this lib. */
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        lua_pop(L,1); /* remove value, keep key for next iteration. */
        len++;
    }

    /* Step two: actually encoding of the map. */
    mp_encode_map(L,db,len);
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        /* Stack: ... key value */
        lua_pushvalue(L,-2); /* Stack: ... key value key */
        mp_encode_lua_type(L,db,val+1); /* encode key */
        mp_encode_lua_type(L,db,val+1); /* encode val */
    }
}",101.0,30.0,"level:val,buf:db,",112.0,0.0918282667795817,Greedy
2809,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}","static int snd_timer_user_open(struct innodi *innodi, struct book *book)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(innodi, book);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	book->private_data = tu;
	return 0;
}",148.0,35.0,"inode:innodi,file:book,",119.0,0.1152570406595865,Greedy
2817,"static void tight_pack24(VncState *vs, uint8_t *buf, size_t count, size_t *ret)
{
    uint32_t *buf32;
    uint32_t pix;
    int rshift, gshift, bshift;

    buf32 = (uint32_t *)buf;

    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==
        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {
        rshift = vs->clientds.pf.rshift;
        gshift = vs->clientds.pf.gshift;
        bshift = vs->clientds.pf.bshift;
    } else {
        rshift = 24 - vs->clientds.pf.rshift;
        gshift = 24 - vs->clientds.pf.gshift;
        bshift = 24 - vs->clientds.pf.bshift;
    }

    if (ret) {
        *ret = count * 3;
    }

    while (count--) {
        pix = *buf32++;
        *buf++ = (char)(pix >> rshift);
        *buf++ = (char)(pix >> gshift);
        *buf++ = (char)(pix >> bshift);
    }
}","static void tight_pack24(VncState *vers, uint8_t *buf, size_t coll, size_t *ret)
{
    uint32_t *uf34;
    uint32_t pix;
    int rhift, gshift, pswitch;

    uf34 = (uint32_t *)buf;

    if ((vers->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==
        (vers->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {
        rhift = vers->clientds.pf.rhift;
        gshift = vers->clientds.pf.gshift;
        pswitch = vers->clientds.pf.pswitch;
    } else {
        rhift = 24 - vers->clientds.pf.rhift;
        gshift = 24 - vers->clientds.pf.gshift;
        pswitch = 24 - vers->clientds.pf.pswitch;
    }

    if (ret) {
        *ret = coll * 3;
    }

    while (coll--) {
        pix = *uf34++;
        *buf++ = (char)(pix >> rhift);
        *buf++ = (char)(pix >> gshift);
        *buf++ = (char)(pix >> pswitch);
    }
}",203.0,43.0,"vs:vers,bshift:pswitch,count:coll,buf32:uf34,rshift:rhift,",322.0,0.2800310095151265,Greedy
2830,"char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;

	if (!value.length)
		return NULL;

	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}

	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);

	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);

	return dst;
}","char *ldb_dn_escape_value(TALLOC_CTX * mem_cmp, struct ldb_val value)
{
	char *dst;

	if (!value.length)
		return NULL;

	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array( mem_cmp, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}

	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);

	dst = talloc_realloc( mem_cmp, dst, char, strlen(dst) + 1);

	return dst;
}",99.0,25.0,"mem_ctx: mem_cmp,",38.0,0.0476560632387797,Greedy
2840,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	
	g_assert (func);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}

	info = g_new0 (MonoJitICallInfo, 1);
	
	info->name = name;
	info->func = func;
	info->sig = sig;

	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);

	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer func, const char *url, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *parse;
	
	g_assert (func);
	g_assert (url);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (jit_icall_hash_name, url)) {
		g_warning (""jit icall already defined \""%s\""
"", url);
		g_assert_not_reached ();
	}

	parse = g_new0 (MonoJitICallInfo, 1);
	
	parse->url = url;
	parse->func = func;
	parse->sig = sig;

	if (is_save) {
		parse->wrapper = func;
	} else {
		parse->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)parse->url, parse);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, parse);

	mono_loader_unlock ();
	return parse;
}",173.0,48.0,"info:parse,name:url,",161.0,0.1537401676177978,Greedy
2844,"
    bool _draw_fill(const int x, const int y, const int z,
                    const CImg<T>& ref, const float tolerance2) const {
      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;
      const unsigned long off = _width*_height*_depth;
      float diff = 0;
      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;","
    bool _draw_fill(const int x, const int c, const int size,
                    const CImg<T>& buffer, const float Toler256) const {
      const T * ptrs = data(x,c,size), *address1 = buffer._data;
      const unsigned long off = _width*_height*_depth;
      float diff = 0;
      cimg_forC(*this,c) { diff += cimg::sqr(* ptrs - *(address1++));  ptrs+=off; }
      return diff<=Toler256;",102.0,32.0,"z:size,tolerance2:Toler256,ptr2:address1,ptr1: ptrs,ref:buffer,y:c,",209.0,0.2341923117637634,Greedy
2853,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;

	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *params, void __user *Arg)
{
	unsigned hostnumber;
	int rc;

	if (get_user(hostnumber, (unsigned __user *) Arg))
		return -EFAULT;
	rc = usb_hub_claim_port(params->dev, hostnumber, params);
	if (rc == 0)
		snoop(&params->dev->dev, ""port %d claimed by process %d: %s
"",
			hostnumber, task_pid_nr(current), current->comm);
	return rc;
}",87.0,23.0,"rc:rc,portnum:hostnumber,ps:params,arg:Arg,",187.0,0.2220931013425191,Greedy
2861,"bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;

  string::size_type fdot=domain.find('.');
  if(fdot == string::npos)
    return false;

  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return true;
}","bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;

  string::size_type fdot=domain.find('.');
  if(fdot == string::npos)
    return false;

  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char fb[remain];
    memcpy(fb, domain.c_str()+fdot+1, remain);
    domain.assign(fb, remain);
  }
  return true;
}",134.0,25.0,"tmp:fb,",64.0,0.0923868457476298,Greedy
2864,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR size;
    TCHAR s;

    size=GetCommandLine();
    if(*size==TEXT('\""')) {
        s=TEXT('\""');
        ++size;
    } else {
        s=TEXT(' ');
    }
    for(; *size; ++size)
        if(*size==s) {
            ++size;
            break;
        }
    while(*size==TEXT(' '))
        ++size;
    return size;
}",96.0,22.0,"c:size,",79.0,0.092072319984436,Greedy
2885,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
	
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","g_NPN_GetURLNotify(NPP connection, const char *context, const char *target, void *allifyError)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread
"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
	
  if (connection == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plparser PLUGIN_INSTANCE(connection);
  if (parser == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI(""NPN_GetURLNotify instance=%p
"", connection));
  npw_plugin_instance_ref(parser);
  NPError ret = invoke_NPN_GetURLNotify(plugiparsertext, target, allifyError);
  npw_plugin_instance_unref(parser);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]
"", ret, string_of_NPError(ret)));
  return ret;
}",123.0,34.0,"instance:connection,url:context,notifyData:allifyError,plugin:parser,",372.0,0.292268951733907,GA
2896,"static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;

	/*
	 * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't
	 * expect a lot of shrink+grow operations, just free and allocate
	 * again like we would do for growing. If the pipe currently
	 * contains more buffers than arg, then return busy.
	 */
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;

	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indexes.
	 */
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;

		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);

		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}

	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}","static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nrvPages)
{
	struct pipe_buffer *bufs;

	/*
	 * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't
	 * expect a lot of shrink+grow operations, just free and allocate
	 * again like we would do for growing. If the pipe currently
	 * contains more buffers than arg, then return busy.
	 */
	if (nrvPages < pipe->nrbufs)
		return -EBUSY;

	bufs = kcalloc(nrvPages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indexes.
	 */
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int ack;

		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);

		ack = pipe->nrbufs - tail;
		if (ack)
			memcpy(bufs, pipe->bufs + pipe->curbuf, ack * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + ack, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}

	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nrvPages;
	return nrvPages * PAGE_SIZE;
}",196.0,51.0,"nr_pages:nrvPages,head:ack,",167.0,0.1176389455795288,Greedy
2901,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_open,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *module;
	u64 bytes__usage;
	u64 chunk_type;

	module = btrfs_lookup_block_group(fs_open, chunk_offset);
	ASSERT(module);
	chunk_type = module->flags;
	btrfs_put_block_group(module);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_open->data_sinfo->lock);
		bytes__usage = fs_open->data_sinfo->bytes__usage;
		spin_unlock(&fs_open->data_sinfo->lock);

		if (!bytes__usage) {
			struct btrfs_trans_handle *context;
			int ret;

			context =	btrfs_join_transaction(fs_open->tree_root);
			if (IS_ERR(context))
				return PTR_ERR(context);

			ret = btrfs_force_chunk_alloc(context,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(context);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_open);

			return 1;
		}
	}
	return 0;
}",157.0,44.0,"trans:context,fs_info:fs_open,bytes_used:bytes__usage,cache:module,",272.0,0.1789804577827453,Greedy
2908,"print_arrays_for(char *set)
{
  FILE *f;

  sprintf(buf, ""%s.conf"", set);

  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }

  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);

  /* it would be nice if this used the code in mysys/charset.c, but... */
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");

  fclose(f);

  return;
}","print_arrays_for(char *set)
{
  FILE *fb;

  sprintf(buf, ""%s.conf"", set);

  if ((fb = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s
"", prog, set);
    exit(EXIT_FAILURE);
  }

  printf(""\
/* The %s character set.  Generated automatically by configure and
\
 * the %s program
\
 */

"",
	 set, prog);

  /* it would be nice if this used the code in mysys/charset.c, but... */
  print_array(fb, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(fb, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(fb, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(fb, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""
"");

  fclose(fb);

  return;
}",137.0,38.0,"f:fb,",65.0,0.0625367720921834,Greedy
2916,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *image,
			   struct btrfs_disk_key *length, int length)
{
	int depth;
	struct extent_buffer *token;

	for (depth = length; depth < BTRFS_MAX_LEVEL; depth++) {
		int tslot = image->slots[depth];
		if (!image->nodes[depth])
			break;
		token = image->nodes[depth];
		tree_mod_log_set_node_key(root->fs_info, token, tslot, 1);
		btrfs_set_node_key(token, length, tslot);
		btrfs_mark_buffer_dirty(image->nodes[depth]);
		if (tslot != 0)
			break;
	}
}",118.0,32.0,"i:depth,t:token,path:image,level:length,key:length,",258.0,0.1749045888582865,Greedy
2920,"rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }

    return ary;
}","rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE bar;

    GlobPathValue(str, TRUE);
    bar = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(bar, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }

    return bar;
}",151.0,52.0,"ary:bar,",86.0,0.0624894301096598,Greedy
2922,"void *Sys_LoadDll(const char *name, qboolean useSystemLib)
{
	void *dllhandle;
	
	if(useSystemLib)
		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}","void *Sys_LoadDll(const char *wa, qboolean useLibLib)
{
	void *syshandler;
	
	if(useLibLib)
		Com_Printf(""Trying to load \""%s\""...
"", wa);
	
	if(!useLibLib || !(syshandler = Sys_LoadLibrary(wa)))
	{
		const char *topDir;
		char  libName[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...
"", wa, topDir);
		Com_sprintf( libName, sizeof( libName), ""%s%c%s"", topDir, PATH_SEP, wa);

		if(!(syshandler = Sys_LoadLibrary( libName)))
		{
			const char *basedType = Cvar_VariableString(""fs_basepath"");
			
			if(!basedType || !*basedType)
				basedType = ""."";
			
			if(FS_FilenameCompare(topDir, basedType))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...
"", wa, basedType);
				Com_sprintf( libName, sizeof( libName), ""%s%c%s"", basedType, PATH_SEP, wa);
				syshandler = Sys_LoadLibrary( libName);
			}
			
			if(!syshandler)
				Com_Printf(""Loading \""%s\"" failed
"", wa);
		}
	}
	
	return syshandler;
}",222.0,54.0,"useSystemLib:useLibLib,name:wa,libPath: libName,dllhandle:syshandler,basePath:basedType,",293.0,0.229197629292806,Greedy
2930,"
static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->head = head;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);","
static void __io_queue_proc(struct io_poll_iocb *lex, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(lex->head)) {
		struct io_poll_iocb *poll_one = lex;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		lex = kmalloc(sizeof(*lex), GFP_ATOMIC);
		if (!lex) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(lex, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		lex->wait.private = req;
		*poll_ptr = lex;
	}

	pt->error = 0;
	lex->head = head;

	if (lex->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &lex->wait);
	else
		add_wait_queue(head, &lex->wait);",172.0,42.0,"poll:lex,",113.0,0.0944445133209228,Greedy
2937,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;

    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}","int _mkp_stage_30(struct plugin *pb,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t afferer;
    (void) pb;
    (void) cs;

    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    afferer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, afferer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}",153.0,34.0,"p:pb,referer:afferer,",93.0,0.0761584798494974,Greedy
2946,"relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}","relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *uthis,
	relpPermittedPeers_s __attribute__((unused)) *pPeers)
{
	ENTER_RELPFRC;
#ifdef ENABLE_TLS
	int length;
	relpTcpFreePermittedPeers(uthis);
	if(pPeers->nmemb != 0) {
		if((uthis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(length = 0 ; length < pPeers->nmemb ; ++length) {
			if((uthis->permittedPeers.peer[length].name = strdup(pPeers->name[length])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			uthis->permittedPeers.peer[length].wildcardRoot = NULL;
			uthis->permittedPeers.peer[length].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(uthis->permittedPeers.peer[length])));
		}
	}
	uthis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}",193.0,41.0,"i:length,pThis:uthis,relpPermittedPeers_t:relpPermittedPeers_s,ENTER_RELPFUNC:ENTER_RELPFRC,",196.0,0.1747705419858296,Greedy
2964,"bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif

  static const char* prefixes[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }

  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }

  return false;
}","bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif

  static const char* suffs[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : suffs) {
    if (base::ChartsWithout(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }

  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }

  return false;
}",190.0,40.0,"StartsWith:ChartsWithout,prefixes:suffs,",60.0,0.0908532301584879,Greedy
2967,"bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}","bool ZipCommon::isValidPath(const std::string& c)
{
	if (c == "".."")
		return false;
	if (c.compare(0, 3, ""../"") == 0)
		return false;
	if (c.compare(0, 3, ""..\\"") == 0)
		return false;
	if (c.find(""/.."") != std::string::npos)
		return false;
	if (c.find(""\\.."") != std::string::npos)
		return false;
	return true;
}",105.0,9.0,"path:c,",69.0,0.0717033267021179,Greedy
2974,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* length,
    ...)
{
  YR_OBJECT* object_object;

  va_list s;
  va_start(s, length);

  if (length != NULL)
    object_object = _yr_object_lookup(object, 0, length, s);
  else
    object_object = object;

  va_end(s);

  if (object_object == NULL)
    return NULL;

  assertf(object_object->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string
"", length);

  return ((YR_OBJECT_STRING*) object_object)->value;
}",97.0,24.0,"string_obj:object_object,field:length,args:s,",178.0,0.1574390371640523,Greedy
2976,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*channel) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = channel;
	mutex_unlock(&dlci_ioctl_mutex);
}",35.0,9.0,"hook:channel,",47.0,0.0729630986849467,Greedy
2989,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *memory,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	memory->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		memory->tid_entry.pid = perf_event_pid(event, current);
		memory->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		memory->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		memory->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		memory->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		memory->cpu_entry.cpu	 = raw_smp_processor_id();
		memory->cpu_entry.reserved = 0;
	}
}",152.0,40.0,"data:memory,",89.0,0.0989023725191752,Greedy
