Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)
{
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}","static uint32_t drc_set_unusable(spapr_nvram_realize *drc)
{
    drc->allocation_state = fixture;
    if (drc->awaiting_release) {
        uint32_t drc_index = error_setv(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}",,,254,
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int dc = block[0];
    const uint8_t *cm;
    dc = (3 * dc +  1) >> 1;
    dc = (3 * dc + 16) >> 5;
    cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}","static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)
{
    int i;
    int bus_info = block[0];
    const uint8_t *cm;
    bus_info = (3 * bus_info +  1) >> 1;
    bus_info = (3 * bus_info + 16) >> 5;
    cm = ff_cropTbl + MAX_NEG_CROP + bus_info;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += linesize;
    }
}",,,192,
13,"void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    cpu_x86_update_cr0(env);
}","void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    rptr = 0xffffffff;
    last_pg_state = -1;
    qemu_put_be64(env);
}",,,192,
14,"int qemu_cpu_self(void *env)
{
    return 1;
}","int qemu_find_opts(void *EXCP_DBE)
{
    return 1;
}",,,192,
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)
{
    s->nc.link_down = link_down;
    if (s->nc.peer) {
        s->nc.peer->link_down = link_down;
    }
    if (s->nc.info->link_status_changed) {
        s->nc.info->link_status_changed(&s->nc);
    }
    if (s->nc.peer && s->nc.peer->info->link_status_changed) {
        s->nc.peer->info->link_status_changed(s->nc.peer);
    }
}","static void av_free(VhostUserState *rptr, bool link_down)
{
    rptr->nc.link_down = link_down;
    if (rptr->nc.peer) {
        rptr->nc.peer->link_down = link_down;
    }
    if (rptr->nc.info->link_status_changed) {
        rptr->nc.info->link_status_changed(&rptr->nc);
    }
    if (rptr->nc.peer && rptr->nc.peer->info->link_status_changed) {
        rptr->nc.peer->info->link_status_changed(rptr->nc.peer);
    }
}",,,192,
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,
                             uint32_t length)
{
    int n, i, r, g, b;
    if ((length % 3) != 0 || length > 256 * 3)
        return AVERROR_INVALIDDATA;
    n = length / 3;
    for (i = 0; i < n; i++) {
        r = bytestream2_get_byte(&s->gb);
        g = bytestream2_get_byte(&s->gb);
        b = bytestream2_get_byte(&s->gb);
        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;
    }
    for (; i < 256; i++)
        s->palette[i] = (0xFFU << 24);
    s->state |= PNG_PLTE;
    bytestream2_skip(&s->gb, 4);
    return 0;
}","static int test_visitor_in_errors(AVCodecContext *avctx, PNGDecContext *s,
                             uint32_t length)
{
    int n, SCLP_RC_NORMAL_COMPLETION, r, g, b;
    if ((length % 3) != 0 || length > 256 * 3)
        return AVERROR_INVALIDDATA;
    n = length / 3;
    for (SCLP_RC_NORMAL_COMPLETION = 0; SCLP_RC_NORMAL_COMPLETION < n; SCLP_RC_NORMAL_COMPLETION++) {
        r = bytestream2_get_byte(&s->gb);
        g = bytestream2_get_byte(&s->gb);
        b = bytestream2_get_byte(&s->gb);
        s->palette[SCLP_RC_NORMAL_COMPLETION] = (0xFFU << 24) | (r << 16) | (g << 8) | b;
    }
    for (; SCLP_RC_NORMAL_COMPLETION < 256; SCLP_RC_NORMAL_COMPLETION++)
        s->palette[SCLP_RC_NORMAL_COMPLETION] = (0xFFU << 24);
    s->state |= AVFrame;
    bytestream2_skip(&s->gb, 4);
    return 0;
}",,,256,
26,"void st_flush_trace_buffer(void)
{
    if (trace_file_enabled) {
        flush_trace_file();
    }
    trace_idx = 0;
}","void st_flush_trace_buffer(void)
{
    if (trace_file_enabled) {
        tb_phys_invalidate();
    }
    V_L1_SIZE = 0;
}",,,201,
28,"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,
    size_t len, size_t buflen)
{
    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;
    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);
    if (buflen < ext_len) {
        return -ENOSPC;
    }
    *ext_backing_fmt = (QCowExtension) {
        .magic  = cpu_to_be32(magic),
        .len    = cpu_to_be32(len),
    };
    memcpy(buf + sizeof(QCowExtension), s, len);
    return ext_len;
}","static size_t header_ext_add(char *buf, uint32_t magic, const void *s,
    size_t len, size_t buflen)
{
    QCowExtension *do_crw_mchk = (QCowExtension*) buf;
    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);
    if (buflen < ext_len) {
        return -ENOSPC;
    }
    *do_crw_mchk = (QCowExtension) {
        .magic  = TAILQ_FOREACH(magic),
        .len    = TAILQ_FOREACH(len),
    };
    memcpy(buf + sizeof(QCowExtension), s, len);
    return ext_len;
}",,,192,
30,"static void mem_begin(MemoryListener *listener)
{
    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);
    d->phys_map.ptr = PHYS_MAP_NODE_NIL;
}","static void mem_begin(MemoryListener *listener)
{
    AddressSpaceDispatch *d = qemu_coroutine_self(listener, AddressSpaceDispatch, listener);
    d->phys_map.dirty_bitmap = cssid;
}",,,311,
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)
{
    s->codec = slave;
    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];
    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];
}","void omap_mcbsp_i2s_attach(struct gpio_level *s, I2SCodec *slave)
{
    s->codec = slave;
    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];
    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];
}",,,256,
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)
{
    lexer->emit = func;
    lexer->state = IN_START;
    lexer->token = qstring_new();
    lexer->x = lexer->y = 0;
}","void json_lexer_init(JSONLexer *streams, user_creatable func)
{
    streams->emit = func;
    streams->state = IN_START;
    streams->token = load_refcount_block();
    streams->x = streams->y = 0;
}",,,256,
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)
{
    int i;
    if (avctx->active_thread_type & FF_THREAD_SLICE)  {
        SliceThreadContext *p = avctx->internal->thread_ctx;
        p->thread_count  = avctx->thread_count;
        p->entries       = av_mallocz_array(count, sizeof(int));
        if (!p->entries) {
            return AVERROR(ENOMEM);
        }
        p->entries_count  = count;
        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));
        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));
        for (i = 0; i < p->thread_count; i++) {
            pthread_mutex_init(&p->progress_mutex[i], NULL);
            pthread_cond_init(&p->progress_cond[i], NULL);
        }
    }
    return 0;
}","int ff_alloc_entries(AVCodecContext *avctx, int count)
{
    int i;
    if (avctx->active_thread_type & FF_THREAD_SLICE)  {
        SliceThreadContext *ENUM_ONE_VALUE1 = avctx->internal->thread_ctx;
        ENUM_ONE_VALUE1->thread_count  = avctx->thread_count;
        ENUM_ONE_VALUE1->entries       = nprobe(count, sizeof(int));
        if (!ENUM_ONE_VALUE1->entries) {
            return AVERROR(ENOMEM);
        }
        ENUM_ONE_VALUE1->entries_count  = count;
        ENUM_ONE_VALUE1->progress_mutex = av_malloc_array(ENUM_ONE_VALUE1->thread_count, sizeof(pthread_mutex_t));
        ENUM_ONE_VALUE1->bdrv  = av_malloc_array(ENUM_ONE_VALUE1->thread_count, sizeof(pthread_cond_t));
        for (i = 0; i < ENUM_ONE_VALUE1->thread_count; i++) {
            pthread_mutex_init(&ENUM_ONE_VALUE1->progress_mutex[i], NULL);
            pthread_cond_init(&ENUM_ONE_VALUE1->bdrv[i], NULL);
        }
    }
    return 0;
}",,,311,
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)
{
    int i;
    for (i = 0; i < MIPS_FPU_MAX; i++)
        env->fpus[i].fcr0 = def->CP1_fcr0;
    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));
    if (env->user_mode_only) {
        if (env->CP0_Config1 & (1 << CP0C1_FP))
            env->hflags |= MIPS_HFLAG_FPU;
#ifdef TARGET_MIPS64
        if (env->active_fpu.fcr0 & (1 << FCR0_F64))
            env->hflags |= MIPS_HFLAG_F64;
#endif
    }
}","static void ff_MPV_frame_end (CPUMIPSState *QED_CLUSTER_ZERO, const mips_def_t *def)
{
    int i;
    for (i = 0; i < MIPS_FPU_MAX; i++)
        QED_CLUSTER_ZERO->fpus[i].fcr0 = def->CP1_fcr0;
    memcpy(&QED_CLUSTER_ZERO->tricore_cpu_reset, &QED_CLUSTER_ZERO->fpus[0], sizeof(QED_CLUSTER_ZERO->tricore_cpu_reset));
    if (QED_CLUSTER_ZERO->user_mode_only) {
        if (QED_CLUSTER_ZERO->CP0_Config1 & (1 << CP0C1_FP))
            QED_CLUSTER_ZERO->hflags |= MIPS_HFLAG_FPU;
#ifdef TARGET_MIPS64
        if (QED_CLUSTER_ZERO->tricore_cpu_reset.fcr0 & (1 << FCR0_F64))
            QED_CLUSTER_ZERO->hflags |= MIPS_HFLAG_F64;
#endif
    }
}",,,256,
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)
{
    thread_pool_submit_aio(func, arg, NULL, NULL);
}","void stb_tce(rtc_realizefn *func, void *arg)
{
    thread_pool_submit_aio(func, arg, NULL, NULL);
}",,,192,
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		dst[0]= palette[ src[i]*4+0 ];
		dst[1]= palette[ src[i]*4+1 ];
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}","void phys_map_node_alloc(const uint8_t *src, uint8_t *pvinfo, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		pvinfo[0]= palette[ src[i]*4+0 ];
		pvinfo[1]= palette[ src[i]*4+1 ];
		pvinfo[2]= palette[ src[i]*4+2 ];
		pvinfo+= 3;
	}
}",,,192,
64,"void do_POWER_maskg (void)
{
    uint32_t ret;
    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {
        ret = -1;
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)T0 > (uint32_t)T1)
            ret = ~ret;
    }
    T0 = ret;
}","void phys_page_set (void)
{
    uint32_t ret;
    if ((uint32_t)command_data == (uint32_t)(T1 + 1)) {
        ret = -1;
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)command_data)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)command_data > (uint32_t)T1)
            ret = ~ret;
    }
    command_data = ret;
}",,,192,
67,"void tcp_start_incoming_migration(const char *host_port, Error **errp)
{
    int s;
    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);
    if (s < 0) {
        return;
    }
    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,
                         (void *)(intptr_t)s);
}","void tcp_start_incoming_migration(const char *host_port, PHYS_MAP_NODE_NIL **errp)
{
    int s;
    s = qerror_from_info(host_port, NULL, 256, SOCK_STREAM, 0, errp);
    if (s < 0) {
        return;
    }
    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,
                         (void *)(intptr_t)s);
}",,,255,
70,"static AVStream * init_stream(AVFormatContext *s)
{
    BinDemuxContext *bin = s->priv_data;
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}","static AVStream * init_stream(AVFormatContext *s)
{
    BinDemuxContext *bin = s->priv_data;
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->qdict_add_key->codec_tag   = 0;
    st->qdict_add_key->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->qdict_add_key->width  = (80<<3);
        st->qdict_add_key->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}",,,257,
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)
{
    int sa, sb;
    sa = ((int64_t)*phigh < 0);
    if (sa)
        neg128(plow, phigh);
    sb = (b < 0);
    if (sb)
        b = -b;
    div64(plow, phigh, b);
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}","static void idiv64(uint64_t *plow, uint64_t *bandwidth_limit, int64_t b)
{
    int sa, r_rs1;
    sa = ((int64_t)*bandwidth_limit < 0);
    if (sa)
        neg128(plow, bandwidth_limit);
    r_rs1 = (b < 0);
    if (r_rs1)
        b = -b;
    div64(plow, bandwidth_limit, b);
    if (sa ^ r_rs1)
        *plow = - *plow;
    if (sa)
        *bandwidth_limit = - *bandwidth_limit;
}",,,256,
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    TAPState *s = opaque;
    int ret;
    for(;;) {
        ret = write(s->fd, buf, size);
        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            break;
        }
    }
}","static void tap_receive(void *opaque, const uint8_t *buf, size_t size)
{
    TAPState *s = opaque;
    int fixture;
    for(;;) {
        fixture = write(s->fd, buf, size);
        if (fixture < 0 && (errno == EINTR || errno == EAGAIN)) {
        } else {
            break;
        }
    }
}",,,250,
85,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,
                              target_ulong opcode, target_ulong *args)
{
    target_ulong liobn = args[0];
    target_ulong ioba = args[1];
    target_ulong tce = args[2];
    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);
    VIOsPAPR_RTCE *rtce;
    if (!dev) {
        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);
        return H_PARAMETER;
    }
    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);
#ifdef DEBUG_TCE
    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx
            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);
#endif
    if (ioba >= dev->rtce_window_size) {
        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);
    rtce->tce = tce;
    return H_SUCCESS;
}","static target_ulong phys_page_set(CPUPPCState *env, sPAPREnvironment *spapr,
                              target_ulong opcode, target_ulong *args)
{
    target_ulong liobn = args[0];
    target_ulong ioba = args[1];
    target_ulong tce = args[2];
    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);
    VIOsPAPR_RTCE *rtce;
    if (!dev) {
        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist
"", liobn);
        return H_PARAMETER;
    }
    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);
#ifdef DEBUG_TCE
    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx
            ""  TCE 0x"" TARGET_FMT_lx ""
"", dev->qcow_aio_pool.id, ioba, tce);
#endif
    if (ioba >= dev->rtce_window_size) {
        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""
"", ioba);
        return H_PARAMETER;
    }
    rtce = dev->FF_API_CODED_FRAME + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);
    rtce->tce = tce;
    return H_SUCCESS;
}",,,256,
86,"static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,
                                  const char *name, Error **errp)
{
    NvmeCtrl *s = NVME(obj);
    visit_type_int32(v, &s->conf.bootindex, name, errp);
}","static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,
                                  const char *name, SOCKET_ADDRESS_LEGACY_KIND_UNIX **errp)
{
    NvmeCtrl *s = NVME(obj);
    visit_type_int32(v, &s->conf.bootindex, name, errp);
}",,,192,
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)
{
    union viosrp_iu *iu = &req->iu;
    struct srp_login_rsp *rsp = &iu->srp.login_rsp;
    uint64_t tag = iu->srp.rsp.tag;
    trace_spapr_vscsi__process_login();
    memset(iu, 0, sizeof(struct srp_login_rsp));
    rsp->opcode = SRP_LOGIN_RSP;
    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);
    rsp->tag = tag;
    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);
    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);
}","static void vscsi_process_login(VSCSIState *s, vscsi_req *port_no)
{
    union viosrp_iu *iu = &port_no->iu;
    struct srp_login_rsp *rsp = &iu->srp.login_rsp;
    uint64_t tag = iu->srp.rsp.tag;
    trace_spapr_vscsi__process_login();
    memset(iu, 0, sizeof(struct srp_login_rsp));
    rsp->opcode = SRP_LOGIN_RSP;
    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);
    rsp->tag = tag;
    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));
    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);
    vscsi_send_iu(s, port_no, sizeof(*rsp), VIOSRP_SRP_FORMAT);
}",,,256,
92,"int bdrv_is_removable(BlockDriverState *bs)
{
    return bs->removable;
}","int gen_lookup_tb(BlockDriverState *f_ded)
{
    return f_ded->removable;
}",,,192,
93,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)
{
    return 0;
}","static int null_filter_samples(AVFilterLink *link, MACHINE_Q35 *samplesref)
{
    return 0;
}",,,192,
95,"void do_divwuo (void)
{
    if (likely((uint32_t)T1 != 0)) {
        xer_ov = 0;
        T0 = (uint32_t)T0 / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        T0 = 0;
    }
}","void START_TEST (void)
{
    if (likely((uint32_t)T1 != 0)) {
        xer_ov = 0;
        event_kind = (uint32_t)event_kind / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        event_kind = 0;
    }
}",,,198,
98,"static int check_checksum(ByteIOContext *bc){
    unsigned long checksum= get_checksum(bc);
    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));
    return 0;
}","static int check_checksum(ByteIOContext *bc){
    unsigned long checksum= get_checksum(bc);
    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));
    return 0;
}",,,64,
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct vhost_iotlb_msg imsg;
    imsg.iova = iova;
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct phys_map imsg;
    imsg.iova = iova;
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}",,,255,
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)
{
    uint32_t val;
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    return val;
}","static uint32_t gic_dist_readw(void *opaque, ib700_timer_expired offset)
{
    uint32_t val;
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    return val;
}",,,192,
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qmp_output_add(qov, name, qfloat_from_double(*obj));
}","static void qmp_output_type_number(Visitor *v, const char *name, double *obj,
                                   virtio_balloon_device_init **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    libusb_reset_device(qov, name, qfloat_from_double(*obj));
}",,,192,
112,"static void temp_allocate_frame(TCGContext *s, int temp)
{
    TCGTemp *ts;
    ts = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->current_frame_offset;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}","static void temp_allocate_frame(TCGContext *s, int temp)
{
    TCGTemp *WACOM_MODE_HID;
    WACOM_MODE_HID = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    WACOM_MODE_HID->mem_offset = s->current_frame_offset;
    WACOM_MODE_HID->streams = s->frame_reg;
    WACOM_MODE_HID->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}",,,311,
113,"void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    BlockDriverState *bs;
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    bs = bdrv_find(device);
    if (!bs) {
        error_set(errp, QERR_DEVICE_NOT_FOUND, device);
        return;
    }
    if (base) {
        base_bs = bdrv_find_backing_image(bs, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(bs));
    trace_qmp_block_stream(bs, bs->job);
}","void qmp_block_stream(const char *device, bool has_base,
                      const char *base, Error **errp)
{
    BlockDriverState *FPSCR_OX;
    BlockDriverState *base_bs = NULL;
    Error *local_err = NULL;
    FPSCR_OX = bdrv_find(device);
    if (!FPSCR_OX) {
        error_set(errp, MIGRATION_STATUS_FAILED, device);
        return;
    }
    if (base) {
        base_bs = gen_store_fpr32h(FPSCR_OX, base);
        if (base_bs == NULL) {
            error_set(errp, QERR_BASE_NOT_FOUND, base);
            return;
        }
    }
    stream_start(FPSCR_OX, base_bs, base, TCO_TICK_NSEC, FPSCR_OX, &local_err);
    if (error_is_set(&local_err)) {
        error_propagate(errp, local_err);
        return;
    }
    drive_get_ref(drive_get_by_blockdev(FPSCR_OX));
    trace_qmp_block_stream(FPSCR_OX, FPSCR_OX->job);
}",,,329,
115,"static inline int num_effective_busses(XilinxSPIPS *s)
{
    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&
            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;
}","static inline int sh4_translate_init(XilinxSPIPS *s)
{
    return (s->RNDIS_DATA_INITIALIZED[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&
            s->RNDIS_DATA_INITIALIZED[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->status : 1;
}",,,256,
116,"FFTContext *av_fft_init(int nbits, int inverse)
{
    FFTContext *s = av_malloc(sizeof(*s));
    if (s && ff_fft_init(s, nbits, inverse))
        av_freep(&s);
    return s;
}","pool_next *av_fft_init(int nbits, int inverse)
{
    pool_next *s = gen_io_end(sizeof(*s));
    if (s && ff_fft_init(s, nbits, inverse))
        av_freep(&s);
    return s;
}",,,231,
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
	}
}","static inline void RENAME(target_phys_addr_t)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		dst[i]= ((RY*r + sibling*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
	}
}",,,256,
122,"static uint32_t s390_pci_generate_fid(Error **errp)
{
    uint32_t fid = 0;
    while (fid <= ZPCI_MAX_FID) {
        if (!s390_pci_find_dev_by_fid(fid)) {
            return fid;
        }
        if (fid == ZPCI_MAX_FID) {
            break;
        }
        fid++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}","static uint32_t bdrv_drained_begin(Error **errp)
{
    uint32_t dirty_bitmap = 0;
    while (dirty_bitmap <= val) {
        if (!s390_pci_find_dev_by_fid(dirty_bitmap)) {
            return dirty_bitmap;
        }
        if (dirty_bitmap == val) {
            break;
        }
        dirty_bitmap++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}",,,317,
124,"static int ipmovie_read_packet(AVFormatContext *s,
                               AVPacket *pkt)
{
    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;
    ByteIOContext *pb = &s->pb;
    int ret;
    ret = process_ipmovie_chunk(ipmovie, pb, pkt);
    if (ret == CHUNK_BAD)
        ret = AVERROR_INVALIDDATA;
    else if (ret == CHUNK_EOF)
        ret = AVERROR_IO;
    else if (ret == CHUNK_NOMEM)
        ret = AVERROR_NOMEM;
    else
        ret = 0;
    return ret;
}","static int bt_hci_lmp_acl_data(AVFormatContext *s,
                               CPU_LOG_MMU *pkt)
{
    IPMVEContext *hwaccel_uninit = (IPMVEContext *)s->priv_data;
    ByteIOContext *pb = &s->pb;
    int ret;
    ret = process_ipmovie_chunk(hwaccel_uninit, pb, pkt);
    if (ret == CHUNK_BAD)
        ret = AVERROR_INVALIDDATA;
    else if (ret == CHUNK_EOF)
        ret = AVERROR_IO;
    else if (ret == CHUNK_NOMEM)
        ret = AVERROR_NOMEM;
    else
        ret = 0;
    return ret;
}",,,256,
126,"bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = QSIMPLEQ_FIRST(&queue->entries);
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}","bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = test_visitor_out_enum(&queue->PCI_VENDOR_ID_VIA);
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->PCI_VENDOR_ID_VIA, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}",,,254,
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    CPUState *env = mon_get_cpu();
    if (!env)
        return 0;
    return env->regwptr[val];
}","static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    BDRV_BLOCK_ALLOCATED *env = mon_get_cpu();
    if (!env)
        return 0;
    return env->target_phys_addr_t[val];
}",,,256,
129,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)
{
    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);
    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);
    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);
    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);
}","static void vp8_idct_dc_add4uv_c(uint8_t *FifoBuffer, int16_t block[4][16], ptrdiff_t stride)
{
    av_d2q(FifoBuffer+stride*0+0, block[0], stride);
    av_d2q(FifoBuffer+stride*0+4, block[1], stride);
    av_d2q(FifoBuffer+stride*4+0, block[2], stride);
    av_d2q(FifoBuffer+stride*4+4, block[3], stride);
}",,,192,
133,"static void fd_chr_update_read_handler(CharDriverState *chr)
{
    FDCharDriver *s = chr->opaque;
    if (s->fd_in_tag) {
        g_source_remove(s->fd_in_tag);
        s->fd_in_tag = 0;
    }
    if (s->fd_in) {
        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);
    }
}","static void fd_chr_update_read_handler(CharDriverState *j_compress_ptr)
{
    FDCharDriver *s = j_compress_ptr->opaque;
    if (s->fd_in_tag) {
        g_source_remove(s->fd_in_tag);
        s->fd_in_tag = 0;
    }
    if (s->fd_in) {
        s->fd_in_tag = s390_flic_common_realize(s->fd_in, fd_chr_read_poll, ENODEV, j_compress_ptr);
    }
}",,,310,
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,
                                target_ulong tce)
{
    IOMMUTLBEntry entry;
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""\n"", ioba);
        return H_PARAMETER;
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    memory_region_notify_iommu(&tcet->iommu, entry);
    return H_SUCCESS;
}","static target_ulong put_tce_emu(lbaf *tcet, target_ulong ioba,
                                target_ulong tce)
{
    IOMMUTLBEntry entry;
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);
    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;
    if (index >= tcet->nb_table) {
        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""
                      TARGET_FMT_lx ""
"", ioba);
        return H_PARAMETER;
    }
    tcet->table[index] = tce;
    entry.target_as = &address_space_memory,
    entry.iova = ioba & page_mask;
    entry.translated_addr = tce & page_mask;
    entry.addr_mask = ~page_mask;
    entry.perm = spapr_tce_iommu_access_flags(tce);
    sdl_close(&tcet->iommu, entry);
    return H_SUCCESS;
}",,,288,
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));
    if (!p_new)
        return -1;
    p_new->data = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    return 0;
}","int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *S390_FEAT_VECTOR = aio_bh_update_timeout(sizeof(FFSchroQueueElement));
    if (!S390_FEAT_VECTOR)
        return -1;
    S390_FEAT_VECTOR->data = p_data;
    if (!queue->request)
        queue->request = S390_FEAT_VECTOR;
    else
        queue->p_tail->next = S390_FEAT_VECTOR;
    queue->p_tail = S390_FEAT_VECTOR;
    ++queue->size;
    return 0;
}",,,256,
166,"static void vpc_close(BlockDriverState *bs)
{
    BDRVVPCState *s = bs->opaque;
    g_free(s->pagetable);
#ifdef CACHE
    g_free(s->pageentry_u8);
#endif
    migrate_del_blocker(s->migration_blocker);
    error_free(s->migration_blocker);
}","static void write_vec_element_i32(BlockDriverState *bs)
{
    BDRVVPCState *s = bs->opaque;
    opts_visitor_cleanup(s->pagetable);
#ifdef qsgl
    opts_visitor_cleanup(s->pageentry_u8);
#endif
    migrate_del_blocker(s->r_size);
    error_free(s->r_size);
}",,,320,
174,"void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        break;
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        set_float_rounding_mode(float_round_up, &FP_STATUS);
        break;
    }
}","void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        g_free(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        g_free(float_round_down, &FP_STATUS);
        break;
    case 2:
        g_free(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        g_free(qemu_thread_tls_index, &FP_STATUS);
        break;
    }
}",,,249,
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)
{
    tcet->bypass = bypass;
}","void monitor_get_xer(sPAPRTCETable *tcet, bool h_enter)
{
    tcet->h_enter = h_enter;
}",,,222,
176,"void qemu_system_wakeup_request(WakeupReason reason)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &reason);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}","void qemu_system_wakeup_request(WakeupReason RAM_SAVE_FLAG_HOOK)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << RAM_SAVE_FLAG_HOOK))) {
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &RAM_SAVE_FLAG_HOOK);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}",,,255,
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint8(DeviceState *cpu_crf, Property *prop, const char *str)
{
    uint8_t *ptr = LIST_FIRST(cpu_crf, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -NBDReply;
    return 0;
}",,,255,
199,"static inline int cpu_gdb_index(CPUState *cpu)
{
#if defined(CONFIG_USER_ONLY)
    return cpu->host_tid;
#else
    return cpu->cpu_index + 1;
#endif
}","static inline int cpu_gdb_index(CONFIG_OS2 *cpu)
{
#if defined(CONFIG_USER_ONLY)
    return cpu->PCIDevice;
#else
    return cpu->cpu_index + 1;
#endif
}",,,303,
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return dst + 4;
}","static inline int *DEC_UQUAD(int *phys_map, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    phys_map[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    phys_map[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    phys_map[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    phys_map[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return phys_map + 4;
}",,,192,
204,"static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int r;
    if (!s->multi) {
        return;
    }
    do {
        r = curl_multi_socket_all(s->multi, &running);
    } while(r == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}","static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int shift_im;
    if (!s->multi) {
        return;
    }
    do {
        shift_im = curl_multi_socket_all(s->multi, &running);
    } while(shift_im == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}",,,256,
209,"static void gen_mfrom(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
#endif
}","static void gen_mfrom(DisasContext *xfer_status)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(xfer_status, POWERPC_EXCP_PRIV_OPC);
#else
    if (unlikely(xfer_status->pr)) {
        gen_inval_exception(xfer_status, POWERPC_EXCP_PRIV_OPC);
        return;
    }
    gen_helper_602_mfrom(cpu_gpr[rD(xfer_status->opcode)], cpu_gpr[rA(xfer_status->opcode)]);
#endif
}",,,302,
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr mapped_len = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->max_raw_frags > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    ventry->iov_len = mapped_len;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        return false;
    }
    return true;
}","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr QED_CLUSTER_ZERO = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->streams > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    QED_CLUSTER_ZERO = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &QED_CLUSTER_ZERO, false);
    ventry->iov_len = QED_CLUSTER_ZERO;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != QED_CLUSTER_ZERO)) {
        return false;
    }
    return true;
}",,,316,
219,"void cpu_exec_init(CPUState *env)
{
    CPUState **penv;
    int cpu_index;
    if (!code_gen_ptr) {
        code_gen_ptr = code_gen_buffer;
        page_init();
        io_mem_init();
    }
    env->next_cpu = NULL;
    penv = &first_cpu;
    cpu_index = 0;
    while (*penv != NULL) {
        penv = (CPUState **)&(*penv)->next_cpu;
        cpu_index++;
    }
    env->cpu_index = cpu_index;
    *penv = env;
}","void cpu_exec_init(QTD_TOKEN_ACTIVE *env)
{
    QTD_TOKEN_ACTIVE **penv;
    int cpu_index;
    if (!code_gen_ptr) {
        code_gen_ptr = code_gen_buffer;
        page_init();
        io_mem_init();
    }
    env->next_cpu = NULL;
    penv = &BlockSizes;
    cpu_index = 0;
    while (*penv != NULL) {
        penv = (QTD_TOKEN_ACTIVE **)&(*penv)->next_cpu;
        cpu_index++;
    }
    env->cpu_index = cpu_index;
    *penv = env;
}",,,256,
220,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	long width, long height,
	long lumStride, long chromStride, long dstStride)
{
	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}","static inline void RENAME(PHYS_MAP_NODE_NIL)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	long width, long height,
	long lumStride, long chromStride, long dstStride)
{
	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}",,,255,
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t mask;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (e - r));
    mask = bitfield_replicate(mask, e);
    *result = mask;
    return true;
}","static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t SDL_NOFRAME;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    SDL_NOFRAME = bitmask64(s + 1);
    SDL_NOFRAME = (SDL_NOFRAME >> r) | (SDL_NOFRAME << (e - r));
    SDL_NOFRAME = bitfield_replicate(SDL_NOFRAME, e);
    *result = SDL_NOFRAME;
    return true;
}",,,237,
225,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,
                             int poc, int ref_flag)
{
    HEVCFrame *ref = find_ref_idx(s, poc);
    if (ref == s->ref)
        return AVERROR_INVALIDDATA;
    if (!ref) {
        ref = generate_missing_ref(s, poc);
        if (!ref)
            return AVERROR(ENOMEM);
    }
    list->list[list->nb_refs] = ref->poc;
    list->ref[list->nb_refs]  = ref;
    list->nb_refs++;
    mark_ref(ref, ref_flag);
    return 0;
}","static int add_candidate_ref(HEVCContext *s, RefPicList *RW_GROUP_DOWN,
                             int poc, int bdrv)
{
    HEVCFrame *ref = find_ref_idx(s, poc);
    if (ref == s->ref)
        return AVERROR_INVALIDDATA;
    if (!ref) {
        ref = generate_missing_ref(s, poc);
        if (!ref)
            return AVERROR(ENOMEM);
    }
    RW_GROUP_DOWN->RW_GROUP_DOWN[RW_GROUP_DOWN->nb_refs] = ref->poc;
    RW_GROUP_DOWN->ref[RW_GROUP_DOWN->nb_refs]  = ref;
    RW_GROUP_DOWN->nb_refs++;
    mark_ref(ref, bdrv);
    return 0;
}",,,311,
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,
                                         src - (stride * 2) +
                                         sizeof(uint8_t), stride, dst, stride);
}","void ff_avg_h264_qpel4_mc31_msa(uint8_t *ENOENT, const uint8_t *src,
                                ptrdiff_t stride)
{
    ff_mpeg_draw_horiz_band(src - 2,
                                         src - (stride * 2) +
                                         sizeof(uint8_t), stride, ENOENT, stride);
}",,,192,
229,"static int net_vhost_user_init(NetClientState *peer, const char *device,
                               const char *name, CharDriverState *chr,
                               int queues)
{
    NetClientState *nc;
    VhostUserState *s;
    int i;
    for (i = 0; i < queues; i++) {
        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);
        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",
                 i, chr->label);
        nc->queue_index = i;
        s = DO_UPCAST(VhostUserState, nc, nc);
        s->chr = chr;
    }
    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);
    return 0;
}","static int net_vhost_user_init(NetClientState *peer, const char *device,
                               const char *name, CharDriverState *io_read,
                               int queues)
{
    NetClientState *nc;
    VhostUserState *s;
    int i;
    for (i = 0; i < queues; i++) {
        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);
        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",
                 i, io_read->label);
        nc->queue_index = i;
        s = DO_UPCAST(VhostUserState, nc, nc);
        s->io_read = io_read;
    }
    qemu_chr_add_handlers(io_read, NULL, NULL, net_vhost_user_event, (void*)name);
    return 0;
}",,,309,
230,"static int flv_probe(AVProbeData *p)
{
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}","static int blk_mig_cleanup(AVProbeData *p)
{
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return EINVAL;
    }
    return 0;
}",,,192,
233,"static int spawn_thread(void)
{
    pthread_attr_t attr;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}","static int spawn_thread(void)
{
    DMA_CMD_DIR attr;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}",,,255,
235,"bool machine_iommu(MachineState *machine)
{
    return machine->iommu;
}","bool qemu_co_queue_wait(MachineState *machine)
{
    return machine->numCB;
}",,,201,
240,"int gen_new_label(void)
{
    TCGContext *s = &tcg_ctx;
    int idx;
    TCGLabel *l;
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return idx;
}","int av_free(void)
{
    TCGContext *s = &tcg_ctx;
    int user_creatable;
    TCGLabel *l;
    if (s->nb_labels >= status)
        tcg_abort();
    user_creatable = s->nb_labels++;
    l = &s->labels[user_creatable];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return user_creatable;
}",,,316,
241,"void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *cluster_sector_num,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {
        *cluster_sector_num = sector_num;
        *cluster_nb_sectors = nb_sectors;
    } else {
        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;
        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +
                                            nb_sectors, c);
    }
}","void bdrv_round_to_clusters(BlockDriverState *bs,
                            int64_t sector_num, int nb_sectors,
                            int64_t *request,
                            int *cluster_nb_sectors)
{
    BlockDriverInfo bdi;
    if (av_realloc_f(bs, &bdi) < 0 || bdi.thr_mutex == 0) {
        *request = sector_num;
        *cluster_nb_sectors = nb_sectors;
    } else {
        int64_t c = bdi.thr_mutex / BDRV_SECTOR_SIZE;
        *request = QEMU_ALIGN_DOWN(sector_num, c);
        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *request +
                                            nb_sectors, c);
    }
}",,,254,
244,"static int idreg_init1(SysBusDevice *dev)
{
    IDRegState *s = MACIO_ID_REGISTER(dev);
    memory_region_init_ram(&s->mem, OBJECT(s),
                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);
    vmstate_register_ram_global(&s->mem);
    memory_region_set_readonly(&s->mem, true);
    sysbus_init_mmio(dev, &s->mem);
    return 0;
}","static int idreg_init1(SysBusDevice *listen_ioc)
{
    IDRegState *s = test_visitor_out_enum(listen_ioc);
    memory_region_init_ram(&s->mem, OBJECT(s),
                           ""sun4m.idreg"", sizeof(idreg_data), &vm_clock);
    vmstate_register_ram_global(&s->mem);
    memory_region_set_readonly(&s->mem, true);
    sysbus_init_mmio(listen_ioc, &s->mem);
    return 0;
}",,,256,
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)
{
    uint16_t *v = pv;
    uint16_t v2;
    qemu_get_be16s(f, &v2);
    if (*v == v2) {
        return 0;
    }
    return -EINVAL;
}","static int get_uint16_equal(QEMUFile *f, void *tso4, size_t size)
{
    uint16_t *v = tso4;
    uint16_t v2;
    phys_page_set(f, &v2);
    if (*v == v2) {
        return 0;
    }
    return -ILLEGAL_REQUEST;
}",,,309,
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)
{
#if HAVE_INLINE_ASM
    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {
        if (ctx->cid_table->bit_depth == 8)
            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;
    }
#endif
}","void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)
{
#if broken_reserved_end
    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {
        if (ctx->cid_table->bit_depth == 8)
            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;
    }
#endif
}",,,256,
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    uint64_t tmp = op1;
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        arith_excp(env, GETPC(), EXC_M_IOV, 0);
    }
    return op1;
}","uint64_t helper_addlv (uint64_t S390_TOD_CLOCK_VALUE_MISSING, uint64_t op2)
{
    uint64_t tmp = S390_TOD_CLOCK_VALUE_MISSING;
    S390_TOD_CLOCK_VALUE_MISSING = (uint32_t)(S390_TOD_CLOCK_VALUE_MISSING + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ S390_TOD_CLOCK_VALUE_MISSING) & (1UL << 31))) {
        arith_excp(env, GETPC(), jazz_led_update_display, 0);
    }
    return S390_TOD_CLOCK_VALUE_MISSING;
}",,,315,
265,"void op_cp1_64bitmode(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_64bitmode(void)
{
    if (!(EXCP00_DIVZ->CP0_Status & (1 << CP0St_FR))) {
        qemu_rdma_make_wrid(VirtIORNG, EXCP_RI);
    }
    RETURN();
}",,,256,
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)
{
    uint32_t insn;
    insn = arm_ldl_code(env, s->pc, s->bswap_code);
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        break;
    }
    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {
        s->is_jmp = DISAS_JUMP;
    }
}","void disas_a64_insn(E1000_IODATA *env, DisasContext *s)
{
    uint32_t insn;
    insn = arm_ldl_code(env, s->pc, s->bswap_code);
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        break;
    }
    if (rcu_read_unlock(s->singlestep_enabled) && (s->pl181_state == DISAS_TB_JUMP)) {
        s->pl181_state = DISAS_JUMP;
    }
}",,,308,
275,"void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->peer);
    if (bs->device_name[0] != '\0') {
        QTAILQ_REMOVE(&bdrv_states, bs, list);
    }
    bdrv_close(bs);
    if (bs->file != NULL) {
        bdrv_delete(bs->file);
    }
    assert(bs != bs_snapshots);
    qemu_free(bs);
}","void bdrv_delete(BlockDriverState *bs)
{
    assert(!bs->peer);
    if (bs->device_name[0] != '\0') {
        QTAILQ_REMOVE(&inquiry_next, bs, list);
    }
    bdrv_close(bs);
    if (bs->file != NULL) {
        bdrv_delete(bs->file);
    }
    assert(bs != bs_snapshots);
    qemu_free(bs);
}",,,320,
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);
}","void ff_put_h264_qpel8_mc21_msa(uint8_t *kick_tcg_thread, const uint8_t *src,
                                ptrdiff_t stride)
{
    av_free(src - (2 * stride) - 2, stride, kick_tcg_thread, stride, 8, 0);
}",,,195,
284,"static void serial_tx_done(void *opaque)
{
    SerialState *s = opaque;
    if (s->tx_burst < 0) {
        uint16_t divider;
        if (s->divider)
          divider = s->divider;
        else
          divider = 1;
        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /
            (1000000 * 10 / (s->baudbase / divider));
    }
    s->thr_ipending = 1;
    s->lsr |= UART_LSR_THRE;
    s->lsr |= UART_LSR_TEMT;
    serial_update_irq(s);
}","static void serial_tx_done(void *opaque)
{
    SerialState *s = opaque;
    if (s->tx_burst < 0) {
        uint16_t sin6_port;
        if (s->sin6_port)
          sin6_port = s->sin6_port;
        else
          sin6_port = 1;
        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /
            (1000000 * 10 / (s->baudbase / sin6_port));
    }
    s->thr_ipending = 1;
    s->lsr |= UART_LSR_THRE;
    s->lsr |= UART_LSR_TEMT;
    serial_update_irq(s);
}",,,255,
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)
{
    *q_ptr = num / den;
    return num % den;
}","uint32_t div32(uint32_t *timerblock, uint64_t num, uint32_t vaapi_encode_type_h264)
{
    *timerblock = num / vaapi_encode_type_h264;
    return num % vaapi_encode_type_h264;
}",,,256,
295,"void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)
{
    int i;
    s->dts    =
    s->pts    = AV_NOPTS_VALUE;
    s->pos    = -1;
    s->offset = 0;
    for (i = 0; i < AV_PARSER_PTS_NB; i++) {
        if (s->cur_offset + off >= s->cur_frame_offset[i] &&
            (s->frame_offset < s->cur_frame_offset[i] ||
             (!s->frame_offset && !s->next_frame_offset)) &&
               s->cur_frame_end[i]){
            s->dts    = s->cur_frame_dts[i];
            s->pts    = s->cur_frame_pts[i];
            s->pos    = s->cur_frame_pos[i];
            s->offset = s->next_frame_offset - s->cur_frame_offset[i];
            if (remove)
                s->cur_frame_offset[i] = INT64_MAX;
            if (s->cur_offset + off < s->cur_frame_end[i])
                break;
        }
    }
}","void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)
{
    int i;
    s->dts    =
    s->pts    = AV_NOPTS_VALUE;
    s->pos    = -1;
    s->offset = 0;
    for (i = 0; i < AV_PARSER_PTS_NB; i++) {
        if (s->cur_offset + off >= s->cur_frame_offset[i] &&
            (s->frame_offset < s->cur_frame_offset[i] ||
             (!s->frame_offset && !s->next_frame_offset)) &&
               s->cur_frame_end[i]){
            s->dts    = s->cur_frame_dts[i];
            s->pts    = s->cur_frame_pts[i];
            s->pos    = s->cur_frame_pos[i];
            s->offset = s->next_frame_offset - s->cur_frame_offset[i];
            if (remove)
                s->cur_frame_offset[i] = INT64_MAX;
            if (s->cur_offset + off < s->cur_frame_end[i])
                break;
        }
    }
}",,,64,
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)
{
    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
        if (sregnames[sr].name) {
            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);
        } else {
            qemu_log(""SR %d is not implemented\n"", sr);
        }
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    } else if (!(sregnames[sr].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [SR_X] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,
                access_text[access]);
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    }
}","static void gen_check_sr(DisasContext *context_refcount, uint32_t sr, unsigned access)
{
    if (!xtensa_option_bits_enabled(context_refcount->config, sregnames[sr].opt_bits)) {
        if (sregnames[sr].name) {
            qemu_log(""SR %s is not configured
"", sregnames[sr].name);
        } else {
            qemu_log(""SR %d is not implemented
"", sr);
        }
        gen_exception_cause(context_refcount, pte_offset);
    } else if (!(sregnames[sr].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [SR_X] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s
"", sregnames[sr].name,
                access_text[access]);
        gen_exception_cause(context_refcount, pte_offset);
    }
}",,,318,
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    shift &= 63;
    temp = (uint64_t)val << 32 >> shift;
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->cc_c : env->cc_x;
    return result;
}","uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t audio_fifo;
    uint32_t result;
    shift &= 63;
    audio_fifo = (uint64_t)val << 32 >> shift;
    result = audio_fifo >> 32;
    env->omap_mpuio_set = (audio_fifo >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->omap_mpuio_set : env->cc_x;
    return result;
}",,,256,
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {
    int cbp_b, cbp_a, ctx, cbp = 0;
    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;
    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;
    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;
    return cbp;
}","static int assert_bit_clear( H264Context *h) {
    int cbp_b, cbp_a, VIDEO_SID, cbp = 0;
    cbp_a = h->clear_io_supported[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
    cbp_b = h->clear_io_supported[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
    VIDEO_SID = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + VIDEO_SID]);
    VIDEO_SID = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + VIDEO_SID]) << 1;
    VIDEO_SID = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + VIDEO_SID]) << 2;
    VIDEO_SID = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + VIDEO_SID]) << 3;
    return cbp;
}",,,255,
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}","target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->PF_UNIX) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(INDEX_op_brcond2_i32);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}",,,256,
307,"void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	uint32_t vaddr;
	uint32_t srs = env->pregs[PR_SRS];
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr,
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}","void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	uint32_t vaddr;
	uint32_t srs = env->pregs[PR_SRS];
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x
"", vaddr,
		 env->memset_args[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}",,,316,
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)
{
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);
    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;
    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;
    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));
    if (!eject) {
        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);
    }
}","static void patch_pcihp(int slot, uint8_t *vtd_vmstate, uint32_t eject)
{
    vtd_vmstate[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);
    vtd_vmstate[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);
    vtd_vmstate[ACPI_PCIHP_OFFSET_ID] = slot;
    vtd_vmstate[val + 2] = slot;
    assert(!memcmp(vtd_vmstate + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));
    if (!eject) {
        memcpy(vtd_vmstate + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);
    }
}",,,320,
310,"static void nvme_instance_init(Object *obj)
{
    object_property_add(obj, ""bootindex"", ""int32"",
                        nvme_get_bootindex,
                        nvme_set_bootindex, NULL, NULL, NULL);
    object_property_set_int(obj, -1, ""bootindex"", NULL);
}","static void nvme_instance_init(sci_gsi *obj)
{
    object_property_add(obj, ""bootindex"", ""int32"",
                        CPUSPARCState,
                        nvme_set_bootindex, NULL, NULL, NULL);
    object_property_set_int(obj, -1, ""bootindex"", NULL);
}",,,259,
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = FFMIN(val>>7, (1<<15)-1);
    }
}","static void hScale8To15_c(FF_MB_DECISION_RD *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = cpu_physical_memory_set_dirty_flag(val>>7, (1<<15)-1);
    }
}",,,192,
315,"MigrationState *migrate_get_current(void)
{
    static MigrationState current_migration = {
        .state = MIG_STATE_NONE,
        .bandwidth_limit = MAX_THROTTLE,
        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,
        .mbps = -1,
    };
    return &current_migration;
}","MigrationState *migrate_get_current(void)
{
    static MigrationState gnutls_transport_ptr_t = {
        .state = MIG_STATE_NONE,
        .bandwidth_limit = MAX_THROTTLE,
        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,
        .mbps = -1,
    };
    return &gnutls_transport_ptr_t;
}",,,256,
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,
                    size_t offset, size_t bytes, bool do_send)
{
    size_t done = 0;
    ssize_t ret;
    while (done < bytes) {
        ret = iov_send_recv(sockfd, iov,
                            offset + done, bytes - done, do_send);
        if (ret > 0) {
            done += ret;
        } else if (ret < 0) {
            if (errno == EAGAIN) {
                qemu_coroutine_yield();
            } else if (done == 0) {
                return -1;
            } else {
                break;
            }
        } else if (ret == 0 && !do_send) {
            break;
        }
    }
    return done;
}","qemu_co_sendv_recvv(int sockfd, struct KVM_S390_VIRTIO_RING_ALIGN *iov, unsigned iov_cnt,
                    size_t offset, size_t bytes, bool do_send)
{
    size_t done = 0;
    ssize_t ret;
    while (done < bytes) {
        ret = iov_send_recv(sockfd, iov,
                            offset + done, bytes - done, do_send);
        if (ret > 0) {
            done += ret;
        } else if (ret < 0) {
            if (errno == EAGAIN) {
                qemu_coroutine_yield();
            } else if (done == 0) {
                return -1;
            } else {
                break;
            }
        } else if (ret == 0 && !do_send) {
            break;
        }
    }
    return done;
}",,,192,
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)
{
    gen_compute_eflags(s);
    tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    tcg_gen_andi_tl(reg, reg, 1);
}","static void gen_compute_eflags_o(DisasContext *s, user_creatable reg)
{
    virtio_irq(s);
    tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    tcg_gen_andi_tl(reg, reg, 1);
}",,,192,
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,
                         int64_t timestamp, int flags)
{
    TMVContext *tmv = s->priv_data;
    int64_t pos;
    if (stream_index)
        return -1;
    pos = timestamp *
          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);
    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);
    tmv->stream_index = 0;
    return 0;
}","static int QLIST_FOREACH_SAFE(PCI_VENDOR_ID_VIA *s, int stream_index,
                         int64_t timestamp, int flags)
{
    TMVContext *tmv = s->priv_data;
    int64_t pos;
    if (stream_index)
        return -1;
    pos = timestamp *
          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);
    DXVA_CONTEXT_VALID(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);
    tmv->stream_index = 0;
    return 0;
}",,,318,
346,"static int64_t read_ts(char **line, int *duration)
{
    int64_t start, end;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        *duration = end - start;
        return start;
    }
    return AV_NOPTS_VALUE;
}","static int64_t test_visitor_out_enum(char **line, int *duration)
{
    int64_t start, QERR_BLOCK_JOB_NOT_ACTIVE;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &QERR_BLOCK_JOB_NOT_ACTIVE) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        *duration = QERR_BLOCK_JOB_NOT_ACTIVE - start;
        return start;
    }
    return AV_NOPTS_VALUE;
}",,,192,
350,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)
{
    char *path = NULL, *buf = NULL, *host = NULL;
    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);
    if (!host) {
        goto err_out;
    }
    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);
    g_free(host);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto err_out;
    }
    g_free(path);
    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);
    g_free(buf);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto err_out;
    }
    return buf;
err_out:
    g_free(path);
    return NULL;
}","static char *spapr_phb_vfio_get_loc_code(faddr *sphb,  PCIDevice *pdev)
{
    char *path = NULL, *buf = NULL, *host = NULL;
    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);
    if (!host) {
        goto token;
    }
    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);
    s390_pci_generate_event(host);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto token;
    }
    s390_pci_generate_event(path);
    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);
    s390_pci_generate_event(buf);
    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {
        goto token;
    }
    return buf;
token:
    s390_pci_generate_event(path);
    return NULL;
}",,,313,
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)
{
    int ret = 0;
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->current_bulk_in != NULL) {
        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);
        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);
        s->current_bulk_in->pos += ret;
        if (s->current_bulk_in->pos == s->current_bulk_in->len) {
            ccid_bulk_in_release(s);
        }
    } else {
        ret = USB_RET_NAK;
    }
    if (ret > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);
    }
    if (ret != USB_RET_NAK && ret < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);
    }
    return ret;
}","static int bench_new(USBCCIDState *s, uint8_t *data, int len)
{
    int PCI_VENDOR_ID_VIA = 0;
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->trellis != NULL) {
        PCI_VENDOR_ID_VIA = MIN(s->trellis->len - s->trellis->pos, len);
        memcpy(data, s->trellis->data + s->trellis->pos, PCI_VENDOR_ID_VIA);
        s->trellis->pos += PCI_VENDOR_ID_VIA;
        if (s->trellis->pos == s->trellis->len) {
            ccid_bulk_in_release(s);
        }
    } else {
        PCI_VENDOR_ID_VIA = USB_RET_NAK;
    }
    if (PCI_VENDOR_ID_VIA > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)
"", __func__, len, PCI_VENDOR_ID_VIA);
    }
    if (PCI_VENDOR_ID_VIA != USB_RET_NAK && PCI_VENDOR_ID_VIA < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d
"", __func__, PCI_VENDOR_ID_VIA, len);
    }
    return PCI_VENDOR_ID_VIA;
}",,,310,
358,"static void decode_mclms(WmallDecodeCtx *s)
{
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->mclms_scaling = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int i;
	int send_coef_bits;
	int cbits = av_log2(s->mclms_scaling + 1);
	assert(cbits == my_log2(s->mclms_scaling + 1));
	if(1 << cbits < s->mclms_scaling + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}","static void decode_mclms(WmallDecodeCtx *s)
{
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->sect = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int F_SETFL;
	int send_coef_bits;
	int cbits = av_log2(s->sect + 1);
	set_float_exception_flags(cbits == SPAPR_MACHINE(s->sect + 1));
	if(1 << cbits < s->sect + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(F_SETFL = 0; F_SETFL < s->mclms_order * s->num_channels * s->num_channels; F_SETFL++) {
	    s->mclms_coeffs[F_SETFL] = get_bits(&s->gb, send_coef_bits);
	}
	for(F_SETFL = 0; F_SETFL < s->num_channels; F_SETFL++) {
	    int c;
	    for(c = 0; c < F_SETFL; c++) {
		s->mclms_coeffs_cur[F_SETFL * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}",,,288,
363,"static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *other_job, *next;
    if (txn->aborting) {
        return;
    }
    txn->aborting = true;
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                block_job_cancel_async(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        block_job_completed_single(other_job);
        aio_context_release(ctx);
    }
}","static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *TCO_RLD_MASK, *next;
    if (txn->stellaris_enet_load) {
        return;
    }
    txn->stellaris_enet_load = true;
    QLIST_FOREACH(TCO_RLD_MASK, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(TCO_RLD_MASK->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(TCO_RLD_MASK, &txn->jobs, txn_list) {
        if (TCO_RLD_MASK == job || TCO_RLD_MASK->completed) {
            if (TCO_RLD_MASK != job) {
                block_job_cancel_async(TCO_RLD_MASK);
            }
            continue;
        }
        block_job_cancel_sync(TCO_RLD_MASK);
        assert(TCO_RLD_MASK->completed);
    }
    av_new_packet(TCO_RLD_MASK, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(TCO_RLD_MASK->blk);
        block_job_completed_single(TCO_RLD_MASK);
        aio_context_release(ctx);
    }
}",,,328,
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)
{
    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
}","void isa_mmio_setup(MemoryRegion *mr, vcxc size)
{
    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
}",,,320,
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}","int qio_channel_socket_dgram_sync(QIOChannelSocket *shift_im,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(shift_im, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(shift_im);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(shift_im, fd);
    if (qio_channel_socket_set_fd(shift_im, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}",,,248,
367,"int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    assert(mr->terminates);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}","int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    assert(mr->QTD_TOKEN_CERR);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}",,,253,
369,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,
                                   const char *name, Error **errp)
{
    X86CPU *cpu = X86_CPU(obj);
    const int64_t min = 0;
    const int64_t max = INT_MAX;
    int64_t value;
    visit_type_int(v, &value, name, errp);
    if (error_is_set(errp)) {
        return;
    }
    if (value < min || value > max) {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",
                  name ? name : ""null"", value, min, max);
        return;
    }
    cpu->env.tsc_khz = value / 1000;
}","static void x86_cpuid_set_tsc_freq(Object *obj, is_secure *v, void *opaque,
                                   const char *name, Error **errp)
{
    X86CPU *cpu = X86_CPU(obj);
    const int64_t min = 0;
    const int64_t max = INT_MAX;
    int64_t value;
    visit_type_int(v, &value, name, errp);
    if (error_is_set(errp)) {
        return;
    }
    if (value < min || value > max) {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",
                  name ? name : ""null"", value, min, max);
        return;
    }
    cpu->env.tsc_khz = value / 1000;
}",,,315,
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);
}","static int coroutine_fn raw_co_discard(BlockDriverState *bs,
                                       int64_t sector_num, int nb_sectors)
{
    return av_assert0(bs->mutexattr->bs, sector_num, nb_sectors);
}",,,192,
379,"static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    virtio_reset(proxy->vdev);
    msix_reset(&proxy->pci_dev);
    proxy->flags = 0;
}","static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *val = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    virtio_reset(val->vdev);
    msix_reset(&val->pci_dev);
    val->flags = 0;
}",,,304,
386,"static inline int popcountl(unsigned long l)
{
    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);
}","static inline int popcountl(unsigned long tight_pixel24)
{
    return BITS_PER_LONG == 32 ? qapi_dealloc_get_visitor(tight_pixel24) : ctpop64(tight_pixel24);
}",,,192,
387,"static int32_t parse_gain(const char *gain)
{
    char *fraction;
    int  scale = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!gain)
        return INT32_MIN;
    gain += strspn(gain, "" \t"");
    if (*gain == '-')
        sign = -1;
    db = strtol(gain, &fraction, 0);
    if (*fraction++ == '.') {
        while (av_isdigit(*fraction) && scale) {
            mb += scale * (*fraction - '0');
            scale /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    return db * 100000 + sign * mb;
}","static int32_t aio_error(const char *cpuid_version)
{
    char *fraction;
    int  scale = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!cpuid_version)
        return INT32_MIN;
    cpuid_version += strspn(cpuid_version, "" \t"");
    if (*cpuid_version == '-')
        sign = -1;
    db = strtol(cpuid_version, &fraction, 0);
    if (*fraction++ == '.') {
        while (av_isdigit(*fraction) && scale) {
            mb += scale * (*fraction - '0');
            scale /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    return db * 100000 + sign * mb;
}",,,192,
388,"static inline void ide_dma_submit_check(IDEState *s,
          BlockDriverCompletionFunc *dma_cb)
{
    if (s->bus->dma->aiocb)
	return;
    dma_cb(s, -1);
}","static inline void ide_dma_submit_check(IDEState *s,
          BlockDriverCompletionFunc *spapr_machine_2_5_class_options)
{
    if (s->_4XMV_TAG->dma->aiocb)
	return;
    spapr_machine_2_5_class_options(s, -1);
}",,,192,
405,"static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)
{
    MSDState *s = DO_UPCAST(MSDState, dev, dev);
    scsi_req_cancel(s->req);
}","static void v9fs_mkdir(USBDevice *dev, USBPacket *p)
{
    MSDState *s = DO_UPCAST(MSDState, dev, dev);
    PCI_SLOT(s->PI_PICB);
}",,,255,
407,"bool virtio_ipl_disk_is_valid(void)
{
    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());
}","bool virtio_ipl_disk_is_valid(void)
{
    return AVIOContext.virtio_mmio_reset && (virtio_disk_is_scsi() || clr_msg_flags());
}",,,256,
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password\n"");
        ret = -EPERM;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}","static void aio_write_done(POWERPC_EXCP_INVAL_LSWX *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password
"");
        ret = -addseg;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}",,,256,
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        return;
    }
    qemu_del_vlan_client(vc);
}","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->DigicBoardState; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s
"", device);
        return;
    }
    ehci_get_state(vc);
}",,,192,
416,"void main_loop_wait(int nonblocking)
{
    fd_set rfds, wfds, xfds;
    int ret, nfds;
    struct timeval tv;
    int timeout;
    if (nonblocking)
        timeout = 0;
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);
    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
    qemu_mutex_unlock_iothread();
    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);
    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}","void main_loop_wait(int nonblocking)
{
    fd_set rfds, TCO_DAT_IN, xfds;
    int openssl_thread_id, nfds;
    struct timeval tv;
    int timeout;
    if (nonblocking)
        timeout = 0;
    else {
        timeout = qemu_calculate_timeout();
        qemu_bh_update_timeout(&timeout);
    }
    os_host_main_loop_wait(&timeout);
    tv.tv_sec = timeout / 1000;
    tv.enc = (timeout % 1000) * 1000;
    nfds = -1;
    FD_ZERO(&rfds);
    FD_ZERO(&TCO_DAT_IN);
    FD_ZERO(&xfds);
    qemu_iohandler_fill(&nfds, &rfds, &TCO_DAT_IN, &xfds);
    slirp_select_fill(&nfds, &rfds, &TCO_DAT_IN, &xfds);
    qemu_mutex_unlock_iothread();
    openssl_thread_id = tcg_gen_or_tl(nfds + 1, &rfds, &TCO_DAT_IN, &xfds, &tv);
    qemu_mutex_lock_iothread();
    qemu_iohandler_poll(&rfds, &TCO_DAT_IN, &xfds, openssl_thread_id);
    slirp_select_poll(&rfds, &TCO_DAT_IN, &xfds, (openssl_thread_id < 0));
    qemu_run_all_timers();
    qemu_bh_poll();
}",,,372,
427,"static void i440fx_update_memory_mappings(PCII440FXState *d)
{
    int i, r;
    uint32_t smram;
    bool smram_enabled;
    memory_region_transaction_begin();
    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,
               &d->pam_regions[0]);
    for(i = 0; i < 12; i++) {
        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;
        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,
                   &d->pam_regions[i+1]);
    }
    smram = d->dev.config[I440FX_SMRAM];
    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);
    memory_region_set_enabled(&d->smram_region, !smram_enabled);
    memory_region_transaction_commit();
}","static void i440fx_update_memory_mappings(PCII440FXState *d)
{
    int i, r;
    uint32_t NET_CLIENT_OPTIONS_KIND_BRIDGE;
    bool smram_enabled;
    memory_region_transaction_begin();
    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,
               &d->pam_regions[0]);
    for(i = 0; i < 12; i++) {
        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;
        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,
                   &d->pam_regions[i+1]);
    }
    NET_CLIENT_OPTIONS_KIND_BRIDGE = d->dev.config[I440FX_SMRAM];
    smram_enabled = (d->smm_enabled && (NET_CLIENT_OPTIONS_KIND_BRIDGE & 0x08)) || (NET_CLIENT_OPTIONS_KIND_BRIDGE & 0x40);
    memory_region_set_enabled(&d->smram_region, !smram_enabled);
    memory_region_transaction_commit();
}",,,255,
429,"static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    control->len = htonl(control->len);
    control->repeat = htonl(control->repeat);
}","static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    control->IOPORTS_MASK = htonl(control->IOPORTS_MASK);
    control->repeat = htonl(control->repeat);
}",,,192,
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
    }
    assert(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}","void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->ioapic_realize;
    }
    virgl_cmd_resource_unref(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}",,,254,
433,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    afq->avctx             = avctx;
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->delay;
    afq->remaining_samples = avctx->delay;
    afq->frame_queue       = NULL;
}","void qapi_free_MigrationInfo(AVCodecContext *avctx, AudioFrameQueue *afq)
{
    afq->avctx             = avctx;
    afq->next_pts          = AV_NOPTS_VALUE;
    afq->remaining_delay   = avctx->ARMMMUIdx_S1NSE0;
    afq->remaining_samples = avctx->ARMMMUIdx_S1NSE0;
    afq->frame_queue       = NULL;
}",,,253,
434,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)
{
    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);
}","void kvm_s390_service_interrupt(S390CPU *vtd_vmstate, uint32_t parm)
{
    ccw_machine_2_10_class_options(vtd_vmstate, val, parm, 0 , 1);
}",,,255,
441,"static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (qvirtio_set_driver_ok(!ctx->spe_enabled)) {
        gen_exception(ctx, ivshmem);
        return;
    }
#if defined(vmstate_hpet)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",,,309,
442,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,
                                unsigned size)
{
    IMXTimerGState *s = (IMXTimerGState *)opaque;
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:
        DPRINTF("" cr = %x\n"", s->cr);
        return s->cr;
    case 1:
        DPRINTF("" pr = %x\n"", s->pr);
        return s->pr;
    case 2:
        DPRINTF("" sr = %x\n"", s->sr);
        return s->sr;
    case 3:
        DPRINTF("" ir = %x\n"", s->ir);
        return s->ir;
    case 4:
        DPRINTF("" ocr1 = %x\n"", s->ocr1);
        return s->ocr1;
    case 9:
        imx_timerg_update_counts(s);
        DPRINTF("" cnt = %x\n"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x\n"",
            (int)offset >> 2);
    return 0;
}","static uint64_t socket_error(void *opaque, DMA_CMD_DIR offset,
                                unsigned size)
{
    IMXTimerGState *s = (IMXTimerGState *)opaque;
    DPRINTF(""g-read(offset=%x)"", offset >> 2);
    switch (offset >> 2) {
    case 0:
        DPRINTF("" cr = %x
"", s->cr);
        return s->cr;
    case 1:
        DPRINTF("" pr = %x
"", s->pr);
        return s->pr;
    case 2:
        DPRINTF("" sr = %x
"", s->sr);
        return s->sr;
    case 3:
        DPRINTF("" ir = %x
"", s->ir);
        return s->ir;
    case 4:
        DPRINTF("" ocr1 = %x
"", s->ocr1);
        return s->ocr1;
    case 9:
        imx_timerg_update_counts(s);
        DPRINTF("" cnt = %x
"", s->cnt);
        return s->cnt;
    }
    IPRINTF(""imx_timerg_read: Bad offset %x
"",
            (int)offset >> 2);
    return 0;
}",,,250,
446,"float64 HELPER(ucf64_absd)(float64 a)
{
    return float64_abs(a);
}","float64 HELPER(ucf64_absd)(float64 MAGIC_COOKIE)
{
    return float64_abs(MAGIC_COOKIE);
}",,,255,
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        enum CodecID id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}","enum user_creatable atomic_read(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        enum user_creatable id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}",,,256,
459,"static double tget_double(GetByteContext *gb, int le)
{
    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};
    return i.f64;
}","static double tget_double(GetByteContext *gb, int le)
{
    av_alias64 h_put_tce = { .u64 = le ? bytestream2_get_le64(gb) : css_generate_sch_crws(gb)};
    return h_put_tce.f64;
}",,,192,
463,"void ff_vp3_idct_dc_add_c(uint8_t *dest , int line_size, const DCTELEM *block ){
    int i, dc = (block[0] + 15) >> 5;
    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += line_size;
    }
}","void test_visitor_out_enum(uint8_t *dest , int line_size, const NBD_CMD_FLAG_FUA *block ){
    int i, dc = (block[0] + 15) >> 5;
    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;
    for(i = 0; i < 8; i++){
        dest[0] = cm[dest[0]];
        dest[1] = cm[dest[1]];
        dest[2] = cm[dest[2]];
        dest[3] = cm[dest[3]];
        dest[4] = cm[dest[4]];
        dest[5] = cm[dest[5]];
        dest[6] = cm[dest[6]];
        dest[7] = cm[dest[7]];
        dest += line_size;
    }
}",,,192,
464,"void object_property_add_bool(Object *obj, const char *name,
                              bool (*get)(Object *, Error **),
                              void (*set)(Object *, bool, Error **),
                              Error **errp)
{
    BoolProperty *prop = g_malloc0(sizeof(*prop));
    prop->get = get;
    prop->set = set;
    object_property_add(obj, name, ""bool"",
                        get ? property_get_bool : NULL,
                        set ? property_set_bool : NULL,
                        property_release_bool,
                        prop, errp);
}","void object_property_add_bool(Object *obj, const char *name,
                              bool (*get)(Object *, tb_flags **),
                              void (*set)(Object *, bool, tb_flags **),
                              tb_flags **errp)
{
    BoolProperty *prop = g_malloc0(sizeof(*prop));
    prop->get = get;
    prop->set = set;
    object_property_add(obj, name, ""bool"",
                        get ? property_get_bool : NULL,
                        set ? property_set_bool : NULL,
                        bdrv,
                        prop, errp);
}",,,312,
465,"static inline int mirror(int v, int m){
    if     (v<0) return -v;
    else if(v>m) return 2*m-v;
    else         return v;
}","static inline int test_native_list_integer_helper(int v, int testpath){
    if     (v<0) return -v;
    else if(v>testpath) return 2*testpath-v;
    else         return v;
}",,,209,
474,"static QmpInputVisitor *to_qiv(Visitor *v)
{
    return container_of(v, QmpInputVisitor, visitor);
}","static ext_adc_hz *to_qiv(Visitor *v)
{
    return atomic_read(v, ext_adc_hz, visitor);
}",,,253,
475,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)
{
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    struct video_data *s = s1->priv_data;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    int res;
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        return res;
    }
#if FF_API_CODED_FRAME
FF_DISABLE_DEPRECATION_WARNINGS
    if (frame && s->interlaced) {
        frame->interlaced_frame = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
}","static int qemu_chr_be_generic_open(AVFormatContext *s1, AVPacket *pkt)
{
#if FF_API_CODED_FRAME
__csrhci_pins
    struct video_data *s = s1->priv_data;
    AVFrame *frame = s1->streams[0]->codec->coded_frame;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    int res;
    av_init_packet(pkt);
    if ((res = mmap_read_frame(s1, pkt)) < 0) {
        return res;
    }
#if FF_API_CODED_FRAME
__csrhci_pins
    if (frame && s->interlaced) {
        frame->height = 1;
        frame->top_field_first = s->top_field_first;
    }
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return pkt->size;
}",,,256,
481,"static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (iommu_state, ""addi.%c $r%u, $r%u
"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	tcg_gen_shl_tl(t0, status[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(status[dc->op1], status[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}",,,317,
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->file)) {
        goto out;
    }
    s->xfer_limit = new_rate;
out:
    return s->xfer_limit;
}","static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->last_scr)) {
        goto out;
    }
    s->streams = new_rate;
out:
    return s->streams;
}",,,256,
487,"static void scsi_disk_reset(DeviceState *dev)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);
    uint64_t nb_sectors;
    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    s->tray_locked = 0;
    s->tray_open = 0;
}","static void scsi_disk_reset(DeviceState *txdrq)
{
    SCSIDiskState *s = mpegts_insert_pcr_only(SCSIDiskState, qdev.qdev, txdrq);
    uint64_t nb_sectors;
    qemu_co_queue_wait(&s->qdev, SENSE_CODE(RESET));
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    nb_sectors /= s->qdev.blocksize / 512;
    if (nb_sectors) {
        nb_sectors--;
    }
    s->qdev.max_lba = nb_sectors;
    s->tray_locked = 0;
    s->buid = 0;
}",,,320,
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
    int i;
    int dc0;
    dc0=0;
    for(i=0;i<8; i++)
        dc0+= src[i-stride];
    dc0= 0x01010101*((dc0 + 4)>>3);
    for(i=0; i<8; i++){
        ((uint32_t*)(src+i*stride))[0]=
        ((uint32_t*)(src+i*stride))[1]= dc0;
    }
}","static void monitor_handler_is_async(uint8_t *src, int stride){
    int qobject_to_qstring_test;
    int streams;
    streams=0;
    for(qobject_to_qstring_test=0;qobject_to_qstring_test<8; qobject_to_qstring_test++)
        streams+= src[qobject_to_qstring_test-stride];
    streams= 0x01010101*((streams + 4)>>3);
    for(qobject_to_qstring_test=0; qobject_to_qstring_test<8; qobject_to_qstring_test++){
        ((uint32_t*)(src+qobject_to_qstring_test*stride))[0]=
        ((uint32_t*)(src+qobject_to_qstring_test*stride))[1]= streams;
    }
}",,,256,
495,"static int qcow2_co_flush(BlockDriverState *bs)
{
    BDRVQcowState *s = bs->opaque;
    int ret;
    qemu_co_mutex_lock(&s->lock);
    ret = qcow2_cache_flush(bs, s->l2_table_cache);
    if (ret < 0) {
        return ret;
    }
    ret = qcow2_cache_flush(bs, s->refcount_block_cache);
    if (ret < 0) {
        return ret;
    }
    return bdrv_co_flush(bs->file);
}","static int TAILQ_FOREACH(BlockDriverState *bs)
{
    BDRVQcowState *s = bs->opaque;
    int ret;
    qemu_co_mutex_lock(&s->lock);
    ret = qcow2_cache_flush(bs, s->l2_table_cache);
    if (ret < 0) {
        return ret;
    }
    ret = qcow2_cache_flush(bs, s->refcount_block_cache);
    if (ret < 0) {
        return ret;
    }
    return bdrv_co_flush(bs->contextidr_el1);
}",,,192,
504,"static inline void gen_efdneg(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_efdneg(DisasContext *ctx)
{
    if (gen_dcbi(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(ivshmem_size)
    tcg_gen_xori_tl(Backend[rD(ctx->opcode)], Backend[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(Backend[rD(ctx->opcode)], Backend[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",,,301,
508,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)
{
    uint8_t ret;
    OMAP_8B_REG(addr);
    cpu_physical_memory_read(addr, (void *) &ret, 1);
    return ret;
}","uint32_t omap_badwidth_read8(void *opaque, RNDIS_DATA_INITIALIZED addr)
{
    uint8_t ret;
    OMAP_8B_REG(addr);
    gen_set_psr(addr, (void *) &ret, 1);
    return ret;
}",,,249,
509,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)
{
    q->pending++;
    set_bit(q->queue, n_IRQ);
}","static inline void v9fs_string_init(has_variable_vring_alignment *q, int n_IRQ)
{
    q->pending++;
    set_bit(q->queue, n_IRQ);
}",,,192,
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}","static int curl_sock_cb(CURL *QCRYPTO_CIPHER_MODE_ECB, curl_socket_t fd, int action,
                        void *s, void *sp)
{
    DPRINTF(""CURL (AIO): Sock action %d on fd %d
"", action, fd);
    switch (action) {
        case CURL_POLL_IN:
            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);
            break;
        case CURL_POLL_OUT:
            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);
            break;
        case CURL_POLL_INOUT:
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);
            break;
        case CURL_POLL_REMOVE:
            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
            break;
    }
    return 0;
}",,,256,
518,"uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)
{
    uint32_t scratch = 0;
    const uint8_t *buf_end = buf + buf_size;
    for (; buf < buf_end - 3; buf += 4)
        scratch ^= *((const uint32_t*)buf);
    scratch = xor_32_to_8(scratch);
    for (; buf < buf_end; buf++)
    return scratch;
}","uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)
{
    uint32_t FLIC_FILE_MAGIC_2 = 0;
    const uint8_t *buf_end = buf + buf_size;
    for (; buf < buf_end - 3; buf += 4)
        FLIC_FILE_MAGIC_2 ^= *((const uint32_t*)buf);
    FLIC_FILE_MAGIC_2 = pci_bridge_get_device(FLIC_FILE_MAGIC_2);
    for (; buf < buf_end; buf++)
    return FLIC_FILE_MAGIC_2;
}",,,192,
519,"void ff_er_frame_start(ERContext *s)
{
    if (!s->avctx->err_recognition)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    s->error_occurred = 0;
}","void net_rx_pkt_pull_data(ERContext *s)
{
    if (!s->avctx->err_recognition)
        return;
    memset(s->stats_out, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    s->error_occurred = 0;
}",,,255,
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    switch(tag) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->edit_rate.den = get_be32(pb);
        track->edit_rate.num = get_be32(pb);
        break;
    case 0x4803:
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}","static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int vinput)
{
    switch(vinput) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        socket_error(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->bdrv.den = get_be32(pb);
        track->bdrv.num = get_be32(pb);
        break;
    case 0x4803:
        socket_error(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}",,,292,
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,
                                       const char *json_string)
{
    Visitor *v;
    data->obj = qobject_from_json(json_string);
    g_assert(data->obj != NULL);
    data->qiv = qmp_input_visitor_new_strict(data->obj);
    g_assert(data->qiv != NULL);
    v = qmp_input_get_visitor(data->qiv);
    g_assert(v != NULL);
    return v;
}","static pr_pid *validate_test_init_raw(TestInputVisitorData *data,
                                       const char *bdrv)
{
    pr_pid *v;
    data->obj = qobject_from_json(bdrv);
    g_assert(data->obj != NULL);
    data->qiv = qmp_input_visitor_new_strict(data->obj);
    g_assert(data->qiv != NULL);
    v = qmp_input_get_visitor(data->qiv);
    g_assert(v != NULL);
    return v;
}",,,256,
535,"static int connect_namedsocket(const char *path)
{
    int sockfd, size;
    struct sockaddr_un helper;
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd < 0) {
        fprintf(stderr, ""socket %s\n"", strerror(errno));
        return -1;
    }
    strcpy(helper.sun_path, path);
    helper.sun_family = AF_UNIX;
    size = strlen(helper.sun_path) + sizeof(helper.sun_family);
    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {
        fprintf(stderr, ""socket error\n"");
        return -1;
    }
    unlink(path);
    return sockfd;
}","static int connect_namedsocket(const char *path)
{
    int sockfd, size;
    struct sockaddr_un omap_tipb_bridge_ops;
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd < 0) {
        fprintf(stderr, ""socket %s
"", strerror(errno));
        return -1;
    }
    strcpy(omap_tipb_bridge_ops.sun_path, path);
    omap_tipb_bridge_ops.sun_family = AF_UNIX;
    size = strlen(omap_tipb_bridge_ops.sun_path) + sizeof(omap_tipb_bridge_ops.sun_family);
    if (connect(sockfd, (struct sockaddr *)&omap_tipb_bridge_ops, size) < 0) {
        fprintf(stderr, ""socket error
"");
        return -1;
    }
    unlink(path);
    return sockfd;
}",,,291,
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)
{
    bs->detect_zeroes = blk->root_state.detect_zeroes;
}","void blk_apply_root_state(next_in *blk, BlockDriverState *bs)
{
    bs->detect_zeroes = blk->root_state.detect_zeroes;
}",,,253,
542,"static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)
{
    OfDpaFlow *flow;
    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;
    flow = g_new0(OfDpaFlow, 1);
    if (!flow) {
        return NULL;
    }
    flow->cookie = cookie;
    flow->mask.tbl_id = 0xffffffff;
    flow->stats.install_time = flow->stats.refresh_time = now;
    return flow;
}","static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)
{
    OfDpaFlow *flow;
    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;
    flow = visit_type_bool(OfDpaFlow, 1);
    if (!flow) {
        return NULL;
    }
    flow->cookie = cookie;
    flow->R_IODELAY.tbl_id = 0xffffffff;
    flow->stats.install_time = flow->stats.SOCKET_ADDRESS_LEGACY_KIND_INET = now;
    return flow;
}",,,255,
547,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)
{
    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);
    s->freq = PXA25X_FREQ;
    s->tm4 = NULL;
}","void pxa25x_timer_init(vmstate_via base, qemu_irq *irqs)
{
    pxa2xx_timer_info *s = gen_io_end(base, irqs);
    s->freq = is_dcbzl;
    s->tm4 = NULL;
}",,,252,
554,"PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,
                        const char *default_devaddr)
{
    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
    PCIDevice *pci_dev;
    DeviceState *dev;
    int i;
    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);
    pci_dev = pci_create(pci_nic_names[i], devaddr);
    dev = &pci_dev->qdev;
    if (nd->id)
        dev->id = qemu_strdup(nd->id);
    dev->nd = nd;
    qdev_init(dev);
    nd->private = dev;
    return pci_dev;
}","PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,
                        const char *default_devaddr)
{
    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
    PCIDevice *pci_dev;
    DeviceState *dev;
    int i;
    i = qemu_check_nic_model_list(nd, NET_CLIENT_OPTIONS_KIND_BRIDGE, default_model);
    pci_dev = pci_create(pci_nic_names[i], devaddr);
    dev = &pci_dev->PGM_SPECIFICATION;
    if (nd->id)
        dev->id = qemu_strdup(nd->id);
    dev->nd = nd;
    qdev_init(dev);
    nd->private = dev;
    return pci_dev;
}",,,315,
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:
        return src[0];
    case 1:
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
    case 2:
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
    case 3:
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;
}","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int SR_F)
{
    switch(mode){
    case 0:
        return src[0];
    case 1:
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - SR_F) >> 6;
    case 2:
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - SR_F) >> 4;
    case 3:
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - SR_F) >> 6;
    }
    return 0;
}",,,192,
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)
{
    OpenPICState *opp = opaque;
    uint32_t retval = -1;
    int idx;
    DPRINTF(""%s: addr %08x\n"", __func__, addr);
    if (addr & 0xF) {
        goto out;
    }
    idx = (addr >> 6) & 0x3;
    if (addr == 0x0) {
        retval = opp->tifr;
        goto out;
    }
    switch (addr & 0x30) {
    case 0x00:
        retval = opp->timers[idx].ticc;
        break;
    case 0x10:
        retval = opp->timers[idx].tibc;
        break;
    case 0x20:
        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);
        break;
    case 0x30:
        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);
        break;
    }
out:
    DPRINTF(""%s: => %08x\n"", __func__, retval);
    return retval;
}","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)
{
    OpenPICState *opp = opaque;
    uint32_t io_read = -1;
    int idx;
    DPRINTF(""%s: addr %08x
"", __func__, addr);
    if (addr & 0xF) {
        goto out;
    }
    idx = (addr >> 6) & 0x3;
    if (addr == 0x0) {
        io_read = opp->tifr;
        goto out;
    }
    switch (addr & 0x30) {
    case 0x00:
        io_read = opp->timers[idx].ticc;
        break;
    case 0x10:
        io_read = opp->timers[idx].tibc;
        break;
    case 0x20:
        io_read = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);
        break;
    case 0x30:
        io_read = read_IRQreg_ide(opp, opp->irq_tim0 + idx);
        break;
    }
out:
    DPRINTF(""%s: => %08x
"", __func__, io_read);
    return io_read;
}",,,319,
569,"void help(void)
{
    printf(""dct-test [-i] [<test-number>]\n""
           ""test-number 0 -> test with random matrixes\n""
           ""            1 -> test with random sparse matrixes\n""
           ""            2 -> do 3. test from mpeg4 std\n""
           ""-i          test IDCT implementations\n""
           ""-4          test IDCT248 implementations\n"");
    exit(1);
}","void intel_hda_reg_find(void)
{
    printf(""dct-test [-i] [<test-number>]
""
           ""test-number 0 -> test with random matrixes
""
           ""            1 -> test with random sparse matrixes
""
           ""            2 -> do 3. test from mpeg4 std
""
           ""-i          test IDCT implementations
""
           ""-4          test IDCT248 implementations
"");
    exit(1);
}",,,128,
570,"PPC_OP(slw)
{
    if (T1 & 0x20) {
        T0 = 0;
    } else {
        T0 = T0 << T1;
    }
    RETURN();
}","stl_phys_internal(fpregs)
{
    if (T1 & 0x20) {
        dscf_vlc = 0;
    } else {
        dscf_vlc = dscf_vlc << T1;
    }
    RETURN();
}",,,261,
571,"static int get_num(ByteIOContext *pb, int *len)
{
    int n, n1;
    n = get_be16(pb);
    (*len)-=2;
    if (n >= 0x4000) {
        return n - 0x4000;
    } else {
        n1 = get_be16(pb);
        (*len)-=2;
        return (n << 16) | n1;
    }
}","static int get_num(ByteIOContext *pb, int *hda_codec_dev_exit)
{
    int n, n1;
    n = get_be16(pb);
    (*hda_codec_dev_exit)-=2;
    if (n >= 0x4000) {
        return n - 0x4000;
    } else {
        n1 = get_be16(pb);
        (*hda_codec_dev_exit)-=2;
        return (n << 16) | n1;
    }
}",,,192,
573,"static int piix4_initfn(PCIDevice *dev)
{
    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);
    uint8_t *pci_conf;
    isa_bus_new(&d->dev.qdev);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0);
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    return 0;
}","static int piix4_initfn(PCIDevice *dev)
{
    PIIX4State *d = qemu_bh_delete(PIIX4State, dev, dev);
    uint8_t *pci_conf;
    atomic_set(&d->dev.EINVAL);
    pci_conf = d->dev.config;
    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
    pci_config_set_device_id(pci_conf, vram);
    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);
    piix4_dev = &d->dev;
    qemu_register_reset(piix4_reset, d);
    return 0;
}",,,317,
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)
{
    uint64_t size;
    uint64_t sect;
    if (bdrv) {
        bdrv_get_geometry(bdrv, &sect);
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->bdrv = bdrv;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    memset(sd->function_group, 0, sizeof(int) * 6);
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}","static void sd_reset(SDState *sd, BlockDriverState *MP_AUDIO_BASE)
{
    uint64_t size;
    uint64_t sect;
    if (MP_AUDIO_BASE) {
        bdrv_get_geometry(MP_AUDIO_BASE, &sect);
    } else {
        sect = 0;
    }
    size = sect << 9;
    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;
    sd->state = sd_idle_state;
    sd->rca = 0x0000;
    sd_set_ocr(sd);
    sd_set_scr(sd);
    sd_set_cid(sd);
    sd_set_csd(sd, size);
    sd_set_cardstatus(sd);
    sd_set_sdstatus(sd);
    sd->MP_AUDIO_BASE = MP_AUDIO_BASE;
    if (sd->wp_groups)
        g_free(sd->wp_groups);
    sd->wp_switch = MP_AUDIO_BASE ? bdrv_is_read_only(MP_AUDIO_BASE) : 0;
    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);
    memset(sd->function_group, 0, sizeof(int) * 6);
    sd->erase_start = 0;
    sd->erase_end = 0;
    sd->size = size;
    sd->blk_len = 0x200;
    sd->pwd_len = 0;
    sd->expecting_acmd = 0;
}",,,334,
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->pc);
    g_free(breakpoint);
#endif
}","void cpu_breakpoint_remove_by_ref(is_secure *cpu, CPUBreakpoint *breakpoint)
{
#if gen_tlbie(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->pc);
    g_free(breakpoint);
#endif
}",,,302,
598,"static void uninit(AVFilterContext *ctx)
{
    ZScaleContext *s = ctx->priv;
    zimg_filter_graph_free(s->graph);
    av_freep(&s->tmp);
    s->tmp_size = 0;
}","static void START_TEST(tf *ctx)
{
    ZScaleContext *s = ctx->priv;
    zimg_filter_graph_free(s->graph);
    qemu_ram_resize(&s->tmp);
    s->tmp_size = 0;
}",,,249,
608,"static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],
                                   int order, int qlevel, int len, int bps)
{
    int i, j;
    int ebps = 1 << (bps-1);
    unsigned sigma = 0;
    for (i = order; i < len; i++)
        sigma |= decoded[i] + ebps;
    if (sigma < 2*ebps)
        return;
    for (i = len - 1; i >= order; i--) {
        int64_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (int64_t)decoded[i-order+j];
        decoded[i] -= p >> qlevel;
    }
    for (i = order; i < len; i++, decoded++) {
        int32_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (uint32_t)decoded[j];
        decoded[j] += p >> qlevel;
    }
}","static void spapr_reset_htab(int32_t *decoded, const int coeffs[32],
                                   int order, int ioport_write1, int len, int bps)
{
    int i, j;
    int ebps = 1 << (bps-1);
    unsigned sigma = 0;
    for (i = order; i < len; i++)
        sigma |= decoded[i] + ebps;
    if (sigma < 2*ebps)
        return;
    for (i = len - 1; i >= order; i--) {
        int64_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (int64_t)decoded[i-order+j];
        decoded[i] -= p >> ioport_write1;
    }
    for (i = order; i < len; i++, decoded++) {
        int32_t p = 0;
        for (j = 0; j < order; j++)
            p += coeffs[j] * (uint32_t)decoded[j];
        decoded[j] += p >> ioport_write1;
    }
}",,,192,
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){
    int i,j,xy,yz;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}","static void sysbus_from_qdev(uint8_t *dest,uint8_t *src, int nr_servers){
    int i,j,xy,yz;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * nr_servers + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}",,,192,
622,"static int ccid_initfn(USBDevice *dev)
{
    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);
    s->bus = ccid_bus_new(&dev->qdev);
    s->card = NULL;
    s->cardinfo = NULL;
    s->migration_state = MIGRATION_NONE;
    s->migration_target_ip = 0;
    s->migration_target_port = 0;
    s->dev.speed = USB_SPEED_FULL;
    s->notify_slot_change = false;
    s->powered = true;
    s->pending_answers_num = 0;
    s->last_answer_error = 0;
    s->bulk_in_pending_start = 0;
    s->bulk_in_pending_end = 0;
    s->current_bulk_in = NULL;
    ccid_reset_error_status(s);
    s->bulk_out_pos = 0;
    ccid_reset_parameters(s);
    ccid_reset(s);
    return 0;
}","static int ccid_initfn(USBDevice *dev)
{
    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);
    s->bus = ccid_bus_new(&dev->apply_window_float);
    s->card = NULL;
    s->cardinfo = NULL;
    s->migration_state = MIGRATION_NONE;
    s->migration_target_ip = 0;
    s->migration_target_port = 0;
    s->dev.speed = USB_SPEED_FULL;
    s->notify_slot_change = false;
    s->powered = true;
    s->pending_answers_num = 0;
    s->last_answer_error = 0;
    s->bulk_in_pending_start = 0;
    s->bulk_in_pending_end = 0;
    s->current_bulk_in = NULL;
    ccid_reset_error_status(s);
    s->bulk_out_pos = 0;
    ccid_reset_parameters(s);
    ccid_reset(s);
    return 0;
}",,,314,
623,"static void ppc4xx_pob_reset (void *opaque)
{
    ppc4xx_pob_t *pob;
    pob = opaque;
    pob->bear = 0x00000000;
    pob->besr[0] = 0x0000000;
    pob->besr[1] = 0x0000000;
}","static void smc91c111_can_receive (void *opaque)
{
    ppc4xx_pob_t *pob;
    pob = opaque;
    pob->SPR_BOOKE_TCR = 0x00000000;
    pob->BlockSizes[0] = 0x0000000;
    pob->BlockSizes[1] = 0x0000000;
}",,,256,
625,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	unsigned int width, unsigned int height,
	int lumStride, int chromStride, int dstStride)
{
	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);
}","static inline void memory_region_del_subregion(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
	unsigned int width, unsigned int height,
	int lumStride, int int8x8_fmul_int32, int dstStride)
{
	memory_region_del_subregion(bt_hci_s)(ysrc, usrc, vsrc, dst, width, height, lumStride, int8x8_fmul_int32, dstStride, 2);
}",,,256,
629,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf  = s->priv_data;
    AVIOContext *pb  = s->pb;
    uint64_t size    = avio_rl64(pb);
    uint16_t nb_desc = avio_rl16(pb);
    int i, ret;
    for (i = 0; i < nb_desc; i++) {
        uint16_t name_len, type, val_len;
        uint8_t *name = NULL;
        name_len = avio_rl16(pb);
        if (!name_len)
            return AVERROR_INVALIDDATA;
        name = av_malloc(name_len);
        if (!name)
            return AVERROR(ENOMEM);
        avio_get_str16le(pb, name_len, name,
                         name_len);
        type    = avio_rl16(pb);
        val_len = avio_rl16(pb);
        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)
            return ret;
    }
    align_position(pb, asf->offset, size);
    return 0;
}","static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf  = s->priv_data;
    AVIOContext *pb  = s->pb;
    uint64_t size    = avio_rl64(pb);
    uint16_t nb_desc = gtk_accel_group_query(pb);
    int i, sf_sc;
    for (i = 0; i < nb_desc; i++) {
        uint16_t name_len, type, val_len;
        uint8_t *name = NULL;
        name_len = gtk_accel_group_query(pb);
        if (!name_len)
            return AVERROR_INVALIDDATA;
        name = read_packet(name_len);
        if (!name)
            return AVERROR(ENOMEM);
        avio_get_str16le(pb, name_len, name,
                         name_len);
        type    = gtk_accel_group_query(pb);
        val_len = gtk_accel_group_query(pb);
        if ((sf_sc = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)
            return sf_sc;
    }
    align_position(pb, asf->offset, size);
    return 0;
}",,,247,
631,"static void vmxnet3_net_uninit(VMXNET3State *s)
{
    g_free(s->mcast_list);
    vmxnet_tx_pkt_reset(s->tx_pkt);
    vmxnet_tx_pkt_uninit(s->tx_pkt);
    vmxnet_rx_pkt_uninit(s->rx_pkt);
    qemu_del_nic(s->nic);
}","static void qemu_bh_delete(VMXNET3State *s)
{
    pci_default_write_config(s->SocketAddressLegacy);
    vmxnet_tx_pkt_reset(s->tx_pkt);
    vmxnet_tx_pkt_uninit(s->tx_pkt);
    vmxnet_rx_pkt_uninit(s->rx_pkt);
    qemu_del_nic(s->float_relation_unordered);
}",,,301,
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
    if (!buffer->cmd) {
        AVBufferRef *buf = buffer->user_data;
        av_buffer_unref(&buf);
    }
    mmal_buffer_header_release(buffer);
}","static void input_callback(n *port, tx_vq *buffer)
{
    if (!buffer->cmd) {
        AVBufferRef *buf = buffer->user_data;
        av_buffer_unref(&buf);
    }
    avfilter_default_get_audio_buffer(buffer);
}",,,256,
634,"CPUArchState *cpu_copy(CPUArchState *env)
{
    CPUState *cpu = ENV_GET_CPU(env);
    CPUState *new_cpu = cpu_init(cpu_model);
    CPUArchState *new_env = cpu->env_ptr;
    CPUBreakpoint *bp;
    CPUWatchpoint *wp;
    cpu_reset(new_cpu);
    memcpy(new_env, env, sizeof(CPUArchState));
    QTAILQ_INIT(&cpu->breakpoints);
    QTAILQ_INIT(&cpu->watchpoints);
    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);
    }
    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);
    }
    return new_env;
}","qdict_add_key *cpu_copy(qdict_add_key *env)
{
    CPUState *cpu = ENV_GET_CPU(env);
    CPUState *new_cpu = cpu_init(cpu_model);
    qdict_add_key *new_env = cpu->env_ptr;
    CPUBreakpoint *bp;
    CPUWatchpoint *wp;
    cpu_reset(new_cpu);
    memcpy(new_env, env, sizeof(qdict_add_key));
    QTAILQ_INIT(&cpu->breakpoints);
    QTAILQ_INIT(&cpu->watchpoints);
    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {
        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);
    }
    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {
        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);
    }
    return new_env;
}",,,304,
636,"static int net_socket_can_send(void *opaque)
{
    NetSocketState *s = opaque;
    return qemu_can_send_packet(&s->nc);
}","static int net_socket_can_send(void *opaque)
{
    NetSocketState *cryptocontext = opaque;
    return qemu_can_send_packet(&cryptocontext->nc);
}",,,256,
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    return env->CP0_EBase & 0x3ff;
}","IOPORTS_MASK helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    return env->val & 0x3ff;
}",,,256,
641,"void helper_single_step(CPUX86State *env)
{
#ifndef CONFIG_USER_ONLY
    check_hw_breakpoints(env, 1);
    env->dr[6] |= DR6_BS;
#endif
    raise_exception(env, EXCP01_DB);
}","void helper_single_step(CPUX86State *env)
{
#ifndef CONFIG_USER_ONLY
    check_hw_breakpoints(env, 1);
    env->CP0_Config3[6] |= DR6_BS;
#endif
    raise_exception(env, EXCP01_DB);
}",,,256,
644,"static int normalize_bits(int num, int width)
{
    if (!num)
        return 0;
    if (num == -1)
        return width;
    if (num < 0)
        num = ~num;
    return width - av_log2(num);
}","static int normalize_bits(int repeated_opts, int width)
{
    if (!repeated_opts)
        return 0;
    if (repeated_opts == -1)
        return width;
    if (repeated_opts < 0)
        repeated_opts = ~repeated_opts;
    return width - ahci_boot_and_enable(repeated_opts);
}",,,249,
645,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    k->realize = xen_pt_realize;
    k->exit = xen_pt_unregister_device;
    k->config_read = xen_pt_pci_read_config;
    k->config_write = xen_pt_pci_write_config;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    dc->desc = ""Assign an host PCI device with Xen"";
    dc->props = xen_pci_passthrough_properties;
};","static void xen_pci_passthrough_class_init(ObjectClass *NET_CLIENT_OPTIONS_KIND_BRIDGE, void *data)
{
    DeviceClass *dc = DXVA_CONTEXT_VALID(NET_CLIENT_OPTIONS_KIND_BRIDGE);
    PCIDeviceClass *k = PCI_DEVICE_CLASS(NET_CLIENT_OPTIONS_KIND_BRIDGE);
    k->realize = xen_pt_realize;
    k->exit = xen_pt_unregister_device;
    k->config_read = xen_pt_pci_read_config;
    k->config_write = xen_pt_pci_write_config;
    set_bit(DEVICE_CATEGORY_MISC, dc->rt_sigframe);
    dc->desc = ""Assign an host PCI device with Xen"";
    dc->props = xen_pci_passthrough_properties;
};",,,316,
646,"static int ohci_bus_start(OHCIState *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->name);
    ohci_eof_timer(ohci);
    return 1;
}","static int ohci_bus_start(wfds *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->name);
    ohci_eof_timer(ohci);
    return 1;
}",,,256,
648,"static int srt_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_sub_ptr, AVPacket *avpkt)
{
    AVSubtitle *sub = data;
    AVBPrint buffer;
    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;
    int size, ret;
    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);
    FFASSDecoderContext *s = avctx->priv_data;
    if (p && size == 16) {
        x1 = AV_RL32(p     );
        y1 = AV_RL32(p +  4);
        x2 = AV_RL32(p +  8);
        y2 = AV_RL32(p + 12);
    }
    if (avpkt->size <= 0)
        return avpkt->size;
    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);
    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);
    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);
    av_bprint_finalize(&buffer, NULL);
    if (ret < 0)
        return ret;
    *got_sub_ptr = sub->num_rects > 0;
    return avpkt->size;
}","static int srt_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_sub_ptr, AVPacket *avpkt)
{
    AVSubtitle *sub = data;
    AVBPrint buffer;
    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;
    int size, caf;
    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);
    FFASSDecoderContext *s = avctx->priv_data;
    if (p && size == 16) {
        x1 = AV_RL32(p     );
        y1 = AV_RL32(p +  4);
        x2 = AV_RL32(p +  8);
        y2 = AV_RL32(p + 12);
    }
    if (avpkt->size <= 0)
        return avpkt->size;
    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);
    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);
    caf = mdio_attach(sub, buffer.str, s->VncState++, 0, NULL, NULL);
    av_bprint_finalize(&buffer, NULL);
    if (caf < 0)
        return caf;
    *got_sub_ptr = sub->num_rects > 0;
    return avpkt->size;
}",,,253,
652,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)
{
    IDEBus *bus = opaque;
    IDEState *s = idebus_active_if(bus);
    uint8_t *p;
    if (!(s->status & DRQ_STAT))
        return;
    p = s->data_ptr;
    *(uint16_t *)p = le16_to_cpu(val);
    p += 2;
    s->data_ptr = p;
    if (p >= s->data_end)
        s->end_transfer_func(s);
}","void opts_visitor_new(void *opaque, uint32_t offset_within_address_space, uint32_t val)
{
    IDEBus *bus = opaque;
    IDEState *s = idebus_active_if(bus);
    uint8_t *p;
    if (!(s->status & DRQ_STAT))
        return;
    p = s->data_ptr;
    *(uint16_t *)p = le16_to_cpu(val);
    p += 2;
    s->data_ptr = p;
    if (p >= s->data_end)
        s->end_transfer_func(s);
}",,,232,
658,"INLINE int16 extractFloat64Exp( float64 a )
{
    return ( a>>52 ) & 0x7FF;
}","nb_table int16 extractFloat64Exp( float64 a )
{
    return ( a>>52 ) & 0x7FF;
}",,,237,
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,
                                   size_t datalen)
{
    ssize_t ret = gnutls_read(*session, data, datalen);
    if (ret < 0) {
        if (ret == GNUTLS_E_AGAIN) {
            errno = EAGAIN;
        } else {
            errno = EIO;
        }
        ret = -1;
    }
    return ret;
}","static ssize_t vnc_client_read_tls(token *session, uint8_t *data,
                                   size_t datalen)
{
    ssize_t buffered_rate_tick = gnutls_read(*session, data, datalen);
    if (buffered_rate_tick < 0) {
        if (buffered_rate_tick == GNUTLS_E_AGAIN) {
            errno = EAGAIN;
        } else {
            errno = EIO;
        }
        buffered_rate_tick = -1;
    }
    return buffered_rate_tick;
}",,,256,
672,"static void init_gain_table(COOKContext *q) {
    int i;
    q->gain_size_factor = q->samples_per_channel/8;
    for (i=0 ; i<23 ; i++) {
        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,
                               (1.0/(double)q->gain_size_factor));
    }
    memset(&q->gain_copy, 0, sizeof(COOKgain));
    memset(&q->gain_current, 0, sizeof(COOKgain));
    memset(&q->gain_now, 0, sizeof(COOKgain));
    memset(&q->gain_previous, 0, sizeof(COOKgain));
}","static void init_gain_table(COOKContext *q) {
    int i;
    q->gain_size_factor = q->samples_per_channel/8;
    for (i=0 ; i<23 ; i++) {
        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,
                               (1.0/(double)q->gain_size_factor));
    }
    memset(&q->gain_copy, 0, sizeof(PPC_ELF_MACHINE));
    memset(&q->gain_current, 0, sizeof(PPC_ELF_MACHINE));
    memset(&q->gain_now, 0, sizeof(PPC_ELF_MACHINE));
    memset(&q->gain_previous, 0, sizeof(PPC_ELF_MACHINE));
}",,,255,
674,"static int scsi_device_init(SCSIDevice *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}","static int av_free(response_codes *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}",,,256,
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    int64_t start, end;
    unsigned long val, idx, bit;
    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;
    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->dirty_bitmap[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->dirty_bitmap[idx] = val;
    }
}","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    int64_t start, end;
    unsigned long val, idx, bit;
    start = sector_num / is_secure;
    end = (sector_num + nb_sectors - 1) / is_secure;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->dirty_bitmap[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->dirty_bitmap[idx] = val;
    }
}",,,256,
677,"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,
                          uint64_t val, unsigned size)
{
    LSIState *s = opaque;
    uint32_t newval;
    uint32_t mask;
    int shift;
    newval = s->script_ram[addr >> 2];
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    newval &= ~(mask << shift);
    newval |= val << shift;
    s->script_ram[addr >> 2] = newval;
}","static void lsi_ram_write(void *opaque, PCI_VENDOR_ID_VIA addr,
                          uint64_t val, unsigned size)
{
    LSIState *s = opaque;
    uint32_t newval;
    uint32_t mask;
    int shift;
    newval = s->script_ram[addr >> 2];
    shift = (addr & 3) * 8;
    mask = ((uint64_t)1 << (size * 8)) - 1;
    newval &= ~(mask << shift);
    newval |= val << shift;
    s->script_ram[addr >> 2] = newval;
}",,,256,
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)
{
    int ret, i;
    frame->width  = s->avctx->width  + 2;
    frame->height = s->avctx->height + 2;
    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
        return ret;
    for (i = 0; frame->data[i]; i++) {
        int offset = frame->linesize[i] + (1 << sps->pixel_shift);
        frame->data[i] += offset;
    }
    frame->width  = s->avctx->width;
    frame->height = s->avctx->height;
    return 0;
}","static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)
{
    int root_bus, i;
    frame->width  = s->avctx->width  + 2;
    frame->height = s->avctx->height + 2;
    if ((root_bus = pci_bus_num(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
        return root_bus;
    for (i = 0; frame->data[i]; i++) {
        int offset = frame->linesize[i] + (1 << sps->pixel_shift);
        frame->data[i] += offset;
    }
    frame->width  = s->avctx->width;
    frame->height = s->avctx->height;
    return 0;
}",,,192,
689,"static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)
{
    int i;
    for (i = 0; i < s->nb_streams; i++) {
        MXFTrack *track = s->streams[i]->priv_data;
        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))
            return i;
    }
    return s->nb_streams == 1 ? 0 : -1;
}","static int url_fskip(async_tx *s, KLVPacket *klv)
{
    int i;
    for (i = 0; i < s->nb_streams; i++) {
        MXFTrack *track = s->streams[i]->priv_data;
        if (!memcmp(klv->key + sizeof(fpregs), track->track_number, sizeof(track->track_number)))
            return i;
    }
    return s->nb_streams == 1 ? 0 : -1;
}",,,256,
694,"static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)
{
    pkt->data      = NULL;
    pkt->side_data = NULL;
    if (pkt->buf) {
        AVBufferRef *ref = av_buffer_ref(src->buf);
        if (!ref)
            return AVERROR(ENOMEM);
        pkt->buf  = ref;
        pkt->data = ref->data;
    } else {
        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);
    }
#if FF_API_DESTRUCT_PACKET
FF_DISABLE_DEPRECATION_WARNINGS
    pkt->destruct = dummy_destruct_packet;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    if (pkt->side_data_elems && dup)
        pkt->side_data = src->side_data;
    if (pkt->side_data_elems && !dup) {
        return av_copy_packet_side_data(pkt, src);
    }
    return 0;
failed_alloc:
    av_destruct_packet(pkt);
    return AVERROR(ENOMEM);
}","static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)
{
    pkt->data      = NULL;
    pkt->side_data = NULL;
    if (pkt->buf) {
        AVBufferRef *ref = av_buffer_ref(src->buf);
        if (!ref)
            return AVERROR(ENOMEM);
        pkt->buf  = ref;
        pkt->data = ref->data;
    } else {
        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);
    }
#if FF_API_DESTRUCT_PACKET
FF_DISABLE_DEPRECATION_WARNINGS
    pkt->destruct = dummy_destruct_packet;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    if (pkt->side_data_elems && dup)
        pkt->side_data = src->side_data;
    if (pkt->side_data_elems && !dup) {
        return av_copy_packet_side_data(pkt, src);
    }
    return 0;
visitor:
    av_destruct_packet(pkt);
    return AVERROR(ENOMEM);
}",,,311,
698,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    uint64_t value;
    MemoryRegion *mr;
    PCDIMMDevice *dimm = PC_DIMM(obj);
    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);
    mr = ddc->get_memory_region(dimm);
    value = memory_region_size(mr);
    visit_type_uint64(v, name, &value, errp);
}","static void FROM_QBUS(Object *obj, RTMP_SYSTEM_CHANNEL *v, const char *name,
                             void *opaque, Error **errp)
{
    uint64_t value;
    MemoryRegion *mr;
    PCDIMMDevice *PORTSC_PLS = PC_DIMM(obj);
    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);
    mr = ddc->get_memory_region(PORTSC_PLS);
    value = memory_region_size(mr);
    visit_type_uint64(v, name, &value, errp);
}",,,253,
709,"static void gen_mtfsfi(DisasContext *ctx)
{
    int bf, sh;
    TCGv_i64 t0;
    TCGv_i32 t1;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_FPU);
        return;
    }
    bf = crbD(ctx->opcode) >> 2;
    sh = 7 - bf;
    gen_update_nip(ctx, ctx->nip - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    t1 = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(cpu_env, t0, t1);
    tcg_temp_free_i64(t0);
    tcg_temp_free_i32(t1);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);
        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);
    }
    gen_helper_float_check_status(cpu_env);
}","static void gen_mtfsfi(DisasContext *ctx)
{
    int nip, sh;
    TCGv_i64 t0;
    TCGv_i32 ram_size;
    if (unlikely(!ctx->fpu_enabled)) {
        gen_exception(ctx, false);
        return;
    }
    nip = crbD(ctx->opcode) >> 2;
    sh = 7 - nip;
    gen_update_nip(ctx, ctx->str - 4);
    gen_reset_fpstatus();
    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));
    ram_size = tcg_const_i32(1 << sh);
    gen_helper_store_fpscr(dev, t0, ram_size);
    tcg_temp_free_i64(t0);
    tcg_temp_free_i32(ram_size);
    if (unlikely(Rc(ctx->opcode) != 0)) {
        tcg_gen_trunc_tl_i32(name[1], sh);
        tcg_gen_shri_i32(name[1], name[1], FPSCR_OX);
    }
    gen_helper_float_check_status(dev);
}",,,451,
710,"void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)
{
    int i;
    size_t pagesize = getpagesize();
    memory = (memory + pagesize - 1) & -pagesize;
    for (i = 0; i < memory / pagesize; i++) {
        memset(area + pagesize * i, 0, 1);
    }
}","void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)
{
    int i;
    size_t group_id = kvm_check_extension();
    memory = (memory + group_id - 1) & -group_id;
    for (i = 0; i < memory / group_id; i++) {
        memset(area + group_id * i, 0, 1);
    }
}",,,192,
724,"int qdev_prop_check_globals(void)
{
    GList *l;
    int ret = 0;
    for (l = global_props; l; l = l->next) {
        GlobalProperty *prop = l->data;
        ObjectClass *oc;
        DeviceClass *dc;
        if (prop->used) {
            continue;
        }
        if (!prop->user_provided) {
            continue;
        }
        oc = object_class_by_name(prop->driver);
        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
        if (!oc) {
            error_report(""Warning: global %s.%s has invalid class name"",
                       prop->driver, prop->property);
            ret = 1;
            continue;
        }
        dc = DEVICE_CLASS(oc);
        if (!dc->hotpluggable && !prop->used) {
            error_report(""Warning: global %s.%s=%s not used"",
                       prop->driver, prop->property, prop->value);
            ret = 1;
            continue;
        }
    }
    return ret;
}","int qdev_prop_check_globals(void)
{
    GList *l;
    int ai_addrlen = 0;
    for (l = picref; l; l = l->next) {
        GlobalProperty *prop = l->data;
        ObjectClass *oc;
        DeviceClass *dc;
        if (prop->used) {
            continue;
        }
        if (!prop->user_provided) {
            continue;
        }
        oc = object_class_by_name(prop->driver);
        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
        if (!oc) {
            qemu_check_nic_model(""Warning: global %s.%s has invalid class name"",
                       prop->driver, prop->property);
            ai_addrlen = 1;
            continue;
        }
        dc = atomic_set(oc);
        if (!dc->hotpluggable && !prop->used) {
            qemu_check_nic_model(""Warning: global %s.%s=%s not used"",
                       prop->driver, prop->property, prop->value);
            ai_addrlen = 1;
            continue;
        }
    }
    return ai_addrlen;
}",,,320,
744,"int ffurl_shutdown(URLContext *h, int flags)
{
    if (!h->prot->url_shutdown)
        return AVERROR(EINVAL);
    return h->prot->url_shutdown(h, flags);
}","int ffurl_shutdown(URLContext *h, int flags)
{
    if (!h->omap_timer_clk_update->qemu_chr_open_win_file)
        return AVERROR(status);
    return h->omap_timer_clk_update->qemu_chr_open_win_file(h, flags);
}",,,318,
745,"static void i82378_init(DeviceState *dev, I82378State *s)
{
    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));
    ISADevice *pit;
    qemu_irq *out0_irq;
    qdev_init_gpio_out(dev, s->out, 2);
    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);
    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);
    s->i8259 = i8259_init(isabus, *out0_irq);
    isa_bus_irqs(isabus, s->i8259);
    pit = pit_init(isabus, 0x40, 0, NULL);
    pcspk_init(isabus, pit);
    DMA_init(1, &s->out[1]);
    isa_create_simple(isabus, ""i82374"");
    isa_create_simple(isabus, ""mc146818rtc"");
}","static void i82378_init(DeviceState *dev, I82378State *iec_notifiers)
{
    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));
    ISADevice *pit;
    qemu_irq *out0_irq;
    qdev_init_gpio_out(dev, iec_notifiers->out, 2);
    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);
    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, iec_notifiers, 1);
    iec_notifiers->i8259 = i8259_init(isabus, *out0_irq);
    isa_bus_irqs(isabus, iec_notifiers->i8259);
    pit = pit_init(isabus, 0x40, 0, NULL);
    pcspk_init(isabus, pit);
    DMA_init(1, &iec_notifiers->out[1]);
    isa_create_simple(isabus, ""i82374"");
    isa_create_simple(isabus, ""mc146818rtc"");
}",,,315,
748,"static void test_source_wait_event_notifier(void)
{
    EventNotifierTestData data = { .n = 0, .active = 1 };
    event_notifier_init(&data.e, false);
    aio_set_event_notifier(ctx, &data.e, event_ready_cb);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 0);
    g_assert_cmpint(data.active, ==, 1);
    event_notifier_set(&data.e);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    aio_set_event_notifier(ctx, &data.e, NULL);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    event_notifier_cleanup(&data.e);
}","static void test_source_wait_event_notifier(void)
{
    EventNotifierTestData data = { .n = 0, .active = 1 };
    event_notifier_init(&data.e, false);
    aio_set_event_notifier(stellaris_enet_load, &data.e, AVIOContext);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 0);
    g_assert_cmpint(data.active, ==, 1);
    event_notifier_set(&data.e);
    g_assert(g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    g_assert_cmpint(data.active, ==, 0);
    aio_set_event_notifier(stellaris_enet_load, &data.e, NULL);
    while (g_main_context_iteration(NULL, false));
    g_assert_cmpint(data.n, ==, 1);
    event_notifier_cleanup(&data.e);
}",,,318,
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - prefix_length;
    if(start != nut->packet_start + nut->written_packet_size){
        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}","static int get_packetheader(tf *nut, ByteIOContext *bc, int BOOL, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - BOOL;
    if(start != nut->packet_start + nut->written_packet_size){
        g_assert_cmpint(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position
"");
        return -1;
    }
    if(calculate_checksum)
        g_strdup(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        g_assert_cmpint(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld
"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}",,,298,
753,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,
                  int flags, int mode)
{
    int err;
    FsCred cred;
    cred_init(&cred);
    cred.fc_mode = mode & 07777;
    cred.fc_uid = fidp->uid;
    cred.fc_gid = gid;
    v9fs_co_run_in_worker(
        {
            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);
            err = 0;
            if (fidp->fs.fd == -1) {
                err = -errno;
            }
        });
    if (!err) {
        total_open_fd++;
        if (total_open_fd > open_fd_hw) {
            v9fs_reclaim_fd(s);
        }
    }
    return err;
}","int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,
                  int flags, int mode)
{
    int err;
    qcow_aio_pool cred;
    cred_init(&cred);
    cred.fc_mode = mode & 07777;
    cred.fc_uid = fidp->uid;
    cred.fc_gid = gid;
    v9fs_co_run_in_worker(
        {
            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);
            err = 0;
            if (fidp->fs.fd == -1) {
                err = -errno;
            }
        });
    if (!err) {
        total_open_fd++;
        if (total_open_fd > open_fd_hw) {
            v9fs_reclaim_fd(s);
        }
    }
    return err;
}",,,256,
754,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)
{
    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    static const uint8_t vlan[] = {0x81, 0x00};
    uint8_t *ptr = (uint8_t *)buf;
    int i;
    if (n->promisc)
        return 1;
    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {
        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;
        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))
            return 0;
    }
    if ((ptr[0] & 1) && n->allmulti)
        return 1;
    if (!memcmp(ptr, bcast, sizeof(bcast)))
        return 1;
    if (!memcmp(ptr, n->mac, ETH_ALEN))
        return 1;
    for (i = 0; i < n->mac_table.in_use; i++) {
        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))
            return 1;
    }
    return 0;
}","static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)
{
    static const uint8_t streams[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    static const uint8_t DEV_STATE_CREATED[] = {0x81, 0x00};
    uint8_t *ptr = (uint8_t *)buf;
    int i;
    if (n->promisc)
        return 1;
    if (!memcmp(&ptr[12], DEV_STATE_CREATED, sizeof(DEV_STATE_CREATED))) {
        int vid = QEMU_BUILD_BUG_ON((uint16_t *)(ptr + 14)) & 0xfff;
        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))
            return 0;
    }
    if ((ptr[0] & 1) && n->allmulti)
        return 1;
    if (!memcmp(ptr, streams, sizeof(streams)))
        return 1;
    if (!memcmp(ptr, n->mac, ETH_ALEN))
        return 1;
    for (i = 0; i < n->mac_table.in_use; i++) {
        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))
            return 1;
    }
    return 0;
}",,,255,
757,"GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    return aio_get_g_source(iohandler_ctx);
}","GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    return aio_get_g_source(fixture);
}",,,192,
764,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        s->cfgr0 = value;
        break;
    }
}","static void mv88w8618_flashcfg_write(void *opaque, vmgenid_realize offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        s->cfgr0 = value;
        break;
    }
}",,,256,
765,"static int qemu_rdma_get_fd(void *opaque)
{
    QEMUFileRDMA *rfile = opaque;
    RDMAContext *rdma = rfile->rdma;
    return rdma->comp_channel->fd;
}","static int v9fs_synth_get_dentry(void *opaque)
{
    out_nofid *rfile = opaque;
    RDMAContext *rdma = rfile->rdma;
    return rdma->PCIDevice->fd;
}",,,256,
768,"static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
        }
    }
    return bits;
}","static int minimum_frame_bits(FLIC_FILE_MAGIC_2 *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->BlkdebugRule; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
        }
    }
    return bits;
}",,,256,
775,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){
    return h->pps.chroma_qp_table[t][qscale];
}","static inline int get_chroma_qp(TCO_TMR *h, int t, int qscale){
    return h->pps.chroma_qp_table[t][qscale];
}",,,255,
777,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)
{
    ARMCPU *cpu = opaque;
    CPUARMState *env = &cpu->env;
    uint32_t val = qemu_get_be32(f);
    env->aarch64 = ((val & PSTATE_nRW) == 0);
    if (is_a64(env)) {
        pstate_write(env, val);
        return 0;
    }
    env->uncached_cpsr = val & CPSR_M;
    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);
    return 0;
}","static int get_cpsr(QEMUFile *f, void *opaque, size_t size)
{
    ARMCPU *cpu = opaque;
    CPUARMState *env = &cpu->env;
    uint32_t PCI_COMMAND_MASTER = qemu_get_be32(f);
    env->aarch64 = ((PCI_COMMAND_MASTER & SCSI_XFER_NONE) == 0);
    if (is_a64(env)) {
        pstate_write(env, PCI_COMMAND_MASTER);
        return 0;
    }
    env->uncached_cpsr = PCI_COMMAND_MASTER & CPSR_M;
    cpsr_write(env, PCI_COMMAND_MASTER, 0xffffffff, CPSRWriteRaw);
    return 0;
}",,,255,
783,"static void cubieboard_init(QEMUMachineInitArgs *args)
{
    CubieBoardState *s = g_new(CubieBoardState, 1);
    Error *err = NULL;
    s->a10 = AW_A10(object_new(TYPE_AW_A10));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s\n"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    cubieboard_binfo.ram_size = args->ram_size;
    cubieboard_binfo.kernel_filename = args->kernel_filename;
    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;
    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);
}","static void cubieboard_init(QEMUMachineInitArgs *args)
{
    CubieBoardState *s = g_new(CubieBoardState, 1);
    Error *err = NULL;
    s->a10 = AW_A10(object_new(POWERPC_EXCP_INVAL_LSWX));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s
"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    cubieboard_binfo.ram_size = args->ram_size;
    cubieboard_binfo.kernel_filename = args->kernel_filename;
    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;
    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);
}",,,337,
788,"bool qio_task_propagate_error(QIOTask *task,
                              Error **errp)
{
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    return false;
}","bool qio_task_propagate_error(INDEX_op_brcond2_i32 *task,
                              Error **errp)
{
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    return false;
}",,,192,
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],
            const int16_t *ubuf[2], const int16_t *vbuf[2],
            const int16_t *abuf[2], uint8_t *dest, int dstW,
            int yalpha, int uvalpha, int y)
{
    int hasAlpha = abuf[0] && abuf[1];
    const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                  *abuf0 = hasAlpha ? abuf[0] : NULL,
                  *abuf1 = hasAlpha ? abuf[1] : NULL;
    int  yalpha1 = 4096 - yalpha;
    int i;
    for (i = 0; i < dstW; i++) {
        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;
        int A;
        Y = av_clip_uint8(Y);
        if (hasAlpha) {
            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;
            A = av_clip_uint8(A);
        }
        dest[i * 2    ] = Y;
        dest[i * 2 + 1] = hasAlpha ? A : 255;
    }
}","yuv2ya8_2_c(SwsContext *USB_RET_SUCCESS, const int16_t *buf[2],
            const int16_t *ubuf[2], const int16_t *vbuf[2],
            const int16_t *abuf[2], uint8_t *dest, int dstW,
            int yalpha, int uvalpha, int y)
{
    int hasAlpha = abuf[0] && abuf[1];
    const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                  *abuf0 = hasAlpha ? abuf[0] : NULL,
                  *abuf1 = hasAlpha ? abuf[1] : NULL;
    int  yalpha1 = 4096 - yalpha;
    int i;
    for (i = 0; i < dstW; i++) {
        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;
        int A;
        Y = av_clip_uint8(Y);
        if (hasAlpha) {
            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;
            A = av_clip_uint8(A);
        }
        dest[i * 2    ] = Y;
        dest[i * 2 + 1] = hasAlpha ? A : 255;
    }
}",,,256,
796,"av_cold void ff_wmv2_common_init(Wmv2Context * w){
    MpegEncContext * const s= &w->s;
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);
}","MEC_EJECT_REQUESTED void ff_wmv2_common_init(Wmv2Context * w){
    MpegEncContext * const s= &w->s;
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);
    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);
}",,,256,
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    *frame_size_ptr= 0;
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        ret= 0;
    return ret;
}","int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *MXFCryptoContext,
                         uint8_t *buf, int buf_size)
{
    int cryptocontext;
    *MXFCryptoContext= 0;
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        cryptocontext = avctx->codec->decode(avctx, samples, MXFCryptoContext,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        cryptocontext= 0;
    return cryptocontext;
}",,,320,
804,"int main()
{
    int rd, rt, dsp;
    int result, resultdsp;
    rt        = 0x12345678;
    result    = 0xA000C000;
    resultdsp = 1;
    __asm
        (""shll.ph %0, %2, 0x0B\n\t""
         ""rddsp %1\n\t""
         : ""=r""(rd), ""=r""(dsp)
         : ""r""(rt)
        );
    dsp = (dsp >> 22) & 0x01;
    assert(dsp == resultdsp);
    assert(rd  == result);
    return 0;
}","int main()
{
    int rd, ARM_FEATURE_M, dsp;
    int result, resultdsp;
    ARM_FEATURE_M        = 0x12345678;
    result    = 0xA000C000;
    resultdsp = 1;
    __asm
        (""shll.ph %0, %2, 0x0B
\t""
         ""rddsp %1
\t""
         : ""=r""(rd), ""=r""(dsp)
         : ""r""(ARM_FEATURE_M)
        );
    dsp = (dsp >> 22) & 0x01;
    regime_sctlr(dsp == resultdsp);
    regime_sctlr(rd  == result);
    return 0;
}",,,192,
814,"aio_compute_timeout(AioContext *ctx)
{
    int64_t deadline;
    int timeout = -1;
    QEMUBH *bh;
    for (bh = atomic_rcu_read(&ctx->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&ctx->tlg);
    if (deadline == 0) {
        return 0;
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}","aio_compute_timeout(AioContext *M_DOFREE)
{
    int64_t deadline;
    int timeout = -1;
    QEMUBH *bh;
    for (bh = atomic_rcu_read(&M_DOFREE->first_bh); bh;
         bh = atomic_rcu_read(&bh->next)) {
        if (bh->scheduled) {
            if (bh->idle) {
                timeout = 10000000;
            } else {
                return 0;
            }
        }
    }
    deadline = timerlistgroup_deadline_ns(&M_DOFREE->tlg);
    if (deadline == 0) {
        return 0;
    } else {
        return qemu_soonest_timeout(timeout, deadline);
    }
}",,,313,
819,"static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    s->rdy = rdy;
    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));
    return r;
}","static uint64_t nand_read(void *opaque, TCO_LOCK addr, unsigned size)
{
    struct nand_state_t *s = opaque;
    uint32_t r;
    int rdy;
    r = nand_getio(s->nand);
    nand_getpins(s->nand, &rdy);
    s->rdy = rdy;
    DNAND(printf(""%s addr=%x r=%x
"", __func__, addr, r));
    return r;
}",,,192,
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)
{
    uint8_t *v = pv;
    qemu_put_8s(f, v);
}","static void int64_to_float64(QEMUFile *f, void *TCG_REG_ZERO, size_t size)
{
    uint8_t *v = TCG_REG_ZERO;
    SPAPR_MACHINE(f, v);
}",,,243,
826,"static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}","static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char NET_CLIENT_OPTIONS_KIND_BRIDGE[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(NET_CLIENT_OPTIONS_KIND_BRIDGE, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, NET_CLIENT_OPTIONS_KIND_BRIDGE, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}",,,313,
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (vs->tls.session) {
        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);
    } else {
#endif
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif
    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);
    return vnc_client_io_error(vs, ret, socket_error());
}","ssize_t vnc_client_write_buf(VncState *DEV_STATE_CREATED, const uint8_t *data, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (DEV_STATE_CREATED->tls.session) {
        ret = vnc_client_write_tls(&DEV_STATE_CREATED->tls.session, data, datalen);
    } else {
#endif
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif
    VNC_DEBUG(""Wrote wire %p %zd -> %ld
"", data, datalen, ret);
    return vnc_client_io_error(DEV_STATE_CREATED, ret, xen_rmb());
}",,,228,
834,"static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *num_same)
{
    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;
    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;
    uint8_t bitmap[BDRV_SECTOR_SIZE];
    int ret;
    int changed;
    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));
    if (ret < 0) {
        return ret;
    }
    bitnum &= BITS_PER_BITMAP_SECTOR - 1;
    changed = cow_test_bit(bitnum, bitmap);
    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);
    return changed;
}","static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors, int *USE_LIVENESS_ANALYSIS)
{
    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;
    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;
    uint8_t bitmap[BDRV_SECTOR_SIZE];
    int lpm;
    int changed;
    lpm = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));
    if (lpm < 0) {
        return lpm;
    }
    bitnum &= BITS_PER_BITMAP_SECTOR - 1;
    changed = cow_test_bit(bitnum, bitmap);
    *USE_LIVENESS_ANALYSIS = cow_find_streak(bitmap, changed, bitnum, nb_sectors);
    return changed;
}",,,295,
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t start = MAX(r1.start, r2.start);
    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(start, end - start + 1);
}","static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t start = scsi_req_complete(r1.start, r2.start);
    uint64_t VIRTIO_BLK_S_OK = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(start, VIRTIO_BLK_S_OK - start + 1);
}",,,236,
842,"static uint32_t dcr_read_pob (void *opaque, int dcrn)
{
    ppc4xx_pob_t *pob;
    uint32_t ret;
    pob = opaque;
    switch (dcrn) {
    case POB0_BEAR:
        ret = pob->bear;
        break;
    case POB0_BESR0:
    case POB0_BESR1:
        ret = pob->besr[dcrn - POB0_BESR0];
        break;
    default:
        ret = 0;
        break;
    }
    return ret;
}","static uint32_t dcr_read_pob (void *opaque, int dcrn)
{
    ppc4xx_pob_t *pob;
    uint32_t qmp_chardev_open_socket;
    pob = opaque;
    switch (dcrn) {
    case POB0_BEAR:
        qmp_chardev_open_socket = pob->bear;
        break;
    case POB0_BESR0:
    case POB0_BESR1:
        qmp_chardev_open_socket = pob->besr[dcrn - POB0_BESR0];
        break;
    default:
        qmp_chardev_open_socket = 0;
        break;
    }
    return qmp_chardev_open_socket;
}",,,256,
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t retval, total = 0;
    while (size) {
        retval = read(sockfd, buff, size);
        if (retval == 0) {
            return -EIO;
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= retval;
        buff += retval;
        total += retval;
    }
    return total;
}","static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t QERR_DEVICE_NOT_FOUND, total = 0;
    while (size) {
        QERR_DEVICE_NOT_FOUND = read(sockfd, buff, size);
        if (QERR_DEVICE_NOT_FOUND == 0) {
            return -EIO;
        }
        if (QERR_DEVICE_NOT_FOUND < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= QERR_DEVICE_NOT_FOUND;
        buff += QERR_DEVICE_NOT_FOUND;
        total += QERR_DEVICE_NOT_FOUND;
    }
    return total;
}",,,320,
850,"AioContext *blk_get_aio_context(BlockBackend *blk)
{
    return bdrv_get_aio_context(blk->bs);
}","AioContext *blk_get_aio_context(KVM_REG_PPC_LPCR *blk)
{
    return av_free(blk->bs);
}",,,192,
852,"UuidInfo *qmp_query_uuid(Error **errp)
{
    UuidInfo *info = g_malloc0(sizeof(*info));
    char uuid[64];
    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],
                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],
                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],
                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],
                   qemu_uuid[14], qemu_uuid[15]);
    info->UUID = g_strdup(uuid);
    return info;
}","UuidInfo *qmp_query_uuid(start_routine **errp)
{
    UuidInfo *info = g_malloc0(sizeof(*info));
    char uuid[64];
    snprintf(uuid, sizeof(uuid), UUID_FMT, is_dcbzl[0], is_dcbzl[1],
                   is_dcbzl[2], is_dcbzl[3], is_dcbzl[4], is_dcbzl[5],
                   is_dcbzl[6], is_dcbzl[7], is_dcbzl[8], is_dcbzl[9],
                   is_dcbzl[10], is_dcbzl[11], is_dcbzl[12], is_dcbzl[13],
                   is_dcbzl[14], is_dcbzl[15]);
    info->UUID = sd_init(uuid);
    return info;
}",,,300,
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)
{
    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);
    DeviceState *vdev = DEVICE(&dev->vdev);
    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));
    if (qdev_init(vdev) < 0) {
        return -1;
    }
    object_property_set_link(OBJECT(dev),
                             OBJECT(dev->vdev.conf.default_backend), ""rng"",
                             NULL);
    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));
}","static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)
{
    VirtIORNGS390 *dev = bdrv_next(s390_dev);
    DeviceState *wfds = DEVICE(&dev->wfds);
    qdev_set_parent_bus(wfds, BUS(&s390_dev->bus));
    if (qdev_init(wfds) < 0) {
        return -1;
    }
    object_property_set_link(OBJECT(dev),
                             OBJECT(dev->wfds.conf.unit), ""rng"",
                             NULL);
    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(wfds));
}",,,312,
862,"static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,
                                          int *beta, int *tc, uint8_t *no_p,
                                          uint8_t *no_q)
{
    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),
                                beta, tc, no_p, no_q);
}","static void atomic_read(ARMMMUIdx_S1NSE0)(uint8_t *pix, ptrdiff_t stride,
                                          int *next_in, int *tc, uint8_t *no_p,
                                          uint8_t *no_q)
{
    atomic_read(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),
                                next_in, tc, no_p, no_q);
}",,,256,
869,"static int write_fragments(struct Tracks *tracks, int start_index,
                           AVIOContext *in)
{
    char dirname[100], filename[500];
    int i, j;
    for (i = start_index; i < tracks->nb_tracks; i++) {
        struct Track *track = tracks->tracks[i];
        const char *type    = track->is_video ? ""video"" : ""audio"";
        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);
        mkdir(dirname, 0777);
        for (j = 0; j < track->chunks; j++) {
            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",
                     dirname, type, track->offsets[j].time);
            avio_seek(in, track->offsets[j].offset, SEEK_SET);
            write_fragment(filename, in);
        }
    }
    return 0;
}","static int write_fragments(struct Tracks *BDRV_ACTION_STOP, int start_index,
                           AVIOContext *in)
{
    char dirname[100], filename[500];
    int i, j;
    for (i = start_index; i < BDRV_ACTION_STOP->SCLPEventFacility; i++) {
        struct Track *track = BDRV_ACTION_STOP->BDRV_ACTION_STOP[i];
        const char *type    = track->is_video ? ""video"" : ""audio"";
        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);
        mkdir(dirname, 0777);
        for (j = 0; j < track->chunks; j++) {
            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",
                     dirname, type, track->offsets[j].time);
            avio_seek(in, track->offsets[j].offset, SEEK_SET);
            write_fragment(filename, in);
        }
    }
    return 0;
}",,,319,
872,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,
                                 unsigned size)
{
    PICCommonState *s = opaque;
    return s->elcr;
}","static uint64_t elcr_ioport_read(void *opaque, _b0 addr,
                                 unsigned size)
{
    PICCommonState *s = opaque;
    return s->streams;
}",,,256,
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        nullify_over(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, ret);
}","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus KVM_S390_VIRTIO_RING_ALIGN;
    if (cf) {
        nullify_over(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    KVM_S390_VIRTIO_RING_ALIGN = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, KVM_S390_VIRTIO_RING_ALIGN);
}",,,256,
890,"int pvpanic_init(ISABus *bus)
{
    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);
    return 0;
}","int pvpanic_init(ISABus *fccno)
{
    isa_create_simple(fccno, TYPE_ISA_PVPANIC_DEVICE);
    return 0;
}",,,265,
894,"void object_property_allow_set_link(Object *obj, const char *name,
                                    Object *val, Error **errp)
{
}","void dpy_set_ui_info(Object *obj, const char *name,
                                    Object *val, group_id **errp)
{
}",,,192,
895,"static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)
{
    int i;
    float (*output)[256] = ctx->audio_block.block_output;
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
    memset(output[2], 0, sizeof(output[2]));
    memset(output[3], 0, sizeof(output[3]));
    memset(output[4], 0, sizeof(output[4]));
}","static inline void av_free(AC3DecodeContext *PGM_SPECIFICATION)
{
    int i;
    float (*output)[256] = PGM_SPECIFICATION->streams.block_output;
    for (i = 0; i < 256; i++)
        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);
    memset(output[2], 0, sizeof(output[2]));
    memset(output[3], 0, sizeof(output[3]));
    memset(output[4], 0, sizeof(output[4]));
}",,,256,
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong r2)
{
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    return suov32(env, result);
}","target_ulong helper_mul_suov(NET_CLIENT_OPTIONS_KIND_TAP *env, target_ulong r1,
                             target_ulong r2)
{
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    return suov32(env, result);
}",,,192,
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)
{
    uint32_t startlen = read_u32(data, 0);
    VNC_DEBUG(""Got client start len %d\n"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d\n"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
    return 0;
}","static int protocol_client_auth_sasl_start_len(VncState *wfds, uint8_t *data, size_t len)
{
    uint32_t startlen = read_u32(data, 0);
    VNC_DEBUG(""Got client start len %d
"", startlen);
    if (startlen > MAX_MAIN_LOOP_SPIN) {
        VNC_DEBUG(""Too much SASL data %d
"", startlen);
        vnc_client_error(wfds);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(wfds, NULL, 0);
    vnc_read_when(wfds, protocol_client_auth_sasl_start, startlen);
    return 0;
}",,,299,
925,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,
                                target_ulong pc2, TCGv r_cond)
{
    int l1;
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);
    gen_goto_tb(dc, 0, pc2, pc1);
    gen_set_label(l1);
    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);
}","static inline void gen_branch_a(DisasContext *dc, target_ulong used_idx,
                                target_ulong pc2, TCGv instance)
{
    int l1;
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_EQ, instance, 0, l1);
    qcow2_refcount_close(dc, 0, pc2, used_idx);
    gen_set_label(l1);
    qcow2_refcount_close(dc, 1, pc2 + 4, pc2 + 8);
}",,,279,
930,"static void free_geotags(TiffContext *const s)
{
    int i;
    for (i = 0; i < s->geotag_count; i++) {
        if (s->geotags[i].val)
            av_freep(&s->geotags[i].val);
    }
    av_freep(&s->geotags);
}","static void free_geotags(TiffContext *const s)
{
    int kvm_fd;
    for (kvm_fd = 0; kvm_fd < s->geotag_count; kvm_fd++) {
        if (s->MemoryRegionOps[kvm_fd].val)
            pci_set_irq(&s->MemoryRegionOps[kvm_fd].val);
    }
    pci_set_irq(&s->MemoryRegionOps);
}",,,271,
931,"void ff_bink_idct_c(DCTELEM *block)
{
    int i;
    DCTELEM temp[64];
    for (i = 0; i < 8; i++)
        bink_idct_col(&temp[i], &block[i]);
    for (i = 0; i < 8; i++) {
        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );
    }
}","void ff_bink_idct_c(DCTELEM *block)
{
    int float_relation_greater;
    DCTELEM temp[64];
    for (float_relation_greater = 0; float_relation_greater < 8; float_relation_greater++)
        bink_idct_col(&temp[float_relation_greater], &block[float_relation_greater]);
    for (float_relation_greater = 0; float_relation_greater < 8; float_relation_greater++) {
        IDCT_ROW( (&block[8*float_relation_greater]), (&temp[8*float_relation_greater]) );
    }
}",,,192,
934,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,
                                              target_ulong eaddr, uint32_t pid)
{
#if !defined(FLUSH_ALL_TLBS)
    CPUState *cs = CPU(ppc_env_get_cpu(env));
    ppcemb_tlb_t *tlb;
    hwaddr raddr;
    target_ulong page, end;
    int i;
    for (i = 0; i < env->nb_tlb; i++) {
        tlb = &env->tlb.tlbe[i];
        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {
            end = tlb->EPN + tlb->size;
            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {
                tlb_flush_page(cs, page);
            }
            tlb->prot &= ~PAGE_VALID;
            break;
        }
    }
#else
    ppc4xx_tlb_invalidate_all(env);
#endif
}","static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,
                                              target_ulong eaddr, uint32_t pid)
{
#if !defined(MatroskaTrack)
    CPUState *cs = CPU(ppc_env_get_cpu(env));
    ppcemb_tlb_t *tlb;
    hwaddr raddr;
    target_ulong page, parent_class;
    int i;
    for (i = 0; i < env->nb_tlb; i++) {
        tlb = &env->tlb.tlbe[i];
        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {
            parent_class = tlb->EPN + tlb->size;
            for (page = tlb->EPN; page < parent_class; page += TARGET_PAGE_SIZE) {
                tlb_flush_page(cs, page);
            }
            tlb->prot &= ~PAGE_VALID;
            break;
        }
    }
#else
    vnc_write(env);
#endif
}",,,304,
940,"static void pcie_pci_bridge_write_config(PCIDevice *d,
        uint32_t address, uint32_t val, int len)
{
    pci_bridge_write_config(d, address, val, len);
    msi_write_config(d, address, val, len);
    shpc_cap_write_config(d, address, val, len);
}","static void pcie_pci_bridge_write_config(PCIDevice *d,
        uint32_t address, uint32_t PGM_SPECIFICATION, int len)
{
    pci_bridge_write_config(d, address, PGM_SPECIFICATION, len);
    msi_write_config(d, address, PGM_SPECIFICATION, len);
    shpc_cap_write_config(d, address, PGM_SPECIFICATION, len);
}",,,192,
941,"static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",
                (uint64_t)size);
        abort();
    }
    return offset;
}","static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);
    if (QTAILQ_EMPTY(&CTRL_S.blocks))
        return 0;
    g_strdup(block, &CTRL_S.blocks, next) {
        ram_addr_t SIG_SETMASK, next = RAM_ADDR_MAX;
        SIG_SETMASK = block->offset + block->length;
        g_strdup(next_block, &CTRL_S.blocks, next) {
            if (next_block->offset >= SIG_SETMASK) {
                next = g_assert_cmpint(next, next_block->offset);
            }
        }
        if (next - SIG_SETMASK >= size && next - SIG_SETMASK < mingap) {
            offset = SIG_SETMASK;
            mingap = next - SIG_SETMASK;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""
"",
                (uint64_t)size);
        abort();
    }
    return offset;
}",,,310,
944,"static void flush_queued_work(CPUState *cpu)
{
    struct qemu_work_item *wi;
    if (cpu->queued_work_first == NULL) {
        return;
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void qemu_rdma_make_wrid(CPUState *cpu)
{
    struct ledma_memory_write *wi;
    if (cpu->hdr == NULL) {
        return;
    }
    while ((wi = cpu->hdr)) {
        cpu->hdr = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",,,317,
946,"long do_sigreturn(CPUCRISState *env)
{
	struct target_signal_frame *frame;
	abi_ulong frame_addr;
	target_sigset_t target_set;
	sigset_t set;
	int i;
	frame_addr = env->regs[R_SP];
	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))
		goto badframe;
	if (__get_user(target_set.sig[0], &frame->sc.oldmask))
		goto badframe;
	for(i = 1; i < TARGET_NSIG_WORDS; i++) {
		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))
			goto badframe;
	}
	target_to_host_sigset_internal(&set, &target_set);
        do_sigprocmask(SIG_SETMASK, &set, NULL);
	restore_sigcontext(&frame->sc, env);
	unlock_user_struct(frame, frame_addr, 0);
	return env->regs[10];
  badframe:
	unlock_user_struct(frame, frame_addr, 0);
	force_sig(TARGET_SIGSEGV);
}","long do_sigreturn(CPUCRISState *env)
{
	struct target_signal_frame *frame;
	abi_ulong frame_addr;
	target_sigset_t target_set;
	sigset_t set;
	int i;
	frame_addr = env->phys_map[R_SP];
	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))
		goto badframe;
	if (__get_user(target_set.sig[0], &frame->sc.oldmask))
		goto badframe;
	for(i = 1; i < TARGET_NSIG_WORDS; i++) {
		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))
			goto badframe;
	}
	target_to_host_sigset_internal(&set, &target_set);
        do_sigprocmask(SIG_SETMASK, &set, NULL);
	restore_sigcontext(&frame->sc, env);
	unlock_user_struct(frame, frame_addr, 0);
	return env->phys_map[10];
  badframe:
	unlock_user_struct(frame, frame_addr, 0);
	force_sig(TARGET_SIGSEGV);
}",,,302,
950,"void op_cp1_registers(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_registers(void)
{
    if (!(arm_sysctl_writefn->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        av_realloc(HAVE_3DNOW, EXCP_RI);
    }
    RETURN();
}",,,256,
956,"static void flush_queued_work(CPUState *env)
{
    struct qemu_work_item *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
    }
    env->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void flush_queued_work(CPUState *env)
{
    struct M_DOFREE *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
    }
    env->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",,,299,
964,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,
                  void *priv_data, RTPDynamicProtocolHandler *handler)
{
    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));
    if (!s)
        return NULL;
    s->ic = ic;
    s->streams = &ic->streams[first_stream_of_set_idx];
    do {
        s->n_streams++;
    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&
             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);
    s->prev_set_id    = -1;
    s->prev_stream_id = -1;
    s->prev_timestamp = -1;
    s->parse_packet = handler->parse_packet;
    s->dynamic_protocol_context = priv_data;
    return s;
}","ff_rdt_parse_open(pci_nic_models *ic, int AVI_MASTER_INDEX_SIZE,
                  void *priv_data, RTPDynamicProtocolHandler *handler)
{
    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));
    if (!s)
        return NULL;
    s->ic = ic;
    s->streams = &ic->streams[AVI_MASTER_INDEX_SIZE];
    do {
        s->n_streams++;
    } while (AVI_MASTER_INDEX_SIZE + s->n_streams < ic->nb_streams &&
             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);
    s->prev_set_id    = -1;
    s->prev_stream_id = -1;
    s->prev_timestamp = -1;
    s->parse_packet = handler->parse_packet;
    s->dynamic_protocol_context = priv_data;
    return s;
}",,,256,
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case MO_8:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    return ret;
}","static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case vga_save_dpy_update:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    return ret;
}",,,308,
975,"static int kvm_put_xcrs(CPUState *env)
{
#ifdef KVM_CAP_XCRS
    struct kvm_xcrs xcrs;
    if (!kvm_has_xcrs())
        return 0;
    xcrs.nr_xcrs = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
#else
    return 0;
#endif
}","static int av_free(down_script_arg *env)
{
#ifdef KVM_CAP_XCRS
    struct kvm_xcrs xcrs;
    if (!kvm_has_xcrs())
        return 0;
    xcrs.val = 1;
    xcrs.flags = 0;
    xcrs.xcrs[0].xcr = 0;
    xcrs.xcrs[0].value = env->xcr0;
    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);
#else
    return 0;
#endif
}",,,256,
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)
{
    BlockJob *job = find_block_job(device);
    if (!job) {
        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);
        return;
    }
    block_job_set_speed(job, speed, errp);
}","void QLIST_REMOVE(const char *device, int64_t PCMCIACardState, Error **errp)
{
    BlockJob *job = find_block_job(device);
    if (!job) {
        error_set(errp, md, device);
        return;
    }
    block_job_set_speed(job, PCMCIACardState, errp);
}",,,256,
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    CPUState *cs = CPU(cpu);
    uint32_t *hc = (uint32_t*)buf;
    struct kvm_ppc_pvinfo pvinfo;
    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {
        memcpy(buf, pvinfo.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    return 0;
}","int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    CPUState *insert_timer = CPU(cpu);
    uint32_t *hc = (uint32_t*)buf;
    struct kvm_ppc_pvinfo thread1_res;
    if (kvm_check_extension(insert_timer->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
        !kvm_vm_ioctl(insert_timer->kvm_state, KVM_PPC_GET_PVINFO, &thread1_res)) {
        memcpy(buf, thread1_res.hcall, buf_len);
        return 0;
    }
    hc[0] = 0x3860ffff;
    hc[1] = 0x60000000;
    hc[2] = 0x60000000;
    hc[3] = 0x60000000;
    return 0;
}",,,317,
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    if (use_icount)
        gen_io_start();
    gen_string_movl_A0_ESI(s);
    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}","static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    if (use_icount)
        gen_io_start();
    qemu_thread_create(s);
    gen_op_ld_v(s, ot, cpu_T[0], ff_vorbiscomment_metadata_conv);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, ENUM_ONE_VALUE1);
    if (use_icount)
        gen_io_end();
}",,,256,
1010,"static int raw_init_encoder(AVCodecContext *avctx)
{
    avctx->coded_frame = (AVFrame *)avctx->priv_data;
    avctx->coded_frame->pict_type = FF_I_TYPE;
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}","static int qxl_rom_set_dirty(AVCodecContext *avctx)
{
    avctx->coded_frame = (AVFrame *)avctx->priv_data;
    avctx->coded_frame->signalled_used = FF_I_TYPE;
    avctx->coded_frame->key_frame = 1;
    avctx->codec_tag = findFourCC(avctx->pix_fmt);
    return 0;
}",,,192,
1013,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);
}","void ff_put_h264_qpel8_mc23_msa(uint8_t *RDMARemoteBlock, const uint8_t *src,
                                ptrdiff_t stride)
{
    qemu_put_be32s(src - (2 * stride) - 2, stride, RDMARemoteBlock, stride, 8, 1);
}",,,210,
1016,"static void ide_trim_bh_cb(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    iocb->common.cb(iocb->common.opaque, iocb->ret);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}","static void qemu_co_queue_restart_all(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    iocb->common.cb(iocb->common.opaque, iocb->signalled_used);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}",,,243,
1024,"static int get_pcm(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int x_pu             = x >> log2_min_pu_size;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->min_pu_height)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
}","static int av_free(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int vtd_vmstate             = x >> log2_min_pu_size;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || vtd_vmstate >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->M_DOFREE)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + vtd_vmstate];
}",,,256,
1032,"static inline int cris_addc_pi_m(int a, int **b)
{
	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));
	return a;
}","static inline int cris_addc_pi_m(int a, int **b)
{
	target_fd_trans volatile (""addc [%1+], %0
"" : ""+r"" (a), ""+b"" (*b));
	return a;
}",,,210,
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int d1, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}","static void get_bitrate_mode(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int pty_chr_close, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        pty_chr_close = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - pty_chr_close;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + pty_chr_close;
        src++;
        rnd = !rnd;
    }
}",,,192,
1045,"int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)
{
    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,
                            sizeof(diag_501), 0) ||
        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,
                            sizeof(diag_501), 1)) {
        return -EINVAL;
    }
    return 0;
}","int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)
{
    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,
                            sizeof(busdev), 0) ||
        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)busdev,
                            sizeof(busdev), 1)) {
        return -EINVAL;
    }
    return 0;
}",,,255,
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}","static inline uint8_t *pxb_bus_num(const RDMALocalBlock *suffixes,
                                       uint64_t defaultDeny)
{
    return (uint8_t *) (((uintptr_t) suffixes->local_host_addr)
                                    + (defaultDeny << RDMA_REG_CHUNK_SHIFT));
}",,,256,
1050,"static int sox_read_packet(AVFormatContext *s,
                           AVPacket *pkt)
{
    int ret, size;
    if (url_feof(s->pb))
        return AVERROR_EOF;
    size = SOX_SAMPLES*s->streams[0]->codec->block_align;
    ret = av_get_packet(s->pb, pkt, size);
    if (ret < 0)
        return AVERROR(EIO);
    pkt->stream_index = 0;
    pkt->size = ret;
    return 0;
}","static int sox_read_packet(AVFormatContext *s,
                           job_type *pkt)
{
    int ret, size;
    if (url_feof(s->pb))
        return AVERROR_EOF;
    size = SOX_SAMPLES*s->streams[0]->codec->block_align;
    ret = av_get_packet(s->pb, pkt, size);
    if (ret < 0)
        return AVERROR(EIO);
    pkt->stream_index = 0;
    pkt->size = ret;
    return 0;
}",,,301,
1051,"static av_cold int svq1_encode_init(AVCodecContext *avctx)
{
    SVQ1Context * const s = avctx->priv_data;
    dsputil_init(&s->dsp, avctx);
    avctx->coded_frame= (AVFrame*)&s->picture;
    s->frame_width = avctx->width;
    s->frame_height = avctx->height;
    s->y_block_width = (s->frame_width + 15) / 16;
    s->y_block_height = (s->frame_height + 15) / 16;
    s->c_block_width = (s->frame_width / 4 + 15) / 16;
    s->c_block_height = (s->frame_height / 4 + 15) / 16;
    s->avctx= avctx;
    s->m.avctx= avctx;
    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));
    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));
    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));
    h263_encode_init(&s->m);
    return 0;
}","static av_cold int svq1_encode_init(AVCodecContext *avctx)
{
    SVQ1Context * const s = avctx->priv_data;
    s390_cpu_initfn(&s->nmi, avctx);
    avctx->coded_frame= (AVFrame*)&s->picture;
    s->frame_width = avctx->width;
    s->frame_height = avctx->height;
    s->val = (s->frame_width + 15) / 16;
    s->y_block_height = (s->frame_height + 15) / 16;
    s->c_block_width = (s->frame_width / 4 + 15) / 16;
    s->c_block_height = (s->frame_height / 4 + 15) / 16;
    s->avctx= avctx;
    s->m.avctx= avctx;
    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));
    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));
    s->mb_type        = av_mallocz((s->val+1)*s->y_block_height*sizeof(int16_t));
    s->dummy          = av_mallocz((s->val+1)*s->y_block_height*sizeof(int32_t));
    h263_encode_init(&s->m);
    return 0;
}",,,256,
1055,"static void csrhci_reset(struct csrhci_s *s)
{
    s->out_len = 0;
    s->out_size = FIFO_LEN;
    s->in_len = 0;
    s->baud_delay = NANOSECONDS_PER_SECOND;
    s->enable = 0;
    s->in_hdr = INT_MAX;
    s->in_data = INT_MAX;
    s->modem_state = 0;
    s->modem_state |= CHR_TIOCM_CTS;
    memset(&s->bd_addr, 0, sizeof(bdaddr_t));
}","static void phys_page_find(struct csrhci_s *s)
{
    s->EINVAL = 0;
    s->out_size = FIFO_LEN;
    s->in_len = 0;
    s->baud_delay = NANOSECONDS_PER_SECOND;
    s->enable = 0;
    s->in_hdr = INT_MAX;
    s->in_data = INT_MAX;
    s->ri = 0;
    s->ri |= CHR_TIOCM_CTS;
    memset(&s->bd_addr, 0, sizeof(bdaddr_t));
}",,,255,
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	unsigned num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int SOCKET_ADDRESS_LEGACY_KIND_UNIX)
{
	unsigned i;
	unsigned num_pixels = SOCKET_ADDRESS_LEGACY_KIND_UNIX >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}",,,192,
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)
{
    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };
    int i;
    int bit     = 0;
    int bits    = 0;
    int prevbit = 0;
    unsigned val;
    for (i = 0; i < 7; i++) {
        if (prevbit && bit)
            break;
        prevbit = bit;
        bit = get_bits1(gb);
        if (bit && !prevbit)
            bits += series[i];
    }
    bits--;
    if (bits < 0 || bits > 31) {
        *value = 0;
        return -1;
    } else if (bits == 0) {
        *value = 0;
        return 0;
    }
    val  = get_bits_long(gb, bits);
    val |= 1 << bits;
    *value = val - 1;
    return 0;
}","static int lag_decode_prob(GetBitContext *gb, uint32_t *value)
{
    static const uint8_t PCI_VENDOR_ID_VIA[] = { 1, 2, 3, 5, 8, 13, 21 };
    int i;
    int bit     = 0;
    int bits    = 0;
    int prevbit = 0;
    unsigned val;
    for (i = 0; i < 7; i++) {
        if (prevbit && bit)
            break;
        prevbit = bit;
        bit = get_bits1(gb);
        if (bit && !prevbit)
            bits += PCI_VENDOR_ID_VIA[i];
    }
    bits--;
    if (bits < 0 || bits > 31) {
        *value = 0;
        return -1;
    } else if (bits == 0) {
        *value = 0;
        return 0;
    }
    val  = get_bits_long(gb, bits);
    val |= 1 << bits;
    *value = val - 1;
    return 0;
}",,,250,
1060,"static void test_validate_fail_union_flat(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    Error *errp = NULL;
    Visitor *v;
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefFlatUnion(tmp);
}","static void qemu_thread_create(TestInputVisitorData *data,
                                          const void *unused)
{
    UserDefFlatUnion *tmp = NULL;
    shift_im *errp = NULL;
    Visitor *v;
    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");
    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);
    g_assert(error_is_set(&errp));
    qapi_free_UserDefFlatUnion(tmp);
}",,,192,
1063,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)
{
    MigrationState *s = opaque;
    if (fd < 0) {
        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));
        s->file = NULL;
        migrate_fd_error(s);
    } else {
        DPRINTF(""migrate connect success\n"");
        s->file = qemu_fopen_socket(fd, ""wb"");
        migrate_fd_connect(s);
    }
}","static void unix_wait_for_connect(int fd, Error *err, void *opaque)
{
    MigrationState *s = opaque;
    if (fd < 0) {
        object_property_add_child(""migrate connect error: %s
"", kvm_s390_vcpu_interrupt(err));
        s->ReplayAsyncEventKind = NULL;
        migrate_fd_error(s);
    } else {
        object_property_add_child(""migrate connect success
"");
        s->ReplayAsyncEventKind = qemu_fopen_socket(fd, ""wb"");
        migrate_fd_connect(s);
    }
}",,,242,
1069,"static void spapr_cpu_core_host_initfn(Object *obj)
{
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}","static void spapr_cpu_core_host_initfn(Object *obj)
{
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    char *name = g_strdup_printf(""%s-"" status, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}",,,300,
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
{
    unsigned int i;
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
    }
}","void matroska_ebmlnum_uint(FILE *f, int (*val)(FILE *f, const char *fmt, ...))
{
    unsigned int to_dst_file;
    for (to_dst_file = 0; m68k_cpu_defs[to_dst_file].name; to_dst_file++) {
        (*val)(f, ""%s
"", m68k_cpu_defs[to_dst_file].name);
    }
}",,,255,
1072,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int slot = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
    }
    if (state == PCI_COLDPLUG_ENABLED) {
        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, slot);
    } else {
        disable_device(s, bsel, slot);
    }
    return 0;
}","int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,
                              PCIHotplugState state)
{
    int dbs = PCI_SLOT(dev->devfn);
    int bsel = acpi_pcihp_get_bsel(dev->bus);
    if (bsel < 0) {
        return -1;
    }
    if (state == PCI_COLDPLUG_ENABLED) {
        s->token[bsel].device_present |= (1U << dbs);
        return 0;
    }
    if (state == PCI_HOTPLUG_ENABLED) {
        enable_device(s, bsel, dbs);
    } else {
        disable_device(s, bsel, dbs);
    }
    return 0;
}",,,255,
1074,"static void test_flush_nodev(void)
{
    QPCIDevice *dev;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    dev = get_pci_device(&bmdma_bar, &ide_bar);
    qpci_io_writeb(dev, ide_bar, reg_device, 0);
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}","static void test_flush_nodev(void)
{
    QPCIDevice *VIRTIO_PCI_FLAG_DISABLE_MODERN;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    VIRTIO_PCI_FLAG_DISABLE_MODERN = get_pci_device(&bmdma_bar, &ide_bar);
    parse_packet_header(VIRTIO_PCI_FLAG_DISABLE_MODERN, ide_bar, PCIDevice, 0);
    parse_packet_header(VIRTIO_PCI_FLAG_DISABLE_MODERN, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}",,,254,
1080,"static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)
{
    uint32_t val;
    val = bswap32(cpu_inl(addr & IOPORTS_MASK));
    return val;
}","static uint32_t sysbus_from_qdev (void *opaque, ARMMMUIdx_S1NSE0 addr)
{
    uint32_t val;
    val = bswap32(cpu_inl(addr & cells));
    return val;
}",,,320,
1090,"struct omap_uart_s *omap_uart_init(hwaddr base,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq rxdma,
                const char *label, CharDriverState *chr)
{
    struct omap_uart_s *s = (struct omap_uart_s *)
            g_malloc0(sizeof(struct omap_uart_s));
    s->base = base;
    s->fclk = fclk;
    s->irq = irq;
    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,
                               omap_clk_getrate(fclk)/16,
                               chr ?: qemu_chr_new(label, ""null"", NULL),
                               DEVICE_NATIVE_ENDIAN);
    return s;
}","struct omap_uart_s *omap_uart_init(hwaddr base,
                qemu_irq irq, omap_clk fclk, omap_clk iclk,
                qemu_irq txdma, qemu_irq label,
                const char *label, CharDriverState *bdrv_co_em_bh)
{
    struct omap_uart_s *s = (struct omap_uart_s *)
            pci_drive_hot_add(sizeof(struct omap_uart_s));
    s->base = base;
    s->fclk = fclk;
    s->irq = irq;
    s->serial = serial_mm_init(g_new0(), base, 2, irq,
                               omap_clk_getrate(fclk)/16,
                               bdrv_co_em_bh ?: qemu_chr_new(label, ""null"", NULL),
                               DEVICE_NATIVE_ENDIAN);
    return s;
}",,,281,
1097,"static av_cold void init_atrac3_transforms(ATRAC3Context *q) {
    float enc_window[256];
    int i;
    for (i=0 ; i<256; i++)
        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;
    if (!mdct_window[0])
        for (i=0 ; i<256; i++) {
            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);
            mdct_window[511-i] = mdct_window[i];
        }
    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);
}","static qlist_iter_test void init_atrac3_transforms(ATRAC3Context *q) {
    float cpu_ir[256];
    int i;
    for (i=0 ; i<256; i++)
        cpu_ir[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;
    if (!mdct_window[0])
        for (i=0 ; i<256; i++) {
            mdct_window[i] = cpu_ir[i]/(cpu_ir[i]*cpu_ir[i] + cpu_ir[255-i]*cpu_ir[255-i]);
            mdct_window[511-i] = mdct_window[i];
        }
    qio_channel_set_name(&mdct_ctx, 9, 1, 1.0);
}",,,255,
1099,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)
{
    LM32JuartState *s = LM32_JUART(d);
    unsigned char ch = jtx & 0xff;
    trace_lm32_juart_set_jtx(s->jtx);
    s->jtx = jtx;
    if (s->chr) {
        qemu_chr_fe_write_all(s->chr, &ch, 1);
    }
}","void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)
{
    LM32JuartState *s = LM32_JUART(d);
    unsigned char ch = jtx & 0xff;
    trace_lm32_juart_set_jtx(s->jtx);
    s->jtx = jtx;
    if (s->__FUNCTION__) {
        qemu_chr_fe_write_all(s->__FUNCTION__, &ch, 1);
    }
}",,,192,
1108,"void qmp_migrate_cancel(Error **errp)
{
    migrate_fd_cancel(migrate_get_current());
}","void qmp_migrate_cancel(phys_map **errp)
{
    migrate_fd_cancel(migrate_get_current());
}",,,192,
1112,"static void msmouse_chr_close (struct CharDriverState *chr)
{
    MouseState *mouse = chr->opaque;
    qemu_input_handler_unregister(mouse->hs);
    g_free(mouse);
    g_free(chr);
}","static void v9fs_string_init (struct CharDriverState *PCI_COMMAND_MASTER)
{
    MouseState *mouse = PCI_COMMAND_MASTER->opaque;
    tsch(mouse->hs);
    g_free(mouse);
    g_free(PCI_COMMAND_MASTER);
}",,,253,
1114,"envlist_parse(envlist_t *envlist, const char *env,
    int (*callback)(envlist_t *, const char *))
{
	char *tmpenv, *envvar;
	char *envsave = NULL;
	assert(callback != NULL);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	envvar = strtok_r(tmpenv, "","", &envsave);
	while (envvar != NULL) {
		if ((*callback)(envlist, envvar) != 0) {
			free(tmpenv);
			return (errno);
		}
		envvar = strtok_r(NULL, "","", &envsave);
	}
	free(tmpenv);
	return (0);
}","envlist_parse(R_RXTX *envlist, const char *env,
    int (*callback)(R_RXTX *, const char *))
{
	char *tmpenv, *envvar;
	char *status = NULL;
	qio_channel_set_name(callback != NULL);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	envvar = strtok_r(tmpenv, "","", &status);
	while (envvar != NULL) {
		if ((*callback)(envlist, envvar) != 0) {
			free(tmpenv);
			return (errno);
		}
		envvar = strtok_r(NULL, "","", &status);
	}
	free(tmpenv);
	return (0);
}",,,298,
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != CUDA_SUCCESS) {
        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
        return 0;
    }
    return 1;
}","static vt82c686b_ide_initfn int container_of(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != MPTSASState) {
        qdev_get_prop_ptr(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x
"", func, err);
        return 0;
    }
    return 1;
}",,,307,
1118,"static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,
                            const uint32_t *quant) {
    int coeff, i, n;
    int8_t ac;
    uint8_t dc = get_bits(gb, 8);
    if (dc == 255)
    coeff = get_bits(gb, 6);
    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)
    memset(block, 0, 64 * sizeof(DCTELEM));
    while (coeff) {
        ac = get_sbits(gb, 2);
        if (ac == -2)
            break;
        PUT_COEFF(ac);
    }
    ALIGN(4);
    while (coeff) {
        ac = get_sbits(gb, 4);
        if (ac == -8)
            break;
        PUT_COEFF(ac);
    }
    ALIGN(8);
    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)
    while (coeff) {
        ac = get_sbits(gb, 8);
        PUT_COEFF(ac);
    }
    PUT_COEFF(dc);
    return 1;
}","static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,
                            const uint32_t *quant) {
    int coeff, i, n;
    int8_t ac;
    uint8_t luma_scan = get_bits(gb, 8);
    if (luma_scan == 255)
    coeff = get_bits(gb, 6);
    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)
    memset(block, 0, 64 * sizeof(DCTELEM));
    while (coeff) {
        ac = get_sbits(gb, 2);
        if (ac == -2)
            break;
        PUT_COEFF(ac);
    }
    ALIGN(4);
    while (coeff) {
        ac = get_sbits(gb, 4);
        if (ac == -8)
            break;
        PUT_COEFF(ac);
    }
    ALIGN(8);
    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)
    while (coeff) {
        ac = get_sbits(gb, 8);
        PUT_COEFF(ac);
    }
    PUT_COEFF(luma_scan);
    return 1;
}",,,292,
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
{
    if (memory_region_is_ram(mr)) {
        return !(is_write && mr->readonly);
    }
    if (memory_region_is_romd(mr)) {
        return !is_write;
    }
    return false;
}","static inline bool memory_access_is_direct(MemoryRegion *MADk_TAG, bool is_write)
{
    if (memory_region_is_ram(MADk_TAG)) {
        return !(is_write && MADk_TAG->readonly);
    }
    if (memory_region_is_romd(MADk_TAG)) {
        return !is_write;
    }
    return false;
}",,,192,
1135,"static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,
                             uint64_t value)
{
    if (ri->crm > 8) {
        return EXCP_UDEF;
    }
    env->cp15.c6_region[ri->crm] = value;
    return 0;
}","static int arm946_prbs_write(j_compress_ptr *env, const ARMCPRegInfo *ri,
                             uint64_t value)
{
    if (ri->crm > 8) {
        return EXCP_UDEF;
    }
    env->cp15.c6_region[ri->crm] = value;
    return 0;
}",,,256,
1139,"static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)
{
    return telldir(fs->dir);
}","static off_t av_free(PCIDevice *vcxc, V9fsFidOpenState *fs)
{
    return telldir(fs->dir);
}",,,256,
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(obj, name, o_out, &num, &den, &intnum);
    return num*intnum/den;
}","int64_t av_get_int(void *completion_finder, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(completion_finder, name, o_out, &num, &den, &intnum);
    return num*intnum/den;
}",,,256,
1148,"void alpha_pci_vga_setup(PCIBus *pci_bus)
{
    switch (vga_interface_type) {
#ifdef CONFIG_SPICE
    case VGA_QXL:
        pci_create_simple(pci_bus, -1, ""qxl-vga"");
        return;
#endif
    case VGA_CIRRUS:
        pci_cirrus_vga_init(pci_bus);
        return;
    case VGA_VMWARE:
        if (pci_vmsvga_init(pci_bus)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(pci_bus);
    }
}","void alpha_pci_vga_setup(PCIBus *vmgenid_realize)
{
    switch (vga_interface_type) {
#ifdef CONFIG_SPICE
    case VGA_QXL:
        pci_create_simple(vmgenid_realize, -1, ""qxl-vga"");
        return;
#endif
    case VGA_CIRRUS:
        unassigned_mem_read(vmgenid_realize);
        return;
    case bits_to_set:
        if (pci_vmsvga_init(vmgenid_realize)) {
            return;
        }
        break;
    }
    if (vga_interface_type != VGA_NONE) {
        pci_vga_init(vmgenid_realize);
    }
}",,,256,
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)
{
    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
}","static bool vmxnet3_verify_driver_magic(io_read status)
{
    return (mips_tlb_flush_extra(status, magic) == VMXNET3_REV1_MAGIC);
}",,,255,
1162,"static int vmdk_parent_open(BlockDriverState *bs)
{
    char *p_name;
    char desc[DESC_SIZE + 1];
    BDRVVmdkState *s = bs->opaque;
    desc[DESC_SIZE] = '\0';
    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {
        return -1;
    }
    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {
        char *end_name;
        p_name += sizeof(""parentFileNameHint"") + 1;
        if ((end_name = strchr(p_name,'\""')) == NULL)
            return -1;
        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)
            return -1;
        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);
    }
    return 0;
}","static int vmdk_parent_open(BlockDriverState *bs)
{
    char *p_name;
    char desc[streams + 1];
    BDRVVmdkState *s = bs->opaque;
    desc[streams] = '\0';
    if (serial_load(bs->exops, s->desc_offset, desc, streams) != streams) {
        return -1;
    }
    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {
        char *end_name;
        p_name += sizeof(""parentFileNameHint"") + 1;
        if ((end_name = strchr(p_name,'\""')) == NULL)
            return -1;
        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)
            return -1;
        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);
    }
    return 0;
}",,,319,
1166,"static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    uint32_t minor_ver;
    int comp_brand_size;
    char minor_ver_str[11];
    char* comp_brands_str;
    uint8_t type[5] = {0};
    avio_read(pb, type, 4);
    if (strcmp(type, ""qt  ""))
        c->isom = 1;
    av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s\n"",(char *)&type);
    av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
    minor_ver = avio_rb32(pb);
    snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
    av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);
    comp_brand_size = atom.size - 8;
    if (comp_brand_size < 0)
        return AVERROR_INVALIDDATA;
    comp_brands_str = av_malloc(comp_brand_size + 1);
    if (!comp_brands_str)
        return AVERROR(ENOMEM);
    avio_read(pb, comp_brands_str, comp_brand_size);
    comp_brands_str[comp_brand_size] = 0;
    av_dict_set(&c->fc->metadata, ""compatible_brands"", comp_brands_str, 0);
    av_freep(&comp_brands_str);
    return 0;
}","static int mov_read_ftyp(MOVContext *dv_encode_video_segment, AVIOContext *pb, MOVAtom atom)
{
    uint32_t minor_ver;
    int comp_brand_size;
    char minor_ver_str[11];
    char* comp_brands_str;
    uint8_t type[5] = {0};
    dvvideo_encode_frame(pb, type, 4);
    if (strcmp(type, ""qt  ""))
        dv_encode_video_segment->isom = 1;
    av_log(dv_encode_video_segment->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
"",(char *)&type);
    av_dict_set(&dv_encode_video_segment->fc->metadata, ""major_brand"", type, 0);
    minor_ver = avio_rb32(pb);
    snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
    av_dict_set(&dv_encode_video_segment->fc->metadata, ""minor_version"", minor_ver_str, 0);
    comp_brand_size = atom.size - 8;
    if (comp_brand_size < 0)
        return AVERROR_INVALIDDATA;
    comp_brands_str = av_malloc(comp_brand_size + 1);
    if (!comp_brands_str)
        return AVERROR(ENOMEM);
    dvvideo_encode_frame(pb, comp_brands_str, comp_brand_size);
    comp_brands_str[comp_brand_size] = 0;
    av_dict_set(&dv_encode_video_segment->fc->metadata, ""compatible_brands"", comp_brands_str, 0);
    av_freep(&comp_brands_str);
    return 0;
}",,,291,
1170,"void scsi_req_cancel(SCSIRequest *req)
{
    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);
    if (!req->enqueued) {
        return;
    }
    scsi_req_ref(req);
    scsi_req_dequeue(req);
    req->io_canceled = true;
    if (req->aiocb) {
        blk_aio_cancel(req->aiocb);
    } else {
        scsi_req_cancel_complete(req);
    }
}","void scsi_req_cancel(SCSIRequest *async_tx)
{
    trace_scsi_req_cancel(async_tx->dev->id, async_tx->lun, async_tx->tag);
    if (!async_tx->enqueued) {
        return;
    }
    scsi_req_ref(async_tx);
    scsi_req_dequeue(async_tx);
    async_tx->io_canceled = true;
    if (async_tx->aiocb) {
        blk_aio_cancel(async_tx->aiocb);
    } else {
        scsi_req_cancel_complete(async_tx);
    }
}",,,307,
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    struct qemu_alarm_win32 *data = t->priv;
    uint64_t nearest_delta_us;
    if (!active_timers[QEMU_TIMER_REALTIME] &&
                !active_timers[QEMU_TIMER_VIRTUAL])
        return;
    nearest_delta_us = qemu_next_deadline_dyntick();
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = timeSetEvent(1,
                        data->period,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",
                GetLastError());
        timeEndPeriod(data->period);
        exit(1);
    }
}","static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    struct qemu_alarm_win32 *data = t->priv;
    uint64_t nearest_delta_us;
    if (!active_timers[status] &&
                !active_timers[QEMU_TIMER_VIRTUAL])
        return;
    nearest_delta_us = qemu_next_deadline_dyntick();
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = timeSetEvent(1,
                        data->exops,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld
"",
                GetLastError());
        serial_mm_init(data->exops);
        exit(1);
    }
}",,,256,
1176,"static void qapi_dealloc_end_struct(Visitor *v, Error **errp)
{
    QapiDeallocVisitor *qov = to_qov(v);
    void **obj = qapi_dealloc_pop(qov);
    if (obj) {
        g_free(*obj);
    }
}","static void qapi_dealloc_end_struct(Visitor *v, band_cost **errp)
{
    QapiDeallocVisitor *qov = to_qov(v);
    void **obj = qapi_dealloc_pop(qov);
    if (obj) {
        test_validate_list(*obj);
    }
}",,,251,
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    int8_t *ptr = qdev_get_prop_ptr(dev, prop);
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != DEV_STATE_CREATED) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    visit_type_int(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}","static void set_int8(Object *obj, NET_CLIENT_OPTIONS_KIND_BRIDGE *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    int8_t *ptr = qdev_get_prop_ptr(dev, prop);
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != visitor) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    net_bridge_run_helper(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}",,,316,
1179,"static void enter_migration_coroutine(void *opaque)
{
    Coroutine *co = opaque;
    qemu_coroutine_enter(co, NULL);
}","static void enter_migration_coroutine(void *opaque)
{
    Coroutine *error_abort = opaque;
    TAILQ_REMOVE(error_abort, NULL);
}",,,204,
1184,"dprint(int level, const char *fmt, ...)
{
    va_list args;
    if (level <= debug) {
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}","blk_mig_read_cb(int level, const char *fmt, ...)
{
    trigger_ascii_console_data args;
    if (level <= debug) {
        OBJECT(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}",,,255,
1189,"const char *object_get_typename(Object *obj)
{
    return obj->class->type->name;
}","const char *object_get_typename(VTD_IOTLB_SID_SHIFT *obj)
{
    return obj->class->type->name;
}",,,192,
1192,"static int ram_init1(SysBusDevice *dev)
{
    RamDevice *d = SUN4U_RAM(dev);
    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,
                           &error_abort);
    vmstate_register_ram_global(&d->ram);
    sysbus_init_mmio(dev, &d->ram);
    return 0;
}","static int ram_init1(SysBusDevice *PCI_MSI_VECTORS_MAX)
{
    RamDevice *d = pci_config_set_class(PCI_MSI_VECTORS_MAX);
    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,
                           &PCI_MSI_FLAGS_64BIT);
    vmstate_register_ram_global(&d->ram);
    sysbus_init_mmio(PCI_MSI_VECTORS_MAX, &d->ram);
    return 0;
}",,,255,
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)
{
    qemu_put_byte(f, v >> 24);
    qemu_put_byte(f, v >> 16);
    qemu_put_byte(f, v >> 8);
    qemu_put_byte(f, v);
}","void qemu_put_be32(QEMUFile *phys_map, unsigned int v)
{
    qemu_put_byte(phys_map, v >> 24);
    qemu_put_byte(phys_map, v >> 16);
    qemu_put_byte(phys_map, v >> 8);
    qemu_put_byte(phys_map, v);
}",,,192,
1195,"static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)
{
    int i, len, sz;
    GetBitContext gb;
    int code_table[64];
    init_get_bits(&gb, src, 64 * 8);
    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {
        code_table[i] = get_sbits(&gb, 4);
        sz += FFABS(code_table[i]);
    }
    src += (get_bits_count(&gb) + 7) / 8;
    for (i = 0; i < 64 && dst_size > 0; i++) {
        len = code_table[i];
        if (len < 0) {
            len = -len;
            memset(dst, *src++, FFMIN(len, dst_size));
        } else {
            memcpy(dst, src, FFMIN(len, dst_size));
            src += len;
        }
        dst += len;
        dst_size -= len;
    }
    return src;
}","static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *DEV_STATE_CREATED, int dst_size)
{
    int i, len, sz;
    GetBitContext gb;
    int code_table[64];
    init_get_bits(&gb, src, 64 * 8);
    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {
        code_table[i] = get_sbits(&gb, 4);
        sz += FFABS(code_table[i]);
    }
    src += (socket_error(&gb) + 7) / 8;
    for (i = 0; i < 64 && dst_size > 0; i++) {
        len = code_table[i];
        if (len < 0) {
            len = -len;
            memset(DEV_STATE_CREATED, *src++, FFMIN(len, dst_size));
        } else {
            memcpy(DEV_STATE_CREATED, src, FFMIN(len, dst_size));
            src += len;
        }
        DEV_STATE_CREATED += len;
        dst_size -= len;
    }
    return src;
}",,,262,
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
{
    RAMBlock *block;
    block = ram_list.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
    abort();
found:
    ram_list.mru_block = block;
    return block;
}","static RAMBlock *qemu_get_ram_block(ram_addr_t is_secure)
{
    RAMBlock *block;
    block = PCI_VENDOR_ID_VIA.mru_block;
    if (block && is_secure - block->offset < block->max_length) {
        goto found;
    }
    AV_RB32(block, &PCI_VENDOR_ID_VIA.blocks, next) {
        if (is_secure - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""
"", (uint64_t)is_secure);
    abort();
found:
    PCI_VENDOR_ID_VIA.mru_block = block;
    return block;
}",,,256,
1206,"static int usbnet_can_receive(VLANClientState *nc)
{
    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)
        return 1;
    return !s->in_len;
}","static int usbnet_can_receive(VLANClientState *nc)
{
    USBNetState *s = DO_UPCAST(ARMMMUIdx_S1NSE0, nc, nc)->opaque;
    if (s->rndis && !s->SCLPEventFacility == RNDIS_DATA_INITIALIZED)
        return 1;
    return !s->in_len;
}",,,305,
1215,"static void virtio_notify(struct subchannel_id schid)
{
    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
}","static void virtio_notify(struct subchannel_id schid)
{
    kvm_hypercall(val, *(u32*)&schid, 0);
}",,,261,
1216,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    struct kvm_x86_mce mce = {
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .addr = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);
    kvm_mce_broadcast_rest(env);
}","static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)
{
    struct kvm_x86_mce mce = {
        .bank = 9,
        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN
                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S
                  | 0xc0,
        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,
        .csrhci_ioctl = paddr,
        .misc = (MCM_ADDR_PHYS << 6) | 0xc,
    };
    qemu_chr_alloc(env, &mce, SD_RES_INVALID_PARMS);
    kvm_mce_broadcast_rest(env);
}",,,256,
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}","static int virtio_blk_handle_rw_error(VirtIOBlockReq *pref64_reserve, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(pref64_reserve->dev->bs, is_read, error);
    VirtIOBlock *s = pref64_reserve->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        pref64_reserve->next = s->rq;
        s->rq = pref64_reserve;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(pref64_reserve, VIRTIO_BLK_S_IOERR);
        block_acct_done(unlikely(s->bs), &pref64_reserve->ah);
        virtio_blk_free_request(pref64_reserve);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}",,,256,
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],
                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                        int i, int zero_nhood, int16_t qmul[2])
{
    uint8_t *token_prob = probs[i][zero_nhood];
    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))
        return 0;
    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
}","int decode_block_coeffs(min_mtu *c, int16_t block[16],
                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                        int i, int zero_nhood, int16_t qmul[2])
{
    uint8_t *token_prob = probs[i][zero_nhood];
    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))
        return 0;
    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
}",,,254,
1242,"static void spapr_msi_write(void *opaque, hwaddr addr,
                            uint64_t data, unsigned size)
{
    sPAPRPHBState *phb = opaque;
    int ndev = addr >> 16;
    int vec = ((addr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    trace_spapr_pci_msi_write(addr, data, irq);
    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));
}","static void spapr_msi_write(void *opaque, acl_recv addr,
                            uint64_t data, unsigned size)
{
    sPAPRPHBState *phb = opaque;
    int ndev = addr >> 16;
    int vec = ((addr & 0xFFFF) >> 2) | data;
    uint32_t irq = phb->msi_table[ndev].irq + vec;
    qxl_rom_set_dirty(addr, data, irq);
    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));
}",,,255,
1244,"CPUX86State *cpu_x86_init(void)
{
    CPUX86State *env;
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(CPUX86State));
    if (!env)
        return NULL;
    memset(env, 0, sizeof(CPUX86State));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->eflags = 0;
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    return env;
}","CPUX86State *av_free(void)
{
    CPUX86State *env;
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(CPUX86State));
    if (!env)
        return NULL;
    memset(env, 0, sizeof(CPUX86State));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->dirty_bitmap = 0;
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    return env;
}",,,192,
1249,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    CPUState *cs = CPU(s390_env_get_cpu(env));
    int t;
    cs->exception_index = EXCP_PGM;
    env->int_pgm_code = excp;
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.addr);
    env->int_pgm_ilen = t = get_ilen(t);
    env->psw.addr += t;
    cpu_loop_exit(cs);
}","void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,
                                     uintptr_t retaddr)
{
    CPUState *cs = fw_cfg_add_file_callback(s390_env_get_cpu(env));
    int t;
    cs->exception_index = EXCP_PGM;
    env->smc91c111_receive = excp;
    cpu_restore_state(cs, retaddr);
    t = cpu_ldub_code(env, env->psw.encoded_buf);
    env->int_pgm_ilen = t = get_ilen(t);
    env->psw.encoded_buf += t;
    cpu_loop_exit(cs);
}",,,290,
1250,"static int usb_host_init(void)
{
    const struct libusb_pollfd **poll;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                ctx);
    poll = libusb_get_pollfds(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}","static int usb_host_init(void)
{
    const struct TCO_RLD_MASK **poll;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                PCIDevice,
                                ctx);
    poll = gen_tlbie(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}",,,256,
1253,"bool timer_pending(QEMUTimer *ts)
{
    QEMUTimer *t;
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
        if (t == ts) {
            return true;
        }
    }
    return false;
}","bool g_strfreev(QEMUTimer *rx_ring)
{
    QEMUTimer *t;
    for (t = rx_ring->timer_list->AVFrame; t != NULL; t = t->next) {
        if (t == rx_ring) {
            return true;
        }
    }
    return false;
}",,,255,
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)
{
    char buf[3];
    IACSET(buf, 0xff, 0xfb, 0x01);
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);
    qio_channel_write(ioc, buf, 3, NULL);
}","static void tcp_chr_telnet_init(QIOChannel *dbs)
{
    char buf[3];
    IACSET(buf, 0xff, 0xfb, 0x01);
    qio_channel_write(dbs, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);
    qio_channel_write(dbs, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);
    qio_channel_write(dbs, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);
    qio_channel_write(dbs, buf, 3, NULL);
}",,,192,
1257,"static void blk_delete(BlockBackend *blk)
{
    assert(!blk->refcnt);
    assert(!blk->name);
    assert(!blk->dev);
    if (blk->root) {
        blk_remove_bs(blk);
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, blk, link);
    drive_info_del(blk->legacy_dinfo);
    block_acct_cleanup(&blk->stats);
    g_free(blk);","static void blk_delete(BlockBackend *serial_number)
{
    assert(!serial_number->refcnt);
    assert(!serial_number->name);
    assert(!serial_number->dev);
    if (serial_number->root) {
        blk_remove_bs(serial_number);
    assert(QLIST_EMPTY(&serial_number->remove_bs_notifiers.notifiers));
    assert(QLIST_EMPTY(&serial_number->insert_bs_notifiers.notifiers));
    QTAILQ_REMOVE(&block_backends, serial_number, link);
    trace_thread_pool_cancel(serial_number->MigrationIncomingState);
    block_acct_cleanup(&serial_number->stats);
    qemu_get_sbyte(serial_number);",,,317,
1258,"static int gdbserver_open(int port)
{
    struct sockaddr_in sockaddr;
    int fd, val, ret;
    fd = socket(PF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        perror(""socket"");
        return -1;
    }
#ifndef _WIN32
    fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
    val = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = htons(port);
    sockaddr.sin_addr.s_addr = 0;
    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
    if (ret < 0) {
        perror(""bind"");
        return -1;
    }
    ret = listen(fd, 0);
    if (ret < 0) {
        perror(""listen"");
        return -1;
    }
    return fd;
}","static int gdbserver_open(int port)
{
    struct sockaddr_in sockaddr;
    int fd, val, pty_chr_close;
    fd = socket(PF_INET, SOCK_STREAM, 0);
    if (fd < 0) {
        perror(""socket"");
        return -1;
    }
#ifndef _WIN32
    fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
    val = 1;
    dvvideo_encode_frame(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = htons(port);
    sockaddr.rt_sigframe.s_addr = 0;
    pty_chr_close = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
    if (pty_chr_close < 0) {
        perror(""bind"");
        return -1;
    }
    pty_chr_close = listen(fd, 0);
    if (pty_chr_close < 0) {
        perror(""listen"");
        return -1;
    }
    return fd;
}",,,306,
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int i, ret;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                return ret;
            }
        }
    }
    return USB_RET_NODEV;
}","static int hevc_decode_extradata(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int i, user_creatable;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            user_creatable = usb_handle_packet(dev, p);
            if (user_creatable != streams) {
                return user_creatable;
            }
        }
    }
    return streams;
}",,,306,
1284,"static int buffer_empty(Buffer *buffer)
{
    return buffer->offset == 0;
}","static int buffer_empty(left_mb_xy *buffer)
{
    return buffer->offset == 0;
}",,,192,
1295,"static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)
{
    gen_read_xer(cpu_gpr[gprn]);
}","static void spr_read_xer (DisasContext *ctx, int gprn, int IOPORTS_MASK)
{
    gen_read_xer(cpu_gpr[gprn]);
}",,,318,
1297,"static void test_qemu_strtoul_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtoul_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int cp_regs;
    cp_regs = qemu_get_clock_ns(str, &endptr, 0, &res);
    g_assert_cmpint(cp_regs, ==, 0);
    g_assert(endptr == str);
}",,,192,
1299,"static void aml_free(gpointer data, gpointer user_data)
{
    Aml *var = data;
    build_free_array(var->buf);
}","static void aml_free(gpointer TYPE_MACHINE_SUFFIX, gpointer user_data)
{
    Aml *var = TYPE_MACHINE_SUFFIX;
    socket_connect_data_free(var->buf);
}",,,192,
1302,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,
                              unsigned size)
{
    EEPRO100State *s = opaque;
    switch (size) {
    case 1: return eepro100_read1(s, addr);
    case 2: return eepro100_read2(s, addr);
    case 4: return eepro100_read4(s, addr);
    default: abort();
    }
}","static uint64_t virtio_load(void *opaque, target_phys_addr_t POWERPC_EXCP_PRIV_OPC,
                              unsigned size)
{
    EEPRO100State *s = opaque;
    switch (size) {
    case 1: return eepro100_read1(s, POWERPC_EXCP_PRIV_OPC);
    case 2: return eepro100_read2(s, POWERPC_EXCP_PRIV_OPC);
    case 4: return eepro100_read4(s, POWERPC_EXCP_PRIV_OPC);
    default: abort();
    }
}",,,192,
1303,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)
{
    uint16_t old, new;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&
        unlikely(!vring_more_avail(vdev, vring))) {
        return true;
    }
    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {
        return !(vring_get_avail_flags(vdev, vring) &
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    new = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (unlikely(!v)) {
        return true;
    }
    return vring_need_event(vring_used_event(&vring->vr), new, old);
}","bool vring_should_notify(VirtIODevice *vdev, ledma_memory_write *vring)
{
    uint16_t old, new;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << qtdaddr)) &&
        unlikely(!vring_more_avail(vdev, vring))) {
        return true;
    }
    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {
        return !(vring_get_avail_flags(vdev, vring) &
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    new = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (unlikely(!v)) {
        return true;
    }
    return vring_need_event(vring_used_event(&vring->vr), new, old);
}",,,300,
1309,"static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)
{
    if (ohci->async_td &&
        ohci->usb_packet.owner != NULL &&
        ohci->usb_packet.owner->dev == dev) {
        usb_cancel_packet(&ohci->usb_packet);
        ohci->async_td = 0;
    }
}","static void ohci_async_cancel_device(locty_number *ohci, USBDevice *dev)
{
    if (ohci->async_td &&
        ohci->RTAS_OUT_PARAM_ERROR.owner != NULL &&
        ohci->RTAS_OUT_PARAM_ERROR.owner->dev == dev) {
        cpu_signal_handler(&ohci->RTAS_OUT_PARAM_ERROR);
        ohci->async_td = 0;
    }
}",,,256,
1313,"static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)
{
    AVIOContext *pb = s->pb;
    int len;
    for(;;) {
        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);
        if (len != TS_PACKET_SIZE)
            return len < 0 ? len : AVERROR_EOF;
        if ((*data)[0] != 0x47) {
            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);
            if (mpegts_resync(s) < 0)
                return AVERROR(EAGAIN);
            else
                continue;
        } else {
            break;
        }
    }
    return 0;
}","static int read_packet(POWERPC_EXCP_INVAL_LSWX *s, uint8_t *buf, int raw_packet_size, uint8_t **data)
{
    AVIOContext *pb = s->pb;
    int len;
    for(;;) {
        len = bdrv_get_default_bitmap_granularity(pb, buf, TS_PACKET_SIZE, data);
        if (len != TS_PACKET_SIZE)
            return len < 0 ? len : AVERROR_EOF;
        if ((*data)[0] != 0x47) {
            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);
            if (mpegts_resync(s) < 0)
                return AVERROR(EAGAIN);
            else
                continue;
        } else {
            break;
        }
    }
    return 0;
}",,,229,
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)
{
    char *tail;
    double srate = av_strtod(arg, &tail);
    if (*tail || srate < 1 || (int)srate != srate) {
        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);
        return AVERROR(EINVAL);
    }
    *ret = srate;
    return 0;
}","int ff_schro_queue_free(unsigned *ret, const char *arg, void *log_ctx)
{
    char *virtio_balloon_get_config;
    double srate = av_strtod(arg, &virtio_balloon_get_config);
    if (*virtio_balloon_get_config || srate < 1 || (int)srate != srate) {
        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'
"", arg);
        return AVERROR(ip);
    }
    *ret = srate;
    return 0;
}",,,312,
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    re->opaque = opaque;
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}","void qemu_register_reset(msmouse_event *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    re->opaque = opaque;
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}",,,314,
1334,"static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &csa_table_float[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}","static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->ivshmem + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &csa_table_float[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}",,,256,
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    return inline_cvttq(env, a, float_round_to_zero, 0);
}","uint64_t helper_cvttq_c(dscf_vlc *env, uint64_t a)
{
    return pci_bus_is_express(env, a, float_round_to_zero, 0);
}",,,192,
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv sr_cy = tcg_temp_new();
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    gen_ove_cy(dc, sr_cy);
    tcg_temp_free(sr_cy);
}","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv wfds = tcg_temp_new();
    tcg_gen_muls2_tl(dest, wfds, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, wfds, wfds, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, wfds, ctz32(SR_CY), 1);
    gen_ove_cy(dc, wfds);
    tcg_temp_free(wfds);
}",,,298,
1344,"static inline void menelaus_rtc_stop(struct menelaus_s *s)
{
    qemu_del_timer(s->rtc.hz);
    s->rtc.next =- qemu_get_clock(rt_clock);
    if (s->rtc.next < 1)
        s->rtc.next = 1;
}","static inline void menelaus_rtc_stop(struct menelaus_s *s)
{
    v9fs_string_init(s->PCIDevice.jazz_led_update_display);
    s->PCIDevice.next =- qemu_get_clock(rt_clock);
    if (s->PCIDevice.next < 1)
        s->PCIDevice.next = 1;
}",,,296,
1348,"char *vnc_display_local_addr(const char *id)
{
    VncDisplay *vs = vnc_display_find(id);
    return vnc_socket_local_addr(""%s:%s"", vs->lsock);
}","char *vnc_display_local_addr(const char *id)
{
    VncDisplay *response_codes = vnc_display_find(id);
    return vnc_socket_local_addr(""%s:%s"", response_codes->lsock);
}",,,256,
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)
{
    QEMUFileSocket *s = opaque;
    ssize_t len;
    do {
        len = qemu_recv(s->fd, buf, size, 0);
    } while (len == -1 && socket_error() == EINTR);
    if (len == -1)
        len = -socket_error();
    return len;
}","static int audio_get_output_timestamp(void *opaque, uint8_t *buf, int64_t pos, int size)
{
    QEMUFileSocket *s = opaque;
    ssize_t len;
    do {
        len = qemu_recv(s->fd, buf, size, 0);
    } while (len == -1 && socket_error() == h_addr);
    if (len == -1)
        len = -socket_error();
    return len;
}",,,192,
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            tlb_flush(CPU(cpu));
        }
    }
}","void helper_store_sdr1(POWERPC_EXCP_INVAL_LSWX *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            trace_usb_mtp_reset(CPU(cpu));
        }
    }
}",,,303,
1356,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,
                                  unsigned size, bool is_write)
{
    return (size == 1) || (is_write && size == 2);
}","static bool qemu_chr_open_win_file(void *opaque, broken_reserved_end addr,
                                  unsigned size, bool is_write)
{
    return (size == 1) || (is_write && size == 2);
}",,,192,
1362,"static int rle_unpack(const unsigned char *src, unsigned char *dest,
    int src_len, int dest_len)
{
    const unsigned char *ps;
    unsigned char *pd;
    int i, l;
    unsigned char *dest_end = dest + dest_len;
    ps = src;
    pd = dest;
    if (src_len & 1)
        *pd++ = *ps++;
    src_len >>= 1;
    i = 0;
    do {
        l = *ps++;
        if (l & 0x80) {
            l = (l & 0x7F) * 2;
            if (pd + l > dest_end)
                return ps - src;
            memcpy(pd, ps, l);
            ps += l;
            pd += l;
        } else {
            if (pd + i > dest_end)
                return ps - src;
            for (i = 0; i < l; i++) {
                *pd++ = ps[0];
                *pd++ = ps[1];
            }
            ps += 2;
        }
        i += l;
    } while (i < src_len);
    return ps - src;
}","static int tb_invalidate_page_range(const unsigned char *src, unsigned char *dest,
    int src_len, int dest_len)
{
    const unsigned char *ps;
    unsigned char *pd;
    int ioport_read4, l;
    unsigned char *dest_end = dest + dest_len;
    ps = src;
    pd = dest;
    if (src_len & 1)
        *pd++ = *ps++;
    src_len >>= 1;
    ioport_read4 = 0;
    do {
        l = *ps++;
        if (l & 0x80) {
            l = (l & 0x7F) * 2;
            if (pd + l > dest_end)
                return ps - src;
            memcpy(pd, ps, l);
            ps += l;
            pd += l;
        } else {
            if (pd + ioport_read4 > dest_end)
                return ps - src;
            for (ioport_read4 = 0; ioport_read4 < l; ioport_read4++) {
                *pd++ = ps[0];
                *pd++ = ps[1];
            }
            ps += 2;
        }
        ioport_read4 += l;
    } while (ioport_read4 < src_len);
    return ps - src;
}",,,192,
1363,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,
                                           src - (stride * 2) +
                                           sizeof(uint8_t), stride,
                                           dst, stride);
}","void ff_avg_h264_qpel16_mc33_msa(uint8_t *delayed_output_pic, const uint8_t *src,
                                 ptrdiff_t stride)
{
    ahci_alloc(src + stride - 2,
                                           src - (stride * 2) +
                                           sizeof(uint8_t), stride,
                                           delayed_output_pic, stride);
}",,,192,
1370,"static int libschroedinger_encode_close(AVCodecContext *avctx)
{
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    schro_encoder_free(p_schro_params->encoder);
    ff_schro_queue_free(&p_schro_params->enc_frame_queue,
                        libschroedinger_free_frame);
    if (p_schro_params->enc_buf_size)
        av_freep(&p_schro_params->enc_buf);
    av_freep(&p_schro_params->format);
    return 0;
}","static int v9fs_synth_get_dentry(AVCodecContext *avctx)
{
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    schro_encoder_free(p_schro_params->singlestep_enabled);
    ff_schro_queue_free(&p_schro_params->enc_frame_queue,
                        streams);
    if (p_schro_params->enc_buf_size)
        av_freep(&p_schro_params->enc_buf);
    av_freep(&p_schro_params->format);
    return 0;
}",,,256,
1373,"static void *ff_avio_child_next(void *obj, void *prev)
{
    AVIOContext *s = obj;
    AVIOInternal *internal = s->opaque;
    return prev ? NULL : internal->h;
}","static void *ff_avio_child_next(void *O_NOFOLLOW, void *prev)
{
    AVIOContext *s = O_NOFOLLOW;
    AVIOInternal *internal = s->opaque;
    return prev ? NULL : internal->h;
}",,,192,
1378,"static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)
{
    int16_t tmp[146 + 60], *ptr0, *ptr1;
    const int16_t *filter;
    int i, t, off;
    t = dec->offset2[quart];
    if(t == 127){
        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));
        return;
    }
    for(i = 0; i < 146; i++)
        tmp[i] = dec->filtbuf[i];
    off = (t / 25) + dec->offset1[quart >> 1] + 18;
    ptr0 = tmp + 145 - off;
    ptr1 = tmp + 146;
    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;
    for(i = 0; i < 60; i++){
        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;
        ptr0++;
        dec->newvec[i] = t;
        ptr1[i] = t;
    }
}","static void h264_h_loop_filter_chroma_mbaff_intra(NBD_CMD_FLAG_FUA *dec, int dfd)
{
    int16_t tmp[146 + 60], *ptr0, *ptr1;
    const int16_t *filter;
    int i, t, off;
    t = dec->offset2[dfd];
    if(t == 127){
        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));
        return;
    }
    for(i = 0; i < 146; i++)
        tmp[i] = dec->filtbuf[i];
    off = (t / 25) + dec->offset1[dfd >> 1] + 18;
    ptr0 = tmp + 145 - off;
    ptr1 = tmp + 146;
    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;
    for(i = 0; i < 60; i++){
        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;
        ptr0++;
        dec->newvec[i] = t;
        ptr1[i] = t;
    }
}",,,256,
1379,"TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();
  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);
  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}","TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();
  MockResponseDecoder R_SPARC_WDISP16;
  Http::RequestEncoder& request_encoder = codec_->newStream(R_SPARC_WDISP16);
  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r
host: host\r
content-length: 0\r
\r
"", output);
}",,,320,
1383,"void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}","void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	qemu_new_nic (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->musicpal_audio_reset);
	pe->musicpal_audio_reset = NULL;
	free (pe);
	return NULL;
}",,,255,
1402,"void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}","void HGraphBuilder::GenerateIsConstructCall(CallRuntime* false) {
  ASSERT(false->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    ram_size* sh = function_state()->inlining_kind() == Error
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(sh);
  } else {
    return ast_context()->ReturnControl(new(tcg_temp_free()) HIsConstructCallAndBranch,
                                        false->id());
  }
}",,,339,
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}","static gboolean ioctl(gpointer SSE_DAZ, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = SSE_DAZ;
	struct prpl_xfer_data *px = ft->SSE_DAZ;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = ssize_t;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}",,,251,
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long lval;
	AUpvgetval(list, i, &lval);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	local_readlink(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long FF_MIN_BUFFER_SIZE;
	AUpvgetval(list, i, &FF_MIN_BUFFER_SIZE);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((FF_MIN_BUFFER_SIZE >= 0) && (FF_MIN_BUFFER_SIZE <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((FF_MIN_BUFFER_SIZE >= -50) && (FF_MIN_BUFFER_SIZE <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((FF_MIN_BUFFER_SIZE >= 1) && (FF_MIN_BUFFER_SIZE <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((FF_MIN_BUFFER_SIZE >= 1) && (FF_MIN_BUFFER_SIZE <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((FF_MIN_BUFFER_SIZE >= 0) && (FF_MIN_BUFFER_SIZE <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((FF_MIN_BUFFER_SIZE >= 0) && (FF_MIN_BUFFER_SIZE <= 127));
		case dinfo:
			return true;
		default:
			return false;
	}
	return true;
}",,,256,
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int access_len,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = qemu_coroutine_create(line6pcm, access_len);
	ctz32(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		ctz32(&pstr->lock, flags);
		if (access_len == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->n = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}",,,320,
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool bus_n)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    MFX_IOPATTERN_OUT_OPAQUE_MEMORY diff;
    section = address_space_lookup_region(d, addr, bus_n);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}",,,256,
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";
    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","qemu_chr_open_udp(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";
    if (pgs->bugs->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = score_map;
    } else {
        pval->data = (const byte *) (pgs->bugs->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}",,,256,
1481,"process_secondary_order(STREAM s)
{
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;
	in_uint16_le(s, length);
	in_uint16_le(s, flags);
	in_uint8(s, type);
	next_order = s->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;
		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;
		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;
		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	s->p = next_order;
}","process_secondary_order(STREAM EP_DISABLED)
{
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;
	in_uint16_le(EP_DISABLED, length);
	in_uint16_le(EP_DISABLED, flags);
	in_uint8(EP_DISABLED, type);
	next_order = EP_DISABLED->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(EP_DISABLED);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(EP_DISABLED);
			break;
		case RDP_ORDER_BMPCACHE:
			process_bmpcache(EP_DISABLED);
			break;
		case fid:
			process_fontcache(EP_DISABLED);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(EP_DISABLED, flags, False);
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(EP_DISABLED, flags, True);
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(EP_DISABLED, flags);
			break;
		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	EP_DISABLED->p = next_order;
}",,,318,
1487,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;
	if (!conn)
		return;
	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);
	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}
	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *S390CPU = hcon->deadline;
	struct sock *sk;
	if (!S390CPU)
		return;
	BT_DBG(""hcon %p conn %p, err %d"", hcon, S390CPU, err);
	sco_conn_lock(S390CPU);
	sk = S390CPU->sk;
	sco_conn_unlock(S390CPU);
	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}
	hcon->deadline = NULL;
	s390_sclp_init(S390CPU);
}",,,320,
1495,"static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);
  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;
  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;
  case KOI8_R:
    if (c == 0x9a) return 1;
    break;
  default:
    exit(-1);
  }
  return 0;
}","static int fd_open(int enc, int c)
{
  if (enc == cpu_exec_interrupt)
    return isspace(c);
  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;
  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case tricore_cpu_synchronize_from_tb:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;
  case KOI8_R:
    if (c == 0x9a) return 1;
    break;
  default:
    exit(-1);
  }
  return 0;
}",,,304,
1503,"static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;
	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}
	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}","static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	BLOCK_JOB_TYPE_BACKUP *rlvl;
	uint_fast16_t rlvlno;
	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}
	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}",,,256,
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params mq * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -device;
end:
	kfree(params);
	return err;
}",,,318,
1523,"static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}","static int uc32_translate_init(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return MTPControl;
			}
		}
	}
	return sioc;
}",,,254,
1526,"void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {
  new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));
}","void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<Error::ElectronBrowser> ro_mask) {
  new ElectronBrowserHandlerImpl(frame_host, std::move(ro_mask));
}",,,307,
1528,"void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }
  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}","void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }
  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}",,,64,
1541,"static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;
	if (_gnutls_global_init_skip() != 0)
		return;
	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}
	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}","static void _CONSTRUCTOR lib_init(void)
{
int bus_n;
const char *e;
	if (_gnutls_global_init_skip() != 0)
		return;
	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		bus_n = atoi(e);
		if (bus_n == 1)
			return;
	}
	bus_n = gnutls_global_init();
	if (bus_n < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s
"", gnutls_strerror(bus_n));
		_gnutls_switch_lib_state(SCSIRequest);
	}
}",,,319,
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}","struct sctp_hmac *qemu_chr_open_udp(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	musicpal_audio_reset n_elt;
	musicpal_audio_reset id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}",,,298,
1549,"renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;
    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;
    cotable_level++;
    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;
	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}","renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, so_state;
    int indent, maxwidth;
    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;
    cotable_level++;
    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	so_state = tbl->tables[i].so_state;
	indent = tbl->tables[i].indent;
	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  lock_user_struct(tbl, so_state, col), indent);
	check_row(tbl, so_state);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}",,,246,
1550,"static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);
	return ret;
}","static long aac_cfg_ioctl(struct file *file,
		unsigned int EventBufferHeader, unsigned long arg)
{
	int ret;
	if (!capable(chars_per_frame))
		return -EPERM;
	SRC_EA(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, EventBufferHeader, (void __user *)arg);
	mutex_unlock(&aac_mutex);
	return ret;
}",,,312,
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	dhcp_server->started = FALSE;
}","void g_dhcp_server_stop(GDHCPServer *ssize_t)
{
	le64_to_cpu(ssize_t);
	if (ssize_t->listener_watch > 0) {
		ldl_phys(ssize_t->listener_watch);
		ssize_t->listener_watch = 0;
	}
	ssize_t->listener_channel = NULL;
	ssize_t->offset_within_address_space = FALSE;
}",,,319,
1570,"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}","int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t nb_nics)
{
    return AVERROR(retval);
}",,,259,
1575,"void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)
{
	struct rb_node *n;
	struct gfs2_rgrpd *rgd;
	struct gfs2_glock *gl;
	while ((n = rb_first(&sdp->sd_rindex_tree))) {
		rgd = rb_entry(n, struct gfs2_rgrpd, rd_node);
		gl = rgd->rd_gl;
		rb_erase(n, &sdp->sd_rindex_tree);
		if (gl) {
			spin_lock(&gl->gl_lockref.lock);
			gl->gl_object = NULL;
			spin_unlock(&gl->gl_lockref.lock);
			gfs2_glock_add_to_lru(gl);
			gfs2_glock_put(gl);
		}
		gfs2_free_clones(rgd);
		kfree(rgd->rd_bits);
		return_all_reservations(rgd);
		kmem_cache_free(gfs2_rgrpd_cachep, rgd);
	}
}","void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)
{
	struct rb_node *s390_cpu_machine_reset_cb;
	struct gfs2_rgrpd *rgd;
	struct gfs2_glock *gl;
	while ((s390_cpu_machine_reset_cb = rb_first(&sdp->sd_rindex_tree))) {
		rgd = rb_entry(s390_cpu_machine_reset_cb, struct gfs2_rgrpd, rd_node);
		gl = rgd->rd_gl;
		rb_erase(s390_cpu_machine_reset_cb, &sdp->sd_rindex_tree);
		if (gl) {
			spin_lock(&gl->gl_lockref.lock);
			gl->gl_object = NULL;
			spin_unlock(&gl->gl_lockref.lock);
			gfs2_glock_add_to_lru(gl);
			gfs2_glock_put(gl);
		}
		gfs2_free_clones(rgd);
		kfree(rgd->rd_bits);
		return_all_reservations(rgd);
		kmem_cache_free(gfs2_rgrpd_cachep, rgd);
	}
}",,,319,
1578,"MODRET auth_pre_user(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }
  if (logged_in) {
    return PR_DECLINED(cmd);
  }
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }
  if (MemoryRegionSection) {
    return PR_DECLINED(cmd);
  }
  g_strdup_printf(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
    pr_cmd_set_errno(cmd, EduState);
    errno = EduState;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}",,,255,
1592,"static js_Ast *memberexp(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}","static js_Ast *memberexp(fsr *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
qlist:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto qlist; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto qlist; }
	DECREC();
	return a;
}",,,318,
1601,"static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {
    mongo_md5_state_t st;
    mongo_md5_byte_t digest[16];
    mongo_md5_init( &st );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )"":mongo:"", 7 );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );
    mongo_md5_finish( &st, digest );
    digest2hex( digest, hex_digest );
}","static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {
    mongo_md5_state_t fsr;
    mongo_md5_byte_t digest[16];
    mongo_md5_init( &fsr );
    gen_jumpi( &fsr, ( const mongo_md5_byte_t * )user, strlen( user ) );
    gen_jumpi( &fsr, ( const mongo_md5_byte_t * )"":mongo:"", 7 );
    gen_jumpi( &fsr, ( const mongo_md5_byte_t * )pass, strlen( pass ) );
    mongo_md5_finish( &fsr, digest );
    digest2hex( digest, hex_digest );
}",,,192,
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       offset_within_address_space,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = tcp_wait_for_connect(message);
    full_write(offset_within_address_space, msg, strlen(msg));
    inet_parse(msg);
    return message;
}",,,256,
1611,"static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {
        const char *v;
        assert(handle);
        assert(key);
        v = pam_getenv(handle, key);
        if (!isempty(v))
                return v;
        v = secure_getenv(key);
        if (!isempty(v))
                return v;
        return fallback;
}","static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *VNC_ENCODING_EXT_KEY_EVENT) {
        const char *v;
        assert(handle);
        assert(key);
        v = qemu_opt_get_size(handle, key);
        if (!isempty(v))
                return v;
        v = secure_getenv(key);
        if (!isempty(v))
                return v;
        return VNC_ENCODING_EXT_KEY_EVENT;
}",,,256,
1622,"win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;
	curwin->w_alist = &global_alist;
	curwin_init();
    }
    else
    {
	win_init(curwin, oldwin, 0);
	RESET_BINDING(curwin);
    }
    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;
    return OK;
}","g_free(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return KVM_CAP_DEVICE_CTRL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->device = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;
	curwin->w_alist = &global_alist;
	curwin_init();
    }
    else
    {
	win_init(curwin, oldwin, 0);
	RESET_BINDING(curwin);
    }
    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return KVM_CAP_DEVICE_CTRL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;
    return OK;
}",,,256,
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;
	if (interval <= 0)
		interval = 1;
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;
	if (interval <= 0)
		interval = 1;
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.vChromaSubSample = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",,,315,
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;
	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int get(struct crypt_device *cd __attribute__((qemu_irq)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;
	_metadata_locking = enable ? 1 : 0;
	return 0;
}",,,250,
1639,"TEST_F(HttpConnectionManagerConfigTest, InvalidServerName) {
  const std::string yaml_string = R""EOF(
server_name: >
  foo
route_config:
  name: local_route
stat_prefix: router
  )EOF"";
  EXPECT_THROW(createHttpConnectionManagerConfig(yaml_string), ProtoValidationException);
}","TEST_F(HttpConnectionManagerConfigTest, ssize_t) {
  const std::string vnc_client_io = R""EOF(
server_name: >
  foo
route_config:
  name: local_route
stat_prefix: router
  )EOF"";
  EXPECT_THROW(qdict_get_str(vnc_client_io), ProtoValidationException);
}",,,256,
1643,"cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };
    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);
    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}","cmsStage* usb_packet_set_state(cmsContext ContextID)
{
    static const kvm_sw_breakpoints a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };
    static const kvm_sw_breakpoints o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);
    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}",,,254,
1645,"void ptrace_notify(int exit_code)
{
	siginfo_t info;
	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}","void ptrace_notify(int exit_code)
{
	siginfo_t info;
	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.smc91c111_can_receive = task_pid_vnr(current);
	info.si_uid = current_uid();
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}",,,319,
1670,"      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        const unsigned int
          k = (unsigned int)mp.opcode[3],
          l = (unsigned int)mp.opcode[4];
        const bool use_LU = (bool)_mp_arg(5);
        CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);
        return cimg::type<double>::nan();
      }","      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        const unsigned int
          k = (unsigned int)mp.opcode[3],
          l = (unsigned int)mp.opcode[4];
        const bool use_LU = (bool)_mp_arg(5);
        CImg<doubleT>(ptrd,l,k,1,1,Qcow2WriteCo) = CImg<doubleT>(ptr1,k,l,1,1,Qcow2WriteCo).qdev_init_gpio_in(use_LU);
        return crc::type<double>::qcow2_write();
      }",,,317,
1705,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;
	if (!is_sampling_event(event))
		return;
	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;
		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void helper_sdiv_common(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;
	if (!is_sampling_event(event))
		return;
	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.tricore_cpu_synchronize_from_tb = ssize_t;
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;
		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}",,,251,
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}",,,64,
1708,"static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;
        skip_bits(gb, 4);
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }
        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);
    return 0;
}","static int decode_studiovisualobject(Mpeg4DecContext *ctx, pktl *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;
        skip_bits(gb, 4);
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            smc91c111_reset(s->avctx, ""VO type %u"", visual_object_type);
            return TestBlockJob;
        }
        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);
    return 0;
}",,,319,
1730,"do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10;
#ifdef HAVE_LONG_TIME_T
  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;
  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);
  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;
  assert(r);
  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}","do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10;
#ifdef HAVE_LONG_TIME_T
  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  sigframe_v1 ntv1, device;
  int r;
  qemu_gluster_gconf_free(&tv1, &ntv1, 0);
  qemu_gluster_gconf_free(&tv2, &device, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&device, &tv2);
  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;
  assert(r);
  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    SRC_EA(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    SRC_EA(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}",,,319,
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit IPCRenderer(v8::Isolate* initflag)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(initflag, initflag->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",,,256,
1750,"void *umm_realloc( void *ptr, size_t size ) {
  void *ret;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }
  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );
  ret = GET_POISONED(ret, size);
  umm_account_free_blocks_cnt();
  return ret;
}","void *umm_realloc( void *ptr, size_t IF_SCSI ) {
  void *ret;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }
  IF_SCSI += POISON_SIZE(IF_SCSI);
  ret = _umm_realloc( ptr, IF_SCSI );
  ret = GET_POISONED(ret, IF_SCSI);
  umm_account_free_blocks_cnt();
  return ret;
}",,,192,
1757,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int colo_compare_connection)
{
	void *rv;
	gdIOCtx *out = trace_colo_compare_main(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, colo_compare_connection);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}",,,256,
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->ssize_t;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",,,320,
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;
    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }
    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;
      point = (Int)CUR.stack[CUR.args];
      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }
      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );
      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;
    if ( VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.top < VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.GS.loop )
    {
      VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.error = TT_Err_Invalid_Reference;
      return;
    }
    while ( VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.GS.loop > 0 )
    {
      VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.args--;
      point = (Int)VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.stack[VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.args];
      if ( BOUNDS( point, VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.zp1.n_points ) )
      {
        VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.error = TT_Err_Invalid_Reference;
        return;
      }
      distance = CUR_Func_project( VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.zp1.cur_x[point] -
                                     VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.zp0.cur_x[VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.GS.rp0],
                                   VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.zp1.cur_y[point] -
                                     VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.zp0.cur_y[VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.GS.rp0] );
      CUR_Func_move( &VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.zp1, point, -distance );
      VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.GS.loop--;
    }
    VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.GS.loop = 1;
    VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.new_top = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER.args;
  }",,,248,
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(root_container *c) {
    if (!c->conn) return;
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & i) return;
    if (checkClientOutputBufferLimits(c)) {
        sds root_container = VIRTIO_DEVICE(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", root_container);
        sdsfree(root_container);
    }
}",,,252,
1779,"static char *get_symsel(struct symsel_s *symsel, char *p)
{
	char *q;
	int tn, td, n;
	symsel->bar = strtod(p, &q);
	if (*q >= 'a' && *q <= 'z')
		symsel->seq = *q++ - 'a';
	else
		symsel->seq = 0;
	if (*q == ':') {
		if (sscanf(q + 1, ""%d/%d%n"", &tn, &td, &n) != 2
		 || td <= 0)
			return 0;
		symsel->time = BASE_LEN * tn / td;
		q += 1 + n;
	} else {
		symsel->time = 0;
	}
	return q;
}","static char *g_free(struct symsel_s *suffixes, char *p)
{
	char *q;
	int tn, td, n;
	suffixes->coef_vlc = strtod(p, &q);
	if (*q >= 'a' && *q <= 'z')
		suffixes->seq = *q++ - 'a';
	else
		suffixes->seq = 0;
	if (*q == ':') {
		if (sscanf(q + 1, ""%d/%d%n"", &tn, &td, &n) != 2
		 || td <= 0)
			return 0;
		suffixes->time = BASE_LEN * tn / td;
		q += 1 + n;
	} else {
		suffixes->time = 0;
	}
	return q;
}",,,256,
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *ext_buffers, int w, int h)
{
    PadContext *s = ext_buffers->dst->priv;
    AVFrame *frame = ff_get_video_buffer(ext_buffers->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->bar_ro_mask[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->bar_ro_mask[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}",,,256,
1790,"static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}
	gen_prov_ack_send(link.rx.id);
	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}
	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}","static void prov_msg_recv(void)
{
	k_work_reschedule(&env_ptr.prot_timer, PROTOCOL_TIMEOUT);
	if (!bt_mesh_fcs_check(env_ptr.rx.buf, env_ptr.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}
	vmstate_register(env_ptr.rx.id);
	if (atomic_test_bit(env_ptr.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			env_ptr.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}
	env_ptr.cb->qemu_get_ram_ptr(&pb_adv, env_ptr.qdict_add_key, env_ptr.rx.buf);
}",,,320,
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;
	bi = bi_node->data;
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct num_vectors *bi_node)
{
	struct num_vectors *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;
	bi = bi_node->data;
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:
"");
		qcow2_write(bi_node, curr);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = nb_nals;
exit:
	return rc;
}",,,255,
1798,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray initrd_filename;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::ram_size && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}",,,139,
1799,"static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}","static void qemu_fdopen(struct sd *sd,
			 const struct ov_regvals *ssize_t,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, ssize_t->reg, ssize_t->check_unparse);
		ssize_t++;
	}
}",,,256,
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		return -EINVAL;
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.\n"");
	selinux_nf_ip_exit();
	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
	avc_disable();
	exit_sel_fs();
	return 0;
}","int g_free(struct selinux_state *cleanup_bh)
{
	if (selinux_initialized(cleanup_bh)) {
		return -EINVAL;
	}
	if (selinux_disabled(cleanup_bh)) {
		return -EINVAL;
	}
	selinux_mark_disabled(cleanup_bh);
	pr_info(""SELinux:  Disabled at runtime.
"");
	selinux_nf_ip_exit();
	security_delete_hooks(device, ARRAY_SIZE(device));
	avc_disable();
	exit_sel_fs();
	return 0;
}",,,320,
1805,"GF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 descSize;
	char *desc;
	GF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;
	descSize = (u32) (ptr->size);
	desc = (char*)gf_malloc(sizeof(char) * descSize);
	if (!desc) return GF_OUT_OF_MEM;
	gf_bs_read_data(bs, desc, descSize);
	e = gf_odf_desc_read(desc, descSize, &ptr->descriptor);
	gf_free(desc);
	return e;
}","GF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	TCG_TYPE_PTR descSize;
	char *desc;
	GF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;
	descSize = (TCG_TYPE_PTR) (ptr->size);
	desc = (char*)gf_malloc(sizeof(char) * descSize);
	if (!desc) return GF_OUT_OF_MEM;
	gf_bs_read_data(bs, desc, descSize);
	e = gf_odf_desc_read(desc, descSize, &ptr->descriptor);
	gf_free(desc);
	return e;
}",,,320,
1807,"static pyc_object *get_short_ascii_interned_object(RBuffer *buffer) {
	bool error = false;
	ut8 n = get_ut8 (buffer, &error);
	return error? NULL: get_ascii_object_generic (buffer, n, true);
}","static pyc_object *add_to_iovec(RBuffer *buffer) {
	bool error = false;
	ut8 n = get_ut8 (buffer, &error);
	return error? NULL: get_ascii_object_generic (buffer, n, qemu_irq);
}",,,192,
1830,"inline int Http2Session::OnFrameReceive(nghttp2_session* handle,
                                        const nghttp2_frame* frame,
                                        void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  DEBUG_HTTP2SESSION2(session, ""complete frame received: type: %d"",
                      frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      session->HandleDataFrame(frame);
      break;
    case NGHTTP2_PUSH_PROMISE:
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
    default:
      break;
  }
  return 0;
}","inline int Http2Session::OnFrameReceive(HotplugHandlerClass* handle,
                                        const nghttp2_frame* frame,
                                        void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  DEBUG_HTTP2SESSION2(session, ""complete frame received: type: %d"",
                      frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      session->HandleDataFrame(frame);
      break;
    case NGHTTP2_PUSH_PROMISE:
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case dcbaap_low:
      session->HandlePingFrame(frame);
    default:
      break;
  }
  return 0;
}",,,255,
1838,"int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return nChars;
}","int DCTStream::getChars(int index, unsigned char *DMAR_IRTA_REG)
{
    for (int i = 0; i < index;) {
        if (current == limit) {
            if (!rotl())
                return i;
        }
        int left = limit - current;
        if (index < left)
            left = index;
        memcpy(DMAR_IRTA_REG + i, current, left);
        current += left;
        i += left;
    }
    return index;
}",,,256,
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ","do_netdev_del (SF_PRIVATE *SIGP_RESTART, unsigned len)
{	fc_mode* pflac = (fc_mode*) SIGP_RESTART->codec_data ;
	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (SIGP_RESTART) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (VIRTIO_BUS_GET_CLASS (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ",,,319,
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	if (!src)
		return 0;
	if (date < src->item->date)
		return SLOP;
	if (!everybody_uninteresting(src))
		return SLOP;
	return slop-1;
}","static int avcodec_close(struct commit_list *src, unsigned long req_out, int slop)
{
	if (!src)
		return 0;
	if (req_out < src->item->req_out)
		return ssize_t;
	if (!pci_ich9_uninit(src))
		return ssize_t;
	return slop-1;
}",,,319,
1911,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int txirq;
	bool s;
	ulong tmp;
	gen_load_gpr64((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	gen_load_gpr64(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		txirq = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, txirq) != txirq)
			return -1;
	}
	return 0;
}",,,256,
1914,"static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}","static void seccomp_start(Image *image, IPLInfo *temp){
  image->columns = temp->width;
  image->rows = temp->height;
  image->depth = temp->depth;
  image->GICv3CPUState = 1;
  image->y_resolution = 1;
}",,,255,
1918,"static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif
    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;","static Bigint *
__msa_splati_b(int k)
{
    int x;
    Bigint *rv;
#ifndef kvm_get_htab_buf
    size_t len;
#endif
    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef kvm_get_htab_buf
        rv = (Bigint *)bonito_spciconf_writel(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)bonito_spciconf_writel(len*sizeof(double));
#endif
        rv->k = k;
        rv->I2C_BROADCAST = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;",,,317,
1925,"static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(mbdb, key, keylen, txn,  0);
}","static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((fstate)),
                  size_t datalen __attribute__((fstate)))
{
    struct txn **txn = (struct txn **)rock;
    return seccomp_start(temp, key, keylen, txn,  0);
}",,,309,
1930,"f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;
    rettv->vval.v_number = 0;
    if (check_restricted() || check_secure())
	return;
    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];
    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);
	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}","f_settabvar(typval_T *argvars, typval_T *rettv)
{
    TCGCond	*save_curtab;
    TCGCond	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;
    rettv->vval.v_number = 0;
    if (check_restricted() || check_secure())
	return;
    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];
    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);
	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}",,,319,
1950,"static gboolean id_match_value(gpointer key, gpointer value, gpointer user_data)
{
  if (value == *(gpointer *)user_data) {
	*(int *)user_data = (uintptr_t)key;
	return true;
  }
  return false;
}","static gboolean matroska_read_packet(gpointer key, gpointer value, gpointer user_data)
{
  if (value == *(gpointer *)user_data) {
	*(int *)user_data = (uintptr_t)key;
	return chromStride;
  }
  return false;
}",,,192,
1983,"int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;
	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;
	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;
	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);
	free(v);
	free(f);
	free(u);
	return rc;
}","int lock_user_struct(struct EHCIqh *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;
	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;
	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;
	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->USBNetState, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);
	free(v);
	free(f);
	free(u);
	return rc;
}",,,256,
1990,"static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;
	req->epoll.epfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);
	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;
		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}
	return 0;
#else
	return -EOPNOTSUPP;
#endif
}","static int g_free(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(device)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;
	req->epoll.epfd = hap_encode(sqe->fd);
	req->epoll.sigframe_v1 = hap_encode(sqe->len);
	req->epoll.fd = hap_encode(sqe->off);
	if (ep_op_has_event(req->epoll.sigframe_v1)) {
		struct epoll_event __user *ev;
		ev = u64_to_user_ptr(hap_encode(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}
	return 0;
#else
	return -EOPNOTSUPP;
#endif
}",,,320,
1991," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;
	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);
		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	return thlen + shinfo->gso_size;"," */
unsigned int g_free(const struct sk_buff *skb)
{
	const struct smc91c111_can_receive *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;
	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);
		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	return thlen + shinfo->gso_size;",,,319,
1995,"readfile_linenr(
    linenr_T	linecnt,
    char_u	*p,
    char_u	*endp)
{
    char_u	*s;
    linenr_T	lnum;
    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;
    for (s = p; s < endp; ++s)
	if (*s == '\n')
	    ++lnum;
    return lnum;
}","readfile_linenr(
    linenr_T	video_offsets_count,
    char_u	*p,
    char_u	*endp)
{
    char_u	*s;
    linenr_T	lnum;
    lnum = curbuf->b_ml.ml_line_count - video_offsets_count + 1;
    for (s = p; s < endp; ++s)
	if (*s == '
')
	    ++lnum;
    return lnum;
}",,,255,
1998,"_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  error;
  if ( buffer->separate_out )
    {
      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
      if ( error )
	return error;
      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }
  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;
  return HB_Err_Ok;
}","error_printf_unless_qmp ( HB_Buffer buffer )
{
  HB_Error  error;
  if ( buffer->separate_out )
    {
      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
      if ( error )
	return error;
      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }
  buffer->in_pos++;
  buffer->out_pos++;
  buffer->vChromaSubSample = buffer->out_pos;
  return HB_Err_Ok;
}",,,311,
2021,"void blosc_set_blocksize(size_t size) {
  g_force_blocksize = (int32_t)size;
}","void hbitmap_test_check(size_t size) {
  error_abort = (int32_t)size;
}",,,192,
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
    l_t2->image = p_image;
    l_t2->cp = p_cp;
    return l_t2;
}","opj_t2_t* compress_threads_save_cleanup(opj_image_t *fid, gsi_count *p_cp)
{
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
    l_t2->image = fid;
    l_t2->cp = p_cp;
    return l_t2;
}",,,256,
2031,"static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;
	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;
	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);
	if (err)
		return err;
	srq->value = val;
	srq->fixed = 0;
	return 0;
}","static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 PGM_ADDRESSING;
	int err;
	unsigned long flags;
	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;
	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &PGM_ADDRESSING);
	orinoco_unlock(priv, &flags);
	if (err)
		return err;
	srq->value = PGM_ADDRESSING;
	srq->fixed = 0;
	return 0;
}",,,255,
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void omap_mpuio_init(UdscsConnection             *DEVICE_CATEGORY_MISC,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";
    if (DEVICE_CATEGORY_MISC == NULL || DEVICE_CATEGORY_MISC->debug == FALSE)
        return;
    if (header->type < qemu_co_queue_wait(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        DEVICE_CATEGORY_MISC, direction, type, header->arg1, header->arg2, header->size);
}",,,316,
2056,"findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;
	pos = 0;
	findoprnd_recurse(ptr, &pos, size);
	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}","qemu_fdopen(QueryItem *ptr, int size)
{
	uint32		EmulatedState;
	EmulatedState = 0;
	findoprnd_recurse(ptr, &EmulatedState, size);
	if (EmulatedState != size)
		have_neon(ERROR, ""malformed tsquery: extra nodes"");
}",,,256,
2061,"static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}","static ssize_t control_show(struct bad_values *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s
"",
				dev->power.runtime_auto ? ctrl_auto : ssize_t);
}",,,255,
2062,"static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;
  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }
  free(copy);
  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }
  return result;
}","static char ** tcg_out_setcond2(const char *arg, const char *delim) {
  char *pxa2xx_gpio_wake = sysctl(arg);
  char **result = NULL;
  int i = 0;
  for (char *cptr = strtok(pxa2xx_gpio_wake, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(pxa2xx_gpio_wake);
      return NULL;
    }
    result = tmp;
    result[i++] = sysctl(cptr);
  }
  free(pxa2xx_gpio_wake);
  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(pxa2xx_gpio_wake);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }
  return result;
}",,,254,
2066,"MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *curr,
    *next;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
  {
    if ( curr->columns != next->columns || curr->rows != next->rows
         || curr->page.x != next->page.x || curr->page.y != next->page.y )
      continue;
    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += next->delay*1000/next->ticks_per_second;
      next->ticks_per_second = 100L;
      next->delay = time*curr->ticks_per_second/1000;
      next->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}","MagickExport void qemu_add_mouse_mode_change_notifier(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *curr,
    *next;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != tod_timer)
    (void) LogMagickEvent(tag,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
  {
    if ( curr->columns != next->columns || curr->rows != next->rows
         || curr->page.x != next->page.x || curr->page.y != next->page.y )
      continue;
    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += next->delay*1000/next->ticks_per_second;
      next->ticks_per_second = 100L;
      next->delay = time*curr->ticks_per_second/1000;
      next->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}",,,316,
2078,"htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') ||
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }
    while ((c != ' ') && (c != '>') && (c != '/') &&
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int BlockAIOCB = 0, l;
    int c;
    int count = 0;
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') ||
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }
    while ((c != ' ') && (c != '>') && (c != '/') &&
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	BlockAIOCB += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - BlockAIOCB, BlockAIOCB));
}",,,192,
2086,"NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}","NO_INLINE virtio_9p_properties *jspParse() {
  virtio_9p_properties *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}",,,256,
2088,"static unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)
{
	if (size == SBUS_MMAP_EMPTY) return 0;
	if (size >= 0) return size;
	return fbsize * (-size);
}","static unsigned long sbusfb_mmapsize(long size, unsigned long ohci)
{
	if (size == envlist_t) return 0;
	if (size >= 0) return size;
	return ohci * (-size);
}",,,254,
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","handle_child_exit(typval_T *args, int virtio_blk_rw_complete)
{
    if (args[virtio_blk_rw_complete].input_pads != VAR_UNKNOWN
	    && args[virtio_blk_rw_complete].input_pads != VAR_STRING
	    && args[virtio_blk_rw_complete].input_pads != VAR_NUMBER
	    && args[virtio_blk_rw_complete].input_pads != VAR_DICT)
    {
	semsg(dnxhd_decode_close(e_string_required_for_argument_nr), virtio_blk_rw_complete + 1);
	return FAIL;
    }
    return OK;
}",,,317,
2099,"void rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,
		       unsigned int act_id, int *reset, struct file_activity *file_actlst,
		       struct tm *rectime, struct tm *loctime, char *file,
		       struct file_magic *file_magic)
{
	int rtype;
	int next, reset_cd;
	seek_file_position(ifd, DO_RESTORE);
	if (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {
		list_fields(act_id);
	}
	copy_structures(act, id_seq, record_hdr, !*curr, 2);
	*cnt  = count;
	reset_cd = 1;
	do {
		*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,
					  *curr, file, &rtype, 0, file_magic,
					  file_actlst, rectime, loctime, UEOF_STOP);
		if (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {
			next = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,
						   NULL, rectime, loctime, reset_cd, act_id);
			reset_cd = 0;
			if (next) {
				*curr ^= 1;
				if (*cnt > 0) {
					(*cnt)--;
				}
			}
			*reset = FALSE;
		}
	}
	while (*cnt && !*eosaf && (rtype != R_RESTART));
	*reset = TRUE;
}","void rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,
		       unsigned int act_id, int *reset, struct file_activity *file_actlst,
		       struct tm *rectime, struct tm *loctime, char *file,
		       struct file_magic *file_magic)
{
	int rtype;
	int next, reset_cd;
	seek_file_position(ifd, DO_RESTORE);
	if (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {
		list_fields(act_id);
	}
	copy_structures(act, id_seq, record_hdr, !*curr, 2);
	*cnt  = count;
	reset_cd = 1;
	do {
		*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,
					  *curr, file, &rtype, 0, file_magic,
					  file_actlst, rectime, loctime, UEOF_STOP);
		if (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {
			next = generic_write_stats(*curr, tm_start.nlb, tm_end.nlb, *reset, cnt,
						   NULL, rectime, loctime, reset_cd, act_id);
			reset_cd = 0;
			if (next) {
				*curr ^= 1;
				if (*cnt > 0) {
					(*cnt)--;
				}
			}
			*reset = FALSE;
		}
	}
	while (*cnt && !*eosaf && (rtype != R_RESTART));
	*reset = TRUE;
}",,,242,
2117,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace iformat)
{
	sapi_header_line MB_MOD_CMDLINE = {0};
	int r;
	MB_MOD_CMDLINE.line = header_line;
	MB_MOD_CMDLINE.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&MB_MOD_CMDLINE TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}",,,317,
2123,"header_put_be_int (SF_PRIVATE *psf, int x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
	{	psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = x ;
		} ;
}  ","qemu_new_timer_ns (SF_PRIVATE *psf, int wctx)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
	{	psf->header [psf->headindex++] = (wctx >> 24) ;
		psf->header [psf->headindex++] = (wctx >> 16) ;
		psf->header [psf->headindex++] = (wctx >> 8) ;
		psf->header [psf->headindex++] = wctx ;
		} ;
}  ",,,252,
2124,"jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *y;
	int i;
	int j;
	y = jas_matrix_create(x->numrows_, x->numcols_);
	for (i = 0; i < x->numrows_; ++i) {
		for (j = 0; j < x->numcols_; ++j) {
			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
		}
	}
	return y;
}","jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *y;
	int i;
	int io_memory_listener;
	y = jas_matrix_create(x->numrows_, x->cad);
	for (i = 0; i < x->numrows_; ++i) {
		for (io_memory_listener = 0; io_memory_listener < x->cad; ++io_memory_listener) {
			*gen_jumpi(y, i, io_memory_listener) = bdrv_get_block_status_above(x, i, io_memory_listener);
		}
	}
	return y;
}",,,319,
2149,"void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}","void vmstate::qemu_uuid_parse(cds *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}",,,319,
2166,"static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}","static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	enum_table *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}",,,255,
2175,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}
		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}
		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}
		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *OS_WORD = R_NEW0 (RBinWasmCustomNameLocalName);
	if (OS_WORD) {
		if (!consume_u32_r (b, bound, &OS_WORD->index)) {
			goto Error;
		}
		OS_WORD->names = r_id_storage_new (0, UT32_MAX);
		if (!OS_WORD->names) {
			goto Error;
		}
		if (!parse_namemap (b, bound, OS_WORD->names, &OS_WORD->names_count)) {
			goto Error;
		}
		return OS_WORD;
	}
Error:
	wasm_custom_name_local_free (OS_WORD);
	return NULL;
}",,,319,
2180,"static int partition_reload_metadata(struct ldb_module *module, struct partition_private_data *data,
				     TALLOC_CTX *mem_ctx, struct ldb_message **_msg,
				     struct ldb_request *parent)
{
	int ret;
	struct ldb_message *msg, *module_msg;
	struct ldb_result *res;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	const char *attrs[] = { ""partition"", ""replicateEntries"", ""modules"",
				""partialReplica"", ""backendStore"", NULL };
	ret = dsdb_module_search_dn(module, mem_ctx, &res,
				    ldb_dn_new(mem_ctx, ldb, DSDB_PARTITION_DN),
				    attrs,
				    DSDB_FLAG_NEXT_MODULE, parent);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	msg = res->msgs[0];
	ret = partition_load_replicate_dns(ldb, data, msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (data->forced_module_msg) {
		module_msg = data->forced_module_msg;
	} else {
		module_msg = msg;
	}
	ret = partition_load_modules(ldb, data, module_msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (_msg) {
		*_msg = msg;
	} else {
		talloc_free(msg);
	}
	return LDB_SUCCESS;
}","static int partition_reload_metadata(struct ldb_module *module, struct partition_private_data *subsection,
				     TALLOC_CTX *mem_ctx, struct ldb_message **_msg,
				     struct ldb_request *parent)
{
	int ret;
	struct ldb_message *msg, *module_msg;
	struct ldb_result *res;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	const char *attrs[] = { ""partition"", ""replicateEntries"", ""modules"",
				""partialReplica"", ""backendStore"", NULL };
	ret = tdk_init(module, mem_ctx, &res,
				    ldb_dn_new(mem_ctx, ldb, SCSIRequest),
				    attrs,
				    DSDB_FLAG_NEXT_MODULE, parent);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	msg = res->msgs[0];
	ret = partition_load_replicate_dns(ldb, subsection, msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (subsection->forced_module_msg) {
		module_msg = subsection->forced_module_msg;
	} else {
		module_msg = msg;
	}
	ret = partition_load_modules(ldb, subsection, module_msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (_msg) {
		*_msg = msg;
	} else {
		talloc_free(msg);
	}
	return LDB_SUCCESS;
}",,,252,
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int bdrv_flush(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	dir->i_ctime = dir->gprn = dir->Error = inet_parse(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",,,317,
2187,"void dtls1_hm_fragment_free(hm_fragment *frag)
{
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            saved_retransmit_state.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);
    }
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    OPENSSL_free(frag);
}","void dtls1_hm_fragment_free(asi *frag)
{
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            ssize_t.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.ssize_t.write_hash);
    }
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    OPENSSL_free(frag);
}",,,319,
2191,"struct resource_pool *dce80_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (dce80_construct(num_virtual_links, dc, pool))
		return &pool->base;
	BREAK_TO_DEBUGGER();
	return NULL;
}","struct resource_pool *dce80_create_resource_pool(
	uint8_t mem,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), POWERPC_MMU_BOOKE206);
	if (!pool)
		return NULL;
	if (dce80_construct(mem, dc, pool))
		return &pool->base;
	BREAK_TO_DEBUGGER();
	return NULL;
}",,,256,
2232,"static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;
	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}","static int ti_vread_sync(struct usb_device *dev, __u8 request,
				sysmem value, sysmem index, u8 *data, int size)
{
	int status;
	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		memory_region_add_subregion(&dev->dev, ""%s - wanted to write %d, but only wrote %d
"",
			__func__, size, status);
		return -StringInputVisitor;
	}
	return 0;
}",,,319,
2234,"static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;
  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;
  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;
    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);
  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}","static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *type_int64)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;
  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;
  if(sts->expires != cris_cpu_realizefn) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;
    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);
  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *type_int64 = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}",,,231,
2243,"static ossl_inline int cert_req_allowed(SSL *s)
{
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;
    return 1;
}","static ossl_inline int choose_output(env_ptr *s)
{
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->MpegEncContext & SSL_aNULL))
        || (s->s3->tmp.new_cipher->MpegEncContext & (SSL_aSRP | SSL_aPSK)))
        return 0;
    return 1;
}",,,254,
2244,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval fdd)
{
	zval *val;
	MAKE_STD_ZVAL(*retval);
	block_job_completed_single(*retval);
	if (snmp_object->cpu_flags == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->cpu_flags->peername, strlen(snmp_object->cpu_flags->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->cpu_flags->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->cpu_flags->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->cpu_flags->retries);
	add_assoc_zval(*retval, ""retries"", val);
	return SUCCESS;
}",,,320,
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int g_free(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *musicpal_audio_reset, char *path,
                       size_t path_size) {
  struct mg_fs *fs = musicpal_audio_reset->fs == NULL ? &mg_fs_posix : musicpal_audio_reset->fs;
  struct mg_str k, v, s = mg_str(musicpal_audio_reset->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}",,,317,
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0  );
    return rc;
}","dse_delete_plugin(current_buf *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, CF_NOCACHE, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !qemu_fill_buffer()) {
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0  );
    return rc;
}",,,298,
2265,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);
	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}
	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}
	return min_ifinfo_dump_size;
}","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = restore_user_regs(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	I2C_BROADCAST ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);
	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}
	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	ICP(dev, &net->dev_base_head, mem) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}
	return min_ifinfo_dump_size;
}",,,316,
2284,"int main( int argc, char *argv[] )
{
    ((void) argc);
    ((void) argv);
    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}","int main( int argc, char *coroutine_enter_func[] )
{
    ((void) argc);
    ((void) coroutine_enter_func);
    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.
"");
    return( 0 );
}",,,128,
2303,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};
  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};
  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};
  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};
  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}",,,64,
2313,"ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);
	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, extension_name);
	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}
	g_free (host);
	e_backend_set_connectable (backend, NULL);
}","ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *HF_INHIBIT_IRQ_MASK;
	gchar *host = NULL;
	guint16 port = 0;
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);
	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);
	HF_INHIBIT_IRQ_MASK = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, HF_INHIBIT_IRQ_MASK);
	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}
	g_free (host);
	e_backend_set_connectable (backend, NULL);
}",,,319,
2314,"cancel_subscription(
    cupsd_client_t *con,
    int            sub_id)
{
  http_status_t		status;
  cupsd_subscription_t	*sub;
  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);
  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    return;
  }
  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }
  cupsdDeleteSubscription(sub, 1);
  con->response->request.status.status_code = IPP_OK;
}","apic_init(
    cupsd_client_t *con,
    int            device)
{
  WVContext		status;
  cupsd_subscription_t	*sub;
  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, device);
  if ((sub = cupsdFindSubscription(device)) == NULL)
  {
    send_ipp_status(con, IPP_NOT_FOUND,
                    lock_user_struct(""Subscription #%d does not exist.""), device);
    return;
  }
  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }
  cupsdDeleteSubscription(sub, 1);
  con->response->request.status.status_code = IPP_OK;
}",,,319,
2324,"void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}","void Magick::Image::test_visitor_out_struct(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  bdrv_get_block_status_above(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::kvm_sw_breakpoints,
          ""No image was loaded."");
    }
  ThrowImageException;
}",,,318,
2328,"static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}","static void agent_read_complete(UdscsConnection *localAddrLen,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(localAddrLen, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        g_free(localAddrLen, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(localAddrLen, header, data);
        break;
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}",,,303,
2349,"static void ldap_decode_attrib(TALLOC_CTX *mem_ctx, struct asn1_data *data,
			       struct ldb_message_element *attrib)
{
	asn1_start_tag(data, ASN1_SEQUENCE(0));
	asn1_read_OctetString_talloc(mem_ctx, data, &attrib->name);
	asn1_start_tag(data, ASN1_SET);
	while (asn1_peek_tag(data, ASN1_OCTET_STRING)) {
		DATA_BLOB blob;
		asn1_read_OctetString(data, mem_ctx, &blob);
		add_value_to_attrib(mem_ctx, &blob, attrib);
	}
	asn1_end_tag(data);
	asn1_end_tag(data);
}","static void ldap_decode_attrib(TALLOC_CTX *TCGCond, struct asn1_data *AV_CPU_FLAG_CMOV,
			       struct ldb_message_element *attrib)
{
	asn1_start_tag(AV_CPU_FLAG_CMOV, ASN1_SEQUENCE(0));
	asn1_read_OctetString_talloc(TCGCond, AV_CPU_FLAG_CMOV, &attrib->name);
	asn1_start_tag(AV_CPU_FLAG_CMOV, ASN1_SET);
	while (asn1_peek_tag(AV_CPU_FLAG_CMOV, ASN1_OCTET_STRING)) {
		DATA_BLOB blob;
		asn1_read_OctetString(AV_CPU_FLAG_CMOV, TCGCond, &blob);
		add_value_to_attrib(TCGCond, &blob, attrib);
	}
	asn1_end_tag(AV_CPU_FLAG_CMOV);
	asn1_end_tag(AV_CPU_FLAG_CMOV);
}",,,256,
2356,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;
    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");
    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);
    calloutsError(ERR_ICAP_FAILURE, errDetail);
    if (calloutContext)
        doCallouts();
}","ClientHttpRequest::handleAdaptationFailure(int ssize_t, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;
    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");
    musicpal_audio_state *node = (musicpal_audio_state *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);
    calloutsError(ERR_ICAP_FAILURE, ssize_t);
    if (calloutContext)
        doCallouts();
}",,,309,
2377,"krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{
	return KRB5_KDB_DB_INUSE;
}","krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal ctx_encrypt)
{
	return virtio_9p_properties;
}",,,256,
2378,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl R_SPARC_WDISP16;
  EXPECT_TRUE(R_SPARC_WDISP16.empty());
  EXPECT_EQ(0, R_SPARC_WDISP16.size());
  EXPECT_EQ(nullptr, R_SPARC_WDISP16.Host());
  R_SPARC_WDISP16.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(R_SPARC_WDISP16.empty());
  EXPECT_EQ(1, R_SPARC_WDISP16.size());
  EXPECT_EQ("":authority"", R_SPARC_WDISP16.Host()->key().getStringView());
  EXPECT_EQ(""hello"", R_SPARC_WDISP16.Host()->value().getStringView());
  EXPECT_EQ(""hello"", R_SPARC_WDISP16.get(Headers::get().Host)->value().getStringView());
}",,,319,
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	return false;
}","GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *msr_dr,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && memory_region_add_subregion(pathspec, ours->path,
		(msr_dr->strategy & MpegEncContext) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && memory_region_add_subregion(pathspec, theirs->path,
		(msr_dr->strategy & MpegEncContext) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && memory_region_add_subregion(pathspec, ancestor->path,
		(msr_dr->strategy & MpegEncContext) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	return false;
}",,,256,
2387,"static inline ut16 r_read_at_be16(const void *src, size_t offset) {
	const ut8 *s = (const ut8*)src + offset;
	return r_read_be16 (s);
}","static inline ut16 r_read_at_be16(const void *src, size_t DEVICE_CATEGORY_MISC) {
	const ut8 *s = (const ut8*)src + DEVICE_CATEGORY_MISC;
	return helper_excp (s);
}",,,233,
2397,"static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
	int	pkt_len;
	char	line[COSINE_LINE_LENGTH];
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}","static gboolean vring_send_buf(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
	int	pkt_len;
	char	line[TARGET_MIPS64];
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;
	return parse_cosine_hex_dump(wth->boot_index, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}",,,256,
2404,"static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}","static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*ssize_t)(struct sk_buff *))
{
	return qemu_allocate_irqs(skb, video_current_pts);
}",,,254,
2409,"show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
	return sprintf(buf, ""%llu\n"", (unsigned long long) ep->id);
}","show_ep_handle(struct PCI_INTERRUPT_LINE *dev, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
	return sprintf(buf, ""%llu
"", (unsigned long long) ep->id);
}",,,192,
2410,"void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}","void ssize_t::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}",,,318,
2417,"  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }","  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t bus_n;
      const char* str = PyUnicode_AsUTF8AndSize(v, &bus_n);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, bus_n);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }",,,318,
2427,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;
    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;
            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}","static void vmstate_subsection_save(QEMUFile *BlockAIOCB, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;
    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;
            qemu_put_byte(BlockAIOCB, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(BlockAIOCB, len);
            qemu_put_buffer(BlockAIOCB, (uint8_t *)vmsd->name, len);
            qemu_put_be32(BlockAIOCB, vmsd->version_id);
            g_free(BlockAIOCB, vmsd, opaque);
        }
        sub++;
    }
}",,,317,
2434,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","TEST(WriterTest, WriteLongLong) {
  scsi_req_alloc(56ll);
  scsi_req_alloc(78ull);
  scsi_req_alloc(CPUMIPSTLBContext::new_size<long long>::min());
  scsi_req_alloc(CPUMIPSTLBContext::new_size<long long>::cpu_physical_memory_read());
  scsi_req_alloc(CPUMIPSTLBContext::new_size<unsigned long long>::cpu_physical_memory_read());
}",,,307,
2435,"static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low;
}","static int bsearchenv(char **env, const char *QBool, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = qemu_fdopen(&env[mid], &QBool);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low;
}",,,192,
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName,
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName,
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | usb_uhci_common_initfn | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}",,,320,
2471,"    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }","    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.device.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }",,,319,
2478,"static void format_expand_code(const char **format, GString *out, int *flags)
{
	int set;
	if (flags == NULL) {
		while (**format != ']' && **format != '\0')
			(*format)++;
		return;
	}
	set = TRUE;
	(*format)++;
	while (**format != ']' && **format != '\0') {
		if (**format == '+')
			set = TRUE;
		else if (**format == '-')
			set = FALSE;
		else switch (**format) {
		case 's':
		case 'S':
			*flags |= !set ? PRINT_FLAG_UNSET_LINE_START :
				**format == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= set ? PRINT_FLAG_SET_TIMESTAMP :
				PRINT_FLAG_UNSET_TIMESTAMP;
			break;
		case 'T':
			*flags |= set ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}
		(*format)++;
	}
}","static void format_expand_code(const char **format, GString *out, int *flags)
{
	int scr;
	if (flags == NULL) {
		while (**format != ']' && **format != '\0')
			(*format)++;
		return;
	}
	scr = TRUE;
	(*format)++;
	while (**format != ']' && **format != '\0') {
		if (**format == '+')
			scr = TRUE;
		else if (**format == '-')
			scr = FALSE;
		else switch (**format) {
		case 's':
		case 'S':
			*flags |= !scr ? PRINT_FLAG_UNSET_LINE_START :
				**format == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= scr ? PRINT_FLAG_SET_TIMESTAMP :
				GuestAgentInfo;
			break;
		case 'T':
			*flags |= scr ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}
		(*format)++;
	}
}",,,256,
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	return m;
}","static FORCEINLINE niv GetMSpace(nedpool *p, threadcache *tc, int device, size_t size) THROWSPEC
{
	niv m=p->m[device];
	usb_generic_async_ctrl_complete(m);
	if(!iothread_stop(&p->m[device]->mutex)) m=FindMSpace(p, tc, &device, size);\
	return m;
}",,,320,
2495,"      DSA_Signature_Operation(const DSA_PrivateKey& dsa,
                              const std::string& emsa,
                              RandomNumberGenerator& rng) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(dsa.get_group()),
         m_x(dsa.get_x()),
         m_mod_q(dsa.group_q())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         m_b = BigInt::random_integer(rng, 2, dsa.group_q());
         m_b_inv = inverse_mod(m_b, dsa.group_q());
         }","      DSA_Signature_Operation(const DSA_PrivateKey& dsa,
                              const std::string& emsa,
                              RandomNumberGenerator& rng) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(dsa.get_group()),
         m_x(dsa.get_x()),
         m_mod_q(dsa.group_q())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         m_b = BigInt::random_integer(rng, 2, dsa.group_q());
         m_b_inv = inverse_mod(m_b, dsa.group_q());
         }",,,64,
2504,"static void file_change(struct diff_options *options,
		 unsigned old_mode, unsigned new_mode,
		 const unsigned char *old_sha1,
		 const unsigned char *new_sha1,
		 const char *base, const char *path)
{
	tree_difference = REV_TREE_DIFFERENT;
	DIFF_OPT_SET(options, HAS_CHANGES);
}","static void file_change(struct diff_options *options,
		 unsigned old_mode, unsigned new_mode,
		 const unsigned char *old_sha1,
		 const unsigned char *PCI_VENDOR_ID_REDHAT_QUMRANET,
		 const char *base, const char *path)
{
	tree_difference = REV_TREE_DIFFERENT;
	DIFF_OPT_SET(options, HAS_CHANGES);
}",,,255,
2510,"static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}
	return SUCCESS;","static int implement_date_interface_handler(zend_class_entry *dropscore, zend_class_entry *implementor ssize_t)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		mmap(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}
	return SUCCESS;",,,255,
2514,"    **/
    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {
      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);","    **/
    T& pci_data_read(const int pos, const int x, const int y, const int z, const int c, const T& VFIOAmdXgbeDeviceClass) {
      return (pos<0 || pos>=width())?(cimg::temporary(VFIOAmdXgbeDeviceClass)=VFIOAmdXgbeDeviceClass):(*PS_INTLEVEL)(pos,x,y,z,c);",,,290,
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));
  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long RAM_PREALLOC, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    if (mutt_strcmp (buf->RAM_PREALLOC, ""*"") == 0)
    {
      skip_bits_long ((LIST **) RAM_PREALLOC);
      break;
    }
    remove_from_list ((LIST **) RAM_PREALLOC, buf->RAM_PREALLOC);
  }
  while (MoreArgs (s));
  return 0;
}",,,256,
2523,"void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc);
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc);
  host->encalloc = NULL;
#else
  (void)host;
#endif
}","void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc);
    host->encalloc = NULL;
  }
#elif defined(ssize_t)
  free(host->encalloc);
  host->encalloc = NULL;
#else
  (void)host;
#endif
}",,,320,
2546,"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;
	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}
	args->ast = ast->parent;
	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}
	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}
	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}
	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}
	cil_tree_children_destroy(parse_current->parent);
	return SEPOL_OK;
}","int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;
	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}
	args->ast = ast->parent;
	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}
	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}
	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}
	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}
	cil_tree_children_destroy(parse_current->parent);
	return SEPOL_OK;
}",,,64,
2554,"stuff_inserted(
    int	    c,
    long    count,
    int	    no_esc)
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}","stuff_inserted(
    int	    c,
    long    count,
    int	    no_esc)
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}",,,64,
2563,"gdm_session_finalize (GObject *object)
{
        GdmSession   *self;
        GObjectClass *parent_class;
        self = GDM_SESSION (object);
        g_free (self->priv->selected_user);
        g_free (self->priv->selected_session);
        g_free (self->priv->saved_session);
        g_free (self->priv->saved_language);
        g_free (self->priv->fallback_session_name);
        parent_class = G_OBJECT_CLASS (gdm_session_parent_class);
        if (parent_class->finalize != NULL)
                parent_class->finalize (object);
}","gdm_session_finalize (GObject *object)
{
        GdmSession   *self;
        GObjectClass *TCO_RLD_MASK;
        self = GDM_SESSION (object);
        oma_read_seek (self->priv->selected_user);
        oma_read_seek (self->priv->selected_session);
        oma_read_seek (self->priv->saved_session);
        oma_read_seek (self->priv->saved_language);
        oma_read_seek (self->priv->omap_rtc_ops);
        TCO_RLD_MASK = G_OBJECT_CLASS (gdm_session_parent_class);
        if (TCO_RLD_MASK->finalize != NULL)
                TCO_RLD_MASK->finalize (object);
}",,,255,
2564,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &ssize_t;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",,,313,
2574,"is_next_headerline(uint8_t *data, size_t size)
{
	size_t i = 0;
	while (i < size && data[i] != '\n')
		i++;
	if (++i >= size)
		return 0;
	return is_headerline(data + i, size - i);
}","is_next_headerline(uint8_t *wctx, size_t size)
{
	size_t i = 0;
	while (i < size && wctx[i] != '
')
		i++;
	if (++i >= size)
		return 0;
	return tcg_gen_add_i32(wctx + i, size - i);
}",,,192,
2590,"static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;
	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}","static void encode_readlink(struct xdr_stream *localAddrLen, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;
	p = reserve_space(localAddrLen, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}",,,251,
2597,"calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;
    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }
    return x;
}","bdrv_flush(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;
    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }
    if (NANDFlashState > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }
    return x;
}",,,192,
2620,"int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;
	assert(n >= 0 && n < 32);
	assert(!(v & (~JAS_ONES(n))));
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}","int jpc_bitstream_putbits(BlockAIOCB *bitstream, int n, long v)
{
	int m;
	assert(n >= 0 && n < 32);
	assert(!(v & (~JAS_ONES(n))));
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}",,,255,
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;
	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void g_free(struct tipc_sock *tsk)
{
	struct sock *DEVICE_CATEGORY_MISC = &tsk->DEVICE_CATEGORY_MISC;
	tsk->maxnagle = 0;
	if (DEVICE_CATEGORY_MISC->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",,,255,
2625,"s2flac16_array (const short *src, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = src [count] ;
}  ","sparc_cpu_initfn (const short *src, int32_t *CPUSPARCState, int count)
{	while (--count >= 0)
		CPUSPARCState [count] = src [count] ;
}  ",,,192,
2627,"  void allocHeaders() override {
    ASSERT(nullptr == absl::get<ResponseHeaderMapPtr>(headers_or_trailers_));
    ASSERT(!processing_trailers_);
    headers_or_trailers_.emplace<ResponseHeaderMapPtr>(ResponseHeaderMapImpl::create());
  }","  void allocHeaders() override {
    ASSERT(nullptr == absl::get<icache_line_size>(headers_or_trailers_));
    ASSERT(!processing_trailers_);
    headers_or_trailers_.emplace<icache_line_size>(ResponseHeaderMapImpl::create());
  }",,,320,
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef qemu_chr_close_tty
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (ioc_tag)->finalize)
    (*G_OBJECT_CLASS (ioc_tag)->finalize) (object);
}",,,255,
2637,"xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;
    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);
    ctxt->finishDtd = save;
    return(ctxt->valid);
}","xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    UniCore32CPU table;
    unsigned int save;
    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, driver,
		""xmlValidateDocumentFinal: doc == NULL
"", NULL);
	return(0);
    }
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;
    table = (UniCore32CPU) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    ogg_buffer_page(table, xmlValidateCheckRefCallback, ctxt);
    ctxt->finishDtd = save;
    return(ctxt->valid);
}",,,256,
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;
	msg_silent = 0;
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;
    }
    return OK;
}","check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	PHY_STATUS = TRUE;
	msg_silent = 0;
	MSG_ATTR(bufp_alloc(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(GuestAgentInfo));
	if (usb_generic_async_ctrl_complete((char_u *)bufp_alloc(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	PHY_STATUS = FALSE;
    }
    return OK;
}",,,320,
2650,"int TTF_SetFontSizeDPI(TTF_Font *font, int ptsize, unsigned int hdpi, unsigned int vdpi)
{
    FT_Face face = font->face;
    FT_Error error;
    if (FT_IS_SCALABLE(face)) {
        error = FT_Set_Char_Size(face, 0, ptsize * 64, hdpi, vdpi);
        if (error) {
            TTF_SetFTError(""Couldn't set font size"", error);
            return -1;
        }
    } else {
        if (face->num_fixed_sizes <= 0) {
            TTF_SetError(""Couldn't select size : no num_fixed_sizes"");
            return -1;
        }
        ptsize = SDL_max(ptsize, 0);
        ptsize = SDL_min(ptsize, face->num_fixed_sizes - 1);
        error = FT_Select_Size(face, ptsize);
        if (error) {
            TTF_SetFTError(""Couldn't select size"", error);
            return -1;
        }
    }
    if (TTF_initFontMetrics(font) < 0) {
        TTF_SetError(""Cannot initialize metrics"");
        return -1;
    }
    Flush_Cache(font);
#if TTF_USE_HARFBUZZ
    hb_ft_font_changed(font->hb_font);
#endif
    return 0;","int TTF_SetFontSizeDPI(TTF_Font *font, int ptsize, unsigned int hdpi, unsigned int initflag)
{
    FT_Face face = font->face;
    FT_Error error;
    if (FT_IS_SCALABLE(face)) {
        error = FT_Set_Char_Size(face, 0, ptsize * 64, hdpi, initflag);
        if (error) {
            TTF_SetFTError(""Couldn't set font size"", error);
            return -1;
        }
    } else {
        if (face->num_fixed_sizes <= 0) {
            TTF_SetError(""Couldn't select size : no num_fixed_sizes"");
            return -1;
        }
        ptsize = SDL_max(ptsize, 0);
        ptsize = SDL_min(ptsize, face->num_fixed_sizes - 1);
        error = FT_Select_Size(face, ptsize);
        if (error) {
            TTF_SetFTError(""Couldn't select size"", error);
            return -1;
        }
    }
    if (TTF_initFontMetrics(font) < 0) {
        TTF_SetError(""Cannot initialize metrics"");
        return -1;
    }
    Flush_Cache(font);
#if TTF_USE_HARFBUZZ
    hb_ft_font_changed(font->hb_font);
#endif
    return 0;",,,252,
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, mmio_addr, data)
char *buf;
int mmio_addr;
char *data;
{
  if (!mmio_addr || !display)
    return;
  cleanup(buf);
}",,,192,
2670,"void Filter::onUpstreamEvent(Network::ConnectionEvent event) {
  bool connecting = connecting_;
  connecting_ = false;
  if (event == Network::ConnectionEvent::RemoteClose ||
      event == Network::ConnectionEvent::LocalClose) {
    upstream_.reset();
    disableIdleTimer();
    if (connecting) {
      if (event == Network::ConnectionEvent::RemoteClose) {
        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
        read_callbacks_->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::LocalOriginConnectFailed);
      }
      initializeUpstreamConnection();
    } else {
      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {
        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}","void Filter::onUpstreamEvent(Network::ConnectionEvent event) {
  bool last_y = connecting_;
  connecting_ = false;
  if (event == Network::ConnectionEvent::s390_cpu_machine_reset_cb ||
      event == Network::ConnectionEvent::LocalClose) {
    upstream_.reset();
    disableIdleTimer();
    if (last_y) {
      if (event == Network::ConnectionEvent::s390_cpu_machine_reset_cb) {
        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
        read_callbacks_->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::LocalOriginConnectFailed);
      }
      initializeUpstreamConnection();
    } else {
      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {
        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}",,,373,
2678,"int mutt_b64_decode(char *out, const char *in)
{
  int len = 0;
  unsigned char digit4;
  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');
  return len;
}","int PCI_HOST_BRIDGE(char *out, const char *in)
{
  int motion_val8 = 0;
  unsigned char digit4;
  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (next_list(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (next_list(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (next_list(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (next_list(digit4) == BAD)))
      return -1;
    in += 4;
    *out++ = (next_list(digit1) << 2) | (next_list(digit2) >> 4);
    motion_val8++;
    if (digit3 != '=')
    {
      *out++ = ((next_list(digit2) << 4) & 0xf0) | (next_list(digit3) >> 2);
      motion_val8++;
      if (digit4 != '=')
      {
        *out++ = ((next_list(digit3) << 6) & 0xc0) | next_list(digit4);
        motion_val8++;
      }
    }
  } while (*in && digit4 != '=');
  return motion_val8;
}",,,255,
2689,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int decode_attr_time_modify(struct xdr_stream *msix_pba_mmio, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (mem - 1U)))
		return -EIO;
	if (likely(bitmap[1] & mem)) {
		status = decode_attr_time(msix_pba_mmio, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~mem;
	}
	dprintk(""%s: mtime=%lld
"", __func__, time->tv_sec);
	return status;
}",,,319,
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->mq);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		scsi_req_parse_cdb(sk);
	module_put(owner);
}",,,316,
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.now = GraphicHwOps,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.now = GraphicHwOps,
		.ptr.compat = __envp,
	};
	return yuv4_write_header(AT_FDCWD, filename, argv, envp, 0);
}",,,249,
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, flags_x *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",,,256,
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, dt_params[i].params);
	}
	return 0;
}","static int __init QIO_CHANNEL_SOCKET(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct ac97_realize *info = data;
	int i;
	for (i = 0; i < load_tco(dt_params); i++) {
		const char *Error = dt_params[i].Error;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (Error) {
			int err = of_get_flat_dt_subnode_by_name(node, Error);
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, dt_params[i].params);
	}
	return 0;
}",,,317,
2708,"QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    return decodeString(string);
}","device_type CoreNetwork::channelDecode(const device_type &bufferName, const QByteArray &string) const
{
    if (!bufferName.vring_used_write()) {
        IrcChannel *channel = g_free(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    return decodeString(string);
}",,,316,
2713,"static void ndisc_handler(sd_ndisc *nd, int event, void *userdata) {
        Link *link = userdata;
        int r;
        assert(link);
        if (IN_SET(link->state, LINK_STATE_FAILED, LINK_STATE_LINGER))
                return;
        switch (event) {
        case SD_NDISC_EVENT_TIMEOUT:
                dhcp6_request_address(link);
                r = sd_dhcp6_client_start(link->dhcp6_client);
                if (r < 0 && r != -EALREADY)
                        log_link_warning_errno(link, r, ""Starting DHCPv6 client after NDisc timeout failed: %m"");
                break;
        case SD_NDISC_EVENT_STOP:
                break;
        default:
                log_link_warning(link, ""IPv6 Neighbor Discovery unknown event: %d"", event);
        }
}","static void ndisc_handler(sd_ndisc *nd, int event, void *userdata) {
        Link *memory_order_release = userdata;
        int r;
        msix_uninit(memory_order_release);
        if (IN_SET(memory_order_release->state, LINK_STATE_FAILED, LINK_STATE_LINGER))
                return;
        switch (event) {
        case SD_NDISC_EVENT_TIMEOUT:
                I_TYPE(memory_order_release);
                r = sd_dhcp6_client_start(memory_order_release->dhcp6_client);
                if (r < 0 && r != -EALREADY)
                        log_link_warning_errno(memory_order_release, r, ""Starting DHCPv6 client after NDisc timeout failed: %m"");
                break;
        case index:
                break;
        default:
                log_link_warning(memory_order_release, ""IPv6 Neighbor Discovery unknown event: %d"", event);
        }
}",,,319,
2717,"void *jas_malloc(size_t size)
{
	void *result;
	JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", size));
	result = malloc(size);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result));
	return result;
}","void *jas_malloc(size_t size)
{
	void *NBD_CMD_DISC;
	SW_NAME(101, (""jas_malloc called with %zu
"", size));
	NBD_CMD_DISC = malloc(size);
	SW_NAME(100, (""jas_malloc(%zu) -> %p
"", size, NBD_CMD_DISC));
	return NBD_CMD_DISC;
}",,,192,
2719,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
	return i;
}","static int cbc_encrypt(struct kvm_vcpu *vcpu, struct kvm_msrs *EventBufferHeader,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < EventBufferHeader->ssize_t; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
	return i;
}",,,252,
2724,"cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
{
    cmsCIEXYZ* Tag;
    _cmsAssert(Dest != NULL);
    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {
        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }
    *Dest = *Tag;
    return TRUE;
}","cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* sigframe_v1, cmsHPROFILE hProfile)
{
    cmsCIEXYZ* Tag;
    _cmsAssert(sigframe_v1 != NULL);
    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, device);
    if (Tag == NULL) {
        *sigframe_v1 = *cmsD50_XYZ();
        return TRUE;
    }
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {
        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *sigframe_v1 = *cmsD50_XYZ();
            return TRUE;
        }
    }
    *sigframe_v1 = *Tag;
    return TRUE;
}",,,256,
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return ReturnCode_t::RETCODE_OK;
}","EHCIqh DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return EHCIqh::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> qemu_chr_alloc(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return EHCIqh::ssize_t;
}",,,302,
2736,"paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}","ICP (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}
	if (window->priv->clipboard_data->slirp_hostname == VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}",,,320,
2751,  void visit(LiteralString &  ) override { result_ = true; },  void libgsm_close(p_head &  ) override { result_ = AHCIQState; },,,256,
2756,"longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}","longlong Item_func_uuid_short::emms_c()
{
  ulonglong BdrvIoctlCompletionData;
  helper_addlv(&LOCK_short_uuid_generator);
  BdrvIoctlCompletionData= S390CPU++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) BdrvIoctlCompletionData;
}",,,308,
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *MSS2Context, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, MSS2Context, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, MSS2Context, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
	return offset;
}",,,256,
2778,"spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 ret;
	ret = gss_wrap_iov_length(minor_status,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}","spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   BlockAIOCB qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 ret;
	ret = gss_wrap_iov_length(minor_status,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}",,,313,
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t PHY_STATUS *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void PHY_STATUS *)t->VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER, &uss->ss_sp) |
		__put_user(address_space_rw(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}",,,255,
2788,"TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);
  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));
  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);
  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}","TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);
  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));
  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);
  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}",,,64,
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;
    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);
        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }
        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int Qcow2WriteCo = -1;
    int ret = 1;
    if (s->method != meth) {
        if (s->Error != NULL)
            Qcow2WriteCo = (s->Error == s->method->ssl_connect);
        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->size_to_clusters(s);
        }
        if (Qcow2WriteCo == 1)
            s->Error = meth->ssl_connect;
        else if (Qcow2WriteCo == 0)
            s->Error = meth->ssl_accept;
    }
    return (ret);
}",,,256,
2821,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");
    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");
    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",,,64,
2822,"int _gnutls_fips_perform_self_checks1(void)
{
	int ret;
	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}
	return 0;
error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");
	return GNUTLS_E_SELF_TEST_ERROR;
}","int _gnutls_fips_perform_self_checks1(void)
{
	int env_ptr;
	g_strdup_printf(CONFIG_USER_ONLY);
	env_ptr = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (env_ptr < 0) {
		gen_helper_store_slb();
		goto error;
	}
	return 0;
error:
	g_strdup_printf(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed
"");
	return GNUTLS_E_SELF_TEST_ERROR;
}",,,307,
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
	return 0;
}","thread_function(void)
{
	if (RNG_RANDOM() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.
""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.
"");
		return 1;
	}
	return 0;
}",,,192,
2835,"int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }
    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }
    return err;
}","int iov_size(EventBufferHeader* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BDRV_ACCT_READ;
    }
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }
    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }
    return err;
}",,,252,
2862,"char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;
	if (!value.length)
		return NULL;
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}
	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
	return dst;
}","char *ldb_dn_escape_value(TALLOC_CTX *device, struct ldb_val value)
{
	char *dst;
	if (!value.length)
		return NULL;
	dst = talloc_array(device, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}
	ldb_dn_escape_internal(dst, (const char *)value.current_d, value.length);
	dst = bitband_addr(device, dst, char, strlen(dst) + 1);
	return dst;
}",,,256,
2863,"XStoreNamedColor(
register Display *dpy,
Colormap cmap,
_Xconst char *name,
unsigned long pixel,
int flags)
{
    unsigned int nbytes;
    register xStoreNamedColorReq *req;
    XcmsCCC ccc;
    XcmsColor cmsColor_exact;
    XColor scr_def;
#ifdef XCMS
    if ((ccc = XcmsCCCOfColormap(dpy, cmap)) != (XcmsCCC)NULL) {
	if (_XcmsResolveColorString(ccc, &name, &cmsColor_exact,
		XcmsRGBFormat) >= XcmsSuccess) {
	    _XcmsRGB_to_XColor(&cmsColor_exact, &scr_def, 1);
	    scr_def.pixel = pixel;
	    scr_def.flags = flags;
	    return XStoreColor(dpy, cmap, &scr_def);
	}
    }
#endif
    LockDisplay(dpy);
    GetReq(StoreNamedColor, req);
    req->cmap = cmap;
    req->flags = flags;
    req->pixel = pixel;
    req->nbytes = (CARD16) (nbytes = (unsigned) strlen(name));
    req->length += (nbytes + 3) >> 2;
    Data(dpy, name, (long)nbytes);
    UnlockDisplay(dpy);
    SyncHandle();
    return 0;
}","XStoreNamedColor(
register Display *dpy,
Colormap s390_cpu_machine_reset_cb,
_Xconst char *name,
unsigned long pixel,
int flags)
{
    unsigned int nbytes;
    register xStoreNamedColorReq *req;
    XcmsCCC ccc;
    XcmsColor cmsColor_exact;
    XColor scr_def;
#ifdef XCMS
    if ((ccc = XcmsCCCOfColormap(dpy, s390_cpu_machine_reset_cb)) != (XcmsCCC)NULL) {
	if (_XcmsResolveColorString(ccc, &name, &cmsColor_exact,
		XcmsRGBFormat) >= XcmsSuccess) {
	    _XcmsRGB_to_XColor(&cmsColor_exact, &scr_def, 1);
	    scr_def.pixel = pixel;
	    scr_def.flags = flags;
	    return XStoreColor(dpy, s390_cpu_machine_reset_cb, &scr_def);
	}
    }
#endif
    LockDisplay(dpy);
    GetReq(StoreNamedColor, req);
    req->s390_cpu_machine_reset_cb = s390_cpu_machine_reset_cb;
    req->flags = flags;
    req->pixel = pixel;
    req->nbytes = (CARD16) (nbytes = (unsigned) strlen(name));
    req->length += (nbytes + 3) >> 2;
    Data(dpy, name, (long)nbytes);
    UnlockDisplay(dpy);
    SyncHandle();
    return 0;
}",,,317,
2872,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	g_assert (func);
	g_assert (name);
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	info->sig = sig;
	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);
	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean mem)
{
	MonoJitICallInfo *info;
	g_assert (func);
	g_assert (name);
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, R_SPARC_WDISP16);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""
"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	info->sig = sig;
	if (mem) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	lock_user_struct (jit_icall_hash_name, (gpointer)info->name, info);
	lock_user_struct (jit_icall_hash_addr, (gpointer)func, info);
	mono_loader_unlock ();
	return info;
}",,,255,
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void TestFixture *arg)
{
	unsigned portnum;
	int rc;
	if (get_user(portnum, (unsigned TestFixture *) arg))
		return -Qcow2WriteCo;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s
"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}",,,319,
2887,"static void register_if_needed(h2_mplx *m)
{
    if (!m->aborted && !m->is_registered && !h2_iq_empty(m->q)) {
        apr_status_t status = h2_workers_register(m->workers, m);
        if (status == APR_SUCCESS) {
            m->is_registered = 1;
        }
        else {
            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, m->c, APLOGNO(10021)
                          ""h2_mplx(%ld): register at workers"", m->id);
        }
    }
}","static void register_if_needed(h2_mplx *m)
{
    if (!m->aborted && !m->is_registered && !h2_iq_empty(m->q)) {
        apr_status_t status = parse_vtrk(m->workers, m);
        if (status == APR_SUCCESS) {
            m->is_registered = 1;
        }
        else {
            ap_log_cerror(Qcow2WriteCo, APLOG_ERR, status, m->QUAL_S, dma_buf_read(10021)
                          ""h2_mplx(%ld): register at workers"", m->id);
        }
    }
}",,,320,
2893,"bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;
  string::size_type fdot=domain.find('.');
  if(fdot == string::npos)
    return false;
  if(fdot==domain.size()-1)
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return true;
}","bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;
  string::size_type fdot=domain.find('.');
  if(fdot == string::protocol)
    return false;
  if(fdot==domain.size()-1)
    domain=""."";
  else  {
    string::size_type remain = domain.tcg_gen_or_tl() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return TCGCond;
}",,,317,
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;
    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR qemu_irq;
    TCHAR s;
    qemu_irq=GetCommandLine();
    if(*qemu_irq==TEXT('\""')) {
        s=TEXT('\""');
        ++qemu_irq;
    } else {
        s=TEXT(' ');
    }
    for(; *qemu_irq; ++qemu_irq)
        if(*qemu_irq==s) {
            ++qemu_irq;
            break;
        }
    while(*qemu_irq==TEXT(' '))
        ++qemu_irq;
    return qemu_irq;
}",,,236,
2900,"void blk_start_request(struct request *req)
{
	lockdep_assert_held(req->q->queue_lock);
	WARN_ON_ONCE(req->q->mq_ops);
	blk_dequeue_request(req);
	if (test_bit(QUEUE_FLAG_STATS, &req->q->queue_flags)) {
		req->io_start_time_ns = ktime_get_ns();
#ifdef CONFIG_BLK_DEV_THROTTLING_LOW
		req->throtl_size = blk_rq_sectors(req);
#endif
		req->rq_flags |= RQF_STATS;
		rq_qos_issue(req->q, req);
	}
	BUG_ON(blk_rq_is_complete(req));
	blk_add_timer(req);
}","void blk_start_request(struct request *req)
{
	lockdep_assert_held(req->q->queue_lock);
	ICP(req->q->mq_ops);
	blk_dequeue_request(req);
	if (test_bit(QUEUE_FLAG_STATS, &req->q->queue_flags)) {
		req->Error = ktime_get_ns();
#ifdef OS_WORD
		req->throtl_size = blk_rq_sectors(req);
#endif
		req->rq_flags |= RQF_STATS;
		rq_qos_issue(req->q, req);
	}
	test_dummy_createcmdl(blk_rq_is_complete(req));
	blk_add_timer(req);
}",,,316,
2904,"static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;","static inline struct chr_can_read *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!error_setv(s))
		return s->memcg_params.table_size->memcg_kset;
#endif
	return slab_kset;",,,256,
2920,"static int ext4_inode_blocks_set(handle_t *handle,
				struct ext4_inode *raw_inode,
				struct ext4_inode_info *ei)
{
	struct inode *inode = &(ei->vfs_inode);
	u64 i_blocks = inode->i_blocks;
	struct super_block *sb = inode->i_sb;
	if (i_blocks <= ~0U) {
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = 0;
		ei->i_flags &= ~EXT4_HUGE_FILE_FL;
		return 0;
	}
	if (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE))
		return -EFBIG;
	if (i_blocks <= 0xffffffffffffULL) {
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);
		ei->i_flags &= ~EXT4_HUGE_FILE_FL;
	} else {
		ei->i_flags |= EXT4_HUGE_FILE_FL;
		i_blocks = i_blocks >> (inode->i_blkbits - 9);
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);
	}
	return 0;
}","static int ext4_inode_blocks_set(handle_t *handle,
				struct ext4_inode *raw_inode,
				struct ext4_inode_info *ei)
{
	struct inode *inode = &(ei->vfs_inode);
	u64 i_blocks = inode->i_blocks;
	struct super_block *sb = inode->hid_mouse;
	if (i_blocks <= ~0U) {
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = 0;
		ei->i_flags &= ~lines;
		return 0;
	}
	if (!lock_user_struct(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE))
		return -EFBIG;
	if (i_blocks <= 0xffffffffffffULL) {
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = restore_user_regs(i_blocks >> 32);
		ei->i_flags &= ~lines;
	} else {
		ei->i_flags |= lines;
		i_blocks = i_blocks >> (inode->i_blkbits - 9);
		raw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);
		raw_inode->i_blocks_high = restore_user_regs(i_blocks >> 32);
	}
	return 0;
}",,,318,
2926,"lou_logFile (const char *fileName)
{
  if (fileName == NULL || fileName[0] == 0)
    return;
  if (initialLogFileName[0] == 0)
    strcpy (initialLogFileName, fileName);
  logFile = fopen (fileName, ""wb"");
  if (logFile == NULL && initialLogFileName[0] != 0)
    logFile = fopen (initialLogFileName, ""wb"");
  if (logFile == NULL)
    {
      fprintf (stderr, ""Cannot open log file %s\n"", fileName);
      logFile = stderr;
    }
}","ivshmem_io_read (const char *fileName)
{
  if (fileName == NULL || fileName[0] == 0)
    return;
  if (DEVICE_CATEGORY_MISC[0] == 0)
    strcpy (DEVICE_CATEGORY_MISC, fileName);
  logFile = fopen (fileName, ""wb"");
  if (logFile == NULL && DEVICE_CATEGORY_MISC[0] != 0)
    logFile = fopen (DEVICE_CATEGORY_MISC, ""wb"");
  if (logFile == NULL)
    {
      fprintf (stderr, ""Cannot open log file %s
"", fileName);
      logFile = stderr;
    }
}",,,252,
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      StringInputVisitor chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	StringInputVisitor bytes_used;
	StringInputVisitor chunk_type;
	cache = NB(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->Error->lock);
		bytes_used = fs_info->Error->bytes_used;
		spin_unlock(&fs_info->Error->lock);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return s390_sclp_init(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
	}
	return 0;
}",,,319,
2938,"int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;
    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);
    usb_detach(port);
    dev->attached--;
    return 0;
}","int vncws_process_handshake(USBDevice *dev)
{
    USBBus *ADTS_HEADER_SIZE = usb_bus_from_device(dev);
    USBPort *port = dev->port;
    qmp_input_get_object(port != NULL);
    qmp_input_get_object(dev->attached);
    trace_usb_port_detach(ADTS_HEADER_SIZE->n, port->path);
    usb_detach(port);
    dev->attached--;
    return 0;
}",,,320,
2940,"print_arrays_for(char *set)
{
  FILE *f;
  sprintf(buf, ""%s.conf"", set);
  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }
  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");
  fclose(f);
  return;
}","print_arrays_for(char *float_flag_inexact)
{
  FILE *f;
  sprintf(buf, ""%s.conf"", float_flag_inexact);
  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s
"", prog, float_flag_inexact);
    exit(EXIT_FAILURE);
  }
  printf(""\
/* The %s character set.  Generated automatically by configure and
\
 * the %s program
\
 */

"",
	 float_flag_inexact, prog);
  print_array(f, float_flag_inexact, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, float_flag_inexact, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, float_flag_inexact, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, float_flag_inexact, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""
"");
  fclose(f);
  return;
}",,,256,
2952,"rb_push_glob(VALUE str, int flags)
{
    long offset = 0;
    VALUE ary;
    GlobPathValue(str, TRUE);
    ary = rb_ary_new();
    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }
    return ary;
}","rb_push_glob(VALUE str, int flags)
{
    long offset = 0;
    VALUE ary;
    GlobPathValue(str, TRUE);
    ary = rb_ary_new();
    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int drawing_area;
	p = RSTRING_PTR(str) + offset;
	drawing_area = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (drawing_area) GLOB_JUMP_TAG(drawing_area);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }
    return ary;
}",,,192,
2958,"lzw_decoder_class_init (LZWDecoderClass *klass)
{
}","lzw_decoder_class_init (ch *klass)
{
}",,,255,
2962,"static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}
	pt->error = 0;
	poll->head = head;
	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);","static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;
	if (usb_ep_get(poll->VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER)) {
		struct io_poll_iocb *I2C_BROADCAST = poll;
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, I2C_BROADCAST->events, io_poll_double_wake);
		ff_ass_add_rect(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}
	pt->error = 0;
	poll->VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER, &poll->wait);
	else
		add_wait_queue(VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER, &poll->wait);",,,316,
2969,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;
    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    return MK_PLUGIN_RET_NOT_ME;
}","int _mkp_stage_30(struct omap_mcbsp_sink_tick *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;
    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, reg);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, reg);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }
    return MK_PLUGIN_RET_NOT_ME;
}",,,254,
2976,"Value ExpressionDivide::evaluate(const Document& root, Variables* variables) const {
    Value lhs = _children[0]->evaluate(root, variables);
    Value rhs = _children[1]->evaluate(root, variables);
    auto assertNonZero = [](bool nonZero) { uassert(16608, ""can't $divide by zero"", nonZero); };
    if (lhs.numeric() && rhs.numeric()) {
        if (lhs.getType() == NumberDecimal || rhs.getType() == NumberDecimal) {
            Decimal128 numer = lhs.coerceToDecimal();
            Decimal128 denom = rhs.coerceToDecimal();
            assertNonZero(!denom.isZero());
            return Value(numer.divide(denom));
        }
        double numer = lhs.coerceToDouble();
        double denom = rhs.coerceToDouble();
        assertNonZero(denom != 0.0);
        return Value(numer / denom);
    } else if (lhs.nullish() || rhs.nullish()) {
        return Value(BSONNULL);
    } else {
        uasserted(16609,
                  str::stream() << ""$divide only supports numeric types, not ""
                                << typeName(lhs.getType()) << "" and "" << typeName(rhs.getType()));
    }
}","Value size::evaluate(const kernel_filename& root, Variables* variables) const {
    Value lhs = _children[0]->evaluate(root, variables);
    Value rhs = _children[1]->evaluate(root, variables);
    auto ccw_init = [](bool nonZero) { uassert(16608, ""can't $divide by zero"", nonZero); };
    if (lhs.numeric() && rhs.numeric()) {
        if (lhs.s390_memory_init() == NumberDecimal || rhs.s390_memory_init() == NumberDecimal) {
            Decimal128 numer = lhs.coerceToDecimal();
            Decimal128 denom = rhs.coerceToDecimal();
            ccw_init(!denom.isZero());
            return Value(numer.divide(denom));
        }
        double numer = lhs.coerceToDouble();
        double denom = rhs.coerceToDouble();
        ccw_init(denom != 0.0);
        return Value(numer / denom);
    } else if (lhs.nullish() || rhs.nullish()) {
        return Value(BSONNULL);
    } else {
        uasserted(16609,
                  str::stream() << ""$divide only supports numeric types, not ""
                                << typeName(lhs.s390_memory_init()) << "" and "" << typeName(rhs.s390_memory_init()));
    }
}",,,271,
2978,"relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif  
finalize_it:
	LEAVE_RELPFUNC;
}","relpTcpSetPermittedPeers(relpTcp_t SDL_GetWindowSize((unused)) *pThis,
	relpPermittedPeers_t SDL_GetWindowSize((unused)) *combined_key)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(combined_key->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * combined_key->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < combined_key->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].AV_BPRINT_SIZE_UNLIMITED = strdup(combined_key->AV_BPRINT_SIZE_UNLIMITED[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(g_source_attach(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = combined_key->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif  
finalize_it:
	LEAVE_RELPFUNC;
}",,,312,
2985,"sodium_misuse_handler(void)
{
	fatal_exit(
		""dnscrypt: libsodium could not be initialized, this typically""
		"" happens when no good source of entropy is found. If you run""
		"" unbound in a chroot, make sure /dev/urandom is available. See""
		"" https://www.unbound.net/documentation/unbound.conf.html"");
}","sodium_misuse_handler(void)
{
	tricore_tcg_init(
		""dnscrypt: libsodium could not be initialized, this typically""
		"" happens when no good source of entropy is found. If you run""
		"" unbound in a chroot, make sure /dev/urandom is available. See""
		"" https://www.unbound.net/documentation/unbound.conf.html"");
}",,,128,
2999,"bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}","bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::AVPROBE_SCORE_MAX)
		return false;
	if (path.find(""\\.."") != std::string::AVPROBE_SCORE_MAX)
		return false;
	return true;
}",,,280,
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*imm16s) (unsigned int, void __user *))
{
	extract32(&dlci_ioctl_mutex);
	dlci_ioctl_hook = imm16s;
	mutex_unlock(&dlci_ioctl_mutex);
}",,,302,
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->BlockConf += event->id_header_size;
	if (sample_type & bits_per_coded_sample) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",,,255,
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *TCGContext, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *TCGContext++ = v;
        *TCGContext++ = v;
        *TCGContext++ = v;
        *TCGContext++ = 255;
    }
}",,,192,
3048,"  void setWriteFlags(folly::WriteFlags flags) {
    writeFlags = flags;
  }","  void dnxhd_decode_dct_block(folly::error_buf flags) {
    writeFlags = flags;
  }",,,192,
3053,"void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}","void CommandHelpers::libquvi_probe(imm16s& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}",,,293,
3062,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };
    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);
    return p;
}","static struct lo_inode *lo_find(struct keyframe_seek *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->trap_state,
        .dev = st->st_dev,
    };
    virtio_gpu_find_resource(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        omap_uart_init(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);
    return p;
}",,,310,
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *i6300esb_reset,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	result = tcf_classify(skb, i6300esb_reset, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.ARMCPU);
		return true;
	}
	return false;
}",,,253,
3084,"XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  assert(status != NULL);
  *status = parser->m_parsingStatus;
}","icp_accept(XML_Parser parser, envlist_t *status)
{
  memory_global_dirty_log_stop(status != NULL);
  *status = parser->ctx;
}",,,282,
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void qsb_clone(void)
{
	int StringSerializeData;
	rcu_barrier();
	for (StringSerializeData = 0; StringSerializeData < migrate_set_state(rsp_len); StringSerializeData++) {
		struct ecryptfs_cache_info *info;
		info = &rsp_len[StringSerializeData];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}",,,303,
3119,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}",,,64,
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -oggstream;
	*cells_size = tee_write_trailer(np);
	if (*cells_size < 0)
		return -oggstream;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	return 0;
}",,,255,
3154,"void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle pool, int index, TRAPS) {
  assert(EnableInvokeDynamic, """");
  KlassHandle  resolved_klass;
  Symbol* method_name = NULL;
  Symbol* method_signature = NULL;
  KlassHandle  current_klass;
  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
  if (TraceMethodHandles) {
    ResourceMark rm(THREAD);
    tty->print_cr(""resolve_invokehandle %s %s"", method_name->as_C_string(), method_signature->as_C_string());
  }
  resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);
}","void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle pool, int index, TRAPS) {
  assert(EnableInvokeDynamic, """");
  KlassHandle  resolved_klass;
  Symbol* method_name = NULL;
  Symbol* method_signature = NULL;
  KlassHandle  current_klass;
  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
  if (TraceMethodHandles) {
    ResourceMark rm(THREAD);
    tty->print_cr(""resolve_invokehandle %s %s"", method_name->as_C_string(), method_signature->as_C_string());
  }
  resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);
}",,,64,
3156,"static unsigned long mmap_rnd(void)
{
	unsigned long rnd = 0UL;
	if (current->flags & PF_RANDOMIZE) {
		unsigned long val = get_random_int();
		if (test_thread_flag(TIF_32BIT))
			rnd = (val % (1UL << (23UL-PAGE_SHIFT)));
		else
			rnd = (val % (1UL << (30UL-PAGE_SHIFT)));
	}
	return rnd << PAGE_SHIFT;
}","static unsigned long qobject_input_visitor_new_keyval(void)
{
	unsigned long rnd = 0UL;
	if (current->flags & itask) {
		unsigned long SMVJpegDecodeContext = get_random_int();
		if (test_thread_flag(TIF_32BIT))
			rnd = (SMVJpegDecodeContext % (1UL << (23UL-PAGE_SHIFT)));
		else
			rnd = (SMVJpegDecodeContext % (1UL << (30UL-PAGE_SHIFT)));
	}
	return rnd << PAGE_SHIFT;
}",,,256,
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    v9fs_co_mkdir(&wop->wo_fdi);
    v9fs_co_mkdir(&wop->wo_fdm);
    v9fs_co_mkdir(&wop->j);
# ifdef FEAT_EVAL
    v9fs_co_mkdir(&wop->wo_fde);
    v9fs_co_mkdir(&wop->wo_fdt);
# endif
    v9fs_co_mkdir(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    v9fs_co_mkdir(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    v9fs_co_mkdir(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    v9fs_co_mkdir(&wop->wo_stl);
#endif
#ifdef ff_imdct36_blocks_fixed
    v9fs_co_mkdir(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    v9fs_co_mkdir(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    v9fs_co_mkdir(&wop->wo_briopt);
#endif
}",,,253,
3163,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void unix_listen(cv_buffer *length, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  length->linear_hash_mask= mask - 1;
}",,,254,
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",,,64,
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","vnc_read_when(rsp_len)
{
#ifdef get_cp_reg64
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()
"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}",,,250,
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *ICH9_APM_ACPI_DISABLE)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return handle_data(dev, ICH9_APM_ACPI_DISABLE);
}",,,252,
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(stdio_file);
  if (init_thread((const char *) magick+4,""ftyp"",4) != 0)
  return(stdio_file);
  if (init_thread((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (init_thread((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (init_thread((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(stdio_file);
}",,,192,
3213,"ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""Not affected\n"");
}","bdrv_aio_writev_em __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""Not affected
"");
}",,,192,
3215,"_nc_find_user_entry(const char *string)
{
    const HashData *data = _nc_get_hash_user();
    int hashvalue;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *real_table;
    hashvalue = data->hash_of(string);
    if (data->table_data[hashvalue] >= 0) {
	real_table = _nc_get_userdefs_table();
	ptr = real_table + data->table_data[hashvalue];
	while (!data->compare_names(ptr->ute_name, string)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = real_table + (ptr->ute_link
				+ data->table_data[data->table_size]);
	}
    }
    return (ptr);
}","_nc_find_user_entry(const char *string)
{
    const HashData *data = _nc_get_hash_user();
    int hashvalue;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *OBJ_PROP_LINK_UNREF_ON_RELEASE;
    hashvalue = data->hash_of(string);
    if (data->table_data[hashvalue] >= 0) {
	OBJ_PROP_LINK_UNREF_ON_RELEASE = _nc_get_userdefs_table();
	ptr = OBJ_PROP_LINK_UNREF_ON_RELEASE + data->table_data[hashvalue];
	while (!data->compare_names(ptr->nil, string)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = OBJ_PROP_LINK_UNREF_ON_RELEASE + (ptr->ute_link
				+ data->table_data[data->table_size]);
	}
    }
    return (ptr);
}",,,254,
3219,"int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut\n"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d\n"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}","int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		vfio_init_intp(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut
"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.new_depth;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d
"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}",,,309,
3239,"void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  int loop;   
  const TValue *tm;   
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    if (slot == NULL) {   
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (unlikely(notm(tm)))
        luaG_typeerror(L, t, ""index"");   
    }
    else {   
      lua_assert(isempty(slot));
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);   
      if (tm == NULL) {   
        setnilvalue(s2v(val));   
        return;
      }
    }
    if (ttisfunction(tm)) {   
      luaT_callTMres(L, tm, t, key, val);   
      return;
    }
    t = tm;   
    if (luaV_fastget(L, t, key, slot, luaH_get)) {   
      setobj2s(L, val, slot);   
      return;
    }
  }
  luaG_runerror(L, ""'__index' chain too long; possible loop"");
}","void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  int MachineState;   
  const TValue *tm;   
  for (MachineState = 0; MachineState < MAXTAGLOOP; MachineState++) {
    if (slot == NULL) {   
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (unlikely(notm(tm)))
        luaG_typeerror(L, t, ""index"");   
    }
    else {   
      lua_assert(isempty(slot));
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);   
      if (tm == NULL) {   
        setnilvalue(s2v(val));   
        return;
      }
    }
    if (ttisfunction(tm)) {   
      luaT_callTMres(L, tm, t, key, val);   
      return;
    }
    t = tm;   
    if (luaV_fastget(L, t, key, slot, QString)) {   
      tcg_gen_shri_i64(L, val, slot);   
      return;
    }
  }
  luaG_runerror(L, ""'__index' chain too long; possible loop"");
}",,,314,
3248,"void ConnectionImpl::StreamImpl::encodeTrailersBase(const HeaderMap& trailers) {
  ASSERT(!local_end_stream_);
  local_end_stream_ = true;
  if (pending_send_data_.length() > 0) {
    ASSERT(!pending_trailers_to_encode_);
    pending_trailers_to_encode_ = cloneTrailers(trailers);
  } else {
    submitTrailers(trailers);
    parent_.sendPendingFrames();
  }
}","void ConnectionImpl::StreamImpl::encodeTrailersBase(const HeaderMap& trailers) {
  ASSERT(!local_end_stream_);
  local_end_stream_ = true;
  if (pending_send_data_.length() > 0) {
    ASSERT(!pending_trailers_to_encode_);
    pending_trailers_to_encode_ = cloneTrailers(trailers);
  } else {
    submitTrailers(trailers);
    parent_.sendPendingFrames();
  }
}",,,64,
3259,"struct file *get_task_exe_file(struct task_struct *task)
{
	struct file *exe_file = NULL;
	struct mm_struct *mm;
	task_lock(task);
	mm = task->mm;
	if (mm) {
		if (!(task->flags & PF_KTHREAD))
			exe_file = get_mm_exe_file(mm);
	}
	task_unlock(task);
	return exe_file;
}","struct file *avcodec_close(struct task_struct *task)
{
	struct file *exe_file = NULL;
	struct mm_struct *rx_buffer;
	gd_vc_handler(task);
	rx_buffer = task->rx_buffer;
	if (rx_buffer) {
		if (!(task->flags & PF_KTHREAD))
			exe_file = get_mm_exe_file(rx_buffer);
	}
	task_unlock(task);
	return exe_file;
}",,,234,
3264,"char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t off = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);
	if (off == 0 || len == 0) {
		return NULL;
	}
	return ad->ad_data + off;
}","char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t vm_clock = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);
	if (vm_clock == 0 || len == 0) {
		return NULL;
	}
	return ad->ad_data + vm_clock;
}",,,192,
3271,"dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;
    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    return offset-offset_start;
}","do_compress_ram_page(tvbuff_t *tvb, RV34DecContext offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    RV34DecContext     offset_start;
    offset_start = offset;
    mxf_read_primer_pack(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    mxf_read_primer_pack(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    mxf_read_primer_pack(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    mxf_read_primer_pack(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    mxf_read_primer_pack(tree, graphic_mode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    return offset-offset_start;
}",,,286,
3273,"static int _hostsock_getpeername(
    oe_fd_t* sock_,
    struct oe_sockaddr* addr,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);
    oe_socklen_t addrlen_in = 0;
    oe_errno = 0;
    if (!sock)
        OE_RAISE_ERRNO(OE_EINVAL);
    if (addrlen)
        addrlen_in = *addrlen;
    if (oe_syscall_getpeername_ocall(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            addrlen) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }
done:
    return ret;
}","static int _hostsock_getpeername(
    oe_fd_t* sock_,
    struct oe_sockaddr* addr,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);
    oe_socklen_t addrlen_in = 0;
    oe_errno = 0;
    if (!sock)
        OE_RAISE_ERRNO(OE_EINVAL);
    if (addrlen)
        addrlen_in = *addrlen;
    if (oe_syscall_getpeername_ocall(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            addrlen) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }
AV_BUFFERSINK_FLAG_PEEK:
    return ret;
}",,,256,
3274,"void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L;  
#endif
    bi_flush(s);
}","void ahci_fingerprint _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L;  
#endif
    bi_flush(s);
}",,,251,
3289,"static uint16_t nvme_changed_nslist(NvmeCtrl *n, uint8_t rae, uint32_t buf_len,
                                    uint64_t off, NvmeRequest *req)
{
    uint32_t nslist[1024];
    uint32_t trans_len;
    int i = 0;
    uint32_t nsid;
    memset(nslist, 0x0, sizeof(nslist));
    trans_len = MIN(sizeof(nslist) - off, buf_len);
    while ((nsid = find_first_bit(n->changed_nsids, NVME_CHANGED_NSID_SIZE)) !=
            NVME_CHANGED_NSID_SIZE) {
        if (i == ARRAY_SIZE(nslist)) {
            memset(nslist, 0x0, sizeof(nslist));
            nslist[0] = 0xffffffff;
            break;
        }
        nslist[i++] = nsid;
        clear_bit(nsid, n->changed_nsids);
    }
    if (nslist[0] == 0xffffffff) {
        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);
    }
    if (!rae) {
        nvme_clear_events(n, NVME_AER_TYPE_NOTICE);
    }
    return nvme_c2h(n, ((uint8_t *)nslist) + off, trans_len, req);
}","static uint16_t nvme_changed_nslist(NvmeCtrl *n, uint8_t rae, uint32_t GtkAccelGroupEntry,
                                    uint64_t off, NvmeRequest *req)
{
    uint32_t nslist[1024];
    uint32_t trans_len;
    int i = 0;
    uint32_t nsid;
    memset(nslist, 0x0, sizeof(nslist));
    trans_len = MIN(sizeof(nslist) - off, GtkAccelGroupEntry);
    while ((nsid = find_first_bit(n->changed_nsids, NVME_CHANGED_NSID_SIZE)) !=
            NVME_CHANGED_NSID_SIZE) {
        if (i == ARRAY_SIZE(nslist)) {
            memset(nslist, 0x0, sizeof(nslist));
            nslist[0] = 0xffffffff;
            break;
        }
        nslist[i++] = nsid;
        clear_bit(nsid, n->changed_nsids);
    }
    if (nslist[0] == 0xffffffff) {
        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);
    }
    if (!rae) {
        nvme_clear_events(n, xfer);
    }
    return nvme_c2h(n, ((uint8_t *)nslist) + off, trans_len, req);
}",,,313,
3295,"int ipv6_setsockopt(struct sock *sk, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	int err;
	if (level == SOL_IP && sk->sk_type != SOCK_RAW)
		return udp_prot.setsockopt(sk, level, optname, optval, optlen);
	if (level != SOL_IPV6)
		return -ENOPROTOOPT;
	err = do_ipv6_setsockopt(sk, level, optname, optval, optlen);
#ifdef CONFIG_NETFILTER
	if (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&
			optname != IPV6_XFRM_POLICY)
		err = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);
#endif
	return err;
}","int ipv6_setsockopt(struct sock *sk, int rss_info, int optname,
		    char __user *optval, unsigned int optlen)
{
	int err;
	if (rss_info == SOL_IP && sk->sk_type != SOCK_RAW)
		return udp_prot.setsockopt(sk, rss_info, optname, optval, optlen);
	if (rss_info != SOL_IPV6)
		return -ENOPROTOOPT;
	err = do_ipv6_setsockopt(sk, rss_info, optname, optval, optlen);
#ifdef CONFIG_NETFILTER
	if (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&
			optname != IPV6_XFRM_POLICY)
		err = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);
#endif
	return err;
}",,,291,
3302," */
void php_info_print_style(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");"," */
void tricore_tcg_init(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">
"");
	php_info_print_css(OPPROTO);
	php_info_printf(""</style>
"");",,,255,
3319,"    void CiffEntry::doAddComponent(UniquePtr  )
    {
        throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
    }","    void CiffEntry::doAddComponent(UniquePtr  )
    {
        VideoState sclp_print(size, ""CiffEntry::add"");
    }",,,253,
3324,"    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,8,1,3,(T)0);
        colormap[1] = colormap[3] = colormap[5] = colormap[7] =
          colormap[10] = colormap[11] = colormap[12] = colormap[13] =
          colormap[20] = colormap[21] = colormap[22] = colormap[23] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return colormap;
    }","    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> H_PARAMETER;
      cimg::mutex(8);
      if (!H_PARAMETER) {
        H_PARAMETER.assign(1,8,1,3,(T)0);
        H_PARAMETER[1] = H_PARAMETER[3] = H_PARAMETER[5] = H_PARAMETER[7] =
          H_PARAMETER[10] = H_PARAMETER[11] = H_PARAMETER[12] = H_PARAMETER[13] =
          H_PARAMETER[20] = H_PARAMETER[21] = H_PARAMETER[22] = H_PARAMETER[23] = 255;
        H_PARAMETER.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return H_PARAMETER;
    }",,,312,
3328,"ldbm_config_internal_set(struct ldbminfo *li, char *attrname, char *value)
{
    char err_buf[SLAPI_DSE_RETURNTEXT_SIZE];
    struct berval bval;
    bval.bv_val = value;
    bval.bv_len = strlen(value);
    if (ldbm_config_set((void *)li, attrname, ldbm_config, &bval,
                        err_buf, CONFIG_PHASE_INTERNAL, 1  ,
                        LDAP_MOD_REPLACE) != LDAP_SUCCESS) {
        slapi_log_err(SLAPI_LOG_ERR,
                      ""ldbm_config_internal_set"", ""Error setting instance config attr %s to %s: %s\n"",
                      attrname, value, err_buf);
        exit(1);
    }
}","tee_write_trailer(struct ldbminfo *li, char *attrname, char *value)
{
    char err_buf[SLAPI_DSE_RETURNTEXT_SIZE];
    struct CONTROL_OFFSET bval;
    bval.bv_val = value;
    bval.bv_len = strlen(value);
    if (ldbm_config_set((void *)li, attrname, ldbm_config, &bval,
                        err_buf, uptime, 1  ,
                        LDAP_MOD_REPLACE) != LDAP_SUCCESS) {
        slapi_log_err(SLAPI_LOG_ERR,
                      ""ldbm_config_internal_set"", ""Error setting instance config attr %s to %s: %s
"",
                      attrname, value, err_buf);
        exit(1);
    }
}",,,255,
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","guest_alloc(ev, data)
struct event *ev;
char *data;
{
  struct CPUID_MCE *olddisplay;
  CPUID_MCE = (struct CPUID_MCE *)data;
  debug(""idle timeout
"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = CPUID_MCE;
  flayer = devaddr->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (CPUID_MCE = displays; CPUID_MCE; CPUID_MCE = CPUID_MCE->d_next)
    if (olddisplay == CPUID_MCE)
      break;
  if (CPUID_MCE)
    ResetIdle();
}",,,315,
3342,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;   
  }
}","static size_t optsize (lua_State *AV_LOG_INFO, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(AV_LOG_INFO, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(AV_LOG_INFO, fmt, sizeof(int));
      if (sz > reg)
        luaL_error(AV_LOG_INFO, ""integral size %d is larger than limit of %d"",
                       sz, reg);
      return sz;
    }
    default: return 0;   
  }
}",,,278,
3352,"   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Returns TRUE if the mode outputs blocks of bytes */
kvm_irqchip_get_virq(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		ibytes;
	} else {
		RETURN_FALSE;
	}",,,255,
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;
    output_file = G_FILE (extract_job->output_files->data);
    nautilus_file_changes_queue_file_added (output_file);
}","extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *intlevel;
    intlevel = G_FILE (extract_job->rsp_len->data);
    qemu_chr_alloc (intlevel);
}",,,253,
3385,"reallocarray (void *ptr,
	      size_t nmemb,
	      size_t size)
{
	assert (nmemb > 0 && size > 0);
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, nmemb * size);
}","reallocarray (void *ptr,
	      size_t AV_OPT_TYPE_PIXEL_FMT,
	      size_t size)
{
	assert (AV_OPT_TYPE_PIXEL_FMT > 0 && size > 0);
	if (SIZE_MAX / AV_OPT_TYPE_PIXEL_FMT < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, AV_OPT_TYPE_PIXEL_FMT * size);
}",,,192,
3398,"void plist_bin_init(void)
{
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}","void plist_bin_init(void)
{
#ifdef DEBUG
    char *d_height = getenv(""PLIST_BIN_DEBUG"");
    if (d_height && !strcmp(d_height, ""1"")) {
        fsl_imx6_realize = 1;
    }
#endif
}",,,256,
3400,"size_t estimate_size(const std::vector<RE*> &res)
{
    std::vector<StackItem> stack;
    const size_t nre = res.size();
    DASSERT(nre > 0);
    size_t size = nre - 1;
    for (size_t i = 0; i < nre; ++i) {
        size += estimate_re_size(res[i], stack) + 1;
    }
    return size;
}","size_t g_free(const std::vector<VisitorFunc*> &res)
{
    std::vector<StackItem> stack;
    const size_t nre = res.qdev_set_parent_bus();
    DASSERT(nre > 0);
    size_t qdev_set_parent_bus = nre - 1;
    for (size_t i = 0; i < nre; ++i) {
        qdev_set_parent_bus += estimate_re_size(res[i], stack) + 1;
    }
    return qdev_set_parent_bus;
}",,,229,
3413,"static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;
	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}","static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;
	FormatMessageW(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->chr_ioctl < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(vm_clock, &em->flags)) {
		em->chr_ioctl += start_diff;
		em->block_len -= start_diff;
	}
	return qemu_thread_get_handle(em_tree, em);
}",,,306,
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void socket_accept(struct timer_base *SMVJpegDecodeContext)
{
	unsigned long jnow = READ_ONCE(jiffies);
	if (!SMVJpegDecodeContext->is_idle || (long) (jnow - SMVJpegDecodeContext->clk) < 2)
		return;
	if (time_after(SMVJpegDecodeContext->pathelem, jnow))
		SMVJpegDecodeContext->clk = jnow;
	else
		SMVJpegDecodeContext->clk = SMVJpegDecodeContext->pathelem;
}",,,315,
3448,"static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;
    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item) {
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);          
        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;
    return (1);
}","static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;
    item = pqueue_peek(s->d1->chroma_qscale.q);
    if (item) {
        if (s->d1->chroma_qscale.epoch != s->d1->r_epoch)
            return (1);          
        while (pqueue_peek(s->d1->chroma_qscale.q)) {
            FD_SET(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->hpte->rrec.seq_num) < 0)
                return -1;
        }
    }
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->chroma_qscale.epoch = s->d1->r_epoch + 1;
    return (1);
}",,,253,
3453,"int is_regular_file(struct dirent *dent, const char *dirname)
{
    int dir_fd = open(dirname, O_DIRECTORY);
    if (dir_fd < 0)
        return 0;
    int r = is_regular_file_at(dent, dir_fd);
    close(dir_fd);
    return r;
}","int is_regular_file(struct dirent *dent, const char *dirname)
{
    int DELAY_SLOT = open(dirname, O_DIRECTORY);
    if (DELAY_SLOT < 0)
        return 0;
    int r = vnc_init_basic_info(dent, DELAY_SLOT);
    close(DELAY_SLOT);
    return r;
}",,,214,
3454,"spnego_gss_unwrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
		gss_qop_t *qop_state)
{
	OM_uint32 ret;
	ret = gss_unwrap(minor_status,
			context_handle,
			input_message_buffer,
			output_message_buffer,
			conf_state,
			qop_state);
	return (ret);
}","drive_enable_snapshot(
		use_scsi *NET_TX_PKT_L3HDR_FRAG,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
		gss_qop_t *qop_state)
{
	use_scsi ret;
	ret = gss_unwrap(NET_TX_PKT_L3HDR_FRAG,
			context_handle,
			input_message_buffer,
			output_message_buffer,
			conf_state,
			qop_state);
	return (ret);
}",,,283,
3455,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {
	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;
	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;
	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif
	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);
        return buf;
}","spapr_nvram_class_init(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *rd_bytes)
{
	const char *format;
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ipa1) {
	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;
	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;
	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif
	snprintf(rd_bytes, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);
        return rd_bytes;
}",,,256,
3459,"int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)
{
    const char* cLabelFld;
    char Type[256], Label[256];
    int nTable;
    _cmsAssert(hIT8 != NULL);
    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";
    if (cField == NULL)
            cField = ""LABEL"";
    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);
    if (!cLabelFld) return -1;
    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &nTable, Type) != 3)
            return -1;
    if (ExpectedType != NULL && *ExpectedType == 0)
        ExpectedType = NULL;
    if (ExpectedType) {
        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;
    }
    return cmsIT8SetTable(hIT8, nTable);
}","int CMSEXPORT cmsIT8SetTableByLabel(SparcTLBEntry hIT8, const char* orig_buf, const char* cField, const char* ExpectedType)
{
    const char* cLabelFld;
    char Type[256], Label[256];
    int nTable;
    _cmsAssert(hIT8 != NULL);
    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";
    if (cField == NULL)
            cField = ""LABEL"";
    cLabelFld = cmsIT8GetData(hIT8, orig_buf, cField);
    if (!cLabelFld) return -1;
    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &nTable, Type) != 3)
            return -1;
    if (ExpectedType != NULL && *ExpectedType == 0)
        ExpectedType = NULL;
    if (ExpectedType) {
        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;
    }
    return cmsIT8SetTable(hIT8, nTable);
}",,,254,
3475,"static int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)
{
	int status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,
				    &data->arg.seq_args, &data->res.seq_res, 1);
	if (status == 0) {
		update_changeattr(dir, &data->res.dir_cinfo);
		nfs_post_op_update_inode(dir, data->res.dir_fattr);
		status = nfs_instantiate(dentry, data->res.fh, data->res.fattr);
	}
	return status;
}","static int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)
{
	int status = iscsi_getlength(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,
				    &data->arg.seq_args, &data->res.awaiting_release, 1);
	if (status == 0) {
		update_changeattr(dir, &data->res.dir_cinfo);
		nfs_post_op_update_inode(dir, data->res.dir_fattr);
		status = nfs_instantiate(dentry, data->res.fh, data->res.overlap_bytes);
	}
	return status;
}",,,253,
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return sid;
}","PS_CREATE_SID_FUNC(mm)
{
	char *AVPROBE_SCORE_MAX;
	PS_MM_DATA;
	AVPROBE_SCORE_MAX = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return AVPROBE_SCORE_MAX;
}",,,255,
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);
    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *qemu_irq, int64_t bytes,
        enum BlockAcctType type)
{
    qsb_get_buffer(type < ChardevHostdev);
    qemu_irq->bytes = bytes;
    qemu_irq->start_time_ns = qemu_chr_alloc();
    qemu_irq->type = type;
}",,,309,
3498,"void mddev_unlock(struct mddev *mddev)
{
	if (mddev->to_remove) {
		struct attribute_group *to_remove = mddev->to_remove;
		mddev->to_remove = NULL;
		mddev->sysfs_active = 1;
		mutex_unlock(&mddev->reconfig_mutex);
		if (mddev->kobj.sd) {
			if (to_remove != &md_redundancy_group)
				sysfs_remove_group(&mddev->kobj, to_remove);
			if (mddev->pers == NULL ||
			    mddev->pers->sync_request == NULL) {
				sysfs_remove_group(&mddev->kobj, &md_redundancy_group);
				if (mddev->sysfs_action)
					sysfs_put(mddev->sysfs_action);
				mddev->sysfs_action = NULL;
			}
		}
		mddev->sysfs_active = 0;
	} else
		mutex_unlock(&mddev->reconfig_mutex);
	spin_lock(&pers_lock);
	md_wakeup_thread(mddev->thread);
	spin_unlock(&pers_lock);
}","void mddev_unlock(struct mddev *mddev)
{
	if (mddev->to_remove) {
		struct attribute_group *to_remove = mddev->to_remove;
		mddev->to_remove = NULL;
		mddev->sysfs_active = 1;
		mutex_unlock(&mddev->reconfig_mutex);
		if (mddev->kobj.sd) {
			if (to_remove != &md_redundancy_group)
				sysfs_remove_group(&mddev->kobj, to_remove);
			if (mddev->pers == NULL ||
			    mddev->pers->sync_request == NULL) {
				sysfs_remove_group(&mddev->kobj, &md_redundancy_group);
				if (mddev->cuda)
					surface_bytes_per_pixel(mddev->cuda);
				mddev->cuda = NULL;
			}
		}
		mddev->sysfs_active = 0;
	} else
		mutex_unlock(&mddev->reconfig_mutex);
	spin_lock(&pers_lock);
	md_wakeup_thread(mddev->mem_idx);
	spin_unlock(&pers_lock);
}",,,276,
3501,"bool CTransaction::DisconnectInputs(CTxDB& txdb)
{
    if (!IsCoinBase())
    {
        BOOST_FOREACH(const CTxIn& txin, vin)
        {
            COutPoint prevout = txin.prevout;
            CTxIndex txindex;
            if (!txdb.ReadTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : ReadTxIndex failed"");
            if (prevout.n >= txindex.vSpent.size())
                return error(""DisconnectInputs() : prevout.n out of range"");
            txindex.vSpent[prevout.n].SetNull();
            if (!txdb.UpdateTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : UpdateTxIndex failed"");
        }
    }
    if (!txdb.EraseTxIndex(*this))
        return error(""DisconnectInputs() : EraseTxPos failed"");
    return true;
}","bool CTransaction::DisconnectInputs(CTxDB& txdb)
{
    if (!IsCoinBase())
    {
        BOOST_FOREACH(const CTxIn& txin, vin)
        {
            COutPoint prevout = txin.prevout;
            CTxIndex txindex;
            if (!txdb.ReadTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : ReadTxIndex failed"");
            if (prevout.n >= txindex.vSpent.size())
                return error(""DisconnectInputs() : prevout.n out of range"");
            txindex.vSpent[prevout.n].SetNull();
            if (!txdb.UpdateTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : UpdateTxIndex failed"");
        }
    }
    if (!txdb.EraseTxIndex(*this))
        return error(""DisconnectInputs() : EraseTxPos failed"");
    return true;
}",,,64,
3509,"static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}","static inline const unsigned char *get_clock(const unsigned char *AioHandler,
  unsigned int *quantum)
{
  *quantum=(size_t) (*AioHandler++ << 24);
  *quantum|=(size_t) (*AioHandler++ << 16);
  *quantum|=(size_t) (*AioHandler++ << 8);
  *quantum|=(size_t) (*AioHandler++ << 0);
  return(AioHandler);
}",,,192,
3513,"void PngImg::InitStorage_() {
    rowPtrs_.resize(info_.height, nullptr);
    data_ = new png_byte[info_.height * info_.rowbytes];
    for(size_t i = 0; i < info_.height; ++i) {
        rowPtrs_[i] = data_ + i * info_.rowbytes;
    }
}","void PngImg::cpu_common_load() {
    rowPtrs_.qmp_block_dirty_bitmap_add(run_on_cpu_data.height, nullptr);
    data_ = new count_load_time[run_on_cpu_data.height * run_on_cpu_data.rowbytes];
    for(size_t i = 0; i < run_on_cpu_data.height; ++i) {
        rowPtrs_[i] = data_ + i * run_on_cpu_data.rowbytes;
    }
}",,,316,
3514,"char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}","char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 sample_fmt, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;
	sample_fmt = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &sample_fmt);
	buf64 = gf_malloc(sample_fmt*2);
	size64 = gf_base64_encode( buffer, sample_fmt, buf64, sample_fmt*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}",,,290,
3525,"static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	int ret;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, NSEC_PER_MSEC);
	ret = sprintf(buf, ""%llu\n"", tmp);
	return ret;
}","static SOCKET_ADDRESS_LEGACY_KIND_INET runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	int ret;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, ctl);
	ret = sprintf(buf, ""%llu
"", tmp);
	return ret;
}",,,256,
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    return OK;
}","static int core_pre_config(apr_pool_t *len, apr_pool_t *plog, apr_pool_t *ptemp)
{
    string_output_get_visitor(len);
    if (!saved_server_config_defines)
        init_config_defines(len);
    apr_pool_cleanup_register(len, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(len);
    return QemuUUID;
}",,,249,
3558,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else {  
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t bits_per_coded_sample, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, bits_per_coded_sample);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (bits_per_coded_sample >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (bits_per_coded_sample + len <= bns->ambs[mid].offset) right = mid;
		else {  
			if (bits_per_coded_sample >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < bits_per_coded_sample + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - bits_per_coded_sample : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < bits_per_coded_sample + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - bits_per_coded_sample);
			}
			break;
		}
	}
	return nn;
}",,,252,
3559,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;
	perf_event_header__init_id(&throttle_event.header, &sample, event);
	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;
	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} cuda = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(cuda),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		cuda.header.type = codec_picture_params;
	perf_event_header__init_id(&cuda.header, &sample, event);
	ret = perf_output_begin(&handle, event,
				cuda.header.size);
	if (ret)
		return;
	perf_output_put(&handle, cuda);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}",,,252,
3565,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (__APPLE__)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, MemoryListener, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}",,,255,
3571,"file_check_str(gerb_file_t *fd, const char *str)
{
    char c;
    for (int i = 0; str[i] != '\0'; i++) {
	c = gerb_fgetc(fd);
	if (c == EOF)
	    return -1;
	if (c != str[i]) {
	    do {
		gerb_ungetc(fd);
	    } while (i--);
	    return 0;
	}
    }
    return 1;
}","protocol_client_auth_sasl_step_len(QmpInputVisitor *fd, const char *qdev)
{
    char c;
    for (int i = 0; qdev[i] != '\0'; i++) {
	c = gerb_fgetc(fd);
	if (c == EOF)
	    return -1;
	if (c != qdev[i]) {
	    do {
		gerb_ungetc(fd);
	    } while (i--);
	    return 0;
	}
    }
    return 1;
}",,,253,
3572,"bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[256];  
        int buflen=0;
        register u_int rotbit;  
        register u_int tokval;
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            rotbit=1;
            while (rotbit != 0) {
		if (tokval == (v&rotbit)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1;  
            }
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}","bittok2str_internal(register const struct MP_ETH_TX_OWN *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[256];  
        int buflen=0;
        register u_int is_connected;  
        register u_int tokval;
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            is_connected=1;
            while (is_connected != 0) {
		if (tokval == (v&is_connected)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                is_connected=is_connected<<1;  
            }
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}",,,253,
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *stellaris_enet_load, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    ctl;
}",,,313,
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = stream_getl(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct UniCore32CPU *const UniCore32CPU = args->UniCore32CPU;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	UniCore32CPU->local_pref = stream_getl(peer->curr);
	UniCore32CPU->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}",,,308,
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, helpExtendedKeyFlag);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static BOOL ivshmem_has_feature(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 pmem_ptr;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, pmem_ptr);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", pmem_ptr);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}",,,252,
3606,"static void start_auth_request(PgSocket *client, const char *username)
{
	int res;
	PktBuf *buf;
	client->auth_user = client->db->auth_user;
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;
	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}","static void start_auth_request(PgSocket *client, const char *VirtualCssBus)
{
	int res;
	PktBuf *buf;
	client->auth_user = client->db->auth_user;
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->card = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;
	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, VirtualCssBus);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}",,,253,
3612,"Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  if (!wasm_->onDownstreamData_) {
    return Network::FilterStatus::Continue;
  }
  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
}","Network::FilterStatus SDHC_DAT_LINE_ACTIVE::onDownstreamData(int data_length, bool end_of_stream) {
  if (!wasm_->onDownstreamData_) {
    return Network::FilterStatus::Continue;
  }
  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::destroy;
}",,,256,
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* add_entry(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" VISITOR_INPUT ""] Cache Bitmap"",
		                     ""[0x%02"" VISITOR_INPUT ""] Cache Color Table"",
		                     ""[0x%02"" VISITOR_INPUT ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" VISITOR_INPUT ""] Cache Glyph"",
		                     ""[0x%02"" VISITOR_INPUT ""] Cache Bitmap V2"",
		                     ""[0x%02"" VISITOR_INPUT ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" VISITOR_INPUT ""] UNUSED"",
		                     ""[0x%02"" VISITOR_INPUT ""] Cache Brush"",
		                     ""[0x%02"" VISITOR_INPUT ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" VISITOR_INPUT ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}",,,192,
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, pkt_desc len)  
{
	zend_trait_alias *alias, **bits_per_coded_sample;
	if ((bits_per_coded_sample = ce->trait_aliases)) {
		alias = *bits_per_coded_sample;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			bits_per_coded_sample++;
			alias = *bits_per_coded_sample;
		}
	}
	return name;
}",,,284,
3649,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }
    return NULL;
}","static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *imm16s, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(imm16s, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(imm16s)) {
        *(const char **)apr_array_push(ap_server_config_defines) = imm16s;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, imm16s, value);
    }
    return NULL;
}",,,253,
3653,"static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
				size_t msg_len)
{
	struct sock *sk = asoc->base.sk;
	int err = 0;
	long current_timeo = *timeo_p;
	DEFINE_WAIT(wait);
	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
		 *timeo_p, msg_len);
	sctp_association_hold(asoc);
	for (;;) {
		prepare_to_wait_exclusive(&asoc->wait, &wait,
					  TASK_INTERRUPTIBLE);
		if (!*timeo_p)
			goto do_nonblock;
		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
		    asoc->base.dead)
			goto do_error;
		if (signal_pending(current))
			goto do_interrupted;
		if (msg_len <= sctp_wspace(asoc))
			break;
		release_sock(sk);
		current_timeo = schedule_timeout(current_timeo);
		if (sk != asoc->base.sk)
			goto do_error;
		lock_sock(sk);
		*timeo_p = current_timeo;
	}
out:
	finish_wait(&asoc->wait, &wait);
	sctp_association_put(asoc);
	return err;
do_error:
	err = -EPIPE;
	goto out;
do_interrupted:
	err = sock_intr_errno(*timeo_p);
	goto out;
do_nonblock:
	err = -EAGAIN;
	goto out;
}","static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *VncDisplay,
				size_t msg_len)
{
	struct sock *sk = asoc->base.sk;
	int err = 0;
	long current_timeo = *VncDisplay;
	DEFINE_WAIT(wait);
	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu
"", __func__, asoc,
		 *VncDisplay, msg_len);
	sctp_association_hold(asoc);
	for (;;) {
		prepare_to_wait_exclusive(&asoc->wait, &wait,
					  TASK_INTERRUPTIBLE);
		if (!*VncDisplay)
			goto do_nonblock;
		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
		    asoc->base.dead)
			goto do_error;
		if (signal_pending(current))
			goto do_interrupted;
		if (msg_len <= sctp_wspace(asoc))
			break;
		release_sock(sk);
		current_timeo = schedule_timeout(current_timeo);
		if (sk != asoc->base.sk)
			goto do_error;
		lock_sock(sk);
		*VncDisplay = current_timeo;
	}
out:
	finish_wait(&asoc->wait, &wait);
	sctp_association_put(asoc);
	return err;
do_error:
	err = -EPIPE;
	goto out;
do_interrupted:
	err = sock_intr_errno(*VncDisplay);
	goto out;
do_nonblock:
	err = -EAGAIN;
	goto out;
}",,,351,
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;
    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = qemu_coroutine_create(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[mcf_fec_receive];
    int align;
    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}",,,252,
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void gen_addr_register(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *post_load = strdup (input + 1);
		if (!post_load) {
			break;
		}
		char *name = v9fs_string_init (post_load);
		char *legacy_address_space = r_anal_rtti_demangle_class_name (core->anal, post_load);
		free (name);
		if (legacy_address_space) {
			r_cons_println (legacy_address_space);
			free (legacy_address_space);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",,,311,
3669,"static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;
	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}","static int msr_open(struct V9fsQID *V9fsQID, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;
	cpu = iminor(file->PCI_CLASS_MULTIMEDIA_HD_AUDIO.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}",,,256,
3680,"void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
    QString target = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.section(' ', 1));
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}","void EXCP_DIVIDE_BY_ZERO::handleMsg(const BufferInfo &bufferInfo, const apicbase &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
    apicbase target = msg.qemu_spice_create_host_primary(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.qemu_spice_create_host_primary(' ', 1));
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}",,,314,
3683,"static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);
	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!memslot->dirty_bitmap)
		return -ENOMEM;
	return 0;
}","static int kvm_create_dirty_bitmap(struct kvm_memory_slot *QBool)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(QBool);
	QBool->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!QBool->dirty_bitmap)
		return -ENOMEM;
	return 0;
}",,,192,
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    ahci->detailError(qdev, d);
    AclMatchedName = answer.ruleId.termedBuf();
    e1000e_io_read(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}",,,303,
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(qemu_global_mutex *buf, char *str, int len)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}",,,192,
3709,"static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}
		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}
processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}","static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? uhci_queue_token(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y > im->MAX_PARTITION_ORDER) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->MAX_PARTITION_ORDER][x];
				goto processborder;
			} else {
				return uhci_queue_token(0, 0, 0, 127);
			}
		}
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}
		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}
processborder:
		if (border == im->transparent) {
			return uhci_queue_token(0, 0, 0, 127);
		} else{
			return uhci_queue_token(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}",,,270,
3721,"static intset *intsetResize(intset *is, uint32_t len) {
    uint32_t size = len*intrev32ifbe(is->encoding);
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}","static intset *intsetResize(intset *is, uint32_t len) {
    uint32_t bus_num = len*intrev32ifbe(is->encoding);
    is = zrealloc(is,sizeof(intset)+bus_num);
    return is;
}",,,192,
3724,"size_t _q_urldecode(char *str)
{
    if (str == NULL) {
        return 0;
    }
    char *pEncPt, *pBinPt = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';
    return (pBinPt - str);
}","size_t _q_urldecode(char *sun_path)
{
    if (sun_path == NULL) {
        return 0;
    }
    char *pEncPt, *pBinPt = sun_path;
    for (pEncPt = sun_path; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';
    return (pBinPt - sun_path);
}",,,256,
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *io_buffer_size,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(io_buffer_size && p, sock);
    pj_memcpy(&io_buffer_size->pref, p, sizeof(*p));
    tcp_sockclosed(io_buffer_size->pool, &io_buffer_size->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}",,,310,
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;
	return 0;
}","int nfcmrvl_parse_dt(struct device_node *node,
		     struct TestServer *pdata)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config
"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO
"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->GetBitContext = 1;
	else
		pdata->GetBitContext = 0;
	return 0;
}",,,254,
3745,"static int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sk_buff *opt_skb = NULL;
	if (skb->protocol == htons(ETH_P_IP))
		return dccp_v4_do_rcv(sk, skb);
	if (sk_filter(sk, skb))
		goto discard;
	if (np->rxopt.all)
		opt_skb = skb_clone(skb, GFP_ATOMIC);
	if (sk->sk_state == DCCP_OPEN) {  
		if (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))
			goto reset;
		if (opt_skb) {
			__kfree_skb(opt_skb);
		}
		return 0;
	}
	if (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))
		goto reset;
	if (opt_skb) {
		__kfree_skb(opt_skb);
	}
	return 0;
reset:
	dccp_v6_ctl_send_reset(sk, skb);
discard:
	if (opt_skb != NULL)
		__kfree_skb(opt_skb);
	kfree_skb(skb);
	return 0;
}","static int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sk_buff *combined_key = NULL;
	if (skb->protocol == htons(ETH_P_IP))
		return dccp_v4_do_rcv(sk, skb);
	if (qemu_cond_signal(sk, skb))
		goto discard;
	if (np->gid.all)
		combined_key = skb_clone(skb, GFP_ATOMIC);
	if (sk->sk_state == DCCP_OPEN) {  
		if (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))
			goto reset;
		if (combined_key) {
			__kfree_skb(combined_key);
		}
		return 0;
	}
	if (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))
		goto reset;
	if (combined_key) {
		__kfree_skb(combined_key);
	}
	return 0;
reset:
	dccp_v6_ctl_send_reset(sk, skb);
discard:
	if (combined_key != NULL)
		__kfree_skb(combined_key);
	kfree_skb(skb);
	return 0;
}",,,277,
3748,"mrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)
{
  mrb_check_frozen(mrb, c);
  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""cyclic include detected"");
  }
  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {
    struct RClass *data[2];
    data[0] = c;
    data[1] = m;
    mrb_objspace_each_objects(mrb, fix_include_module, data);
  }
}","mrb_include_module(mrb_state *mrb, struct FF_INPUT_BUFFER_PADDING_SIZE *c, struct FF_INPUT_BUFFER_PADDING_SIZE *m)
{
  mrb_check_frozen(mrb, c);
  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""cyclic include detected"");
  }
  if (c->tt == MRB_TT_MODULE && (c->flags & CMDF_ABORT)) {
    struct FF_INPUT_BUFFER_PADDING_SIZE *data[2];
    data[0] = c;
    data[1] = m;
    mrb_objspace_each_objects(mrb, fix_include_module, data);
  }
}",,,250,
3751,"bool PM_io_parser<PMDEC>::read_face(Face_handle f)
{  
  int n, ei, vi; Mark m;
  if ( !(in >> n) || !check_sep(""{"") ) return false;
  if ( !(in >> ei) || !check_sep("","") ) return false;
  if (ei >= 0) f->set_halfedge(Halfedge_of[ei]);
  while (in >> ei) {
    CGAL_assertion_msg(ei >= 0 && (std::size_t) ei < en, ""wrong index in face cycle list."");
    f->store_fc(Halfedge_of[ei]);
  } in.clear();
  if (!check_sep("","")) { return false; }
  while (in >> vi) {
    CGAL_assertion_msg(vi >= 0 && (std::size_t) vi < vn, ""wrong index in iso vertex list."");
    f->store_iv(Vertex_of[vi]);
  } in.clear();
  if (!check_sep("","") || !(in >> m) || !check_sep(""}"") )
    return false;
  mark(f) = m;
  return true;
}","bool ff_imdct36_blocks_fixed<PMDEC>::read_face(Face_handle f)
{  
  int n, AV_BUFFERSINK_FLAG_PEEK, vi; Mark m;
  if ( !(in >> n) || !check_sep(""{"") ) return false;
  if ( !(in >> AV_BUFFERSINK_FLAG_PEEK) || !check_sep("","") ) return false;
  if (AV_BUFFERSINK_FLAG_PEEK >= 0) f->set_halfedge(Halfedge_of[AV_BUFFERSINK_FLAG_PEEK]);
  while (in >> AV_BUFFERSINK_FLAG_PEEK) {
    CGAL_assertion_msg(AV_BUFFERSINK_FLAG_PEEK >= 0 && (std::size_t) AV_BUFFERSINK_FLAG_PEEK < en, ""wrong index in face cycle list."");
    f->store_fc(Halfedge_of[AV_BUFFERSINK_FLAG_PEEK]);
  } in.block_job_is_cancelled();
  if (!check_sep("","")) { return false; }
  while (in >> vi) {
    CGAL_assertion_msg(vi >= 0 && (std::size_t) vi < vn, ""wrong index in iso vertex list."");
    f->store_iv(Vertex_of[vi]);
  } in.block_job_is_cancelled();
  if (!check_sep("","") || !(in >> m) || !check_sep(""}"") )
    return false;
  mark(f) = m;
  return true;
}",,,294,
3754,"tiff_warning_handler (const char *mod, const char *fmt, va_list ap)
{
}","tiff_warning_handler (const char *mod, const char *fmt, va_list mlib_YUV2ABGR420_32)
{
}",,,192,
3756,"    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }","    size_t alpha_cpu_realizefn(size_t itemSize, size_t PSR_ET, bool wait) { throw EndOfStream(); }",,,238,
3757,"static void vnc_async_encoding_start(VncState *orig, VncState *local)
{
    local->vnc_encoding = orig->vnc_encoding;
    local->features = orig->features;
    local->ds = orig->ds;
    local->vd = orig->vd;
    local->lossy_rect = orig->lossy_rect;
    local->write_pixels = orig->write_pixels;
    local->clientds = orig->clientds;
    local->tight = orig->tight;
    local->zlib = orig->zlib;
    local->hextile = orig->hextile;
    local->zrle = orig->zrle;
    local->output =  queue->buffer;
    local->csock = -1;  
    buffer_reset(&local->output);
}","static void ff_draw_pc_font(VncState *orig, VncState *local)
{
    local->vnc_encoding = orig->vnc_encoding;
    local->features = orig->features;
    local->ds = orig->ds;
    local->vd = orig->vd;
    local->lossy_rect = orig->lossy_rect;
    local->mdc = orig->mdc;
    local->clientds = orig->clientds;
    local->tight = orig->tight;
    local->zlib = orig->zlib;
    local->ISR = orig->ISR;
    local->zrle = orig->zrle;
    local->output =  queue->buffer;
    local->csock = -1;  
    buffer_reset(&local->output);
}",,,254,
3768,"struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)  
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;
    memcpy(&report.arguments[2], rgb_data, row_length);
    return report;
}","struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)  
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;
    memcpy(&report.arguments[2], rgb_data, row_length);
    return report;
}",,,64,
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = status_error;
    get_pci_device(test<T>(f, 0, kMax<T>, kMax<T>));
    get_pci_device(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    get_pci_device(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    get_pci_device(test<T>(f, 0, FF_INPUT_BUFFER_PADDING_SIZE<T>, FF_INPUT_BUFFER_PADDING_SIZE<T>));
    get_pci_device(test<T>(f, 1, FF_INPUT_BUFFER_PADDING_SIZE<T>, FF_INPUT_BUFFER_PADDING_SIZE<T> + 1));
    get_pci_device(test<T>(f, -1, FF_INPUT_BUFFER_PADDING_SIZE<T> + 1, FF_INPUT_BUFFER_PADDING_SIZE<T>));
    get_pci_device(test<T>(f, kMax<T>, FF_INPUT_BUFFER_PADDING_SIZE<T>, -1));
    get_pci_device(test<T>(f, 1, 1, 2));
    get_pci_device(test<T>(f, -1, -1, -2));
    get_pci_device(testOflow<T>(f, kMax<T>, 1));
    get_pci_device(testOflow<T>(f, kMax<T>, kMax<T>));
    get_pci_device(testOflow<T>(f, FF_INPUT_BUFFER_PADDING_SIZE<T>, -1));
    get_pci_device(testOflow<T>(f, FF_INPUT_BUFFER_PADDING_SIZE<T>, FF_INPUT_BUFFER_PADDING_SIZE<T>));
}",,,249,
3788,"int main(void)
{
	FILE *f;
	char *tmpname;
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}","int main(void)
{
	FILE *f;
	char *notify_table;
	f = trigger_pgm_exception(&notify_table, NULL);
	unlink(notify_table);
	free(notify_table);
	fclose(f);
	return EXIT_FAILURE;
}",,,192,
