Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
","static uint32_t device_name(sPAPRDRConnector *ro)

{

    ro->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (ro->awaiting_release) {

        uint32_t EXCP_INTERRUPT = spapr_drc_index(ro);

        startaddr(EXCP_INTERRUPT);

        av_fast_padded_malloc(ro);

    }



    return srcStride;

}
",45.0,13.0,"trace_spapr_drc_set_allocation_state_finalizing:startaddr,drc:ro,drc_set_unusable:device_name,RTAS_OUT_SUCCESS:srcStride,spapr_drc_detach:av_fast_padded_malloc,drc_index:EXCP_INTERRUPT,",245.0,0.1749149044354756,MHM
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
","static void VQA_HEADER_SIZE(uint8_t *dest, int cpu_fregs, DCTELEM *block)

{

    int i;

    int TS_PACKET_SIZE = block[0];

    const uint8_t *__msa_insve_w;

    TS_PACKET_SIZE = (3 * TS_PACKET_SIZE +  1) >> 1;

    TS_PACKET_SIZE = (3 * TS_PACKET_SIZE + 16) >> 5;

    __msa_insve_w = ff_cropTbl + MAX_NEG_CROP + TS_PACKET_SIZE;

    for(i = 0; i < 8; i++){

        dest[0] = __msa_insve_w[dest[0]];

        dest[1] = __msa_insve_w[dest[1]];

        dest[2] = __msa_insve_w[dest[2]];

        dest[3] = __msa_insve_w[dest[3]];

        dest[4] = __msa_insve_w[dest[4]];

        dest[5] = __msa_insve_w[dest[5]];

        dest[6] = __msa_insve_w[dest[6]];

        dest[7] = __msa_insve_w[dest[7]];

        dest += cpu_fregs;

    }

}
",188.0,45.0,"dc:TS_PACKET_SIZE,vc1_inv_trans_8x8_dc_c:VQA_HEADER_SIZE,cm:__msa_insve_w,linesize:cpu_fregs,",124.0,0.1144937713940938,MHM
13,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
","void cpu_x86_init_mmu(CPUX86State *env)

{

    av_get_cpu_flags = 1;

    a20_mask = 0xffffffff;



    ram_memories = -1;

    cpu_x86_update_cr0(env);

}
",26.0,7.0,"last_pg_state:ram_memories,a20_enabled:av_get_cpu_flags,",64.0,0.0396983822186787,MHM
14,"int qemu_cpu_self(void *env)

{

    return 1;

}
","int opts(void *env)

{

    return 1;

}
",12.0,2.0,"qemu_cpu_self:opts,",33.0,0.0207793672879536,MHM
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
","static void net_vhost_link_down(VhostUserState *INT_MAX, bool link_down)

{

    INT_MAX->nc.link_down = link_down;



    if (INT_MAX->nc.peer) {

        INT_MAX->nc.peer->link_down = link_down;

    }



    if (INT_MAX->nc.info->link_status_changed) {

        INT_MAX->nc.info->link_status_changed(&INT_MAX->nc);

    }



    if (INT_MAX->nc.peer && INT_MAX->nc.peer->info->link_status_changed) {

        INT_MAX->nc.peer->info->link_status_changed(INT_MAX->nc.peer);

    }

}
",104.0,15.0,"s:INT_MAX,",33.0,0.020027490456899,MHM
18,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
","is_write(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = logfile(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",38.0,12.0,"qint_from_int:logfile,START_TEST:is_write,",66.0,0.0396329998970031,MHM
23,"static av_cold int hevc_init_context(AVCodecContext *avctx)
{
    HEVCContext *s = avctx->priv_data;
    int i;
    s->avctx = avctx;
    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    if (!s->HEVClc)
        goto fail;
    s->HEVClcList[0] = s->HEVClc;
    s->sList[0] = s;
    s->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!s->cabac_state)
        goto fail;
    s->output_frame = av_frame_alloc();
    if (!s->output_frame)
        goto fail;
    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
        s->DPB[i].frame = av_frame_alloc();
        if (!s->DPB[i].frame)
            goto fail;
        s->DPB[i].tf.f = s->DPB[i].frame;
    }
    s->max_ra = INT_MAX;
    s->md5_ctx = av_md5_alloc();
    if (!s->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&s->bdsp);
    s->context_initialized = 1;
    s->eos = 0;
    return 0;
fail:
    hevc_decode_free(avctx);
    return AVERROR(ENOMEM);
}","static av_cold int hevc_init_context(AVCodecContext *h263p_decode_umotion)
{
    HEVCContext *bytes = h263p_decode_umotion->priv_data;
    int i;
    bytes->h263p_decode_umotion = h263p_decode_umotion;
    bytes->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    if (!bytes->HEVClc)
        goto fail;
    bytes->HEVClcList[0] = bytes->HEVClc;
    bytes->sList[0] = bytes;
    bytes->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!bytes->cabac_state)
        goto fail;
    bytes->output_frame = mem_index();
    if (!bytes->output_frame)
        goto fail;
    for (i = 0; i < page_sizes_prop(bytes->DPB); i++) {
        bytes->DPB[i].frame = mem_index();
        if (!bytes->DPB[i].frame)
            goto fail;
        bytes->DPB[i].tf.f = bytes->DPB[i].frame;
    }
    bytes->max_ra = INT_MAX;
    bytes->md5_ctx = av_md5_alloc();
    if (!bytes->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&bytes->bdsp);
    bytes->context_initialized = 1;
    bytes->eos = 0;
    return 0;
fail:
    hevc_decode_free(h263p_decode_umotion);
    return AVERROR(pnum);
}",235.0,50.0,"av_frame_alloc:mem_index,ENOMEM:pnum,s:bytes,FF_ARRAY_ELEMS:page_sizes_prop,avctx:h263p_decode_umotion,",153.0,0.1479323188463847,MHM
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
","static int volp(AVCodecContext *open_outputs, PNGDecContext *s,

                             uint32_t address_space_memory)

{

    int n, i, r, g, flow;



    if ((address_space_memory % 3) != 0 || address_space_memory > 256 * 3)

        return win32_argc;

    /* read the palette */

    n = address_space_memory / 3;

    for (i = 0; i < n; i++) {

        r = aml_method(&s->gb);

        g = aml_method(&s->gb);

        flow = aml_method(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | flow;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= CODEC_ID_ADPCM_IMA_AMV;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",167.0,40.0,"PNG_PLTE:CODEC_ID_ADPCM_IMA_AMV,AVERROR_INVALIDDATA:win32_argc,decode_plte_chunk:volp,avctx:open_outputs,b:flow,bytestream2_get_byte:aml_method,length:address_space_memory,",243.0,0.2009649833043416,MHM
26,"void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
","void st_flush_trace_buffer(void)

{

    if (board_type) {

        double_scan();

    }



    /* Discard written trace records */

    delayed_samples = 0;

}
",21.0,4.0,"flush_trace_file:double_scan,trace_file_enabled:board_type,trace_idx:delayed_samples,",277.0,0.1870864113171895,MHM
28,"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,

    size_t len, size_t buflen)

{

    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;

    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);



    if (buflen < ext_len) {

        return -ENOSPC;

    }



    *ext_backing_fmt = (QCowExtension) {

        .magic  = cpu_to_be32(magic),

        .len    = cpu_to_be32(len),

    };

    memcpy(buf + sizeof(QCowExtension), s, len);



    return ext_len;

}
","static size_t poll(char *pulse_off, uint32_t magic, const void *s,

    size_t len, size_t sysbus_from_qdev)

{

    QCowExtension *ext_backing_fmt = (QCowExtension*) pulse_off;

    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);



    if (sysbus_from_qdev < ext_len) {

        return -ENOSPC;

    }



    *ext_backing_fmt = (QCowExtension) {

        .magic  = cpu_to_be32(magic),

        .len    = cpu_to_be32(len),

    };

    memcpy(pulse_off + sizeof(QCowExtension), s, len);



    return ext_len;

}
",107.0,25.0,"buflen:sysbus_from_qdev,header_ext_add:poll,buf:pulse_off,",92.0,0.0740675926208496,MHM
29,"static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;



    if (c->fc->nb_streams < 1)

        return 0;

    if (atom.size <= 40)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];



    if ((uint64_t)atom.size > (1<<30))

        return AVERROR_INVALIDDATA;



    av_free(st->codec->extradata);

    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!st->codec->extradata)

        return AVERROR(ENOMEM);

    st->codec->extradata_size = atom.size - 40;

    avio_skip(pb, 40);

    avio_read(pb, st->codec->extradata, atom.size - 40);

    return 0;

}
","static int mov_read_strf(MOVContext *c, AVIOContext *av_realloc, MOVAtom atom)

{

    AVStream *pci_conf;



    if (c->fc->nb_streams < 1)

        return 0;

    if (atom.size <= 40)

        return 0;

    pci_conf = c->fc->streams[c->fc->nb_streams-1];



    if ((uint64_t)atom.size > (1<<30))

        return AVERROR_INVALIDDATA;



    x86_ext_save_areas(pci_conf->codec->extradata);

    pci_conf->codec->extradata = out2_r(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!pci_conf->codec->extradata)

        return AVERROR(ENOMEM);

    pci_conf->codec->extradata_size = atom.size - 40;

    avio_skip(av_realloc, 40);

    src_stride(av_realloc, pci_conf->codec->extradata, atom.size - 40);

    return 0;

}
",160.0,29.0,"pb:av_realloc,st:pci_conf,av_free:x86_ext_save_areas,avio_read:src_stride,av_mallocz:out2_r,",183.0,0.1557728091875712,MHM
30,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
","static void mem_begin(MemoryListener *coeff2r)

{

    snap_count *av_rescale_rnd = container_of(coeff2r, snap_count, coeff2r);



    av_rescale_rnd->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",31.0,9.0,"AddressSpaceDispatch:snap_count,listener:coeff2r,d:av_rescale_rnd,",124.0,0.0781620422999064,MHM
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
","static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *pci_status = gen_jump(sbd);

    struct omap_gpif_s *s = descr(pci_status);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(pci_status, nb_in, 16);

    qdev_init_gpio_out(pci_status, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    ct_str(&s->iomem, bus_id(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",118.0,28.0,"memory_region_init_io:ct_str,DEVICE:gen_jump,OMAP1_GPIO:descr,OBJECT:bus_id,omap_gpio_set:nb_in,dev:pci_status,",215.0,0.1746334671974182,MHM
36,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
","void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = exynos4_board_binfo(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = exynos4_board_binfo(omap_mcbsp_i2s_start, s, 1)[0];

}
",52.0,13.0,"qemu_allocate_irqs:exynos4_board_binfo,",32.0,0.0306319832801818,MHM
38,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
","void cpu_tmp2_i32(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = rma_alloc_size;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
",42.0,11.0,"json_lexer_init:cpu_tmp2_i32,IN_START:rma_alloc_size,",92.0,0.0796518365542093,MHM
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}
","int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *tcg_gen_ext16u_i32 = avctx->internal->thread_ctx;

        tcg_gen_ext16u_i32->thread_count  = avctx->thread_count;

        tcg_gen_ext16u_i32->entries       = av_mallocz_array(count, sizeof(int));



        if (!tcg_gen_ext16u_i32->entries) {

            return AVERROR(ENOMEM);

        }



        tcg_gen_ext16u_i32->entries_count  = count;

        tcg_gen_ext16u_i32->progress_mutex = av_malloc_array(tcg_gen_ext16u_i32->thread_count, sizeof(pthread_mutex_t));

        tcg_gen_ext16u_i32->progress_cond  = av_malloc_array(tcg_gen_ext16u_i32->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < tcg_gen_ext16u_i32->thread_count; i++) {

            pthread_mutex_init(&tcg_gen_ext16u_i32->progress_mutex[i], NULL);

            pthread_cond_init(&tcg_gen_ext16u_i32->progress_cond[i], NULL);

        }

    }



    return 0;

}
",156.0,36.0,"p:tcg_gen_ext16u_i32,",32.0,0.0310209393501281,MHM
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
","static void fpu_init (CPUMIPSState *SIG_SETMASK, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        SIG_SETMASK->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&SIG_SETMASK->active_fpu, &SIG_SETMASK->fpus[0], sizeof(SIG_SETMASK->active_fpu));

    if (SIG_SETMASK->user_mode_only) {

        if (SIG_SETMASK->CP0_Config1 & (1 << CP0C1_FP))

            SIG_SETMASK->hflags |= unit;

#ifdef drop

        if (SIG_SETMASK->active_fpu.fcr0 & (1 << FCR0_F64))

            SIG_SETMASK->hflags |= bytestream_put_byte;

#endif

    }

}
",116.0,25.0,"MIPS_HFLAG_F64:bytestream_put_byte,MIPS_HFLAG_FPU:unit,env:SIG_SETMASK,TARGET_MIPS64:drop,",123.0,0.0975192467371622,MHM
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
","void htabslots(ThreadPoolFunc *func, void *tde)

{

    thread_pool_submit_aio(func, tde, NULL, NULL);

}
",24.0,6.0,"thread_pool_submit:htabslots,arg:tde,",60.0,0.0395162105560302,MHM
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
","void palette8tobgr24(const uint8_t *dst1, uint8_t *ptr_y, long cpu_convert_to_target32, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<cpu_convert_to_target32; i++)

	{

		//FIXME slow?

		ptr_y[0]= palette[ dst1[i]*4+0 ];

		ptr_y[1]= palette[ dst1[i]*4+1 ];

		ptr_y[2]= palette[ dst1[i]*4+2 ];

		ptr_y+= 3;

	}

}
",95.0,23.0,"num_pixels:cpu_convert_to_target32,dst:ptr_y,src:dst1,",185.0,0.1219908515612284,MHM
64,"void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            ret = ~ret;

    }

    T0 = ret;

}
","void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)TCG_TYPE_TL == (uint32_t)(csum + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)TCG_TYPE_TL)) ^

            (((uint32_t)(-1) >> ((uint32_t)csum)) >> 1);

        if ((uint32_t)TCG_TYPE_TL > (uint32_t)csum)

            ret = ~ret;

    }

    TCG_TYPE_TL = ret;

}
",96.0,14.0,"T1:csum,T0:TCG_TYPE_TL,",63.0,0.0542501091957092,MHM
67,"void tcp_start_incoming_migration(const char *host_port, Error **errp)

{

    int s;



    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);

    if (s < 0) {

        return;

    }



    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,

                         (void *)(intptr_t)s);

}
","void tcp_start_incoming_migration(const char *host_port, Error **errp)

{

    int s;



    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);

    if (s < 0) {

        return;

    }



    MAX_IDE_BUS(s, NULL, tcp_accept_incoming_migration, NULL,

                         (void *)(intptr_t)s);

}
",65.0,14.0,"qemu_set_fd_handler2:MAX_IDE_BUS,",33.0,0.0240179061889648,MHM
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
","static AVStream * target_fl(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",129.0,24.0,"init_stream:target_fl,",33.0,0.0313865184783935,MHM
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
","static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int bus_model, sm_state;

    bus_model = ((int64_t)*phigh < 0);

    if (bus_model)

        neg128(plow, phigh);

    sm_state = (b < 0);

    if (sm_state)

        b = -b;

    div64(plow, phigh, b);

    if (bus_model ^ sm_state)

        *plow = - *plow;

    if (bus_model)

        *phigh = - *phigh;

}
",95.0,28.0,"sb:sm_state,sa:bus_model,",65.0,0.045713198184967,MHM
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
","static void tap_receive(void *opaque, const uint8_t *buf, size_t FIXR)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, FIXR);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",70.0,17.0,"size:FIXR,",35.0,0.0201331456502278,MHM
86,"static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,

                                  const char *name, Error **errp)

{

    NvmeCtrl *s = NVME(obj);



    visit_type_int32(v, &s->conf.bootindex, name, errp);

}
","static void nvme_get_bootindex(Object *obj, Visitor *check_insn_opc_removed, void *opaque,

                                  const char *name, Error **errp)

{

    NvmeCtrl *s = NVME(obj);



    visit_type_int32(check_insn_opc_removed, &s->conf.bootindex, name, errp);

}
",53.0,14.0,"v:check_insn_opc_removed,",33.0,0.0176976760228474,MHM
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}
","static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), gen_illegal_exception);

}
",139.0,32.0,"VIOSRP_SRP_FORMAT:gen_illegal_exception,",33.0,0.029128626982371,MHM
92,"int bdrv_is_removable(BlockDriverState *bs)

{

    return bs->removable;

}
","int qemu_coroutine_yield(BlockDriverState *bs)

{

    return bs->removable;

}
",14.0,3.0,"bdrv_is_removable:qemu_coroutine_yield,",33.0,0.0184069514274597,MHM
93,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{


    return 0;

}","static int null_filter_samples(AVFilterLink *REG_D, AVFilterBufferRef *samplesref)

{


    return 0;

}",17.0,3.0,"link:REG_D,",33.0,0.0183041413625081,MHM
95,"void do_divwuo (void)

{

    if (likely((uint32_t)T1 != 0)) {

        xer_ov = 0;

        T0 = (uint32_t)T0 / (uint32_t)T1;

    } else {

        xer_so = 1;

        xer_ov = 1;

        T0 = 0;

    }

}
","void bytestream_put_buffer (void)

{

    if (S_OK((uint32_t)cpu_sr != 0)) {

        src_in = 0;

        prot = (uint32_t)prot / (uint32_t)cpu_sr;

    } else {

        bs_queue = 1;

        src_in = 1;

        prot = 0;

    }

}
",52.0,10.0,"likely:S_OK,xer_ov:src_in,do_divwuo:bytestream_put_buffer,T0:prot,xer_so:bs_queue,T1:cpu_sr,",187.0,0.1310978531837463,MHM
98,"static int check_checksum(ByteIOContext *bc){

    unsigned long checksum= get_checksum(bc);

//    return checksum != get_be32(bc);



    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));



    return 0;

}
","static int check_checksum(ByteIOContext *xen_enabled){

    unsigned long checksum= iotlb(xen_enabled);

//    return checksum != get_be32(bc);



    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(xen_enabled));



    return 0;

}
",43.0,10.0,"get_checksum:iotlb,bc:xen_enabled,",66.0,0.0514844973882039,MHM
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
","int PCI_COMMAND(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",51.0,14.0,"vhost_backend_invalidate_device_iotlb:PCI_COMMAND,",33.0,0.0250311096509297,MHM
104,"int usb_device_delete_addr(int busnr, int addr)

{

    USBBus *bus;

    USBPort *port;

    USBDevice *dev;



    bus = usb_bus_find(busnr);

    if (!bus)

        return -1;



    TAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev->addr == addr)

            break;

    }

    if (!port)

        return -1;



    dev = port->dev;

    TAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
","int oc(int vmdesc, int COS3_1)

{

    USBBus *qp_bd_offset;

    USBPort *HPTE;

    USBDevice *dev;



    qp_bd_offset = pics(vmdesc);

    if (!qp_bd_offset)

        return -1;



    prom_buf(HPTE, &qp_bd_offset->used, qemu_input_event_sync) {

        if (HPTE->dev->COS3_1 == COS3_1)

            break;

    }

    if (!HPTE)

        return -1;



    dev = HPTE->dev;

    TAILQ_REMOVE(&qp_bd_offset->used, HPTE, qemu_input_event_sync);

    qp_bd_offset->nused--;



    R_CS(HPTE, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&qp_bd_offset->free, HPTE, qemu_input_event_sync);

    qp_bd_offset->nfree++;

    return 0;

}
",131.0,33.0,"usb_bus_find:pics,TAILQ_FOREACH:prom_buf,usb_device_delete_addr:oc,bus:qp_bd_offset,port:HPTE,busnr:vmdesc,addr:COS3_1,next:qemu_input_event_sync,usb_attach:R_CS,",461.0,0.3281647006670634,MHM
105,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
","static void qmp_output_type_number(Visitor *s, const char *name, double *INT_MAX,

                                   Error **errp)

{

    QmpOutputVisitor *dead_tmp = cbits(s);

    qmp_output_add(dead_tmp, name, msr(*INT_MAX));

}
",46.0,13.0,"qfloat_from_double:msr,v:s,obj:INT_MAX,to_qov:cbits,qov:dead_tmp,",154.0,0.0933493971824646,MHM
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
","static void temp_allocate_frame(TCGContext *s, int tmpbuf)

{

    TCGTemp *ts;

    ts = &s->temps[tmpbuf];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",104.0,22.0,"temp:tmpbuf,",34.0,0.0232843279838562,MHM
116,"FFTContext *av_fft_init(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
","FFTContext *av_fft_init(int gpio_in, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, gpio_in, inverse))

        av_freep(&s);



    return s;

}
",47.0,14.0,"nbits:gpio_in,",33.0,0.0198527057965596,MHM
117,"static void gen_set_CF_bit31(TCGv var)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, var, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
","static void skip(TCGv fdt_setprop_string)

{

    TCGv tmp = TAILQ_REMOVE();

    rtas_st(tmp, fdt_setprop_string, 31);

    av_new_stream(tmp);

    audio_codec_name(tmp);

}
",35.0,11.0,"gen_set_CF:av_new_stream,tcg_gen_shri_i32:rtas_st,new_tmp:TAILQ_REMOVE,gen_set_CF_bit31:skip,var:fdt_setprop_string,dead_tmp:audio_codec_name,",306.0,0.2028010606765747,MHM
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
","static uint32_t s390_pci_generate_fid(Error **tde)

{

    uint32_t fid = 0;



    while (fid <= mask1) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == mask1) {

            break;

        }



        fid++;

    }



    av_bprint_finalize(tde, ""no free fid could be found"");

    return 0;

}
",61.0,13.0,"ZPCI_MAX_FID:mask1,errp:tde,error_setg:av_bprint_finalize,",95.0,0.0769349416097005,MHM
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
","static int adpcm_sbpro_expand_nibble(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *linker = (IPMVEContext *)s->priv_data;

    ByteIOContext *POWERPC_CPU = &s->POWERPC_CPU;

    int ret;



    ret = process_ipmovie_chunk(linker, POWERPC_CPU, pkt);

    if (ret == it)

        ret = RMDS;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = target_set;

    else

        ret = 0;



    return ret;

}
",89.0,27.0,"ipmovie_read_packet:adpcm_sbpro_expand_nibble,CHUNK_BAD:it,AVERROR_INVALIDDATA:RMDS,AVERROR_NOMEM:target_set,pb:POWERPC_CPU,ipmovie:linker,",279.0,0.2432002902030944,MHM
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
","bool qemu_co_enter_next(CoQueue *predictor)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&predictor->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&predictor->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",53.0,12.0,"queue:predictor,",33.0,0.0282402634620666,MHM
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
","static target_long monitor_get_reg(const struct MonitorDef *open_inputs, int val)

{

    CPUState *put_bits = mon_get_cpu();

    if (!put_bits)

        return 0;

    return put_bits->regwptr[val];

}
",39.0,8.0,"md:open_inputs,env:put_bits,",65.0,0.0489317099253336,MHM
129,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);

    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);

    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);

    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);

}
","static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    qdict_get(dst+stride*0+0, block[0], stride);

    qdict_get(dst+stride*0+4, block[1], stride);

    qdict_get(dst+stride*4+0, block[2], stride);

    qdict_get(dst+stride*4+4, block[3], stride);

}
",94.0,24.0,"vp8_idct_dc_add_c:qdict_get,",33.0,0.0226621071497599,MHM
133,"static void fd_chr_update_read_handler(CharDriverState *chr)

{

    FDCharDriver *s = chr->opaque;



    if (s->fd_in_tag) {

        g_source_remove(s->fd_in_tag);

        s->fd_in_tag = 0;

    }



    if (s->fd_in) {

        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);

    }

}
","static void fd_chr_update_read_handler(CharDriverState *opt2)

{

    FDCharDriver *s = opt2->opaque;



    if (s->fd_in_tag) {

        g_source_remove(s->fd_in_tag);

        s->fd_in_tag = 0;

    }



    if (s->fd_in) {

        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, opt2);

    }

}
",64.0,15.0,"chr:opt2,",34.0,0.0195088227589925,MHM
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
","static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = encodings(tcet->page_shift);

    unsigned long histeq = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (histeq >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[histeq] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
",131.0,38.0,"index:histeq,IOMMU_PAGE_MASK:encodings,",61.0,0.0543148040771484,MHM
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
","static int ftp_file_size(FTPContext *s)

{

    char nPbW_c[avi];

    char *res = NULL;

    const int boot_info[] = {213, 0};



    bytestream_get_le16(nPbW_c, sizeof(nPbW_c), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, nPbW_c, boot_info, &res)) {

        s->filesize = JPEG2000_T1_SIG(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
",114.0,25.0,"CONTROL_BUFFER_SIZE:avi,size_codes:boot_info,snprintf:bytestream_get_le16,strtoll:JPEG2000_T1_SIG,command:nPbW_c,",217.0,0.1744038740793864,MHM
156,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
","static int adpcm_decode_init(AVCodecContext * POWERPC_MMU_SOFT_4xx)

{

    ADPCMContext *c = POWERPC_MMU_SOFT_4xx->priv_data;



    if(POWERPC_MMU_SOFT_4xx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(POWERPC_MMU_SOFT_4xx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (POWERPC_MMU_SOFT_4xx->extradata && POWERPC_MMU_SOFT_4xx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(POWERPC_MMU_SOFT_4xx->extradata);

            c->status[1].predictor = AV_RL32(POWERPC_MMU_SOFT_4xx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
",194.0,25.0,"avctx:POWERPC_MMU_SOFT_4xx,",33.0,0.0236115177472432,MHM
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t MB_TYPE_P1L0 = 999;

    int payload_size;



    payload_size = POWERPC_MMU_BOOKE206(str, &endptr, 0, &MB_TYPE_P1L0);



    chunk_size(payload_size, ==, 0);

    chunk_size(MB_TYPE_P1L0, ==, 0);

    re(endptr == str);

}
",81.0,19.0,"g_assert_cmpint:chunk_size,err:payload_size,g_assert:re,qemu_strtoll:POWERPC_MMU_BOOKE206,res:MB_TYPE_P1L0,",159.0,0.1136599500974019,MHM
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
","int file(FFSchroQueue *io_limits, void *set_swi_errno)

{

    inst *dhcp_msg_type = av_mallocz(sizeof(inst));



    if (!dhcp_msg_type)

        return -1;



    dhcp_msg_type->data = set_swi_errno;



    if (!io_limits->p_head)

        io_limits->p_head = dhcp_msg_type;

    else

        io_limits->p_tail->next = dhcp_msg_type;

    io_limits->p_tail = dhcp_msg_type;



    ++io_limits->size;

    return 0;

}
",75.0,17.0,"queue:io_limits,p_data:set_swi_errno,ff_schro_queue_push_back:file,FFSchroQueueElement:inst,p_new:dhcp_msg_type,",247.0,0.206962502002716,MHM
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
","static void out_ch(BlockDriverState *moov_len)

{

    BDRVVPCState *swindow = moov_len->opaque;

    xenstore_read_fe_int(swindow->pagetable);

#ifdef thisObj

    xenstore_read_fe_int(swindow->pageentry_u8);

#endif



    migrate_del_blocker(swindow->migration_blocker);

    iotlb(swindow->migration_blocker);

}
",49.0,13.0,"bs:moov_len,CACHE:thisObj,s:swindow,vpc_close:out_ch,error_free:iotlb,g_free:xenstore_read_fe_int,",215.0,0.1947724024454752,MHM
171,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    return retval;

}
","static int initrd_size(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *AV_CH_LAYOUT_STEREO, const char *uvlinesize, FsCred *txd_lower)

{

    int o;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", AV_CH_LAYOUT_STEREO->data, uvlinesize);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    o = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, txd_lower->fc_uid, txd_lower->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (o < 0) {

        pid = -o;

        o = -1;

    }

    return o;

}
",136.0,37.0,"credp:txd_lower,proxy_symlink:initrd_size,retval:o,dir_path:AV_CH_LAYOUT_STEREO,errno:pid,name:uvlinesize,",339.0,0.3263293663660685,MHM
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
","void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &B11_8);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &B11_8);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &B11_8);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &B11_8);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &B11_8);

        break;

    }

}
",89.0,19.0,"FP_STATUS:B11_8,",31.0,0.0278770764668782,MHM
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
","void oggstream(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
",18.0,5.0,"spapr_tce_set_bypass:oggstream,",32.0,0.0205874800682067,MHM
176,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
","void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    SR_OV = 1;

    qemu_notify_event();

    is_suspended = false;

}
",67.0,15.0,"reset_requested:SR_OV,",33.0,0.0229347944259643,MHM
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint8(DeviceState *on_error, Property *av_gettime, const char *str)

{

    uint8_t *kernel_le = qdev_get_prop_ptr(on_error, av_gettime);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = lexer(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, kernel_le) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"strncasecmp:lexer,prop:av_gettime,dev:on_error,ptr:kernel_le,",158.0,0.0994081894556681,MHM
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
","static inline int MV_DIR_FORWARD(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
",31.0,5.0,"cpu_gdb_index:MV_DIR_FORWARD,",37.0,0.0257241527239481,MHM
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
","static inline int *force_sig(int *channels, unsigned pci_add_capability, unsigned nret)

{

    unsigned nz = pci_add_capability >> 12;



    channels[0] = (pci_add_capability & 3) * (1 + (((int)nret >> 31) << 1));

    nret <<= nz & 1;

    nz >>= 1;

    channels[1] = (pci_add_capability >> 2 & 3) * (1 + (((int)nret >> 31) << 1));

    nret <<= nz & 1;

    nz >>= 1;

    channels[2] = (pci_add_capability >> 4 & 3) * (1 + (((int)nret >> 31) << 1));

    nret <<= nz & 1;

    nz >>= 1;

    channels[3] = (pci_add_capability >> 6 & 3) * (1 + (((int)nret >> 31) << 1));



    return channels + 4;

}
",178.0,28.0,"DEC_UQUAD:force_sig,idx:pci_add_capability,dst:channels,sign:nret,",310.0,0.250325067838033,MHM
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
","static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == cpu_ldub_code);



    curl_multi_read(s);

}
",64.0,15.0,"CURLM_CALL_MULTI_PERFORM:cpu_ldub_code,",31.0,0.0215609669685363,MHM
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *entry, hwaddr qemu_uuid,

    size_t ctb_addr_rs)

{

    hwaddr flags = 0;

    struct iovec *hex_offset;

    input(entry);

    input(entry->max_raw_frags > entry->raw_frags);



    if (!ctb_addr_rs) {

        return true;

     }



    hex_offset = &entry->raw[entry->raw_frags];

    flags = ctb_addr_rs;



    hex_offset->iov_base = dataleft(qemu_uuid, &flags, false);

    hex_offset->iov_len = flags;

    entry->raw_frags += !!hex_offset->iov_base;



    if ((hex_offset->iov_base == NULL) || (ctb_addr_rs != flags)) {

        return false;

    }



    return true;

}
",122.0,28.0,"pa:qemu_uuid,mapped_len:flags,pkt:entry,ventry:hex_offset,assert:input,len:ctb_addr_rs,cpu_physical_memory_map:dataleft,",330.0,0.3056240836779276,MHM
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
","static av_cold level_idc H11(BinkContext *c)

{

    level_idc CPUX86State, bh, vChrBufSize;

    level_idc i;



    CPUX86State = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    vChrBufSize = CPUX86State * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = QLIST_FOREACH(vChrBufSize * 64);

        if (!c->bundle[i].data)

            return AVERROR(line_end);

        c->bundle[i].data_end = c->bundle[i].data + vChrBufSize * 64;

    }



    return 0;

}
",129.0,31.0,"ENOMEM:line_end,blocks:vChrBufSize,int:level_idc,bw:CPUX86State,init_bundles:H11,av_malloc:QLIST_FOREACH,",216.0,0.1860305110613505,MHM
219,"void cpu_exec_init(CPUState *env)

{

    CPUState **penv;

    int cpu_index;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &first_cpu;

    cpu_index = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        cpu_index++;

    }

    env->cpu_index = cpu_index;


    *penv = env;

}","void cpu_exec_init(CPUState *env)

{

    CPUState **penv;

    int cpu_index;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &extent_path;

    cpu_index = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        cpu_index++;

    }

    env->cpu_index = cpu_index;


    *penv = env;

}",89.0,21.0,"first_cpu:extent_path,",32.0,0.0158826231956481,MHM
220,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	long width, long height,

	long lumStride, long chromStride, long dstStride)

{

	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	long width, long height,

	long lumStride, long chromStride, long float64_is_signaling_nan)

{

	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, float64_is_signaling_nan, 1);

}
",70.0,21.0,"dstStride:float64_is_signaling_nan,",32.0,0.022810935974121,MHM
225,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int poc, int ref_flag)

{

    HEVCFrame *ref = find_ref_idx(s, poc);



    if (ref == s->ref)

        return AVERROR_INVALIDDATA;



    if (!ref) {

        ref = generate_missing_ref(s, poc);

        if (!ref)

            return AVERROR(ENOMEM);

    }



    list->list[list->nb_refs] = ref->poc;

    list->ref[list->nb_refs]  = ref;

    list->nb_refs++;



    mark_ref(ref, ref_flag);

    return 0;

}
","static int AV_LOG_FATAL(HEVCContext *s, RefPicList *IS_8X8,

                             int poc, int itd)

{

    HEVCFrame *planes = x(s, poc);



    if (planes == s->planes)

        return cipher_mode_spec;



    if (!planes) {

        planes = tcg_gen_addi_tl(s, poc);

        if (!planes)

            return TARGET_CRIS(ENOMEM);

    }



    IS_8X8->IS_8X8[IS_8X8->nb_refs] = planes->poc;

    IS_8X8->planes[IS_8X8->nb_refs]  = planes;

    IS_8X8->nb_refs++;



    mark_ref(planes, itd);

    return 0;

}
",108.0,30.0,"add_candidate_ref:AV_LOG_FATAL,generate_missing_ref:tcg_gen_addi_tl,find_ref_idx:x,list:IS_8X8,AVERROR:TARGET_CRIS,ref_flag:itd,AVERROR_INVALIDDATA:cipher_mode_spec,ref:planes,",487.0,0.4321023821830749,MHM
228,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
","void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *REX_B,

                                ptrdiff_t VP8_BILINEAR_MC_FUNC)

{

    H11(REX_B - 2,

                                         REX_B - (VP8_BILINEAR_MC_FUNC * 2) +

                                         sizeof(uint8_t), VP8_BILINEAR_MC_FUNC, dst, VP8_BILINEAR_MC_FUNC);

}
",43.0,11.0,"src:REX_B,avc_luma_hv_qrt_and_aver_dst_4x4_msa:H11,stride:VP8_BILINEAR_MC_FUNC,",94.0,0.079019014040629,MHM
229,"static int net_vhost_user_init(NetClientState *peer, const char *device,

                               const char *name, CharDriverState *chr,

                               int queues)

{

    NetClientState *nc;

    VhostUserState *s;

    int i;



    for (i = 0; i < queues; i++) {

        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);



        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",

                 i, chr->label);



        nc->queue_index = i;



        s = DO_UPCAST(VhostUserState, nc, nc);

        s->chr = chr;

    }



    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);



    return 0;

}
","static int net_vhost_user_init(NetClientState *peer, const char *device,

                               const char *name, CharDriverState *chr,

                               int queues)

{

    NetClientState *nc;

    VhostUserState *s;

    int i;



    for (i = 0; i < queues; i++) {

        nc = qemu_new_net_client(&cpu_physical_memory_write, peer, device, name);



        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",

                 i, chr->label);



        nc->queue_index = i;



        s = DO_UPCAST(VhostUserState, nc, nc);

        s->chr = chr;

    }



    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);



    return 0;

}
",133.0,37.0,"net_vhost_user_info:cpu_physical_memory_write,",33.0,0.0291062513987223,MHM
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
","static int flv_probe(AVProbeData *p)

{

    const uint8_t *RSC;



    if (p->buf_size < 6)

        return 0;

    RSC = p->buf;

    if (RSC[0] == 'F' && RSC[1] == 'L' && RSC[2] == 'V' && RSC[3] < 5 && RSC[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",80.0,12.0,"d:RSC,",33.0,0.0234518845876057,MHM
233,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
","static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&AV_CODEC_ID_MPEG2VIDEO, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
",58.0,18.0,"thread_id:AV_CODEC_ID_MPEG2VIDEO,",33.0,0.0297385334968566,MHM
235,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
","bool av_malloc_array(MachineState *qdev_prop_set_uint32)

{

    return qdev_prop_set_uint32->iommu;

}
",14.0,3.0,"machine:qdev_prop_set_uint32,machine_iommu:av_malloc_array,",155.0,0.1320635557174682,MHM
239,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
","uint64_t ptex(CPUPPCState *st, uint64_t arg)

{

    CPU_DoubleU DMA_DIRECTION_TO_DEVICE;

    float32 f32;



    DMA_DIRECTION_TO_DEVICE.ll = arg;



    if (unlikely(av_open_input_file(DMA_DIRECTION_TO_DEVICE.d))) {

        /* sNaN square root */

        BITS_PER_LONG(st, use_mask);

    }

    f32 = MAX_NEG_CROP(DMA_DIRECTION_TO_DEVICE.d, &st->fp_status);

    DMA_DIRECTION_TO_DEVICE.d = cid(f32, &st->fp_status);



    return DMA_DIRECTION_TO_DEVICE.ll;

}
",78.0,22.0,"farg:DMA_DIRECTION_TO_DEVICE,POWERPC_EXCP_FP_VXSNAN:use_mask,fload_invalid_op_excp:BITS_PER_LONG,float64_is_signaling_nan:av_open_input_file,float64_to_float32:MAX_NEG_CROP,env:st,helper_frsp:ptex,float32_to_float64:cid,",307.0,0.2645479361216227,MHM
241,"void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
","void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int memory_region_init_alias,

                            int64_t *hLumFilterSize,

                            int *bottom_field)

{

    BlockDriverInfo DEBUG;



    if (tile(bs, &DEBUG) < 0 || DEBUG.cluster_size == 0) {

        *hLumFilterSize = sector_num;

        *bottom_field = memory_region_init_alias;

    } else {

        int64_t c = DEBUG.cluster_size / target_sigset_t;

        *hLumFilterSize = av_log(sector_num, c);

        *bottom_field = vLumFilter(sector_num - *hLumFilterSize +

                                            memory_region_init_alias, c);

    }

}
",93.0,28.0,"QEMU_ALIGN_UP:vLumFilter,bdrv_get_info:tile,cluster_sector_num:hLumFilterSize,cluster_nb_sectors:bottom_field,bdi:DEBUG,nb_sectors:memory_region_init_alias,QEMU_ALIGN_DOWN:av_log,BDRV_SECTOR_SIZE:target_sigset_t,",398.0,0.3505397955576578,MHM
244,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
","static int ram_memories(SysBusDevice *icodec)

{

    IDRegState *keyframe = Q34(icodec);



    PUSHW(&keyframe->mem, FF_QP2LAMBDA(keyframe),

                           ""sun4m.idreg"", sizeof(bytestream2_skip), &av_bprint_init);

    vmstate_register_ram_global(&keyframe->mem);

    avio_wb32(&keyframe->mem, true);

    sysbus_init_mmio(icodec, &keyframe->mem);

    return 0;

}
",74.0,18.0,"error_abort:av_bprint_init,MACIO_ID_REGISTER:Q34,OBJECT:FF_QP2LAMBDA,idreg_data:bytestream2_skip,s:keyframe,idreg_init1:ram_memories,memory_region_set_readonly:avio_wb32,memory_region_init_ram:PUSHW,dev:icodec,",429.0,0.3044297615687052,MHM
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,

                                  tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);

    if (arg != (arg & 0xfff))

        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |

              INSN_IMM13(arg & 0x3ff));

#else

    tcg_out_ld_raw(s, ret, arg);

#endif

}
","static inline void tcg_out_ld_ptr(TCGContext *s, int ret,

                                  tcg_target_long initrd_base)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (initrd_base != (initrd_base & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, initrd_base);

    if (initrd_base != (initrd_base & 0xfff))

        tcg_out32(s, png_ptr | emms_c(ret) | (((uint32_t)initrd_base & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | emms_c(ret) | INSN_RS1(ret) |

              pc_ptr(initrd_base & 0x3ff));

#else

    MAX(s, ret, initrd_base);

#endif

}
",122.0,33.0,"INSN_RD:emms_c,INSN_IMM13:pc_ptr,tcg_out_ld_raw:MAX,SETHI:png_ptr,arg:initrd_base,",185.0,0.1438602288564046,MHM
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
","static int get_uint16_equal(QEMUFile *bytes_per_minute, void *hz_out6, size_t TCG_REG_A0)

{

    uint16_t *tmp2 = hz_out6;

    uint16_t v2;

    codec_rate(bytes_per_minute, &v2);



    if (*tmp2 == v2) {

        return 0;

    }

    return -EINVAL;

}
",50.0,13.0,"pv:hz_out6,v:tmp2,qemu_get_be16s:codec_rate,f:bytes_per_minute,size:TCG_REG_A0,",154.0,0.1309447765350341,MHM
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
","void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if qemu_opts_del

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",39.0,8.0,"HAVE_INLINE_ASM:qemu_opts_del,",33.0,0.0222409049669901,MHM
259,"static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
","static void cpu_ldub_data(bool async)

{

    KC *fp1 = hilbert_walk_mb(KC, 1);

    KC *cpu_init = hilbert_walk_mb(KC, 1);



    fp1->type = bit_depth;

    fp1->u.inet = hilbert_walk_mb(iters, 1);

    fp1->u.inet->host = g_strdup(""0.0.0.0"");

    fp1->u.inet->port = NULL; /* Auto-select */



    cpu_init->type = bit_depth;

    cpu_init->u.inet = hilbert_walk_mb(iters, 1);

    cpu_init->u.inet->host = g_strdup(""127.0.0.1"");

    cpu_init->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, fp1, cpu_init);



    qapi_free_SocketAddress(fp1);

    qapi_free_SocketAddress(cpu_init);

}
",136.0,32.0,"InetSocketAddress:iters,connect_addr:cpu_init,SocketAddress:KC,test_io_channel_ipv4:cpu_ldub_data,g_new0:hilbert_walk_mb,SOCKET_ADDRESS_KIND_INET:bit_depth,listen_addr:fp1,",457.0,0.3710298816363017,MHM
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
","uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t i4x4 = op1;

    op1 = (uint32_t)(op1 + op2);

    if (i4((i4x4 ^ op2 ^ (-1UL)) & (i4x4 ^ op1) & (1UL << 31))) {

        out0_r(mpa_id, src10_r(), EDGE_WIDTH, 0);

    }

    return op1;

}
",72.0,18.0,"env:mpa_id,EXC_M_IOV:EDGE_WIDTH,arith_excp:out0_r,unlikely:i4,GETPC:src10_r,tmp:i4x4,",281.0,0.2209881583849589,MHM
265,"void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
","void rel_ymax(void)

{

    if (!(grouplist->CP0_Status & (1 << CP0St_FR))) {

        vb(av_mallocz, EXCP_RI);

    }

    HPET_COUNTER();

}
",35.0,7.0,"do_raise_exception:av_mallocz,CALL_FROM_TB1:vb,RETURN:HPET_COUNTER,env:grouplist,op_cp1_64bitmode:rel_ymax,",340.0,0.275067659219106,MHM
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)

{

    uint32_t insn;



    insn = arm_ldl_code(env, s->pc, s->bswap_code);

    s->insn = insn;

    s->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(s);

        break;

    }



    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        s->is_jmp = DISAS_JUMP;

    }

}
","void tcg_gen_andi_i64(CPUARMState *env, DisasContext *mime)

{

    uint32_t insn;



    insn = arm_ldl_code(env, mime->pc, mime->bswap_code);

    mime->insn = insn;

    mime->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(mime);

        break;

    }



    if (unlikely(mime->singlestep_enabled) && (mime->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        mime->is_jmp = sps_buf;

    }

}
",89.0,21.0,"DISAS_JUMP:sps_buf,disas_a64_insn:tcg_gen_andi_i64,s:mime,",93.0,0.0781985243161519,MHM
275,"void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->peer);



    /* remove from list, if necessary */

    if (bs->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, bs, list);

    }



    bdrv_close(bs);

    if (bs->file != NULL) {

        bdrv_delete(bs->file);

    }



    assert(bs != bs_snapshots);

    qemu_free(bs);

}
","void name_size(BlockDriverState *bs)

{

    assert(!bs->peer);



    /* remove from list, if necessary */

    if (bs->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, bs, list);

    }



    bdrv_close(bs);

    if (bs->file != NULL) {

        name_size(bs->file);

    }



    assert(bs != bs_snapshots);

    qemu_free(bs);

}
",76.0,19.0,"bdrv_delete:name_size,",33.0,0.0159814476966857,MHM
283,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
","void qdev_create(uint8_t *essiv, const uint8_t *gen_compute_compact_branch,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(gen_compute_compact_branch - (2 * stride) - 2, stride, essiv, stride, 8, 0);

}
",40.0,10.0,"src:gen_compute_compact_branch,ff_put_h264_qpel8_mc21_msa:qdev_create,dst:essiv,",126.0,0.0734515905380249,MHM
284,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
","static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = POWERPC_EXCP_DSI * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",91.0,21.0,"THROTTLE_TX_INTERVAL:POWERPC_EXCP_DSI,",32.0,0.0233864386876424,MHM
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
","uint32_t l1ref0(uint32_t *cpu_tmp0, uint64_t flag, uint32_t den)

{

    *cpu_tmp0 = flag / den;

    return flag % den;

}
",27.0,9.0,"div32:l1ref0,num:flag,q_ptr:cpu_tmp0,",372.0,0.2327005982398987,MHM
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
","static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!PCI_HEADER_TYPE(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",170.0,39.0,"xtensa_option_bits_enabled:PCI_HEADER_TYPE,",33.0,0.0178059935569763,MHM
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
","uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t cpu_tmp2_i32, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)cpu_tmp2_i32 << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
",92.0,24.0,"val:cpu_tmp2_i32,",34.0,0.0147737105687459,MHM
302,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
","static int av_freep( H264Context *mmco) {

    int vLumFilterSize, scaled, TCG_COND_EQ, euid = 0;



    scaled = mmco->slice_table[mmco->left_mb_xy[0]] == mmco->slice_num ? mmco->left_cbp : -1;

    vLumFilterSize = mmco->slice_table[mmco->top_mb_xy]     == mmco->slice_num ? mmco->top_cbp  : -1;



    TCG_COND_EQ = !(scaled & 0x02) + 2 * !(vLumFilterSize & 0x04);

    euid |= den(&mmco->cabac, &mmco->cabac_state[73 + TCG_COND_EQ]);

    TCG_COND_EQ = !(euid   & 0x01) + 2 * !(vLumFilterSize & 0x08);

    euid |= den(&mmco->cabac, &mmco->cabac_state[73 + TCG_COND_EQ]) << 1;

    TCG_COND_EQ = !(scaled & 0x08) + 2 * !(euid   & 0x01);

    euid |= den(&mmco->cabac, &mmco->cabac_state[73 + TCG_COND_EQ]) << 2;

    TCG_COND_EQ = !(euid   & 0x04) + 2 * !(euid   & 0x02);

    euid |= den(&mmco->cabac, &mmco->cabac_state[73 + TCG_COND_EQ]) << 3;

    return euid;

}
",227.0,49.0,"cbp:euid,decode_cabac_mb_cbp_luma:av_freep,cbp_b:vLumFilterSize,h:mmco,get_cabac_noinline:den,ctx:TCG_COND_EQ,cbp_a:scaled,",460.0,0.316870363553365,MHM
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
","target_ulong helper_sdiv(target_ulong x86_stl_phys, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (x86_stl_phys & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
",103.0,22.0,"a:x86_stl_phys,",33.0,0.0210341095924377,MHM
307,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
","void helper_tlb_update(uint32_t T0)

{

#if !defined(sigmask)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	av_clip(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
",80.0,23.0,"CONFIG_USER_ONLY:sigmask,D:av_clip,",64.0,0.0361828724543253,MHM
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
","static void patch_pcihp(int slot, uint8_t *guest_base, uint32_t CNT_NEAR)

{

    guest_base[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    guest_base[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    guest_base[ACPI_PCIHP_OFFSET_ID] = slot;

    guest_base[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!ISA_MIPS32R2(guest_base + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!CNT_NEAR) {

        memcpy(guest_base + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",91.0,26.0,"eject:CNT_NEAR,memcmp:ISA_MIPS32R2,ssdt_ptr:guest_base,",92.0,0.0530015230178833,MHM
310,"static void nvme_instance_init(Object *obj)

{

    object_property_add(obj, ""bootindex"", ""int32"",

                        nvme_get_bootindex,

                        nvme_set_bootindex, NULL, NULL, NULL);

    object_property_set_int(obj, -1, ""bootindex"", NULL);

}
","static void nvme_instance_init(Object *AVERROR_EXTERNAL)

{

    object_property_add(AVERROR_EXTERNAL, ""bootindex"", ""int32"",

                        audiotrack,

                        nvme_set_bootindex, NULL, NULL, NULL);

    av_abort(AVERROR_EXTERNAL, -1, ""bootindex"", NULL);

}
",43.0,8.0,"nvme_get_bootindex:audiotrack,object_property_set_int:av_abort,obj:AVERROR_EXTERNAL,",92.0,0.0520628174146016,MHM
315,"MigrationState *migrate_get_current(void)

{

    static MigrationState current_migration = {

        .state = MIG_STATE_NONE,

        .bandwidth_limit = MAX_THROTTLE,

        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,

        .mbps = -1,

    };



    return &current_migration;

}
","MigrationState *migrate_get_current(void)

{

    static MigrationState how = {

        .state = MIG_STATE_NONE,

        .bandwidth_limit = MAX_THROTTLE,

        .xbzrle_cache_size = PIX_FMT_YUVA420P,

        .mbps = -1,

    };



    return &how;

}
",39.0,6.0,"DEFAULT_MIGRATE_CACHE_SIZE:PIX_FMT_YUVA420P,current_migration:how,",64.0,0.0403776963551839,MHM
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
","qemu_co_sendv_recvv(int target_grouplist, struct iovec *iov, unsigned stb_phys,

                    size_t offset, size_t bytes, bool ACCESS_CODE)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(target_grouplist, iov,

                            offset + done, bytes - done, ACCESS_CODE);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == dest_y) {

                fid();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !ACCESS_CODE) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",126.0,31.0,"qemu_coroutine_yield:fid,iov_cnt:stb_phys,sockfd:target_grouplist,do_send:ACCESS_CODE,EAGAIN:dest_y,",215.0,0.2211260795593261,MHM
326,"static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)
{
    virtio_scsi_common_unrealize(dev, errp);
}","static void rw(DeviceState *dev, Error **qobject_from_jsonf)
{
    cpu_cc_src(dev, qobject_from_jsonf);
}",22.0,6.0,"errp:qobject_from_jsonf,virtio_scsi_device_unrealize:rw,virtio_scsi_common_unrealize:cpu_cc_src,",123.0,0.0830167253812154,MHM
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
","static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    pci_device_rev(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    av_mallocz_array(reg, reg, 1);

}
",36.0,11.0,"gen_compute_eflags:pci_device_rev,tcg_gen_andi_tl:av_mallocz_array,",63.0,0.0469612916310628,MHM
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
","static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t dispinfo, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = dispinfo *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",77.0,20.0,"timestamp:dispinfo,",33.0,0.0204970637957255,MHM
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
","static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""x86_ldub_code"",%""x86_ldub_code, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",73.0,19.0,"SCNd64:x86_ldub_code,",34.0,0.01853848695755,MHM
350,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)

{

    char *path = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(path);

    return NULL;

}
","static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *CODEC_FLAG_GRAY)

{

    char *path = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(CODEC_FLAG_GRAY), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = error_fatal(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = error_fatal(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(path);

    return NULL;

}
",150.0,34.0,"g_strdup_printf:error_fatal,pdev:CODEC_FLAG_GRAY,",64.0,0.0377525170644124,MHM
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
","static void gen_storeq_reg(DisasContext *vst, int rlow, int rhigh, TCGv_i64 rD)

{

    TCGv sampledat;

    sampledat = local_port();

    tcg_gen_trunc_i64_i32(sampledat, rD);

    store_reg(vst, rlow, sampledat);

    sampledat = local_port();

    ptimer_set_limit(rD, rD, 32);

    tcg_gen_trunc_i64_i32(sampledat, rD);

    store_reg(vst, rhigh, sampledat);

}
",75.0,27.0,"new_tmp:local_port,val:rD,tcg_gen_shri_i64:ptimer_set_limit,s:vst,tmp:sampledat,",189.0,0.1125086545944213,MHM
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
","static int ccid_bulk_in_copy_to_guest(USBCCIDState *dispinfo, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(dispinfo);

    if (dispinfo->current_bulk_in != NULL) {

        ret = MIN(dispinfo->current_bulk_in->len - dispinfo->current_bulk_in->pos, len);

        memcpy(data, dispinfo->current_bulk_in->data + dispinfo->current_bulk_in->pos, ret);

        dispinfo->current_bulk_in->pos += ret;

        if (dispinfo->current_bulk_in->pos == dispinfo->current_bulk_in->len) {

            ccid_bulk_in_release(dispinfo);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(dispinfo, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(dispinfo, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
",175.0,45.0,"s:dispinfo,",32.0,0.0201876680056254,MHM
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
","static void decode_mclms(WmallDecodeCtx *cpu_T)

{

    cpu_T->mclms_order = (get_bits(&cpu_T->gb, 4) + 1) * 2;

    cpu_T->mclms_scaling = get_bits(&cpu_T->gb, 4);

    if(get_bits1(&cpu_T->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(cpu_T->mclms_scaling + 1);

	assert(cbits == my_log2(cpu_T->mclms_scaling + 1));

	if(1 << cbits < cpu_T->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&cpu_T->gb, cbits) : 0) + 2;



	for(i = 0; i < cpu_T->mclms_order * cpu_T->num_channels * cpu_T->num_channels; i++) {

	    cpu_T->mclms_coeffs[i] = get_bits(&cpu_T->gb, send_coef_bits);

	}



	for(i = 0; i < cpu_T->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		cpu_T->mclms_coeffs_cur[i * cpu_T->num_channels + c] = get_bits(&cpu_T->gb, send_coef_bits);

	    }

	}

    }

}
",223.0,54.0,"s:cpu_T,",33.0,0.0193944374720255,MHM
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
","void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    av_dict_set_int(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
",27.0,7.0,"memory_region_init_io:av_dict_set_int,",33.0,0.0228937268257141,MHM
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int qio_channel_socket_dgram_sync(QIOChannelSocket *g_assert_cmpstr,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(g_assert_cmpstr, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(g_assert_cmpstr);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(g_assert_cmpstr, fd);

    if (qio_channel_socket_set_fd(g_assert_cmpstr, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",94.0,27.0,"ioc:g_assert_cmpstr,",33.0,0.018298053741455,MHM
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
","int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & get_metadata);

}
",42.0,10.0,"TARGET_PAGE_MASK:get_metadata,",33.0,0.020279586315155,MHM
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= pre << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);

}
","static void tcg_out_insn_3314(TCGContext *COPY, AArch64Insn AV_PIX_FMT_NONE,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    AV_PIX_FMT_NONE |= 1u << 31; /* ext */

    AV_PIX_FMT_NONE |= pre << 24;

    AV_PIX_FMT_NONE |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    AV_PIX_FMT_NONE |= (ofs & (0x7f << 3)) << (15 - 3);



    gen_store_gpr(COPY, AV_PIX_FMT_NONE | r2 << 10 | rn << 5 | r1);

}
",103.0,26.0,"insn:AV_PIX_FMT_NONE,s:COPY,tcg_out32:gen_store_gpr,",94.0,0.0781597256660461,MHM
377,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,

                                       int64_t sector_num, int nb_sectors)

{

    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);

}
","static int dst3 sp(BlockDriverState *bs,

                                       int64_t VNC_SHARE_MODE_EXCLUSIVE, int nb_sectors)

{

    return bdrv_co_discard(bs->file->bs, VNC_SHARE_MODE_EXCLUSIVE, nb_sectors);

}
",32.0,9.0,"coroutine_fn:dst3,raw_co_discard:sp,sector_num:VNC_SHARE_MODE_EXCLUSIVE,",156.0,0.1317576209704081,MHM
379,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
","static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *DISAS_TB_JUMP = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(DISAS_TB_JUMP->vdev);

    msix_reset(&DISAS_TB_JUMP->pci_dev);

    DISAS_TB_JUMP->flags = 0;

}
",46.0,12.0,"proxy:DISAS_TB_JUMP,",33.0,0.0212547461191813,MHM
386,"static inline int popcountl(unsigned long l)

{

    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);

}
","static inline int popcountl(unsigned long conf)

{

    return BITS_PER_LONG == 32 ? ctpop32(conf) : ctpop64(conf);

}
",26.0,7.0,"l:conf,",32.0,0.0272277315457661,MHM
387,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
","static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int cpu_physical_memory_read;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    cpu_physical_memory_read = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(cpu_physical_memory_read) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return cpu_physical_memory_read * 100000 + sign * mb;

}
",145.0,35.0,"db:cpu_physical_memory_read,",32.0,0.0318185687065124,MHM
388,"static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *dma_cb)

{

    if (s->bus->dma->aiocb)

	return;

    dma_cb(s, -1);

}
","static inline void ide_dma_submit_check(IDEState *font_length,

          BlockDriverCompletionFunc *dma_cb)

{

    if (font_length->bus->dma->aiocb)

	return;

    dma_cb(font_length, -1);

}
",34.0,6.0,"s:font_length,",33.0,0.0331162293752034,MHM
405,"static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);

    scsi_req_cancel(s->req);

}
","static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)

{

    MSDState *interlaced = DO_UPCAST(MSDState, dev, dev);

    tcg_gen_ext32u_tl(interlaced->req);

}
",34.0,10.0,"scsi_req_cancel:tcg_gen_ext32u_tl,s:interlaced,",63.0,0.0513342102368672,MHM
407,"bool virtio_ipl_disk_is_valid(void)

{

    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
","bool virtio_ipl_disk_is_valid(void)

{

    return interrupt_request.blk_size && (gemu_log() || mixer_store());

}
",22.0,4.0,"virtio_disk_is_scsi:gemu_log,virtio_disk_is_eckd:mixer_store,blk_cfg:interrupt_request,",212.0,0.1584154605865478,MHM
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
","static void assigned_dev_direct_config_read(Monitor *mon, const char *password, void *guest_mem)

{

    BlockDriverState *bs = guest_mem;

    int UINT_MAX = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        UINT_MAX = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, UINT_MAX);



    monitor_read_command(mon, 1);

}
",81.0,20.0,"bdrv_password_cb:assigned_dev_direct_config_read,ret:UINT_MAX,opaque:guest_mem,",94.0,0.072298264503479,MHM
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!AV_LOG_DEBUG(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
",89.0,23.0,"strcmp:AV_LOG_DEBUG,",35.0,0.0294825752576192,MHM
416,"void main_loop_wait(int nonblocking)

{

    fd_set rfds, wfds, xfds;

    int ret, nfds;

    struct timeval tv;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);

    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);

    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
","void main_loop_wait(int nonblocking)

{

    fd_set rfds, wfds, xfds;

    int ret, nfds;

    struct timeval tv;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    av_realloc(&timeout);



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);

    ARCH_X86_32(&nfds, &rfds, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);

    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
",197.0,59.0,"slirp_select_fill:ARCH_X86_32,os_host_main_loop_wait:av_realloc,",63.0,0.053986918926239,MHM
427,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
","static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool xenstore_read_fe_int;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    xenstore_read_fe_int = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !xenstore_read_fe_int);

    memory_region_transaction_commit();

}
",186.0,38.0,"smram_enabled:xenstore_read_fe_int,",62.0,0.0641278862953186,MHM
429,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
","static void control_to_network(RDMAControlHeader *av_new_packet)

{

    av_new_packet->type = htonl(av_new_packet->type);

    av_new_packet->len = htonl(av_new_packet->len);

    av_new_packet->repeat = htonl(av_new_packet->repeat);

}
",43.0,11.0,"control:av_new_packet,",31.0,0.0271231373151143,MHM
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
","void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & nf);

}
",47.0,11.0,"TARGET_PAGE_MASK:nf,",35.0,0.0259190400441487,MHM
433,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
","void pva_log(AVCodecContext *avctx, AudioFrameQueue *DF)

{

    DF->avctx             = avctx;

    DF->next_pts          = AV_NOPTS_VALUE;

    DF->remaining_delay   = avctx->delay;

    DF->remaining_samples = avctx->delay;

    DF->frame_queue       = NULL;

}
",47.0,12.0,"ff_af_queue_init:pva_log,afq:DF,",61.0,0.0561910986900329,MHM
434,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)

{

    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);

}
","void arm_feature(S390CPU *start_buffer, uint32_t parm)

{

    closesocket(start_buffer, rusage_ptr, parm, 0 , 1);

}
",25.0,7.0,"cpu:start_buffer,kvm_s390_service_interrupt:arm_feature,kvm_s390_interrupt_internal:closesocket,KVM_S390_INT_SERVICE:rusage_ptr,",305.0,0.2577861110369364,MHM
441,"static inline void gen_evfsnabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);

#else

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);

    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
","static inline void localaddr(DisasContext *store)

{

    if (ERROR(!store->spe_enabled)) {

        gen_exception(store, YDELAYA);

        return;

    }

#if defined(TARGET_PPC64)

    keycode(cpu_gpr[rD(store->opcode)], cpu_gpr[rA(store->opcode)], 0x8000000080000000LL);

#else

    keycode(cpu_gpr[rD(store->opcode)], cpu_gpr[rA(store->opcode)], 0x80000000);

    keycode(snap_tag[rD(store->opcode)], snap_tag[rA(store->opcode)], 0x80000000);

#endif

}
",115.0,29.0,"gen_evfsnabs:localaddr,POWERPC_EXCP_APU:YDELAYA,ctx:store,tcg_gen_ori_tl:keycode,cpu_gprh:snap_tag,unlikely:ERROR,",278.0,0.2734856963157653,MHM
446,"float64 HELPER(ucf64_absd)(float64 a)

{

    return float64_abs(a);

}
","float64 TARGET_SIG_DFL(ucf64_absd)(float64 vseq)

{

    return dec_ctx(vseq);

}
",17.0,4.0,"float64_abs:dec_ctx,a:vseq,HELPER:TARGET_SIG_DFL,",303.0,0.2344485600789388,MHM
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && tags[i]; i++){

        enum CodecID id= codec_get_id(tags[i], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
","enum CodecID av_codec_get_id(const AVCodecTag *pics[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && pics[i]; i++){

        enum CodecID id= codec_get_id(pics[i], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
",67.0,18.0,"tags:pics,",34.0,0.0294166405995686,MHM
459,"static double tget_double(GetByteContext *gb, int le)

{

    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};

    return i.f64;

}
","static double offset_data(GetByteContext *ncpu, int ff_thread_report_progress)

{

    av_alias64 den = { .u64 = ff_thread_report_progress ? bytestream2_get_le64(ncpu) : dhcp_msg_type(ncpu)};

    return den.f64;

}
",38.0,10.0,"le:ff_thread_report_progress,gb:ncpu,i:den,bytestream2_get_be64:dhcp_msg_type,tget_double:offset_data,",374.0,0.237874162197113,MHM
463,"void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){

    int i, dc = (block[0] + 15) >> 5;

    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;



    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += line_size;

    }

}
","void ff_vp3_idct_dc_add_c(uint8_t *rhs/*align 8*/, int pva_pts, const DCTELEM *block/*align 16*/){

    int i, dc = (block[0] + 15) >> 5;

    const uint8_t *cm = pci_config_set_vendor_id + video_pts_inc + dc;



    for(i = 0; i < 8; i++){

        rhs[0] = cm[rhs[0]];

        rhs[1] = cm[rhs[1]];

        rhs[2] = cm[rhs[2]];

        rhs[3] = cm[rhs[3]];

        rhs[4] = cm[rhs[4]];

        rhs[5] = cm[rhs[5]];

        rhs[6] = cm[rhs[6]];

        rhs[7] = cm[rhs[7]];

        rhs += pva_pts;

    }

}
",167.0,40.0,"dest:rhs,MAX_NEG_CROP:video_pts_inc,line_size:pva_pts,ff_cropTbl:pci_config_set_vendor_id,",129.0,0.097025446097056,MHM
464,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
","void object_property_add_bool(Object *obj, const char *tcg_gen_subi_i64,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, tcg_gen_subi_i64, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
",102.0,23.0,"name:tcg_gen_subi_i64,",33.0,0.028724447886149,MHM
465,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
","static inline int mirror(int CPUState, int m){

    if     (CPUState<0) return -CPUState;

    else if(CPUState>m) return 2*m-CPUState;

    else         return CPUState;

}
",41.0,10.0,"v:CPUState,",32.0,0.0181530316670735,MHM
474,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
","static av_get_pix_fmt_name *log2_trafo_size(Visitor *bsel)

{

    return container_of(bsel, av_get_pix_fmt_name, tx);

}
",21.0,6.0,"visitor:tx,to_qiv:log2_trafo_size,v:bsel,QmpInputVisitor:av_get_pix_fmt_name,",247.0,0.2290597836176554,MHM
475,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *s = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);

    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && s->interlaced) {

        frame->interlaced_frame = 1;

        frame->top_field_first = s->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return pkt->size;

}
","static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *ad = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);

    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && ad->interlaced) {

        frame->interlaced_frame = 1;

        frame->top_field_first = ad->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return pkt->size;

}
",110.0,25.0,"s:ad,",32.0,0.0323342601458231,MHM
476,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}
","static void bonito_pcihost_class_init(ObjectClass *xenstore_read_fe_int, void *done)

{

    DeviceClass *getopt = swri_audio_convert_alloc(xenstore_read_fe_int);

    SysBusDeviceClass *envlist = object_property_add_child(xenstore_read_fe_int);



    envlist->init = vard;

    getopt->no_user = 1;

}
",44.0,12.0,"DEVICE_CLASS:swri_audio_convert_alloc,bonito_pcihost_initfn:vard,klass:xenstore_read_fe_int,dc:getopt,k:envlist,data:done,SYS_BUS_DEVICE_CLASS:object_property_add_child,",336.0,0.3356467763582865,MHM
478,"void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    IOMMUNotifier *notifier;



    IOMMU_NOTIFIER_FOREACH(notifier, mr) {

        memory_region_iommu_replay(mr, notifier, false);

    }

}
","void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    IOMMUNotifier *cid;



    outbuffer(cid, mr) {

        memory_region_iommu_replay(mr, cid, false);

    }

}
",30.0,7.0,"notifier:cid,IOMMU_NOTIFIER_FOREACH:outbuffer,",95.0,0.0800675193468729,MHM
481,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (t4, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, open[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(open[dc->op1], open[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
",102.0,30.0,"logfile:t4,cpu_R:open,",64.0,0.0585318485895792,MHM
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
","static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *egid = opaque;

    if (qemu_file_get_error(egid->file)) {

        goto out;

    }



    egid->xfer_limit = new_rate;



out:

    return egid->xfer_limit;

}
",46.0,10.0,"s:egid,",31.0,0.0362790942192077,MHM
487,"static void scsi_disk_reset(DeviceState *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);

    uint64_t nb_sectors;



    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));



    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    nb_sectors /= s->qdev.blocksize / 512;

    if (nb_sectors) {

        nb_sectors--;

    }

    s->qdev.max_lba = nb_sectors;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
","static void scsi_disk_reset(DeviceState *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, H.H, dev);

    uint64_t x1;



    scsi_device_purge_requests(&s->H, uvbuf(filtergraphs));



    bdrv_get_geometry(s->H.conf.bs, &x1);

    x1 /= s->H.blocksize / 512;

    if (x1) {

        x1--;

    }

    s->H.max_lba = x1;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
",94.0,23.0,"RESET:filtergraphs,SENSE_CODE:uvbuf,qdev:H,nb_sectors:x1,",216.0,0.2066411693890889,MHM
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
","static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int TCG_COND_GT;

    int dc0;



    dc0=0;

    for(TCG_COND_GT=0;TCG_COND_GT<8; TCG_COND_GT++)

        dc0+= src[TCG_COND_GT-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(TCG_COND_GT=0; TCG_COND_GT<8; TCG_COND_GT++){

        ((uint32_t*)(src+TCG_COND_GT*stride))[0]=

        ((uint32_t*)(src+TCG_COND_GT*stride))[1]= dc0;

    }

}
",110.0,25.0,"i:TCG_COND_GT,",34.0,0.0377710024515787,MHM
495,"static int qcow2_co_flush(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    int ret;



    qemu_co_mutex_lock(&s->lock);

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {


        return ret;

    }



    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {


        return ret;

    }




    return bdrv_co_flush(bs->file);

}","static int qcow2_co_flush(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    int ret;



    elf_entry(&s->lock);

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {


        return ret;

    }



    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {


        return ret;

    }




    return bdrv_co_flush(bs->file);

}",81.0,21.0,"qemu_co_mutex_lock:elf_entry,",33.0,0.0300865848859151,MHM
504,"static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
","static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, sch);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",113.0,29.0,"POWERPC_EXCP_APU:sch,",39.0,0.0348618030548095,MHM
508,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)

{

    uint8_t ret;



    OMAP_8B_REG(addr);

    cpu_physical_memory_read(addr, (void *) &ret, 1);

    return ret;

}
","uint32_t CC_OP_LOGICB(void *tlb, target_phys_addr_t AV_EF_EXPLODE)

{

    uint8_t RFC2132_MSG_TYPE;



    OMAP_8B_REG(AV_EF_EXPLODE);

    AV_RB32(AV_EF_EXPLODE, (void *) &RFC2132_MSG_TYPE, 1);

    return RFC2132_MSG_TYPE;

}
",37.0,10.0,"opaque:tlb,omap_badwidth_read8:CC_OP_LOGICB,ret:RFC2132_MSG_TYPE,cpu_physical_memory_read:AV_RB32,addr:AV_EF_EXPLODE,",338.0,0.2634370366732279,MHM
509,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)

{

    q->pending++;

    set_bit(q->queue, n_IRQ);

}
","static inline void bps1(IRQ_queue_t *q, int n_IRQ)

{

    q->pending++;

    CODEC_FLAG_BITEXACT(q->queue, n_IRQ);

}
",28.0,7.0,"IRQ_setbit:bps1,set_bit:CODEC_FLAG_BITEXACT,",64.0,0.038574206829071,MHM
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
","static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case floor1_Y_final:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
",108.0,29.0,"CURL_POLL_REMOVE:floor1_Y_final,",33.0,0.0294681588808695,MHM
518,"uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)

{

    uint32_t scratch = 0;

    const uint8_t *buf_end = buf + buf_size;





    for (; buf < buf_end - 3; buf += 4)

        scratch ^= *((const uint32_t*)buf);



    scratch = xor_32_to_8(scratch);



    for (; buf < buf_end; buf++)




    return scratch;

}","uint8_t ff_mlp_calculate_parity(const uint8_t *cpu_tmp4, unsigned int buf_size)

{

    uint32_t scratch = 0;

    const uint8_t *buf_end = cpu_tmp4 + buf_size;





    for (; cpu_tmp4 < buf_end - 3; cpu_tmp4 += 4)

        scratch ^= *((const uint32_t*)cpu_tmp4);



    scratch = xor_32_to_8(scratch);



    for (; cpu_tmp4 < buf_end; cpu_tmp4++)




    return scratch;

}",73.0,19.0,"buf:cpu_tmp4,",35.0,0.0233557264010111,MHM
519,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
","void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | uyvy | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
",62.0,13.0,"VP_START:uyvy,",33.0,0.0232536951700846,MHM
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
","static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int isa_bus)

{

    switch(isa_bus) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",99.0,20.0,"tag:isa_bus,",34.0,0.0246865431467692,MHM
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
","static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = TAILQ_REMOVE(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
",77.0,20.0,"qobject_from_json:TAILQ_REMOVE,",37.0,0.0232756773630778,MHM
535,"static int connect_namedsocket(const char *path)

{

    int sockfd, size;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }

    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}","static int connect_namedsocket(const char *path)

{

    int sockfd, size;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }

    PROXY_HDR_SZ(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}",128.0,32.0,"strcpy:PROXY_HDR_SZ,",31.0,0.0262162129084269,MHM
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    bs->detect_zeroes = blk->root_state.detect_zeroes;

}
","void envc(BlockBackend *cb, BlockDriverState *gen_code_buf)

{

    gen_code_buf->detect_zeroes = cb->root_state.detect_zeroes;

}
",23.0,5.0,"blk:cb,bs:gen_code_buf,blk_apply_root_state:envc,",427.0,0.3145282665888468,MHM
542,"static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)

{

    OfDpaFlow *flow;

    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;



    flow = g_new0(OfDpaFlow, 1);

    if (!flow) {

        return NULL;

    }



    flow->cookie = cookie;

    flow->mask.tbl_id = 0xffffffff;



    flow->stats.install_time = flow->stats.refresh_time = now;



    return flow;

}
","static pci_nic_init_nofail *of_dpa_flow_alloc(uint64_t cookie)

{

    pci_nic_init_nofail *flow;

    int64_t DEVICE = part_end(QEMU_CLOCK_VIRTUAL) / 1000;



    flow = v_uv_a(pci_nic_init_nofail, 1);

    if (!flow) {

        return NULL;

    }



    flow->cookie = cookie;

    flow->mask.tbl_id = 0xffffffff;



    flow->stats.install_time = flow->stats.refresh_time = DEVICE;



    return flow;

}
",74.0,17.0,"g_new0:v_uv_a,qemu_clock_get_ms:part_end,now:DEVICE,OfDpaFlow:pci_nic_init_nofail,",188.0,0.1450801332791646,MHM
547,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}
","void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = vhostfdname(base, irqs);

    s->freq = AV_ZERO32;

    s->tm4 = NULL;

}
",35.0,10.0,"PXA25X_FREQ:AV_ZERO32,pxa2xx_timer_init:vhostfdname,",64.0,0.0429537693659464,MHM
554,"PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,

                        const char *default_devaddr)

{

    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;

    PCIDevice *pci_dev;

    DeviceState *dev;

    int i;



    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);

    pci_dev = pci_create(pci_nic_names[i], devaddr);

    dev = &pci_dev->qdev;

    if (nd->id)

        dev->id = qemu_strdup(nd->id);

    dev->nd = nd;

    qdev_init(dev);

    nd->private = dev;

    return pci_dev;

}
","PCIDevice *pci_nic_init(NICInfo *frame_list, const char *default_model,

                        const char *default_devaddr)

{

    const char *devaddr = frame_list->devaddr ? frame_list->devaddr : default_devaddr;

    PCIDevice *pci_dev;

    DeviceState *dev;

    int i;



    i = qemu_check_nic_model_list(frame_list, pci_nic_models, default_model);

    pci_dev = pci_create(pci_nic_names[i], devaddr);

    dev = &pci_dev->qdev;

    if (frame_list->id)

        dev->id = qemu_strdup(frame_list->id);

    dev->frame_list = frame_list;

    qdev_init(dev);

    frame_list->private = dev;

    return pci_dev;

}
",113.0,34.0,"nd:frame_list,",33.0,0.0323673208554585,MHM
557,"void ff_h264_flush_change(H264Context *h)

{

    int i, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=i=0; h->delayed_pic[i]; i++)

            if (h->delayed_pic[i] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[i];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (i = 0; i < h->nb_slice_ctx; i++)

        h->slice_ctx[i].list_count = 0;

}
","void ff_h264_flush_change(H264Context *h)

{

    int selector, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=selector=0; h->delayed_pic[selector]; selector++)

            if (h->delayed_pic[selector] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[selector];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (selector = 0; selector < h->nb_slice_ctx; selector++)

        h->slice_ctx[selector].list_count = 0;

}
",184.0,42.0,"i:selector,",33.0,0.0276153604189554,MHM
560,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
","static void MACIO_DPRINTF(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int pci_set_word = block[0];

    const uint8_t *cm;

    pci_set_word = ( 3 * pci_set_word +  1) >> 1;

    pci_set_word = (17 * pci_set_word + 64) >> 7;

    cm = ff_cropTbl + obt_as + pci_set_word;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188.0,45.0,"MAX_NEG_CROP:obt_as,vc1_inv_trans_8x4_dc_c:MACIO_DPRINTF,dc:pci_set_word,",97.0,0.1147421916325887,MHM
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int memory_region_allocate_system_memory)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - memory_region_allocate_system_memory) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - memory_region_allocate_system_memory) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - memory_region_allocate_system_memory) >> 6;

    }

    return 0; //should not occur

}
",165.0,32.0,"r:memory_region_allocate_system_memory,",33.0,0.0164328932762146,MHM
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *sample_size = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = sample_size->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = sample_size->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = sample_size->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(sample_size, sample_size->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(sample_size, sample_size->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
",171.0,38.0,"opp:sample_size,",32.0,0.025351063410441,MHM
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
","static int MO_LEUL(QEMUFile *cyls, void *RENAME, size_t Y2)

{

    int64_t *mb_type_col = RENAME;

    cpl(cyls, mb_type_col);

    return 0;

}
",33.0,9.0,"v:mb_type_col,pv:RENAME,size:Y2,get_int64:MO_LEUL,qemu_get_sbe64s:cpl,f:cyls,",248.0,0.2174447258313497,MHM
569,"void help(void)

{

    printf(""dct-test [-i] [<test-number>]\n""

           ""test-number 0 -> test with random matrixes\n""

           ""            1 -> test with random sparse matrixes\n""

           ""            2 -> do 3. test from mpeg4 std\n""

           ""-i          test IDCT implementations\n""

           ""-4          test IDCT248 implementations\n"");

    exit(1);

}
","void ptr_y(void)

{

    selected_streams(""dct-test [-i] [<test-number>]\n""

           ""test-number 0 -> test with random matrixes\n""

           ""            1 -> test with random sparse matrixes\n""

           ""            2 -> do 3. test from mpeg4 std\n""

           ""-i          test IDCT implementations\n""

           ""-4          test IDCT248 implementations\n"");

    __FUNCTION__(1);

}
",34.0,3.0,"printf:selected_streams,help:ptr_y,exit:__FUNCTION__,",96.0,0.0862382094065348,MHM
570,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
","x86_stl_phys(slw)

{

    if (slirp & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << slirp;

    }

    container_of();

}
",31.0,7.0,"T1:slirp,RETURN:container_of,PPC_OP:x86_stl_phys,",156.0,0.1256140788396199,MHM
573,"static int piix4_initfn(PCIDevice *dev)

{

    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);

    uint8_t *pci_conf;



    isa_bus_new(&d->dev.qdev);



    pci_conf = d->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &d->dev;

    qemu_register_reset(piix4_reset, d);

    return 0;

}
","static int usb_uas_queue_response(PCIDevice *dev)

{

    PIIX4State *tmp6 = DO_UPCAST(PIIX4State, dev, dev);

    uint8_t *pci_conf;



    isa_bus_new(&tmp6->dev.qdev);



    pci_conf = tmp6->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    reclen(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);



    roundIncrement = &tmp6->dev;

    qemu_register_reset(piix4_reset, tmp6);

    return 0;

}
",83.0,26.0,"pci_config_set_device_id:reclen,piix4_dev:roundIncrement,piix4_initfn:usb_uas_queue_response,d:tmp6,",124.0,0.1516817490259806,MHM
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
","static void dst2(DisasContext *reg, TCGv_i64 vec_st, int rlow)

{

    TCGv_i64 BLK_PERM_ALL;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    BLK_PERM_ALL = tcg_temp_new_i64();

    tmp2 = ssdt_ptr(reg, rlow);

    orientation(BLK_PERM_ALL, tmp2);

    device_name(tmp2);

    drive_index(vec_st, vec_st, BLK_PERM_ALL);

    tcg_temp_free_i64(BLK_PERM_ALL);

}
",63.0,23.0,"dead_tmp:device_name,val:vec_st,tcg_gen_add_i64:drive_index,tcg_gen_extu_i32_i64:orientation,s:reg,load_reg:ssdt_ptr,gen_addq_lo:dst2,tmp:BLK_PERM_ALL,",405.0,0.3565284291903178,MHM
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
","static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    AV_OPT_SEARCH_FAKE_OBJ(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
",209.0,54.0,"memset:AV_OPT_SEARCH_FAKE_OBJ,",36.0,0.0226299921671549,MHM
590,"static CharDriverState *qemu_chr_open_spice_port(const char *id,

                                                 ChardevBackend *backend,

                                                 ChardevReturn *ret,

                                                 Error **errp)

{

    const char *name = backend->spiceport->fqdn;

    CharDriverState *chr;

    SpiceCharDriver *s;



    if (name == NULL) {

        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");

        return NULL;

    }



    chr = chr_open(""port"", spice_port_set_fe_open);

    s = chr->opaque;

    s->sin.portname = g_strdup(name);



    return chr;

}
","static CharDriverState *pps_id(const char *id,

                                                 ChardevBackend *fixture,

                                                 ChardevReturn *M_PI,

                                                 Error **bytestream2_get_be16)

{

    const char *name = fixture->spiceport->fqdn;

    CharDriverState *chr;

    SpiceCharDriver *check;



    if (name == NULL) {

        uMIPS_RD(stderr, ""spice-qemu-char: missing name parameter\n"");

        return NULL;

    }



    chr = chr_open(""port"", listen_addr);

    check = chr->opaque;

    check->sin.portname = g_strdup(name);



    return chr;

}
",94.0,21.0,"s:check,spice_port_set_fe_open:listen_addr,errp:bytestream2_get_be16,fprintf:uMIPS_RD,qemu_chr_open_spice_port:pps_id,backend:fixture,ret:M_PI,",425.0,0.3589478214581807,MHM
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    g_free(breakpoint);

#endif

}
","void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    initrd_filename(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    piix3(breakpoint);

#endif

}
",46.0,13.0,"g_free:piix3,QTAILQ_REMOVE:initrd_filename,",64.0,0.0468096613883972,MHM
598,"static void uninit(AVFilterContext *ctx)

{

    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}","static void bank_no(AVFilterContext *avctx)

{

    ZScaleContext *command_usage = avctx->priv;



    page(command_usage->graph);


    fl_sectors(&command_usage->tmp);

    command_usage->tmp_size = 0;

}",39.0,9.0,"av_freep:fl_sectors,uninit:bank_no,ctx:avctx,zimg_filter_graph_free:page,s:command_usage,",244.0,0.1716655890146891,MHM
608,"static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],

                                   int order, int qlevel, int len, int bps)

{

    int i, j;

    int ebps = 1 << (bps-1);

    unsigned sigma = 0;



    for (i = order; i < len; i++)

        sigma |= decoded[i] + ebps;



    if (sigma < 2*ebps)

        return;



    for (i = len - 1; i >= order; i--) {

        int64_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (int64_t)decoded[i-order+j];

        decoded[i] -= p >> qlevel;

    }

    for (i = order; i < len; i++, decoded++) {

        int32_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (uint32_t)decoded[j];

        decoded[j] += p >> qlevel;

    }

}
","static void lpc_analyze_remodulate(int32_t *VIRTIO_DEVICE, const int coeffs[32],

                                   int order, int qlevel, int len, int bps)

{

    int i, j;

    int ebps = 1 << (bps-1);

    unsigned sigma = 0;



    for (i = order; i < len; i++)

        sigma |= VIRTIO_DEVICE[i] + ebps;



    if (sigma < 2*ebps)

        return;



    for (i = len - 1; i >= order; i--) {

        int64_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (int64_t)VIRTIO_DEVICE[i-order+j];

        VIRTIO_DEVICE[i] -= p >> qlevel;

    }

    for (i = order; i < len; i++, VIRTIO_DEVICE++) {

        int32_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (uint32_t)VIRTIO_DEVICE[j];

        VIRTIO_DEVICE[j] += p >> qlevel;

    }

}
",205.0,64.0,"decoded:VIRTIO_DEVICE,",36.0,0.0305631756782531,MHM
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
","static inline void gen_st16(TCGv cuda_send_packet_to_host, TCGv addr, int index)

{

    tcg_gen_qemu_st16(cuda_send_packet_to_host, addr, index);

    tcg_out_movi(cuda_send_packet_to_host);

}
",30.0,10.0,"dead_tmp:tcg_out_movi,val:cuda_send_packet_to_host,",64.0,0.0431674083073933,MHM
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
","static void b8_stride(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
",137.0,34.0,"h261_v_loop_filter_c:b8_stride,",33.0,0.0337873816490173,MHM
622,"static int ccid_initfn(USBDevice *dev)

{

    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);



    s->bus = ccid_bus_new(&dev->qdev);

    s->card = NULL;

    s->cardinfo = NULL;

    s->migration_state = MIGRATION_NONE;

    s->migration_target_ip = 0;

    s->migration_target_port = 0;

    s->dev.speed = USB_SPEED_FULL;

    s->notify_slot_change = false;

    s->powered = true;

    s->pending_answers_num = 0;

    s->last_answer_error = 0;

    s->bulk_in_pending_start = 0;

    s->bulk_in_pending_end = 0;

    s->current_bulk_in = NULL;

    ccid_reset_error_status(s);

    s->bulk_out_pos = 0;

    ccid_reset_parameters(s);

    ccid_reset(s);

    return 0;

}
","static int ccid_initfn(USBDevice *dev)

{

    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);



    s->bus = ccid_bus_new(&dev->qdev);

    s->card = NULL;

    s->cardinfo = NULL;

    s->migration_state = MIGRATION_NONE;

    s->migration_target_ip = 0;

    s->migration_target_port = 0;

    s->dev.speed = USB_SPEED_FULL;

    s->notify_slot_change = false;

    s->powered = true;

    s->pending_answers_num = 0;

    s->last_answer_error = 0;

    s->bulk_in_pending_start = 0;

    s->bulk_in_pending_end = 0;

    s->current_bulk_in = NULL;

    EXCP_DEBUG(s);

    s->bulk_out_pos = 0;

    ccid_reset_parameters(s);

    ccid_reset(s);

    return 0;

}
",139.0,32.0,"ccid_reset_error_status:EXCP_DEBUG,",36.0,0.037569236755371,MHM
623,"static void ppc4xx_pob_reset (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
","static void ppc4xx_pob_reset (void *ff_h263_decode_motion)

{

    ppc4xx_pob_t *pob;



    pob = ff_h263_decode_motion;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
",42.0,8.0,"opaque:ff_h263_decode_motion,",33.0,0.026437226931254,MHM
629,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, size);

    return 0;

}
","static int asf_read_ext_content(AVFormatContext *BZ_OK, const GUIDParseTable *data)

{

    ASFContext *asf  = BZ_OK->priv_data;

    AVIOContext *bsd_path  = BZ_OK->bsd_path;

    uint64_t psr    = avio_rl64(bsd_path);

    uint16_t old_alloc = avio_rl16(bsd_path);

    int i, ret;



    for (i = 0; i < old_alloc; i++) {

        uint16_t address, type, dhcp_msg_type;

        uint8_t *name = NULL;



        address = avio_rl16(bsd_path);

        if (!address)

            return addr;

        name = av_malloc(address);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(bsd_path, address, name,

                         address);

        type    = avio_rl16(bsd_path);

        dhcp_msg_type = avio_rl16(bsd_path);



        if ((ret = qemu_set_fd_handler(BZ_OK, name, address, dhcp_msg_type, type, &BZ_OK->metadata)) < 0)

            return ret;

    }



    align_position(bsd_path, asf->offset, psr);

    return 0;

}
",181.0,58.0,"AVERROR_INVALIDDATA:addr,s:BZ_OK,nb_desc:old_alloc,pb:bsd_path,g:data,size:psr,process_metadata:qemu_set_fd_handler,val_len:dhcp_msg_type,name_len:address,",273.0,0.3150189359982808,MHM
631,"static void vmxnet3_net_uninit(VMXNET3State *s)

{

    g_free(s->mcast_list);

    vmxnet_tx_pkt_reset(s->tx_pkt);

    vmxnet_tx_pkt_uninit(s->tx_pkt);

    vmxnet_rx_pkt_uninit(s->rx_pkt);

    qemu_del_nic(s->nic);

}
","static void src_end(VMXNET3State *nals_needed)

{

    g_free(nals_needed->mcast_list);

    sample_fmt(nals_needed->tx_pkt);

    tag(nals_needed->tx_pkt);

    x_ctb(nals_needed->rx_pkt);

    y_ctb(nals_needed->nic);

}
",45.0,12.0,"vmxnet3_net_uninit:src_end,vmxnet_tx_pkt_uninit:tag,vmxnet_rx_pkt_uninit:x_ctb,qemu_del_nic:y_ctb,vmxnet_tx_pkt_reset:sample_fmt,s:nals_needed,",186.0,0.1721404910087585,MHM
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(buffer);

}
","static void nb_regs(MMAL_PORT_T *nb_numa_nodes, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *gen_window_check1 = buffer->user_data;

        cpu_to_le64(&gen_window_check1);

    }

    isGray(buffer);

}
",42.0,10.0,"input_callback:nb_regs,buf:gen_window_check1,av_buffer_unref:cpu_to_le64,port:nb_numa_nodes,mmal_buffer_header_release:isGray,",157.0,0.1312031785647074,MHM
634,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
","CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    BDRV_FIX_ERRORS(&cpu->breakpoints);

    BDRV_FIX_ERRORS(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
",142.0,40.0,"QTAILQ_INIT:BDRV_FIX_ERRORS,",31.0,0.0311436374982198,MHM
636,"static int net_socket_can_send(void *opaque)

{

    NetSocketState *s = opaque;



    return qemu_can_send_packet(&s->nc);

}
","static int k0(void *opaque)

{

    NetSocketState *size_to_clusters = opaque;



    return opkt(&size_to_clusters->nc);

}
",25.0,6.0,"qemu_can_send_packet:opkt,net_socket_can_send:k0,s:size_to_clusters,",93.0,0.0980235656102498,MHM
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
","target_ulong helper_rdhwr_cpunum(CPUMIPSState *palstart)

{

    check_hwrena(palstart, 0);

    return palstart->CP0_EBase & 0x3ff;

}
",23.0,5.0,"env:palstart,",34.0,0.0250346660614013,MHM
641,"void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}
","void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= cand_bottom_left;

#endif

    raise_exception(env, EXCP01_DB);

}
",35.0,10.0,"DR6_BS:cand_bottom_left,",34.0,0.0197600841522216,MHM
644,"static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
","static int normalize_bits(int num, int S390_CPU)

{

    if (!num)

        return 0;

    if (num == -1)

        return S390_CPU;

    if (num < 0)

        num = ~num;



    return S390_CPU - av_log2(num);

}
",48.0,12.0,"width:S390_CPU,",34.0,0.0224364002545674,MHM
645,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->realize = xen_pt_realize;

    k->exit = xen_pt_unregister_device;

    k->config_read = xen_pt_pci_read_config;

    k->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->desc = ""Assign an host PCI device with Xen"";

    dc->props = xen_pci_passthrough_properties;

};","static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *sampledat = DEVICE_CLASS(klass);

    PCIDeviceClass *k = old_val(klass);



    k->realize = xen_pt_realize;

    k->exit = xen_pt_unregister_device;

    k->config_read = xen_pt_pci_read_config;

    k->config_write = xen_pt_pci_write_config;


    dprintf(DEVICE_CATEGORY_MISC, sampledat->categories);

    sampledat->desc = ""Assign an host PCI device with Xen"";

    sampledat->props = xen_pci_passthrough_properties;

};",79.0,23.0,"PCI_DEVICE_CLASS:old_val,set_bit:dprintf,dc:sampledat,",95.0,0.0720255414644877,MHM
646,"static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);

        ohci_die(ohci);

        return 0;

    }



    trace_usb_ohci_start(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
","static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);

        ohci_die(ohci);

        return 0;

    }



    le32_to_cpus(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
",63.0,16.0,"trace_usb_ohci_start:le32_to_cpus,",31.0,0.0263883034388224,MHM
648,"static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->size <= 0)

        return avpkt->size;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->size;

}
","static int ref1(AVCodecContext *flash_size,

                            void *data, int *got_sub_ptr, AVPacket *btn)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int pci_dma_read, tcg_rt;

    const uint8_t *p = av_packet_get_side_data(btn, CC_P, &pci_dma_read);

    FFASSDecoderContext *s = flash_size->priv_data;



    if (p && pci_dma_read == 16) {

        x1 = temp2(p     );

        y1 = temp2(p +  4);

        x2 = temp2(p +  8);

        y2 = temp2(p + 12);

    }



    if (btn->pci_dma_read <= 0)

        return btn->pci_dma_read;



    av_bprint_init(&buffer, 0, graph);



    srt_to_ass(flash_size, &buffer, btn->data, x1, y1, x2, y2);

    tcg_rt = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    free_temp(&buffer, NULL);

    if (tcg_rt < 0)

        return tcg_rt;



    *got_sub_ptr = sub->num_rects > 0;

    return btn->pci_dma_read;

}
",216.0,60.0,"size:pci_dma_read,ret:tcg_rt,av_bprint_finalize:free_temp,avpkt:btn,AV_BPRINT_SIZE_UNLIMITED:graph,AV_RL32:temp2,srt_decode_frame:ref1,AV_PKT_DATA_SUBTITLE_POSITION:CC_P,avctx:flash_size,",305.0,0.3861631910006205,MHM
652,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)

{

    IDEBus *bus = opaque;

    IDEState *s = idebus_active_if(bus);

    uint8_t *p;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(s->status & DRQ_STAT))

        return;



    p = s->data_ptr;

    *(uint16_t *)p = le16_to_cpu(val);

    p += 2;

    s->data_ptr = p;

    if (p >= s->data_end)

        s->end_transfer_func(s);

}
","void get_errno(void *opaque, uint32_t addr, uint32_t val)

{

    IDEBus *bus = opaque;

    IDEState *s = idebus_active_if(bus);

    uint8_t *linker;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(s->status & AV_RB24))

        return;



    linker = s->data_ptr;

    *(uint16_t *)linker = le16_to_cpu(val);

    linker += 2;

    s->data_ptr = linker;

    if (linker >= s->data_end)

        s->end_transfer_func(s);

}
",90.0,24.0,"DRQ_STAT:AV_RB24,ide_data_writew:get_errno,p:linker,",95.0,0.1058804790178934,MHM
658,"INLINE int16 extractFloat64Exp( float64 a )

{



    return ( a>>52 ) & 0x7FF;



}
","INLINE low2highuid uid( float64 ROW_SHIFT )

{



    return ( ROW_SHIFT>>52 ) & 0x7FF;



}
",18.0,4.0,"a:ROW_SHIFT,extractFloat64Exp:uid,int16:low2highuid,",156.0,0.1144160151481628,MHM
664,"void net_checksum_calculate(uint8_t *data, int length)

{

    int hlen, plen, proto, csum_offset;

    uint16_t csum;



    if ((data[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    hlen  = (data[14] & 0x0f) * 4;

    plen  = (data[16] << 8 | data[17]) - hlen;

    proto = data[23];



    switch (proto) {

    case PROTO_TCP:

	csum_offset = 16;

	break;

    case PROTO_UDP:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csum_offset+2)

	return;



    data[14+hlen+csum_offset]   = 0;

    data[14+hlen+csum_offset+1] = 0;

    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);

    data[14+hlen+csum_offset]   = csum >> 8;

    data[14+hlen+csum_offset+1] = csum & 0xff;

}
","void net_checksum_calculate(uint8_t *data, int VA_INVALID_ID)

{

    int hlen, filename, S, csum_offset;

    uint16_t csum;



    if ((data[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    hlen  = (data[14] & 0x0f) * 4;

    filename  = (data[16] << 8 | data[17]) - hlen;

    S = data[23];



    switch (S) {

    case currentA:

	csum_offset = 16;

	break;

    case scan_indx:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (filename < csum_offset+2)

	return;



    data[14+hlen+csum_offset]   = 0;

    data[14+hlen+csum_offset+1] = 0;

    csum = CHECK_END(filename, S, data+14+12, data+14+hlen);

    data[14+hlen+csum_offset]   = csum >> 8;

    data[14+hlen+csum_offset+1] = csum & 0xff;

}
",188.0,45.0,"PROTO_UDP:scan_indx,length:VA_INVALID_ID,PROTO_TCP:currentA,net_checksum_tcpudp:CHECK_END,proto:S,plen:filename,",215.0,0.1945212403933207,MHM
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*session, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
","static ssize_t vnc_client_read_tls(gnutls_session_t *vga_bios_ptr, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*vga_bios_ptr, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
",64.0,18.0,"session:vga_bios_ptr,",34.0,0.016442588965098,MHM
671,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
","static void ena_mask(VideoState *ERR)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    ERR->abort_request = 1;

    SDL_WaitThread(ERR->read_tid, NULL);

    SDL_WaitThread(ERR->refresh_tid, NULL);

    packet_queue_destroy(&ERR->videoq);

    packet_queue_destroy(&ERR->audioq);

    packet_queue_destroy(&ERR->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &ERR->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(ERR->pictq_mutex);

    reload(ERR->pictq_cond);

    SDL_DestroyMutex(ERR->subpq_mutex);

    reload(ERR->subpq_cond);

    reload(ERR->continue_read_thread);

#if !CONFIG_AVFILTER

    av_strstart(ERR->img_convert_ctx);

#endif

    MANGLE(ERR);

}
",175.0,44.0,"av_free:MANGLE,sws_freeContext:av_strstart,stream_close:ena_mask,is:ERR,SDL_DestroyCond:reload,",154.0,0.1775067925453186,MHM
672,"static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
","static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    nbd_negotiate_send_rep_err(&q->gain_copy, 0, sizeof(COOKgain));

    nbd_negotiate_send_rep_err(&q->gain_current, 0, sizeof(COOKgain));

    nbd_negotiate_send_rep_err(&q->gain_now, 0, sizeof(COOKgain));

    nbd_negotiate_send_rep_err(&q->gain_previous, 0, sizeof(COOKgain));

}
",131.0,26.0,"memset:nbd_negotiate_send_rep_err,",33.0,0.0367899696032206,MHM
674,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
","static int qemu_mallocz(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
",38.0,8.0,"scsi_device_init:qemu_mallocz,",63.0,0.0676516016324361,MHM
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, job_id, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        job_id = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[job_id];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[job_id] = val;

    }

}
",132.0,35.0,"idx:job_id,",33.0,0.0367896199226379,MHM
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
","static int dest_cr(HEVCContext *s, AVFrame *iov_to_buf, const HEVCSPS *sps)

{

    int TAILQ_REMOVE, i;



    iov_to_buf->width  = s->avctx->width  + 2;

    iov_to_buf->height = s->avctx->height + 2;

    if ((TAILQ_REMOVE = cc(s->avctx, iov_to_buf, AV_GET_BUFFER_FLAG_REF)) < 0)

        return TAILQ_REMOVE;

    for (i = 0; iov_to_buf->data[i]; i++) {

        int arm_feature = iov_to_buf->linesize[i] + (1 << sps->pixel_shift);

        iov_to_buf->data[i] += arm_feature;

    }

    iov_to_buf->width  = s->avctx->width;

    iov_to_buf->height = s->avctx->height;



    return 0;

}
",138.0,31.0,"offset:arm_feature,ret:TAILQ_REMOVE,get_buffer_sao:dest_cr,ff_get_buffer:cc,frame:iov_to_buf,",272.0,0.3033009727795919,MHM
685,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;

    default: abort();

    }

}
","static inline void gen_neon_addl_saturate(TCGv op0, TCGv opp, int reload)

{

    switch (reload) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, POWERPC_MMU_601, op0, opp); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, POWERPC_MMU_601, op0, opp); break;

    default: packFloat16();

    }

}
",60.0,16.0,"op1:opp,abort:packFloat16,size:reload,cpu_env:POWERPC_MMU_601,",158.0,0.1522918581962585,MHM
689,"static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)

{

    int i;



    for (i = 0; i < s->nb_streams; i++) {

        MXFTrack *track = s->streams[i]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))

            return i;

    }

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return s->nb_streams == 1 ? 0 : -1;

}
","static int spr_write_generic(AVFormatContext *s, KLVPacket *file_table)

{

    int i;



    for (i = 0; i < s->nb_streams; i++) {

        MXFTrack *track = s->streams[i]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(file_table->key + sizeof(max_devs), track->track_number, sizeof(track->track_number)))

            return i;

    }

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return s->nb_streams == 1 ? 0 : -1;

}
",87.0,18.0,"mxf_get_stream_index:spr_write_generic,mxf_essence_element_key:max_devs,klv:file_table,",93.0,0.0866566538810729,MHM
694,"static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)

{

    pkt->data      = NULL;

    pkt->side_data = NULL;

    if (pkt->buf) {

        AVBufferRef *ref = av_buffer_ref(src->buf);

        if (!ref)

            return AVERROR(ENOMEM);

        pkt->buf  = ref;

        pkt->data = ref->data;

    } else {

        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);

    }

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

    pkt->destruct = dummy_destruct_packet;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (pkt->side_data_elems && dup)

        pkt->side_data = src->side_data;

    if (pkt->side_data_elems && !dup) {

        return av_copy_packet_side_data(pkt, src);

    }

    return 0;



failed_alloc:

    av_destruct_packet(pkt);

    return AVERROR(ENOMEM);

}
","static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)

{

    pkt->data      = NULL;

    pkt->side_data = NULL;

    if (pkt->buf) {

        AVBufferRef *ref = av_buffer_ref(src->buf);

        if (!ref)

            return AVERROR(ENOMEM);

        pkt->buf  = ref;

        pkt->data = ref->data;

    } else {

        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);

    }

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

    pkt->destruct = dummy_destruct_packet;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (pkt->side_data_elems && dup)

        pkt->side_data = src->side_data;

    if (pkt->side_data_elems && !dup) {

        return cpu_x86_load_seg(pkt, src);

    }

    return 0;



failed_alloc:

    av_destruct_packet(pkt);

    return AVERROR(ENOMEM);

}
",160.0,39.0,"av_copy_packet_side_data:cpu_x86_load_seg,",33.0,0.0381577650705973,MHM
697,"static int virtio_blk_device_exit(DeviceState *dev)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    VirtIOBlock *s = VIRTIO_BLK(dev);

#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE

    remove_migration_state_change_notifier(&s->migration_state_notifier);

    virtio_blk_data_plane_destroy(s->dataplane);

    s->dataplane = NULL;

#endif

    qemu_del_vm_change_state_handler(s->change);

    unregister_savevm(dev, ""virtio-blk"", s);

    blockdev_mark_auto_del(s->bs);

    virtio_cleanup(vdev);

    return 0;

}
","static int HAVE_YASM(DeviceState *filterPos)

{

    VirtIODevice *pci_config_set_class = VIRTIO_DEVICE(filterPos);

    VirtIOBlock *s = pci_bus(filterPos);

#ifdef l1_size2

    remove_migration_state_change_notifier(&s->migration_state_notifier);

    get_ticks_per_sec(s->dataplane);

    s->dataplane = NULL;

#endif

    qemu_del_vm_change_state_handler(s->change);

    unregister_savevm(filterPos, ""virtio-blk"", s);

    blockdev_mark_auto_del(s->bs);

    cpu_env(pci_config_set_class);

    return 0;

}
",84.0,23.0,"virtio_blk_data_plane_destroy:get_ticks_per_sec,dev:filterPos,virtio_blk_device_exit:HAVE_YASM,virtio_cleanup:cpu_env,VIRTIO_BLK:pci_bus,CONFIG_VIRTIO_BLK_DATA_PLANE:l1_size2,vdev:pci_config_set_class,",332.0,0.3042784849802653,MHM
698,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    uint64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);

    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);



    mr = ddc->get_memory_region(dimm);

    value = memory_region_size(mr);



    visit_type_uint64(v, name, &value, errp);

}
","static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **arm_semi_cb)

{

    uint64_t e1;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);

    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);



    mr = ddc->get_memory_region(dimm);

    e1 = input_buffer_size(mr);



    VDP_STATUS_OK(v, name, &e1, arm_semi_cb);

}
",81.0,25.0,"memory_region_size:input_buffer_size,value:e1,visit_type_uint64:VDP_STATUS_OK,errp:arm_semi_cb,",156.0,0.1516213734944661,MHM
709,"static void gen_mtfsfi(DisasContext *ctx)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_FPU);

        return;

    }

    bf = crbD(ctx->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}
","static void intpic(DisasContext *ctx)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, r1);

        return;

    }

    bf = crbD(ctx->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    g_free(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        rem(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    comp_mse(cpu_env);

}
",166.0,48.0,"gen_mtfsfi:intpic,gen_helper_float_check_status:comp_mse,POWERPC_EXCP_FPU:r1,tcg_temp_free_i64:g_free,tcg_gen_shri_i32:rem,",156.0,0.1649872620900472,MHM
710,"void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)

{

    int i;

    size_t pagesize = getpagesize();



    memory = (memory + pagesize - 1) & -pagesize;

    for (i = 0; i < memory / pagesize; i++) {

        memset(area + pagesize * i, 0, 1);

    }

}
","void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)

{

    int i;

    size_t GPIO_E = getpagesize();



    memory = (memory + GPIO_E - 1) & -GPIO_E;

    for (i = 0; i < memory / GPIO_E; i++) {

        memset(area + GPIO_E * i, 0, 1);

    }

}
",73.0,21.0,"pagesize:GPIO_E,",32.0,0.0274839162826538,MHM
724,"int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
","int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *Q34 = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (Q34->used) {

            continue;

        }

        if (!Q34->user_provided) {

            continue;

        }

        oc = object_class_by_name(Q34->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       Q34->driver, Q34->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !Q34->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       Q34->driver, Q34->property, Q34->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
",162.0,37.0,"prop:Q34,",33.0,0.0391719977060953,MHM
744,"int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);

}
","int pthread_mutex_lock(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(tmp_vlc_codes);

    return h->prot->url_shutdown(h, flags);

}
",39.0,9.0,"EINVAL:tmp_vlc_codes,ffurl_shutdown:pthread_mutex_lock,",64.0,0.0445425589879353,MHM
745,"static void i82378_init(DeviceState *dev, I82378State *s)

{

    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));

    ISADevice *pit;

    qemu_irq *out0_irq;



    /* This device has:

       2 82C59 (irq)

       1 82C54 (pit)

       2 82C37 (dma)

       NMI

       Utility Bus Support Registers



       All devices accept byte access only, except timer

     */



    qdev_init_gpio_out(dev, s->out, 2);

    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);



    /* Workaround the fact that i8259 is not qdev'ified... */

    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);



    /* 2 82C59 (irq) */

    s->i8259 = i8259_init(isabus, *out0_irq);

    isa_bus_irqs(isabus, s->i8259);



    /* 1 82C54 (pit) */

    pit = pit_init(isabus, 0x40, 0, NULL);



    /* speaker */

    pcspk_init(isabus, pit);



    /* 2 82C37 (dma) */

    DMA_init(1, &s->out[1]);

    isa_create_simple(isabus, ""i82374"");



    /* timer */

    isa_create_simple(isabus, ""mc146818rtc"");

}
","static void i82378_init(DeviceState *src32_l, I82378State *pci_device_rev)

{

    credp *isabus = tcg_gen_add_i32(credp, qbus, qdev_get_child_bus(src32_l, ""isa.0""));

    ISADevice *pit;

    qemu_irq *out0_irq;



    /* This device has:

       2 82C59 (irq)

       1 82C54 (pit)

       2 82C37 (dma)

       NMI

       Utility Bus Support Registers



       All devices accept byte access only, except timer

     */



    qdev_init_gpio_out(src32_l, pci_device_rev->out, 2);

    qdev_init_gpio_in(src32_l, i82378_request_pic_irq, 16);



    /* Workaround the fact that i8259 is not qdev'ified... */

    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, pci_device_rev, 1);



    /* 2 82C59 (irq) */

    pci_device_rev->i8259 = sd_transfer_state(isabus, *out0_irq);

    block_num(isabus, pci_device_rev->i8259);



    /* 1 82C54 (pit) */

    pit = pit_init(isabus, 0x40, 0, NULL);



    /* speaker */

    pcspk_init(isabus, pit);



    /* 2 82C37 (dma) */

    max_write_zeroes(1, &pci_device_rev->out[1]);

    num_bufs(isabus, ""i82374"");



    /* timer */

    num_bufs(isabus, ""mc146818rtc"");

}
",142.0,40.0,"i8259_init:sd_transfer_state,DO_UPCAST:tcg_gen_add_i32,DMA_init:max_write_zeroes,isa_create_simple:num_bufs,ISABus:credp,dev:src32_l,isa_bus_irqs:block_num,s:pci_device_rev,",245.0,0.245910096168518,MHM
748,"static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    event_notifier_init(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    event_notifier_cleanup(&data.e);

}
","static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    decode012(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    fmt_ctx(&data.e);

}
",197.0,35.0,"event_notifier_init:decode012,event_notifier_cleanup:fmt_ctx,",63.0,0.0808220307032267,MHM
753,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{

    int err;

    FsCred cred;



    cred_init(&cred);

    cred.fc_mode = mode & 07777;

    cred.fc_uid = fidp->uid;

    cred.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -errno;

            }

        });

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }

    }

    return err;

}
","int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{

    int err;

    FsCred cred;



    cred_init(&cred);

    cred.fc_mode = mode & 07777;

    cred.fc_uid = fidp->uid;

    cred.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -av_close_input_file;

            }

        });

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }

    }

    return err;

}
",138.0,35.0,"errno:av_close_input_file,",33.0,0.0253919998804728,MHM
754,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *ptr = (uint8_t *)buf;

    int i;



    if (n->promisc)

        return 1;



    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;

        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((ptr[0] & 1) && n->allmulti)

        return 1;



    if (!memcmp(ptr, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(ptr, n->mac, ETH_ALEN))

        return 1;



    for (i = 0; i < n->mac_table.in_use; i++) {

        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
","static int receive_filter(VirtIONet *RETURN, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *nb_frames = (uint8_t *)buf;

    int i;



    if (RETURN->promisc)

        return 1;



    if (!memcmp(&nb_frames[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(nb_frames + 14)) & 0xfff;

        if (!(RETURN->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((nb_frames[0] & 1) && RETURN->allmulti)

        return 1;



    if (!memcmp(nb_frames, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(nb_frames, RETURN->mac, ETH_ALEN))

        return 1;



    for (i = 0; i < RETURN->mac_table.in_use; i++) {

        if (!memcmp(nb_frames, &RETURN->mac_table.macs[i * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
",240.0,40.0,"ptr:nb_frames,n:RETURN,",62.0,0.0541229605674743,MHM
757,"GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return aio_get_g_source(iohandler_ctx);

}
","GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return aio_get_g_source(gen_check_cpenable);

}
",18.0,4.0,"iohandler_ctx:gen_check_cpenable,",35.0,0.0210106094678243,MHM
765,"static int qemu_rdma_get_fd(void *opaque)

{

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;



    return rdma->comp_channel->fd;

}
","static int temp7(void *__FUNCTION__)

{

    QEMUFileRDMA *sap = __FUNCTION__;

    RDMAContext *rdma = sap->rdma;



    return rdma->comp_channel->fd;

}
",31.0,7.0,"qemu_rdma_get_fd:temp7,rfile:sap,opaque:__FUNCTION__,",123.0,0.1055696725845336,MHM
768,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
","static int minimum_frame_bits(VC2EncContext *s)

{

    int __msa_fill_h, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (__msa_fill_h = 0; __msa_fill_h < s->num_x; __msa_fill_h++) {

            bits += count_hq_slice(s, NULL, __msa_fill_h, slice_y, s->q_ceil);

        }

    }

    return bits;

}
",79.0,21.0,"slice_x:__msa_fill_h,",33.0,0.0251399238904317,MHM
775,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

}
","static inline int ROUND_UP(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

}
",30.0,7.0,"get_chroma_qp:ROUND_UP,",33.0,0.030782663822174,MHM
777,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
","static int get_cpsr(QEMUFile *pci_irq_nrs, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(pci_irq_nrs);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",95.0,26.0,"f:pci_irq_nrs,",34.0,0.0217812299728393,MHM
783,"static void cubieboard_init(QEMUMachineInitArgs *args)

{

    CubieBoardState *s = g_new(CubieBoardState, 1);

    Error *err = NULL;



    s->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);

    if (err != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s\n"",

                error_get_pretty(err));

        exit(1);

    }



    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);

    vmstate_register_ram_global(&s->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &s->sdram);



    cubieboard_binfo.ram_size = args->ram_size;

    cubieboard_binfo.kernel_filename = args->kernel_filename;

    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;

    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);

}
","static void cubieboard_init(QEMUMachineInitArgs *args)

{

    CubieBoardState *s = g_new(CubieBoardState, 1);

    Error *err = NULL;



    s->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(tcg_ctx(s->a10), true, ""realized"", &err);

    if (err != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s\n"",

                error_get_pretty(err));

        exit(1);

    }



    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);

    vmstate_register_ram_global(&s->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &s->sdram);



    cubieboard_binfo.ram_size = args->ram_size;

    cubieboard_binfo.kernel_filename = args->kernel_filename;

    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;

    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);

}
",158.0,37.0,"OBJECT:tcg_ctx,",34.0,0.0350575486818949,MHM
788,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}","bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        product_name(errp, task->err);


        return true;

    }



    return false;

}",37.0,7.0,"error_propagate:product_name,",34.0,0.0168165246645609,MHM
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
","yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int distance)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *qdev_get_gpio_in  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + qdev_get_gpio_in[i * 2] * yalpha) >> 19;

        int sign_extend;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            sign_extend = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            sign_extend = av_clip_uint8(sign_extend);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? sign_extend : 255;

    }

}
",232.0,60.0,"y:distance,A:sign_extend,buf1:qdev_get_gpio_in,",94.0,0.0908102552096049,MHM
796,"av_cold void ff_wmv2_common_init(Wmv2Context * w){

    MpegEncContext * const s= &w->s;



    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);

    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);

}
","av_cold void ff_wmv2_common_init(Wmv2Context * linker){

    MpegEncContext * const s= &linker->s;



    ff_init_scantable(s->dsp.idct_permutation, &linker->abt_scantable[0], ff_wmv2_scantableA);

    ff_init_scantable(s->dsp.idct_permutation, &linker->abt_scantable[1], ff_wmv2_scantableB);

}
",58.0,13.0,"w:linker,",32.0,0.0308828194936116,MHM
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *frame_size_ptr,

                         uint8_t *buf, int buf_size)

{

    int ret;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){

        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,

                                buf, buf_size);

        avctx->frame_number++;

    }else

        ret= 0;

    return ret;

}
","int prefixes(AVCodecContext *img, int16_t *avpkt,

                         int *frame_size_ptr,

                         uint8_t *param, int buf_size)

{

    int IF_SCSI;



    *frame_size_ptr= 0;

    if((img->codec->capabilities & xfds) || buf_size){

        IF_SCSI = img->codec->decode(img, avpkt, frame_size_ptr,

                                param, buf_size);

        img->frame_number++;

    }else

        IF_SCSI= 0;

    return IF_SCSI;

}
",80.0,21.0,"ret:IF_SCSI,avcodec_decode_audio:prefixes,samples:avpkt,buf:param,CODEC_CAP_DELAY:xfds,avctx:img,",308.0,0.3057511409123739,MHM
804,"int main()

{

    int rd, rt, dsp;

    int result, resultdsp;



    rt        = 0x12345678;

    result    = 0xA000C000;

    resultdsp = 1;



    __asm

        (""shll.ph %0, %2, 0x0B\n\t""

         ""rddsp %1\n\t""

         : ""=r""(rd), ""=r""(dsp)

         : ""r""(rt)

        );

    dsp = (dsp >> 22) & 0x01;

    assert(dsp == resultdsp);

    assert(rd  == result);



    return 0;

}
","int main()

{

    int rd, pci_word_test_and_set_mask, dsp;

    int result, resultdsp;



    pci_word_test_and_set_mask        = 0x12345678;

    result    = 0xA000C000;

    resultdsp = 1;



    __asm

        (""shll.ph %0, %2, 0x0B\n\t""

         ""rddsp %1\n\t""

         : ""=r""(rd), ""=r""(dsp)

         : ""r""(pci_word_test_and_set_mask)

        );

    dsp = (dsp >> 22) & 0x01;

    assert(dsp == resultdsp);

    assert(rd  == result);



    return 0;

}
",87.0,21.0,"rt:pci_word_test_and_set_mask,",33.0,0.0364359299341837,MHM
814,"aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;



    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
","aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *previous_left_sample;



    for (previous_left_sample = atomic_rcu_read(&ctx->first_bh); previous_left_sample;

         previous_left_sample = atomic_rcu_read(&previous_left_sample->next)) {

        if (previous_left_sample->scheduled) {

            if (previous_left_sample->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
",104.0,22.0,"bh:previous_left_sample,",33.0,0.040667180220286,MHM
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
","ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t pci_irq_nrs;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        pci_irq_nrs = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, pci_irq_nrs);

    return vnc_client_io_error(vs, pci_irq_nrs, socket_error());

}
",83.0,21.0,"ret:pci_irq_nrs,",33.0,0.0247279167175292,MHM
829,"static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}
","static int libgsm_decode_frame(AVCodecContext *PIX_FMT_NONE,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = PIX_FMT_NONE->frame_size * av_get_bytes_per_sample(PIX_FMT_NONE->sample_fmt);



    if (*data_size < out_size) {

        av_log(PIX_FMT_NONE, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < PIX_FMT_NONE->block_align) {

        av_log(PIX_FMT_NONE, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(PIX_FMT_NONE->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(PIX_FMT_NONE->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(PIX_FMT_NONE->priv_data,buf,data) ||

           gsm_decode(PIX_FMT_NONE->priv_data,buf+33,((int16_t*)data)+dst_int32_t)) return -1;

    }



    *data_size = out_size;

    return PIX_FMT_NONE->block_align;

}
",180.0,45.0,"GSM_FRAME_SIZE:dst_int32_t,avctx:PIX_FMT_NONE,",65.0,0.0554426193237304,MHM
834,"static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *num_same)

{

    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;

    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;

    uint8_t bitmap[BDRV_SECTOR_SIZE];

    int ret;

    int changed;



    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));

    if (ret < 0) {

        return ret;

    }



    bitnum &= BITS_PER_BITMAP_SECTOR - 1;

    changed = cow_test_bit(bitnum, bitmap);

    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);

    return changed;

}
","static int event_notifier_get_fd cow_co_is_allocated(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *num_same)

{

    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;

    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;

    uint8_t bitmap[BDRV_SECTOR_SIZE];

    int ret;

    int changed;



    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));

    if (ret < 0) {

        return ret;

    }



    bitnum &= BITS_PER_BITMAP_SECTOR - 1;

    changed = cow_test_bit(bitnum, bitmap);

    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);

    return changed;

}
",121.0,36.0,"coroutine_fn:event_notifier_get_fd,",35.0,0.0350559671719869,MHM
835,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
","bool timerlist_expired(QEMUTimerList *dead_tmp)

{

    int64_t expire_time;



    if (!atomic_read(&dead_tmp->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&dead_tmp->active_timers_lock);

    if (!dead_tmp->active_timers) {

        prefix(&dead_tmp->active_timers_lock);

        return false;

    }

    expire_time = dead_tmp->active_timers->expire_time;

    prefix(&dead_tmp->active_timers_lock);



    return expire_time < qemu_clock_get_ns(dead_tmp->clock->type);

}
",84.0,17.0,"qemu_mutex_unlock:prefix,timer_list:dead_tmp,",64.0,0.0605389515558878,MHM
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)

{

    uint64_t start = MAX(r1.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);

}
","static AddrRange bs_queue(AddrRange r1, AddrRange r2)

{

    uint64_t start = MAX(r1.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t pci_dev = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return gen_ld(start, pci_dev - start + 1);

}
",58.0,17.0,"addrrange_intersection:bs_queue,addrrange_make:gen_ld,end:pci_dev,",94.0,0.0831989725430806,MHM
842,"static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
","static uint32_t dcr_read_pob (void *opaque, int av_frame_free)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (av_frame_free) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[av_frame_free - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
",71.0,19.0,"dcrn:av_frame_free,",32.0,0.0365095853805541,MHM
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        buff += retval;

        total += retval;

    }

    return total;

}
","static ssize_t socket_read(int sockfd, void *d, size_t size)

{

    ssize_t retval, VMW_CFPRN = 0;



    while (size) {

        retval = read(sockfd, d, size);

        if (retval == 0) {

            return -tcg_temp_new_i32;

        }

        if (retval < 0) {

            if (errno == lumFilter) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        d += retval;

        VMW_CFPRN += retval;

    }

    return VMW_CFPRN;

}
",89.0,25.0,"total:VMW_CFPRN,EIO:tcg_temp_new_i32,EINTR:lumFilter,buff:d,",157.0,0.1573404232660929,MHM
852,"UuidInfo *qmp_query_uuid(Error **errp)

{

    UuidInfo *info = g_malloc0(sizeof(*info));

    char uuid[64];



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    info->UUID = g_strdup(uuid);

    return info;

}
","UuidInfo *qmp_query_uuid(Error **errp)

{

    UuidInfo *info = g_malloc0(sizeof(*info));

    char uuid[64];



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    info->UUID = DEBUG_DISAS(uuid);

    return info;

}
",134.0,30.0,"g_strdup:DEBUG_DISAS,",33.0,0.0260638912518819,MHM
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
","static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *event_notifier_get_fd = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&event_notifier_get_fd->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(event_notifier_get_fd),

                             OBJECT(event_notifier_get_fd->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
",93.0,23.0,"dev:event_notifier_get_fd,",34.0,0.0297945976257324,MHM
862,"static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,

                                          int *beta, int *tc, uint8_t *no_p,

                                          uint8_t *no_q)

{

    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),

                                beta, tc, no_p, no_q);

}
","static void pagesize(hevc_h_loop_filter_luma)(uint8_t *migrate_get_current, ptrdiff_t stride,

                                          int *beta, int *dstV, uint8_t *y_end,

                                          uint8_t *no_q)

{

    pagesize(frame_rate)(migrate_get_current, stride, sizeof(target_tv),

                                beta, dstV, y_end, no_q);

}
",55.0,16.0,"tc:dstV,FUNC:pagesize,hevc_loop_filter_luma:frame_rate,pixel:target_tv,no_p:y_end,pix:migrate_get_current,",339.0,0.2611667553583781,MHM
869,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
","static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *RoQ_CHUNK_PREAMBLE_SIZE = tracks->tracks[i];

        const char *type    = RoQ_CHUNK_PREAMBLE_SIZE->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", RoQ_CHUNK_PREAMBLE_SIZE->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < RoQ_CHUNK_PREAMBLE_SIZE->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, RoQ_CHUNK_PREAMBLE_SIZE->offsets[j].time);

            avio_seek(in, RoQ_CHUNK_PREAMBLE_SIZE->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
",174.0,44.0,"track:RoQ_CHUNK_PREAMBLE_SIZE,",37.0,0.0285847226778666,MHM
872,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,

                                 unsigned size)

{

    PICCommonState *s = opaque;

    return s->elcr;

}
","static uint64_t qemu_ram_alloc(void *gen_add_A0_im, target_phys_addr_t sysbus_mmio_map,

                                 unsigned QCOW_MAX_CRYPT_CLUSTERS)

{

    PICCommonState *mb_type_len = gen_add_A0_im;

    return mb_type_len->elcr;

}
",27.0,7.0,"addr:sysbus_mmio_map,s:mb_type_len,opaque:gen_add_A0_im,size:QCOW_MAX_CRYPT_CLUSTERS,elcr_ioport_read:qemu_ram_alloc,",372.0,0.2772796432177226,MHM
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned CPUID_EXT_XSAVE = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus lowcomp;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    lowcomp = do_log(ctx, CPUID_EXT_XSAVE, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, lowcomp);

}
",130.0,41.0,"ret:lowcomp,rt:CPUID_EXT_XSAVE,",65.0,0.0365457653999328,MHM
890,"int pvpanic_init(ISABus *bus)

{

    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
","int pvpanic_init(ISABus *bus)

{

    precno(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
",19.0,5.0,"isa_create_simple:precno,",63.0,0.0625118454297383,MHM
894,"void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *val, Error **errp)

{

    /* Allow the link to be set, always */

}
","void object_property_allow_set_link(Object *obj, const char *avio_rl32,

                                    Object *val, Error **errp)

{

    /* Allow the link to be set, always */

}
",23.0,5.0,"name:avio_rl32,",33.0,0.0158762256304423,MHM
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(env, result);

}
","target_ulong helper_mul_suov(CPUTriCoreState *pci_set_long, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(pci_set_long, result);

}
",54.0,16.0,"env:pci_set_long,",33.0,0.022921605904897,MHM
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *old, size_t len)

{

    uint32_t startlen = read_u32(old, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
",89.0,22.0,"data:old,",35.0,0.0303483883539835,MHM
923,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_fw->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_mv->y);

    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}
","static inline void cfs(AVSContext *pci_add_capability, cavs_vector *pmv_fw,

                                  cavs_vector *memory_region_init)

{

    cavs_vector *pmv_bw = pmv_fw + refcount_table;

    int tcg_gen_sub_i64 = pci_add_capability->direct_den[memory_region_init->ref];

    int pkt = xpsr(memory_region_init->x);



    pmv_fw->dist = pci_add_capability->dist[1];

    pmv_bw->dist = pci_add_capability->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((tcg_gen_sub_i64 + (tcg_gen_sub_i64 * memory_region_init->x * pmv_fw->dist ^ pkt) - pkt - 1) >> 14) ^ pkt) - pkt;

    pmv_bw->x = pkt - (((tcg_gen_sub_i64 + (tcg_gen_sub_i64 * memory_region_init->x * pmv_bw->dist ^ pkt) - pkt - 1) >> 14) ^ pkt);

    pkt = xpsr(memory_region_init->y);

    pmv_fw->y =     (((tcg_gen_sub_i64 + (tcg_gen_sub_i64 * memory_region_init->y * pmv_fw->dist ^ pkt) - pkt - 1) >> 14) ^ pkt) - pkt;

    pmv_bw->y = pkt - (((tcg_gen_sub_i64 + (tcg_gen_sub_i64 * memory_region_init->y * pmv_bw->dist ^ pkt) - pkt - 1) >> 14) ^ pkt);

}
",236.0,58.0,"FF_SIGNBIT:xpsr,m:pkt,den:tcg_gen_sub_i64,MV_BWD_OFFS:refcount_table,col_mv:memory_region_init,mv_pred_direct:cfs,h:pci_add_capability,",303.0,0.3299895723660787,MHM
925,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,

                                target_ulong pc2, TCGv r_cond)

{

    int l1;



    l1 = gen_new_label();



    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);



    gen_goto_tb(dc, 0, pc2, pc1);



    gen_set_label(l1);

    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);

}
","static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,

                                target_ulong pc2, TCGv r_cond)

{

    int l1;



    l1 = gen_new_label();



    tcg_gen_brcondi_tl(AML_READ_WRITE, r_cond, 0, l1);



    gen_goto_tb(dc, 0, pc2, pc1);



    gen_set_label(l1);

    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);

}
",71.0,22.0,"TCG_COND_EQ:AML_READ_WRITE,",34.0,0.03703506787618,MHM
930,"static void free_geotags(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            av_freep(&s->geotags[i].val);

    }

    av_freep(&s->geotags);


}","static void pred_x(TiffContext *const s)

{

    int bytestream_get_byte;

    for (bytestream_get_byte = 0; bytestream_get_byte < s->geotag_count; bytestream_get_byte++) {

        if (s->geotags[bytestream_get_byte].val)

            av_freep(&s->geotags[bytestream_get_byte].val);

    }

    av_freep(&s->geotags);


}",63.0,14.0,"free_geotags:pred_x,i:bytestream_get_byte,",94.0,0.0860892136891682,MHM
931,"void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
","void avio_read(DCTELEM *block)

{

    int pci_bus;

    DCTELEM temp[64];



    for (pci_bus = 0; pci_bus < 8; pci_bus++)

        bink_idct_col(&temp[pci_bus], &block[pci_bus]);

    for (pci_bus = 0; pci_bus < 8; pci_bus++) {

        IDCT_ROW( (&block[8*pci_bus]), (&temp[8*pci_bus]) );

    }

}
",84.0,20.0,"ff_bink_idct_c:avio_read,i:pci_bus,",62.0,0.0591575980186462,MHM
934,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,

                                              target_ulong eaddr, uint32_t pid)

{

#if !defined(FLUSH_ALL_TLBS)

    CPUState *cs = CPU(ppc_env_get_cpu(env));

    ppcemb_tlb_t *tlb;

    hwaddr raddr;

    target_ulong page, end;

    int i;



    for (i = 0; i < env->nb_tlb; i++) {

        tlb = &env->tlb.tlbe[i];

        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {

            end = tlb->EPN + tlb->size;

            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }

            tlb->prot &= ~PAGE_VALID;

            break;

        }

    }

#else

    ppc4xx_tlb_invalidate_all(env);

#endif

}
","static inline void quirk(CPUPPCState *env,

                                              target_ulong eaddr, uint32_t pid)

{

#if !defined(FLUSH_ALL_TLBS)

    CPUState *cs = CPU(sd(env));

    ppcemb_tlb_t *tlb;

    hwaddr raddr;

    target_ulong page, cpu_gbr;

    int i;



    for (i = 0; i < env->nb_tlb; i++) {

        tlb = &env->tlb.tlbe[i];

        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {

            cpu_gbr = tlb->EPN + tlb->size;

            for (page = tlb->EPN; page < cpu_gbr; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }

            tlb->prot &= ~PAGE_VALID;

            break;

        }

    }

#else

    ppc4xx_tlb_invalidate_all(env);

#endif

}
",155.0,44.0,"end:cpu_gbr,ppc_env_get_cpu:sd,ppc4xx_tlb_invalidate_virt:quirk,",95.0,0.0978590885798136,MHM
940,"static void pcie_pci_bridge_write_config(PCIDevice *d,

        uint32_t address, uint32_t val, int len)

{

    pci_bridge_write_config(d, address, val, len);

    msi_write_config(d, address, val, len);

    shpc_cap_write_config(d, address, val, len);

}
","static void pcie_pci_bridge_write_config(PCIDevice *d,

        uint32_t address, uint32_t val, int len)

{

    pci_bridge_write_config(d, address, val, len);

    x86_cpu(d, address, val, len);

    shpc_cap_write_config(d, address, val, len);

}
",52.0,20.0,"msi_write_config:x86_cpu,",37.0,0.024217689037323,MHM
941,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
","static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    AV_DICT_DONT_OVERWRITE(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = block_height(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(shorts1, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
",169.0,51.0,"stderr:shorts1,MIN:block_height,assert:AV_DICT_DONT_OVERWRITE,",91.0,0.0966159621874491,MHM
944,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void vi(CPUState *dev)

{

    struct qemu_work_item *wi;



    if (dev->queued_work_first == NULL) {

        return;

    }



    while ((wi = dev->queued_work_first)) {

        dev->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            MemoryRegion(wi);

        }

    }

    dev->queued_work_last = NULL;

    src_vF(&qemu_work_cond);

}
",87.0,17.0,"g_free:MemoryRegion,qemu_cond_broadcast:src_vF,flush_queued_work:vi,cpu:dev,",125.0,0.1157579580942789,MHM
946,"long do_sigreturn(CPUCRISState *env)

{

	struct target_signal_frame *frame;

	abi_ulong frame_addr;

	target_sigset_t target_set;

	sigset_t set;

	int i;



	frame_addr = env->regs[R_SP];

	/* Make sure the guest isn't playing games.  */

	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))

		goto badframe;



	/* Restore blocked signals */

	if (__get_user(target_set.sig[0], &frame->sc.oldmask))

		goto badframe;

	for(i = 1; i < TARGET_NSIG_WORDS; i++) {

		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))

			goto badframe;

	}

	target_to_host_sigset_internal(&set, &target_set);

        do_sigprocmask(SIG_SETMASK, &set, NULL);



	restore_sigcontext(&frame->sc, env);

	unlock_user_struct(frame, frame_addr, 0);

	return env->regs[10];

  badframe:

	unlock_user_struct(frame, frame_addr, 0);

	force_sig(TARGET_SIGSEGV);

}
","long do_sigreturn(CPUCRISState *env)

{

	struct target_signal_frame *frame;

	abi_ulong frame_addr;

	target_sigset_t target_set;

	sigset_t set;

	int i;



	frame_addr = env->regs[src_vt1];

	/* Make sure the guest isn't playing games.  */

	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))

		goto badframe;



	/* Restore blocked signals */

	if (__get_user(target_set.sig[0], &frame->sc.oldmask))

		goto badframe;

	for(i = 1; i < TARGET_NSIG_WORDS; i++) {

		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))

			goto badframe;

	}

	target_to_host_sigset_internal(&set, &target_set);

        do_sigprocmask(SIG_SETMASK, &set, NULL);



	restore_sigcontext(&frame->sc, env);

	unlock_user_struct(frame, frame_addr, 0);

	return env->regs[10];

  badframe:

	unlock_user_struct(frame, frame_addr, 0);

	force_sig(TARGET_SIGSEGV);

}
",176.0,44.0,"R_SP:src_vt1,",34.0,0.0273749589920043,MHM
950,"void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
","void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << PNG_COLOR_TYPE_PALETTE)) && (PARAM1 & 1)) {

        vseq(TCG_TARGET_REG_BITS, IF_SD);

    }

    RETURN();

}
",41.0,8.0,"CALL_FROM_TB1:vseq,EXCP_RI:IF_SD,do_raise_exception:TCG_TARGET_REG_BITS,CP0St_FR:PNG_COLOR_TYPE_PALETTE,",217.0,0.2108860611915588,MHM
956,"static void flush_queued_work(CPUState *env)

{

    struct qemu_work_item *wi;



    if (!env->queued_work_first)

        return;



    while ((wi = env->queued_work_first)) {

        env->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

    }

    env->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *env)

{

    struct qemu_work_item *wi;



    if (!env->queued_work_first)

        return;



    while ((wi = env->queued_work_first)) {

        env->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

    }

    env->queued_work_last = NULL;

    qemu_cond_broadcast(&r);

}
",71.0,14.0,"qemu_work_cond:r,",35.0,0.0377253890037536,MHM
964,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));

    if (!s)

        return NULL;



    s->ic = ic;

    s->streams = &ic->streams[first_stream_of_set_idx];

    do {

        s->n_streams++;

    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&

             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);

    s->prev_set_id    = -1;

    s->prev_stream_id = -1;

    s->prev_timestamp = -1;

    s->parse_packet = handler->parse_packet;

    s->dynamic_protocol_context = priv_data;



    return s;

}
","ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *coeff1l)

{

    RDTDemuxContext *FF_QP2LAMBDA = av_mallocz(sizeof(RDTDemuxContext));

    if (!FF_QP2LAMBDA)

        return NULL;



    FF_QP2LAMBDA->ic = ic;

    FF_QP2LAMBDA->streams = &ic->streams[first_stream_of_set_idx];

    do {

        FF_QP2LAMBDA->n_streams++;

    } while (first_stream_of_set_idx + FF_QP2LAMBDA->n_streams < ic->nb_streams &&

             FF_QP2LAMBDA->streams[FF_QP2LAMBDA->n_streams]->priv_data == FF_QP2LAMBDA->streams[0]->priv_data);

    FF_QP2LAMBDA->prev_set_id    = -1;

    FF_QP2LAMBDA->prev_stream_id = -1;

    FF_QP2LAMBDA->prev_timestamp = -1;

    FF_QP2LAMBDA->parse_packet = coeff1l->parse_packet;

    FF_QP2LAMBDA->dynamic_protocol_context = priv_data;



    return FF_QP2LAMBDA;

}
",133.0,29.0,"handler:coeff1l,s:FF_QP2LAMBDA,",65.0,0.066022253036499,MHM
970,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (qemu_paio_write(&acb->aiocb) < 0) {

        raw_aio_remove(acb);

        return NULL;

    }

    return &acb->common;

}
","static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *FIXHR, int mmu_model,

        BlockDriverCompletionFunc *taglen, void *opaque)

{

    RawAIOCB *extradata_copied;



    extradata_copied = raw_aio_setup(bs, sector_num, FIXHR, mmu_model, taglen, opaque);

    if (!extradata_copied)

        return NULL;

    if (qemu_paio_write(&extradata_copied->aiocb) < 0) {

        term_hist_entry(extradata_copied);

        return NULL;

    }

    return &extradata_copied->common;

}
",86.0,22.0,"raw_aio_remove:term_hist_entry,acb:extradata_copied,nb_sectors:mmu_model,cb:taglen,qiov:FIXHR,",186.0,0.1908085227012634,MHM
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, s->pc);

        s->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
","static inline uint32_t insn_get(CPUX86State *FW_CFG_FILE_FIRST, DisasContext *s, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(FW_CFG_FILE_FIRST, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(FW_CFG_FILE_FIRST, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(FW_CFG_FILE_FIRST, s->pc);

        s->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
",107.0,28.0,"env:FW_CFG_FILE_FIRST,",33.0,0.0387233138084411,MHM
975,"static int kvm_put_xcrs(CPUState *env)

{

#ifdef KVM_CAP_XCRS

    struct kvm_xcrs xcrs;



    if (!kvm_has_xcrs())

        return 0;



    xcrs.nr_xcrs = 1;

    xcrs.flags = 0;

    xcrs.xcrs[0].xcr = 0;

    xcrs.xcrs[0].value = env->xcr0;

    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);

#else

    return 0;

#endif

}
","static int kvm_put_xcrs(CPUState *env)

{

#ifdef KVM_CAP_XCRS

    struct kvm_xcrs xcrs;



    if (!qemu_iovec_destroy())

        return 0;



    xcrs.nr_xcrs = 1;

    xcrs.flags = 0;

    xcrs.xcrs[0].xcr = 0;

    xcrs.xcrs[0].value = env->xcr0;

    return kvm_vcpu_ioctl(env, argv_w, &xcrs);

#else

    return 0;

#endif

}
",78.0,14.0,"kvm_has_xcrs:qemu_iovec_destroy,KVM_SET_XCRS:argv_w,",94.0,0.0870521664619445,MHM
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(device);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
","void ACCHI(const char *top_ref, int64_t tctx, Error **errp)

{

    BlockJob *job = av_fast_padded_malloc(top_ref);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, top_ref);

        return;

    }



    block_job_set_speed(job, tctx, errp);

}
",54.0,16.0,"find_block_job:av_fast_padded_malloc,speed:tctx,device:top_ref,qmp_block_job_set_speed:ACCHI,",157.0,0.1719237446784973,MHM
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
","int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int aresample)

{

    PowerPCCPU *SR_OV = ppc_env_get_cpu(env);

    CPUState *qemu_put_be32 = CPU(SR_OV);

    uint32_t *MAX_FD = (uint32_t*)buf;



    struct kvm_ppc_pvinfo dest;



    if (so(qemu_put_be32->kvm_state, announce_addr) &&

        !v9fs_string_free(qemu_put_be32->kvm_state, nptr, &dest)) {

        memcpy(buf, dest.hcall, aresample);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    MAX_FD[0] = 0x3860ffff;

    MAX_FD[1] = 0x60000000;

    MAX_FD[2] = 0x60000000;

    MAX_FD[3] = 0x60000000;



    return 0;

}
",119.0,28.0,"KVM_PPC_GET_PVINFO:nptr,buf_len:aresample,hc:MAX_FD,cs:qemu_put_be32,kvm_check_extension:so,KVM_CAP_PPC_GET_PVINFO:announce_addr,cpu:SR_OV,kvm_vm_ioctl:v9fs_string_free,pvinfo:dest,",334.0,0.3421242713928222,MHM
998,"float32 HELPER(ucf64_abss)(float32 a)

{

    return float32_abs(a);

}
","float32 bitmap(ucf64_abss)(float32 print_int)

{

    return rel_ymax(print_int);

}
",17.0,4.0,"a:print_int,HELPER:bitmap,float32_abs:rel_ymax,",95.0,0.0846541086832682,MHM
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
","static inline void TCG_COND_GT(DisasContext *s, TCGMemOp gic_msi)

{

    if (avio_get_str16le)

        gen_io_start();

    subframe_len(s);

    gen_op_ld_v(s, gic_msi, f[0], iov_cnt);



    dstW(MO_LEQ, new_block[R_EDX]);

    depth(MO_LEQ, MO_LEQ, 0xffff);

    dstW(daddr, f[0]);

    migrate_get_current(gic_msi, MO_LEQ, daddr);



    gen_op_movl_T0_Dshift(gic_msi);

    ban(s->aflag, R_ESI);

    if (avio_get_str16le)

        gen_io_end();

}
",101.0,33.0,"tcg_gen_andi_i32:depth,use_icount:avio_get_str16le,ot:gic_msi,cpu_tmp2_i32:MO_LEQ,gen_string_movl_A0_ESI:subframe_len,tcg_gen_trunc_tl_i32:dstW,cpu_tmp3_i32:daddr,gen_op_add_reg_T0:ban,cpu_T:f,gen_outs:TCG_COND_GT,cpu_A0:iov_cnt,cpu_regs:new_block,gen_helper_out_func:migrate_get_current,",487.0,0.485440707206726,MHM
1010,"static int raw_init_encoder(AVCodecContext *avctx)

{

    avctx->coded_frame = (AVFrame *)avctx->priv_data;

    avctx->coded_frame->pict_type = FF_I_TYPE;

    avctx->coded_frame->key_frame = 1;

    avctx->codec_tag = findFourCC(avctx->pix_fmt);

    return 0;

}
","static int bit_length(AVCodecContext *IS_DIR)

{

    IS_DIR->coded_frame = (AVFrame *)IS_DIR->priv_data;

    IS_DIR->coded_frame->pict_type = lrintf;

    IS_DIR->coded_frame->key_frame = 1;

    IS_DIR->codec_tag = findFourCC(IS_DIR->pix_fmt);

    return 0;

}
",52.0,10.0,"raw_init_encoder:bit_length,FF_I_TYPE:lrintf,avctx:IS_DIR,",155.0,0.1457386612892151,MHM
1013,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);

}
","void ff_put_h264_qpel8_mc23_msa(uint8_t *DPADD_SH3_SH, const uint8_t *offset1,

                                ptrdiff_t g_assert_cmphex)

{

    avc_luma_midv_qrt_8w_msa(offset1 - (2 * g_assert_cmphex) - 2, g_assert_cmphex, DPADD_SH3_SH, g_assert_cmphex, 8, 1);

}
",40.0,10.0,"src:offset1,dst:DPADD_SH3_SH,stride:g_assert_cmphex,",154.0,0.1400151173273722,MHM
1016,"static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    qemu_aio_unref(iocb);

}
","static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    VNC_SHARE_MODE_EXCLUSIVE(iocb);

}
",51.0,12.0,"qemu_aio_unref:VNC_SHARE_MODE_EXCLUSIVE,",33.0,0.0202597896258036,MHM
1024,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
","static int get_pcm(HEVCContext *adpcm_sbpro_expand_nibble, int x, int DELAYED_PIC_REF)

{

    int de = adpcm_sbpro_expand_nibble->sps->de;

    int x_pu             = x >> de;

    int y_pu             = DELAYED_PIC_REF >> de;



    if (x < 0 || x_pu >= adpcm_sbpro_expand_nibble->sps->min_pu_width ||

        DELAYED_PIC_REF < 0 || y_pu >= adpcm_sbpro_expand_nibble->sps->min_pu_height)

        return 2;

    return adpcm_sbpro_expand_nibble->is_pcm[y_pu * adpcm_sbpro_expand_nibble->sps->min_pu_width + x_pu];

}
",84.0,22.0,"s:adpcm_sbpro_expand_nibble,y:DELAYED_PIC_REF,log2_min_pu_size:de,",218.0,0.1855539639790852,MHM
1032,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
","static inline int name(int cpu_msr, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (cpu_msr), ""+b"" (*b));

	return cpu_msr;

}
",39.0,6.0,"cris_addc_pi_m:name,a:cpu_msr,",61.0,0.0524053295453389,MHM
1033,"static void vmgenid_query_monitor_test(void)

{

    QemuUUID expected, measured;

    gchar *cmd;



    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);



    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(cmd);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    qtest_quit(global_qtest);

    g_free(cmd);

}
","static void xy2(void)

{

    QemuUUID filename_bytes, eosf;

    gchar *nb_output_streams;



    samples_size(qemu_uuid_parse(VGID_GUID, &filename_bytes) == 0);



    nb_output_streams = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(nb_output_streams);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&eosf);

    samples_size(memcmp(eosf.data, filename_bytes.data, sizeof(eosf.data)) == 0);



    qtest_quit(global_qtest);

    g_free(nb_output_streams);

}
",86.0,24.0,"measured:eosf,g_assert:samples_size,expected:filename_bytes,vmgenid_query_monitor_test:xy2,cmd:nb_output_streams,",155.0,0.1592948714892069,MHM
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
","static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, pci_set_word, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        pci_set_word = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + pci_set_word - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = pci_set_word - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
",160.0,53.0,"b:pci_set_word,",32.0,0.0389512300491333,MHM
1045,"int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)

{



    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,

                            sizeof(diag_501), 0) ||

        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,

                            sizeof(diag_501), 1)) {

        return -EINVAL;

    }

    return 0;

}
","int kvm_arch_insert_sw_breakpoint(CPUState *error_set, struct kvm_sw_breakpoint *bp)

{



    if (cpu_memory_rw_debug(error_set, bp->pc, (uint8_t *)&bp->saved_insn,

                            sizeof(diag_501), 0) ||

        cpu_memory_rw_debug(error_set, bp->pc, (uint8_t *)diag_501,

                            sizeof(diag_501), 1)) {

        return -EINVAL;

    }

    return 0;

}
",72.0,14.0,"cs:error_set,",34.0,0.0240988532702128,MHM
1050,"static int sox_read_packet(AVFormatContext *s,

                           AVPacket *pkt)

{

    int ret, size;



    if (url_feof(s->pb))

        return AVERROR_EOF;



    size = SOX_SAMPLES*s->streams[0]->codec->block_align;

    ret = av_get_packet(s->pb, pkt, size);

    if (ret < 0)

        return AVERROR(EIO);


    pkt->stream_index = 0;

    pkt->size = ret;



    return 0;

}","static int max_packet_size(AVFormatContext *s,

                           AVPacket *pkt)

{

    int ret, size;



    if (url_feof(s->pb))

        return get_tag_value;



    size = SOX_SAMPLES*s->streams[0]->codec->block_align;

    ret = av_get_packet(s->pb, pkt, size);

    if (ret < 0)

        return AVERROR(EIO);


    pkt->stream_index = 0;

    pkt->size = ret;



    return 0;

}",86.0,22.0,"AVERROR_EOF:get_tag_value,sox_read_packet:max_packet_size,",64.0,0.0426758050918579,MHM
1051,"static av_cold int svq1_encode_init(AVCodecContext *avctx)

{

    SVQ1Context * const s = avctx->priv_data;



    dsputil_init(&s->dsp, avctx);

    avctx->coded_frame= (AVFrame*)&s->picture;



    s->frame_width = avctx->width;

    s->frame_height = avctx->height;



    s->y_block_width = (s->frame_width + 15) / 16;

    s->y_block_height = (s->frame_height + 15) / 16;



    s->c_block_width = (s->frame_width / 4 + 15) / 16;

    s->c_block_height = (s->frame_height / 4 + 15) / 16;



    s->avctx= avctx;

    s->m.avctx= avctx;


    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));

    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));

    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));

    h263_encode_init(&s->m); //mv_penalty



    return 0;

}","static av_cold block_predictor svq1_encode_init(AVCodecContext *avctx)

{

    SVQ1Context * const pal_exdata = avctx->priv_data;



    dsputil_init(&pal_exdata->dsp, avctx);

    avctx->coded_frame= (AVFrame*)&pal_exdata->picture;



    pal_exdata->frame_width = avctx->width;

    pal_exdata->frame_height = avctx->height;



    pal_exdata->y_block_width = (pal_exdata->frame_width + 15) / 16;

    pal_exdata->y_block_height = (pal_exdata->frame_height + 15) / 16;



    pal_exdata->c_block_width = (pal_exdata->frame_width / 4 + 15) / 16;

    pal_exdata->c_block_height = (pal_exdata->frame_height / 4 + 15) / 16;



    pal_exdata->avctx= avctx;

    pal_exdata->m.avctx= avctx;


    pal_exdata->m.me.scratchpad= x86_stl_phys((avctx->width+64)*2*16*2*sizeof(uint8_t));

    pal_exdata->m.me.map       = x86_stl_phys(ME_MAP_SIZE*sizeof(uint32_t));

    pal_exdata->m.me.score_map = x86_stl_phys(ME_MAP_SIZE*sizeof(uint32_t));

    pal_exdata->mb_type        = x86_stl_phys((pal_exdata->y_block_width+1)*pal_exdata->y_block_height*sizeof(int16_t));

    pal_exdata->dummy          = x86_stl_phys((pal_exdata->y_block_width+1)*pal_exdata->y_block_height*sizeof(int32_t));

    h263_encode_init(&pal_exdata->m); //mv_penalty



    return 0;

}",258.0,45.0,"av_mallocz:x86_stl_phys,int:block_predictor,s:pal_exdata,",155.0,0.1202065229415893,MHM
1055,"static void csrhci_reset(struct csrhci_s *s)

{

    s->out_len = 0;

    s->out_size = FIFO_LEN;

    s->in_len = 0;

    s->baud_delay = NANOSECONDS_PER_SECOND;

    s->enable = 0;

    s->in_hdr = INT_MAX;

    s->in_data = INT_MAX;



    s->modem_state = 0;

    /* After a while... (but sooner than 10ms) */

    s->modem_state |= CHR_TIOCM_CTS;



    memset(&s->bd_addr, 0, sizeof(bdaddr_t));

}
","static void __FUNCTION__(struct csrhci_s *s)

{

    s->out_len = 0;

    s->out_size = di;

    s->in_len = 0;

    s->baud_delay = tcg_gen_shli_tl;

    s->enable = 0;

    s->in_hdr = INT_MAX;

    s->in_data = INT_MAX;



    s->modem_state = 0;

    /* After a while... (but sooner than 10ms) */

    s->modem_state |= CHR_TIOCM_CTS;



    memset(&s->bd_addr, 0, sizeof(bdaddr_t));

}
",80.0,19.0,"csrhci_reset:__FUNCTION__,FIFO_LEN:di,NANOSECONDS_PER_SECOND:tcg_gen_shli_tl,",153.0,0.1160217841466268,MHM
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void bs_vm_state(const uint8_t *cpu_cc_src, uint8_t *dst, unsigned int avio_r8)

{

	unsigned i;

	unsigned obj = avio_r8 >> 1;

	

	for(i=0; i<obj; i++)

	{

	    unsigned lowroom,g,vc1_unescape_buffer;

	    register uint16_t rgb;

	    rgb = cpu_cc_src[2*i];

	    vc1_unescape_buffer = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    lowroom = (rgb&0x7C00)>>10;

	    dst[2*i] = (lowroom&0x1F) | ((g&0x1F)<<5) | ((vc1_unescape_buffer&0x1F)<<10);

	}

}
",122.0,29.0,"r:vc1_unescape_buffer,src_size:avio_r8,b:lowroom,num_pixels:obj,rgb15tobgr15:bs_vm_state,src:cpu_cc_src,",307.0,0.242310611406962,MHM
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
","static int lag_decode_prob(GetBitContext *gb, uint32_t *gen_helper_write_eflags)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *gen_helper_write_eflags = 0;

        return -1;

    } else if (bits == 0) {

        *gen_helper_write_eflags = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *gen_helper_write_eflags = val - 1;



    return 0;

}
",171.0,38.0,"value:gen_helper_write_eflags,",34.0,0.0268694678942362,MHM
1060,"static void test_validate_fail_union_flat(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefFlatUnion *tmp = NULL;

    Error *errp = NULL;

    Visitor *v;



    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefFlatUnion(tmp);

}
","static void sps_id(TestInputVisitorData *packet_bytes,

                                          const void *unused)

{

    UserDefFlatUnion *tmp = NULL;

    Error *errp = NULL;

    Visitor *version;



    version = media(packet_bytes, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    visit_type_UserDefFlatUnion(version, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    tss(tmp);

}
",68.0,18.0,"v:version,data:packet_bytes,validate_test_init:media,qapi_free_UserDefFlatUnion:tss,test_validate_fail_union_flat:sps_id,",216.0,0.1783058524131774,MHM
1061,"void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)

{

#if defined(DEBUG_MMU)

    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);

#endif

    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=

        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {

        tlb_flush(env, 1);

    }

    /* SSE handling */

    if (!(env->cpuid_features & CPUID_SSE))

        new_cr4 &= ~CR4_OSFXSR_MASK;

    if (new_cr4 & CR4_OSFXSR_MASK)

        env->hflags |= HF_OSFXSR_MASK;

    else

        env->hflags &= ~HF_OSFXSR_MASK;



    env->cr[4] = new_cr4;

}
","void cpu_x86_update_cr4(CPUX86State *migrate_get_current, uint32_t new_cr4)

{

#if defined(rbase)

    printf(""CR4 update: CR4=%08x\n"", (uint32_t)migrate_get_current->cr[4]);

#endif

    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=

        (migrate_get_current->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {

        cpu_fprintf(migrate_get_current, 1);

    }

    /* SSE handling */

    if (!(migrate_get_current->cpuid_features & CPUID_SSE))

        new_cr4 &= ~CR4_OSFXSR_MASK;

    if (new_cr4 & CR4_OSFXSR_MASK)

        migrate_get_current->hflags |= isa_bios_size;

    else

        migrate_get_current->hflags &= ~isa_bios_size;



    migrate_get_current->cr[4] = new_cr4;

}
",121.0,28.0,"DEBUG_MMU:rbase,HF_OSFXSR_MASK:isa_bios_size,tlb_flush:cpu_fprintf,env:migrate_get_current,",124.0,0.1230498472849528,MHM
1069,"static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
","static void profile(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
",62.0,17.0,"spapr_cpu_core_host_initfn:profile,",30.0,0.0343483368555704,MHM
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
","void m68k_cpu_list(FILE *f, int (*BITS_PER_LONG)(FILE *f, const char *unwrap_prev_frame_num, ...))

{

    unsigned int GETPC;



    for (GETPC = 0; qobject_from_jsonf[GETPC].name; GETPC++) {

        (*BITS_PER_LONG)(f, ""%s\n"", qobject_from_jsonf[GETPC].name);

    }

}
",68.0,14.0,"i:GETPC,m68k_cpu_defs:qobject_from_jsonf,fmt:unwrap_prev_frame_num,cpu_fprintf:BITS_PER_LONG,",186.0,0.1949854771296183,MHM
1072,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,

                              PCIHotplugState state)

{

    int slot = PCI_SLOT(dev->devfn);

    int bsel = acpi_pcihp_get_bsel(dev->bus);

    if (bsel < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (state == PCI_COLDPLUG_ENABLED) {

        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

        return 0;

    }



    if (state == PCI_HOTPLUG_ENABLED) {

        enable_device(s, bsel, slot);

    } else {

        disable_device(s, bsel, slot);

    }



    return 0;

}
","int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,

                              PCIHotplugState state)

{

    int dc = PCI_SLOT(dev->devfn);

    int bsel = acpi_pcihp_get_bsel(dev->bus);

    if (bsel < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (state == PCI_COLDPLUG_ENABLED) {

        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << dc);

        return 0;

    }



    if (state == PCI_HOTPLUG_ENABLED) {

        enable_device(s, bsel, dc);

    } else {

        disable_device(s, bsel, dc);

    }



    return 0;

}
",105.0,26.0,"slot:dc,",33.0,0.0390438675880432,MHM
1074,"static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}","static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar gen_window_check3, celt_output_samples;



    ide_test_start("""");



    dev = sei_cont(&gen_window_check3, &celt_output_samples);



    /* FLUSH CACHE command on device 0*/

    raise_exception(dev, celt_output_samples, reg_device, 0);

    raise_exception(dev, celt_output_samples, cpu_physical_memory_read, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}",60.0,19.0,"qpci_io_writeb:raise_exception,ide_bar:celt_output_samples,bmdma_bar:gen_window_check3,get_pci_device:sei_cont,reg_command:cpu_physical_memory_read,",187.0,0.1964119354883829,MHM
1089,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
","static void get_sensor_evt_enable(IPMIBmcSim *unlock_user,

                                  uint8_t *media_info, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((media_info[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(unlock_user->sensors + media_info[2])) {

        rsp[2] = VA_INVALID_ID;

        return;

    }

    sens = unlock_user->sensors + media_info[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
",138.0,30.0,"ibs:unlock_user,IPMI_CC_REQ_ENTRY_NOT_PRESENT:VA_INVALID_ID,cmd:media_info,",125.0,0.135328201452891,MHM
1099,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)

{

    LM32JuartState *s = LM32_JUART(d);

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    }

}","void lm32_juart_set_jtx(DeviceState *cpu_fir, uint32_t jtx)

{

    LM32JuartState *s = LM32_JUART(cpu_fir);

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    }

}",62.0,16.0,"d:cpu_fir,",33.0,0.0256816347440083,MHM
1108,"void qmp_migrate_cancel(Error **errp)

{

    migrate_fd_cancel(migrate_get_current());

}
","void control(Error **errp)

{

    migrate_fd_cancel(OPENPIC_OUTPUT_NB());

}
",17.0,4.0,"qmp_migrate_cancel:control,migrate_get_current:OPENPIC_OUTPUT_NB,",64.0,0.055846087137858,MHM
1112,"static void msmouse_chr_close (struct CharDriverState *chr)

{

    MouseState *mouse = chr->opaque;



    qemu_input_handler_unregister(mouse->hs);

    g_free(mouse);

    g_free(chr);

}
","static void msmouse_chr_close (struct CharDriverState *TCG_REG_T1)

{

    MouseState *mouse = TCG_REG_T1->opaque;



    qemu_input_handler_unregister(mouse->hs);

    g_free(mouse);

    g_free(TCG_REG_T1);

}
",36.0,10.0,"chr:TCG_REG_T1,",63.0,0.0669515927632649,MHM
1114,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
","clock(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *AVERROR_UNKNOWN, *envvar;

	char *l2_index = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((AVERROR_UNKNOWN = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(AVERROR_UNKNOWN, "","", &l2_index);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(AVERROR_UNKNOWN);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &l2_index);

	}



	free(AVERROR_UNKNOWN);

	return (0);

}
",154.0,40.0,"envsave:l2_index,envlist_parse:clock,tmpenv:AVERROR_UNKNOWN,",96.0,0.1080186128616333,MHM
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}
","static av_cold tables aio_context_release(AVCodecContext *target_ulong, CUresult PCI_COMMAND, const char *U)

{

    if (PCI_COMMAND != se) {

        av_log(target_ulong, object_property_add_bool, "">> %s - failed with error code 0x%x\n"", U, PCI_COMMAND);

        return 0;

    }

    return 1;

}
",48.0,12.0,"AV_LOG_FATAL:object_property_add_bool,int:tables,func:U,err:PCI_COMMAND,avctx:target_ulong,check_cuda_errors:aio_context_release,CUDA_SUCCESS:se,",312.0,0.2739734927813212,MHM
1131,"int ff_thread_init(AVCodecContext *avctx)

{

    if (avctx->thread_opaque) {

        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");

        return -1;

    }



#if HAVE_W32THREADS

    w32thread_init();

#endif



    if (avctx->codec) {

        validate_thread_parameters(avctx);



        if (avctx->active_thread_type&FF_THREAD_SLICE)

            return thread_init(avctx);

        else if (avctx->active_thread_type&FF_THREAD_FRAME)

            return frame_thread_init(avctx);

    }



    return 0;

}
","int NBD_CMD_READ(AVCodecContext *nPbW)

{

    if (nPbW->thread_opaque) {

        devenum(nPbW, mmreg, ""avcodec_thread_init is ignored after avcodec_open\n"");

        return -1;

    }



#if HAVE_W32THREADS

    put_user_u32();

#endif



    if (nPbW->codec) {

        box_size(nPbW);



        if (nPbW->active_thread_type&AVERROR_EOF)

            return thread_init(nPbW);

        else if (nPbW->active_thread_type&dxy)

            return frame_thread_init(nPbW);

    }



    return 0;

}
",84.0,19.0,"validate_thread_parameters:box_size,FF_THREAD_SLICE:AVERROR_EOF,FF_THREAD_FRAME:dxy,av_log:devenum,w32thread_init:put_user_u32,AV_LOG_ERROR:mmreg,ff_thread_init:NBD_CMD_READ,avctx:nPbW,",401.0,0.4116337259610494,MHM
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
","static inline bool memory_access_is_direct(MemoryRegion *MAX_CHANNELS, bool iopattern)

{

    if (av_realloc(MAX_CHANNELS)) {

        return !(iopattern && MAX_CHANNELS->readonly);

    }

    if (STATUS_VAR(MAX_CHANNELS)) {

        return !iopattern;

    }



    return false;

}
",49.0,10.0,"is_write:iopattern,mr:MAX_CHANNELS,memory_region_is_ram:av_realloc,memory_region_is_romd:STATUS_VAR,",187.0,0.1824627677599589,MHM
1135,"static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,

                             uint64_t value)

{

    if (ri->crm > 8) {

        return EXCP_UDEF;

    }

    env->cp15.c6_region[ri->crm] = value;

    return 0;

}
","static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *TCG_REG_O1,

                             uint64_t value)

{

    if (TCG_REG_O1->crm > 8) {

        return EXCP_UDEF;

    }

    env->cp15.c6_region[TCG_REG_O1->crm] = value;

    return 0;

}
",47.0,9.0,"ri:TCG_REG_O1,",32.0,0.0259409666061401,MHM
1137,"static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}","static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = target_set(dev);

    DeviceState *d = tcg_gen_ext32s_tl(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, cipher_mode_spec(pci), &clut, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, init_vlc, &pci->io);

    s->irq = intnum(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        srcStrideParam(&s->bus, &err);

        if (err != NULL) {


            t2(err);

            return -1;

        }

    }

    return 0;

}",191.0,49.0,"OBJECT:cipher_mode_spec,PCI_ESP:target_set,scsi_bus_legacy_handle_cmdline:srcStrideParam,PCI_BASE_ADDRESS_SPACE_IO:init_vlc,pci_allocate_irq:intnum,esp_pci_io_ops:clut,error_free:t2,DEVICE:tcg_gen_ext32s_tl,",279.0,0.2908128420511881,MHM
1139,"static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)

{

    return telldir(fs->dir);

}
","static off_t QTAILQ_INIT(FsContext *extradata_copied, V9fsFidOpenState *busdev)

{

    return zywrle_level(busdev->dir);

}
",22.0,5.0,"proxy_telldir:QTAILQ_INIT,fs:busdev,ctx:extradata_copied,telldir:zywrle_level,",336.0,0.2699931383132934,MHM
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t disasm_info=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &disasm_info);

    return num*disasm_info/den;

}
",60.0,17.0,"intnum:disasm_info,",31.0,0.0294284184773763,MHM
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);

}
","static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (vex2(dshmem, magic) == VMXNET3_REV1_MAGIC);

}
",21.0,6.0,"VMXNET3_READ_DRV_SHARED32:vex2,",33.0,0.0344103415807088,MHM
1159,"static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}
","static void piix3_class_init(ObjectClass *dprintf, void *data)

{

    DeviceClass *xen_enabled = DEVICE_CLASS(dprintf);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(dprintf);



    xen_enabled->desc        = ""ISA bridge"";

    xen_enabled->vmsd        = &vmstate_piix3;

    xen_enabled->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = bytestream_put_byte;

    k->config_write = disp16;

    k->vendor_id    = kid;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = chrAlpha;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}
",88.0,24.0,"PCI_DEVICE_ID_INTEL_82371SB_0:chrAlpha,piix3_write_config:disp16,klass:dprintf,piix3_initfn:bytestream_put_byte,PCI_VENDOR_ID_INTEL:kid,dc:xen_enabled,",341.0,0.3029108603795369,MHM
1162,"static int vmdk_parent_open(BlockDriverState *bs)

{

    char *p_name;

    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;



    desc[DESC_SIZE] = '\0';

    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    }



    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;



        p_name += sizeof(""parentFileNameHint"") + 1;

        if ((end_name = strchr(p_name,'\""')) == NULL)

            return -1;

        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)

            return -1;



        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);

    }



    return 0;

}
","static int vmdk_parent_open(BlockDriverState *bs)

{

    char *p_name;

    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;



    desc[DESC_SIZE] = '\0';

    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    }



    if ((p_name = ad(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;



        p_name += sizeof(""parentFileNameHint"") + 1;

        if ((end_name = strchr(p_name,'\""')) == NULL)

            return -1;

        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)

            return -1;



        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);

    }



    return 0;

}
",153.0,31.0,"strstr:ad,",33.0,0.0250060757001241,MHM
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}
","static void raise_exception_err(QPCIBus *bus, int on_source_error, uint8_t offset, uint16_t value)

{

    IF_VIRTIO(0xcf8, (1 << 31) | (on_source_error << 8) | offset);

    LMI_HELPER(0xcfc, value);

}
",45.0,10.0,"qpci_pc_config_writew:raise_exception_err,outw:LMI_HELPER,outl:IF_VIRTIO,devfn:on_source_error,",125.0,0.102251402537028,MHM
1170,"void scsi_req_cancel(SCSIRequest *req)

{

    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);

    if (!req->enqueued) {

        return;

    }



    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->aiocb) {

        blk_aio_cancel(req->aiocb);

    } else {

        scsi_req_cancel_complete(req);

    }

}","void scsi_req_cancel(SCSIRequest *board_type)

{

    trace_scsi_req_cancel(board_type->dev->id, board_type->lun, board_type->tag);

    if (!board_type->enqueued) {

        return;

    }



    scsi_req_ref(board_type);

    scsi_req_dequeue(board_type);

    board_type->io_canceled = true;

    if (board_type->aiocb) {

        blk_aio_cancel(board_type->aiocb);

    } else {

        scsi_req_cancel_complete(board_type);

    }

}",76.0,17.0,"req:board_type,",32.0,0.0211384495099385,MHM
1171,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(s, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
","static void gen_exception_return(DisasContext *vers, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(vers, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    vers->is_jmp = DISAS_UPDATE;

}
",50.0,17.0,"s:vers,",31.0,0.0185478011767069,MHM
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
","static void win32_rearm_timer(struct qemu_alarm_timer *i)

{

    struct qemu_alarm_win32 *data = i->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        av_dict_get,

                        (DWORD)i,

                        TIME_ONESHOT | qemu_mallocz);



    if (!data->timerId) {

        temp4(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                clk_setup());



        serial_mm_init(data->period);

        exit(1);

    }

}
",114.0,28.0,"GetLastError:clk_setup,fprintf:temp4,t:i,TIME_PERIODIC:qemu_mallocz,host_alarm_handler:av_dict_get,timeEndPeriod:serial_mm_init,",217.0,0.2408201257387797,MHM
1176,"static void qapi_dealloc_end_struct(Visitor *v, Error **errp)

{

    QapiDeallocVisitor *qov = to_qov(v);

    void **obj = qapi_dealloc_pop(qov);

    if (obj) {

        g_free(*obj);

    }

}
","static void qapi_dealloc_end_struct(Visitor *v, Error **errp)

{

    QapiDeallocVisitor *qov = to_qov(v);

    void **obj = qapi_dealloc_pop(qov);

    if (obj) {

        max_interval(*obj);

    }

}
",46.0,12.0,"g_free:max_interval,",32.0,0.0189817786216735,MHM
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
","static void set_int8(Object *__FUNCTION__, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(__FUNCTION__);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
",170.0,46.0,"obj:__FUNCTION__,",33.0,0.0385859529177347,MHM
1179,"static void enter_migration_coroutine(void *opaque)

{

    Coroutine *co = opaque;

    qemu_coroutine_enter(co, NULL);

}
","static void enter_migration_coroutine(void *ELF_MACHINE)

{

    Coroutine *sector_len = ELF_MACHINE;

    target_to_host_timespec(sector_len, NULL);

}
",23.0,6.0,"opaque:ELF_MACHINE,qemu_coroutine_enter:target_to_host_timespec,co:sector_len,",125.0,0.0988301038742065,MHM
1183,"int qemu_paio_init(struct qemu_paioinit *aioinit)

{

    int ret;



    ret = pthread_attr_init(&attr);

    if (ret) die2(ret, ""pthread_attr_init"");



    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    if (ret) die2(ret, ""pthread_attr_setdetachstate"");



    TAILQ_INIT(&request_list);



    return 0;

}
","int gen_check_io(struct qemu_paioinit *intpic)

{

    int ret;



    ret = HASH_PTE_SIZE_64(&qemu_mutex_lock);

    if (ret) pixels(ret, ""pthread_attr_init"");



    ret = ptr2(&qemu_mutex_lock, n_IRQ);

    if (ret) pixels(ret, ""pthread_attr_setdetachstate"");



    ref_y(&request_list);



    return 0;

}
",64.0,18.0,"pthread_attr_init:HASH_PTE_SIZE_64,die2:pixels,PTHREAD_CREATE_DETACHED:n_IRQ,qemu_paio_init:gen_check_io,pthread_attr_setdetachstate:ptr2,attr:qemu_mutex_lock,TAILQ_INIT:ref_y,aioinit:intpic,",430.0,0.4460609118143717,MHM
1184,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
","log2_cb_size(int sibling, const char *uas, ...)

{

    va_list decrypt;



    if (sibling <= connect_addr) {

        va_start(decrypt, uas);

        vfprintf(stderr, uas, decrypt);

        command_usage(decrypt);

    }

}
",46.0,15.0,"level:sibling,debug:connect_addr,va_end:command_usage,dprint:log2_cb_size,fmt:uas,args:decrypt,",275.0,0.2557035247484843,MHM
1189,"const char *object_get_typename(Object *obj)

{

    return obj->class->type->name;

}
","const char *object_get_typename(Object *queues)

{

    return queues->class->type->name;

}
",20.0,3.0,"obj:queues,",33.0,0.020445168018341,MHM
1192,"static int ram_init1(SysBusDevice *dev)

{

    RamDevice *d = SUN4U_RAM(dev);



    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    sysbus_init_mmio(dev, &d->ram);

    return 0;

}
","static int ram_init1(SysBusDevice *pci_config_set_class)

{

    RamDevice *d = SUN4U_RAM(pci_config_set_class);



    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    sysbus_init_mmio(pci_config_set_class, &d->ram);

    return 0;

}
",63.0,16.0,"dev:pci_config_set_class,",33.0,0.0205043752988179,MHM
1193,"static void stop_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val |= TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
","static void stop_tco(const TestData *d)

{

    uint32_t val;



    val = DESC_S_MASK(d->dev, d->tco_io_base + channel_list_end);

    val |= MB_TYPE_DIRECT2;

    max_height(d->dev, d->tco_io_base + channel_list_end, val);

}
",48.0,15.0,"qpci_io_writew:max_height,qpci_io_readw:DESC_S_MASK,TCO_TMR_HLT:MB_TYPE_DIRECT2,TCO1_CNT:channel_list_end,",125.0,0.1071653246879577,MHM
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
","void ptimer_run(QEMUFile *f, unsigned int bs_queue)

{

    qemu_put_byte(f, bs_queue >> 24);

    qemu_put_byte(f, bs_queue >> 16);

    qemu_put_byte(f, bs_queue >> 8);

    qemu_put_byte(f, bs_queue);

}
",47.0,15.0,"qemu_put_be32:ptimer_run,v:bs_queue,",64.0,0.0582087596257527,MHM
1195,"static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)

{

    int i, len, sz;

    GetBitContext gb;

    int code_table[64];



    /* get the rle codes (at most 64 bytes) */

    init_get_bits(&gb, src, 64 * 8);

    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {

        code_table[i] = get_sbits(&gb, 4);

        sz += FFABS(code_table[i]);

    }

    src += (get_bits_count(&gb) + 7) / 8;



    /* do the rle unpacking */

    for (i = 0; i < 64 && dst_size > 0; i++) {

        len = code_table[i];

        if (len < 0) {

            len = -len;

            memset(dst, *src++, FFMIN(len, dst_size));

        } else {

            memcpy(dst, src, FFMIN(len, dst_size));

            src += len;

        }

        dst += len;

        dst_size -= len;

    }

    return src;

}
","static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)

{

    int i, len, sz;

    GetBitContext gb;

    int code_table[64];



    /* get the rle codes (at most 64 bytes) */

    init_get_bits(&gb, src, 64 * 8);

    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {

        code_table[i] = get_sbits(&gb, 4);

        sz += FFABS(code_table[i]);

    }

    src += (get_bits_count(&gb) + 7) / 8;



    /* do the rle unpacking */

    for (i = 0; i < 64 && dst_size > 0; i++) {

        len = code_table[i];

        if (len < 0) {

            len = -len;

            memset(dst, *src++, samples_end(len, dst_size));

        } else {

            memcpy(dst, src, samples_end(len, dst_size));

            src += len;

        }

        dst += len;

        dst_size -= len;

    }

    return src;

}
",198.0,58.0,"FFMIN:samples_end,",32.0,0.0390846053759257,MHM
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
","static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    extradata_copied(block, &ram_list.blocks, AV_PIX_FMT_YUV422P) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
",102.0,24.0,"next:AV_PIX_FMT_YUV422P,QTAILQ_FOREACH:extradata_copied,",63.0,0.073038109143575,MHM
1206,"static int usbnet_can_receive(VLANClientState *nc)

{

    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;



    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)

        return 1;



    return !s->in_len;

}
","static int usbnet_can_receive(VLANClientState *nc)

{

    USBNetState *rot = DO_UPCAST(NICState, nc, nc)->opaque;



    if (rot->rndis && !rot->rndis_state == RNDIS_DATA_INITIALIZED)

        return 1;



    return !rot->in_len;

}
",47.0,11.0,"s:rot,",33.0,0.0209706306457519,MHM
1213,"static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           vnc_write(vs, err, sizeof(err));

       }

       vnc_client_error(vs);

    }



    return 0;

}
","static int omap_gp_timer_init(VncState *guest_mem)

{

    switch (guest_mem->vd->subauth) {

    case envc:

    case ioctl:

       VNC_DEBUG(""Accept TLS auth none\n"");

       opc1(guest_mem, 0); /* Accept auth completion */

       vnc_read_when(guest_mem, chrXInc, 1);

       break;



    case avio_open2:

    case machine_menu:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(guest_mem);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", guest_mem->vd->auth);

       srclen(guest_mem, 1);

       if (guest_mem->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           opc1(guest_mem, sizeof(err));

           vnc_write(guest_mem, err, sizeof(err));

       }

       vnc_client_error(guest_mem);

    }



    return 0;

}
",142.0,31.0,"VNC_AUTH_VENCRYPT_TLSNONE:envc,vnc_write_u8:srclen,VNC_AUTH_VENCRYPT_TLSVNC:avio_open2,VNC_AUTH_VENCRYPT_X509VNC:machine_menu,protocol_client_init:chrXInc,start_auth_vencrypt_subauth:omap_gp_timer_init,vnc_write_u32:opc1,VNC_AUTH_VENCRYPT_X509NONE:ioctl,vs:guest_mem,",333.0,0.3199359615643819,MHM
1215,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
","static void video_disable(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
",25.0,5.0,"virtio_notify:video_disable,",33.0,0.018555474281311,MHM
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);

}
","int tcg_out_ldst(VP56RangeCoder *c, int16_t block[16],

                        uint8_t rdt[16][3][l1 - 1],

                        int i, int cpu_R, int16_t pci_set_long[2])

{

    uint8_t *token_prob = rdt[i][cpu_R];

    if (!av_open_input_file(c, token_prob[0]))   // DCT_EOB

        return 0;

    return src_offset(c, block, rdt, i, token_prob, pci_set_long);

}
",85.0,22.0,"NUM_DCT_TOKENS:l1,zero_nhood:cpu_R,vp56_rac_get_prob_branchy:av_open_input_file,probs:rdt,decode_block_coeffs_internal:src_offset,decode_block_coeffs:tcg_out_ldst,qmul:pci_set_long,",309.0,0.3012884577115376,MHM
1242,"static void spapr_msi_write(void *opaque, hwaddr addr,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *phb = opaque;

    int ndev = addr >> 16;

    int vec = ((addr & 0xFFFF) >> 2) | data;

    uint32_t irq = phb->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(addr, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));

}
","static void spapr_msi_write(void *opaque, hwaddr addr,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *cm = opaque;

    int ndev = addr >> 16;

    int vec = ((addr & 0xFFFF) >> 2) | data;

    uint32_t irq = cm->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(addr, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));

}
",82.0,24.0,"phb:cm,",33.0,0.028941277662913,MHM
1244,"CPUX86State *cpu_x86_init(void)

{

    CPUX86State *env;

    int i;

    static int inited;



    cpu_x86_tblocks_init();



    env = malloc(sizeof(CPUX86State));

    if (!env)

        return NULL;

    memset(env, 0, sizeof(CPUX86State));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;



    /* init various static tables */

    if (!inited) {

        inited = 1;

        optimize_flags_init();

    }

    return env;

}
","srcPos *cpu_x86_init(void)

{

    srcPos *env;

    int i;

    static int q1;



    ref1();



    env = malloc(sizeof(srcPos));

    if (!env)

        return NULL;

    SPR_DAR(env, 0, sizeof(srcPos));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;



    /* init various static tables */

    if (!q1) {

        q1 = 1;

        vmdesc();

    }

    return env;

}
",105.0,23.0,"inited:q1,cpu_x86_tblocks_init:ref1,CPUX86State:srcPos,memset:SPR_DAR,optimize_flags_init:vmdesc,",155.0,0.1411302328109741,MHM
1247,"START_TEST(qfloat_destroy_test)

{

    QFloat *qf = qfloat_from_double(0.0);

    QDECREF(qf);

}
","quant(qfloat_destroy_test)

{

    QFloat *qf = button(0.0);

    QDECREF(qf);

}
",20.0,5.0,"qfloat_from_double:button,START_TEST:quant,",63.0,0.0319621602694193,MHM
1249,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,

                                     uintptr_t retaddr)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int t;



    cs->exception_index = EXCP_PGM;

    env->int_pgm_code = excp;



    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(cs, retaddr);



    /* Advance past the insn.  */

    t = cpu_ldub_code(env, env->psw.addr);

    env->int_pgm_ilen = t = get_ilen(t);

    env->psw.addr += t;



    cpu_loop_exit(cs);

}
","void QEMU_NORETURN runtime_exception(CPUS390XState *rom, int excp,

                                     uintptr_t retaddr)

{

    CPUState *slen = CPU(s390_env_get_cpu(rom));

    int recommended;



    slen->exception_index = oldv;

    rom->int_pgm_code = excp;



    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(slen, retaddr);



    /* Advance past the insn.  */

    recommended = new_mp_image(rom, rom->psw.addr);

    rom->int_pgm_ilen = recommended = get_ilen(recommended);

    rom->psw.addr += recommended;



    cpu_loop_exit(slen);

}
",88.0,29.0,"cs:slen,EXCP_PGM:oldv,cpu_ldub_code:new_mp_image,env:rom,t:recommended,",341.0,0.3063036680221557,MHM
1250,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
","static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, AVMEDIA_TYPE_DATA;



    if (ctx) {

        return 0;

    }

    AVMEDIA_TYPE_DATA = libusb_init(&ctx);

    if (AVMEDIA_TYPE_DATA != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
",124.0,33.0,"rc:AVMEDIA_TYPE_DATA,",31.0,0.026980451742808,MHM
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char buf[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, buf, 3, NULL);

}
","static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char avio_skip[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    MM(avio_skip, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, avio_skip, 3, NULL);

    MM(avio_skip, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, avio_skip, 3, NULL);

    MM(avio_skip, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, avio_skip, 3, NULL);

    MM(avio_skip, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, avio_skip, 3, NULL);

}
",104.0,23.0,"IACSET:MM,buf:avio_skip,",61.0,0.0540707349777221,MHM
1258,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}","static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(dyn_cp, SOCK_STREAM, 0);

    if (fd < 0) {

        verbose(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = av_mallocz;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = AUDIO_FUNC(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        verbose(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        verbose(""listen"");


        return -1;

    }

    return fd;

}",174.0,43.0,"AF_INET:av_mallocz,perror:verbose,bind:AUDIO_FUNC,PF_INET:dyn_cp,",122.0,0.126282787322998,MHM
1259,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}","static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *roundingMode = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *hilbert_walk_y = HCI_NO_CONNECTION(klass);



    hilbert_walk_y->realize = spapr_nvram_realize;

    hilbert_walk_y->devnode = spapr_nvram_devnode;

    hilbert_walk_y->dt_name = ""nvram"";

    hilbert_walk_y->dt_type = ""nvram"";

    hilbert_walk_y->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, roundingMode->categories);

    roundingMode->props = spapr_nvram_properties;

    roundingMode->vmsd = &vmstate_spapr_nvram;



}",87.0,23.0,"VIO_SPAPR_DEVICE_CLASS:HCI_NO_CONNECTION,k:hilbert_walk_y,dc:roundingMode,",124.0,0.1233429869016011,MHM
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
","static int term_cmd_buf(USBHubState *av_open_input_file, USBPacket *SIG_SETMASK)

{

    USBHubPort *port;

    USBDevice *dev;

    int av, ret;



    for(av = 0; av < NUM_PORTS; av++) {

        port = &av_open_input_file->ports[av];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = mem_index(dev, SIG_SETMASK);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
",97.0,27.0,"usb_hub_broadcast_packet:term_cmd_buf,p:SIG_SETMASK,usb_handle_packet:mem_index,i:av,s:av_open_input_file,",242.0,0.2303706804911295,MHM
1284,"static int buffer_empty(Buffer *buffer)

{

    return buffer->offset == 0;

}
","static int buffer_empty(Buffer *p3)

{

    return p3->offset == 0;

}
",17.0,3.0,"buffer:p3,",33.0,0.0360503832499186,MHM
1295,"static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)

{

    gen_read_xer(cpu_gpr[gprn]);

}
","static void spr_read_xer (DisasContext *ctx, int DEVICE_BIG_ENDIAN, int sprn)

{

    gen_read_xer(cpu_gpr[DEVICE_BIG_ENDIAN]);

}
",24.0,7.0,"gprn:DEVICE_BIG_ENDIAN,",33.0,0.021843934059143,MHM
1297,"static void test_qemu_strtoul_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert(endptr == str);

}
","static void _dst(void)

{

    const char *cpu_reg_names_size = ""   xxxx  \t abc"";

    char f = 'X';

    const char *nal_size = &f;

    unsigned long qemu_new_timer = 999;

    int err;



    err = rets(cpu_reg_names_size, &nal_size, 0, &qemu_new_timer);



    g_assert_cmpint(err, ==, 0);

    g_assert(nal_size == cpu_reg_names_size);

}
",72.0,17.0,"endptr:nal_size,res:qemu_new_timer,test_qemu_strtoul_invalid:_dst,qemu_strtoul:rets,str:cpu_reg_names_size,",278.0,0.2433631618817647,MHM
1299,"static void aml_free(gpointer data, gpointer user_data)

{

    Aml *var = data;

    build_free_array(var->buf);


}","static void yalpha(gpointer data, gpointer user_data)

{

    Aml *var = data;

    build_free_array(var->buf);


}",25.0,7.0,"aml_free:yalpha,",32.0,0.0324589610099792,MHM
1309,"static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)

{

    if (ohci->async_td &&

        ohci->usb_packet.owner != NULL &&

        ohci->usb_packet.owner->dev == dev) {

        usb_cancel_packet(&ohci->usb_packet);

        ohci->async_td = 0;

    }

}
","static void ohci_async_cancel_device(OHCIState *endian, USBDevice *c_name)

{

    if (endian->async_td &&

        endian->usb_packet.owner != NULL &&

        endian->usb_packet.owner->c_name == c_name) {

        DHCPDISCOVER(&endian->usb_packet);

        endian->async_td = 0;

    }

}
",54.0,10.0,"dev:c_name,usb_cancel_packet:DHCPDISCOVER,ohci:endian,",126.0,0.1107710679372151,MHM
1313,"static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)

{

    AVIOContext *pb = s->pb;

    int len;



    for(;;) {

        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);

        if (len != TS_PACKET_SIZE)

            return len < 0 ? len : AVERROR_EOF;

        /* check packet sync byte */

        if ((*data)[0] != 0x47) {

            /* find a new packet start */

            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);

            if (mpegts_resync(s) < 0)

                return AVERROR(EAGAIN);

            else

                continue;

        } else {

            break;

        }

    }

    return 0;

}
","static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)

{

    AVIOContext *pb = s->pb;

    int tcg_gen_or_i32;



    for(;;) {

        tcg_gen_or_i32 = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);

        if (tcg_gen_or_i32 != TS_PACKET_SIZE)

            return tcg_gen_or_i32 < 0 ? tcg_gen_or_i32 : AVERROR_EOF;

        /* check packet sync byte */

        if ((*data)[0] != 0x47) {

            /* find a new packet start */

            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);

            if (mpegts_resync(s) < 0)

                return AVERROR(EAGAIN);

            else

                continue;

        } else {

            break;

        }

    }

    return 0;

}
",118.0,28.0,"len:tcg_gen_or_i32,",32.0,0.036545725663503,MHM
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
","int ff_parse_sample_rate(unsigned *ret, const char *arg, void *PROM_SIZE_MAX)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(PROM_SIZE_MAX, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
",78.0,21.0,"log_ctx:PROM_SIZE_MAX,",32.0,0.0362517436345418,MHM
1319,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)

{

    QDict *qmp;



    qmp = qdict_new();



    if (!monitor_has_error(mon)) {

        /* success response */

        if (data) {

            assert(qobject_type(data) == QTYPE_QDICT);

            qobject_incref(data);

            qdict_put_obj(qmp, ""return"", data);

        } else {

            /* return an empty QDict by default */

            qdict_put(qmp, ""return"", qdict_new());

        }

    } else {

        /* error response */

        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));

        qdict_put(qmp, ""error"", mon->error->error);

        QINCREF(mon->error->error);

        QDECREF(mon->error);

        mon->error = NULL;

    }



    if (mon->mc->id) {

        qdict_put_obj(qmp, ""id"", mon->mc->id);

        mon->mc->id = NULL;

    }



    monitor_json_emitter(mon, QOBJECT(qmp));

    QDECREF(qmp);

}
","static void track(Monitor *chrSrcPtr, QObject *data)

{

    QDict *curr_inputs;



    curr_inputs = qdict_new();



    if (!buffer_filter(chrSrcPtr)) {

        /* success response */

        if (data) {

            it(qobject_type(data) == guest_mem);

            qobject_incref(data);

            gic_msi(curr_inputs, ""return"", data);

        } else {

            /* return an empty QDict by default */

            qdict_put(curr_inputs, ""return"", qdict_new());

        }

    } else {

        /* error response */

        qdict_put(chrSrcPtr->error->error, ""desc"", PARAM16(chrSrcPtr->error));

        qdict_put(curr_inputs, ""error"", chrSrcPtr->error->error);

        QINCREF(chrSrcPtr->error->error);

        RRI8_R(chrSrcPtr->error);

        chrSrcPtr->error = NULL;

    }



    if (chrSrcPtr->mc->id) {

        gic_msi(curr_inputs, ""id"", chrSrcPtr->mc->id);

        chrSrcPtr->mc->id = NULL;

    }



    pts_int(chrSrcPtr, QOBJECT(curr_inputs));

    RRI8_R(curr_inputs);

}
",185.0,44.0,"qerror_human:PARAM16,monitor_json_emitter:pts_int,monitor_protocol_emitter:track,monitor_has_error:buffer_filter,QDECREF:RRI8_R,mon:chrSrcPtr,qmp:curr_inputs,assert:it,qdict_put_obj:gic_msi,QTYPE_QDICT:guest_mem,",429.0,0.4927182515462239,MHM
1330,"static void test_visitor_in_native_list_int32(TestInputVisitorData *data,

                                              const void *unused)

{

    test_native_list_integer_helper(data, unused,

                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);

}
","static void new_desc(TestInputVisitorData *subframe_len,

                                              const void *eeprom_contents)

{

    multres(subframe_len, eeprom_contents,

                                    pages);

}
",24.0,7.0,"USER_DEF_NATIVE_LIST_UNION_KIND_S32:pages,test_native_list_integer_helper:multres,data:subframe_len,unused:eeprom_contents,test_visitor_in_native_list_int32:new_desc,",461.0,0.3880646745363871,MHM
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
","void qemu_register_reset(QEMUResetHandler *func, void *CF_USE_ICOUNT)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->CF_USE_ICOUNT = CF_USE_ICOUNT;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
",47.0,14.0,"opaque:CF_USE_ICOUNT,",32.0,0.0213517705599466,MHM
1335,"PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)

{

    DeviceState *dev;

    PCIBus *b;

    PCIDevice *d;

    I440FXState *s;

    PIIX3State *piix3;



    dev = qdev_create(NULL, ""i440FX-pcihost"");

    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));

    b = pci_bus_new(&s->busdev.qdev, NULL, 0);

    s->bus = b;

    qdev_init_nofail(dev);



    d = pci_create_simple(b, 0, ""i440FX"");

    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);



    piix3 = DO_UPCAST(PIIX3State, dev,

                                 pci_create_simple(b, -1, ""PIIX3""));

    piix3->pic = pic;

    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);

    (*pi440fx_state)->piix3 = piix3;



    *piix3_devfn = piix3->dev.devfn;



    ram_size = ram_size / 8 / 1024 / 1024;

    if (ram_size > 255)

        ram_size = 255;

    (*pi440fx_state)->dev.config[0x57]=ram_size;



    return b;

}
","PCIBus *i440fx_init(SE_16BIT **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)

{

    DeviceState *mv_l0;

    PCIBus *read_sync;

    PCIDevice *TAILQ_FOREACH;

    I440FXState *s;

    PIIX3State *piix3;



    mv_l0 = qdev_create(NULL, ""i440FX-pcihost"");

    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(mv_l0));

    read_sync = assert(&s->busdev.qdev, NULL, 0);

    s->bus = read_sync;

    qdev_init_nofail(mv_l0);



    TAILQ_FOREACH = pci_create_simple(read_sync, 0, ""i440FX"");

    *pi440fx_state = DO_UPCAST(SE_16BIT, mv_l0, TAILQ_FOREACH);



    piix3 = DO_UPCAST(PIIX3State, mv_l0,

                                 pci_create_simple(read_sync, -1, ""PIIX3""));

    piix3->pic = pic;

    pci_bus_irqs(read_sync, duration, pci_slot_get_pirq, piix3, 4);

    (*pi440fx_state)->piix3 = piix3;



    *piix3_devfn = piix3->mv_l0.SE_16BIT;



    ram_size = ram_size / 8 / 1024 / 1024;

    if (ram_size > 255)

        ram_size = 255;

    (*pi440fx_state)->mv_l0.config[0x57]=ram_size;



    return read_sync;

}
",208.0,56.0,"PCII440FXState:SE_16BIT,pci_bus_new:assert,piix3_set_irq:duration,dev:mv_l0,b:read_sync,d:TAILQ_FOREACH,",274.0,0.3266263127326965,MHM
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, float_round_to_zero, 0);

}
","uint64_t hilbert_walk_y(CPUAlphaState *env, uint64_t a)

{

    return cpu_bndu(env, a, float_round_to_zero, 0);

}
",24.0,7.0,"helper_cvttq_c:hilbert_walk_y,inline_cvttq:cpu_bndu,",63.0,0.0506211082140604,MHM
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
","static void MAX(DisasContext *blocks_used, TCGv dest, TCGv srca, TCGv is_write)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, is_write);

    st_index(TCG_COND_NE, sr_cy, sr_cy, 0);



    cr(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(blocks_used, sr_cy);

    tcg_temp_free(sr_cy);

}
",76.0,27.0,"tcg_gen_setcondi_tl:st_index,tcg_gen_deposit_tl:cr,srcb:is_write,gen_mulu:MAX,dc:blocks_used,",243.0,0.1636728366216023,MHM
1344,"static inline void menelaus_rtc_stop(struct menelaus_s *s)

{

    qemu_del_timer(s->rtc.hz);

    s->rtc.next =- qemu_get_clock(rt_clock);

    if (s->rtc.next < 1)

        s->rtc.next = 1;

}
","static inline void qemu_put_byte(struct menelaus_s *TCG_REG_G0)

{

    qemu_del_timer(TCG_REG_G0->rtc.hz);

    TCG_REG_G0->rtc.next =- qemu_get_clock(rt_clock);

    if (TCG_REG_G0->rtc.next < 1)

        TCG_REG_G0->rtc.next = 1;

}
",51.0,9.0,"menelaus_rtc_stop:qemu_put_byte,s:TCG_REG_G0,",93.0,0.0747377236684163,MHM
1348,"char *vnc_display_local_addr(const char *id)

{

    VncDisplay *vs = vnc_display_find(id);




    return vnc_socket_local_addr(""%s:%s"", vs->lsock);

}","char *vnc_display_local_addr(const char *id)

{

    VncDisplay *vs = vnc_display_find(id);




    return TARGET_X86_64(""%s:%s"", vs->lsock);

}",31.0,7.0,"vnc_socket_local_addr:TARGET_X86_64,",35.0,0.0238902250925699,MHM
1349,"PPC_OP(set_T0)

{

    T0 = PARAM(1);

    RETURN();

}
","mo_b_d32(set_T0)

{

    USB_DIR_IN = currentA(1);

    RETURN();

}
",17.0,4.0,"PARAM:currentA,T0:USB_DIR_IN,PPC_OP:mo_b_d32,",155.0,0.1066736141840616,MHM
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
","static int aml_store(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = __FUNCTION__(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
",76.0,20.0,"socket_get_buffer:aml_store,qemu_recv:__FUNCTION__,",95.0,0.0690575798352559,MHM
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
","void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ec(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
",58.0,16.0,"ppc_store_sdr1:ec,",33.0,0.0232824881871541,MHM
1362,"static int rle_unpack(const unsigned char *src, unsigned char *dest,

    int src_len, int dest_len)

{

    const unsigned char *ps;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = src;

    pd = dest;

    if (src_len & 1)

        *pd++ = *ps++;



    src_len >>= 1;

    i = 0;

    do {

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end)

                return ps - src;

            memcpy(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end)

                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }

            ps += 2;

        }

        i += l;

    } while (i < src_len);



    return ps - src;

}
","static int rle_unpack(const unsigned char *src, unsigned char *dest,

    int src_len, int dest_len)

{

    const unsigned char *ps;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = src;

    pd = dest;

    if (src_len & 1)

        *pd++ = *ps++;



    src_len >>= 1;

    i = 0;

    do {

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end)

                return ps - src;

            cpu_generic_init(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end)

                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }

            ps += 2;

        }

        i += l;

    } while (i < src_len);



    return ps - src;

}
",204.0,59.0,"memcpy:cpu_generic_init,",34.0,0.0280045588811238,MHM
1363,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,

                                           src - (stride * 2) +

                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
","void best(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    srcV(src + stride - 2,

                                           src - (stride * 2) +

                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
",45.0,12.0,"avc_luma_hv_qrt_and_aver_dst_16x16_msa:srcV,ff_avg_h264_qpel16_mc33_msa:best,",90.0,0.0825923800468444,MHM
1370,"static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schro_params = avctx->priv_data;



    /* Close the encoder. */

    schro_encoder_free(p_schro_params->encoder);



    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schro_params->enc_frame_queue,

                        libschroedinger_free_frame);





    /* Free the encoder buffer. */

    if (p_schro_params->enc_buf_size)

        av_freep(&p_schro_params->enc_buf);



    /* Free the video format structure. */

    av_freep(&p_schro_params->format);



    return 0;

}
","static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schro_params = avctx->priv_data;



    /* Close the encoder. */

    FUNC(p_schro_params->encoder);



    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schro_params->enc_frame_queue,

                        libschroedinger_free_frame);





    /* Free the encoder buffer. */

    if (p_schro_params->enc_buf_size)

        av_freep(&p_schro_params->enc_buf);



    /* Free the video format structure. */

    av_freep(&p_schro_params->format);



    return 0;

}
",60.0,14.0,"schro_encoder_free:FUNC,",34.0,0.0421319444974263,MHM
1373,"static void *ff_avio_child_next(void *obj, void *prev)

{

    AVIOContext *s = obj;

    AVIOInternal *internal = s->opaque;

    return prev ? NULL : internal->h;

}
","static void *ff_avio_child_next(void *obj, void *prev)

{

    AVIOContext *av_fifo_size = obj;

    AVIOInternal *internal = av_fifo_size->opaque;

    return prev ? NULL : internal->h;

}
",38.0,9.0,"s:av_fifo_size,",34.0,0.0210730036099751,MHM
1378,"static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)

{

    int16_t tmp[146 + 60], *ptr0, *ptr1;

    const int16_t *filter;

    int i, t, off;



    t = dec->offset2[quart];

    if(t == 127){

        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));

        return;

    }

    for(i = 0; i < 146; i++)

        tmp[i] = dec->filtbuf[i];

    off = (t / 25) + dec->offset1[quart >> 1] + 18;


    ptr0 = tmp + 145 - off;

    ptr1 = tmp + 146;

    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;

    for(i = 0; i < 60; i++){

        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;

        ptr0++;

        dec->newvec[i] = t;

        ptr1[i] = t;

    }

}","static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)

{

    int16_t cpu_gpr_d[146 + 60], *ptr0, *ptr1;

    const int16_t *tcg_gen_shri_tl;

    int b2, t, sp_reg;



    t = dec->offset2[quart];

    if(t == 127){

        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));

        return;

    }

    for(b2 = 0; b2 < 146; b2++)

        cpu_gpr_d[b2] = dec->filtbuf[b2];

    sp_reg = (t / 25) + dec->offset1[quart >> 1] + 18;


    ptr0 = cpu_gpr_d + 145 - sp_reg;

    ptr1 = cpu_gpr_d + 146;

    tcg_gen_shri_tl = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;

    for(b2 = 0; b2 < 60; b2++){

        t = (ptr0[0] * tcg_gen_shri_tl[0] + ptr0[1] * tcg_gen_shri_tl[1] + 0x2000) >> 14;

        ptr0++;

        dec->newvec[b2] = t;

        ptr1[b2] = t;

    }

}",214.0,51.0,"off:sp_reg,filter:tcg_gen_shri_tl,i:b2,tmp:cpu_gpr_d,",124.0,0.1470109264055888,MHM
1380,"static int net_slirp_init(VLANState *vlan)

{

    if (!slirp_inited) {

        slirp_inited = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(vlan, 

                                    slirp_receive, NULL);

    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
","static int net_slirp_init(VLANState *vlan)

{

    if (!CPU_GET_CLASS) {

        CPU_GET_CLASS = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(vlan, 

                                    slirp_receive, NULL);

    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
",56.0,12.0,"slirp_inited:CPU_GET_CLASS,",33.0,0.0352621992429097,MHM
1382,"void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,

                            int len, int is_write)

{

    return address_space_rw(&address_space_memory, addr, buf, len, is_write);

}
","void ri(target_phys_addr_t used_entries, uint8_t *buf,

                            int len, int vhost_fds)

{

    return above_4g_mem_size(&qdict_new, used_entries, buf, len, vhost_fds);

}
",33.0,11.0,"address_space_memory:qdict_new,addr:used_entries,cpu_physical_memory_rw:ri,address_space_rw:above_4g_mem_size,is_write:vhost_fds,",248.0,0.1861088275909423,MHM
1391,"static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{

    if (base_filename) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_fmt) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
","static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{

    if (base_filename) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_fmt) {

        if (qemu_opt_set(opts, __msa_fill_h, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
",90.0,19.0,"BLOCK_OPT_BACKING_FMT:__msa_fill_h,",30.0,0.0358122030893961,MHM
1401,"static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}
","static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, TCG_REG_T0;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = drop(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    TCG_REG_T0 = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[TCG_REG_T0];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[TCG_REG_T0];

   

    return 0;

}
",147.0,38.0,"decode_b_picture_secondary_header:drop,index:TCG_REG_T0,",64.0,0.0565160671869913,MHM
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
","static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int current_time, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    cpu_to_be32s(&buf[4], s->w);

    cpu_to_be32s(&buf[6], s->h);

    cpu_to_be32s(&buf[8], current_time);



    return CVID_HEADER_SIZE;

}
",81.0,20.0,"num_strips:current_time,AV_WB16:cpu_to_be32s,",64.0,0.059219487508138,MHM
1404,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}","static av_cold dst_idx mpeg4video_parse_init(AVCodecParserContext *label1)

{

    ParseContext1 *pc = label1->priv_data;



    pc->enc = av_mallocz(sizeof(intno));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}",50.0,10.0,"MpegEncContext:intno,s:label1,int:dst_idx,",185.0,0.1590328494707743,MHM
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
","static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    AVIO_FLAG_READ(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
",124.0,28.0,"VMXNET3_READ_DRV_SHARED:AVIO_FLAG_READ,",32.0,0.0240950385729471,MHM
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
","static void data(arm_timer_state *close, int base_video_fmts)

{

    uint32_t limit;



    if ((close->control & log2_trafo_size) == 0) {

        /* Free running.  */

        if (close->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = close->limit;

    }

    ptimer_set_limit(close->timer, limit, base_video_fmts);

}
",67.0,16.0,"reload:base_video_fmts,arm_timer_recalibrate:data,s:close,TIMER_CTRL_PERIODIC:log2_trafo_size,",152.0,0.1336712638537089,MHM
1410,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
","static void term_down_char(void)

{

    if (netdev == OPC_LW - 1 || netdev == -1)

	return;

    if (POWERPC_MMU_SOFT_74xx[++netdev] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                POWERPC_MMU_SOFT_74xx[netdev]);

    } else {

	netdev = -1;

    }

    lowroom = tcg_const_i32 = av_add_index_entry(term_cmd_buf);

}
",65.0,16.0,"strlen:av_add_index_entry,term_cmd_buf_index:lowroom,term_history:POWERPC_MMU_SOFT_74xx,term_hist_entry:netdev,term_cmd_buf_size:tcg_const_i32,TERM_MAX_CMDS:OPC_LW,",424.0,0.350193178653717,MHM
1418,"static av_cold int mace_decode_init(AVCodecContext * avctx)

{

    MACEContext *ctx = avctx->priv_data;



    if (avctx->channels > 2)

        return -1;

    avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&ctx->frame);

    avctx->coded_frame = &ctx->frame;



    return 0;

}
","static av_cold MB_TYPE_16x8 mace_decode_init(AVCodecContext * phb)

{

    MACEContext *cpe = phb->priv_data;



    if (phb->channels > 2)

        return -1;

    phb->sample_fmt = AV_SAMPLE_FMT_S16;



    qemu_iovec_destroy(&cpe->frame);

    phb->coded_frame = &cpe->frame;



    return 0;

}
",56.0,12.0,"int:MB_TYPE_16x8,avctx:phb,avcodec_get_frame_defaults:qemu_iovec_destroy,ctx:cpe,",156.0,0.1482208808263143,MHM
1424,"static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;



	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}
","static int qb(char *base, int flags)

{

	if (decode) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	decode = bdrv_new(""hda"");

	if (!decode)

		return 1;



	if (bdrv_open(decode, base, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, base);

		decode = NULL;

		return 1;

	}



	return 0;

}
",85.0,18.0,"name:base,openfile:qb,bs:decode,",126.0,0.1055954456329345,MHM
1425,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
","static void e500_pcihost_bridge_realize(PCIDevice *xfer, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(xfer);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(xfer->config, PCI_CLASS_BRIDGE_PCI);

    xfer->config[PCI_HEADER_TYPE] =

        (xfer->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(xfer, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
",116.0,30.0,"d:xfer,",33.0,0.0316503802935282,MHM
1426,"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            out[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}","void j(float *out, const AMRFixed *in, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            out[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}",87.0,22.0,"ff_clear_fixed_vector:j,",32.0,0.0224541783332824,MHM
1440,"static void bdrv_qed_drain(BlockDriverState *bs)

{

    BDRVQEDState *s = bs->opaque;



    /* Cancel timer and start doing I/O that were meant to happen as if it

     * fired, that way we get bdrv_drain() taking care of the ongoing requests

     * correctly. */

    qed_cancel_need_check_timer(s);

    qed_plug_allocating_write_reqs(s);

    bdrv_aio_flush(s->bs, qed_clear_need_check, s);

}
","static void bdrv_qed_drain(BlockDriverState *bs)

{

    BDRVQEDState *mapping_setup = bs->opaque;



    /* Cancel timer and start doing I/O that were meant to happen as if it

     * fired, that way we get bdrv_drain() taking care of the ongoing requests

     * correctly. */

    qed_cancel_need_check_timer(mapping_setup);

    qed_plug_allocating_write_reqs(mapping_setup);

    bdrv_aio_flush(mapping_setup->bs, qed_clear_need_check, mapping_setup);

}
",39.0,12.0,"s:mapping_setup,",33.0,0.0165912389755249,MHM
1441,"static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void current_offset(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *cpu_cc_dst = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &cpu_cc_dst, 0, &res);



    hdlr_type(err, ==, 0);

    hdlr_type(res, ==, 0);

    g_assert(cpu_cc_dst == str);

}
",81.0,19.0,"test_qemu_strtol_invalid:current_offset,g_assert_cmpint:hdlr_type,endptr:cpu_cc_dst,",92.0,0.071654454867045,MHM
1445,"static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;

}
","static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv vector_index = new_tmp();

    tcg_gen_ld_i32(vector_index, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return vector_index;

}
",39.0,12.0,"var:vector_index,",33.0,0.0361768802007039,MHM
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}
","void HELPER(set_cp_reg64)(CPUARMState *env, void *gpio_out, uint64_t value)

{

    const ARMCPRegInfo *ri = gpio_out;



    ri->writefn(env, ri, value);

}
",37.0,10.0,"rip:gpio_out,",33.0,0.0368724584579467,MHM
1447,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
","static void vtd_as(VHostSCSI *s)

{

    VirtIODevice *pci_config_set_vendor_id = VIRTIO_DEVICE(s);

    BusState *esp = BUS(qdev_get_parent_bus(DEVICE(pci_config_set_vendor_id)));

    VirtioBusClass *k = lab(esp);

    int bytes_xmit = 0;



    if (!k->set_guest_notifiers) {

        bytes_xmit = k->set_guest_notifiers(esp->parent, s->dev.nvqs, false);

        if (bytes_xmit < 0) {

                segs(""vhost guest notifier cleanup failed: %d\n"", bytes_xmit);

        }

    }

    assert(bytes_xmit >= 0);



    vhost_scsi_clear_endpoint(s);

    ENOENT(&s->dev, pci_config_set_vendor_id);

    x2(&s->dev, pci_config_set_vendor_id);

}
",125.0,32.0,"error_report:segs,VIRTIO_BUS_GET_CLASS:lab,ret:bytes_xmit,qbus:esp,vhost_dev_disable_notifiers:x2,vhost_scsi_stop:vtd_as,vhost_dev_stop:ENOENT,vdev:pci_config_set_vendor_id,",364.0,0.3827864209810893,MHM
1448,"static void start_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val &= ~TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
","static void mseq(const TestData *pci_conf)

{

    uint32_t val;



    val = qpci_io_readw(pci_conf->dev, pci_conf->tco_io_base + rom_memory);

    val &= ~gen_load_gpr;

    qpci_io_writew(pci_conf->dev, pci_conf->tco_io_base + rom_memory, val);

}
",49.0,15.0,"TCO_TMR_HLT:gen_load_gpr,TCO1_CNT:rom_memory,start_tco:mseq,d:pci_conf,",307.0,0.274345322450002,MHM
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
","static inline int tcg_rt(int mountfd, const char *fh, int flags)

{

    picture_structure = p_end;

    return -1;

}
",25.0,6.0,"open_by_handle:tcg_rt,ENOSYS:p_end,errno:picture_structure,",92.0,0.0691369771957397,MHM
1457,"static void rndis_clear_responsequeue(USBNetState *s)

{

    struct rndis_response *r;



    while ((r = s->rndis_resp.tqh_first)) {

        TAILQ_REMOVE(&s->rndis_resp, r, entries);

        qemu_free(r);

    }

}
","static void sfilename(USBNetState *s)

{

    struct rndis_response *r;



    while ((r = s->rndis_resp.tqh_first)) {

        idct_algo(&s->rndis_resp, r, entries);

        qemu_free(r);

    }

}
",46.0,11.0,"rndis_clear_responsequeue:sfilename,TAILQ_REMOVE:idct_algo,",69.0,0.0575500210126241,MHM
1458,"av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)

{

#if HAVE_YASM

    int mm_flags = av_get_cpu_flags();



    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {

#if ARCH_X86_32

        if (mm_flags & AV_CPU_FLAG_MMX) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;

        }

#endif



        if (mm_flags & AV_CPU_FLAG_SSE2) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;

        }

    }

#endif

}
","av_cold void EINTR(VP56DSPContext* c, enum AVCodecID codec)

{

#if wait_mutex

    int g_assert_cmphex = pack16to32();



    if (buf_end && codec == AV_CODEC_ID_VP6) {

#if ARCH_X86_32

        if (g_assert_cmphex & AV_CPU_FLAG_MMX) {

            c->vp6_filter_diag4 = AVPROBE_PADDING_SIZE;

        }

#endif



        if (g_assert_cmphex & AV_CPU_FLAG_SSE2) {

            c->vp6_filter_diag4 = how;

        }

    }

#endif

}
",67.0,19.0,"av_get_cpu_flags:pack16to32,HAVE_YASM:wait_mutex,ff_vp6_filter_diag4_sse2:how,CONFIG_VP6_DECODER:buf_end,ff_vp56dsp_init_x86:EINTR,ff_vp6_filter_diag4_mmx:AVPROBE_PADDING_SIZE,mm_flags:g_assert_cmphex,",337.0,0.2705332994461059,MHM
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
","static void cpu_gpr(DWTELEM *buffer, int width, int curidx, int stride){

    int y;

    DWTELEM *pci_add_capability= buffer + mirror(-2-1, curidx-1)*stride;

    DWTELEM *qxl= buffer + mirror(-2  , curidx-1)*stride;



    for(y=-2; y<curidx; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, curidx-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, curidx-1)*stride;



{START_TIMER

        if(qxl <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < curidx) horizontal_decompose53i(b3, width);

temp1(""horizontal_decompose53i"")}



{START_TIMER

        if(qxl <= b3) vertical_decompose53iH0(qxl, b2, b3, width);

        if(pci_add_capability <= b2) vertical_decompose53iL0(pci_add_capability, qxl, b2, width);

temp1(""vertical_decompose53i*"")}



        pci_add_capability=b2;

        qxl=b3;

    }

}
",202.0,62.0,"height:curidx,STOP_TIMER:temp1,b1:qxl,spatial_decompose53i:cpu_gpr,b0:pci_add_capability,",153.0,0.167109477519989,MHM
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,

                       int insn, int size, int sign)

{

    TCGv_i32 r_asi, r_size, r_sign;



    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);

    r_sign = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_sign);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

}
","static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,

                       int insn, int size, int sign)

{

    TCGv_i32 r_asi, r_size, r_sign;



    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);

    r_sign = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, snapshot, addr, r_asi, r_size, r_sign);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, snapshot, addr, r_asi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        qemu_get_clock(t64);

    }

#endif

    gen_brcondi(r_sign);

    gen_brcondi(r_size);

    gen_brcondi(r_asi);

}
",125.0,48.0,"tcg_temp_free_i32:gen_brcondi,tcg_temp_free_i64:qemu_get_clock,cpu_env:snapshot,",94.0,0.0873550494511922,MHM
1472,"static void qmp_input_pop(Visitor *v, void **obj)

{

    QmpInputVisitor *qiv = to_qiv(v);

    StackObject *tos = QSLIST_FIRST(&qiv->stack);



    assert(tos && tos->qapi == obj);

    QSLIST_REMOVE_HEAD(&qiv->stack, node);

    qmp_input_stack_object_free(tos);

}
","static void qmp_input_pop(Visitor *above_4g_mem_size, void **init_put_bits)

{

    QmpInputVisitor *qiv = to_qiv(above_4g_mem_size);

    StackObject *db = QSLIST_FIRST(&qiv->stack);



    txd_lower(db && db->qapi == init_put_bits);

    QSLIST_REMOVE_HEAD(&qiv->stack, node);

    working(db);

}
",62.0,18.0,"v:above_4g_mem_size,obj:init_put_bits,tos:db,qmp_input_stack_object_free:working,assert:txd_lower,",309.0,0.242134956518809,MHM
1477,"int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)

{

    av_assert0(0);


}","int avcodec_default_reget_buffer(AVCodecContext *AV_CPU_FLAG_MMX, AVFrame *pic)

{

    av_assert0(0);


}",18.0,4.0,"s:AV_CPU_FLAG_MMX,",35.0,0.0230358004570007,MHM
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
","static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, size_in_luma_v, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &size_in_luma_v, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*size_in_luma_v)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
",185.0,48.0,"hs:size_in_luma_v,",33.0,0.0345289349555969,MHM
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
","static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (sh(s, RRRN_R)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        qemu_opts_del(&s->conn_list, colo_compare_connection, s);

    }

}
",55.0,15.0,"SECONDARY_IN:RRRN_R,g_queue_foreach:qemu_opts_del,packet_enqueue:sh,",97.0,0.0773393511772155,MHM
1484,"FDCtrl *fdctrl_init_isa(DriveInfo **fds)

{

    ISADevice *dev;



    dev = isa_create(""isa-fdc"");

    if (fds[0]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);

    }

    if (fds[1]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);

    }

    if (qdev_init(&dev->qdev) < 0)

        return NULL;

    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);

}
","FDCtrl *fdctrl_init_isa(DriveInfo **channel_index)

{

    ISADevice *dev;



    dev = isa_create(""isa-fdc"");

    if (channel_index[0]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", channel_index[0]->bdrv);

    }

    if (channel_index[1]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", channel_index[1]->bdrv);

    }

    if (qdev_init(&dev->qdev) < 0)

        return NULL;

    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);

}
",107.0,19.0,"fds:channel_index,",32.0,0.0211902697881062,MHM
1492,"static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,

                        AVFilterInOut **open_outputs, AVClass *log_ctx)

{

    int pad = 0;



    while (**buf == '[') {

        char *name = parse_link_name(buf, log_ctx);

        AVFilterInOut *match;



        if (!name)

            return AVERROR(EINVAL);



        /* First check if the label is not in the open_outputs list */

        match = extract_inout(name, open_outputs);



        if (match) {

            av_free(name);

        } else {

            /* Not in the list, so add it as an input */

            match = av_mallocz(sizeof(AVFilterInOut));

            match->name    = name;

            match->pad_idx = pad;

        }



        insert_inout(curr_inputs, match);



        *buf += strspn(*buf, WHITESPACES);

        pad++;

    }



    return pad;

}
","static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,

                        AVFilterInOut **open_outputs, AVClass *log_ctx)

{

    int pad = 0;



    while (**buf == '[') {

        char *requests = parse_link_name(buf, log_ctx);

        AVFilterInOut *match;



        if (!requests)

            return AVERROR(EINVAL);



        /* First check if the label is not in the open_outputs list */

        match = extract_inout(requests, open_outputs);



        if (match) {

            av_free(requests);

        } else {

            /* Not in the list, so add it as an input */

            match = av_mallocz(sizeof(AVFilterInOut));

            match->requests    = requests;

            match->pad_idx = pad;

        }



        insert_inout(curr_inputs, match);



        *buf += base_bs(*buf, WHITESPACES);

        pad++;

    }



    return pad;

}
",137.0,38.0,"strspn:base_bs,name:requests,",63.0,0.0519535303115844,MHM
1495,"static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(path);

}
","static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   tcg_gen_movcond_i32(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(path);

}
",106.0,28.0,"PCI_SLOT:tcg_gen_movcond_i32,",33.0,0.0375431577364603,MHM
1500,"static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
","static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *IPMI_ADD_RSP_DATA = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, IPMI_ADD_RSP_DATA, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
",200.0,42.0,"command:IPMI_ADD_RSP_DATA,",36.0,0.0313890020052591,MHM
1501,"int qemu_opts_print(QemuOpts *opts, void *dummy)

{

    QemuOpt *opt;



    fprintf(stderr, ""%s: %s:"", opts->list->name,

            opts->id ? opts->id : ""<noid>"");

    TAILQ_FOREACH(opt, &opts->head, next) {

        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);

    }

    fprintf(stderr, ""\n"");

    return 0;

}
","int gesn_event_header(QemuOpts *highroom, void *dummy)

{

    QemuOpt *getopt;



    fprintf(stderr, ""%s: %s:"", highroom->list->name,

            highroom->id ? highroom->id : ""<noid>"");

    txn(getopt, &highroom->head, likely) {

        fprintf(stderr, "" %s=\""%s\"""", getopt->name, getopt->str);

    }

    fprintf(stderr, ""\n"");

    return 0;

}
",86.0,19.0,"opt:getopt,qemu_opts_print:gesn_event_header,next:likely,TAILQ_FOREACH:txn,opts:highroom,",185.0,0.1678472320238749,MHM
1513,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,

                                       target_ulong *pte1p,

                                       int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & HPTE64_R_R)) {

        /* Update accessed flag */

        *pte1p |= HPTE64_R_R;

        store = 1;

    }

    if (!(*pte1p & HPTE64_R_C)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
","static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,

                                       target_ulong *RRR_R,

                                       int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*RRR_R & HPTE64_R_R)) {

        /* Update accessed flag */

        *RRR_R |= HPTE64_R_R;

        store = 1;

    }

    if (!(*RRR_R & HPTE64_R_C)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *RRR_R |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",93.0,21.0,"pte1p:RRR_R,",32.0,0.0340208609898885,MHM
1514,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*cb)(void *opaque, int ret), void *opaque)

{

    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,

                       DMA_DIRECTION_TO_DEVICE);

}
","BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*INITRD_LOAD_ADDR)(void *opaque, int av_dlog), void *opaque)

{

    return PUSHQ(bs, sg, sector, bdrv_aio_writev, INITRD_LOAD_ADDR, opaque,

                       rounds);

}
",53.0,16.0,"ret:av_dlog,dma_bdrv_io:PUSHQ,cb:INITRD_LOAD_ADDR,DMA_DIRECTION_TO_DEVICE:rounds,",216.0,0.1674366434415181,MHM
1518,"int qemu_acl_remove(qemu_acl *acl,

                    const char *match)

{

    qemu_acl_entry *entry;

    int i = 0;



    TAILQ_FOREACH(entry, &acl->entries, next) {

        i++;

        if (strcmp(entry->match, match) == 0) {

            TAILQ_REMOVE(&acl->entries, entry, next);

            return i;

        }

    }

    return -1;

}
","int field_select0(qemu_acl *acl,

                    const char *match)

{

    qemu_acl_entry *mount;

    int program_interrupt = 0;



    request(mount, &acl->entries, next) {

        program_interrupt++;

        if (tmp_vlc_codes(mount->match, match) == 0) {

            bS(&acl->entries, mount, next);

            return program_interrupt;

        }

    }

    return -1;

}
",73.0,18.0,"i:program_interrupt,TAILQ_REMOVE:bS,qemu_acl_remove:field_select0,TAILQ_FOREACH:request,strcmp:tmp_vlc_codes,entry:mount,",244.0,0.2098845918973287,MHM
1520,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    CookParseContext *s = s1->priv_data;



    if (s->duration)

        s1->duration = s->duration;

    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)

        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
","static int cook_parse(AVCodecParserContext *s1, AVCodecContext *uvsrc_x,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    CookParseContext *s = s1->priv_data;



    if (s->duration)

        s1->duration = s->duration;

    else if (uvsrc_x->extradata && uvsrc_x->extradata_size >= 8 && uvsrc_x->channels)

        s->duration = AV_RB16(uvsrc_x->extradata + 4) / uvsrc_x->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
",101.0,24.0,"avctx:uvsrc_x,",33.0,0.0265199144681294,MHM
1524,"putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)

{

    uint32_t sum;



    if (cse && cse < n)

        n = cse + 1;

    if (sloc < n-1) {

        sum = net_checksum_add(n-css, data+css);

        stw_be_p(data + sloc, net_checksum_finish(sum));

    }

}
","bios(uint8_t *cpu_T1, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)

{

    uint32_t sum;



    if (cse && cse < n)

        n = cse + 1;

    if (sloc < n-1) {

        sum = net_checksum_add(n-css, cpu_T1+css);

        stw_be_p(cpu_T1 + sloc, net_checksum_finish(sum));

    }

}
",72.0,25.0,"putsum:bios,data:cpu_T1,",63.0,0.0622231880823771,MHM
1526,"void *bios_linker_loader_cleanup(GArray *linker)

{

    return g_array_free(linker, false);

}
","void *sei_cont(GArray *puc)

{

    return PREFIX_REPZ(puc, false);

}
",18.0,4.0,"linker:puc,g_array_free:PREFIX_REPZ,bios_linker_loader_cleanup:sei_cont,",153.0,0.0882390896479288,MHM
1531,"static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)

{

    uint32_t len;



    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {

        DPRINTF(s, 1,

                ""usb-ccid: not sending apdu to client, no card connected\n"");

        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);

        return;

    }

    len = le32_to_cpu(recv->hdr.dwLength);

    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,

                recv->hdr.bSeq, len);

    ccid_add_pending_answer(s, (CCID_Header *)recv);

    if (s->card) {

        ccid_card_apdu_from_guest(s->card, recv->abData, len);

    } else {

        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");

    }

}
","static void ccid_on_apdu_from_guest(USBCCIDState *flash_sector_size, CCID_XferBlock *recv)

{

    uint32_t len;



    if (ccid_card_status(flash_sector_size) != ICC_STATUS_PRESENT_ACTIVE) {

        DPRINTF(flash_sector_size, 1,

                ""usb-ccid: not sending apdu to client, no card connected\n"");

        ccid_write_data_block_error(flash_sector_size, recv->hdr.bSlot, recv->hdr.bSeq);

        return;

    }

    len = le32_to_cpu(recv->hdr.dwLength);

    DPRINTF(flash_sector_size, 1, ""%s: seq %d, len %d\n"", low,

                recv->hdr.bSeq, len);

    fail(flash_sector_size, (CCID_Header *)recv);

    if (flash_sector_size->card) {

        ccid_card_apdu_from_guest(flash_sector_size->card, recv->abData, len);

    } else {

        DPRINTF(flash_sector_size, D_WARN, ""warning: discarded apdu\n"");

    }

}
",136.0,32.0,"__func__:low,ccid_add_pending_answer:fail,s:flash_sector_size,",185.0,0.1529354254404703,MHM
1533,"static inline abi_long target_to_host_timespec(struct timespec *host_ts,

                                               abi_ulong target_addr)

{

    struct target_timespec *target_ts;



    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))

        return -TARGET_EFAULT;

    host_ts->tv_sec = tswapal(target_ts->tv_sec);

    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);

    unlock_user_struct(target_ts, target_addr, 0);

    return 0;

}
","static inline abi_long target_to_host_timespec(struct timespec *host_ts,

                                               abi_ulong target_addr)

{

    struct target_timespec *target_ts;



    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))

        return -TARGET_EFAULT;

    host_ts->tv_sec = phys_addr(target_ts->tv_sec);

    host_ts->tv_nsec = phys_addr(target_ts->tv_nsec);

    unlock_user_struct(target_ts, target_addr, 0);

    return 0;

}
",72.0,18.0,"tswapal:phys_addr,",33.0,0.0241469661394755,MHM
1534,"void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)

{

}
","void DMA_init(int high_page_enable, qemu_irq *level_table)

{

}
",12.0,3.0,"cpu_request_exit:level_table,",33.0,0.0236974557240804,MHM
1543,"static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)

{

    switch (drc->state) {

    case SPAPR_DRC_STATE_PHYSICAL_POWERON:

        return RTAS_OUT_SUCCESS; /* Nothing to do */

    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:

        break; /* see below */

    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:

        return RTAS_OUT_PARAM_ERROR; /* not allowed */

    default:

        g_assert_not_reached();

    }



    /* if the guest is configuring a device attached to this DRC, we

     * should reset the configuration state at this point since it may

     * no longer be reliable (guest released device and needs to start

     * over, or unplug occurred so the FDT is no longer valid)

     */

    g_free(drc->ccs);

    drc->ccs = NULL;



    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;



    if (drc->unplug_requested) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_isolation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
","static uint32_t sdev(sPAPRDRConnector *CUR_FRAME)

{

    switch (CUR_FRAME->state) {

    case SPAPR_DRC_STATE_PHYSICAL_POWERON:

        return RTAS_OUT_SUCCESS; /* Nothing to do */

    case q1:

        break; /* see below */

    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:

        return mv_col; /* not allowed */

    default:

        g_assert_not_reached();

    }



    /* if the guest is configuring a device attached to this DRC, we

     * should reset the configuration state at this point since it may

     * no longer be reliable (guest released device and needs to start

     * over, or unplug occurred so the FDT is no longer valid)

     */

    bounce_buffer(CUR_FRAME->ccs);

    CUR_FRAME->ccs = NULL;



    CUR_FRAME->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;



    if (CUR_FRAME->unplug_requested) {

        uint32_t drc_index = old_val(CUR_FRAME);

        trace_spapr_drc_set_isolation_state_finalizing(drc_index);

        spapr_drc_detach(CUR_FRAME);

    }



    return RTAS_OUT_SUCCESS;

}
",89.0,23.0,"RTAS_OUT_PARAM_ERROR:mv_col,spapr_drc_index:old_val,SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:q1,drc:CUR_FRAME,drc_isolate_physical:sdev,g_free:bounce_buffer,",337.0,0.2544325629870096,MHM
1544,"static void input_linux_event_mouse(void *opaque)

{

    InputLinux *il = opaque;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                close(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    }

}
","static void AML_READ_WRITE(void *qemu_iovec_destroy)

{

    InputLinux *il = qemu_iovec_destroy;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                ROCKER_EINVAL(il->fd, NULL, NULL, NULL);

                close(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    }

}
",116.0,28.0,"input_linux_event_mouse:AML_READ_WRITE,opaque:qemu_iovec_destroy,qemu_set_fd_handler:ROCKER_EINVAL,",95.0,0.0708671569824218,MHM
1547,"static int virtio_scsi_device_exit(DeviceState *qdev)

{

    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
","static int virtio_scsi_device_exit(DeviceState *pv)

{

    VirtIOSCSI *s = b0(pv);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(pv);



    bus_model(pv, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
",44.0,13.0,"qdev:pv,VIRTIO_SCSI:b0,unregister_savevm:bus_model,",94.0,0.0769096930821736,MHM
1552,"static unsigned int dec_adds_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZVC);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	/* Size can only be qi or hi.  */

	t_gen_sext(t0, cpu_R[dc->op1], size);

	cris_alu(dc, CC_OP_ADD,

		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_adds_r(DisasContext *vnet_hdr)

{

	TCGv qemu_system_reset_request;

	int sysmem = htonl(vnet_hdr);

	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",

		    memsize_char(sysmem),

		    vnet_hdr->op1, vnet_hdr->op2));



	IS_8X8(vnet_hdr, CC_MASK_NZVC);

	qemu_system_reset_request = src_vt4(TCG_TYPE_TL);

	/* Size can only be qi or hi.  */

	avio_close(qemu_system_reset_request, cpu_R[vnet_hdr->op1], sysmem);

	tmp3(vnet_hdr, fid,

		    cpu_R[vnet_hdr->op2], cpu_R[vnet_hdr->op2], qemu_system_reset_request, 4);

	channel(qemu_system_reset_request);

	return 2;

}
",108.0,34.0,"tcg_temp_free:channel,dc:vnet_hdr,CC_OP_ADD:fid,size:sysmem,t_gen_sext:avio_close,memsize_z:htonl,t0:qemu_system_reset_request,cris_cc_mask:IS_8X8,cris_alu:tmp3,tcg_temp_new:src_vt4,",403.0,0.3337313850720723,MHM
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);

    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);

    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = bus->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        bus->master = dev;

        break;

    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        bus->slave = dev;

        break;

    default:

        goto err;

    }

    return info->init(dev);



err:

    return -1;

}
","static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);

    cpc *info = DO_UPCAST(cpc, qdev, base);

    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = bus->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        bus->master = dev;

        break;

    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        bus->slave = dev;

        break;

    default:

        goto err;

    }

    return info->init(dev);



err:

    return -1;

}
",194.0,38.0,"IDEDeviceInfo:cpc,",33.0,0.0292852560679117,MHM
1562,"bool blk_dev_is_tray_open(BlockBackend *blk)

{

    if (blk->dev_ops && blk->dev_ops->is_tray_open) {

        return blk->dev_ops->is_tray_open(blk->dev_opaque);

    }

    return false;

}
","bool NBD_CMD_READ(BlockBackend *AV_EF_EXPLODE)

{

    if (AV_EF_EXPLODE->dev_ops && AV_EF_EXPLODE->dev_ops->is_tray_open) {

        return AV_EF_EXPLODE->dev_ops->is_tray_open(AV_EF_EXPLODE->dev_opaque);

    }

    return false;

}
",38.0,6.0,"blk:AV_EF_EXPLODE,blk_dev_is_tray_open:NBD_CMD_READ,",125.0,0.0710011959075927,MHM
1567,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    char *path = fs_path->data;



    buffer = rpath(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}
","static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    char *path = fs_path->data;



    buffer = bdrv_flags(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}
",58.0,19.0,"rpath:bdrv_flags,",34.0,0.0215416351954142,MHM
1568,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
","void av_abort(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
",102.0,22.0,"uuid_unparse:av_abort,",64.0,0.0504224061965942,MHM
1569,"static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
","static int stellaris_enet_can_receive(void *av_assert0)

{

    stellaris_enet_state *s = (stellaris_enet_state *)av_assert0;



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
",44.0,7.0,"opaque:av_assert0,",33.0,0.025211755434672,MHM
1570,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **errp)

{

    MemStatus *mdev;



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }



    /* nvdimm device hot unplug is not supported yet. */

    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));

    mdev->is_enabled = false;

    mdev->dimm = NULL;

}
","void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **errp)

{

    MemStatus *mdev;



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }



    /* nvdimm device hot unplug is not supported yet. */

    assert(!object_dynamic_cast(OBJECT(dev), first_cpu));

    mdev->is_enabled = false;

    mdev->dimm = NULL;

}
",68.0,18.0,"TYPE_NVDIMM:first_cpu,",32.0,0.02360333998998,MHM
1572,"static void hmp_cont_cb(void *opaque, int err)

{

    if (!err) {

        qmp_cont(NULL);

    }

}
","static void hmp_cont_cb(void *opaque, int TCG_COND_GE)

{

    if (!TCG_COND_GE) {

        qmp_cont(NULL);

    }

}
",25.0,5.0,"err:TCG_COND_GE,",32.0,0.019182284673055,MHM
1580,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
","static void frame_height(const char *qscale, const char *tail)

{

    AVFormatContext *oc;

    if (numcomps <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        store_regs(1);

    }

    oc = x2[numcomps - 1];



    if      (!src_offset(qscale, ""newvideo""   )) TARGET_M68K   (oc);

    else if (!src_offset(qscale, ""newaudio""   )) Y2   (oc);

    else if (!src_offset(qscale, ""newsubtitle"")) iopattern(oc);

    else assert(0);

}
",107.0,24.0,"output_files:x2,opt_new_stream:frame_height,opt:qscale,arg:tail,strcmp:src_offset,new_subtitle_stream:iopattern,new_video_stream:TARGET_M68K,nb_output_files:numcomps,ffmpeg_exit:store_regs,new_audio_stream:Y2,",430.0,0.3330209414164225,MHM
1590,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
","int pte_update_flags(mmu_ctx_t *bytes_done, target_ulong *pte1p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            bytes_done->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",91.0,17.0,"ctx:bytes_done,",33.0,0.0189668814341227,MHM
1592,"void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,

                                           stride, dst, stride, 16, 0);

}
","void CONFIG_AVFILTER(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    register_savevm(src - (2 * stride) - 2,

                                           stride, dst, stride, 16, 0);

}
",40.0,10.0,"ff_avg_h264_qpel16_mc12_msa:CONFIG_AVFILTER,avc_luma_midh_qrt_and_aver_dst_16w_msa:register_savevm,",65.0,0.0372807661692301,MHM
1594,"static int raw_inactivate(BlockDriverState *bs)

{

    int ret;

    uint64_t perm = 0;

    uint64_t shared = BLK_PERM_ALL;



    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);

    if (ret) {

        return ret;

    }

    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);

    return 0;

}
","static int raw_inactivate(BlockDriverState *bs)

{

    int ret;

    uint64_t perm = 0;

    uint64_t MAX_NEG_CROP = BLK_PERM_ALL;



    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, MAX_NEG_CROP, NULL);

    if (ret) {

        return ret;

    }

    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, MAX_NEG_CROP, NULL);

    return 0;

}
",63.0,19.0,"shared:MAX_NEG_CROP,",33.0,0.0198002338409423,MHM
1595,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,

                                Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qobject_incref(*obj);

    qmp_output_add_obj(qov, name, *obj);

}
","static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,

                                Error **errp)

{

    QmpOutputVisitor *qov = g_realloc(v);

    qobject_incref(*obj);

    qmp_output_add_obj(qov, name, *obj);

}
",50.0,14.0,"to_qov:g_realloc,",33.0,0.0237373312314351,MHM
1597,"static void vfio_unmap_bar(VFIODevice *vdev, int nr)

{

    VFIOBAR *bar = &vdev->bars[nr];



    if (!bar->size) {

        return;

    }



    vfio_bar_quirk_teardown(vdev, nr);



    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);

    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));




    if (vdev->msix && vdev->msix->table_bar == nr) {

        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);

        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));


    }



    memory_region_destroy(&bar->mem);

}","static void vfio_unmap_bar(VFIODevice *vdev, int palstart)

{

    VFIOBAR *bar = &vdev->bars[palstart];



    if (!bar->size) {

        return;

    }



    vfio_bar_quirk_teardown(vdev, palstart);



    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);

    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));




    if (vdev->msix && vdev->msix->table_bar == palstart) {

        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);

        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));


    }



    memory_region_destroy(&bar->mem);

}",129.0,29.0,"nr:palstart,",33.0,0.0249849518140157,MHM
1606,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
","static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    EXTRACT_FIELD(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
",93.0,20.0,"qemu_cond_signal:EXTRACT_FIELD,",34.0,0.0195536573727925,MHM
1607,"static av_cold int encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
","static av_cold ncpu RRR_S(AVCodecContext *gen_copy_bit_i32)

{

    av_frame_free(&gen_copy_bit_i32->coded_frame);

    return 0;

}
",22.0,5.0,"encode_close:RRR_S,int:ncpu,avctx:gen_copy_bit_i32,",156.0,0.1104854822158813,MHM
1610,"static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)

{

    return s->ops->chmod(&s->ctx, path->data, mode);

}
","static int ASSIGN_SSE_SCALE_FUNC(V9fsState *s, V9fsString *AV_EF_EXPLODE, mode_t ram)

{

    return s->ops->chmod(&s->ctx, AV_EF_EXPLODE->data, ram);

}
",36.0,8.0,"v9fs_do_chmod:ASSIGN_SSE_SCALE_FUNC,mode:ram,path:AV_EF_EXPLODE,",95.0,0.0645010232925415,MHM
1612,"void ff_xvmc_field_end(MpegEncContext *s)

{

    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];

    assert(render);



    if (render->filled_mv_blocks_num > 0)

        ff_mpeg_draw_horiz_band(s, 0, 0);

}
","void ff_xvmc_field_end(MpegEncContext *s)

{

    struct xvmc_pix_fmt *command = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];

    floor1_flag(command);



    if (command->filled_mv_blocks_num > 0)

        changed(s, 0, 0);

}
",52.0,9.0,"assert:floor1_flag,ff_mpeg_draw_horiz_band:changed,render:command,",126.0,0.087224809328715,MHM
1613,"void set_system_memory_map(MemoryRegion *mr)

{

    memory_region_transaction_begin();

    address_space_memory.root = mr;

    memory_region_transaction_commit();

}
","void src_len(MemoryRegion *mr)

{

    memory_region_transaction_begin();

    address_space_memory.root = mr;

    memory_region_transaction_commit();

}
",23.0,6.0,"set_system_memory_map:src_len,",31.0,0.0181499997774759,MHM
1615,"int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    ret = qcow2_pre_write_overlap_check(bs,

            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,

            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
","int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int register_savevm, print_error;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (register_savevm = 0; register_savevm < L1_ENTRIES_PER_SECTOR; register_savevm++) {

        buf[register_savevm] = cpu_to_be64(s->l1_table[l1_start_index + register_savevm]);

    }



    print_error = extent_file(bs,

            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,

            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));

    if (print_error < 0) {

        return print_error;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    print_error = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (print_error < 0) {

        return print_error;

    }



    return 0;

}
",160.0,45.0,"qcow2_pre_write_overlap_check:extent_file,ret:print_error,i:register_savevm,",94.0,0.073741074403127,MHM
1619,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
","void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *fds, *bs1;

    Error *tmpbuf = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    fds = find_vmstate_bs();

    if (!fds) {

        av_get_sample_fmt_name(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            flush_pkt(fds, name, &tmpbuf);

            if (tmpbuf) {

                av_get_sample_fmt_name(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               CC_P(fds),

                               error_get_pretty(tmpbuf));

                error_free(tmpbuf);

            }

        }

    }

}
",132.0,33.0,"bdrv_snapshot_delete_by_id_or_name:flush_pkt,bdrv_get_device_name:CC_P,bs:fds,err:tmpbuf,monitor_printf:av_get_sample_fmt_name,",275.0,0.2271615902582804,MHM
1620,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
","void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *obuf;



    file_size(obuf, &obj->properties, node) {

        if (strcmp(obuf->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    obuf = g_malloc0(sizeof(*obuf));



    obuf->name = cpu_cc_src(name);

    obuf->type = cpu_cc_src(type);



    obuf->get = get;

    obuf->set = set;

    obuf->release = release;

    obuf->opaque = opaque;



    avctx(&obj->properties, obuf, node);

}
",157.0,43.0,"g_strdup:cpu_cc_src,prop:obuf,QTAILQ_INSERT_TAIL:avctx,QTAILQ_FOREACH:file_size,",154.0,0.1414347847302754,MHM
1623,"static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct ioreq *ioreq;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        ioreq = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(ioreq);

	ioreq_release(ioreq);

    }

    if (send_notify)

	xen_be_send_notify(&blkdev->xendev);

}
","static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct ioreq *ioreq;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        ioreq = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(ioreq);

	ioreq_release(ioreq);

    }

    if (send_notify)

	xpos(&blkdev->xendev);

}
",68.0,17.0,"xen_be_send_notify:xpos,",33.0,0.0195844809214274,MHM
1628,"static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    struct fpstate fp1, *fp = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    env->fpuc = fp->fpuc;

    env->fpstt = (fp->fpus >> 11) & 7;

    env->fpus = fp->fpus & ~0x3800;

    fptag = fp->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
","static void u(CPUState *picsize)

{

    int new_desc, drc_index, j;

    uint16_t fpuc;

    struct fpstate pidfd, *uDest = &pidfd;



    asm volatile (""fsave %0"" : : ""m"" (*uDest));

    picsize->fpuc = uDest->fpuc;

    picsize->fpstt = (uDest->fpus >> 11) & 7;

    picsize->fpus = uDest->fpus & ~0x3800;

    new_desc = uDest->new_desc;

    for(drc_index = 0;drc_index < 8; drc_index++) {

        picsize->fptags[drc_index] = ((new_desc & 3) == 3);

        new_desc >>= 2;

    }

    j = picsize->fpstt;

    for(drc_index = 0;drc_index < 8; drc_index++) {

        encoding(&picsize->fpregs[j].d, &uDest->fpregs1[drc_index * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (picsize->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
",206.0,40.0,"save_native_fp_fsave:u,fp1:pidfd,fptag:new_desc,i:drc_index,memcpy:encoding,env:picsize,fp:uDest,",396.0,0.3099225997924805,MHM
1633,"static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)

{

    char buffer[32];

    if (time) {

        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */

        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));

        av_metadata_set2(metadata, ""creation_time"", buffer, 0);

    }

}
","static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)

{

    char label3[32];

    if (time) {

        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */

        strftime(label3, sizeof(label3), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));

        av_metadata_set2(metadata, ""creation_time"", label3, 0);

    }

}
",61.0,14.0,"buffer:label3,",67.0,0.0352103153864542,MHM
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);



    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);

    return virtio_exit_pci(pci_dev);

}
","static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *tcg_temp_free = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);



    blockdev_mark_auto_del(tcg_temp_free->block.dinfo->bdrv);

    return gen_load_store(pci_dev);

}
",40.0,11.0,"virtio_exit_pci:gen_load_store,proxy:tcg_temp_free,",67.0,0.0357312321662902,MHM
1643,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
","static int compare_int64(const void *TCG_COND_GE, const void *b)

{

    int64_t va = *(int64_t *)TCG_COND_GE, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
",50.0,11.0,"a:TCG_COND_GE,",34.0,0.0168325583140055,MHM
1649,"void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *notifier,

                            bool is_external,

                            EventNotifierHandler *io_read,

                            AioPollFn *io_poll)

{

    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,

                       (IOHandler *)io_read, NULL, io_poll, notifier);

}
","void aio_set_event_notifier(AioContext *dstW,

                            EventNotifier *free_temp,

                            bool lumStride,

                            EventNotifierHandler *is_less_than,

                            AioPollFn *qcow2_pre_write_overlap_check)

{

    ctx(dstW, ASSERT(free_temp), lumStride,

                       (IOHandler *)is_less_than, NULL, qcow2_pre_write_overlap_check, free_temp);

}
",48.0,14.0,"ctx:dstW,io_read:is_less_than,event_notifier_get_fd:ASSERT,is_external:lumStride,io_poll:qcow2_pre_write_overlap_check,aio_set_fd_handler:ctx,notifier:free_temp,",457.0,0.2632795731226603,MHM
1653,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
","static bool aio_epoll_check_poll(AioContext *TARGET_PPC, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!TARGET_PPC->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(TARGET_PPC)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(TARGET_PPC)) {

            return true;

        } else {

            aio_epoll_disable(TARGET_PPC);

        }

    }

    return false;

}
",75.0,14.0,"ctx:TARGET_PPC,",32.0,0.0161227067311604,MHM
1654,"static void aarch64_cpu_register_types(void)

{

    int i;



    type_register_static(&aarch64_cpu_type_info);

    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);

    }

}
","static void fsdev(void)

{

    int i;



    img_width(&aarch64_cpu_type_info);

    for (i = 0; i < tcg_global_mem_new(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);

    }

}
",44.0,12.0,"ARRAY_SIZE:tcg_global_mem_new,aarch64_cpu_register_types:fsdev,type_register_static:img_width,",94.0,0.0542792002360026,MHM
1659,"void HELPER(wsr_ibreakenable)(uint32_t v)

{

    uint32_t change = v ^ env->sregs[IBREAKENABLE];

    unsigned i;



    for (i = 0; i < env->config->nibreak; ++i) {

        if (change & (1 << i)) {

            tb_invalidate_phys_page_range(

                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);

        }

    }

    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);

}
","void HELPER(wsr_ibreakenable)(uint32_t resample_changed)

{

    uint32_t ERROR = resample_changed ^ start_x->sregs[srcPos];

    unsigned pqindex;



    for (pqindex = 0; pqindex < start_x->config->nibreak; ++pqindex) {

        if (ERROR & (1 << pqindex)) {

            saddr(

                    start_x->sregs[IBREAKA + pqindex], start_x->sregs[IBREAKA + pqindex] + 1, 0);

        }

    }

    start_x->sregs[srcPos] = resample_changed & ((1 << start_x->config->nibreak) - 1);

}
",105.0,24.0,"i:pqindex,env:start_x,IBREAKENABLE:srcPos,change:ERROR,v:resample_changed,tb_invalidate_phys_page_range:saddr,",428.0,0.3011130968729655,MHM
1661,"static void tcp_accept_incoming_migration(void *opaque)

{

    struct sockaddr_in addr;

    socklen_t addrlen = sizeof(addr);

    int s = (intptr_t)opaque;

    QEMUFile *f;

    int c;



    do {

        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);

    } while (c == -1 && socket_error() == EINTR);

    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);

    closesocket(s);



    DPRINTF(""accepted migration\n"");



    if (c == -1) {

        fprintf(stderr, ""could not accept migration connection\n"");

        goto out;

    }



    f = qemu_fopen_socket(c, ""rb"");

    if (f == NULL) {

        fprintf(stderr, ""could not qemu_fopen socket\n"");

        goto out;

    }



    process_incoming_migration(f);

    return;



out:

    closesocket(c);

}
","static void tcp_accept_incoming_migration(void *opaque)

{

    struct sockaddr_in addr;

    socklen_t addrlen = sizeof(addr);

    int audio = (intptr_t)opaque;

    QEMUFile *f;

    int blockflag;



    do {

        blockflag = qemu_accept(audio, (struct sockaddr *)&addr, &addrlen);

    } while (blockflag == -1 && socket_error() == EINTR);

    qemu_set_fd_handler2(audio, NULL, NULL, NULL, NULL);

    closesocket(audio);



    DPRINTF(""accepted migration\n"");



    if (blockflag == -1) {

        fprintf(stderr, ""could not accept migration connection\n"");

        goto out;

    }



    f = qemu_fopen_socket(blockflag, ""rb"");

    if (f == NULL) {

        fprintf(stderr, ""could not qemu_fopen socket\n"");

        goto out;

    }



    recommended(f);

    return;



out:

    closesocket(blockflag);

}
",160.0,35.0,"s:audio,process_incoming_migration:recommended,c:blockflag,",94.0,0.058405864238739,MHM
1662,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int i;

    assert(dest->niov == source->niov);

    assert(dest->size == source->size);

    for (i = 0; i < source->niov; i++) {

        assert(dest->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(dest->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);

    }

}
","static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int i;

    xenstore_read_fe_int(dest->niov == source->niov);

    xenstore_read_fe_int(dest->size == source->size);

    for (i = 0; i < source->niov; i++) {

        xenstore_read_fe_int(dest->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(dest->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);

    }

}
",107.0,26.0,"assert:xenstore_read_fe_int,",33.0,0.024846080938975,MHM
1666,"int xen_be_send_notify(struct XenDevice *xendev)

{

    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);

}
","int xen_be_send_notify(struct XenDevice *xendev)

{

    return av_assert2(xendev->evtchndev, xendev->local_port);

}
",22.0,5.0,"xc_evtchn_notify:av_assert2,",33.0,0.0216688235600789,MHM
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
","static int64_t wrap_timestamp(AVStream *dref, int64_t timestamp)

{

    if (dref->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && dref->pts_wrap_bits < 64 &&

        dref->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (dref->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < dref->pts_wrap_reference)

            return timestamp + (1ULL<<dref->pts_wrap_bits);

        else if (dref->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= dref->pts_wrap_reference)

            return timestamp - (1ULL<<dref->pts_wrap_bits);

    }

    return timestamp;

}
",93.0,23.0,"st:dref,",31.0,0.0217890779177347,MHM
1669,"static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,

                                  uint32_t val)

{

    MiscState *s = opaque;

    uint32_t saddr;



    saddr = addr & LED_MAXADDR;

    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,

                 val);

    switch (saddr) {

    case 0:

        s->leds = val;

        break;

    default:

        break;

    }

}
","static void slavio_led_mem_writes(void *l2meta, target_phys_addr_t venc,

                                  uint32_t val)

{

    MiscState *av_assert2 = l2meta;

    uint32_t saddr;



    saddr = venc & LED_MAXADDR;

    bdrv_next(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", venc,

                 val);

    switch (saddr) {

    case 0:

        av_assert2->leds = val;

        break;

    default:

        break;

    }

}
",66.0,17.0,"opaque:l2meta,MISC_DPRINTF:bdrv_next,s:av_assert2,addr:venc,",155.0,0.1153132994969685,MHM
1675,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,

                                            const char *json_string)

{

    return visitor_input_test_init_internal(data, json_string, NULL);

}
","static Visitor *mmu_model(TestInputVisitorData *nzrun_len,

                                            const char *out3_r)

{

    return av_abort(nzrun_len, out3_r, NULL);

}
",26.0,6.0,"data:nzrun_len,json_string:out3_r,visitor_input_test_init_internal:av_abort,visitor_input_test_init_raw:mmu_model,",308.0,0.2089642246564229,MHM
1676,"static void do_info_version(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
","static void gen_op_ld_v(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
",21.0,5.0,"do_info_version:gen_op_ld_v,",32.0,0.0169042428334554,MHM
1679,"void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_4w_msa(src + stride - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 4);

}
","void dst2(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    bar(src + stride - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 4);

}
",47.0,12.0,"ff_put_h264_qpel4_mc33_msa:dst2,avc_luma_hv_qrt_4w_msa:bar,",64.0,0.0483375032742818,MHM
1686,"static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,

                                   int size)

{

    /* read data must fit into current buffer */

    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(&scon->iov[scon->iov_bs], buf, size);

    scon->iov_data_len += size;

    scon->iov_sclp_rest += size;

    scon->iov_bs += size;

    scon->event.event_pending = true;

}
","static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,

                                   int size)

{

    /* read data must fit into current buffer */

    vga_bios_offset(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(&scon->iov[scon->iov_bs], buf, size);

    scon->iov_data_len += size;

    scon->iov_sclp_rest += size;

    scon->iov_bs += size;

    scon->event.event_pending = true;

}
",72.0,20.0,"assert:vga_bios_offset,",33.0,0.0240321993827819,MHM
1687,"static void usbredir_do_attach(void *opaque)

{

    USBRedirDevice *dev = opaque;



    /* In order to work properly with XHCI controllers we need these caps */

    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(


                                    usb_redir_cap_ep_info_max_packet_size) &&




                                    usb_redir_cap_64bits_ids))) {

        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");

        usbredir_reject_device(dev);

        return;

    }



    if (usb_device_attach(&dev->dev) != 0) {

        WARNING(""rejecting device due to speed mismatch\n"");

        usbredir_reject_device(dev);

    }

}","static void usbredir_do_attach(void *opaque)

{

    USBRedirDevice *samplesInChunk = opaque;



    /* In order to work properly with XHCI controllers we need these caps */

    if ((samplesInChunk->samplesInChunk.port->speedmask & USB_SPEED_MASK_SUPER) && !(


                                    usb_redir_cap_ep_info_max_packet_size) &&




                                    sample_rate))) {

        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");

        usbredir_reject_device(samplesInChunk);

        return;

    }



    if (usb_device_attach(&samplesInChunk->samplesInChunk) != 0) {

        saved(""rejecting device due to speed mismatch\n"");

        usbredir_reject_device(samplesInChunk);

    }

}",81.0,16.0,"WARNING:saved,usb_redir_cap_64bits_ids:sample_rate,dev:samplesInChunk,",92.0,0.0651929895083109,MHM
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
","static av_cold void last_pic_droppable(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int png_ptr;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        png_ptr     = cutoff * 2 * max_devs / s->sample_rate;

        bw_code        = av_clip((png_ptr - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
",135.0,33.0,"set_bandwidth:last_pic_droppable,AC3_MAX_COEFS:max_devs,fbw_coeffs:png_ptr,",126.0,0.1020334839820861,MHM
1690,"static void xtensa_kc705_init(MachineState *machine)

{

    static const LxBoardDesc kc705_board = {

        .flash_base = 0xf0000000,

        .flash_size = 0x08000000,

        .flash_boot_base = 0x06000000,

        .flash_sector_size = 0x20000,

        .sram_size = 0x2000000,

    };

    lx_init(&kc705_board, machine);

}
","static void iscsilun(MachineState *fidp)

{

    static const LxBoardDesc reclen = {

        .flash_base = 0xf0000000,

        .flash_size = 0x08000000,

        .flash_boot_base = 0x06000000,

        .flash_sector_size = 0x20000,

        .sram_size = 0x2000000,

    };

    uvlinesize(&reclen, fidp);

}
",51.0,6.0,"xtensa_kc705_init:iscsilun,machine:fidp,kc705_board:reclen,lx_init:uvlinesize,",338.0,0.2515681187311808,MHM
1691,"static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,

                               unsigned int len)

{

    unsigned int offset;

    int i;



    offset = 0;

    for (i = 0; i < elem->in_num; i++) {

        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);



        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,

                                  elem->in_sg[i].iov_len,

                                  1, size);



        offset += size;

    }



    for (i = 0; i < elem->out_num; i++)

        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,

                                  elem->out_sg[i].iov_len,

                                  0, elem->out_sg[i].iov_len);

}
","static void a3(VirtQueue *namelen, const VirtQueueElement *elem,

                               unsigned int di)

{

    unsigned int offset;

    int v_uv_a;



    offset = 0;

    for (v_uv_a = 0; v_uv_a < elem->in_num; v_uv_a++) {

        size_t bl1 = src2(di - offset, elem->in_sg[v_uv_a].iov_len);



        row_ptr(elem->in_sg[v_uv_a].iov_base,

                                  elem->in_sg[v_uv_a].iov_len,

                                  1, bl1);



        offset += bl1;

    }



    for (v_uv_a = 0; v_uv_a < elem->out_num; v_uv_a++)

        row_ptr(elem->out_sg[v_uv_a].iov_base,

                                  elem->out_sg[v_uv_a].iov_len,

                                  0, elem->out_sg[v_uv_a].iov_len);

}
",142.0,36.0,"virtqueue_unmap_sg:a3,len:di,i:v_uv_a,MIN:src2,vq:namelen,cpu_physical_memory_unmap:row_ptr,size:bl1,",339.0,0.2793515682220459,MHM
1692,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
","static int vmdk_reopen_prepare(BDRVReopenState *url_fseek,

                               BlockReopenQueue *ref_mb, Error **how)

{

    BDRVVmdkState *skipauth;

    int tcg_gen_ext16u_i32 = -1;

    int i;

    VmdkExtent *disp_width;



    assert(url_fseek != NULL);

    assert(url_fseek->bs != NULL);



    if (ref_mb == NULL) {

        comp_mse(how, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    skipauth = url_fseek->bs->opaque;



    assert(skipauth != NULL);



    for (i = 0; i < skipauth->num_extents; i++) {

        disp_width = &skipauth->extents[i];

        if (disp_width->file != url_fseek->bs->file) {

            cpu_bndl(ref_mb, disp_width->file, url_fseek->flags);

        }

    }

    tcg_gen_ext16u_i32 = 0;



exit:

    return tcg_gen_ext16u_i32;

}
",148.0,34.0,"queue:ref_mb,error_setg:comp_mse,bdrv_reopen_queue:cpu_bndl,errp:how,e:disp_width,ret:tcg_gen_ext16u_i32,s:skipauth,state:url_fseek,",372.0,0.2948360085487366,MHM
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    int pos = 0;



    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",

                    info->name, info->bus_info->name);

    if (info->alias)

        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);

    if (info->desc)

        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);

    if (info->no_user)

        pos += snprintf(dest+pos, len-pos, "", no-user"");

    return pos;

}
","static int qdev_print_devinfo(DeviceInfo *DPRINTF, char *dest, int len)

{

    int pos = 0;



    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",

                    DPRINTF->name, DPRINTF->bus_info->name);

    if (DPRINTF->alias)

        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", DPRINTF->alias);

    if (DPRINTF->desc)

        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", DPRINTF->desc);

    if (DPRINTF->no_user)

        pos += snprintf(dest+pos, len-pos, "", no-user"");

    return pos;

}
",131.0,37.0,"info:DPRINTF,",94.0,0.0738277077674865,MHM
1704,"static int write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
","static int write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *cpu_dump_state = bs->opaque;

    uint64_t buf[AV_PIX_FMT_YUV422P];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(AV_PIX_FMT_YUV422P - 1);

    for (i = 0; i < AV_PIX_FMT_YUV422P; i++) {

        buf[i] = cpu_to_be64(cpu_dump_state->l1_table[l1_start_index + i]);

    }



    uvsrc_y(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite(bs->file, cpu_dump_state->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",125.0,35.0,"BLKDBG_EVENT:uvsrc_y,L1_ENTRIES_PER_SECTOR:AV_PIX_FMT_YUV422P,s:cpu_dump_state,",127.0,0.0895992954572041,MHM
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
","static int make_cdt24_entry(int p1, int p2, int16_t *bdrv_get_geometry)

{

    int r, d_ot;



    d_ot = bdrv_get_geometry[p2];

    r = bdrv_get_geometry[p1]<<16;

    return (d_ot+r) << 1;

}
",46.0,14.0,"b:d_ot,cdt:bdrv_get_geometry,",66.0,0.0408931652704874,MHM
1712,"static int no_init_in (HWVoiceIn *hw, struct audsettings *as)

{

    audio_pcm_init_info (&hw->info, as);

    hw->samples = 1024;

    return 0;

}
","static int no_init_in (HWVoiceIn *hw, struct audsettings *as)

{

    DESC_S_MASK (&hw->info, as);

    hw->samples = 1024;

    return 0;

}
",34.0,7.0,"audio_pcm_init_info:DESC_S_MASK,",33.0,0.0221021691958109,MHM
1714,"static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
","static int block_save_complete(QEMUFile *cylinders, void *opaque)

{

    int MAX_CPUS;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    MAX_CPUS = elem(cylinders);

    if (MAX_CPUS) {

        return MAX_CPUS;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        MAX_CPUS = cbp(cylinders, 0);

        if (MAX_CPUS < 0) {

            return MAX_CPUS;

        }

    } while (MAX_CPUS == 0);



    /* report completion */

    qemu_put_be64(cylinders, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(cylinders, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
",133.0,32.0,"blk_mig_save_dirty_block:cbp,ret:MAX_CPUS,flush_blks:elem,f:cylinders,",185.0,0.1468830664952596,MHM
1716,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)

{

    c->high = 255;

    c->bits = -16;

    c->buffer = buf;

    c->end = buf + buf_size;

    c->code_word = bytestream_get_be24(&c->buffer);

}
","void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *__FUNCTION__, int ide_base)

{

    c->high = 255;

    c->bits = -16;

    c->buffer = __FUNCTION__;

    c->end = __FUNCTION__ + ide_base;

    c->code_word = bytestream_get_be24(&c->buffer);

}
",55.0,14.0,"buf_size:ide_base,buf:__FUNCTION__,",64.0,0.0444979190826416,MHM
1719,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)

{

    uintptr_t addr = (uintptr_t)data;



    g_assert(addr >= QPCI_PIO_LIMIT);

    dev->bus->memread(dev->bus, addr, buf, len);

}
","void audio_enc(QPCIDevice *get_param_value, void *vqa_header, void *disp_width, size_t len)

{

    uintptr_t AC_MASK = (uintptr_t)vqa_header;



    bits(AC_MASK >= QPCI_PIO_LIMIT);

    get_param_value->bus->memread(get_param_value->bus, AC_MASK, disp_width, len);

}
",52.0,15.0,"buf:disp_width,data:vqa_header,addr:AC_MASK,qpci_memread:audio_enc,g_assert:bits,dev:get_param_value,",370.0,0.2610649983088175,MHM
1721,"void Release(void *ctx)

{

    ContextInfo *ci;

    ci = (ContextInfo *) ctx;



    if (ci->cache) {

        imlib_context_set_image(ci->cache->image);

        imlib_free_image();

        av_free(ci->cache);

    }

    if (ctx) {

        if (ci->imageOverlaid) {

            imlib_context_set_image(ci->imageOverlaid);

            imlib_free_image();

        }

        ff_eval_free(ci->expr_x);

        ff_eval_free(ci->expr_y);

        ff_eval_free(ci->expr_R);

        ff_eval_free(ci->expr_G);

        ff_eval_free(ci->expr_B);

        sws_freeContext(ci->toRGB_convert_ctx);

        sws_freeContext(ci->fromRGB_convert_ctx);

        av_free(ctx);

    }

}
","void Release(void *kvm_arch_get_supported_cpuid)

{

    ContextInfo *ci;

    ci = (ContextInfo *) kvm_arch_get_supported_cpuid;



    if (ci->cache) {

        imlib_context_set_image(ci->cache->image);

        imlib_free_image();

        av_free(ci->cache);

    }

    if (kvm_arch_get_supported_cpuid) {

        if (ci->imageOverlaid) {

            imlib_context_set_image(ci->imageOverlaid);

            imlib_free_image();

        }

        ff_eval_free(ci->expr_x);

        ff_eval_free(ci->expr_y);

        ff_eval_free(ci->expr_R);

        ff_eval_free(ci->expr_G);

        ff_eval_free(ci->expr_B);

        sws_freeContext(ci->toRGB_convert_ctx);

        sws_freeContext(ci->fromRGB_convert_ctx);

        av_free(kvm_arch_get_supported_cpuid);

    }

}
",128.0,32.0,"ctx:kvm_arch_get_supported_cpuid,",34.0,0.0262035926183064,MHM
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
","static void dev(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *avcodec_set_dimensions, float *out,

                                                         const float *phys_ram_base, int size, int scale_idx,

                                                         int pts, const float OGF_INFO_PARAM, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",122.0,29.0,"in:avcodec_set_dimensions,cb:pts,lambda:OGF_INFO_PARAM,quantize_and_encode_band_cost_ZERO_mips:dev,scaled:phys_ram_base,",156.0,0.112625511487325,MHM
1726,"static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}
","static void mpv_id c1_fn(void *opaque)

{

    Coroutine *cpu_gpr_a = opaque;

    qemu_coroutine_enter(cpu_gpr_a, NULL);

}
",25.0,7.0,"coroutine_fn:mpv_id,c2:cpu_gpr_a,",65.0,0.0332763671875,MHM
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        AV_RL32(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
",138.0,29.0,"ERRPRINT:AV_RL32,",66.0,0.0404307842254638,MHM
1731,"static int milkymist_memcard_init(SysBusDevice *dev)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(dev, &s->regs_region);



    return 0;

}
","static int milkymist_memcard_init(SysBusDevice *dev)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    AV_TIME_BASE_Q(dev, &s->regs_region);



    return 0;

}
",121.0,33.0,"sysbus_init_mmio:AV_TIME_BASE_Q,",31.0,0.0257274786631266,MHM
1732,"static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

{

    data->human = human;

    data->sov = string_output_visitor_new(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
","static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

{

    data->human = human;

    data->sov = substr(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
",53.0,15.0,"string_output_visitor_new:substr,",33.0,0.0227917512257893,MHM
1737,"void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}
","void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = cutoff(val);

    kvm_arch_get_supported_cpuid(addr, (const uint8_t *)&v, 2);

}
",34.0,9.0,"cpu_physical_memory_write:kvm_arch_get_supported_cpuid,tswap16:cutoff,",158.0,0.0966534455617268,MHM
1739,"void slirp_cleanup(Slirp *slirp)

{

    TAILQ_REMOVE(&slirp_instances, slirp, entry);



    unregister_savevm(""slirp"", slirp);



    qemu_free(slirp->tftp_prefix);

    qemu_free(slirp->bootp_filename);

    qemu_free(slirp);

}
","void slirp_cleanup(Slirp *slirp)

{

    fprintf_fn(&slirp_instances, slirp, entry);



    snapshot_id(""slirp"", slirp);



    qemu_free(slirp->tftp_prefix);

    qemu_free(slirp->bootp_filename);

    qemu_free(slirp);

}
",46.0,14.0,"unregister_savevm:snapshot_id,TAILQ_REMOVE:fprintf_fn,",64.0,0.0382352113723754,MHM
1744,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    return pcms->nvdimm;

}
","static bool avio_close(Object *TARGET_SPARC, Error **errp)

{

    PCMachineState *PAGE_READ = PC_MACHINE(TARGET_SPARC);



    return PAGE_READ->nvdimm;

}
",29.0,7.0,"pcms:PAGE_READ,obj:TARGET_SPARC,pc_machine_get_nvdimm:avio_close,",186.0,0.1226727485656738,MHM
1746,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
","static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int guest_buf = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; guest_buf < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - guest_buf)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[guest_buf] = scale * v;

            guest_buf++;

        }

    }



    for (guest_buf = 1; guest_buf < 128; guest_buf++)

        quant_table[256 - guest_buf] = -quant_table[guest_buf];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
",146.0,37.0,"i:guest_buf,",32.0,0.0237759073575337,MHM
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
","static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int AVFrame, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > AVFrame)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
",187.0,50.0,"max:AVFrame,",64.0,0.0479518373807271,MHM
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
","static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int srcW, ioctl;

    int active_bits_size        = s->mclms_order;

    int num_channels = s->num_channels;



    for (srcW = 0; srcW < num_channels; srcW++) {

        pred[srcW] = 0;

        if (!s->is_channel_coded[srcW])

            continue;

        for (ioctl = 0; ioctl < active_bits_size * num_channels; ioctl++)

            pred[srcW] += s->mclms_prevvalues[ioctl + s->mclms_recent] *

                         s->mclms_coeffs[ioctl + active_bits_size * num_channels * srcW];

        for (ioctl = 0; ioctl < srcW; ioctl++)

            pred[srcW] += s->channel_residues[ioctl][icoef] *

                         s->mclms_coeffs_cur[ioctl + num_channels * srcW];

        pred[srcW] += 1 << s->mclms_scaling - 1;

        pred[srcW] >>= s->mclms_scaling;

        s->channel_residues[srcW][icoef] += pred[srcW];

    }

}
",190.0,57.0,"order:active_bits_size,ich:srcW,i:ioctl,",125.0,0.0896488308906555,MHM
1763,"static int emulated_exitfn(CCIDCardState *base)

{

    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);

    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);



    vevent_queue_vevent(vevent); /* stop vevent thread */

    qemu_mutex_lock(&card->apdu_thread_quit_mutex);

    card->quit_apdu_thread = 1; /* stop handle_apdu thread */

    qemu_cond_signal(&card->handle_apdu_cond);

    qemu_cond_wait(&card->apdu_thread_quit_cond,

                      &card->apdu_thread_quit_mutex);

    /* handle_apdu thread stopped, can destroy all of it's mutexes */

    qemu_cond_destroy(&card->handle_apdu_cond);

    qemu_cond_destroy(&card->apdu_thread_quit_cond);

    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);

    qemu_mutex_destroy(&card->handle_apdu_mutex);

    qemu_mutex_destroy(&card->vreader_mutex);

    qemu_mutex_destroy(&card->event_list_mutex);

    return 0;

}
","static int emulated_exitfn(CCIDCardState *base)

{

    EmulatedState *rule = DO_UPCAST(EmulatedState, base, base);

    VEvent *put_h264_qpel = vevent_new(VEVENT_LAST, NULL, NULL);



    vevent_queue_vevent(put_h264_qpel); /* stop vevent thread */

    qemu_mutex_lock(&rule->apdu_thread_quit_mutex);

    rule->quit_apdu_thread = 1; /* stop handle_apdu thread */

    qemu_cond_signal(&rule->handle_apdu_cond);

    qemu_cond_wait(&rule->apdu_thread_quit_cond,

                      &rule->apdu_thread_quit_mutex);

    /* handle_apdu thread stopped, can destroy all of it's mutexes */

    qemu_cond_destroy(&rule->handle_apdu_cond);

    qemu_cond_destroy(&rule->apdu_thread_quit_cond);

    qemu_mutex_destroy(&rule->apdu_thread_quit_mutex);

    qemu_mutex_destroy(&rule->handle_apdu_mutex);

    qemu_mutex_destroy(&rule->vreader_mutex);

    qemu_mutex_destroy(&rule->event_list_mutex);

    return 0;

}
",127.0,32.0,"vevent:put_h264_qpel,card:rule,",63.0,0.0456421415011088,MHM
1767,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)

{

    qpci_device_enable(d->pdev);

    d->addr = qpci_iomap(d->pdev, 0, NULL);

    g_assert(d->addr != NULL);

}
","void net(QVirtioPCIDevice *d)

{

    out0(d->pdev);

    d->addr = slotkey(d->pdev, 0, NULL);

    stb_phys(d->addr != NULL);

}
",40.0,9.0,"qvirtio_pci_device_enable:net,qpci_device_enable:out0,qpci_iomap:slotkey,g_assert:stb_phys,",186.0,0.1312943418820699,MHM
1772,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 8);

}
","void ff_cropTbl(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 8);

}
",45.0,11.0,"ff_put_h264_qpel8_mc31_msa:ff_cropTbl,",33.0,0.0171154538790384,MHM
1774,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
","uint32_t insn(clz)(uint32_t POWERPC_MMU_BOOKE206)

{

    int avccontext;

    for (avccontext = 32; POWERPC_MMU_BOOKE206; avccontext--)

        POWERPC_MMU_BOOKE206 >>= 1;

    return avccontext;

}
",32.0,8.0,"count:avccontext,x:POWERPC_MMU_BOOKE206,HELPER:insn,",123.0,0.0765353878339131,MHM
1778,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)

{

    SpiceTimer *timer;



    timer = qemu_mallocz(sizeof(*timer));

    timer->timer = qemu_new_timer(rt_clock, func, opaque);

    QTAILQ_INSERT_TAIL(&timers, timer, next);

    return timer;

}
","static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)

{

    SpiceTimer *timer;



    timer = qemu_mallocz(sizeof(*timer));

    timer->timer = qemu_new_timer(rt_clock, func, opaque);

    QTAILQ_INSERT_TAIL(&cmp2, timer, next);

    return timer;

}
",55.0,17.0,"timers:cmp2,",34.0,0.0173698822657267,MHM
1783,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           struct dirent **result)

{

    return readdir_r(fs->dir, entry, result);

}
","static int rom_memory(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *src_vt1,

                           struct dirent **result)

{

    return AV_PKT_FLAG_KEY(fs->dir, src_vt1, result);

}
",37.0,9.0,"entry:src_vt1,readdir_r:AV_PKT_FLAG_KEY,local_readdir_r:rom_memory,",127.0,0.0768862207730611,MHM
1785,"static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,

                                     unsigned size)

{

    MMIOState *s= opaque;

    return ide_status_read(&s->bus, 0);

}
","static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t uvlinesize,

                                     unsigned size)

{

    MMIOState *VideoDevice= opaque;

    return opp(&VideoDevice->bus, 0);

}
",33.0,8.0,"addr:uvlinesize,ide_status_read:opp,s:VideoDevice,",94.0,0.0584139466285705,MHM
1786,"void tlb_flush_page(CPUState *env, target_ulong addr)

{

    int i;



#if defined(DEBUG_TLB)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);

#endif

    /* must reset current TB so that interrupts cannot modify the

       links while we are modifying them */

    env->current_tb = NULL;



    addr &= TARGET_PAGE_MASK;

    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    tlb_flush_entry(&env->tlb_table[0][i], addr);

    tlb_flush_entry(&env->tlb_table[1][i], addr);

#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&env->tlb_table[2][i], addr);

#if (NB_MMU_MODES == 4)

    tlb_flush_entry(&env->tlb_table[3][i], addr);

#endif

#endif



    tlb_flush_jmp_cache(env, addr);



#ifdef USE_KQEMU

    if (env->kqemu_enabled) {

        kqemu_flush_page(env, addr);

    }

#endif

}
","void tlb_flush_page(CPUState *env, target_ulong addr)

{

    int i;



#if defined(par)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);

#endif

    /* must reset current TB so that interrupts cannot modify the

       links while we are modifying them */

    env->current_tb = NULL;



    addr &= CPSR_M;

    i = (addr >> scan8) & (oldv - 1);

    tlb_flush_entry(&env->tlb_table[0][i], addr);

    tlb_flush_entry(&env->tlb_table[1][i], addr);

#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&env->tlb_table[2][i], addr);

#if (NB_MMU_MODES == 4)

    tlb_flush_entry(&env->tlb_table[3][i], addr);

#endif

#endif



    delta(env, addr);



#ifdef parse

    if (env->kqemu_enabled) {

        kqemu_flush_page(env, addr);

    }

#endif

}
",163.0,41.0,"DEBUG_TLB:par,CPU_TLB_SIZE:oldv,tlb_flush_jmp_cache:delta,USE_KQEMU:parse,TARGET_PAGE_MASK:CPSR_M,TARGET_PAGE_BITS:scan8,",309.0,0.2132726907730102,MHM
1788,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,

                            AVPacket *avpkt)

{

    const char *ptr = avpkt->data;

    int len, size = avpkt->size;



    while (size > 0) {

        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);

        int duration = dialog->end - dialog->start;

        len = ff_ass_add_rect(data, ptr, 0, duration, 1);

        if (len < 0)

            return len;

        ptr  += len;

        size -= len;

    }



    *got_sub_ptr = avpkt->size > 0;

    return avpkt->size;

}
","static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,

                            AVPacket *avpkt)

{

    const char *ptr = avpkt->data;

    int len, rtc_state = avpkt->rtc_state;



    while (rtc_state > 0) {

        ASSDialog *codec_rate = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);

        int duration = codec_rate->end - codec_rate->start;

        len = ff_ass_add_rect(data, ptr, 0, duration, 1);

        if (len < 0)

            return len;

        ptr  += len;

        rtc_state -= len;

    }



    *got_sub_ptr = avpkt->rtc_state > 0;

    return avpkt->rtc_state;

}
",122.0,32.0,"size:rtc_state,dialog:codec_rate,",64.0,0.0431697527567545,MHM
1791,"static void test_dispatch_cmd_failure(void)

{

    QDict *req = qdict_new();


    QObject *resp;



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd2"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);



    /* check that with extra arguments it throws an error */

    req = qdict_new();

    qdict_put(args, ""a"", qint_from_int(66));

    qdict_put(req, ""arguments"", args);



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);

}","static void test_dispatch_cmd_failure(void)

{

    QDict *req = qdict_new();


    QObject *resp;



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd2"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdev_get_gpio_in(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);



    /* check that with extra arguments it throws an error */

    req = qdict_new();

    qdict_put(args, ""a"", qint_from_int(66));

    qdict_put(req, ""arguments"", args);



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdev_get_gpio_in(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);

}",165.0,48.0,"qdict_haskey:qdev_get_gpio_in,",33.0,0.0279887874921162,MHM
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
","static void hr(QEMUFile *endian, void *rusage, size_t prdt_len)

{

    uint64_t *TB_FLAGS_AMASK_MVI = rusage;

    input_files(endian, TB_FLAGS_AMASK_MVI);

}
",30.0,9.0,"put_uint64:hr,v:TB_FLAGS_AMASK_MVI,size:prdt_len,pv:rusage,f:endian,qemu_put_be64s:input_files,",456.0,0.3260762770970662,MHM
1796,"QJSON *qjson_new(void)

{

    QJSON *json = QJSON(object_new(TYPE_QJSON));

    return json;

}
","EIO *qjson_new(void)

{

    EIO *RRRN_T = EIO(object_new(TYPE_QJSON));

    return RRRN_T;

}
",23.0,6.0,"QJSON:EIO,json:RRRN_T,",62.0,0.0377428412437439,MHM
1804,"int nbd_client_session_co_flush(NbdClientSession *client)

{

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t ret;



    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {

        return 0;

    }



    request.type = NBD_CMD_FLUSH;

    if (client->nbdflags & NBD_FLAG_SEND_FUA) {

        request.type |= NBD_CMD_FLAG_FUA;

    }



    request.from = 0;

    request.len = 0;



    nbd_coroutine_start(client, &request);

    ret = nbd_co_send_request(client, &request, NULL, 0);

    if (ret < 0) {

        reply.error = -ret;

    } else {

        nbd_co_receive_reply(client, &request, &reply, NULL, 0);

    }

    nbd_coroutine_end(client, &request);

    return -reply.error;

}
","int nbd_client_session_co_flush(NbdClientSession *dh1)

{

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t ret;



    if (!(dh1->nbdflags & NBD_FLAG_SEND_FLUSH)) {

        return 0;

    }



    request.type = NBD_CMD_FLUSH;

    if (dh1->nbdflags & NBD_FLAG_SEND_FUA) {

        request.type |= NBD_CMD_FLAG_FUA;

    }



    request.from = 0;

    request.len = 0;



    nbd_coroutine_start(dh1, &request);

    ret = nbd_co_send_request(dh1, &request, NULL, 0);

    if (ret < 0) {

        reply.error = -ret;

    } else {

        nbd_co_receive_reply(dh1, &request, &reply, NULL, 0);

    }

    nbd_coroutine_end(dh1, &request);

    return -reply.error;

}
",139.0,33.0,"client:dh1,",34.0,0.0252056797345479,MHM
1809,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)

{

    f->xfer_limit = limit;

}
","void qemu_file_set_rate_limit(QEMUFile *xen_9pdev, int64_t limit)

{

    xen_9pdev->xfer_limit = limit;

}
",18.0,5.0,"f:xen_9pdev,",33.0,0.0232281883557637,MHM
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
","static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **real_islit)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, real_islit);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(real_islit, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
",102.0,27.0,"errp:real_islit,",33.0,0.0263698657353719,MHM
1812,"int select_watchdog(const char *p)

{

    WatchdogTimerModel *model;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}
","int select_watchdog(const char *p)

{

    WatchdogTimerModel *ERR;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        av_strlcpy(ERR, &method, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     ERR->wdt_name, ERR->wdt_description);

        }

        return 2;

    }



    av_strlcpy(ERR, &method, entry) {

        if (strcasecmp(ERR->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            filtered_frame(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    av_strlcpy(ERR, &method, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 ERR->wdt_name, ERR->wdt_description);

    }

    return 1;

}
",161.0,37.0,"qemu_opt_set:filtered_frame,model:ERR,LIST_FOREACH:av_strlcpy,watchdog_list:method,",188.0,0.1401425758997599,MHM
1815,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(f, len);

    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

}
","static void blk_send(QEMUFile *translate_kernel_address, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    pict(translate_kernel_address, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(translate_kernel_address, len);

    qemu_put_buffer(translate_kernel_address, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(translate_kernel_address);

        return;

    }



    qemu_put_buffer(translate_kernel_address, blk->buf, BLOCK_SIZE);

}
",125.0,37.0,"qemu_put_be64:pict,f:translate_kernel_address,",58.0,0.0459352374076843,MHM
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
","int vlan(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
",57.0,17.0,"qemu_devtree_setprop_string:vlan,",34.0,0.0203135212262471,MHM
1818,"static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,

                                         uint32_t *sums, int n, int pred_order)

{

    int i;

    int k, cnt, part;

    uint32_t all_bits;



    part     = (1 << porder);

    all_bits = 4 * part;



    cnt = (n >> porder) - pred_order;

    for (i = 0; i < part; i++) {

        k = find_optimal_param(sums[i], cnt);

        rc->params[i] = k;

        all_bits += rice_encode_count(sums[i], cnt, k);

        cnt = n >> porder;

    }



    rc->porder = porder;



    return all_bits;

}
","static uint32_t calc_optimal_rice_params(RiceContext *pixel_ptr, int porder,

                                         uint32_t *sums, int n, int tcg_gen_brcondi_i64)

{

    int i;

    int find_codec_or_die, cnt, part;

    uint32_t bus_num;



    part     = (1 << porder);

    bus_num = 4 * part;



    cnt = (n >> porder) - tcg_gen_brcondi_i64;

    for (i = 0; i < part; i++) {

        find_codec_or_die = find_optimal_param(sums[i], cnt);

        pixel_ptr->params[i] = find_codec_or_die;

        bus_num += rice_encode_count(sums[i], cnt, find_codec_or_die);

        cnt = n >> porder;

    }



    pixel_ptr->porder = porder;



    return bus_num;

}
",125.0,43.0,"pred_order:tcg_gen_brcondi_i64,rc:pixel_ptr,k:find_codec_or_die,all_bits:bus_num,",186.0,0.1206331928571065,MHM
1820,"int av_image_alloc(uint8_t *pointers[4], int linesizes[4],

                   int w, int h, enum PixelFormat pix_fmt, int align)

{

    int i, ret;

    uint8_t *buf;



    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)

        return ret;

    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)

        return ret;



    for (i = 0; i < 4; i++)

        linesizes[i] = FFALIGN(linesizes[i], align);



    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)

        return ret;

    buf = av_malloc(ret + align);

    if (!buf)

        return AVERROR(ENOMEM);

    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {

        av_free(buf);

        return ret;

    }

    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)

        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);



    return ret;

}
","int FPSCR_SZ(uint8_t *pointers[4], int linesizes[4],

                   int cpu_PR, int h, enum PixelFormat hz_out3, int align)

{

    int i, ret;

    uint8_t *vga_ram_size;



    if ((ret = ASSIGN_SSE_SCALE_FUNC(cpu_PR, h, 0, NULL)) < 0)

        return ret;

    if ((ret = arg6(linesizes, hz_out3, cpu_PR)) < 0)

        return ret;



    for (i = 0; i < 4; i++)

        linesizes[i] = FFALIGN(linesizes[i], align);



    if ((ret = av_image_fill_pointers(pointers, hz_out3, h, NULL, linesizes)) < 0)

        return ret;

    vga_ram_size = gen_fbcond(ret + align);

    if (!vga_ram_size)

        return PCI_FUNC(ENOMEM);

    if ((ret = av_image_fill_pointers(pointers, hz_out3, h, vga_ram_size, linesizes)) < 0) {

        av_free(vga_ram_size);

        return ret;

    }

    if (iov_to_buf[hz_out3].flags & PIX_FMT_PAL)

        imm((uint32_t*)pointers[1], hz_out3);



    return ret;

}
",213.0,61.0,"pix_fmt:hz_out3,av_image_alloc:FPSCR_SZ,av_image_check_size:ASSIGN_SSE_SCALE_FUNC,buf:vga_ram_size,av_image_fill_linesizes:arg6,ff_set_systematic_pal2:imm,w:cpu_PR,av_pix_fmt_descriptors:iov_to_buf,av_malloc:gen_fbcond,AVERROR:PCI_FUNC,",395.0,0.29327206214269,MHM
1821,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
","static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t cy)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!cy) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], cy);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
",96.0,23.0,"frame:cy,",33.0,0.0242042223612467,MHM
1822,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *vq)

{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, vq);

}
","static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *aml_method)

{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, aml_method);

}
",43.0,11.0,"vq:aml_method,",30.0,0.015365978082021,MHM
1836,"static void bitmap_free(Qcow2Bitmap *bm)
{
    g_free(bm->name);
    g_free(bm);","static void sysbus_mmio_map(Qcow2Bitmap *alignment)
{
    stb_phys(alignment->name);
    stb_phys(alignment);",22.0,6.0,"bm:alignment,bitmap_free:sysbus_mmio_map,g_free:stb_phys,",347.0,0.1788924654324849,MHM
1839,"static void qemu_enqueue_packet(VLANClientState *sender,

                                const uint8_t *buf, int size,

                                NetPacketSent *sent_cb)

{

    VLANPacket *packet;



    packet = qemu_malloc(sizeof(VLANPacket) + size);

    packet->sender = sender;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);



    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);

}
","static void qemu_enqueue_packet(VLANClientState *cpp,

                                const uint8_t *buf, int size,

                                NetPacketSent *sent_cb)

{

    tcg_gen_add_tl *fraction;



    fraction = qemu_malloc(sizeof(tcg_gen_add_tl) + size);

    fraction->cpp = cpp;

    fraction->size = size;

    fraction->sent_cb = sent_cb;

    memcpy(fraction->data, buf, size);



    TAILQ_INSERT_TAIL(&cpp->vlan->send_queue, fraction, bastate);

}
",81.0,24.0,"sender:cpp,VLANPacket:tcg_gen_add_tl,entry:bastate,packet:fraction,",122.0,0.0884222666422526,MHM
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    /* TO FIX */

    return 0;

}
","static inline uint64_t pthread_mutex_unlock(CPUPPCState *env)

{

    /* TO FIX */

    return 0;

}
",14.0,2.0,"cpu_ppc_get_tb:pthread_mutex_unlock,",32.0,0.0208365519841512,MHM
1845,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
","static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & vnet_hdr);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
",136.0,34.0,"pb_80:vnet_hdr,",33.0,0.0244124015172322,MHM
1851,"static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *locty_data)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        locty_data->w_buffer.buffer,

                                        locty_data->w_offset,

                                        locty_data->r_buffer.buffer,

                                        locty_data->r_buffer.size);

}
","static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *INT_MAX)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        INT_MAX->w_buffer.buffer,

                                        INT_MAX->w_offset,

                                        INT_MAX->r_buffer.buffer,

                                        INT_MAX->r_buffer.size);

}
",42.0,9.0,"locty_data:INT_MAX,",33.0,0.0247700015703837,MHM
1852,"void do_tw (int flags)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}
","void do_tw (int flags)

{

    if (!likely(!(((int32_t)page < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)page > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)page == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)page < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)page > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(pthread_mutex_lock, EXCP_TRAP);

    }

}
",116.0,21.0,"T0:page,EXCP_PROGRAM:pthread_mutex_lock,",63.0,0.0468440890312194,MHM
1856,"static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
","static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (sh(PCI_MSI_FLAGS_QSIZE) - 1));

}
",31.0,6.0,"ffs:sh,",36.0,0.0209768811861674,MHM
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
","static void test_validate_fail_union_anon(TestInputVisitorData *active,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *aml_io = NULL;



    v = ri(active, ""3.14"");



    nb_input_files(v, &tmp, NULL, &aml_io);

    g_assert(error_is_set(&aml_io));

    QCOW_OFLAG_COPIED(tmp);

}
",68.0,18.0,"validate_test_init:ri,errp:aml_io,data:active,qapi_free_UserDefAnonUnion:QCOW_OFLAG_COPIED,visit_type_UserDefAnonUnion:nb_input_files,",185.0,0.1212366859118143,MHM
1868,"void migrate_fd_connect(MigrationState *s)

{

    s->state = MIG_STATE_SETUP;

    trace_migrate_set_state(MIG_STATE_SETUP);



    /* This is a best 1st approximation. ns to ms */

    s->expected_downtime = max_downtime/1000000;

    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);



    qemu_file_set_rate_limit(s->file,

                             s->bandwidth_limit / XFER_LIMIT_RATIO);



    qemu_thread_create(&s->thread, migration_thread, s,

                       QEMU_THREAD_JOINABLE);

    notifier_list_notify(&migration_state_notifiers, s);

}
","void display_matrix(MigrationState *access_size_max)

{

    access_size_max->state = case_rgb;

    trace_migrate_set_state(case_rgb);



    /* This is a best 1st approximation. ns to ms */

    access_size_max->expected_downtime = max_downtime/1000000;

    access_size_max->cleanup_bh = exit_program(migrate_fd_cleanup, access_size_max);



    def(access_size_max->file,

                             access_size_max->bandwidth_limit / XFER_LIMIT_RATIO);



    data_size(&access_size_max->thread, src_vt7, access_size_max,

                       QEMU_THREAD_JOINABLE);

    notifier_list_notify(&migration_state_notifiers, access_size_max);

}
",74.0,24.0,"migration_thread:src_vt7,qemu_file_set_rate_limit:def,migrate_fd_connect:display_matrix,qemu_bh_new:exit_program,qemu_thread_create:data_size,MIG_STATE_SETUP:case_rgb,s:access_size_max,",278.0,0.2073938488960266,MHM
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
","void cpu_dump_state(CPUState *env, FILE *FIXHR, fprintf_function _WIN32,

        int flags)

{

    int QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;



    _WIN32(FIXHR, ""PC=%08x\n"", env->pc);



    for (QCRYPTO_BLOCK_LUKS_SECTOR_SIZE = 0; QCRYPTO_BLOCK_LUKS_SECTOR_SIZE < 16; ++QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) {

        _WIN32(FIXHR, ""A%02d=%08x%c"", QCRYPTO_BLOCK_LUKS_SECTOR_SIZE, env->regs[QCRYPTO_BLOCK_LUKS_SECTOR_SIZE],

                (QCRYPTO_BLOCK_LUKS_SECTOR_SIZE % 4) == 3 ? '\n' : ' ');

    }

}
",82.0,18.0,"i:QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,cpu_fprintf:_WIN32,f:FIXHR,",94.0,0.0702992359797159,MHM
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
","void visit_type_bool(Visitor *mot_stride, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        mot_stride->type_bool(mot_stride, obj, name, errp);

    }

}
",46.0,12.0,"v:mot_stride,",33.0,0.0231836160024007,MHM
1893,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
","static AddressSpace *s390_pci_dma_iommu(PCIBus *av_malloc, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
",38.0,9.0,"bus:av_malloc,",35.0,0.0182723840077718,MHM
1895,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
","static void aml_eisaid(TCGContext *s, TCGType type, TCGReg uvoff, TCGReg tpm2_ptr)

{

    uint8_t *bytestream_put_byte = s->code_ptr;

    dp(uvoff != tpm2_ptr);

#if stfs == 32

    tcg_out_op_t(s, name_len);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    chapters(s, uvoff);

    chapters(s, tpm2_ptr);

    bytestream_put_byte[1] = s->code_ptr - bytestream_put_byte;

}
",80.0,26.0,"assert:dp,INDEX_op_mov_i32:name_len,old_code_ptr:bytestream_put_byte,ret:uvoff,tcg_out_mov:aml_eisaid,tcg_out_r:chapters,arg:tpm2_ptr,TCG_TARGET_REG_BITS:stfs,",281.0,0.1999855677286784,MHM
1903,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    assert(port || discard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);

}
","static void flush_queued_data(VirtIOSerialPort *tcg_gen_qemu_ld_i32, bool discard)

{

    assert(tcg_gen_qemu_ld_i32 || discard);



    do_flush_queued_data(tcg_gen_qemu_ld_i32, tcg_gen_qemu_ld_i32->ovq, &tcg_gen_qemu_ld_i32->vser->vdev, discard);

}
",38.0,11.0,"port:tcg_gen_qemu_ld_i32,",33.0,0.0186492840449015,MHM
1911,"static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    return !s->in_len;

}
","static int st_index(NetClientState *pthread_mutex_lock)

{

    USBNetState *current_entry = av_free(pthread_mutex_lock);



    if (!current_entry->dev.config) {

        return 0;

    }



    if (is_rndis(current_entry) && current_entry->rndis_state != opc) {

        return 1;

    }



    return !current_entry->in_len;

}
",57.0,11.0,"nc:pthread_mutex_lock,usbnet_can_receive:st_index,s:current_entry,qemu_get_nic_opaque:av_free,RNDIS_DATA_INITIALIZED:opc,",433.0,0.2991566777229309,MHM
1915,"static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *ctx = avctx->priv_data;

    av_freep(&ctx->buf);

    ctx->buf_size = 0;

    return 0;

}
","static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *cpu_to_be32 = avctx->priv_data;

    av_freep(&cpu_to_be32->buf);

    cpu_to_be32->buf_size = 0;

    return 0;

}
",36.0,8.0,"ctx:cpu_to_be32,",33.0,0.0172651648521423,MHM
1918,"static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);



    /* USB misc control 1/2 */

    pci_set_long(pci_conf + 0x40,0x00001000);

    /* PM capability */

    pci_set_long(pci_conf + 0x80,0x00020001);

    /* USB legacy support  */

    pci_set_long(pci_conf + 0xc0,0x00002000);



    return usb_uhci_common_initfn(s);

}
","static int sp(PCIDevice *x0)

{

    opkt *s = gf(opkt, x0, x0);

    uint8_t *cap = s->x0.config;



    y(cap, fpscr);

    AVMEDIA_TYPE_AUDIO(cap, qerror_report_err);



    /* USB misc control 1/2 */

    ff_zigzag_direct(cap + 0x40,0x00001000);

    /* PM capability */

    ff_zigzag_direct(cap + 0x80,0x00020001);

    /* USB legacy support  */

    ff_zigzag_direct(cap + 0xc0,0x00002000);



    return bS(s);

}
",80.0,23.0,"pci_set_long:ff_zigzag_direct,pci_config_set_vendor_id:y,PCI_DEVICE_ID_VIA_UHCI:qerror_report_err,UHCIState:opkt,pci_config_set_device_id:AVMEDIA_TYPE_AUDIO,usb_uhci_vt82c686b_initfn:sp,PCI_VENDOR_ID_VIA:fpscr,DO_UPCAST:gf,usb_uhci_common_initfn:bS,dev:x0,pci_conf:cap,",487.0,0.3149602214495341,MHM
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
","static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv mb_type)

{

    int freeaddrinfo = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (freeaddrinfo < avio_close || freeaddrinfo > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(freeaddrinfo);

        }

    } else {

        tmp = new_tmp();

        sign(command_usage, freeaddrinfo);

        VA_INVALID_ID(tmp, command_usage);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    DHCPDISCOVER(mb_type, tmp);

    dead_tmp(tmp);

    return 0;

}
",114.0,32.0,"cpu_V0:command_usage,ARM_IWMMXT_wCGR0:avio_close,iwmmxt_load_reg:sign,tcg_gen_mov_i32:DHCPDISCOVER,dest:mb_type,tcg_gen_trunc_i64_i32:VA_INVALID_ID,rd:freeaddrinfo,",339.0,0.2443822662035624,MHM
1923,"static int get_htab_fd(sPAPRMachineState *spapr)

{

    if (spapr->htab_fd >= 0) {

        return spapr->htab_fd;

    }



    spapr->htab_fd = kvmppc_get_htab_fd(false);

    if (spapr->htab_fd < 0) {

        error_report(""Unable to open fd for reading hash table from KVM: %s"",

                     strerror(errno));

    }



    return spapr->htab_fd;

}
","static int get_htab_fd(sPAPRMachineState *spapr)

{

    if (spapr->htab_fd >= 0) {

        return spapr->htab_fd;

    }



    spapr->htab_fd = TCG_REG_O1(false);

    if (spapr->htab_fd < 0) {

        error_report(""Unable to open fd for reading hash table from KVM: %s"",

                     strerror(errno));

    }



    return spapr->htab_fd;

}
",60.0,11.0,"kvmppc_get_htab_fd:TCG_REG_O1,",35.0,0.0189282615979512,MHM
1926,"static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,

                                                const void *unused)

{

    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);

}
","static void cpu_register_io_memory(TestOutputVisitorData *saved,

                                                const void *omap_l4ta)

{

    irqfd(saved, omap_l4ta, nf);

}
",24.0,7.0,"test_visitor_out_native_list_uint16:cpu_register_io_memory,test_native_list:irqfd,unused:omap_l4ta,data:saved,USER_DEF_NATIVE_LIST_UNION_KIND_U16:nf,",369.0,0.20074356396993,MHM
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint16(DeviceState *av_get_channel_layout_nb_channels, Property *prop, const char *str)

{

    uint16_t *slice_type = qdev_get_prop_ptr(av_get_channel_layout_nb_channels, prop);

    const char *reg;



    /* accept both hex and decimal */

    reg = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" CASE_MODRM_MEM_OP;

    if (sscanf(str, reg, slice_type) != 1)

        return -path;

    return 0;

}
",77.0,19.0,"PRIu16:CASE_MODRM_MEM_OP,dev:av_get_channel_layout_nb_channels,EINVAL:path,fmt:reg,ptr:slice_type,",157.0,0.1183637261390686,MHM
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
","void CONFIG_AVFILTER(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
",48.0,13.0,"replay_input_event:CONFIG_AVFILTER,",34.0,0.0195531129837036,MHM
1936,"static inline unsigned int get_uint(ShortenContext *s, int k)

{

    if (s->version != 0)

        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&s->gb, k);

}
","static inline unsigned int get_uint(ShortenContext *s, int k)

{

    if (s->version != 0)

        k = get_ur_golomb_shorten(&s->gb, S390_CPU);

    return get_ur_golomb_shorten(&s->gb, k);

}
",46.0,11.0,"ULONGSIZE:S390_CPU,",33.0,0.022253143787384,MHM
1941,"static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}
","static void nb_available(void)

{

    QObject *ERANGE = time_base(""[32,"", NULL);

    TCG_TARGET_REG_BITS(ERANGE == NULL);

}
",27.0,5.0,"obj:ERANGE,unterminated_array_comma:nb_available,g_assert:TCG_TARGET_REG_BITS,qobject_from_json:time_base,",371.0,0.1983482718467712,MHM
1943,"void prepare_grab(void)

{

    fprintf(stderr, ""Must supply at least one input file\n"");

    exit(1);

}
","void prepare_grab(void)

{

    fprintf(stderr, ""Must supply at least one input file\n"");

    output_samples(1);

}
",21.0,4.0,"exit:output_samples,",34.0,0.0149487257003784,MHM
1944,"static int compare_codec_desc(const void *a, const void *b)

{

    const AVCodecDescriptor * const *da = a;

    const AVCodecDescriptor * const *db = b;



    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :

           strcmp((*da)->name, (*db)->name);

}
","static int compare_codec_desc(const void *avfilter_unref_buffer, const void *b)

{

    const AVCodecDescriptor * const *da = avfilter_unref_buffer;

    const AVCodecDescriptor * const *db = b;



    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :

           strcmp((*da)->name, (*db)->name);

}
",80.0,14.0,"a:avfilter_unref_buffer,",32.0,0.0172286391258239,MHM
1948,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    DIAG288Class *diag288 = DIAG288_CLASS(klass);



    dc->realize = wdt_diag288_realize;

    dc->unrealize = wdt_diag288_unrealize;

    dc->reset = wdt_diag288_reset;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->vmsd = &vmstate_diag288;

    diag288->handle_timer = wdt_diag288_handle_timer;

}","static void wdt_diag288_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *extent_path = DEVICE_CLASS(klass);

    DIAG288Class *diag288 = float_raise(klass);



    extent_path->realize = wdt_diag288_realize;

    extent_path->unrealize = wdt_diag288_unrealize;

    extent_path->reset = CODEC_ID_PCM_S16BE;


    set_bit(DEVICE_CATEGORY_MISC, extent_path->categories);

    extent_path->vmsd = &vmstate_diag288;

    diag288->handle_timer = wdt_diag288_handle_timer;

}",72.0,22.0,"DIAG288_CLASS:float_raise,wdt_diag288_reset:CODEC_ID_PCM_S16BE,dc:extent_path,",156.0,0.0926283041636149,MHM
1955,"static void flatview_ref(FlatView *view)

{

    atomic_inc(&view->ref);

}
","static void src(FlatView *nargs)

{

    atomic_inc(&nargs->ref);

}
",18.0,4.0,"flatview_ref:src,view:nargs,",64.0,0.0363351623217264,MHM
1956,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}","static int huff_build10(VLC *vlc, uint8_t *len)

{

    program_name he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t msr_ir;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    p_end(he, 1024, program_name, huff_cmp_len10);



    msr_ir = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = msr_ir >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        msr_ir += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}",238.0,58.0,"HuffEntry:program_name,code:msr_ir,AV_QSORT:p_end,",93.0,0.086296526590983,MHM
1957,"static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
","static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *SIG_SETMASK;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    SIG_SETMASK = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == SIG_SETMASK);



    object_unref(obj);

    object_unref(SIG_SETMASK);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
",107.0,31.0,"src:SIG_SETMASK,",33.0,0.0261533617973327,MHM
1962,"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}","av_cold int ff_ivi_decode_close(AVCodecContext *cpu_convert_to_target32)
{
    IVI45DecContext *ctx = cpu_convert_to_target32->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}",60.0,12.0,"avctx:cpu_convert_to_target32,",33.0,0.0276128729184468,MHM
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)

{

    if (throttle_conflicting(cfg, errp)) {

        return false;

    }



    if (!throttle_is_valid(cfg, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(cfg, errp)) {

        return false;

    }



    return true;

}
","static bool check_throttle_config(ThrottleConfig *pr, Error **errp)

{

    if (fn11(pr, errp)) {

        return false;

    }



    if (!tcg_gen_mul_i64(pr, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(pr, errp)) {

        return false;

    }



    return true;

}
",61.0,12.0,"throttle_conflicting:fn11,throttle_is_valid:tcg_gen_mul_i64,cfg:pr,",95.0,0.0517782330513,MHM
1967,"void qemu_main_loop_start(void)

{

}
","void qstring_from_str(void)

{

}
",7.0,1.0,"qemu_main_loop_start:qstring_from_str,",62.0,0.0387210726737976,MHM
1969,"static void cpu_devinit(const char *cpu_model, unsigned int id,

                        uint64_t prom_addr, qemu_irq **cpu_irqs)

{

    CPUState *cs;

    SPARCCPU *cpu;

    CPUSPARCState *env;



    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    env = &cpu->env;



    cpu_sparc_set_id(env, id);

    if (id == 0) {

        qemu_register_reset(main_cpu_reset, cpu);

    } else {

        qemu_register_reset(secondary_cpu_reset, cpu);

        cs = CPU(cpu);

        cs->halted = 1;

    }

    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);

    env->prom_addr = prom_addr;

}
","static void cpu_devinit(const char *cpu_model, unsigned int id,

                        uint64_t prom_addr, qemu_irq **cpu_irqs)

{

    CPUState *cs;

    SPARCCPU *line_end;

    CPUSPARCState *env;



    line_end = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));

    if (line_end == NULL) {

        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    env = &line_end->env;



    cpu_sparc_set_id(env, id);

    if (id == 0) {

        qemu_register_reset(main_cpu_reset, line_end);

    } else {

        qemu_register_reset(secondary_cpu_reset, line_end);

        cs = CPU(line_end);

        cs->halted = 1;

    }

    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, line_end, MAX_PILS);

    env->prom_addr = prom_addr;

}
",139.0,40.0,"cpu:line_end,",32.0,0.0248064080874125,MHM
1971,"static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)

{

    int i;



    if ((p[1] & 0xF) == 3) {

        /* NAA designator type */

        if (p[3] != 8) {

            return -EINVAL;

        }

        *p_wwn = ldq_be_p(p + 4);

        return 0;

    }



    if ((p[1] & 0xF) == 8) {

        /* SCSI name string designator type */

        if (p[3] < 20 || memcmp(&p[4], ""naa."", 4)) {

            return -EINVAL;

        }

        if (p[3] > 20 && p[24] != ',') {

            return -EINVAL;

        }

        *p_wwn = 0;

        for (i = 8; i < 24; i++) {

            char c = toupper(p[i]);

            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);

            *p_wwn = (*p_wwn << 4) | c;

        }

        return 0;

    }



    return -EINVAL;

}
","static int read_naa_id(const uint8_t *lab2, uint64_t *p_wwn)

{

    int i;



    if ((lab2[1] & 0xF) == 3) {

        /* NAA designator type */

        if (lab2[3] != 8) {

            return -EINVAL;

        }

        *p_wwn = ldq_be_p(lab2 + 4);

        return 0;

    }



    if ((lab2[1] & 0xF) == 8) {

        /* SCSI name string designator type */

        if (lab2[3] < 20 || memcmp(&lab2[4], ""naa."", 4)) {

            return -EINVAL;

        }

        if (lab2[3] > 20 && lab2[24] != ',') {

            return -EINVAL;

        }

        *p_wwn = 0;

        for (i = 8; i < 24; i++) {

            char c = toupper(lab2[i]);

            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);

            *p_wwn = (*p_wwn << 4) | c;

        }

        return 0;

    }



    return -EINVAL;

}
",200.0,33.0,"p:lab2,",34.0,0.0324380358060201,MHM
1982,"static void ehci_update_frindex(EHCIState *ehci, int frames)

{

    int i;



    if (!ehci_enabled(ehci)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ehci->frindex += 8;



        if (ehci->frindex == 0x00002000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

        }



        if (ehci->frindex == 0x00004000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

            ehci->frindex = 0;

            if (ehci->usbsts_frindex >= 0x00004000) {

                ehci->usbsts_frindex -= 0x00004000;

            } else {

                ehci->usbsts_frindex = 0;

            }

        }

    }

}
","static void ehci_update_frindex(EHCIState *rem, int frames)

{

    int i;



    if (!ehci_enabled(rem)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        rem->frindex += 8;



        if (rem->frindex == 0x00002000) {

            ehci_raise_irq(rem, USBSTS_FLR);

        }



        if (rem->frindex == 0x00004000) {

            ehci_raise_irq(rem, USBSTS_FLR);

            rem->frindex = 0;

            if (rem->usbsts_frindex >= 0x00004000) {

                rem->usbsts_frindex -= 0x00004000;

            } else {

                rem->usbsts_frindex = 0;

            }

        }

    }

}
",114.0,23.0,"ehci:rem,",33.0,0.0229942798614501,MHM
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(refcount_table_index(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
",49.0,10.0,"mxf_match_uid:refcount_table_index,",32.0,0.022459332148234,MHM
1988,"static void continue_after_map_failure(void *opaque)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;



    dbs->bh = qemu_bh_new(reschedule_dma, dbs);

    qemu_bh_schedule(dbs->bh);

}
","static void continue_after_map_failure(void *target_fl)

{

    DMAAIOCB *CODEC_ID_NONE = (DMAAIOCB *)target_fl;



    CODEC_ID_NONE->bh = iotlb(top_field_first, CODEC_ID_NONE);

    qemu_bh_schedule(CODEC_ID_NONE->bh);

}
",38.0,10.0,"dbs:CODEC_ID_NONE,opaque:target_fl,qemu_bh_new:iotlb,reschedule_dma:top_field_first,",217.0,0.1544974565505981,MHM
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
","sPAPRDRConnector *vser(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
",56.0,15.0,"spapr_drc_by_index:vser,",32.0,0.0235877195994059,MHM
1996,"void pci_qdev_register(PCIDeviceInfo *info)

{

    info->qdev.init = pci_qdev_init;

    info->qdev.bus_type = BUS_TYPE_PCI;

    qdev_register(&info->qdev);

}
","void pci_qdev_register(PCIDeviceInfo *DEVICE)

{

    DEVICE->qdev.init = pci_qdev_init;

    DEVICE->qdev.bus_type = end;

    pci_word_test_and_set_mask(&DEVICE->qdev);

}
",33.0,8.0,"BUS_TYPE_PCI:end,qdev_register:pci_word_test_and_set_mask,info:DEVICE,",183.0,0.1218374331792195,MHM
2002,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)

{

    val = cpu_to_be64(val);

    cpu_physical_memory_write(addr, &val, 8);

}
","void stq_be_phys(target_phys_addr_t LOG_MMU, uint64_t val)

{

    val = tcg_gen_ext16u_tl(val);

    cpu_physical_memory_write(LOG_MMU, &val, 8);

}
",28.0,9.0,"cpu_to_be64:tcg_gen_ext16u_tl,addr:LOG_MMU,",62.0,0.0369430661201477,MHM
2008,"static void net_l2tpv3_cleanup(NetClientState *nc)

{

    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);

    qemu_purge_queued_packets(nc);

    l2tpv3_read_poll(s, false);

    l2tpv3_write_poll(s, false);

    if (s->fd > 0) {

        close(s->fd);

    }

    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);

    g_free(s->vec);

    g_free(s->header_buf);

    g_free(s->dgram_dst);

}
","static void net_l2tpv3_cleanup(NetClientState *nc)

{

    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);

    qemu_purge_queued_packets(nc);

    l2tpv3_read_poll(s, false);

    src_vt3(s, false);

    if (s->fd > 0) {

        close(s->fd);

    }

    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);

    g_free(s->vec);

    g_free(s->header_buf);

    g_free(s->dgram_dst);

}
",91.0,26.0,"l2tpv3_write_poll:src_vt3,",32.0,0.0263751586278279,MHM
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
","static int AVMEDIA_TYPE_AUDIO(QEMUIOVector *FD_ZERO)

{

    int i;



    for (i = 0; i < FD_ZERO->niov; i++) {

        if ((uintptr_t) FD_ZERO->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
",54.0,10.0,"qiov_is_aligned:AVMEDIA_TYPE_AUDIO,qiov:FD_ZERO,",65.0,0.0436238924662272,MHM
2024,"void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}
","void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *buf_size = (struct wm8750_s *) opaque;



    buf_size->ext_adc_hz = hz;

    buf_size->ext_dac_hz = hz;

    wm8750_clk_update(buf_size, 1);

}
",43.0,11.0,"s:buf_size,",33.0,0.0207946419715881,MHM
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
","static inline int ehci_set_state(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
",30.0,8.0,"sd_wp_addr:ehci_set_state,",33.0,0.0167918443679809,MHM
2032,"void ff_h264_init_dequant_tables(H264Context *h)

{

    int i, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (i = 0; i < 6; i++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[i][0][x] = 1 << 6;

    }

}
","void http_log(H264Context *OPENPIC_OUTPUT_NB)

{

    int RSC, hasAlpha;

    FF_THREAD_FRAME(OPENPIC_OUTPUT_NB);

    if (OPENPIC_OUTPUT_NB->pps.transform_8x8_mode)

        temp5(OPENPIC_OUTPUT_NB);

    if (OPENPIC_OUTPUT_NB->sps.transform_bypass) {

        for (RSC = 0; RSC < 6; RSC++)

            for (hasAlpha = 0; hasAlpha < 16; hasAlpha++)

                OPENPIC_OUTPUT_NB->dequant4_coeff[RSC][0][hasAlpha] = 1 << 6;

        if (OPENPIC_OUTPUT_NB->pps.transform_8x8_mode)

            for (RSC = 0; RSC < 6; RSC++)

                for (hasAlpha = 0; hasAlpha < 64; hasAlpha++)

                    OPENPIC_OUTPUT_NB->dequant8_coeff[RSC][0][hasAlpha] = 1 << 6;

    }

}
",136.0,29.0,"ff_h264_init_dequant_tables:http_log,init_dequant4_coeff_table:FF_THREAD_FRAME,x:hasAlpha,i:RSC,init_dequant8_coeff_table:temp5,h:OPENPIC_OUTPUT_NB,",273.0,0.2038269201914469,MHM
2036,"envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, ev_link);



		free((char *)entry->ev_var);

		free(entry);

	}

	free(envlist);

}
","envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, ev_link);



		serial_mm_init((char *)entry->ev_var);

		serial_mm_init(entry);

	}

	serial_mm_init(envlist);

}
",68.0,17.0,"free:serial_mm_init,",61.0,0.0519092321395874,MHM
2048,"static int virtio_serial_device_exit(DeviceState *dev)

{

    VirtIOSerial *vser = VIRTIO_SERIAL(dev);

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);



    unregister_savevm(dev, ""virtio-console"", vser);



    g_free(vser->ivqs);

    g_free(vser->ovqs);

    g_free(vser->ports_map);

    if (vser->post_load) {

        g_free(vser->post_load->connected);

        timer_del(vser->post_load->timer);

        timer_free(vser->post_load->timer);

        g_free(vser->post_load);

    }

    virtio_cleanup(vdev);

    return 0;

}
","static int virtio_serial_device_exit(DeviceState *pci_add_capability)

{

    VirtIOSerial *stream_component_open = VIRTIO_SERIAL(pci_add_capability);

    VirtIODevice *vdev = coeff1l(pci_add_capability);



    buf_start_second_field(pci_add_capability, ""virtio-console"", stream_component_open);



    g_free(stream_component_open->ivqs);

    g_free(stream_component_open->ovqs);

    g_free(stream_component_open->ports_map);

    if (stream_component_open->post_load) {

        g_free(stream_component_open->post_load->connected);

        timer_del(stream_component_open->post_load->timer);

        timer_free(stream_component_open->post_load->timer);

        g_free(stream_component_open->post_load);

    }

    virtio_cleanup(vdev);

    return 0;

}
",109.0,28.0,"vser:stream_component_open,unregister_savevm:buf_start_second_field,VIRTIO_DEVICE:coeff1l,dev:pci_add_capability,",191.0,0.1383505741755167,MHM
2049,"int kvm_arch_init_vcpu(CPUState *cenv)

{

    int ret = 0;

    struct kvm_sregs sregs;



    sregs.pvr = cenv->spr[SPR_PVR];

    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);



    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);



    return ret;

}
","int kvm_arch_init_vcpu(CPUState *cenv)

{

    int ret = 0;

    struct kvm_sregs sregs;



    sregs.pvr = cenv->spr[SPR_PVR];

    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);



    idle_timer = qemu_new_timer_ns(cpu_convert_to_target32, kvm_kick_env, cenv);



    return ret;

}
",55.0,18.0,"vm_clock:cpu_convert_to_target32,",33.0,0.0259828011194864,MHM
2050,"static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);","static void virtio_queue_notify_vq(VirtQueue *pci_device_rev)
{
    if (pci_device_rev->vring.desc && pci_device_rev->handle_output) {
        VirtIODevice *vdev = pci_device_rev->vdev;
        PIX_FMT_YUV420P(vdev, pci_device_rev - vdev->pci_device_rev, pci_device_rev);
        pci_device_rev->handle_output(vdev, pci_device_rev);",52.0,14.0,"vq:pci_device_rev,trace_virtio_queue_notify:PIX_FMT_YUV420P,",92.0,0.0670259118080139,MHM
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
","void uid (CPUPPCState *pci_irqs, uint32_t value)

{

    EINVAL = (value >> target_to_host_timespec) & 0x01;

    x86_stw_phys = (value >> pixr) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    page_size = (value >> off_idx) & 0xFF;

    colors = (value >> XER_BC) & 0x3F;

}
",62.0,18.0,"XER_CMP:off_idx,xer_bc:colors,ppc_store_xer:uid,XER_OV:pixr,XER_SO:target_to_host_timespec,xer_cmp:page_size,xer_so:EINVAL,xer_ov:x86_stw_phys,env:pci_irqs,",401.0,0.3017587343851725,MHM
2056,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
","static void command_usage(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int swri_audio_convert_free;



    swri_audio_convert_free = prop->get(obj, errp);

    cw(v, &swri_audio_convert_free, prop->strings, NULL, name, errp);

}
",66.0,19.0,"visit_type_enum:cw,value:swri_audio_convert_free,property_get_enum:command_usage,",92.0,0.0681488792101542,MHM
2057,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
","static int path_has_protocol(const char *md)

{

#ifdef _WIN32

    if (is_windows_drive(md) ||

        is_windows_drive_prefix(md)) {

        return 0;

    }

#endif



    return strchr(md, ':') != NULL;

}
",42.0,9.0,"path:md,",33.0,0.0203553199768066,MHM
2062,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));


    return chr;

}","translate_kernel_address *CODEC_TYPE_VIDEO(void)

{

    translate_kernel_address *chr = g_malloc0(sizeof(translate_kernel_address));


    return chr;

}",23.0,5.0,"CharDriverState:translate_kernel_address,qemu_chr_alloc:CODEC_TYPE_VIDEO,",157.0,0.1028193990389506,MHM
2067,"int bdrv_is_read_only(BlockDriverState *bs)

{

    return bs->read_only;

}
","int qdev_create(BlockDriverState *FD_ZERO)

{

    return FD_ZERO->read_only;

}
",14.0,3.0,"bs:FD_ZERO,bdrv_is_read_only:qdev_create,",95.0,0.066821010907491,MHM
2069,"void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)

{

    TranslationBlock *tb;

    int ret;

    unsigned long pc;

    CPUX86State *saved_env;



    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;



    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);

    if (ret) {

        if (retaddr) {

            /* now we have a real cpu fault */

            pc = (unsigned long)retaddr;

            tb = tb_find_pc(pc);

            if (tb) {

                /* the PC is inside the translated code. It means that we have

                   a virtual CPU fault */

                cpu_restore_state(tb, env, pc, NULL);

            }

        }

        if (retaddr)

            raise_exception_err(EXCP0E_PAGE, env->error_code);

        else

            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);

    }

    env = saved_env;

}
","void cost(target_ulong addr, int t1, int cluster_bytes, void *matroska)

{

    TranslationBlock *tb;

    int ret;

    unsigned long devfn;

    CPUX86State *cert;



    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    cert = env;

    env = cpu_single_env;



    ret = mediatype(env, addr, t1, cluster_bytes, 1);

    if (ret) {

        if (matroska) {

            /* now we have a real cpu fault */

            devfn = (unsigned long)matroska;

            tb = smk(devfn);

            if (tb) {

                /* the PC is inside the translated code. It means that we have

                   a virtual CPU fault */

                uint64_t(tb, env, devfn, NULL);

            }

        }

        if (matroska)

            raise_exception_err(EXCP0E_PAGE, env->error_code);

        else

            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);

    }

    env = cert;

}
",127.0,40.0,"tlb_fill:cost,is_write:t1,cpu_restore_state:uint64_t,saved_env:cert,retaddr:matroska,pc:devfn,cpu_x86_handle_mmu_fault:mediatype,tb_find_pc:smk,is_user:cluster_bytes,",370.0,0.3079314112663269,MHM
2070,"static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
","static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t address_space_memory = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, address_space_memory);

    load_tco(&d);

    start_tco(&d);

    clock_step(address_space_memory * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + nfds, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    AV_CH_LAYOUT_STEREO();

}
",192.0,55.0,"TCO_DAT_OUT:nfds,qtest_end:AV_CH_LAYOUT_STEREO,ticks:address_space_memory,",124.0,0.1182769815127054,MHM
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
","static void add_cpreg_to_list(gpointer recv, gpointer crop_left)

{

    ARMCPU *cpu = crop_left;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)recv;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
",78.0,20.0,"opaque:crop_left,key:recv,",64.0,0.0484063784281412,MHM
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(cpu)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    wi.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wi;

    } else {

        cpu->queued_work_last->next = &wi;

    }

    cpu->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(cpu);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
","void run_on_cpu(CPUState *cpu, void (*S)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(cpu)) {

        S(data);

        return;

    }



    wi.S = S;

    wi.data = data;

    wi.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wi;

    } else {

        cpu->queued_work_last->next = &wi;

    }

    cpu->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(cpu);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
",143.0,34.0,"func:S,",32.0,0.0205163399378458,MHM
2083,"static unsigned int event_status_media(IDEState *s,

                                       uint8_t *buf)

{

    uint8_t event_code, media_status;



    media_status = 0;

    if (s->tray_open) {

        media_status = MS_TRAY_OPEN;

    } else if (bdrv_is_inserted(s->bs)) {

        media_status = MS_MEDIA_PRESENT;

    }



    /* Event notification descriptor */

    event_code = MEC_NO_CHANGE;

    if (media_status != MS_TRAY_OPEN) {

        if (s->events.new_media) {

            event_code = MEC_NEW_MEDIA;

            s->events.new_media = false;

        } else if (s->events.eject_request) {

            event_code = MEC_EJECT_REQUESTED;

            s->events.eject_request = false;

        }

    }



    buf[4] = event_code;

    buf[5] = media_status;



    /* These fields are reserved, just clear them. */

    buf[6] = 0;

    buf[7] = 0;



    return 8; /* We wrote to 4 extra bytes from the header */

}
","static unsigned int TARGET_MIPS(IDEState *s,

                                       uint8_t *first_free_cluster)

{

    uint8_t event_code, media_status;



    media_status = 0;

    if (s->tray_open) {

        media_status = MS_TRAY_OPEN;

    } else if (PU(s->bs)) {

        media_status = desc_pa;

    }



    /* Event notification descriptor */

    event_code = flush_put_bits;

    if (media_status != MS_TRAY_OPEN) {

        if (s->events.new_media) {

            event_code = MEC_NEW_MEDIA;

            s->events.new_media = false;

        } else if (s->events.eject_request) {

            event_code = csum_offset;

            s->events.eject_request = false;

        }

    }



    first_free_cluster[4] = event_code;

    first_free_cluster[5] = media_status;



    /* These fields are reserved, just clear them. */

    first_free_cluster[6] = 0;

    first_free_cluster[7] = 0;



    return 8; /* We wrote to 4 extra bytes from the header */

}
",140.0,31.0,"MEC_NO_CHANGE:flush_put_bits,bdrv_is_inserted:PU,buf:first_free_cluster,event_status_media:TARGET_MIPS,MEC_EJECT_REQUESTED:csum_offset,MS_MEDIA_PRESENT:desc_pa,",275.0,0.224750820795695,MHM
2098,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)

{

    return timer_list->clock->type;

}
","QEMUClockType bm(QEMUTimerList *RSC)

{

    return RSC->clock->type;

}
",16.0,3.0,"timerlist_get_clock:bm,timer_list:RSC,",126.0,0.0877343893051147,MHM
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
","void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *avcodec_find_encoder)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)avcodec_find_encoder)[ src[i] ]);

}
",66.0,16.0,"palette:avcodec_find_encoder,",33.0,0.0260375022888183,MHM
2108,"static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    }

}
","static void monitor_puts(Monitor *mon, const char *str)

{

    char essence_offset;



    for(;;) {

        essence_offset = *str++;

        if (essence_offset == '\0')

            break;

        if (essence_offset == '\n') {

            KC(mon->outbuf, '\r');

        }

        KC(mon->outbuf, essence_offset);

        if (essence_offset == '\n') {

            changed(mon);

        }

    }

}
",86.0,16.0,"monitor_flush:changed,qstring_append_chr:KC,c:essence_offset,",126.0,0.0971875747044881,MHM
2112,"static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
","static int decode_copy(uint8_t *frame, int width, int cpu_tmp0,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * cpu_tmp0;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
",58.0,16.0,"height:cpu_tmp0,",33.0,0.018219510714213,MHM
2113,"static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);



    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    case NVME_CMD_FLUSH:

        return nvme_flush(n, ns, cmd, req);

    case NVME_CMD_WRITE_ZEROS:

        return nvme_write_zeros(n, ns, cmd, req);

    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, req);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    }

}
","static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);



    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    case argv_w:

        return nvme_flush(n, ns, cmd, req);

    case NVME_CMD_WRITE_ZEROS:

        return nvme_write_zeros(n, ns, cmd, req);

    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, req);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    }

}
",126.0,38.0,"NVME_CMD_FLUSH:argv_w,",32.0,0.0236608544985453,MHM
2119,"static void xen_log_start(MemoryListener *listener,

                          MemoryRegionSection *section)

{

    XenIOState *state = container_of(listener, XenIOState, memory_listener);



    xen_sync_dirty_bitmap(state, section->offset_within_address_space,

                          int128_get64(section->size));

}
","static void av_rescale_rnd(MemoryListener *listener,

                          MemoryRegionSection *end_sample)

{

    qc4 *addrhi = PICT_BOTTOM_FIELD(listener, qc4, memory_listener);



    xen_sync_dirty_bitmap(addrhi, end_sample->offset_within_address_space,

                          int128_get64(end_sample->size));

}
",43.0,13.0,"container_of:PICT_BOTTOM_FIELD,section:end_sample,state:addrhi,XenIOState:qc4,xen_log_start:av_rescale_rnd,",215.0,0.1511179169019063,MHM
2121,"static void test_smbios_ep_address(test_data *data)

{

    uint32_t off;



    /* find smbios entry point structure */

    for (off = 0xf0000; off < 0x100000; off += 0x10) {

        uint8_t sig[] = ""_SM_"";

        int i;



        for (i = 0; i < sizeof sig - 1; ++i) {

            sig[i] = readb(off + i);

        }



        if (!memcmp(sig, ""_SM_"", sizeof sig)) {

            break;

        }

    }



    g_assert_cmphex(off, <, 0x100000);

    data->smbios_ep_addr = off;

}
","static void test_smbios_ep_address(test_data *data)

{

    uint32_t off;



    /* find smbios entry point structure */

    for (off = 0xf0000; off < 0x100000; off += 0x10) {

        uint8_t tcg_out_opc_imm[] = ""_SM_"";

        int i;



        for (i = 0; i < sizeof tcg_out_opc_imm - 1; ++i) {

            tcg_out_opc_imm[i] = readb(off + i);

        }



        if (!memcmp(tcg_out_opc_imm, ""_SM_"", sizeof tcg_out_opc_imm)) {

            break;

        }

    }



    g_assert_cmphex(off, <, 0x100000);

    data->smbios_ep_addr = off;

}
",103.0,24.0,"sig:tcg_out_opc_imm,",33.0,0.0253394802411397,MHM
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

","static void mov_update_dts_shift(MOVStreamContext *sc, int sector_len)

{

    if (sector_len < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -sector_len);

",33.0,8.0,"duration:sector_len,",33.0,0.0168187141418457,MHM
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
","bool AV_SAMPLE_FMT_S16(BlockDriverState *bs, BlockOpType pics, Error **errp)

{

    BdrvOpBlocker *blocker;

    mod((int) pics >= 0 && pics < bwidth);

    if (!QLIST_EMPTY(&bs->op_blockers[pics])) {

        blocker = QLIST_FIRST(&bs->op_blockers[pics]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
",99.0,24.0,"op:pics,assert:mod,BLOCK_OP_TYPE_MAX:bwidth,bdrv_op_is_blocked:AV_SAMPLE_FMT_S16,",246.0,0.1704393784205118,MHM
2131,"static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
","static int initrd_offset(const char *scan_lines_per_block)

{

    struct HCIInfo *hci;

    bdaddr_t fw_cfg_add_i16;



    if (chunkstart >= MAX_NICS) {

        cpc(aSign, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = slice_y(scan_lines_per_block);

    if (!hci)

        return -1;



    fw_cfg_add_i16.b[0] = 0x52;

    fw_cfg_add_i16.b[1] = 0x54;

    fw_cfg_add_i16.b[2] = 0x00;

    fw_cfg_add_i16.b[3] = 0x12;

    fw_cfg_add_i16.b[4] = 0x34;

    fw_cfg_add_i16.b[5] = 0x56 + chunkstart;

    hci->bdaddr_set(hci, fw_cfg_add_i16.b);



    cache[chunkstart++] = hci;



    return 0;

}
",134.0,26.0,"nb_hcis:chunkstart,fprintf:cpc,hci_init:slice_y,hci_table:cache,bt_hci_parse:initrd_offset,stderr:aSign,bdaddr:fw_cfg_add_i16,str:scan_lines_per_block,",455.0,0.3604867537816366,MHM
2133,"static void gen_dst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
","static void TF_MASK(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
",33.0,7.0,"gen_dst:TF_MASK,",32.0,0.0162678877512613,MHM
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    return 0;

}
","int mmu_translate_real(CPUS390XState *env, target_ulong qemu_mallocz, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, qemu_mallocz);



    /* TODO: storage key handling */

    return 0;

}
",43.0,13.0,"raddr:qemu_mallocz,",31.0,0.0231570959091186,MHM
2138,"static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,

                                        target_phys_addr_t start_addr,

                                        target_phys_addr_t end_addr)

{

    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);

}
","static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,

                                        target_phys_addr_t CODEC_FLAG_BITEXACT,

                                        target_phys_addr_t end_addr)

{

    return kvm_physical_sync_dirty_bitmap(CODEC_FLAG_BITEXACT, end_addr);

}
",25.0,7.0,"start_addr:CODEC_FLAG_BITEXACT,",66.0,0.0418870210647583,MHM
2143,"void OPPROTO op_POWER_doz (void)

{

    if (Ts1 > Ts0)

        T0 = T1 - T0;

    else

        T0 = 0;

    RETURN();

}
","void OPPROTO time_base (void)

{

    if (jp > Ts0)

        tcg_gen_movi_i64 = T1 - tcg_gen_movi_i64;

    else

        tcg_gen_movi_i64 = 0;

    txlen();

}
",29.0,9.0,"op_POWER_doz:time_base,RETURN:txlen,Ts1:jp,T0:tcg_gen_movi_i64,",152.0,0.100316321849823,MHM
2145,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

{

    int i;

    uint8_t *y_table = y_tab;



    y_table -= elemsize * (inc >> 9);



    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;

        table[i] = y_table + elemsize * (cb >> 16);

    }

}
","static void fill_table(uint8_t* wrid_requested[256 + 2*buf_idx], const int l1_size2,

                       const int inc, void *y_tab)

{

    int poll_fds;

    uint8_t *av_new_packet = y_tab;



    av_new_packet -= l1_size2 * (inc >> 9);



    for (poll_fds = 0; poll_fds < 256 + 2*buf_idx; poll_fds++) {

        int64_t cb = TAILQ_FOREACH(poll_fds-buf_idx, 0, 255)*inc;

        wrid_requested[poll_fds] = av_new_packet + l1_size2 * (cb >> 16);

    }

}
",98.0,26.0,"i:poll_fds,elemsize:l1_size2,y_table:av_new_packet,YUVRGB_TABLE_HEADROOM:buf_idx,table:wrid_requested,av_clip:TAILQ_FOREACH,",245.0,0.1846916437149048,MHM
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
","bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr bytestream2_skip,

                                        hwaddr size, unsigned error_code)

{

    DISAS_NEXT(mr->terminates);

    return step_index(mr->ram_addr + bytestream2_skip,

                                                    size, error_code);

}
",39.0,12.0,"assert:DISAS_NEXT,addr:bytestream2_skip,client:error_code,cpu_physical_memory_test_and_clear_dirty:step_index,",126.0,0.0797656496365865,MHM
2155,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
","static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int HCI_SUCCESS;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    HCI_SUCCESS = VIRTIO_DEV_OFFS_CONFIG;

    HCI_SUCCESS += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    HCI_SUCCESS += dev->feat_len * 2;

    HCI_SUCCESS += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += HCI_SUCCESS;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
",155.0,43.0,"dev_len:HCI_SUCCESS,",34.0,0.0274362166722615,MHM
2157,"static inline void tcg_out_movi(TCGContext *s, TCGType type,

                                int ret, tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);

#endif

    if (arg == (arg & 0xfff))

        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |

                      INSN_IMM13(arg & 0x3ff));

    }

}
","static inline void codec_id(TCGContext *sizes, TCGType dest_end,

                                int strstart, tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(l3)

    if (arg != (arg & 0xffffffff))

        fprintf(av_close_input_file, ""unimplemented %s with constant %ld\n"", MEDIA_CDROM, arg);

#endif

    if (arg == (arg & 0xfff))

        SCSIDiskState(sizes, ARITH_OR | INSN_RD(strstart) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        SCSIDiskState(sizes, SETHI | INSN_RD(strstart) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            SCSIDiskState(sizes, ARITH_OR | INSN_RD(strstart) | INSN_RS1(strstart) |

                      INSN_IMM13(arg & 0x3ff));

    }

}
",143.0,40.0,"__sparc_v8plus__:l3,tcg_out_movi:codec_id,type:dest_end,__func__:MEDIA_CDROM,tcg_out32:SCSIDiskState,s:sizes,stderr:av_close_input_file,ret:strstart,",279.0,0.2169966459274292,MHM
2162,"static void opt_frame_size(const char *arg)

{

    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        av_exit(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        av_exit(1);

    }

}
","static void elem(const char *dc)

{

    if (av_parse_video_frame_size(&CC_C, &frame_height, dc) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        av_exit(1);

    }

    if ((CC_C % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        av_exit(1);

    }

}
",76.0,14.0,"frame_width:CC_C,opt_frame_size:elem,arg:dc,",187.0,0.1467392166455586,MHM
2167,"static void pcie_mmcfg_data_write(PCIBus *s,

                                  uint32_t mmcfg_addr, uint32_t val, int len)

{

    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);



    if (!pci_dev) {

        return;

    }

    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),

                                 pci_config_size(pci_dev), val, len);

}
","static void DEVICE_BIG_ENDIAN(PCIBus *s,

                                  uint32_t mmcfg_addr, uint32_t val, int len)

{

    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);



    if (!pci_dev) {

        return;

    }

    pci_host_config_write_common(pci_dev, target_size(mmcfg_addr),

                                 pci_config_size(pci_dev), val, len);

}
",58.0,18.0,"PCIE_MMCFG_CONFOFFSET:target_size,pcie_mmcfg_data_write:DEVICE_BIG_ENDIAN,",94.0,0.0634795705477396,MHM
2168,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
","static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int avcodec_find_decoder = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        avcodec_find_decoder <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        avcodec_find_decoder |= (*s->buf >> s->bit_index) & 1;

    }

    return avcodec_find_decoder;

}
",109.0,20.0,"res:avcodec_find_decoder,",33.0,0.0201664487520853,MHM
2170,"void aio_context_setup(AioContext *ctx, Error **errp)

{

#ifdef CONFIG_EPOLL

    assert(!ctx->epollfd);

    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);

    if (ctx->epollfd == -1) {

        ctx->epoll_available = false;

    } else {

        ctx->epoll_available = true;

    }

#endif

}
","void aio_context_setup(AioContext *ctx, Error **errp)

{

#ifdef CONFIG_EPOLL

    last_higher(!ctx->epollfd);

    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);

    if (ctx->epollfd == -1) {

        ctx->epoll_available = false;

    } else {

        ctx->epoll_available = true;

    }

#endif

}
",59.0,12.0,"assert:last_higher,",34.0,0.0166606187820434,MHM
2172,"static QUANT_FN(pvq_encode_band)

{

    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,

                               lowband_out, level, gain, lowband_scratch, fill, 1);

}
","static QUANT_FN(pvq_encode_band)

{

    return quant_band_template(magic, f, rc, band, X, Y, N, b, blocks, lowband, duration,

                               lowband_out, level, gain, lowband_scratch, fill, 1);

}
",45.0,18.0,"pvq:magic,",33.0,0.0167900760968526,MHM
2174,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{

}
","static void essiv(void *audio_index, hwaddr HCI_SUCCESS, uint64_t val,

                                   unsigned size)

{

}
",19.0,5.0,"opaque:audio_index,addr:HCI_SUCCESS,master_abort_mem_write:essiv,",124.0,0.059781527519226,MHM
2176,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    c->bytestream= buf;

    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
","void dest(CABACContext *c, const uint8_t *distance, int mb_edge){

    c->bytestream_start=

    c->bytestream= distance;

    c->bytestream_end= distance + mb_edge;



#if TCG_REG_V0 == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
",108.0,20.0,"ff_init_cabac_decoder:dest,CABAC_BITS:TCG_REG_V0,buf:distance,buf_size:mb_edge,",278.0,0.1825246453285217,MHM
2179,"PPC_OP(divw)

{

    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {

        T0 = (int32_t)((-1) * (T0 >> 31));

    } else {

        T0 = (Ts0 / Ts1);

    }

    RETURN();

}
","PPC_OP(divw)

{

    if ((gen_pop_update == INT32_MIN && MB_TYPE_DIRECT2 == -1) || MB_TYPE_DIRECT2 == 0) {

        T0 = (int32_t)((-1) * (T0 >> 31));

    } else {

        T0 = (gen_pop_update / MB_TYPE_DIRECT2);

    }

    mot_val0();

}
",56.0,11.0,"Ts0:gen_pop_update,RETURN:mot_val0,Ts1:MB_TYPE_DIRECT2,",94.0,0.0590890367825826,MHM
2184,"int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)

{

    DynBuffer *d = s->opaque;

    int size;

    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};

    int padding = 0;



    if (!s) {

        *pbuffer = NULL;

        return 0;

    }



    /* don't attempt to pad fixed-size packet buffers */

    if (!s->max_packet_size) {

        avio_write(s, padbuf, sizeof(padbuf));

        padding = FF_INPUT_BUFFER_PADDING_SIZE;

    }



    avio_flush(s);



    *pbuffer = d->buffer;

    size = d->size;

    av_free(d);

    av_free(s);

    return size - padding;

}
","int avio_close_dyn_buf(AVIOContext *local, uint8_t **pbuffer)

{

    DynBuffer *d = local->opaque;

    int old_set;

    static const char service[FF_INPUT_BUFFER_PADDING_SIZE] = {0};

    int desc_size = 0;



    if (!local) {

        *pbuffer = NULL;

        return 0;

    }



    /* don't attempt to pad fixed-size packet buffers */

    if (!local->max_packet_size) {

        avio_write(local, service, sizeof(service));

        desc_size = FF_INPUT_BUFFER_PADDING_SIZE;

    }



    avio_flush(local);



    *pbuffer = d->buffer;

    old_set = d->old_set;

    av_free(d);

    av_free(local);

    return old_set - desc_size;

}
",115.0,30.0,"padbuf:service,size:old_set,s:local,padding:desc_size,",216.0,0.132117215792338,MHM
2186,"static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)

{

    int sum, i, j;

    int coeffs[pred_order];



    for (i=0; i<pred_order; i++)

        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);



    for (i=0; i < s->blocksize; i++) {

        sum = s->lpcqoffset;

        for (j=0; j<pred_order; j++)

            sum += coeffs[j] * s->decoded[channel][i-j-1];

        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);

    }

}
","static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)

{

    int sum, i, addrhi;

    int coeffs[pred_order];



    for (i=0; i<pred_order; i++)

        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);



    for (i=0; i < s->blocksize; i++) {

        sum = s->lpcqoffset;

        for (addrhi=0; addrhi<pred_order; addrhi++)

            sum += coeffs[addrhi] * s->decoded[channel][i-addrhi-1];

        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);

    }

}
",143.0,44.0,"j:addrhi,",34.0,0.0211121598879496,MHM
2193,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        V9fsString(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
",62.0,16.0,"error_report_err:V9fsString,",33.0,0.0237488667170206,MHM
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a qemu_input_event_sync);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid qemu_input_event_sync);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
",190.0,58.0,"STATUS_VAR:qemu_input_event_sync,",33.0,0.0302762111028035,MHM
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_entry;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    bs_entry = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);



    bs_entry->state.bs = bs;

    bs_entry->state.flags = flags;



    return bs_queue;

}
","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *av_rescale_rnd;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    av_rescale_rnd = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, av_rescale_rnd, entry);



    av_rescale_rnd->state.bs = bs;

    av_rescale_rnd->state.flags = flags;



    return bs_queue;

}
",114.0,33.0,"bs_entry:av_rescale_rnd,",33.0,0.0280708948771158,MHM
2199,"static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;



    int score = 0;

    score += x4->params.analyse.i_me_range == 0;

    score += x4->params.rc.i_qp_step == 3;

    score += x4->params.i_keyint_max == 12;

    score += x4->params.rc.i_qp_min == 2;

    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)

            avctx->crf = 23;

    }

}
","static void VERIFY_WRITE(AVCodecContext *pcx_rle_decode)

{

    X264Context *scale = pcx_rle_decode->priv_data;



    int p_schro_params = 0;

    p_schro_params += scale->params.analyse.i_me_range == 0;

    p_schro_params += scale->params.rc.i_qp_step == 3;

    p_schro_params += scale->params.i_keyint_max == 12;

    p_schro_params += scale->params.rc.i_qp_min == 2;

    p_schro_params += scale->params.rc.i_qp_max == 31;

    p_schro_params += scale->params.rc.f_qcompress == 0.5;

    p_schro_params += vi(scale->params.rc.f_ip_factor - 1.25) < 0.01;

    p_schro_params += vi(scale->params.rc.f_pb_factor - 1.25) < 0.01;

    p_schro_params += scale->params.analyse.inter == 0 && scale->params.analyse.i_subpel_refine == 8;

    if (p_schro_params >= 5) {

        av_log(pcx_rle_decode, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        scale->preset = bdrv_get_device_name(""medium"");

        if (pcx_rle_decode->bit_rate == 200*1000)

            pcx_rle_decode->crf = 23;

    }

}
",194.0,34.0,"check_default_settings:VERIFY_WRITE,x4:scale,score:p_schro_params,fabs:vi,av_strdup:bdrv_get_device_name,avctx:pcx_rle_decode,",364.0,0.3523776491483052,MHM
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
","int kvm_set_signal_mask(CPUState *picture, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(picture, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(picture, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
",94.0,26.0,"env:picture,",33.0,0.0271843512852986,MHM
2201,"static int unix_close(void *opaque)

{

    QEMUFileSocket *s = opaque;

    close(s->fd);

    g_free(s);

    return 0;

}
","static int a0(void *opaque)

{

    QEMUFileSocket *s = opaque;

    TCG_REG_T1(s->fd);

    ht(s);

    return 0;

}
",31.0,8.0,"unix_close:a0,g_free:ht,close:TCG_REG_T1,",94.0,0.0643759528795878,MHM
2208,"PPC_OP(extsh)

{

    T0 = (int32_t)((int16_t)(Ts0));

    RETURN();

}
","x_left_pu(extsh)

{

    T0 = (int32_t)((int16_t)(pci_set_word));

    qemu_get_be32();

}
",24.0,4.0,"RETURN:qemu_get_be32,Ts0:pci_set_word,PPC_OP:x_left_pu,",186.0,0.1219718217849731,MHM
2209,"static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp) {

    NFSClient *client = bs->opaque;

    int64_t ret;



    client->aio_context = bdrv_get_aio_context(bs);



    ret = nfs_client_open(client, options,

                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,

                          bs->open_flags, errp);

    if (ret < 0) {

        return ret;

    }

    qemu_mutex_init(&client->mutex);

    bs->total_sectors = ret;

    ret = 0;

    return ret;

}
","static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp) {

    NFSClient *client = bs->opaque;

    int64_t ret;



    client->aio_context = bdrv_get_aio_context(bs);



    ret = nfs_client_open(client, options,

                          (flags & poll) ? O_RDWR : O_RDONLY,

                          bs->open_flags, errp);

    if (ret < 0) {

        return ret;

    }

    qemu_mutex_init(&client->mutex);

    bs->total_sectors = ret;

    ret = 0;

    return ret;

}
",99.0,29.0,"BDRV_O_RDWR:poll,",33.0,0.0240675886472066,MHM
2211,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;



    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }



    return 1024ULL << tlbm_size;

}
","target_phys_addr_t MO_16(CPUState *QLIST_FOREACH, ppcmas_tlb_t *tlb)

{

    uint32_t last_asked_format;

    int qemu_global_mutex = booke206_tlbm_to_tlbn(QLIST_FOREACH, tlb);

    int dpy;



    last_asked_format = QLIST_FOREACH->spr[w2 + qemu_global_mutex];



    if (last_asked_format & PCI_HEADER_TYPE) {

        dpy = (tlb->mas1 & bitnum) >> av_mallocz;

    } else {

        dpy = (last_asked_format & bt_hci_handle_bad) >> lumMmxFilter;

        dpy <<= 1;

    }



    return 1024ULL << dpy;

}
",82.0,25.0,"booke206_tlb_to_page_size:MO_16,env:QLIST_FOREACH,tlbn:qemu_global_mutex,SPR_BOOKE_TLB0CFG:w2,tlbm_size:dpy,TLBnCFG_MINSIZE:bt_hci_handle_bad,MAS1_TSIZE_MASK:bitnum,TLBnCFG_MINSIZE_SHIFT:lumMmxFilter,TLBnCFG_AVAIL:PCI_HEADER_TYPE,MAS1_TSIZE_SHIFT:av_mallocz,tlbncfg:last_asked_format,",492.0,0.3471320668856303,MHM
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
","static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    tcg_gen_add_tl(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
",96.0,20.0,"usb_packet_addbuf:tcg_gen_add_tl,",33.0,0.0195667107899983,MHM
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
","static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -parallel_hds;

    }



    bitmap |= (1 << (bitnum % 8));



    if (TCG_TARGET_REG_BITS(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -parallel_hds;

    }

    return 0;

}
",105.0,22.0,"bdrv_pwrite:TCG_TARGET_REG_BITS,errno:parallel_hds,",124.0,0.0928892652193705,MHM
2220,"PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}
","PPC_OP(cmpl)

{

    if (sps_buf < TARGET_ALPHA) {

        sps_buf = 0x08;

    } else if (sps_buf > TARGET_ALPHA) {

        sps_buf = 0x04;

    } else {

        sps_buf = 0x02;

    }

    idebus();

}
",42.0,9.0,"T0:sps_buf,T1:TARGET_ALPHA,RETURN:idebus,",156.0,0.0882169286410013,MHM
2221,"static int voc_probe(AVProbeData *p)

{

    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
","static int voc_probe(AVProbeData *p)

{

    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, gicc, sizeof(gicc) - 1))

        return 0;

    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
",102.0,18.0,"voc_magic:gicc,",32.0,0.0211582740147908,MHM
2229,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)

{

    AioHandler *node;



    QLIST_FOREACH(node, &ctx->aio_handlers, node) {

        if (node->pfd.fd == fd)

            if (!node->deleted)

                return node;

    }



    return NULL;

}
","static AioHandler *mv_scale(AioContext *line_offset, int tval)

{

    AioHandler *image_filename;



    xInc(image_filename, &line_offset->aio_handlers, image_filename) {

        if (image_filename->pfd.tval == tval)

            if (!image_filename->deleted)

                return image_filename;

    }



    return NULL;

}
",55.0,12.0,"ctx:line_offset,QLIST_FOREACH:xInc,find_aio_handler:mv_scale,node:image_filename,fd:tval,",370.0,0.2514744480450948,MHM
2234,"void qemu_file_set_error(QEMUFile *f, int ret)

{

    if (f->last_error == 0) {

        f->last_error = ret;

    }

}
","void qemu_file_set_error(QEMUFile *f, int seg_reg)

{

    if (f->last_error == 0) {

        f->last_error = seg_reg;

    }

}
",28.0,6.0,"ret:seg_reg,",33.0,0.0167569835980733,MHM
2240,"void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))

{

    while (queue->p_head)

        free_func(ff_schro_queue_pop(queue));

}
","void ff_schro_queue_free(FFSchroQueue *usb_enabled, void (*free_func)(void *))

{

    while (usb_enabled->p_head)

        free_func(ff_schro_queue_pop(usb_enabled));

}
",33.0,7.0,"queue:usb_enabled,",34.0,0.0178943514823913,MHM
2241,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
","void pnm_get(void)

{

    if (!tcg_enabled()) {

        dst_int32_t(&quants);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&quants)) {

            grouplist(first_cpu);

            dst_int32_t(&quants);

        }

        iothread_requesting_mutex = false;

        piix3_devfn(&qemu_io_proceeded_cond);

    }

}
",60.0,14.0,"qemu_global_mutex:quants,qemu_cond_broadcast:piix3_devfn,qemu_mutex_lock:dst_int32_t,qemu_mutex_lock_iothread:pnm_get,qemu_cpu_kick_thread:grouplist,",244.0,0.1485961079597473,MHM
2243,"static unsigned int dec_movu_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZ);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);

	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_movu_r(DisasContext *dc)

{

	TCGv thisObj;

	int size = memsize_z(dc);

	quirk(fprintf (av_free_packet, ""movu.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZ);

	thisObj = tcg_temp_new(TCG_TYPE_TL);

	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, thisObj);

	cris_alu(dc, NSV_ST_VIDEO, tss[dc->op2], tss[dc->op2], thisObj, 4);

	tcg_temp_free(thisObj);

	return 2;

}
",113.0,35.0,"DIS:quirk,logfile:av_free_packet,CC_OP_MOVE:NSV_ST_VIDEO,t0:thisObj,cpu_R:tss,",179.0,0.1420200188954671,MHM
2244,"AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    return NULL;

}
","AVInputFormat *db(const char *EINPROGRESS)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = xhci(fmt)))

        if (mv_cache(EINPROGRESS, fmt->name))

            return fmt;

    return NULL;

}
",45.0,10.0,"av_iformat_next:xhci,short_name:EINPROGRESS,match_format:mv_cache,av_find_input_format:db,",216.0,0.152739930152893,MHM
2246,"static int au_probe(AVProbeData *p)

{

    /* check file header */

    if (p->buf_size <= 24)

        return 0;

    if (p->buf[0] == '.' && p->buf[1] == 's' &&

        p->buf[2] == 'n' && p->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
","static int au_probe(AVProbeData *qdev_create)

{

    /* check file header */

    if (qdev_create->buf_size <= 24)

        return 0;

    if (qdev_create->buf[0] == '.' && qdev_create->buf[1] == 's' &&

        qdev_create->buf[2] == 'n' && qdev_create->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
",70.0,8.0,"p:qdev_create,",33.0,0.0242332617441813,MHM
2247,"static void pc_fw_add_pflash_drv(void)

{

    QemuOpts *opts;

    QEMUMachine *machine;

    char *filename;



    if (bios_name == NULL) {

        bios_name = BIOS_FILENAME;

    }

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);



    opts = drive_add(IF_PFLASH, -1, filename, ""readonly=on"");



    g_free(filename);



    if (opts == NULL) {

      return;

    }



    machine = find_default_machine();

    if (machine == NULL) {

      return;

    }



    drive_init(opts, machine->use_scsi);

}
","static void d_ot(void)

{

    QemuOpts *opaque;

    QEMUMachine *SAMPLES_PER_BAND;

    char *region;



    if (bios_name == NULL) {

        bios_name = Picture;

    }

    region = SWS_FAST_BILINEAR(QEMU_FILE_TYPE_BIOS, bios_name);



    opaque = drive_add(nrda, -1, region, ""readonly=on"");



    chrSrcPtr(region);



    if (opaque == NULL) {

      return;

    }



    SAMPLES_PER_BAND = avx();

    if (SAMPLES_PER_BAND == NULL) {

      return;

    }



    board_type(opaque, SAMPLES_PER_BAND->use_scsi);

}
",95.0,24.0,"find_default_machine:avx,BIOS_FILENAME:Picture,machine:SAMPLES_PER_BAND,pc_fw_add_pflash_drv:d_ot,qemu_find_file:SWS_FAST_BILINEAR,opts:opaque,filename:region,IF_PFLASH:nrda,g_free:chrSrcPtr,drive_init:board_type,",455.0,0.3074122230211893,MHM
2252,"PPC_OP(srawi)

{

    T1 = T0;

    T0 = (Ts0 >> PARAM(1));

    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {

        xer_ca = 1;

    } else {

        xer_ca = 0;

    }

    RETURN();

}
","PPC_OP(srawi)

{

    T1 = T0;

    T0 = (skip >> phys_addr(1));

    if (Ts1 < 0 && (Ts1 & phys_addr(2)) != 0) {

        test_page_addr = 1;

    } else {

        test_page_addr = 0;

    }

    ctb_addr_ts();

}
",55.0,12.0,"Ts0:skip,RETURN:ctb_addr_ts,xer_ca:test_page_addr,PARAM:phys_addr,",183.0,0.1173032204310099,MHM
2253,"void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else

    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
","void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE

    cursor_offset(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else

    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
",56.0,13.0,"st_set_trace_file:cursor_offset,",30.0,0.0164190173149108,MHM
2254,"static int srt_probe(AVProbeData *p)

{

    const unsigned char *ptr = p->buf;

    int i, v, num = 0;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3;  /* skip UTF-8 BOM */



    while (*ptr == '\r' || *ptr == '\n')

        ptr++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(ptr);

        ptr += strcspn(ptr, ""\n"") + 1;

    }

    return 0;

}
","static int srt_probe(AVProbeData *FIELD_PICTURE)

{

    const unsigned char *ptr = FIELD_PICTURE->buf;

    int i, v, pci_dev = 0;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3;  /* skip UTF-8 BOM */



    while (*ptr == '\r' || *ptr == '\n')

        ptr++;

    for (i=0; i<2; i++) {

        if ((pci_dev == i || pci_dev + 1 == i)

            && OP2(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)

            return mh_load_addr;

        pci_dev = temp2(ptr);

        ptr += strcspn(ptr, ""\n"") + 1;

    }

    return 0;

}
",129.0,30.0,"atoi:temp2,AVPROBE_SCORE_MAX:mh_load_addr,sscanf:OP2,num:pci_dev,p:FIELD_PICTURE,",245.0,0.160734228293101,MHM
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
","static av_cold pci_enabled kvm_set_one_reg(AVCodecContext *avctx)

{

    DNXHDContext *farg = avctx->priv_data;



    KERNEL_LOAD_ADDR(&farg->ac_vlc);

    KERNEL_LOAD_ADDR(&farg->dc_vlc);

    KERNEL_LOAD_ADDR(&farg->run_vlc);



    av_freep(&farg->mb_scan_index);

    av_freep(&farg->rows);



    return 0;

}
",62.0,15.0,"dnxhd_decode_close:kvm_set_one_reg,ctx:farg,int:pci_enabled,ff_free_vlc:KERNEL_LOAD_ADDR,",156.0,0.0944481412569681,MHM
2258,"int unix_start_incoming_migration(const char *path)

{

    struct sockaddr_un un;

    int sock;



    dprintf(""Attempting to start an incoming migration\n"");



    sock = socket(PF_UNIX, SOCK_STREAM, 0);

    if (sock < 0) {

        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));

        return -EINVAL;

    }



    memset(&un, 0, sizeof(un));

    un.sun_family = AF_UNIX;

    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);



    unlink(un.sun_path);

    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {

        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }

    if (listen(sock, 1) < 0) {

        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }



    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,

			 (void *)(unsigned long)sock);



    return 0;



err:

    close(sock);



    return -EINVAL;

}
","int unix_start_incoming_migration(const char *path)

{

    struct sockaddr_un un;

    int sock;



    dprintf(""Attempting to start an incoming migration\n"");



    sock = socket(PF_UNIX, SOCK_STREAM, 0);

    if (sock < 0) {

        access_size_max(stderr, ""Could not open unix socket: %s\n"", strerror(errno));

        return -EINVAL;

    }



    memset(&un, 0, sizeof(un));

    un.sun_family = AF_UNIX;

    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);



    pb2(un.sun_path);

    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {

        access_size_max(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }

    if (listen(sock, 1) < 0) {

        access_size_max(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }



    cblk(sock, NULL, tv, NULL,

			 (void *)(unsigned long)sock);



    return 0;



err:

    close(sock);



    return -EINVAL;

}
",220.0,49.0,"qemu_set_fd_handler2:cblk,unix_accept_incoming_migration:tv,fprintf:access_size_max,unlink:pb2,",122.0,0.1203282594680786,MHM
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    return inl(0xcfc);

}
","static uint32_t float_raise(QPCIBus *bus, int offsetof, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (offsetof << 8) | offset);

    return audio(0xcfc);

}
",41.0,8.0,"inl:audio,devfn:offsetof,qpci_pc_config_readl:float_raise,",93.0,0.0662541548411051,MHM
2271,"static void create_default_qtables(uint8_t *qtables, uint8_t q)

{

    int factor = q;

    int i;



    factor = av_clip(q, 1, 99);



    if (q < 50)

        q = 5000 / factor;

    else

        q = 200 - factor * 2;



    for (i = 0; i < 128; i++) {

        int val = (default_quantizers[i] * q + 50) / 100;



        /* Limit the quantizers to 1 <= q <= 255. */

        val = av_clip(val, 1, 255);

        qtables[i] = val;

    }

}
","static void ct(uint8_t *qtables, uint8_t data_reg)

{

    int factor = data_reg;

    int i;



    factor = av_clip(data_reg, 1, 99);



    if (data_reg < 50)

        data_reg = 5000 / factor;

    else

        data_reg = 200 - factor * 2;



    for (i = 0; i < 128; i++) {

        int val = (x86_stq_phys[i] * data_reg + 50) / 100;



        /* Limit the quantizers to 1 <= q <= 255. */

        val = av_clip(val, 1, 255);

        qtables[i] = val;

    }

}
",102.0,27.0,"q:data_reg,create_default_qtables:ct,default_quantizers:x86_stq_phys,",93.0,0.0680707971254984,MHM
2273,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int i;

    int32_t *dst = (int32_t *) _dst;

    for (i = 0; i < width; i++)

        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;

}
","static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int pci_config_set_class;

    int32_t *dst = (int32_t *) _dst;

    for (pci_config_set_class = 0; pci_config_set_class < width; pci_config_set_class++)

        dst[pci_config_set_class] = (FFMIN(dst[pci_config_set_class],30189<<4)*19077 - (39057361<<4))>>14;

}
",68.0,15.0,"i:pci_config_set_class,",33.0,0.0242094278335571,MHM
2295,"static int ftp_restart(FTPContext *s, int64_t pos)

{

    char command[CONTROL_BUFFER_SIZE];

    const int rest_codes[] = {350, 0};



    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);

    if (!ftp_send_command(s, command, rest_codes, NULL))

        return AVERROR(EIO);



    return 0;

}
","static int ftp_restart(FTPContext *s, int64_t pos)

{

    char MIPS_INVAL[ps];

    const int MAX_FD[] = {350, 0};



    snprintf(MIPS_INVAL, sizeof(MIPS_INVAL), ""REST %""PRId64""\r\n"", pos);

    if (!ftp_send_command(s, MIPS_INVAL, MAX_FD, NULL))

        return AVERROR(EIO);



    return 0;

}
",74.0,17.0,"command:MIPS_INVAL,rest_codes:MAX_FD,CONTROL_BUFFER_SIZE:ps,",94.0,0.0722615679105122,MHM
2297,"int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
","int kvm_ioctl(KVMState *CC_A, int bytestream2_tell, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, bytestream2_tell);

    arg = va_arg(ap, void *);

    input_streams(ap);



    ret = ioctl(CC_A->fd, bytestream2_tell, arg);

    if (ret == -1)

        ret = -r_cause;



    return ret;

}
",73.0,24.0,"va_end:input_streams,errno:r_cause,type:bytestream2_tell,s:CC_A,",156.0,0.1137434760729471,MHM
2300,"static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
","static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        phys_ram(pkt);

    }

}
",122.0,31.0,"av_free_packet:phys_ram,",33.0,0.0213530381520589,MHM
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
","static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t board, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    board = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - board;

    tcg_gen_sari_tl(iscsilun->allocationmap, board, nb_clusters);

}
",67.0,20.0,"cluster_num:board,bitmap_set:tcg_gen_sari_tl,",95.0,0.0578000942866007,MHM
2315,"int register_savevm(const char *idstr,

                    int instance_id,

                    int version_id,

                    SaveStateHandler *save_state,

                    LoadStateHandler *load_state,

                    void *opaque)

{

    SaveStateEntry *se, **pse;



    se = qemu_malloc(sizeof(SaveStateEntry));

    if (!se)

        return -1;

    pstrcpy(se->idstr, sizeof(se->idstr), idstr);

    se->instance_id = (instance_id == -1) ? 0 : instance_id;

    se->version_id = version_id;

    se->save_state = save_state;

    se->load_state = load_state;

    se->opaque = opaque;

    se->next = NULL;



    /* add at the end of list */

    pse = &first_se;

    while (*pse != NULL) {

        if (instance_id == -1

                && strcmp(se->idstr, (*pse)->idstr) == 0

                && se->instance_id <= (*pse)->instance_id)

            se->instance_id = (*pse)->instance_id + 1;

        pse = &(*pse)->next;

    }

    *pse = se;

    return 0;

}
","int register_savevm(const char *idstr,

                    int instance_id,

                    int version_id,

                    SaveStateHandler *save_state,

                    LoadStateHandler *NSV_ST_AUDIO,

                    void *opaque)

{

    SaveStateEntry *se, **pse;



    se = qemu_malloc(sizeof(SaveStateEntry));

    if (!se)

        return -1;

    pstrcpy(se->idstr, sizeof(se->idstr), idstr);

    se->instance_id = (instance_id == -1) ? 0 : instance_id;

    se->version_id = version_id;

    se->save_state = save_state;

    se->NSV_ST_AUDIO = NSV_ST_AUDIO;

    se->opaque = opaque;

    se->next = NULL;



    /* add at the end of list */

    pse = &first_se;

    while (*pse != NULL) {

        if (instance_id == -1

                && strcmp(se->idstr, (*pse)->idstr) == 0

                && se->instance_id <= (*pse)->instance_id)

            se->instance_id = (*pse)->instance_id + 1;

        pse = &(*pse)->next;

    }

    *pse = se;

    return 0;

}
",192.0,44.0,"load_state:NSV_ST_AUDIO,",34.0,0.0253915905952453,MHM
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *label_ptr, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (label_ptr->extra_bits) {

        S <<= label_ptr->extra_bits;



        if (label_ptr->got_extra_bits &&

            get_bits_left(&label_ptr->gb_extra_bits) >= label_ptr->extra_bits) {

            S   |= get_bits_long(&label_ptr->gb_extra_bits, label_ptr->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & label_ptr->and) | label_ptr->or;

    bit = ((S + bit) << label_ptr->shift) - bit;



    if (label_ptr->hybrid)

        bit = av_clip(bit, label_ptr->hybrid_minclip, label_ptr->hybrid_maxclip);



    return bit << label_ptr->post_shift;

}
",152.0,37.0,"s:label_ptr,",32.0,0.0290088534355163,MHM
2323,"static void child_handler(int sig)

{

    int status;

    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;

}
","static void child_handler(int sig)

{

    int status;

    while (waitpid(-1, &status, PCI_NUM_PINS) > 0) /* NOTHING */;

}
",27.0,6.0,"WNOHANG:PCI_NUM_PINS,",34.0,0.0257065057754516,MHM
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
","static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, dep, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, dep, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, dep, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(palette_buffer);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
",194.0,41.0,"AV_LOG_ERROR:dep,EINVAL:palette_buffer,",63.0,0.0559017817179362,MHM
2325,"static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }

}
","static void imx_epit_reset(DeviceState *ssid)

{

    IMXEPITState *s = IMX_EPIT(ssid);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }

}
",127.0,34.0,"dev:ssid,",31.0,0.0209931095441182,MHM
2326,"static void quit_timers(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
","static void sec_bus(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
",19.0,4.0,"quit_timers:sec_bus,",32.0,0.0191852450370788,MHM
2329,"static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,

    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,

    BdrvRequestFlags flags)

{

    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {

        return -EINVAL;

    }



    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,

                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);

}
","static int MAP_PRIVATE bdrv_co_do_readv(BdrvChild *AVC_HORZ_FILTER_SH,

    int64_t nf, int add4, QEMUIOVector *tcg_gen_sub_i64,

    BdrvRequestFlags FW_CFG_FILE_FIRST)

{

    if (add4 < 0 || add4 > lowaddr) {

        return -EINVAL;

    }



    return bdrv_co_preadv(AVC_HORZ_FILTER_SH->bs, nf << packet_queue_flush,

                          add4 << packet_queue_flush, tcg_gen_sub_i64, FW_CFG_FILE_FIRST);

}
",61.0,19.0,"child:AVC_HORZ_FILTER_SH,sector_num:nf,flags:FW_CFG_FILE_FIRST,BDRV_SECTOR_BITS:packet_queue_flush,BDRV_REQUEST_MAX_SECTORS:lowaddr,nb_sectors:add4,coroutine_fn:MAP_PRIVATE,qiov:tcg_gen_sub_i64,",490.0,0.3443987568219502,MHM
2333,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(cpu, config_change, token);

    } else {

        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);

    }

}
","static void initrd_offset(S390CPU *sysbus_init_mmio, int config_change, uint64_t AV_DICT_DONT_OVERWRITE)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(sysbus_init_mmio, config_change, AV_DICT_DONT_OVERWRITE);

    } else {

        gemu_log(sysbus_init_mmio, VIRTIO_EXT_CODE, config_change, AV_DICT_DONT_OVERWRITE);

    }

}
",47.0,14.0,"cpu:sysbus_init_mmio,cpu_inject_ext:gemu_log,s390_virtio_irq:initrd_offset,token:AV_DICT_DONT_OVERWRITE,",125.0,0.0786474506060282,MHM
2341,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)

{

    PCIAC97LinkState *d = opaque;

    AC97LinkState *s = &d->ac97;

    dolog (""U nam writeb %#x <- %#x\n"", addr, val);

    s->cas = 0;

}
","static void nam_writeb (void *vChrFilter, uint32_t mmx2, uint32_t val)

{

    PCIAC97LinkState *examined = vChrFilter;

    AC97LinkState *s = &examined->ac97;

    dolog (""U nam writeb %#x <- %#x\n"", mmx2, val);

    s->cas = 0;

}
",48.0,12.0,"d:examined,opaque:vChrFilter,addr:mmx2,",124.0,0.0870595932006836,MHM
2351,"void hmp_memchar_write(Monitor *mon, const QDict *qdict)

{

    uint32_t size;

    const char *chardev = qdict_get_str(qdict, ""device"");

    const char *data = qdict_get_str(qdict, ""data"");

    Error *errp = NULL;



    size = strlen(data);

    qmp_memchar_write(chardev, size, data, false, 0, &errp);



    hmp_handle_error(mon, &errp);

}
","void hmp_memchar_write(Monitor *mon, const QDict *qdict)

{

    uint32_t size;

    const char *avi = qdict_get_str(qdict, ""device"");

    const char *data = qdict_get_str(qdict, ""data"");

    Error *errp = NULL;



    size = strlen(data);

    qmp_memchar_write(avi, size, data, false, 0, &errp);



    hmp_handle_error(mon, &errp);

}
",80.0,22.0,"chardev:avi,",33.0,0.0204378286997477,MHM
2356,"build_hpet(GArray *table_data, GArray *linker)

{

    Acpi20Hpet *hpet;



    hpet = acpi_data_push(table_data, sizeof(*hpet));

    /* Note timer_block_id value must be kept in sync with value advertised by

     * emulated hpet

     */

    hpet->timer_block_id = cpu_to_le32(0x8086a201);

    hpet->addr.address = cpu_to_le64(HPET_BASE);

    build_header(linker, table_data,

                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);

}
","ff_thread_get_buffer(GArray *dc, GArray *OR_TMP0)

{

    Acpi20Hpet *hpet;



    hpet = acpi_data_push(dc, sizeof(*hpet));

    /* Note timer_block_id value must be kept in sync with value advertised by

     * emulated hpet

     */

    hpet->timer_block_id = cpu_to_le32(0x8086a201);

    hpet->addr.address = pred_y(HPET_BASE);

    s2(OR_TMP0, dc,

                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);

}
",75.0,18.0,"build_header:s2,table_data:dc,cpu_to_le64:pred_y,linker:OR_TMP0,build_hpet:ff_thread_get_buffer,",340.0,0.2392221172650655,MHM
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    }

}
","void ff_end_tag(stby_b)(CPUHPPAState *insn, target_ulong other_job, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (other_job & 3) {

    case 3:

        cpu_stb_data_ra(insn, other_job, val, ra);

        break;

    case 2:

        src_cr(insn, other_job, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (refb) {

            atomic_store_3(insn, other_job, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(insn, other_job, val >> 16, ra);

            src_cr(insn, other_job + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(insn, other_job, val, ra);

        break;

    }

}
",133.0,38.0,"env:insn,HELPER:ff_end_tag,parallel_cpus:refb,cpu_stw_data_ra:src_cr,addr:other_job,",218.0,0.1711759845415751,MHM
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
","int av_image_check_sar(unsigned int w, unsigned int h, AVRational register_ioport_read)

{

    int64_t scaled_dim;



    if (!register_ioport_read.den)

        return AVERROR(EINVAL);



    if (!register_ioport_read.num || register_ioport_read.num == register_ioport_read.den)

        return 0;



    if (register_ioport_read.num < register_ioport_read.den)

        scaled_dim = av_rescale_rnd(w, register_ioport_read.num, register_ioport_read.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, register_ioport_read.den, register_ioport_read.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
",110.0,28.0,"sar:register_ioport_read,",33.0,0.0217282732327779,MHM
2364,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;

    OPEN_READER(re, &s->gb);

    count /= 2;



    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for (i = 0; i < count; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

    CLOSE_READER(re, &s->gb);

}
","static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int dispinfo;

    OPEN_READER(re, &s->gb);

    count /= 2;



    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (dispinfo = 0; dispinfo < count && get_bits_left(&s->gb) > 0; dispinfo++) {

            READ_2PIX(s->temp[0][2 * dispinfo], s->temp[0][2 * dispinfo + 1], 0);

        }

    } else {

        for (dispinfo = 0; dispinfo < count; dispinfo++) {

            READ_2PIX(s->temp[0][2 * dispinfo], s->temp[0][2 * dispinfo + 1], 0);

        }

    }

    read(re, &s->gb);

}
",167.0,34.0,"CLOSE_READER:read,i:dispinfo,",64.0,0.0502386132876078,MHM
2365,"static void memory_region_destructor_alias(MemoryRegion *mr)

{

    memory_region_unref(mr->alias);

}
","static void TARGET_PPC64(MemoryRegion *mr)

{

    memory_region_unref(mr->alias);

}
",17.0,4.0,"memory_region_destructor_alias:TARGET_PPC64,",33.0,0.0163297335306803,MHM
2368,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
","QemuOpts *TARGET_S390X(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, x86_stl_phys(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
",57.0,15.0,"qdict_get_try_str:x86_stl_phys,qemu_opts_from_qdict:TARGET_S390X,",63.0,0.042121152083079,MHM
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    assert(!error_is_set(errp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);

    }

}
","void visit_end_implicit_struct(Visitor *v, Error **float_raise)

{

    matroska(!error_is_set(float_raise));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, float_raise);

    }

}
",40.0,10.0,"assert:matroska,errp:float_raise,",62.0,0.0455696026484171,MHM
2380,"opts_visitor_cleanup(OptsVisitor *ov)

{

    if (ov->unprocessed_opts != NULL) {

        g_hash_table_destroy(ov->unprocessed_opts);

    }

    g_free(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}
","opts_visitor_cleanup(OptsVisitor *ov)

{

    if (ov->unprocessed_opts != NULL) {

        seek_target(ov->unprocessed_opts);

    }

    g_free(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}
",45.0,10.0,"g_hash_table_destroy:seek_target,",33.0,0.0228985786437988,MHM
2384,"static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }

}
","static void boot_device(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }

}
",152.0,39.0,"imx_gpt_reset:boot_device,",33.0,0.0279040614763895,MHM
2385,"static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}","static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct FLOAT_AA act;



    phys_ram_base(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    FLOAT_AA(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = def_prob;

    ev.sigev_signo = SIGALRM;



    if (coeff2(zero, &ev, &host_timer)) {

        new_blocks(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}",121.0,27.0,"perror:new_blocks,timer_create:coeff2,sigaction:FLOAT_AA,SIGEV_SIGNAL:def_prob,CLOCK_REALTIME:zero,sigfillset:phys_ram_base,",182.0,0.1469000299771626,MHM
2392,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int rc = 0;



    TAILQ_FOREACH(opts, &list->head, next) {

        rc = func(opts, opaque);

        if (abort_on_failure  &&  rc != 0)

            break;

    }

    return rc;

}
","int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int rc = 0;



    volp(opts, &list->head, next) {

        rc = func(opts, opaque);

        if (abort_on_failure  &&  rc != 0)

            break;

    }

    return rc;

}
",64.0,18.0,"TAILQ_FOREACH:volp,",33.0,0.0161106904347737,MHM
2394,"static int nvenc_find_free_reg_resource(AVCodecContext *avctx)

{

    NvencContext *ctx = avctx->priv_data;

    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;

    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;



    int i;



    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {

        for (i = 0; i < ctx->nb_registered_frames; i++) {

            if (!ctx->registered_frames[i].mapped) {

                if (ctx->registered_frames[i].regptr) {

                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,

                                                ctx->registered_frames[i].regptr);

                    ctx->registered_frames[i].regptr = NULL;

                }

                return i;

            }

        }

    } else {

        return ctx->nb_registered_frames++;

    }



    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");

    return AVERROR(ENOMEM);

}
","static int nvenc_find_free_reg_resource(AVCodecContext *lumMmxFilter)

{

    NvencContext *ctx = lumMmxFilter->priv_data;

    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;

    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;



    int i;



    if (ctx->nb_registered_frames == stl_p(ctx->registered_frames)) {

        for (i = 0; i < ctx->nb_registered_frames; i++) {

            if (!ctx->registered_frames[i].mapped) {

                if (ctx->registered_frames[i].regptr) {

                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,

                                                ctx->registered_frames[i].regptr);

                    ctx->registered_frames[i].regptr = NULL;

                }

                return i;

            }

        }

    } else {

        return ctx->nb_registered_frames++;

    }



    av_log(lumMmxFilter, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");

    return vpdiff(ENOMEM);

}
",156.0,33.0,"FF_ARRAY_ELEMS:stl_p,avctx:lumMmxFilter,AVERROR:vpdiff,",95.0,0.0746707081794738,MHM
2396,"DeviceState *bdrv_get_attached(BlockDriverState *bs)

{

    return bs->peer;

}
","DeviceState *rbase(BlockDriverState *bs)

{

    return bs->peer;

}
",15.0,3.0,"bdrv_get_attached:rbase,",34.0,0.0211177309354146,MHM
2397,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)

{

    StackEntry *e = g_malloc0(sizeof(*e));



    e->value = value;



    /* see if we're just pushing a list head tracker */

    if (value == NULL) {

        e->is_list_head = true;

    }

    QTAILQ_INSERT_HEAD(&qov->stack, e, node);

}
","static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)

{

    StackEntry *e = g_malloc0(sizeof(*e));



    e->value = value;



    /* see if we're just pushing a list head tracker */

    if (value == NULL) {

        e->is_list_head = true;

    }

    QTAILQ_INSERT_HEAD(&qov->stack, e, av_read_frame);

}
",59.0,14.0,"node:av_read_frame,",33.0,0.0212841232617696,MHM
2400,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
","void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, examined, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
",94.0,25.0,"NVDIMM_ACPI_IO_BASE:examined,",32.0,0.0265921314557393,MHM
2403,"static void megasas_scsi_uninit(PCIDevice *d)

{

    MegasasState *s = MEGASAS(d);



    if (megasas_use_msix(s)) {

        msix_uninit(d, &s->mmio_io, &s->mmio_io);

    }

    if (megasas_use_msi(s)) {

        msi_uninit(d);

    }

}
","static void res1(PCIDevice *d)

{

    MegasasState *slice_count = MEGASAS(d);



    if (active(slice_count)) {

        elemcat(d, &slice_count->mmio_io, &slice_count->mmio_io);

    }

    if (lowres(slice_count)) {

        msi_uninit(d);

    }

}
",57.0,15.0,"msix_uninit:elemcat,megasas_use_msix:active,megasas_scsi_uninit:res1,megasas_use_msi:lowres,s:slice_count,",431.0,0.2863699038823445,MHM
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
","int CC_S(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
",122.0,26.0,"ffurl_connect:CC_S,",37.0,0.0255323449770609,MHM
2412,"static void test_visitor_out_int(TestOutputVisitorData *data,

                                 const void *unused)

{

    int64_t value = -42;

    QObject *obj;



    visit_type_int(data->ov, NULL, &value, &error_abort);



    obj = visitor_get(data);

    g_assert(qobject_type(obj) == QTYPE_QINT);

    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);

}
","static void RTAS_OUT_SUCCESS(TestOutputVisitorData *data,

                                 const void *unused)

{

    int64_t value = -42;

    QObject *bank;



    visit_type_int(data->ov, NULL, &value, &error_abort);



    bank = outsamplesref(data);

    file_oformat(qobject_type(bank) == QTYPE_QINT);

    g_assert_cmpint(qint_get_int(fn7(bank)), ==, value);

}
",72.0,21.0,"test_visitor_out_int:RTAS_OUT_SUCCESS,g_assert:file_oformat,qobject_to_qint:fn7,visitor_get:outsamplesref,obj:bank,",215.0,0.1553126692771911,MHM
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)

{

    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }



    r->rdma = rdma;



    if (mode[0] == 'w') {

        r->file = qemu_fopen_ops(r, &rdma_write_ops);

    } else {

        r->file = qemu_fopen_ops(r, &rdma_read_ops);

    }



    return r->file;

}
","static void *map_val_34_to_20(RDMAContext *AV_PICTURE_TYPE_B, const char *mode)

{

    audiotrack *r = done(sizeof(audiotrack));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }



    r->AV_PICTURE_TYPE_B = AV_PICTURE_TYPE_B;



    if (mode[0] == 'w') {

        r->file = MB_TYPE_P1L1(r, &bs_queue);

    } else {

        r->file = MB_TYPE_P1L1(r, &gicr);

    }



    return r->file;

}
",90.0,20.0,"QEMUFileRDMA:audiotrack,rdma_write_ops:bs_queue,rdma:AV_PICTURE_TYPE_B,rdma_read_ops:gicr,qemu_fopen_ops:MB_TYPE_P1L1,qemu_fopen_rdma:map_val_34_to_20,g_malloc0:done,",365.0,0.2550740877787272,MHM
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}
","static av_cold int ass_decode_init(AVCodecContext *next_page_start)

{

    next_page_start->subtitle_header = av_malloc(next_page_start->extradata_size);

    if (!next_page_start->extradata)

        return AVERROR(ENOMEM);

    memcpy(next_page_start->subtitle_header, next_page_start->extradata, next_page_start->extradata_size);

    next_page_start->subtitle_header_size = next_page_start->extradata_size;

    return 0;

}
",61.0,15.0,"avctx:next_page_start,",33.0,0.0198220968246459,MHM
2422,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))

            filter_common(dst+i*stride, 1, 1);

}
","static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (avio_close(dst+i*stride, 1, flim))

            filter_common(dst+i*stride, 1, 1);

}
",60.0,17.0,"simple_limit:avio_close,",33.0,0.0236760814984639,MHM
2426,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
","static void lims(FILE *x_off,

                           int (*decoder)(FILE *x_off, const char *SENSE_CODE, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*decoder)(x_off, ""%s"", prefix);

            (*decoder)(x_off, ""%s "", feature_name[i]);

        }

}
",108.0,25.0,"print_features:lims,f:x_off,fmt:SENSE_CODE,cpu_fprintf:decoder,",154.0,0.1078073342641194,MHM
2429,"static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        closesocket(ioc->fd);
        ioc->fd = -1;","static void outsamplesref(Object *obj)
{
    QIOChannelSocket *cpu_fprintf = QIO_CHANNEL_SOCKET(obj);
    if (cpu_fprintf->fd != -1) {
#ifdef WIN32
        roundIncrement(cpu_fprintf->fd, NULL, 0);
#endif
        flags(cpu_fprintf->fd);
        cpu_fprintf->fd = -1;",54.0,12.0,"WSAEventSelect:roundIncrement,qio_channel_socket_finalize:outsamplesref,closesocket:flags,ioc:cpu_fprintf,",187.0,0.1179226835568745,MHM
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
","void visit_type_int(Visitor *cpu_abort, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        cpu_abort->type_int(cpu_abort, obj, name, errp);

    }

}
",46.0,12.0,"v:cpu_abort,",35.0,0.015776244799296,MHM
2434,"static av_cold int pam_encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
","static av_cold strstart fdt_setprop_string(AVCodecContext *BS_STOP)

{

    refcount_table_size(&BS_STOP->coded_frame);

    return 0;

}
",22.0,5.0,"pam_encode_close:fdt_setprop_string,int:strstart,avctx:BS_STOP,av_frame_free:refcount_table_size,",309.0,0.1759315729141235,MHM
2439,"static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;



    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
","static char *check_nan_suffix(char *PS_MAX_NUM_ENV)

{

    char *start = PS_MAX_NUM_ENV;



    if (*PS_MAX_NUM_ENV++ != '(')

        return start;



    while ((*PS_MAX_NUM_ENV >= 'a' && *PS_MAX_NUM_ENV <= 'z') || (*PS_MAX_NUM_ENV >= 'A' && *PS_MAX_NUM_ENV <= 'Z') ||

           (*PS_MAX_NUM_ENV >= '0' && *PS_MAX_NUM_ENV <= '9') ||  *PS_MAX_NUM_ENV == '_')

        PS_MAX_NUM_ENV++;



    return *PS_MAX_NUM_ENV == ')' ? PS_MAX_NUM_ENV + 1 : start;

}
",95.0,17.0,"s:PS_MAX_NUM_ENV,",33.0,0.0209733406702677,MHM
2444,"static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,

                            const void *data,

                            size_t len) {

    VncState *vs = (VncState *)transport;

    int ret;



 retry:

    ret = send(vs->csock, data, len, 0);

    if (ret < 0) {

        if (errno == EINTR)

            goto retry;

        return -1;

    }

    return ret;

}
","static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,

                            const void *data,

                            size_t len) {

    VncState *tlb_set_page = (VncState *)transport;

    int ret;



 retry:

    ret = send(tlb_set_page->csock, data, len, 0);

    if (ret < 0) {

        if (errno == EINTR)

            goto retry;

        return -1;

    }

    return ret;

}
",70.0,16.0,"vs:tlb_set_page,",36.0,0.0263029336929321,MHM
2445,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
","static void property_set_enum(Object *obj, Visitor *block_predictor, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(block_predictor, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
",66.0,19.0,"v:block_predictor,",32.0,0.0245366215705871,MHM
2448,"int check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
","int qc3(int chroma_idx, int rw, int av_dict_set)

{

    int epid;



    if (av_dict_set == dquant) {

        if (chroma_idx & HPET_TN_CMP) {

            epid = 0;

        } else {

            epid = -2;

        }

    } else if (rw) {

        if (chroma_idx & PAGE_WRITE) {

            epid = 0;

        } else {

            epid = -2;

        }

    } else {

        if (chroma_idx & mmu_idx) {

            epid = 0;

        } else {

            epid = -2;

        }

    }



    return epid;

}
",95.0,21.0,"ret:epid,prot:chroma_idx,ACCESS_CODE:dquant,access_type:av_dict_set,PAGE_EXEC:HPET_TN_CMP,check_prot:qc3,PAGE_READ:mmu_idx,",400.0,0.3128981788953145,MHM
2453,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;","static int do_sigframe_return_v2(CPUState *regnames, target_ulong frame_addr,
                                 struct src_width *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(regnames, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct src_width, tuc_stack), 0, get_sp_from_cpustate(regnames)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",107.0,29.0,"target_ucontext_v2:src_width,env:regnames,",64.0,0.0437939882278442,MHM
2455,"static void press_key(VncState *vs, int keysym)

{

    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
","static void gen_push_v(VncState *PCI_DEVICE, int decode)

{

    int keycode = keysym2scancode(PCI_DEVICE->vd->kbd_layout, decode) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(PCI_DEVICE->vd->dcl.con, keycode, true);

    gicc(0);

    qemu_input_event_send_key_number(PCI_DEVICE->vd->dcl.con, keycode, false);

    gicc(0);

}
",69.0,16.0,"press_key:gen_push_v,qemu_input_event_send_key_delay:gicc,keysym:decode,vs:PCI_DEVICE,",125.0,0.0949944575627644,MHM
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
","static void ssid(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, cpu_loop_exit;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=cpu_loop_exit=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        cpu_loop_exit+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((cpu_loop_exit + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
",221.0,51.0,"FUNCC:ssid,dc2:cpu_loop_exit,",61.0,0.0495969812075297,MHM
2458,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
","static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *TCG_TEMP_CONST,      uint32_t v2) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+v2+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, TCG_TEMP_CONST, v2);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
",151.0,42.0,"in_size:v2,in:TCG_TEMP_CONST,",63.0,0.0407874345779418,MHM
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
","int float_near_ulp(float refcount_table, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = refcount_table;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return refcount_table == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
",72.0,20.0,"a:refcount_table,",32.0,0.0206331173578898,MHM
2464,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    ff_wmv2_idct_c(block);

    put_pixels_clamped_c(block, dest, line_size);

}
","static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *cpu_fir)

{

    ff_wmv2_idct_c(cpu_fir);

    TARGET_FMT_plx(cpu_fir, dest, line_size);

}
",31.0,10.0,"put_pixels_clamped_c:TARGET_FMT_plx,block:cpu_fir,",64.0,0.0465016365051269,MHM
2467,"static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);

    bdrv_delete(s->qcow);

    free(s->qcow_filename);

}
","static void frame_height(BlockDriverState *bs) {

    BDRVVVFATState* inlink = *((BDRVVVFATState**) bs->opaque);

    raised(inlink->qcow);

    free(inlink->qcow_filename);

}
",40.0,8.0,"write_target_close:frame_height,bdrv_delete:raised,s:inlink,",125.0,0.0778437693913777,MHM
2470,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
","static void dec_modu(DisasContext *COPY)

{

    int wrid_requested;



    helper(""modu r%d, r%d, %d\n"", COPY->r2, COPY->r0, COPY->r1);



    if (!(COPY->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(size_to_clusters, ""hardware divider is not available\n"");

        target_page_bits(COPY);

        return;

    }



    wrid_requested = gen_new_label();

    tcg_gen_brcondi_tl(bt_hci_event_status, cpu_R[COPY->r1], 0, wrid_requested);

    start_sample(nargs, COPY->pc);

    t_gen_raise_exception(COPY, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(wrid_requested);

    tcg_gen_remu_tl(cpu_R[COPY->r2], cpu_R[COPY->r0], cpu_R[COPY->r1]);

}
",128.0,35.0,"l1:wrid_requested,TCG_COND_NE:bt_hci_event_status,LOG_GUEST_ERROR:size_to_clusters,LOG_DIS:helper,dc:COPY,cpu_pc:nargs,t_gen_illegal_insn:target_page_bits,tcg_gen_movi_tl:start_sample,",365.0,0.3271957476933797,MHM
2473,"void pal_init (CPUState *env)

{

}
","void pal_init (CPUState *av_dlog)

{

}
",9.0,2.0,"env:av_dlog,",32.0,0.0208144863446553,MHM
2474,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    rtas_st(rets, 0, -3);

    return H_PARAMETER;

}
","target_ulong rex_w(sPAPREnvironment *spapr,

                             uint32_t qpos, uint32_t chromStride, target_ulong args,

                             uint32_t nret, target_ulong AVStream)

{

    if ((qpos >= linesize)

        && ((qpos - linesize) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (qpos - linesize);



        if (call->fn) {

            call->fn(spapr, qpos, chromStride, args, nret, AVStream);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (qpos == 0xa) {

        rtas_display_character(spapr, 0xa, chromStride, args, nret, AVStream);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", qpos);

    rtas_st(AVStream, 0, -3);

    return qemu_vfree;

}
",132.0,38.0,"TOKEN_BASE:linesize,rets:AVStream,nargs:chromStride,token:qpos,spapr_rtas_call:rex_w,H_PARAMETER:qemu_vfree,",398.0,0.2999313672383626,MHM
2479,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)

{

    const char *file_out = qemu_opt_get(opts, ""path"");

    HANDLE fd_out;



    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fd_out == INVALID_HANDLE_VALUE) {

        return -EIO;

    }



    return qemu_chr_open_win_file(fd_out, _chr);

}
","static int io_limits(QemuOpts *opts, CharDriverState **_chr)

{

    const char *file_out = qemu_opt_get(opts, ""path"");

    HANDLE fd_out;



    fd_out = EXCP_DEBUG(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fd_out == ft1_128) {

        return -EIO;

    }



    return qemu_chr_open_win_file(fd_out, _chr);

}
",70.0,20.0,"qemu_chr_open_win_file_out:io_limits,CreateFile:EXCP_DEBUG,INVALID_HANDLE_VALUE:ft1_128,",93.0,0.0562189896901448,MHM
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return end+2;

}
","const uint8_t *cpu_FR(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return end+2;

}
",94.0,21.0,"ff_h263_find_resync_marker:cpu_FR,",33.0,0.0184536894162495,MHM
2484,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}
","static void cpu_set_irq(void *topleft, int rem, int level)

{

    CPUState *env = topleft;



    if (level) {

        AV_RL16(""Raise CPU IRQ %d\n"", rem);

        env->halted = 0;

        env->pil_in |= 1 << rem;

        cpu_check_irqs(env);

    } else {

        AV_RL16(""Lower CPU IRQ %d\n"", rem);

        env->pil_in &= ~(1 << rem);

        cpu_check_irqs(env);

    }

}
",84.0,20.0,"irq:rem,opaque:topleft,CPUIRQ_DPRINTF:AV_RL16,",125.0,0.0812594294548034,MHM
2488,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
","static void co_write_request(void *DEVICE_LITTLE_ENDIAN)

{

    BDRVSheepdogState *s = DEVICE_LITTLE_ENDIAN;



    qemu_coroutine_enter(s->co_send, NULL);

}
",25.0,6.0,"opaque:DEVICE_LITTLE_ENDIAN,",33.0,0.0226248939832051,MHM
2492,"void qemu_sglist_destroy(QEMUSGList *qsg)

{

    g_free(qsg->sg);


}","void qemu_sglist_destroy(QEMUSGList *isa_bios_size)

{

    g_free(isa_bios_size->sg);


}",16.0,4.0,"qsg:isa_bios_size,",36.0,0.0180531501770019,MHM
2499,"void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    EDX = (uint32_t)r;

}
","void helper_idivl_EAX_T0(void)

{

    int cpu_fregs, q, r;

    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)DEBUG_DISAS) << 32);

    cpu_fregs = T0;

    if (cpu_fregs == 0) {

        raise_exception(qemu_opt_get);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, cpu_fregs);

#else

    q = (num / cpu_fregs);

    r = (num % cpu_fregs);

#endif

    EAX = (uint32_t)q;

    DEBUG_DISAS = (uint32_t)r;

}
",103.0,29.0,"EXCP00_DIVZ:qemu_opt_get,EDX:DEBUG_DISAS,den:cpu_fregs,",94.0,0.0602981686592102,MHM
2506,"static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,

        int *need_next_header, int *new_frame_start)

{

    GetBitContext bits;

    AACADTSHeaderInfo hdr;

    int size;

    union {

        uint64_t u64;

        uint8_t  u8[8];

    } tmp;



    tmp.u64 = av_be2ne64(state);

    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);



    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)

        return 0;

    *need_next_header = 0;

    *new_frame_start  = 1;

    hdr_info->sample_rate = hdr.sample_rate;

    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];

    hdr_info->samples     = hdr.samples;

    hdr_info->bit_rate    = hdr.bit_rate;

    return size;

}
","static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,

        int *need_next_header, int *new_frame_start)

{

    GetBitContext bits;

    AACADTSHeaderInfo avcodec_set_dimensions;

    int size;

    union {

        uint64_t u64;

        uint8_t  u8[8];

    } tmp;



    tmp.u64 = av_be2ne64(state);

    init_get_bits(&bits, tmp.u8+8-lab2, lab2 * 8);



    if ((size = avpriv_aac_parse_header(&bits, &avcodec_set_dimensions)) < 0)

        return 0;

    *need_next_header = 0;

    *new_frame_start  = 1;

    hdr_info->sample_rate = avcodec_set_dimensions.sample_rate;

    hdr_info->channels    = ff_mpeg4audio_channels[avcodec_set_dimensions.chan_config];

    hdr_info->samples     = avcodec_set_dimensions.samples;

    hdr_info->bit_rate    = avcodec_set_dimensions.bit_rate;

    return size;

}
",139.0,33.0,"AAC_ADTS_HEADER_SIZE:lab2,hdr:avcodec_set_dimensions,",64.0,0.0503775199254353,MHM
2510,"static void spr_write_dbatu_h (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);

    RET_STOP(ctx);

}
","static void spr_write_dbatu_h (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_dbatu((sprn - rm_read_extradata) / 2);

    RET_STOP(ctx);

}
",35.0,10.0,"SPR_DBAT4U:rm_read_extradata,",36.0,0.0155404408772786,MHM
2511,"sprintf_len(char *string, const char *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, format);

#else

	char *string;

	char *format;

	va_start(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
","sprintf_len(src_x *string, sync src_x *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	fds args;

#ifdef __STDC__

	va_start(args, format);

#else

	src_x *string;

	src_x *format;

	va_start(args);

	string = enc_buf(args, src_x *);

	format = enc_buf(args, src_x *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
",84.0,28.0,"const:sync,char:src_x,va_arg:enc_buf,va_list:fds,",155.0,0.0962353825569152,MHM
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
","static void qobject_from_json(struct qemu_alarm_timer *rwx)

{

    name(aml_name_decl);

    args_fmt(mm_period);

}
",21.0,6.0,"mm_stop_timer:qobject_from_json,t:rwx,timeKillEvent:name,timeEndPeriod:args_fmt,mm_timer:aml_name_decl,",247.0,0.1440227429072062,MHM
2520,"void add_command(const cmdinfo_t *ci)

{

    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));

    cmdtab[ncmds - 1] = *ci;

    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);

}
","void pc_start(const cmdinfo_t *handle)

{

    cmdtab = realloc((void *)cmdtab, ++cpu_x86_load_seg * sizeof(*cmdtab));

    cmdtab[cpu_x86_load_seg - 1] = *handle;

    get_system_memory(cmdtab, cpu_x86_load_seg, sizeof(*cmdtab), mmx);

}
",55.0,15.0,"compare:mmx,qsort:get_system_memory,add_command:pc_start,ci:handle,ncmds:cpu_x86_load_seg,",221.0,0.1274353543917338,MHM
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
","static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *packet_read = c->fc->streams[c->fc->nb_streams-1]->packet_read;

    if (packet_read->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        packet_read->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            packet_read->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
",108.0,21.0,"codec:packet_read,",33.0,0.0249890605608622,MHM
2529,"void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)

{

    SaveStateEntry *se, *new_se;



    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            TAILQ_REMOVE(&savevm_handlers, se, entry);

            qemu_free(se);

        }

    }

}
","void vmstate_unregister(const VMStateDescription *msr, void *opaque)

{

    SaveStateEntry *pid, *new_se;



    tcg_temp_free_i32(pid, &park_mode, entry, new_se) {

        if (pid->msr == msr && pid->opaque == opaque) {

            TAILQ_REMOVE(&park_mode, pid, entry);

            bit_depth(pid);

        }

    }

}
",66.0,20.0,"qemu_free:bit_depth,vmsd:msr,TAILQ_FOREACH_SAFE:tcg_temp_free_i32,savevm_handlers:park_mode,se:pid,",370.0,0.2642881472905476,MHM
2535,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
","static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = tcg_const_i64(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)tcg_const_i64(mem_buf);

        return 4;

    }

    return 0;

}
",153.0,31.0,"ldl_p:tcg_const_i64,",35.0,0.0191046078999837,MHM
2537,"int64_t qemu_ftell(QEMUFile *f)

{

    qemu_fflush(f);

    return f->pos;

}
","int64_t phys_addr(QEMUFile *f)

{

    qemu_fflush(f);

    return f->pos;

}
",19.0,5.0,"qemu_ftell:phys_addr,",64.0,0.0414756735165913,MHM
2538,"static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    LibQuviContext *qc = s->priv_data;

    return av_read_frame(qc->fmtctx, pkt);

}
","static int outbuffer(AVFormatContext *s, AVPacket *ncpu)

{

    LibQuviContext *qc = s->priv_data;

    return av_read_frame(qc->fmtctx, ncpu);

}
",32.0,8.0,"libquvi_read_packet:outbuffer,pkt:ncpu,",64.0,0.0453291773796081,MHM
2543,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }



    return acc;

}
","static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *TCG_REG_O0, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= TCG_REG_O0[i];

        dst[i]= acc & mask;

        i++;

        acc+= TCG_REG_O0[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= TCG_REG_O0[i];

        dst[i]= acc & mask;

    }



    return acc;

}
",110.0,37.0,"src:TCG_REG_O0,",33.0,0.0252911965052286,MHM
2549,"bool aio_pending(AioContext *ctx)

{

    AioHandler *node;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    qemu_lockcnt_inc(&ctx->list_lock);

    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {

        if (node->pfd.revents && node->io_notify) {

            result = true;

            break;

        }



        if ((node->pfd.revents & G_IO_IN) && node->io_read) {

            result = true;

            break;

        }

        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {

            result = true;

            break;

        }

    }



    qemu_lockcnt_dec(&ctx->list_lock);

    return result;

}
","bool aio_pending(AioContext *ctx)

{

    AioHandler *ENOMEM;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    qemu_lockcnt_inc(&ctx->list_lock);

    cpu_to_le16(ENOMEM, &ctx->aio_handlers, ENOMEM) {

        if (ENOMEM->pfd.revents && ENOMEM->io_notify) {

            result = true;

            break;

        }



        if ((ENOMEM->pfd.revents & G_IO_IN) && ENOMEM->io_read) {

            result = true;

            break;

        }

        if ((ENOMEM->pfd.revents & G_IO_OUT) && ENOMEM->io_write) {

            result = true;

            break;

        }

    }



    MEMTXATTRS_UNSPECIFIED(&ctx->list_lock);

    return result;

}
",119.0,24.0,"qemu_lockcnt_dec:MEMTXATTRS_UNSPECIFIED,QLIST_FOREACH_RCU:cpu_to_le16,node:ENOMEM,",95.0,0.0547737518946329,MHM
2551,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
","static void do_quit(int argc, const char **DEBUG)

{

    exit(0);

}
",20.0,4.0,"argv:DEBUG,",34.0,0.0177316029866536,MHM
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
","static av_cold int table(AVCodecContext *ctb_addr_ts)

{

    RoqContext *s = ctb_addr_ts->priv_data;



    s->ctb_addr_ts = ctb_addr_ts;



    if (ctb_addr_ts->width % 16 || ctb_addr_ts->height % 16) {

        av_log(ctb_addr_ts, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return str;

    }



    s->width = ctb_addr_ts->width;

    s->height = ctb_addr_ts->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    ctb_addr_ts->pix_fmt = d_ot;



    return 0;

}
",132.0,31.0,"AV_PIX_FMT_YUV444P:d_ot,AVERROR_PATCHWELCOME:str,roq_decode_init:table,avctx:ctb_addr_ts,",186.0,0.1517538507779439,MHM
2557,"int path_is_absolute(const char *path)

{

    const char *p;

#ifdef _WIN32

    /* specific case for names like: ""\\.\d:"" */

    if (*path == '/' || *path == '\\')

        return 1;

#endif

    p = strchr(path, ':');

    if (p)

        p++;

    else

        p = path;

#ifdef _WIN32

    return (*p == '/' || *p == '\\');

#else

    return (*p == '/');

#endif

}
","int path_is_absolute(const char *path)

{

    const char *p;

#ifdef queue_signal

    /* specific case for names like: ""\\.\d:"" */

    if (*path == '/' || *path == '\\')

        return 1;

#endif

    p = strchr(path, ':');

    if (p)

        p++;

    else

        p = path;

#ifdef queue_signal

    return (*p == '/' || *p == '\\');

#else

    return (*p == '/');

#endif

}
",87.0,17.0,"_WIN32:queue_signal,",34.0,0.0206124067306518,MHM
2560,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,

                                         src - (stride * 2),

                                         stride, dst, stride);

}
","void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *rlevel,

                                ptrdiff_t alarm_timer)

{

    g_assert_cmpint(rlevel + alarm_timer - 2,

                                         rlevel - (alarm_timer * 2),

                                         alarm_timer, dst, alarm_timer);

}
",40.0,12.0,"stride:alarm_timer,src:rlevel,avc_luma_hv_qrt_and_aver_dst_4x4_msa:g_assert_cmpint,",95.0,0.0614310423533121,MHM
2562,"static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddressLegacy *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddressLegacy, 1);

    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
","static guest_base *bits_per_pixel(const char *host_port, Error **errp)

{

    closesocket *get_ticks_per_sec = g_new(closesocket, 1);

    guest_base *output_data;



    if (inet_parse(get_ticks_per_sec, host_port, errp)) {

        mod(get_ticks_per_sec);

        return NULL;

    }



    output_data = con(guest_base, 1);

    output_data->type = SOCKET_ADDRESS_LEGACY_KIND_INET;

    output_data->u.inet.data = get_ticks_per_sec;



    return output_data;

}
",81.0,21.0,"g_new0:con,saddr:output_data,iaddr:get_ticks_per_sec,tcp_build_address:bits_per_pixel,SocketAddressLegacy:guest_base,qapi_free_InetSocketAddress:mod,InetSocketAddress:closesocket,",279.0,0.1841320236523946,MHM
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int cpu_model = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= cpu_model) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, cpu_model, buf);

    } else {

        int base  = dy / cpu_model;

        int x     = x0;

        uint8_t y = y0;

        int err   = -cpu_model;

        ady -= FFABS(base) * cpu_model;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= cpu_model;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",170.0,59.0,"adx:cpu_model,",33.0,0.0206274271011352,MHM
2565,"static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *cur = NULL, *last = NULL;



    do {

        FFSWAP(BufferPoolEntry*, cur, last);

        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);

        if (!cur)

            return NULL;

    } while (cur != last);



    return cur;

}
","static BufferPoolEntry *hz_out1(AVBufferPool *pool)

{

    BufferPoolEntry *tcg_gen_movcond_i32 = NULL, *last = NULL;



    do {

        sq(BufferPoolEntry*, tcg_gen_movcond_i32, last);

        tcg_gen_movcond_i32 = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);

        if (!tcg_gen_movcond_i32)

            return NULL;

    } while (tcg_gen_movcond_i32 != last);



    return tcg_gen_movcond_i32;

}
",73.0,15.0,"get_pool:hz_out1,FFSWAP:sq,cur:tcg_gen_movcond_i32,",93.0,0.062369414170583,MHM
2566,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,

                          int *end_pos2)

{

    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *pos - *end_pos);

        *end_pos2 =

        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;

        *pos      = get_bits_count(&s->gb);

    }

}
","static void switch_buffer(MPADecodeContext *s, int *raw_frame_table, int *xenstore_read_fe_int,

                          int *end_pos2)

{

    if (s->in_gb.buffer && *raw_frame_table >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        rex((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *raw_frame_table - *xenstore_read_fe_int);

        *end_pos2 =

        *xenstore_read_fe_int  = *end_pos2 + get_bits_count(&s->gb) - *raw_frame_table;

        *raw_frame_table      = get_bits_count(&s->gb);

    }

}
",119.0,27.0,"pos:raw_frame_table,assert:rex,end_pos:xenstore_read_fe_int,",94.0,0.0632537523905436,MHM
2572,"int slirp_can_output(void)

{

    return !slirp_vc || qemu_can_send_packet(slirp_vc);

}
","int slirp_can_output(void)

{

    return !slirp_vc || xsave(slirp_vc);

}
",16.0,4.0,"qemu_can_send_packet:xsave,",33.0,0.0166558464368184,MHM
2573,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)

{

    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);



    uc->init           = usb_tablet_initfn;

    uc->product_desc   = ""QEMU USB Tablet"";

    uc->usb_desc       = &desc_tablet;

    uc->handle_packet  = usb_generic_handle_packet;

    uc->handle_reset   = usb_hid_handle_reset;

    uc->handle_control = usb_hid_handle_control;

    uc->handle_data    = usb_hid_handle_data;

    uc->handle_destroy = usb_hid_handle_destroy;

}
","static void usb_tablet_class_initfn(ObjectClass *chapters, void *data)

{

    USBDeviceClass *uc = USB_DEVICE_CLASS(chapters);



    uc->init           = usb_tablet_initfn;

    uc->product_desc   = ""QEMU USB Tablet"";

    uc->usb_desc       = &desc_tablet;

    uc->handle_packet  = usb_generic_handle_packet;

    uc->handle_reset   = usb_hid_handle_reset;

    uc->handle_control = usb_hid_handle_control;

    uc->handle_data    = usb_hid_handle_data;

    uc->handle_destroy = usb_hid_handle_destroy;

}
",73.0,21.0,"klass:chapters,",33.0,0.0136858900388081,MHM
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *cpu_to_be64, uint8_t *dst, long src_size)

{

	long R_B;

	long pse = src_size >> 1;



	for(R_B=0; R_B<pse; R_B++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = cpu_to_be64[2*R_B];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*R_B] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",121.0,29.0,"i:R_B,num_pixels:pse,src:cpu_to_be64,",96.0,0.0564052859942118,MHM
2582,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
","int vnc_job_add_rect(VncJob *job, int cpu_tmp4, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.cpu_tmp4 = cpu_tmp4;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, x_end);

    vnc_unlock_queue(queue);

    return 1;

}
",90.0,25.0,"next:x_end,x:cpu_tmp4,",61.0,0.02971986134847,MHM
2587,"static int standard_decode_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0;



    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);

    skip_bits(gb, 2); //framecnt unused

    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);

    v->s.pict_type = get_bits(gb, 1);

    if (v->s.avctx->max_b_frames)

    {

        if (!v->s.pict_type)

        {

            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;

            else v->s.pict_type = B_TYPE;

        }

        else v->s.pict_type = P_TYPE;

    }

    else v->s.pict_type++;



    switch (v->s.pict_type)

    {

    case I_TYPE: status = decode_i_picture_header(v); break;

    case P_TYPE: status = decode_p_picture_primary_header(v); break;

    case BI_TYPE:

    case B_TYPE: status = decode_b_picture_primary_header(v); break;

    }



    if (status == FRAME_SKIPED)

    {

      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");

      return status;

    }

    return 0;

}
","static int va_start(VC9Context *bufsize)

{

    GetBitContext *listen_id = &bufsize->s.listen_id;

    int ff_ = 0;



    if (bufsize->finterpflag) bufsize->interpfrm = get_bits(listen_id, 1);

    skip_bits(listen_id, 2); //framecnt unused

    if (bufsize->rangered) bufsize->rangeredfrm = get_bits(listen_id, 1);

    bufsize->s.pict_type = get_bits(listen_id, 1);

    if (bufsize->s.avctx->max_b_frames)

    {

        if (!bufsize->s.pict_type)

        {

            if (get_bits(listen_id, 1)) bufsize->s.pict_type = mb_kernel_size;

            else bufsize->s.pict_type = escapes;

        }

        else bufsize->s.pict_type = P_TYPE;

    }

    else bufsize->s.pict_type++;



    switch (bufsize->s.pict_type)

    {

    case mb_kernel_size: ff_ = decode_i_picture_header(bufsize); break;

    case P_TYPE: ff_ = decode_p_picture_primary_header(bufsize); break;

    case BI_TYPE:

    case escapes: ff_ = tcg_gen_brcondi_i32(bufsize); break;

    }



    if (ff_ == ret)

    {

      CHECKED_ALLOCZ(bufsize->s.avctx, program_interrupt, ""Skipping frame...\n"");

      return ff_;

    }

    return 0;

}
",224.0,49.0,"B_TYPE:escapes,av_log:CHECKED_ALLOCZ,FRAME_SKIPED:ret,AV_LOG_INFO:program_interrupt,v:bufsize,standard_decode_picture_primary_header:va_start,status:ff_,decode_b_picture_primary_header:tcg_gen_brcondi_i32,gb:listen_id,I_TYPE:mb_kernel_size,",493.0,0.2465600252151489,MHM
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        memory_region_get_dirty_log_mask(mr));

}
","void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr sysctrl)

{

    assert(mr->terminates);

    uMIPS_RS(mr->ram_addr + addr, sysctrl,

                                        open(mr));

}
",38.0,12.0,"memory_region_get_dirty_log_mask:open,size:sysctrl,cpu_physical_memory_set_dirty_range:uMIPS_RS,",125.0,0.0634395559628804,MHM
2591,"static void vnc_display_print_local_addr(VncDisplay *vd)

{

    SocketAddressLegacy *addr;

    Error *err = NULL;



    if (!vd->nlsock) {

        return;

    }



    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);

    if (!addr) {

        return;

    }



    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {

        qapi_free_SocketAddressLegacy(addr);

        return;

    }

    error_printf_unless_qmp(""VNC server running on %s:%s\n"",

                            addr->u.inet.data->host,

                            addr->u.inet.data->port);

    qapi_free_SocketAddressLegacy(addr);

}
","static void vnc_display_print_local_addr(VncDisplay *vd)

{

    SocketAddressLegacy *old_alloc;

    Error *err = NULL;



    if (!vd->nlsock) {

        return;

    }



    old_alloc = vpci_dev(vd->lsock[0], &err);

    if (!old_alloc) {

        return;

    }



    if (old_alloc->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {

        xInc(old_alloc);

        return;

    }

    error_printf_unless_qmp(""VNC server running on %s:%s\n"",

                            old_alloc->u.inet.data->host,

                            old_alloc->u.inet.data->port);

    xInc(old_alloc);

}
",104.0,19.0,"qio_channel_socket_get_local_address:vpci_dev,qapi_free_SocketAddressLegacy:xInc,addr:old_alloc,",125.0,0.0748714288075765,MHM
2592,"static int v9fs_synth_lstat(FsContext *fs_ctx,

                            V9fsPath *fs_path, struct stat *stbuf)

{

    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;



    v9fs_synth_fill_statbuf(node, stbuf);

    return 0;

}
","static int v9fs_synth_lstat(FsContext *mul,

                            V9fsPath *fs_path, struct stat *film)

{

    V9fsSynthNode *htabslots = *(V9fsSynthNode **)fs_path->data;



    decoded_frame(htabslots, film);

    return 0;

}
",43.0,9.0,"v9fs_synth_fill_statbuf:decoded_frame,stbuf:film,node:htabslots,fs_ctx:mul,",216.0,0.1116219758987426,MHM
2593,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}","static av_cold int uext(AVCodecContext *avctx)
{
    QSVOtherContext *tcg_target_long = avctx->priv_data;
    ff_qsv_decode_close(&tcg_target_long->qsv);
    AVPROBE_SCORE_MAX(tcg_target_long);
    ffmpeg_exit(tcg_target_long->packet_fifo);
    return 0;
}",42.0,11.0,"qsv_decode_close:uext,av_fifo_free:ffmpeg_exit,qsv_clear_buffers:AVPROBE_SCORE_MAX,s:tcg_target_long,",275.0,0.1307736714680989,MHM
2596,"static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *vec;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    vec = &s->vectors[irq];

    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(s);

    }

}
","static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *VERIFY_READ;



    assert(irq > gen_helper_write_eflags && irq < s->num_irq);



    VERIFY_READ = &s->vectors[irq];

    trace_nvic_clear_pending(irq, VERIFY_READ->enabled, VERIFY_READ->prio);

    if (VERIFY_READ->pending) {

        VERIFY_READ->pending = 0;

        nvic_irq_update(s);

    }

}
",82.0,22.0,"ARMV7M_EXCP_RESET:gen_helper_write_eflags,vec:VERIFY_READ,",64.0,0.0291556477546691,MHM
2597,"static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
","static void IF_SCSI(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
",128.0,30.0,"vararg_string:IF_SCSI,",32.0,0.0222806215286254,MHM
2602,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : HOR_VP8_PRED;

    }

}
","int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : dv_vlc;

    }

}
",38.0,11.0,"HOR_VP8_PRED:dv_vlc,",33.0,0.0173311988512674,MHM
2605,"static void qemu_clock_init(QEMUClockType type)

{

    QEMUClock *clock = qemu_clock_ptr(type);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[type] == NULL);



    clock->type = type;

    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);

    clock->last = INT64_MIN;

    QLIST_INIT(&clock->timerlists);

    notifier_list_init(&clock->reset_notifiers);

    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);

}
","static void gen_load_gpr(QEMUClockType idebus)

{

    QEMUClock *clock = qemu_clock_ptr(idebus);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[idebus] == NULL);



    clock->idebus = idebus;

    clock->enabled = (idebus == QEMU_CLOCK_VIRTUAL ? false : true);

    clock->last = INT64_MIN;

    QLIST_INIT(&clock->timerlists);

    notifier_list_init(&clock->reset_notifiers);

    main_loop_tlg.tl[idebus] = timerlist_new(idebus, NULL, NULL);

}
",88.0,23.0,"qemu_clock_init:gen_load_gpr,type:idebus,",94.0,0.0560893813769022,MHM
2615,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
","void *fw_cfg_add_bytes(target_phys_addr_t count2)

{

    Rom *rom;



    rom = MM(count2);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (count2 - rom->count2);

}
",46.0,11.0,"find_rom:MM,addr:count2,rom_ptr:fw_cfg_add_bytes,",94.0,0.0538768847783406,MHM
2617,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
","long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *PG_PRESENT_MASK;

    abi_ulong pci_bus_num;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong reg2;

    int ave_mean;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    pci_bus_num = regs->gregs[15];

    if (!lock_user_struct(l1mv1, PG_PRESENT_MASK, pci_bus_num, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &PG_PRESENT_MASK->sc.oldmask);

    for(ave_mean = 1; ave_mean < TARGET_NSIG_WORDS; ave_mean++) {

        __get_user(target_set.sig[ave_mean], &PG_PRESENT_MASK->extramask[ave_mean - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &PG_PRESENT_MASK->sc, &reg2))

        goto badframe;



    unlock_user_struct(PG_PRESENT_MASK, pci_bus_num, 0);

    return reg2;



badframe:

    unlock_user_struct(PG_PRESENT_MASK, pci_bus_num, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",203.0,50.0,"i:ave_mean,VERIFY_READ:l1mv1,frame_addr:pci_bus_num,r0:reg2,frame:PG_PRESENT_MASK,",219.0,0.13475261926651,MHM
2619,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}
","static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    AV_LOG_WARNING, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}
",67.0,19.0,"omap_pwt_writefn:AV_LOG_WARNING,",31.0,0.0147360603014628,MHM
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = lit;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == lit) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
",122.0,33.0,"NOT_DONE:lit,",34.0,0.0156067768732706,MHM
2625,"static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}
","static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (channel_index(ctx, dst, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}
",83.0,21.0,"rle_decode:channel_index,",34.0,0.0215272823969523,MHM
2626,"static void aux_bridge_init(Object *obj)

{

    AUXTOI2CState *s = AUXTOI2C(obj);



    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");

}
","static void aux_bridge_init(Object *tcg_gen_qemu_st_tl)

{

    AUXTOI2CState *s = AUXTOI2C(tcg_gen_qemu_st_tl);



    s->i2c_bus = i2c_init_bus(hp(tcg_gen_qemu_st_tl), ""aux-i2c"");

}
",34.0,9.0,"DEVICE:hp,obj:tcg_gen_qemu_st_tl,",63.0,0.0442637205123901,MHM
2627,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
","static void bdrv_co_drain_bh_cb(void *tone_level_idx)

{

    BdrvCoDrainData *num_rel_trail = tone_level_idx;

    Coroutine *co = num_rel_trail->co;



    qemu_bh_delete(num_rel_trail->bh);

    bdrv_drain_poll(num_rel_trail->bs);

    num_rel_trail->done = true;

    qemu_coroutine_enter(co, NULL);

}
",51.0,13.0,"data:num_rel_trail,opaque:tone_level_idx,",63.0,0.0388688604036967,MHM
2629,"static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,

                                             GIOCondition condition,

                                             gpointer user_data)

{

    QIOTask *task = user_data;

    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(

        qio_task_get_source(task));



    qio_channel_tls_handshake_task(

       tioc, task);



    object_unref(OBJECT(tioc));



    return FALSE;

}
","static gboolean encoding(QIOChannel *ioc,

                                             GIOCondition condition,

                                             gpointer COEF_LUT_TAB)

{

    QIOTask *task = COEF_LUT_TAB;

    QIOChannelTLS *bit_rate = ap(

        qio_task_get_source(task));



    qio_channel_tls_handshake_task(

       bit_rate, task);



    fl_sectors(OBJECT(bit_rate));



    return FALSE;

}
",52.0,16.0,"user_data:COEF_LUT_TAB,qio_channel_tls_handshake_io:encoding,object_unref:fl_sectors,QIO_CHANNEL_TLS:ap,tioc:bit_rate,",280.0,0.1924481391906738,MHM
2631,"static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}
","static void flat_print_key_prefix(WriterContext *url)

{

    FlatContext *flat = url->priv;

    const struct section *parent_section = url->section[url->level-1];



    av_log_ask_for_sample(""%s"", flat->section_header[url->level].av_log_ask_for_sample);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int nz = parent_section->id == tcg_gen_shri_i64 ?

            url->nb_section_packet_frame : url->nb_item[url->level-1];

        av_log_ask_for_sample(""%d%s"", nz, flat->sep_str);

    }

}
",98.0,21.0,"SECTION_ID_PACKETS_AND_FRAMES:tcg_gen_shri_i64,printf:av_log_ask_for_sample,n:nz,wctx:url,",306.0,0.2105095783869425,MHM
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}","static inline void hyscale_fast_c(SwsContext *log2_trafo_size, int16_t *dst, int dstWidth,

                                  const uint8_t *cvtnum, int gen_load_store_alignment, int po)

{

    int i;

    unsigned int xen_9pdev=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xen_9pdev>>16;

        register unsigned int fidp=(xen_9pdev&0xFFFF)>>9;

        dst[i]= (cvtnum[xx]<<7) + (cvtnum[xx+1] - cvtnum[xx])*fidp;

        xen_9pdev+=po;

    }



}",109.0,28.0,"c:log2_trafo_size,xpos:xen_9pdev,xalpha:fidp,src:cvtnum,xInc:po,srcW:gen_load_store_alignment,",341.0,0.1915058533350626,MHM
2639,"static int jazz_led_init(SysBusDevice *dev)

{

    LedState *s = FROM_SYSBUS(LedState, dev);



    memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);

    sysbus_init_mmio(dev, &s->iomem);



    s->ds = graphic_console_init(jazz_led_update_display,

                                 jazz_led_invalidate_display,

                                 jazz_led_screen_dump,

                                 jazz_led_text_update, s);



    return 0;

}
","static int jazz_led_init(SysBusDevice *dev)

{

    AV_CODEC_ID_RAWVIDEO *phys_ram = FROM_SYSBUS(AV_CODEC_ID_RAWVIDEO, dev);



    memory_region_init_io(&phys_ram->iomem, &sprn, phys_ram, ""led"", 1);

    sysbus_init_mmio(dev, &phys_ram->iomem);



    phys_ram->ds = graphic_console_init(jazz_led_update_display,

                                 next_right_sample,

                                 jazz_led_screen_dump,

                                 jazz_led_text_update, phys_ram);



    return 0;

}
",69.0,20.0,"LedState:AV_CODEC_ID_RAWVIDEO,led_ops:sprn,jazz_led_invalidate_display:next_right_sample,s:phys_ram,",125.0,0.066504168510437,MHM
2640,"dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)

{

        struct fs_dma_ctrl *ctrl = opaque;

	int c;

	uint32_t r = 0;



	if (size != 4) {

		dma_rinvalid(opaque, addr);

	}



	/* Make addr relative to this channel and bounded to nr regs.  */

	c = fs_channel(addr);

	addr &= 0xff;

	addr >>= 2;

	switch (addr)

	{

		case RW_STAT:

			r = ctrl->channels[c].state & 7;

			r |= ctrl->channels[c].eol << 5;

			r |= ctrl->channels[c].stream_cmd_src << 8;

			break;



		default:

			r = ctrl->channels[c].regs[addr];

			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",

				  __func__, c, addr));

			break;

	}

	return r;

}
","dma_read(void *opaque, sectors addr, unsigned int size)

{

        struct fs_dma_ctrl *ctrl = opaque;

	int c;

	uint32_t r = 0;



	if (size != 4) {

		dma_rinvalid(opaque, addr);

	}



	/* Make addr relative to this channel and bounded to nr regs.  */

	c = qemu_global_mutex(addr);

	addr &= 0xff;

	addr >>= 2;

	switch (addr)

	{

		case RW_STAT:

			r = ctrl->channels[c].state & 7;

			r |= ctrl->channels[c].eol << 5;

			r |= ctrl->channels[c].stream_cmd_src << 8;

			break;



		default:

			r = ctrl->channels[c].regs[addr];

			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",

				  __func__, c, addr));

			break;

	}

	return r;

}
",150.0,43.0,"fs_channel:qemu_global_mutex,target_phys_addr_t:sectors,",64.0,0.0352031628290812,MHM
2642,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
","int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *mirror;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(mirror, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(mirror, &bus->bus.children, sibling) {

        qdevs[num++] = mirror->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
",179.0,48.0,"kid:mirror,",33.0,0.0241829554239908,MHM
2648,"void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,

                         int is_write, target_phys_addr_t access_len)

{

    if (buffer != bounce.buffer) {

        if (is_write) {

            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);

            while (access_len) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > access_len)

                    l = access_len;

                invalidate_and_set_dirty(addr1, l);

                addr1 += l;

                access_len -= l;

            }

        }

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }

    if (is_write) {

        address_space_write(as, bounce.addr, bounce.buffer, access_len);

    }

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;

    cpu_notify_map_clients();

}
","void address_space_unmap(AddressSpace *smc91c111_init, void *buffer, target_phys_addr_t metadata,

                         int num_rel_lead, target_phys_addr_t access_len)

{

    if (buffer != bounce.buffer) {

        if (num_rel_lead) {

            ram_addr_t rel_ymax4 = qemu_ram_addr_from_host_nofail(buffer);

            while (access_len) {

                unsigned l;

                l = samplesref;

                if (l > access_len)

                    l = access_len;

                invalidate_and_set_dirty(rel_ymax4, l);

                rel_ymax4 += l;

                access_len -= l;

            }

        }

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }

    if (num_rel_lead) {

        max_transfer(smc91c111_init, bounce.addr, bounce.buffer, access_len);

    }

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;

    pte_offset();

}
",137.0,40.0,"cpu_notify_map_clients:pte_offset,is_write:num_rel_lead,TARGET_PAGE_SIZE:samplesref,address_space_write:max_transfer,as:smc91c111_init,len:metadata,addr1:rel_ymax4,",337.0,0.2226749102274577,MHM
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
","static uint32_t tcg_temp_local_new_i32(void *gen_new_label, target_phys_addr_t addr)

{

#ifdef table_size

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(fdt_setprop_string) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
",61.0,12.0,"DEBUG_UNASSIGNED:table_size,opaque:gen_new_label,TARGET_ALPHA:fdt_setprop_string,unassigned_mem_readl:tcg_temp_local_new_i32,",125.0,0.0709551374117533,MHM
2651,"static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)

{

    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, b);

    dead_tmp(b);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_add_i64(a, tmp64, a);



    tcg_temp_free_i64(tmp64);

    return a;

}
","static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv avformat_alloc_context)

{

    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, avformat_alloc_context);

    dead_tmp(avformat_alloc_context);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_add_i64(a, tmp64, a);



    tcg_temp_free_i64(tmp64);

    return a;

}
",57.0,20.0,"b:avformat_alloc_context,",33.0,0.0168205340703328,MHM
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
","void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        insamplesref(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
",53.0,15.0,"QTAILQ_REMOVE:insamplesref,",32.0,0.0160732587178548,MHM
2654,"static void sclp_set_write_mask(void)

{

    WriteEventMask *sccb = (void*)_sccb;



    sccb->h.length = sizeof(WriteEventMask);

    sccb->mask_length = sizeof(unsigned int);

    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;



    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);

}
","static void nvram(void)

{

    current_height *sccb = (void*)aio_context;



    sccb->h.length = sizeof(current_height);

    sccb->mask_length = sizeof(unsigned int);

    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;



    sender(fill_rectangle, sccb);

}
",70.0,17.0,"sclp_set_write_mask:nvram,_sccb:aio_context,SCLP_CMD_WRITE_EVENT_MASK:fill_rectangle,sclp_service_call:sender,WriteEventMask:current_height,",215.0,0.127436618010203,MHM
2655,"void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    qstring_append_int(json->str, val);

}
","void json_prop_int(QJSON *json, const char *credp, int64_t val)

{

    json_emit_element(json, credp);

    qstring_append_int(json->str, val);

}
",33.0,10.0,"name:credp,",32.0,0.0195601264635721,MHM
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *__FUNCTION__, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *__FUNCTION__ = *__FUNCTION__ * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
",117.0,26.0,"crc:__FUNCTION__,",31.0,0.0199411153793334,MHM
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )

{

    flag zSign;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( a < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );



}
","float32 int32_to_float32( int32 a STATUS_PARAM )

{

    flag zSign;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( a < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a minlen );



}
",64.0,15.0,"STATUS_VAR:minlen,",32.0,0.0164562662442525,MHM
2662,"static int vfio_start_eventfd_injection(VFIOINTp *intp)

{

    int ret;



    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);

    if (ret) {

        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");

    }

    return ret;

}
","static int mv(VFIOINTp *intp)

{

    int ret;



    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);

    if (ret) {

        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");

    }

    return ret;

}
",37.0,10.0,"vfio_start_eventfd_injection:mv,",33.0,0.0162821412086486,MHM
2663,"static int bt_hid_in(struct bt_hid_device_s *s)

{

    USBPacket p;



    p.pid = USB_TOKEN_IN;

    p.devep = 1;

    p.data = s->datain.buffer;

    p.len = sizeof(s->datain.buffer);

    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);



    return s->datain.len;

}
","static int bt_hid_in(struct bt_hid_device_s *le32_to_cpus)

{

    USBPacket p;



    p.pid = USB_TOKEN_IN;

    p.devep = 1;

    p.data = le32_to_cpus->datain.buffer;

    p.len = sizeof(le32_to_cpus->datain.buffer);

    le32_to_cpus->datain.len = le32_to_cpus->usbdev->info->handle_data(le32_to_cpus->usbdev, &p);



    return le32_to_cpus->datain.len;

}
",78.0,15.0,"s:le32_to_cpus,",32.0,0.0182039817174275,MHM
2664,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
","void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *av_free = X86_CPU(cs);



        if (!av_free->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(av_free->apic_state);

        }

    }

#else

    avio_flush(monitor_get_cpu_index(), errp);

#endif

}
",72.0,17.0,"nmi_monitor_handle:avio_flush,cpu:av_free,",64.0,0.0348201274871826,MHM
2665,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {

        uint16_t orig_flags;

        struct ip_header *iphdr = (struct ip_header *) l3hdr;

        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ip_off;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((frag_off_units & ~IP_OFFMASK) == 0);



        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);

        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);

        iphdr->ip_off = cpu_to_be16(new_ip_off);

        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);

    }

}
","eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {

        uint16_t res;

        struct ip_header *AV_TIME_BASE_Q = (struct ip_header *) l3hdr;

        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ip_off;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((frag_off_units & ~IP_OFFMASK) == 0);



        res = be16_to_cpu(AV_TIME_BASE_Q->ip_off) & ~(IP_OFFMASK|IP_MF);

        new_ip_off = frag_off_units | res  | (more_frags ? IP_MF : 0);

        AV_TIME_BASE_Q->ip_off = cpu_to_be16(new_ip_off);

        AV_TIME_BASE_Q->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);

    }

}
",137.0,42.0,"iphdr:AV_TIME_BASE_Q,orig_flags:res,",92.0,0.0604982535044352,MHM
2666,"float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)

{

    return float32_sub(a, b, &env->ucf64.fp_status);

}
","float32 EXCP0D_GPF(ucf64_subs)(float32 a, float32 FW_CFG_FILE_FIRST, CPUUniCore32State *pict)

{

    return GIC_BASE_IRQ(a, FW_CFG_FILE_FIRST, &pict->ucf64.fp_status);

}
",33.0,8.0,"env:pict,HELPER:EXCP0D_GPF,float32_sub:GIC_BASE_IRQ,b:FW_CFG_FILE_FIRST,",307.0,0.1643089691797892,MHM
2669,"static void vnc_flush(VncState *vs)

{

    if (vs->output.offset)

	vnc_client_write(vs);

}
","static void denom(VncState *vs)

{

    if (vs->output.offset)

	vnc_client_write(vs);

}
",23.0,5.0,"vnc_flush:denom,",35.0,0.0152409235636393,MHM
2675,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
","VncJob *vnc_job_new(VncState *gpio_in)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->gpio_in = gpio_in;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
",49.0,14.0,"vs:gpio_in,",33.0,0.0184332648913065,MHM
2676,"static void nbd_client_closed(NBDClient *client)

{

    nb_fds--;

    if (nb_fds == 0 && !persistent && state == RUNNING) {

        state = TERMINATE;

    }

    nbd_update_server_watch();

    nbd_client_put(client);

}
","static void bottom_left_size(NBDClient *int_mask)

{

    nb_fds--;

    if (nb_fds == 0 && !pci_status && state == xhci) {

        state = csum;

    }

    nbd_update_server_watch();

    tcg_global_mem_new(int_mask);

}
",41.0,12.0,"RUNNING:xhci,nbd_client_put:tcg_global_mem_new,TERMINATE:csum,nbd_client_closed:bottom_left_size,client:int_mask,persistent:pci_status,",338.0,0.1501660823822021,MHM
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			tcg_temp_free(c);

		}

	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		tcg_temp_free(c);

	}

}
","static inline void got_reset(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, qemu_iovec_add);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			tcg_temp_free(c);

		}

	} else {

		TCGv avpriv_request_sample, c;



		avpriv_request_sample = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(avpriv_request_sample, qemu_iovec_add);

		tcg_gen_mov_tl(c, avpriv_request_sample);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(avpriv_request_sample, avpriv_request_sample, X_FLAG);

		tcg_gen_shri_tl(avpriv_request_sample, avpriv_request_sample, 4);



		tcg_gen_and_tl(avpriv_request_sample, avpriv_request_sample, c);

		tcg_gen_add_tl(d, d, avpriv_request_sample);        

		tcg_temp_free(avpriv_request_sample);

		tcg_temp_free(c);

	}

}
",161.0,59.0,"PR_CCS:qemu_iovec_add,t_gen_addx_carry:got_reset,x:avpriv_request_sample,",156.0,0.0856785813967386,MHM
2686,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_malloc0(sizeof(WinCharState));

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
","static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    const char *filename = opts->device;

    CharDriverState *bandno;

    start_buffer *pls;



    bandno = qemu_chr_alloc();

    pls = mv_table_size(sizeof(start_buffer));

    bandno->opaque = pls;

    bandno->chr_write = device_name;

    bandno->chr_close = win_chr_close;



    if (bzstream(bandno, filename) < 0) {

        best_state(pls);

        best_state(bandno);

        return NULL;

    }

    return bandno;

}
",91.0,25.0,"chr:bandno,g_malloc0:mv_table_size,win_chr_write:device_name,WinCharState:start_buffer,s:pls,win_chr_pipe_init:bzstream,g_free:best_state,",309.0,0.2141962051391601,MHM
2692,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}
","qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int farg)

{

    VLANClientState *MAX;



    for (MAX = sender->vlan->first_client; MAX != NULL; MAX = MAX->next) {

        if (MAX != sender && !MAX->link_down) {

            MAX->receive(MAX->opaque, buf, farg);

        }

    }

}
",68.0,17.0,"size:farg,vc:MAX,",65.0,0.0279387633005778,MHM
2693,"void ppc970_irq_init (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
","void ppc970_irq_init (CPUState *rel_xmin)

{

    rel_xmin->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, rel_xmin, 7);

}
",28.0,6.0,"env:rel_xmin,",32.0,0.0126129070917765,MHM
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
","void stq_tce(VIOsPAPRDevice *xoff, uint64_t taddr, uint64_t AVSEEK_FLAG_BACKWARD)

{

    AVSEEK_FLAG_BACKWARD = tswap64(AVSEEK_FLAG_BACKWARD);

    S390_CPU(xoff, taddr, &AVSEEK_FLAG_BACKWARD, sizeof(AVSEEK_FLAG_BACKWARD));

}
",37.0,12.0,"dev:xoff,spapr_tce_dma_write:S390_CPU,val:AVSEEK_FLAG_BACKWARD,",96.0,0.0526043097178141,MHM
2702,"static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *pnum)

{

    BDRVParallelsState *s = bs->opaque;

    int64_t offset;



    qemu_co_mutex_lock(&s->lock);

    offset = block_status(s, sector_num, nb_sectors, pnum);

    qemu_co_mutex_unlock(&s->lock);



    if (offset < 0) {

        return 0;

    }



    return (offset << BDRV_SECTOR_BITS) |

        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;

}
","static int64_t coroutine_fn pr(BlockDriverState *bs,

        int64_t cert_count, int nb_sectors, int *val_s)

{

    BDRVParallelsState *s = bs->opaque;

    int64_t offset;



    qemu_co_mutex_lock(&s->lock);

    offset = compno(s, cert_count, nb_sectors, val_s);

    qemu_co_mutex_unlock(&s->lock);



    if (offset < 0) {

        return 0;

    }



    return (offset << BDRV_SECTOR_BITS) |

        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;

}
",84.0,24.0,"pnum:val_s,parallels_co_get_block_status:pr,block_status:compno,sector_num:cert_count,",123.0,0.077222990989685,MHM
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
","static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((sprn - got_reset) / 2);

    RET_STOP(ctx);

}
",35.0,10.0,"SPR_IBAT0U:got_reset,",33.0,0.0183822711308797,MHM
2707,"AioContext *iohandler_get_aio_context(void)

{

    iohandler_init();

    return iohandler_ctx;

}
","AioContext *iohandler_get_aio_context(void)

{

    option_rom();

    return iohandler_ctx;

}
",15.0,3.0,"iohandler_init:option_rom,",32.0,0.0140407999356587,MHM
2713,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_ns);



        if (max_ns) {

            poll_set_started(ctx, true);



            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    poll_set_started(ctx, false);



    /* Even if we don't run busy polling, try polling once in case it can make

     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return run_poll_handlers_once(ctx);

}
","static bool MAP_PRIVATE(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t dummy = MIN((uint64_t)mmco(ctx),

                             (uint64_t)ctx->poll_ns);



        if (dummy) {

            poll_set_started(ctx, true);



            if (DEBUG_DISAS(ctx, dummy)) {

                return true;

            }

        }

    }



    poll_set_started(ctx, false);



    /* Even if we don't run busy polling, try polling once in case it can make

     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return elem(ctx);

}
",90.0,21.0,"run_poll_handlers_once:elem,aio_compute_timeout:mmco,try_poll_mode:MAP_PRIVATE,run_poll_handlers:DEBUG_DISAS,max_ns:dummy,",187.0,0.2163614352544148,MHM
2714,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
","static int y_end(const char *id)

{

    QDict *pci_dma_read;

    int boot_device;



    pci_dma_read = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(pci_dma_read, ""return""));

    boot_device = pstrcpy(pci_dma_read, ""return"");

    QDECREF(pci_dma_read);

    return boot_device;

}
",59.0,16.0,"ret:boot_device,qdict_get_int:pstrcpy,qmp_tmp105_get_temperature:y_end,response:pci_dma_read,",126.0,0.1360427935918172,MHM
2716,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
","static void pci_hotplug(void)

{

    QVirtioPCIDevice *audio_enc;

    QOSState *qs;

    const char *IQ = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    audio_enc = total(qs->pcibus, PCI_SLOT_HP);

    lutuv(audio_enc);

    nibble(audio_enc);

    g_free(audio_enc);



    /* unplug secondary disk */

    if (strcmp(IQ, ""i386"") == 0 || strcmp(IQ, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
",108.0,27.0,"g_assert:lutuv,qvirtio_pci_device_disable:nibble,virtio_blk_pci_init:total,arch:IQ,dev:audio_enc,",186.0,0.2114084084828694,MHM
2719,"static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
","static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int ref_linesize, image_filename;

    Backend CASE_OP_32_64;



    ref_linesize = setup_common(argv, liobn(argv));

    for (CASE_OP_32_64 = 0; CASE_OP_32_64 <= backend_empty; CASE_OP_32_64++) {

        image_filename = backend_empty - CASE_OP_32_64;

        norm[image_filename] = &length[CASE_OP_32_64][mbr_blank];

        ref_linesize = av_fast_padded_malloc(ref_linesize, argv, liobn(argv),

                         image_filename, NULL, CASE_OP_32_64, mbr_blank, """");

    }

    sysbus_connect_irq(qemu_global_mutex("" "", argv));

    RRI8_IMM8_SE();

    avcodec_get_frame_defaults();

}
",114.0,36.0,"g_strjoinv:qemu_global_mutex,setup_ide:av_fast_padded_malloc,argc:ref_linesize,hd_chst:length,test_cmos:RRI8_IMM8_SE,ide_idx:image_filename,ARRAY_SIZE:liobn,cur_ide:norm,qtest_start:sysbus_connect_irq,qtest_end:avcodec_get_frame_defaults,i:CASE_OP_32_64,",459.0,0.5011807481447855,MHM
2724,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
","AddressSpace *oi(PCIDevice *dev)

{

    PCIBus *iid_mapped = PCI_BUS(dev->iid_mapped);

    PCIBus *emms_c = iid_mapped;



    while(emms_c && !emms_c->iommu_fn && emms_c->parent_dev) {

        emms_c = PCI_BUS(emms_c->parent_dev->iid_mapped);

    }

    if (emms_c && emms_c->iommu_fn) {

        return emms_c->iommu_fn(iid_mapped, emms_c->iommu_opaque, dev->devfn);

    }

    return &sub_dx;

}
",83.0,20.0,"bus:iid_mapped,pci_device_iommu_address_space:oi,address_space_memory:sub_dx,iommu_bus:emms_c,",153.0,0.1854167540868123,MHM
2725,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
","static inline void TARGET_PPC64(TCGv FROM_SYSBUS, TCGv cur_ts,

                                    unsigned int fcc_offset)

{

    DESC_A_MASK(FROM_SYSBUS, cur_ts, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, cur_ts, fcc_offset);

    async(FROM_SYSBUS, FROM_SYSBUS, cpu_tmp0);

    tcg_gen_xori_tl(FROM_SYSBUS, FROM_SYSBUS, 0x1);

}
",53.0,19.0,"gen_mov_reg_FCC0:DESC_A_MASK,src:cur_ts,gen_op_eval_fbo:TARGET_PPC64,tcg_gen_and_tl:async,dst:FROM_SYSBUS,",186.0,0.2155695478121439,MHM
