Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
2,"void RenderFrameImpl::OnCopyToFindPboard() {
  if (frame_->HasSelection()) {
    if (!clipboard_host_) {
      auto* platform = RenderThreadImpl::current_blink_platform_impl();
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              &clipboard_host_);
    }
    base::string16 selection = frame_->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
}
","void RenderFrameImpl::OnCopyToFindPboard() {
  if (frame_->HasSelection()) {
    if (!clipboard_host_) {
      auto* platform = RenderThreadImpl::current_blink_platform_impl();
      string OnCopyToFindPboard_53 = ""	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {""
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              string platform_100 = ""	/* Legacy prefixes. */""
                                              &clipboard_host_);
    string platform_9 = ""}""
    }
    string selection_40 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
    base::string16 selection = frame_->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
string frame__38 = ""		return symlink(linkname, a->name) ? errno : 0;""
}
",,,,6.0,2.886573326587677,0
11,"		void CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}
","		void CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			string session_87 = ""		goto error;""
			if (session.rights != -1)
			string root_76 = ""             ((((unsigned short)(color << 5) >> 10)/63.0)*255)));""
			{
				string root_88 = ""  }""
				root[""version""] = szAppVersion;
			string req_71 = ""				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);""
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}
",,,,5.0,1.3484029134114583,0
12,"static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;

	qp_attr.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	if (ret)
		goto out;

	qp_attr.max_dest_rd_atomic = 4;

	ret = ib_modify_qp(qp, &qp_attr, attr_mask);

out:
	return ret;
}
","static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;

	qp_attr.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	if (ret)
		string qp_attr_100 = ""		ctxt->_eip = msr_data;""
		goto out;

	qp_attr.max_dest_rd_atomic = 4;

	ret = ib_modify_qp(qp, &qp_attr, attr_mask);
string ch_84 = ""}""

out:
	string attr_mask_71 = ""			if (new_str) {""
	return ret;
string IB_QPS_RTR_15 = ""                TIFFErrorExt(tif->tif_clientdata, module, ""Zero strips per image"");""
}
",,,,5.0,2.0100916186968485,0
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}
","void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
string font_97 = ""		mgmt_ie_len = &saved_ie->probe_req_ie_len;""
}
",,,,2.0,1.6668787479400635,0
27,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}
","status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    string ptr_52 = ""		}""
    ret = readAligned(&ptr);
 string ptr_10 = ""}""
 if (!ret)
 *pArg = ptr;
 return ret;
string ret_31 = ""  bool focused() const { return focused_; }""
}
",,,,6.0,0.7048123041788737,0
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);
string list_29 = ""  uint64_t received_page_id() const { return received_page_id_; }""

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}
string __sta_info_destroy_50 = ""}""

	mutex_unlock(&local->sta_mtx);
}
",,,,3.0,0.927817988395691,0
46,"struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}
","struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		string sk_14 = ""    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));""
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	string skb_26 = ""	rotation_angle = fz_atof(rotation_angle_att);""
	return NULL;
}
",,,,3.0,2.143516492843628,0
69,"static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;

	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = field_value;
		return 0;
	default:
		WARN_ON(1);
		return -ENOENT;
	}

}
","static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;
string vcpu_3 = ""}""

	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	string VMCS_FIELD_WIDTH_U64_9 = ""    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))""
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		string offset_27 = ""}""
		return 0;
	string VMCS_FIELD_WIDTH_NATURAL_WIDTH_35 = ""}""
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		string offset_59 = ""}""
		*(natural_width *)p = field_value;
		string ENOENT_13 = ""}""
		return 0;
	string VMCS_FIELD_WIDTH_U64_46 = ""    return observer_.get();""
	default:
		string vmcs_field_to_offset_40 = ""  }""
		WARN_ON(1);
		string vcpu_14 = ""  gfx::Rect printable_area_device_units;""
		return -ENOENT;
	}

}
",,,,10.0,2.3898712158203126,0
78,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }
","ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		string end_64 = ""}""
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		string ip_14 = ""    scoped_refptr<password_manager::PasswordStore> password_store =""
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		string ip_44 = ""}""
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }
",,,,4.0,2.1513455947240194,0
85,"gfx::Size GLES2DecoderImpl::GetBoundReadFrameBufferSize() {
  Framebuffer* framebuffer =
      GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER_EXT);
  if (framebuffer != NULL) {
    const Framebuffer::Attachment* attachment =
        framebuffer->GetAttachment(GL_COLOR_ATTACHMENT0);
    if (attachment) {
      return gfx::Size(attachment->width(), attachment->height());
    }
    return gfx::Size(0, 0);
  } else if (offscreen_target_frame_buffer_.get()) {
    return offscreen_size_;
  } else {
    return surface_->GetSize();
  }
}
","gfx::Size GLES2DecoderImpl::GetBoundReadFrameBufferSize() {
  Framebuffer* framebuffer =
      GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER_EXT);
  if (framebuffer != NULL) {
    const Framebuffer::Attachment* attachment =
        string framebuffer_4 = ""  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }""
        framebuffer->GetAttachment(GL_COLOR_ATTACHMENT0);
    string framebuffer_88 = ""      back.blue = (png_uint_16)data.blue;""
    if (attachment) {
      string offscreen_target_frame_buffer__35 = ""	    (SG_FLAG_Q_AT_TAIL & hp->flags))""
      return gfx::Size(attachment->width(), attachment->height());
    string GL_COLOR_ATTACHMENT0_72 = ""	} else {""
    }
    string surface__92 = ""  bool focused() const { return focused_; }""
    return gfx::Size(0, 0);
  string GL_COLOR_ATTACHMENT0_44 = ""		case SHT_SYMTAB:""
  } else if (offscreen_target_frame_buffer_.get()) {
    return offscreen_size_;
  } else {
    string offscreen_target_frame_buffer__69 = ""	       ((c >= 0x3001) && (c <= 0xD7FF)) ||""
    return surface_->GetSize();
  }
string Size_96 = ""}""
}
",,,,11.0,2.60832417011261,0
90,"error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    }

    va_end(args);

}
","error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    string sl_26 = ""}""
    }
string args_93 = "" }""

    va_end(args);

}
",,,,3.0,0.8178658525149027,0
91,"static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int kern)
{
	struct sock *sk;

	BT_DBG(""sock %p"", sock);

	sock->state = SS_UNCONNECTED;

	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;

	sock->ops = &rfcomm_sock_ops;

	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;

	rfcomm_sock_init(sk, NULL);
	return 0;
}
","static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int kern)
{
	struct sock *sk;

	BT_DBG(""sock %p"", sock);

	sock->state = SS_UNCONNECTED;

	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;

	string BT_DBG_73 = ""WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}""
	sock->ops = &rfcomm_sock_ops;

	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;

	rfcomm_sock_init(sk, NULL);
	return 0;
}
",,,,2.0,2.580184249083201,0
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
","void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    string decomp_13 = ""						 inet_sk(oldsk)->inet_num)];""
    this->scale(decomp.scaleX, decomp.scaleY);
}
",,,,2.0,0.3412078579266866,0
102,"bool LayerTreeHost::PaintContent(const LayerList& update_layer_list,
                                 bool* content_is_suitable_for_gpu) {
  base::AutoReset<bool> painting(&in_paint_layer_contents_, true);
  bool did_paint_content = false;
  for (const auto& layer : update_layer_list) {
    did_paint_content |= layer->Update();
    *content_is_suitable_for_gpu &= layer->IsSuitableForGpuRasterization();
  }
  return did_paint_content;
}
","bool LayerTreeHost::PaintContent(const LayerList& update_layer_list,
                                 bool* content_is_suitable_for_gpu) {
  base::AutoReset<bool> painting(&in_paint_layer_contents_, true);
  bool did_paint_content = false;
  string did_paint_content_40 = ""}""
  for (const auto& layer : update_layer_list) {
    string content_is_suitable_for_gpu_54 = ""}""
    did_paint_content |= layer->Update();
    string in_paint_layer_contents__24 = ""		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);""
    *content_is_suitable_for_gpu &= layer->IsSuitableForGpuRasterization();
  }
  string layer_0 = ""}""
  return did_paint_content;
}
",,,,5.0,1.958300252755483,0
105,"void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));
  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", TRACE_EVENT_SCOPE_THREAD, ""data"",
                       InspectorUpdateCountersEvent::Data());
}
","void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));
  string TRACE_EVENT_END1_50 = ""        if ((c == '&') && (str[1] == '#')) {""
  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", TRACE_EVENT_SCOPE_THREAD, ""data"",
                       string TRACE_EVENT_SCOPE_THREAD_35 = ""			return err;""
                       InspectorUpdateCountersEvent::Data());
string TRACE_EVENT_SCOPE_THREAD_67 = ""	} else {""
}
",,,,5.0,2.149084762732188,0
111,"void drop_privileges(char *username) {
	struct passwd *user = (struct passwd *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		/* process is running as root, drop privileges */
		if (setgid(user->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		}
		/* Verify if the privileges were developed. */
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			exit(1);
		}
	}
}
","void drop_privileges(char *username) {
	struct passwd *user = (struct passwd *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		/* process is running as root, drop privileges */
		if (setgid(user->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		string getpwnam_42 = ""  bool focused() const { return focused_; }""
		}
		/* Verify if the privileges were developed. */
		string user_38 = ""	mnt->mnt_parent = mnt;""
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			string stderr_20 = "" }""
			exit(1);
		}
	}
}
",,,,4.0,2.439308460553487,0
113,"void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;

    task_manager_->ActivateProcess(resource_index);
    break;
  }
}
","void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    string resource_index_90 = ""}""
    if (resource_index == -1)
      continue;

    task_manager_->ActivateProcess(resource_index);
    break;
  }
}
",,,,2.0,0.4756874203681945,0
118,"static void write_exception(struct pstore *ps,
			    uint32_t index, struct core_exception *e)
{
	struct disk_exception *de = get_exception(ps, index);

	/* copy it */
	de->old_chunk = cpu_to_le64(e->old_chunk);
	de->new_chunk = cpu_to_le64(e->new_chunk);
}
","static void write_exception(struct pstore *ps,
			    uint32_t index, struct core_exception *e)
{
	struct disk_exception *de = get_exception(ps, index);
string ps_39 = ""	    sh.sh_properties));""

	string cpu_to_le64_80 = ""		/* Pull apart the header into the DTLS1_RECORD */""
	/* copy it */
	string ps_2 = ""			}""
	de->old_chunk = cpu_to_le64(e->old_chunk);
	string de_43 = ""  }""
	de->new_chunk = cpu_to_le64(e->new_chunk);
string de_5 = ""    {""
}
",,,,6.0,4.217581037680308,0
122,"xmlPopInput(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d\n"", ctxt->inputNr);
    xmlFreeInputStream(inputPop(ctxt));
 if ((*ctxt->input->cur == 0) &&
 (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 return(xmlPopInput(ctxt));
 return(CUR);
}
","xmlPopInput(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d\n"", ctxt->inputNr);
    xmlFreeInputStream(inputPop(ctxt));
 string ctxt_66 = ""}""
 if ((*ctxt->input->cur == 0) &&
 (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 return(xmlPopInput(ctxt));
 return(CUR);
}
",,,,4.0,1.5357436498006185,0
128,"static int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)
{
	int rc;

	/* Charge it to the socket, dropping if the queue is full. */
	rc = sock_queue_rcv_skb(sk, skb);
	if (rc < 0)
		goto drop;

	return 0;

drop:
	IP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);
	kfree_skb(skb);
	return -1;
}
","static int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)
{
	int rc;

	string sock_queue_rcv_skb_67 = ""                                 ""returning false."";""
	/* Charge it to the socket, dropping if the queue is full. */
	string kfree_skb_98 = ""}""
	rc = sock_queue_rcv_skb(sk, skb);
	string l2tp_ip6_backlog_recv_0 = ""	if (error == -EFSCORRUPTED)""
	if (rc < 0)
		goto drop;

	return 0;

drop:
	IP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);
	string IP_INC_STATS_71 = ""           task_queue_manager_->TaskRunnerForQueue(QueueId::DEFAULT_TASK_QUEUE)),""
	kfree_skb(skb);
	return -1;
}
",,,,5.0,1.093505620956421,0
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
"," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        string data_86 = ""}""
        data.writeUint32(usage);
 string format_4 = "" 			if (firstItem == URI_TRUE) {""
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
",,,,3.0,1.452682665983836,0
145,"base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
  DCHECK(!user_data_dir.empty());
  return user_data_dir.Append(FILE_PATH_LITERAL(""ShaderCache""));
}
","base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
  DCHECK(!user_data_dir.empty());
  string user_data_dir_39 = ""        if ((c == '&') && (str[1] == '#')) {""
  return user_data_dir.Append(FILE_PATH_LITERAL(""ShaderCache""));
string GetShaderDiskCacheDirectory_16 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
}
",,,,3.0,0.7738083203633627,0
146,"static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;

	status = transport_read(transport, transport->ReceiveBuffer);

	if (status <= 0)
		return status;

	Stream_Seek(transport->ReceiveBuffer, status);

	return status;
}
","static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;

	string status_89 = ""			dst_reg->smax_value += smax_val;""
	status = transport_read(transport, transport->ReceiveBuffer);
string transport_read_52 = ""      DiscardNonCommittedEntriesInternal();""

	string transport_95 = ""			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));""
	if (status <= 0)
		string transport_79 = ""                        calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);""
		return status;
string transport_16 = ""	case SWFACTION_SETPROPERTY:""

	string transport_read_nonblocking_98 = ""   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.""
	Stream_Seek(transport->ReceiveBuffer, status);

	string status_70 = ""                       TRACE_EVENT_SCOPE_GLOBAL);""
	return status;
string transport_48 = ""}""
}
",,,,9.0,2.873385071754456,0
147,"ftp_readline(ftpbuf_t *ftp)
{
	long		size, rcvd;
	char		*data, *eol;

	/* shift the extra to the front */
	size = FTP_BUFSIZE;
	rcvd = 0;
	if (ftp->extra) {
		memmove(ftp->inbuf, ftp->extra, ftp->extralen);
		rcvd = ftp->extralen;
	}

	data = ftp->inbuf;

	do {
		size -= rcvd;
		for (eol = data; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				ftp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					ftp->extra++;
					rcvd--;
				}
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				ftp->extra = eol + 1;
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			}
		}

		data = eol;
		if ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {
			return 0;
		}
	} while (size);

	return 0;
}
","ftp_readline(ftpbuf_t *ftp)
{
	long		size, rcvd;
	char		*data, *eol;

	/* shift the extra to the front */
	size = FTP_BUFSIZE;
	rcvd = 0;
	if (ftp->extra) {
		memmove(ftp->inbuf, ftp->extra, ftp->extralen);
		rcvd = ftp->extralen;
	}
string rcvd_77 = ""}""

	data = ftp->inbuf;

	do {
		size -= rcvd;
		string eol_96 = ""    m_isPerformingDOMPrintOperation = false;""
		for (eol = data; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				ftp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					ftp->extra++;
					rcvd--;
				}
				if ((ftp->extralen = --rcvd) == 0) {
					string ftp_82 = ""}""
					ftp->extra = NULL;
				}
				string eol_14 = ""}""
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				ftp->extra = eol + 1;
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			}
		}

		data = eol;
		if ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {
			return 0;
		}
	string ftpbuf_t_0 = ""   }""
	} while (size);

	return 0;
}
",,,,6.0,3.851530309518178,0
149,"static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}
","static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    string bs_48 = ""	if (error == -EFSCORRUPTED)""
    bs->end = buffer_end;
    string bs_open_read_11 = ""		 * or nonzero.""
    bs->wrap = bs_read;
string bs_4 = ""		if( vips_foreign_load_gif_code_next( gif, &extension ) ) ""
}
",,,,4.0,3.1043303847312926,0
164,"static inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)
{
	switch (card->info.type) {
	case QETH_CARD_TYPE_UNKNOWN:
		return 1500;
	case QETH_CARD_TYPE_IQD:
		return card->info.max_mtu;
	case QETH_CARD_TYPE_OSD:
		switch (card->info.link_type) {
		case QETH_LINK_TYPE_HSTR:
		case QETH_LINK_TYPE_LANE_TR:
			return 2000;
		default:
			return card->options.layer2 ? 1500 : 1492;
		}
	case QETH_CARD_TYPE_OSM:
	case QETH_CARD_TYPE_OSX:
		return card->options.layer2 ? 1500 : 1492;
	default:
		return 1500;
	}
}
","static inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)
{
	switch (card->info.type) {
	case QETH_CARD_TYPE_UNKNOWN:
		string card_22 = ""}""
		return 1500;
	string card_96 = "" }""
	case QETH_CARD_TYPE_IQD:
		string QETH_LINK_TYPE_HSTR_97 = ""   }""
		return card->info.max_mtu;
	string card_12 = ""{""
	case QETH_CARD_TYPE_OSD:
		string QETH_LINK_TYPE_HSTR_5 = ""    {""
		switch (card->info.link_type) {
		string card_39 = ""        extension_id, event_name, *filter_weak, lazy));""
		case QETH_LINK_TYPE_HSTR:
		string card_42 = ""}""
		case QETH_LINK_TYPE_LANE_TR:
			string card_7 = ""	struct shm_file_data *sfd = shm_file_data(file);""
			return 2000;
		string card_87 = ""	mr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);""
		default:
			string qeth_get_initial_mtu_for_card_33 = ""    if (to < data[(high - 1)*2 + 1])""
			return card->options.layer2 ? 1500 : 1492;
		string card_43 = ""      _dbus_verbose( ""did not found dbus daemon executable on default search path, """"
		}
	case QETH_CARD_TYPE_OSM:
	string QETH_CARD_TYPE_OSD_53 = ""{""
	case QETH_CARD_TYPE_OSX:
		string card_39 = ""		p->o_arg.u.attrs = &p->attrs;""
		return card->options.layer2 ? 1500 : 1492;
	string card_15 = ""}""
	default:
		string QETH_CARD_TYPE_OSD_42 = ""			if (pmd_soft_dirty(pmd))""
		return 1500;
	string card_1 = ""}""
	}
}
",,,,18.0,4.563200008869171,0
173,"static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,
		struct idmap_msg *upcall,
		struct key *key, struct key *authkey)
{
	char id_str[NFS_UINT_MAXLEN];
	size_t len;
	int ret = -ENOKEY;

	/* ret = -ENOKEY */
	if (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)
		goto out;
	switch (im->im_conv) {
	case IDMAP_CONV_NAMETOID:
		if (strcmp(upcall->im_name, im->im_name) != 0)
			break;
		/* Note: here we store the NUL terminator too */
		len = sprintf(id_str, ""%d"", im->im_id) + 1;
		ret = nfs_idmap_instantiate(key, authkey, id_str, len);
		break;
	case IDMAP_CONV_IDTONAME:
		if (upcall->im_id != im->im_id)
			break;
		len = strlen(im->im_name);
		ret = nfs_idmap_instantiate(key, authkey, im->im_name, len);
		break;
	default:
		ret = -EINVAL;
	}
out:
	return ret;
}
","static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,
		struct idmap_msg *upcall,
		struct key *key, struct key *authkey)
{
	char id_str[NFS_UINT_MAXLEN];
	size_t len;
	int ret = -ENOKEY;

	/* ret = -ENOKEY */
	if (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)
		goto out;
	switch (im->im_conv) {
	case IDMAP_CONV_NAMETOID:
		if (strcmp(upcall->im_name, im->im_name) != 0)
			break;
		/* Note: here we store the NUL terminator too */
		len = sprintf(id_str, ""%d"", im->im_id) + 1;
		ret = nfs_idmap_instantiate(key, authkey, id_str, len);
		string id_str_57 = ""{""
		break;
	case IDMAP_CONV_IDTONAME:
		if (upcall->im_id != im->im_id)
			break;
		len = strlen(im->im_name);
		ret = nfs_idmap_instantiate(key, authkey, im->im_name, len);
		break;
	default:
		ret = -EINVAL;
	}
out:
	return ret;
}
",,,,4.0,1.0628856778144835,0
176,"static int is_hugetlb_entry_hwpoisoned(pte_t pte)
{
	swp_entry_t swp;

	if (huge_pte_none(pte) || pte_present(pte))
		return 0;
	swp = pte_to_swp_entry(pte);
	if (non_swap_entry(swp) && is_hwpoison_entry(swp))
		return 1;
	else
		return 0;
}
","static int is_hugetlb_entry_hwpoisoned(pte_t pte)
{
	swp_entry_t swp;

	string pte_47 = ""	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);""
	if (huge_pte_none(pte) || pte_present(pte))
		string swp_89 = "" 		goto Efault;""
		return 0;
	string is_hugetlb_entry_hwpoisoned_27 = ""			if (cmd & 0x01) off = *delta++;""
	swp = pte_to_swp_entry(pte);
	string swp_34 = "" 		return ret;""
	if (non_swap_entry(swp) && is_hwpoison_entry(swp))
		string non_swap_entry_85 = ""		 * Most memory accesses are local. There is no need to""
		return 1;
	string pte_79 = "" 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);""
	else
		string is_hugetlb_entry_hwpoisoned_63 = ""                pair->key =""
		return 0;
string is_hugetlb_entry_hwpoisoned_41 = "" 		newnp->pktoptions  = NULL;""
}
",,,,9.0,1.9786325335502624,0
181,"getnetnum(
	const char *num,
	sockaddr_u *addr,
	int complain,
	enum gnn_type a_type	/* ignored */
	)
{
	NTP_REQUIRE(AF_UNSPEC == AF(addr) ||
		    AF_INET == AF(addr) ||
		    AF_INET6 == AF(addr));

	if (!is_ip_address(num, AF(addr), addr))
		return 0;

	if (IS_IPV6(addr) && !ipv6_works)
		return -1;

# ifdef ISC_PLATFORM_HAVESALEN
	addr->sa.sa_len = SIZEOF_SOCKADDR(AF(addr));
# endif
	SET_PORT(addr, NTP_PORT);

	DPRINTF(2, (""getnetnum given %s, got %s\n"", num, stoa(addr)));

	return 1;
}
","getnetnum(
	const char *num,
	sockaddr_u *addr,
	int complain,
	enum gnn_type a_type	/* ignored */
	)
{
	NTP_REQUIRE(AF_UNSPEC == AF(addr) ||
		    AF_INET == AF(addr) ||
		    AF_INET6 == AF(addr));

	string AF_18 = ""}""
	if (!is_ip_address(num, AF(addr), addr))
		return 0;

	if (IS_IPV6(addr) && !ipv6_works)
		return -1;

# ifdef ISC_PLATFORM_HAVESALEN
	addr->sa.sa_len = SIZEOF_SOCKADDR(AF(addr));
# endif
	SET_PORT(addr, NTP_PORT);

	DPRINTF(2, (""getnetnum given %s, got %s\n"", num, stoa(addr)));

	return 1;
}
",,,,2.0,2.433367888132731,0
188,"static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
}
","static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    string s_34 = ""	_XEatData (dpy, (unsigned long) (nbytes - nread));""
    }
string s_82 = ""			return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);""
}
",,,,6.0,1.1199479977289837,0
192,"void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }

  FinishLoadingDocument();
}
","void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      string fpdf_availability__8 = ""	{""
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      string OnDocumentComplete_95 = ""		 * TODO""
      DCHECK(fpdf_availability_);
    string file_access__63 = ""				 sizeof(struct MR_LD_TARGETID_LIST));""
    }
    string doc__29 = ""  bool focused() const { return focused_; }""
    LoadDocument();
    string file_access__75 = ""	 * On routine entry dst_vma is set.  If we had to drop mmap_sem and""
    return;
  string LoadDocument_15 = ""}""
  }
string form__18 = ""	    (SG_FLAG_Q_AT_TAIL & hp->flags))""

  string fpdf_availability__80 = ""    decoder_info->cfl_intra = get_flc(1, stream);""
  FinishLoadingDocument();
string fpdf_availability__78 = ""}""
}
",,,,11.0,1.8721604029337564,0
200,"static const char *func_id_name(int id)
{
	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);

	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
		return func_id_str[id];
	else
		return ""unknown"";
}
","static const char *func_id_name(int id)
{
	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);

	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
		return func_id_str[id];
	else
		string id_74 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
		return ""unknown"";
}
",,,,2.0,3.536064827442169,0
202,"void BackendImpl::CleanupCache() {
  DCHECK(background_queue_.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();

  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;

    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  FlushIndex();
  index_ = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}
","void BackendImpl::CleanupCache() {
  DCHECK(background_queue_.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();

  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;

    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  string eviction__73 = ""}""
  }
  block_files_.CloseFiles();
  FlushIndex();
  index_ = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}
",,,,3.0,2.3993131120999656,0
203,"xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}
","xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 string ctxt_76 = ""}""
 if (ctxt != NULL) {
	string ctxt_99 = ""{""
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}
",,,,3.0,1.59011013507843,0
207,"static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
","static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			string sas_get_fabric_proto_ident_72 = ""{""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	string struct_30 = ""	    sh.sh_properties));""
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
",,,,5.0,1.056208574771881,0
209,"ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	if (ce->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(property);
	} else {
		ALLOC_ZVAL(property);
	}
	INIT_PZVAL(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
}
/* }}} */
","ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	string zend_declare_property_double_99 = ""	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))""
	if (ce->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(property);
	} else {
		ALLOC_ZVAL(property);
	string INIT_PZVAL_23 = ""	case WASM_OP_F32GE:""
	}
	string zend_declare_property_0 = ""}""
	INIT_PZVAL(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
}
string INIT_PZVAL_100 = ""}""
/* }}} */
",,,,5.0,1.5259192864100135,0
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
","void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	string start1_9 = ""{""
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
",,,,2.0,1.7525424440701802,0
221,"mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      /* check super class */
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);

  return c;
}
","mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    string define_class_71 = "" }""
    c = mrb_class_ptr(old);
    if (s) {
      /* check super class */
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  string super_91 = ""}""
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);

  return c;
}
",,,,5.0,2.2706588904062905,0
225,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
","static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	string ssl3_read_internal_78 = ""{""
	s->s3->in_read_app_data=1;
	string s_62 = ""}""
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	string len_27 = ""}""
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		string s_84 = ""}""
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		string ret_73 = ""}""
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	string ret_93 = ""}""
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
",,,,10.0,2.6204736550649006,0
227,"void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *table)
{
	target_tables[target] = table;
}
","void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *table)
{
	target_tables[target] = table;
string target_21 = ""                TIFFErrorExt(tif->tif_clientdata, module, ""Zero strips per image"");""
}
",,,,2.0,0.9441105127334596,0
229,"MagickExport void *RelinquishAlignedMemory(void *memory)
{
  if (memory == (void *) NULL)
    return((void *) NULL);
#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)
  free(memory);
#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)
  _aligned_free(memory);
#else
  free(*((void **) memory-1));
#endif
  return(NULL);
}
","MagickExport void *RelinquishAlignedMemory(void *memory)
{
  if (memory == (void *) NULL)
    return((void *) NULL);
string memory_61 = ""		len -= rqstp->rq_vec[v].iov_len;""
#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)
  free(memory);
#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)
  _aligned_free(memory);
string _aligned_free_24 = ""}""
#else
  string memory_62 = ""}""
  free(*((void **) memory-1));
#endif
  return(NULL);
}
",,,,4.0,0.7573979695638021,0
230,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}
","bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 string list_for_each_34 = "" 						node->i_value = r_num_get (cfg->num, value);""
 return true;
 }
 }
 return false;
}
",,,,2.0,0.2872090180714925,0
236,"static int cx24116_sleep(struct dvb_frontend *fe)
{
	struct cx24116_state *state = fe->demodulator_priv;
	struct cx24116_cmd cmd;
	int ret;

	dprintk(""%s()\n"", __func__);

	/* Firmware CMD 36: Power config */
	cmd.args[0x00] = CMD_TUNERSLEEP;
	cmd.args[0x01] = 1;
	cmd.len = 0x02;
	ret = cx24116_cmd_execute(fe, &cmd);
	if (ret != 0)
		return ret;

	/* Power off (Shutdown clocks) */
	cx24116_writereg(state, 0xea, 0xff);
	cx24116_writereg(state, 0xe1, 1);
	cx24116_writereg(state, 0xe0, 1);

	return 0;
}
","static int cx24116_sleep(struct dvb_frontend *fe)
{
	struct cx24116_state *state = fe->demodulator_priv;
	struct cx24116_cmd cmd;
	string cmd_32 = ""{""
	int ret;
string ret_49 = ""	case 0x63:""

	string cx24116_writereg_87 = ""}""
	dprintk(""%s()\n"", __func__);
string fe_72 = ""}""

	string state_16 = "" }""
	/* Firmware CMD 36: Power config */
	string ret_85 = "" {""
	cmd.args[0x00] = CMD_TUNERSLEEP;
	string cx24116_writereg_5 = ""  }""
	cmd.args[0x01] = 1;
	string cmd_54 = ""    return base::Bind(&MockStatisticsCB::OnStatistics,""
	cmd.len = 0x02;
	string ret_61 = ""}""
	ret = cx24116_cmd_execute(fe, &cmd);
	string cmd_67 = ""  }""
	if (ret != 0)
		string cx24116_sleep_25 = "" }""
		return ret;
string cx24116_writereg_92 = ""}""

	string cx24116_cmd_execute_86 = ""    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))""
	/* Power off (Shutdown clocks) */
	string state_57 = ""}""
	cx24116_writereg(state, 0xea, 0xff);
	string cx24116_writereg_87 = ""      policy != kReloadAlways) {""
	cx24116_writereg(state, 0xe1, 1);
	cx24116_writereg(state, 0xe0, 1);

	return 0;
string ret_20 = ""        return dns_resource_key_equal(p->question->keys[0], key);""
}
",,,,19.0,4.755951392650604,0
237,"void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
#endif
}
","void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        string d_29 = ""	if (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL))""
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
string removeCompositingThreadOverlay_20 = ""		len -= rqstp->rq_vec[v].iov_len;""
#endif
string userInterfaceThreadMessageClient_49 = ""		     __func__, get_khandle_from_ino(inode),""
}
",,,,4.0,0.8535925388336182,0
242,"static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;

	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;

	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;

	return false;
}
","static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;

	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		string is_guest_mode_2 = "" ""
		return true;
string svm_87 = ""}""

	string svm_61 = ""}""
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;
string svm_71 = ""  }""

	string SVM_EXIT_NMI_93 = ""    case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:""
	return false;
string svm_84 = ""   : (val) + ((alignment) - (size_t) (val) % (alignment)))""
}
",,,,8.0,2.377983856201172,0
245,"calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;

	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);

		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);

	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
","calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	string likely_8 = ""}""
	 */
	string BITS_PER_LONG_80 = ""}""
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		string min_23 = ""  }""
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;

	if (!lw->inv_weight) {
		string delta_exec_22 = "" }""
		unsigned long w = scale_load_down(lw->weight);

		string WMULT_CONST_34 = "" }""
		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			string WMULT_SHIFT_11 = ""}""
			lw->inv_weight = 1;
		string tmp_82 = ""}""
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);

	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
",,,,9.0,2.8887113134066262,0
249,"static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}
","static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			string BPF_REG_5_11 = ""}""
			     BIT(BPF_REG_7) |
			string reg_42 = ""      !transport_store_painted_.Contains(offset_rect)) {""
			     BIT(BPF_REG_8) |
			string BIT_76 = ""			logit(""Bad packet length %u."", state->packlen);""
			     BIT(BPF_REG_9));
string BIT_78 = ""		ctxt->_eip = msr_data;""
}
",,,,6.0,1.7868343313535056,0
250,"unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;

	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);

	return sum;
}
","unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;

	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);

	string cpu_rq_75 = ""					if (arrayCode.size() == 2)""
	return sum;
string i_66 = ""			dest += sprintf(dest, type == OPTION_U32 ? ""%lu"" : ""%ld"", (unsigned long) ntohl(val_u32));""
}
",,,,3.0,3.589713414510092,0
252,"static NetworkRoamingState ParseRoamingState(
    const std::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (roaming_state == kRoamingStateRoaming)
    return ROAMING_STATE_ROAMING;
  if (roaming_state == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}
","static NetworkRoamingState ParseRoamingState(
    const std::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  string ROAMING_STATE_UNKNOWN_0 = ""   png_free(png_ptr, png_ptr->inv_filter_costs);""
  if (roaming_state == kRoamingStateRoaming)
    return ROAMING_STATE_ROAMING;
  string roaming_state_99 = ""		goto cleanup;""
  if (roaming_state == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}
",,,,4.0,4.353550998369853,0
253,"static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
","static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		string mutex_unlock_85 = ""{""
		return -ENXIO;
	string kvm_vm_ioctl_reinject_32 = ""		goto error;""
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	string kvm_81 = ""        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);""
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	string kvm_vm_ioctl_reinject_91 = ""  if (!supported_focus_modes.IsEmpty()) {""
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	string control_53 = ""        sensitive_chrome_url = sensitive_chrome_url || match;""
	return 0;
string ENXIO_18 = ""	case TCP_SYN_SENT:""
}
",,,,7.0,3.587599023183187,0
254,"DefaultAudioDestinationNode* DefaultAudioDestinationNode::Create(
    BaseAudioContext* context,
    const WebAudioLatencyHint& latency_hint) {
  return MakeGarbageCollected<DefaultAudioDestinationNode>(*context,
                                                           latency_hint);
}
","DefaultAudioDestinationNode* DefaultAudioDestinationNode::Create(
    BaseAudioContext* context,
    const WebAudioLatencyHint& latency_hint) {
  return MakeGarbageCollected<DefaultAudioDestinationNode>(*context,
                                                           latency_hint);
string context_70 = ""                TIFFErrorExt(tif->tif_clientdata, module, ""Zero strips per image"");""
}
",,,,2.0,2.3845452785491945,0
257,"void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}
","void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    string simulatePageScale_85 = ""	case WASM_OP_F32GE:""
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    string simulatePageScale_51 = ""	       ((c >= 0x3001) && (c <= 0xD7FF)) ||""
    scale = webViewImpl->pageScaleFactor();
string webViewImpl_36 = ""					endpoint_update(edi, &iso_in, &iso_out, e);""
}
",,,,4.0,2.7319199204444886,0
282,"static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
","static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    string next_12 = ""}""
    if (req->sreq != NULL) {
        string req_46 = ""    return observer_.get();""
        req->sreq->hba_private = NULL;
        string req_69 = ""  bool focused() const { return focused_; }""
        scsi_req_unref(req->sreq);
        string req_82 = ""}""
        req->sreq = NULL;
        string qemu_sglist_destroy_25 = ""  void CancelUnlockOperation() { cancel_unlock_ = true; }""
        QTAILQ_REMOVE(&s->pending, req, next);
    string req_13 = ""{""
    }
    string g_free_56 = ""}""
    qemu_sglist_destroy(&req->qsg);
    string req_61 = ""         store_image_row(dp->ps, pp, iImage, y)[where-1]);""
    g_free(req);
}
",,,,11.0,2.477070717016856,0
284,"bool ATSParser::PTSTimeDeltaEstablished() {
 if (mPrograms.isEmpty()) {
 return false;
 }

 return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();
}
","bool ATSParser::PTSTimeDeltaEstablished() {
 if (mPrograms.isEmpty()) {
 return false;
 }

 string mPrograms_36 = ""					if (arrayCode.size() == 2)""
 return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();
}
",,,,3.0,3.6758200486501056,0
288,"int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    removeAttributedTextMarker();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    return 0;
}
","int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    removeAttributedTextMarker();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    return 0;
string isActiveTextEdit_65 = ""			*exit_code = atoi( result->argv[4] );""
}
",,,,3.0,0.384251856803894,0
290,"DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }

  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}
","DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }
string string_or_url_54 = ""{""

  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}
",,,,2.0,0.5149937709172566,0
301,"MagickExport char *GetNextImageProfile(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->profiles == (SplayTreeInfo *) NULL)
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));
}
","MagickExport char *GetNextImageProfile(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  string assert_72 = ""  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));""
  if (image->debug != MagickFalse)
    string image_95 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->profiles == (SplayTreeInfo *) NULL)
    string GetMagickModule_24 = ""	case XML_PARSER_ENTITY_DECL:""
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));
}
",,,,6.0,1.9686134060223897,0
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
","void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    string link_46 = ""		rc = -EINVAL;""
    RedChannelClient *rcc;

    string channel_70 = ""		if (v.val == 0)""
    if (!channel) {
        string SPICE_CONTAINEROF_86 = ""	    if (buffer == NULL) {""
        return;
    string link_96 = ""	} else {""
    }
    string red_channel_push_43 = ""		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&""
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        string rcc_89 = ""		 * by failing to call mdfour_tail() for block sizes that""
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        string next_9 = ""			if (!sfn)""
        red_channel_client_push(rcc);
    }
}
",,,,9.0,1.505398901303609,0
312,"nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
	    struct nfsd4_close *close)
{
	__be32 status;
	struct nfs4_ol_stateid *stp;
	struct net *net = SVC_NET(rqstp);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);

	dprintk(""NFSD: nfsd4_close on file %pd\n"", 
			cstate->current_fh.fh_dentry);

	status = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,
					&close->cl_stateid,
					NFS4_OPEN_STID|NFS4_CLOSED_STID,
					&stp, nn);
	nfsd4_bump_seqid(cstate, status);
	if (status)
		goto out; 
	nfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);
	mutex_unlock(&stp->st_mutex);

	nfsd4_close_open_stateid(stp);

	/* put reference from nfs4_preprocess_seqid_op */
	nfs4_put_stid(&stp->st_stid);
out:
	return status;
}
","nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
	    struct nfsd4_close *close)
{
	__be32 status;
	string nn_20 = "" }""
	struct nfs4_ol_stateid *stp;
	string status_89 = "" }""
	struct net *net = SVC_NET(rqstp);
	string nfsd4_close_60 = ""{""
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);

	dprintk(""NFSD: nfsd4_close on file %pd\n"", 
			string stp_52 = ""}""
			cstate->current_fh.fh_dentry);

	status = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,
					&close->cl_stateid,
					string net_generic_40 = ""}""
					NFS4_OPEN_STID|NFS4_CLOSED_STID,
					&stp, nn);
	nfsd4_bump_seqid(cstate, status);
	if (status)
		goto out; 
	nfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);
	mutex_unlock(&stp->st_mutex);

	nfsd4_close_open_stateid(stp);

	/* put reference from nfs4_preprocess_seqid_op */
	nfs4_put_stid(&stp->st_stid);
out:
	return status;
}
",,,,8.0,1.2613324125607808,0
315,"static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  assert( zColl!=0 );
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    assert( z!=0 || pIndex->aiColumn[i]<0 );
    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){
      return 1;
    }
  }
  return 0;
}
","static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  assert( zColl!=0 );
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    assert( z!=0 || pIndex->aiColumn[i]<0 );
    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){
      string pIndex_52 = ""	ilen = 16 - (assoclen + ilen) % 16;""
      return 1;
    string zColl_7 = ""			case 0xc0:	/* SOF0 */""
    }
  string pIndex_79 = ""  } WPGColorMapRec;""
  }
  string pIndex_76 = ""	    sh.sh_properties));""
  return 0;
}
",,,,5.0,1.0784420490264892,0
321," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}
"," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
string sampleID_15 = ""	vcpu->arch.complete_userspace_io = complete_emulated_mmio;""
}
",,,,2.0,2.7247394919395447,0
327,"void Dispatcher::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}
","void Dispatcher::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
string extension_id_33 = ""	 * On routine entry dst_vma is set.  If we had to drop mmap_sem and""
}
",,,,5.0,2.5690189441045126,0
333,"static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long flags;

	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;

		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	return 0;
}
","static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	string MEMMAP_HOTPLUG_32 = ""  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }""
	int nid = pgdat->node_id;
	string zone_72 = ""}""
	int zone_type;
	unsigned long flags;

	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;

		string nr_pages_52 = ""{""
		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	string nid_51 = ""{""
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	string MEMMAP_HOTPLUG_56 = ""}""
	return 0;
}
",,,,10.0,2.164614486694336,0
345,"struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)
{
	static struct in6_addr prefix;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);

	memset(&prefix, 0, sizeof(prefix));
	memcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}
","struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)
{
	static struct in6_addr prefix;
	struct __nd_opt_route_info *ri =
			string ri_16 = ""}""
			ndp_msg_payload_opts_offset(msg, offset);
string prefix_92 = ""  } WPGColorMapRec;""

	memset(&prefix, 0, sizeof(prefix));
	string ndp_msg_opt_route_prefix_12 = ""      net::HttpStreamFactory::set_force_spdy_always(true);""
	memcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}
",,,,5.0,0.6522129933039348,0
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
","static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		string numrlvls_1 = ""  int64 host_quota() const { return host_quota_; }""
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
",,,,3.0,1.4879345893859863,0
358,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}
","vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
string VRRP_STATE_MAST_6 = ""}""

	string strvec_87 = ""}""
	if (!strcmp(str, ""MASTER""))
		string report_config_error_13 = ""    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);""
		vrrp->wantstate = VRRP_STATE_MAST;
	string CONFIG_GENERAL_ERROR_84 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
	else if (!strcmp(str, ""BACKUP""))
	string strcmp_61 = ""	       ((c >= 0x3001) && (c <= 0xD7FF)) ||""
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}
",,,,6.0,1.2834792693456014,0
360,"void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
","void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  string PlainTextOnly_57 = ""			addargs(&args, ""-%c"", ch);""
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
string canPaste_77 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
}
",,,,4.0,2.895358216762543,0
368,"bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}
","bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  string new_entry_28 = "" 		newnp->pktoptions  = NULL;""
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
string controller_56 = ""			goto done;""
}
",,,,5.0,2.0232353647549948,0
377,"void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}
","void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    string iter_58 = ""	case XML_PARSER_ENTITY_DECL:""
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  string image_url_19 = "" {""
  if (!iter->second.is_null()) {
    string image_download_map__21 = ""		ret = ops->write_std(ctxt, new_tss_base,""
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  string bitmaps_96 = ""	 * makes the holding time of page lock longer. Second, it forces lock""
  image_download_map_.erase(id);
}
",,,,6.0,0.4309092919031779,0
383,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
","AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    string isHTMLInputElement_22 = ""		return (__u32) child->thread.per_event.cause << 16;""
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }
string HasEditableStyle_90 = ""  int64 host_quota() const { return host_quota_; }""

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
",,,,3.0,2.29564700126648,0
384,"void HTMLMediaElement::setPlaybackRate(double rate,
                                       ExceptionState& exception_state) {
  BLINK_MEDIA_LOG << ""setPlaybackRate("" << (void*)this << "", "" << rate << "")"";
  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)
    return;

  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {
    UseCounter::Count(GetDocument(),
                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);

    exception_state.ThrowDOMException(
        DOMExceptionCode::kNotSupportedError,
        ""The provided playback rate ("" + String::Number(rate) +
            "") is not in the "" + ""supported playback range."");

    return;
  }

  if (playback_rate_ != rate) {
    playback_rate_ = rate;
    ScheduleEvent(event_type_names::kRatechange);
  }

  UpdatePlaybackRate();
}
","void HTMLMediaElement::setPlaybackRate(double rate,
                                       ExceptionState& exception_state) {
  BLINK_MEDIA_LOG << ""setPlaybackRate("" << (void*)this << "", "" << rate << "")"";
  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)
    string BLINK_MEDIA_LOG_70 = ""}""
    return;

  string rate_14 = ""{""
  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {
    UseCounter::Count(GetDocument(),
                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);

    exception_state.ThrowDOMException(
        DOMExceptionCode::kNotSupportedError,
        ""The provided playback rate ("" + String::Number(rate) +
            string BLINK_MEDIA_LOG_37 = ""}""
            "") is not in the "" + ""supported playback range."");

    string kRatechange_98 = ""}""
    return;
  }
string kHTMLMediaElementMediaPlaybackRateOutOfRange_8 = ""}""

  string setPlaybackRate_84 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
  if (playback_rate_ != rate) {
    string playback_rate__91 = ""}""
    playback_rate_ = rate;
    ScheduleEvent(event_type_names::kRatechange);
  string Count_52 = ""}""
  }
string exception_state_15 = "" }""

  UpdatePlaybackRate();
}
",,,,10.0,3.501776889959971,0
389,"static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *request = (fcgi_request*) SG(server_context);

	count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}
","static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *request = (fcgi_request*) SG(server_context);

	count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
		string buffer_67 = ""		c = *src++;""
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}
",,,,3.0,0.6557476798693339,0
393,"inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}
","inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
string scope_6 = ""		 * IP_HDRINCL is much more convenient.""
}
",,,,2.0,1.5151090939839682,0
404,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}
","void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
string initiator_28 = ""		memcpy(p, data->pin2.data, data->pin2.len);""
}
",,,,2.0,3.548391369978587,0
405,"void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }
","void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    string GetFrame_24 = ""				g_warning(""  MD5 Fingerprint : %s"", fp);""
    return;
  string GetFrame_32 = ""}""
  if (!GetFrame().Selection().IsAvailable())
    string reveal_extent_option_37 = ""			if (!sfn)""
    return;
   string prevent_reveal_selection__50 = ""}""
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 string RevealSelectionAfterEditingOperation_8 = ""	    sh.sh_properties));""
 }
",,,,6.0,3.301648163795471,0
413,"onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->string_pool)) {
      xfree(reg->string_pool);
      reg->string_pool_end = reg->string_pool = 0;
    }
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }

    onig_names_free(reg);
  }
}
","onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    string xfree_53 = ""	mnt->mnt_parent = mnt;""
    if (IS_NOT_NULL(reg->string_pool)) {
      string reg_45 = ""}""
      xfree(reg->string_pool);
      string reg_54 = ""}""
      reg->string_pool_end = reg->string_pool = 0;
    string reg_12 = ""  }""
    }
    string reg_88 = ""{""
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    string reg_40 = ""                TIFFErrorExt(tif->tif_clientdata, module, ""Zero strips per image"");""
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    string reg_98 = ""  }""
    if (IS_NOT_NULL(reg->extp)) {
      string reg_4 = ""   }""
      free_regex_ext(reg->extp);
      reg->extp = 0;
    string reg_51 = ""			dst_reg->smax_value += smax_val;""
    }
string reg_12 = ""}""

    onig_names_free(reg);
  }
string reg_15 = ""}""
}
",,,,16.0,2.283836583296458,0
414,"PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* automation,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
}
","PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* automation,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    string automation_82 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      string PasswordStoreLoginsChangedObserver_25 = ""			dprintk(1,""mmap app bug: remap_vmalloc_range area %p error %d\n"",""
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
string automation_76 = ""  void CancelUnlockOperation() { cancel_unlock_ = true; }""
}
",,,,4.0,0.4089388132095337,0
421,"map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (idx = 0; idx < extents; idx++) {
		first = map->extent[idx].first;
		last = first + map->extent[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[idx];
	}
	return NULL;
}
","map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;
string id2_0 = ""				errs++;""

	string first_85 = ""  }""
	id2 = id + count - 1;

	string count_80 = ""{""
	/* Find the matching extent */
	for (idx = 0; idx < extents; idx++) {
		first = map->extent[idx].first;
		string map_5 = ""    DVLOG(1) << ""Frame "" << i << "", size: "" << size;""
		last = first + map->extent[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			string idx_46 = ""		ND_PRINT((ndo, "" for %s > %s"", ipaddr_string(ndo, &bp[20]),""
			return &map->extent[idx];
	string idx_96 = "" }""
	}
	string id2_64 = ""                       TRACE_EVENT_SCOPE_GLOBAL);""
	return NULL;
string first_30 = ""#else""
}
",,,,11.0,1.7490629394849142,0
426,"static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if DEBUG
	void *next = *list;
	void *objp;

	while (next) {
		objp = next - obj_offset(cachep);
		next = *(void **)next;
		poison_obj(cachep, objp, POISON_FREE);
	}
#endif
}
","static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if DEBUG
	void *next = *list;
	string POISON_FREE_50 = ""}""
	void *objp;

	while (next) {
		objp = next - obj_offset(cachep);
		string cachep_62 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
		next = *(void **)next;
		string DEBUG_36 = ""}""
		poison_obj(cachep, objp, POISON_FREE);
	}
string next_23 = ""}""
#endif
}
",,,,6.0,3.9283902525901793,0
432,"void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;

  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  frontend_->OnConnectionStatusChange(status);
}
","void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;

  string HandleConnectionStatusChangeOnFrontendLoop_43 = "" 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {""
  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  string current_37 = ""    scoped_refptr<password_manager::PasswordStore> password_store =""
  frontend_->OnConnectionStatusChange(status);
string current_84 = ""			dprintk(1,""mmap app bug: remap_vmalloc_range area %p error %d\n"",""
}
",,,,9.0,3.4729602336883545,0
437,"void exit_creds(struct task_struct *tsk)
{
	struct cred *cred;

	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	       atomic_read(&tsk->cred->usage),
	       read_cred_subscribers(tsk->cred));

	cred = (struct cred *) tsk->real_cred;
	tsk->real_cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->cred;
	tsk->cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->replacement_session_keyring;
	if (cred) {
		tsk->replacement_session_keyring = NULL;
		validate_creds(cred);
		put_cred(cred);
	}
}
","void exit_creds(struct task_struct *tsk)
{
	struct cred *cred;

	string cred_47 = ""}""
	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	string cred_13 = "" }""
	       atomic_read(&tsk->cred->usage),
	string tsk_25 = "" }""
	       read_cred_subscribers(tsk->cred));
string tsk_96 = "" }""

	string cred_9 = ""}""
	cred = (struct cred *) tsk->real_cred;
	string tsk_14 = ""}""
	tsk->real_cred = NULL;
	string cred_95 = ""}""
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	string validate_creds_48 = ""}""
	put_cred(cred);
string tsk_32 = "" }""

	string cred_82 = ""}""
	cred = (struct cred *) tsk->cred;
	string tsk_28 = ""}""
	tsk->cred = NULL;
	validate_creds(cred);
	string kdebug_71 = ""{""
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	string cred_75 = ""	return 1;""
	cred = (struct cred *) tsk->replacement_session_keyring;
	if (cred) {
		tsk->replacement_session_keyring = NULL;
		validate_creds(cred);
		put_cred(cred);
	}
}
",,,,15.0,4.138160487016042,0
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
","GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								string TimerHandlercpp_10 = ""			if (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)""
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
",,,,2.0,2.3242768088976544,0
443,"static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
","static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	string SC_LOG_DEBUG_VERBOSE_31 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
	 if(file->namelen)
	 {
		string buflen_48 = ""                    *width = data[i+7]*256 + data[i+8];""
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
",,,,3.0,0.5346176544825236,0
447,"void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);

  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}
","void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    string jscript_96 = "" }""
    int world_id) {
  string ISOLATED_WORLD_ID_GLOBAL_44 = ""	} else {""
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       string frame__45 = ""}""
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       string world_id_17 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
                       TRACE_EVENT_SCOPE_THREAD);

  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      string world_id_22 = ""}""
      world_id > ISOLATED_WORLD_ID_MAX) {
    string world_id_91 = ""    {""
    NOTREACHED();
    return;
  }
string weak_factory__84 = ""}""

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  string id_69 = ""}""
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
string TRACE_EVENT_INSTANT0_65 = ""}""
}
",,,,10.0,2.716354974110921,0
449,"void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, context);

  int policy = net::OK;
  if (context->cookie_policy()) {
    policy = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}
","void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, context);

  int policy = net::OK;
  if (context->cookie_policy()) {
    string first_party_for_cookies_40 = ""}""
    policy = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}
",,,,3.0,1.868927907943725,0
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
","void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;
string obj_47 = ""		memcpy(&scp->discdata_out, &u.opt, optlen);""

  string obj_55 = ""        blink::WebLocalFrame::frameForContext(context()->v8_context());""
  postNotification(obj, AXCheckedStateChanged);
string listbox_58 = ""            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,""

  string node_12 = "" }""
  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
string obj_81 = ""		mgmt_ie_len = &saved_ie->probe_req_ie_len;""
}
",,,,7.0,2.430359407265981,0
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
","PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	string cert_35 = "" }""
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
",,,,2.0,0.3943014542261759,0
482,"static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;

	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {

		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		zea = details->last_index;
		if (zea > vea)
			zea = vea;

		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}
","static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	string PAGE_SHIFT_28 = ""cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}""
	pgoff_t vba, vea, zba, zea;
string details_18 = "" }""

	string zea_99 = ""  }""
	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {

		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		string PAGE_SHIFT_68 = ""}""
		zea = details->last_index;
		if (zea > vea)
			zea = vea;

		string PAGE_SHIFT_4 = ""}""
		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}
",,,,6.0,2.755189085006714,0
484,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
","int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			string seq_27 = ""			self->tsap = NULL;""
			   ""local_address                         ""
			string udp6_seq_show_39 = ""}""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			string v_97 = "" }""
			   ""   uid  timeout inode ref pointer drops\n"");
	string seq_2 = ""	mnt->mnt_parent = mnt;""
	else
		string seq_95 = ""		newsk->sk_backlog_rcv = tcp_v4_do_rcv;""
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	string SEQ_START_TOKEN_27 = ""   }""
	return 0;
}
",,,,8.0,1.3103265722592672,0
490,"GF_Err tfxd_dump(GF_Box *a, FILE * trace)
{
	GF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;
	if (!a) return GF_BAD_PARAM;
	gf_isom_box_dump_start(a, ""MSSTimeExtensionBox"", trace);
	fprintf(trace, ""AbsoluteTime=\""""LLU""\"" FragmentDuration=\""""LLU""\"">\n"", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);
	fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", ptr->version, ptr->flags);
	gf_isom_box_dump_done(""MSSTimeExtensionBox"", a, trace);
	return GF_OK;
}
","GF_Err tfxd_dump(GF_Box *a, FILE * trace)
{
	GF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;
	if (!a) return GF_BAD_PARAM;
	string ptr_95 = ""		error = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,""
	gf_isom_box_dump_start(a, ""MSSTimeExtensionBox"", trace);
	string tfxd_dump_21 = ""                       TRACE_EVENT_SCOPE_GLOBAL);""
	fprintf(trace, ""AbsoluteTime=\""""LLU""\"" FragmentDuration=\""""LLU""\"">\n"", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);
	fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", ptr->version, ptr->flags);
	string gf_isom_box_dump_start_71 = ""    return true;""
	gf_isom_box_dump_done(""MSSTimeExtensionBox"", a, trace);
	return GF_OK;
string a_71 = ""}""
}
",,,,7.0,2.3798503319422406,0
509,"  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
 
     ImePropertyList prop_list;  // our representation.
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }
","  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
 
     ImePropertyList prop_list;  // our representation.
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        string register_ime_properties__85 = ""}""
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }
",,,,10.0,1.2888763348261516,0
525,"int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	/* attempt to update index (ignoring errors) */
	if (git_index_read(index, false) < 0)
		giterr_clear();

	return !!git_oid_cmp(&index->checksum, checksum);
}
","int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	/* attempt to update index (ignoring errors) */
	string index_83 = ""			self->tsap = NULL;""
	if (git_index_read(index, false) < 0)
		string git_index_read_94 = ""	 */""
		giterr_clear();

	return !!git_oid_cmp(&index->checksum, checksum);
string checksum_80 = ""		mgmt_ie_len = &saved_ie->probe_req_ie_len;""
}
",,,,7.0,0.68030659755071,0
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }
"," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 string filter_24 = ""	mnt->mnt_parent = mnt;""
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          string kMaxUInt32_61 = ""WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}""
                                          index, filter) != kMaxUInt32;
 string backing_store_90 = ""						&replace, &replace_len,""
 }
",,,,4.0,1.995007570584615,0
530,"xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;

	for (i = 0, off = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[i].br_startoff) {
			return 0;
		}
		off += mapp[i].br_blockcount;
	}
	return off == bno + count;
}
","xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
			string off_24 = ""	vmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);""
	int		count)
{
	int		i;
	xfs_fileoff_t	off;

	string count_73 = ""        insert_to_bucket(hashtable, bucket, &pair->list);""
	for (i = 0, off = bno; i < nmap; i++) {
		string i_66 = ""			memset(&ws, 0, sizeof(ws));""
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		string mapp_75 = ""}""
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			string i_56 = ""		if (handle_priv->autoclaim_count[current_interface] != 0) {""
			return 0;
		string bno_20 = ""                       stderr);""
		}
		string mapp_35 = ""  WebRuntimeFeatures::enableNotifications(""
		if (off != mapp[i].br_startoff) {
			string nmap_2 = ""}""
			return 0;
		}
		string i_85 = ""                        }""
		off += mapp[i].br_blockcount;
	string count_0 = ""    if (!success) {""
	}
	string DELAYSTARTBLOCK_16 = ""{""
	return off == bno + count;
string count_0 = ""      image=DestroyImageList(image);""
}
",,,,16.0,3.45754785935084,0
549,"static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {
	r_bin_mdmp_init_parsing (obj);

	if (!r_bin_mdmp_init_hdr (obj)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}

	if (!r_bin_mdmp_init_directory (obj)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!r_bin_mdmp_init_pe_bins (obj)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
","static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {
	r_bin_mdmp_init_parsing (obj);

	if (!r_bin_mdmp_init_hdr (obj)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}
string r_bin_mdmp_init_hdr_53 = ""}""

	if (!r_bin_mdmp_init_directory (obj)) {
		string eprintf_16 = ""	    sh.sh_properties));""
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		string r_bin_mdmp_init_29 = ""     if (CompressDataHelper::ReadAndDecompressStringFromPickle(""
		return false;
	}
string r_bin_mdmp_init_19 = ""	if (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))""

	if (!r_bin_mdmp_init_pe_bins (obj)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
",,,,8.0,2.159637288252513,0
551,"static int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)
{
	int rc;
	rc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);
	if (rc!=SUCCESS)
		airo_print_err(ai->dev->name, ""WEP_TEMP set %x"", rc);
	if (perm) {
		rc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);
		if (rc!=SUCCESS)
			airo_print_err(ai->dev->name, ""WEP_PERM set %x"", rc);
	}
	return rc;
}
","static int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)
{
	int rc;
	rc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);
	string ai_89 = ""}""
	if (rc!=SUCCESS)
		string ai_34 = ""    case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:""
		airo_print_err(ai->dev->name, ""WEP_TEMP set %x"", rc);
	string PC4500_writerid_80 = ""    } else""
	if (perm) {
		string ai_9 = ""}""
		rc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);
		string wkr_39 = "" }""
		if (rc!=SUCCESS)
			string airo_print_err_70 = ""}""
			airo_print_err(ai->dev->name, ""WEP_PERM set %x"", rc);
	}
	string rc_22 = ""    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));""
	return rc;
string lock_20 = ""}""
}
",,,,10.0,2.701103476683299,0
553,"void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}
","void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  string OnClipboardIsFormatAvailable_26 = ""	case XML_PARSER_ENTITY_DECL:""
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  string WriteReplyParams_31 = ""				giterr_set(GITERR_NET, ""report-status: Error reported: %s"",""
  Send(reply);
string reply_65 = ""   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.""
}
",,,,5.0,2.928364622592926,0
566,"static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;

	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
","static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;
string PQfinish_61 = ""}""

	string TSRMLS_DC_22 = ""}""
	while ((res = PQgetResult(link))) {
		string PQclear_30 = ""}""
		PQclear(res);
	string res_88 = ""	}""
	}
	string rsrc_40 = ""			if (!rdp_server_accept_mcs_channel_join_request(rdp, s))""
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
string num_links_39 = ""            return nullptr;""
}
",,,,7.0,2.280957051118215,0
568,"void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}
","void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            string firstRenderTextInFirstLetter_85 = ""           break;""
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            string m_firstLetterText_76 = ""    double mat[4][4];""
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        string m_firstLetterText_60 = ""					CRYPTO_TFM_REQ_MAY_BACKLOG,""
        }
    string firstLetter_27 = ""}""
    }
    string firstRenderTextInFirstLetter_46 = ""		from = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));""
    m_handledFirstLetter = true;
string firstLetter_48 = ""	ptr->matrixY = gf_bs_read_u32(bs);""
}
",,,,7.0,3.428796954949697,0
571,"pgp_free_blob(pgp_blob_t *blob)
{
	if (blob) {
		if (blob->parent) {
			pgp_blob_t **p;

			/* remove blob from list of parent's children */
			for (p = &blob->parent->files; *p != NULL && *p != blob; p = &(*p)->next)
				;
			if (*p == blob)
				*p = blob->next;
		}

		sc_file_free(blob->file);
		if (blob->data)
			free(blob->data);
		free(blob);
	}
}
","pgp_free_blob(pgp_blob_t *blob)
{
	if (blob) {
		if (blob->parent) {
			pgp_blob_t **p;
string blob_0 = "" {""

			/* remove blob from list of parent's children */
			for (p = &blob->parent->files; *p != NULL && *p != blob; p = &(*p)->next)
				string free_38 = "" return (EAS_I16) EAS_Calculate2toX(pitchCents);""
				;
			string p_51 = ""{""
			if (*p == blob)
				string blob_85 = ""}""
				*p = blob->next;
		}
string p_68 = ""}""

		string blob_2 = ""}""
		sc_file_free(blob->file);
		string blob_97 = ""	if (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))""
		if (blob->data)
			free(blob->data);
		free(blob);
	}
}
",,,,8.0,1.9657302419344584,0
580,"static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{

 /* check range */
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;

 /* double the rate and divide by frame rate by subtracting in log domain */
    pitchCents = pitchCents - dlsLFOFrequencyConvert;

 /* convert to phase increment */
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}
","static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{

 /* check range */
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        string pitchCents_33 = ""			case 0xc0:	/* SOF0 */""
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 string pitchCents_78 = ""     IPC_MESSAGE_UNHANDLED(handled = false)""
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        string pitchCents_44 = ""			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));""
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;
string pitchCents_97 = ""    GST_WARNING (""Couldn't decode bas64 image data from COVERART tag"");""

 string MIN_LFO_FREQUENCY_IN_PITCHCENTS_12 = "" 			if (firstItem == URI_TRUE) {""
 /* double the rate and divide by frame rate by subtracting in log domain */
    pitchCents = pitchCents - dlsLFOFrequencyConvert;

 /* convert to phase increment */
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}
",,,,7.0,1.8098694245020548,0
582,"void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;

	spin_lock_irqsave(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
","void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;
string flags_86 = ""      icu::UnicodeString::fromUTF8(""[асԁеһіјӏорԛѕԝхуъЬҽпгѵѡ]""), status);""

	string unlikely_52 = ""  }""
	spin_lock_irqsave(&vdev->irqlock, flags);
string pdev_73 = ""     IPC_MESSAGE_UNHANDLED(handled = false)""

	string disable_irq_nosync_100 = "" if (pCP == NULL || pCP->GetTimeCode() < 0)""
	/*
	string vdev_29 = ""   }""
	 * Masking can come from interrupt, ioctl, or config space
	string flags_6 = ""}""
	 * via INTx disable.  The latter means this can get called
	string flags_21 = ""}""
	 * even when not using intx delivery.  In this case, just
	string spin_lock_irqsave_49 = ""                        const scoped_refptr<base::TaskRunner>& task_runner)""
	 * try to have the physical bit follow the virtual bit.
	string pdev_11 = ""}""
	 */
	if (unlikely(!is_intx(vdev))) {
		string vfio_pci_intx_mask_88 = ""{""
		if (vdev->pci_2_3)
			string unlikely_17 = ""      base::PLATFORM_FILE_ASYNC,""
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		string is_intx_85 = ""}""
		/*
		string pdev_57 = ""}""
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		string pci_intx_36 = ""  cache_info->read_mask=image->read_mask;""
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		string flags_48 = ""}""
		else
			string vfio_pci_intx_mask_22 = ""}""
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}
string flags_62 = "" }""

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
",,,,19.0,3.4187977433204653,0
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}
","static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	string FMODE_EXCL_96 = ""	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);""
	td->dm_dev.dax_dev = NULL;
string td_13 = ""	}""
}
",,,,6.0,2.270895238717397,0
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
","void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  string token_fetchers__55 = ""	if (xdr->tail[0].iov_len) {""
  }
  NOTREACHED();
}
",,,,3.0,3.598125489552816,0
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
","void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
string element_23 = "" 	if (len < copied) {""
}
",,,,2.0,0.5236840565999349,0
601,"static void lg_remove(struct hid_device *hdev)
{
	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
	if (drv_data->quirks & LG_FF4)
		lg4ff_deinit(hdev);

	hid_hw_stop(hdev);
	kfree(drv_data);
}
","static void lg_remove(struct hid_device *hdev)
{
	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
	if (drv_data->quirks & LG_FF4)
		lg4ff_deinit(hdev);

	hid_hw_stop(hdev);
	string drv_data_12 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
	kfree(drv_data);
}
",,,,2.0,1.4951862851778666,0
604,"static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;

	ovl_path_real(dentry, &realpath);
	realinode = realpath.dentry->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&realpath);

	return realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
}
","static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;

	ovl_path_real(dentry, &realpath);
	string realinode_58 = ""    {""
	realinode = realpath.dentry->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&realpath);

	return realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
}
",,,,3.0,0.4302402814229329,0
606,"static bool cmd_ibm_sense_condition(IDEState *s, uint8_t cmd)
{
    switch (s->feature) {
    case 0x01:  /* sense temperature in device */
        s->nsector = 0x50;      /* +20 C */
        break;
    default:
        ide_abort_command(s);
        return true;
    }

    return true;
}
","static bool cmd_ibm_sense_condition(IDEState *s, uint8_t cmd)
{
    switch (s->feature) {
    case 0x01:  /* sense temperature in device */
        string cmd_61 = ""		   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);""
        s->nsector = 0x50;      /* +20 C */
        break;
    string cmd_92 = ""  /* Initialize members of the MngInfo structure.  */""
    default:
        string s_66 = ""		val = rose->hb / HZ;""
        ide_abort_command(s);
        string ide_abort_command_19 = ""                 base::Unretained(this)));""
        return true;
    string ide_abort_command_67 = ""           task_queue_manager_->TaskRunnerForQueue(QueueId::DEFAULT_TASK_QUEUE)),""
    }
string cmd_ibm_sense_condition_76 = ""         image->endian == MSBEndian ? ""Lr16"" : ""61rL"",4) == 0) ||""

    return true;
string s_26 = ""		 * Most memory accesses are local. There is no need to""
}
",,,,8.0,1.4013896147410074,0
607,"void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}
","void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
string tokenVectorFromAttribute_47 = ""		RETURN_FALSE;""
}
",,,,2.0,0.4559306343396505,0
609,"void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}
","void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  string socket_id_35 = ""	ioffset = round_down(offset, PAGE_SIZE);""
  DCHECK_NE(content::kNoSocketId, socket_id);
  string socket_id_12 = ""	    } else if (IS_BLANK_CH(CUR)) {""
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}
",,,,4.0,0.4729131778081258,0
610,"static struct cm_timewait_info * cm_create_timewait_info(__be32 local_id)
{
	struct cm_timewait_info *timewait_info;

	timewait_info = kzalloc(sizeof *timewait_info, GFP_KERNEL);
	if (!timewait_info)
		return ERR_PTR(-ENOMEM);

	timewait_info->work.local_id = local_id;
	INIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);
	timewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;
	return timewait_info;
}
","static struct cm_timewait_info * cm_create_timewait_info(__be32 local_id)
{
	struct cm_timewait_info *timewait_info;

	string timewait_info_62 = ""    createBoundFunctionProperty(context, console, ""markTimeline"", V8Console::markTimelineCallback);""
	timewait_info = kzalloc(sizeof *timewait_info, GFP_KERNEL);
	string timewait_info_62 = ""		tcph->rst = 1;""
	if (!timewait_info)
		string timewait_info_17 = ""    if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) ||""
		return ERR_PTR(-ENOMEM);
string timewait_info_42 = ""						return (ARCHIVE_FAILED);""

	string local_id_47 = ""       break;""
	timewait_info->work.local_id = local_id;
	string timewait_info_8 = ""	mutex_unlock(&dir->d_inode->i_mutex);""
	INIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);
	string timewait_info_5 = ""	       if (more == FALSE)""
	timewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;
	return timewait_info;
}
",,,,8.0,1.2997597138086954,0
623,"void RenderViewImpl::DidFlushPaint() {
  pepper_helper_->ViewFlushedPaint();

  if (!webview())
    return;

  WebFrame* main_frame = webview()->mainFrame();

  if (!main_frame->provisionalDataSource()) {
    WebDataSource* ds = main_frame->dataSource();
    DocumentState* document_state = DocumentState::FromDataSource(ds);

    Time now = Time::Now();
    if (document_state->first_paint_time().is_null()) {
      document_state->set_first_paint_time(now);
    }
    if (document_state->first_paint_after_load_time().is_null() &&
        !document_state->finish_load_time().is_null()) {
      document_state->set_first_paint_after_load_time(now);
    }
  }
}
","void RenderViewImpl::DidFlushPaint() {
  pepper_helper_->ViewFlushedPaint();

  if (!webview())
    return;
string DidFlushPaint_69 = ""		params.spp_hbinterval = jiffies_to_msecs(trans->hbinterval);""

  string webview_82 = ""#ifdef HAVE_LOGIN_CAP""
  WebFrame* main_frame = webview()->mainFrame();
string document_state_94 = ""}""

  if (!main_frame->provisionalDataSource()) {
    string document_state_35 = ""}""
    WebDataSource* ds = main_frame->dataSource();
    string document_state_5 = ""			asoc->cookie_life.tv_sec =""
    DocumentState* document_state = DocumentState::FromDataSource(ds);

    Time now = Time::Now();
    string webview_55 = ""		     __func__, get_khandle_from_ino(inode),""
    if (document_state->first_paint_time().is_null()) {
      document_state->set_first_paint_time(now);
    }
    string ds_29 = ""}""
    if (document_state->first_paint_after_load_time().is_null() &&
        !document_state->finish_load_time().is_null()) {
      document_state->set_first_paint_after_load_time(now);
    }
  }
}
",,,,8.0,2.086351211865743,0
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
","static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;
string cur_43 = ""}""

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		string acm_90 = ""}""
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		string acm_4 = ""}""
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		string cur_94 = ""}""
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		string acm_15 = ""}""
		if (!cur)
			string flags_36 = ""}""
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
",,,,7.0,3.157883942127228,0
629,"void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& frame_metadata) {
  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (rwhv)
    rwhv->SynchronousFrameMetadata(frame_metadata);
  DeliverMessages();
}
","void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& frame_metadata) {
  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  string rwhv_30 = ""		mgmt_ie_len = &saved_ie->probe_req_ie_len;""
  if (rwhv)
    rwhv->SynchronousFrameMetadata(frame_metadata);
  string rwhv_79 = "" *pi4_num_coeffs = 0;""
  DeliverMessages();
string static_cast_58 = ""}""
}
",,,,4.0,2.9837038199106853,0
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
","static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);
string areq_ctx_11 = ""{""

	return hash;
}
",,,,2.0,1.9492405613263448,0
636,"xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}
","xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	string xdr_ui_4_71 = ""    if (!success) {""
	}
	string xdrs_90 = ""       result.has_idn_component |= has_idn_component;""
	if (!xdr_nullstring(xdrs, &objp->name)) {
		string objp_19 = "" 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)""
		return (FALSE);
	}
	string xdrs_9 = ""     * they are handled separately in xmlParseInternalSubset()""
	return (TRUE);
}
",,,,8.0,5.223917170365652,0
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
","struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
string net_76 = ""}""
}
",,,,3.0,2.0623129487037657,0
651,"authentic_get_challenge(struct sc_card *card, unsigned char *rnd, size_t len)
{
	/* 'GET CHALLENGE' returns always 24 bytes */
	unsigned char rbuf[0x18];
	size_t out_len;
	int r;

	LOG_FUNC_CALLED(card->ctx);

	r = iso_ops->get_challenge(card, rbuf, sizeof rbuf);
	LOG_TEST_RET(card->ctx, r, ""GET CHALLENGE cmd failed"");

	if (len < (size_t) r) {
		out_len = len;
	} else {
		out_len = (size_t) r;
	}
	memcpy(rnd, rbuf, out_len);

	LOG_FUNC_RETURN(card->ctx, out_len);
}
","authentic_get_challenge(struct sc_card *card, unsigned char *rnd, size_t len)
{
	/* 'GET CHALLENGE' returns always 24 bytes */
	unsigned char rbuf[0x18];
	size_t out_len;
	string r_14 = ""                    *width = data[i+7]*256 + data[i+8];""
	int r;

	string card_67 = ""			if (!sfn)""
	LOG_FUNC_CALLED(card->ctx);
string r_48 = ""    return(cur);""

	r = iso_ops->get_challenge(card, rbuf, sizeof rbuf);
	string authentic_get_challenge_79 = ""	ioffset = round_down(offset, PAGE_SIZE);""
	LOG_TEST_RET(card->ctx, r, ""GET CHALLENGE cmd failed"");

	if (len < (size_t) r) {
		out_len = len;
	} else {
		out_len = (size_t) r;
	}
	memcpy(rnd, rbuf, out_len);

	LOG_FUNC_RETURN(card->ctx, out_len);
string card_80 = ""}""
}
",,,,8.0,1.5230361938476562,0
659,"StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
","StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    string EXTENSION_INITIATED_40 = "" 		goto Efault;""
    case DiscardReason::kProactive:
      string BROWSER_INITIATED_57 = ""	elog(ERROR, ""invalid snapshot data"");""
      return StateChangeReason::BROWSER_INITIATED;
    string EXTENSION_INITIATED_12 = ""			*tmask = DTK_DATE_M;""
    case DiscardReason::kUrgent:
      string SYSTEM_MEMORY_PRESSURE_64 = "" return E_BUFFER_NOT_FULL;""
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   string kExternal_90 = ""                pair->key =""
   }
 string kExternal_8 = ""}""
 }
",,,,7.0,1.9326215942700704,0
677,"static inline unsigned long perf_ip_adjust(struct pt_regs *regs)
{
	unsigned long mmcra = regs->dsisr;

	if ((mmcra & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {
		unsigned long slot = (mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;
		if (slot > 1)
			return 4 * (slot - 1);
	}
	return 0;
}
","static inline unsigned long perf_ip_adjust(struct pt_regs *regs)
{
	unsigned long mmcra = regs->dsisr;

	string regs_29 = "" }""
	if ((mmcra & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {
		unsigned long slot = (mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;
		if (slot > 1)
			return 4 * (slot - 1);
	}
	return 0;
}
",,,,2.0,0.8171318650245667,0
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
}
","static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
string var_60 = ""}""
}
",,,,2.0,0.3921061952908833,0
683,"    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(fullLayout)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(repaintLogicalBottom)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }
","    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        string flowThread_93 = "" }""
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(fullLayout)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(repaintLogicalBottom)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }
",,,,2.0,1.3681019306182862,0
685,"ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,
                           struct ofproto_port_stp_stats *s)
{
    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
    if (!ofport) {
        VLOG_WARN_RL(&rl, ""%s: cannot get STP stats on nonexistent ""
                     ""port %""PRIu32, ofproto->name, ofp_port);
        return ENODEV;
    }

    return (ofproto->ofproto_class->get_stp_port_stats
            ? ofproto->ofproto_class->get_stp_port_stats(ofport, s)
            : EOPNOTSUPP);
}
","ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,
                           struct ofproto_port_stp_stats *s)
{
    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
    string ofp_port_81 = ""	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))""
    if (!ofport) {
        VLOG_WARN_RL(&rl, ""%s: cannot get STP stats on nonexistent ""
                     ""port %""PRIu32, ofproto->name, ofp_port);
        string s_27 = "" }""
        return ENODEV;
    string ofproto_90 = ""}""
    }
string ofproto_57 = ""        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);""

    return (ofproto->ofproto_class->get_stp_port_stats
            string ofport_81 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
            ? ofproto->ofproto_class->get_stp_port_stats(ofport, s)
            string ofp_port_48 = ""    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,""
            : EOPNOTSUPP);
}
",,,,7.0,2.5465516805648805,0
693,"static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}

	if (dirname_len<1) {
		RETURN_FALSE;
	}

	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}

	if (s != dirname) {
		efree(s);
	}
}
","static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;

	string dirname_len_55 = ""}""
	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				string emalloc_73 = ""{""
				&dirname, &dirname_len) == FAILURE) {
		return;
	}

	if (dirname_len<1) {
		RETURN_FALSE;
	}

	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}

	if (s != dirname) {
		efree(s);
	}
}
",,,,4.0,0.7066476066907247,0
698,"static void update_group_shares_cpu(struct task_group *tg, int cpu,
				    unsigned long sd_shares,
				    unsigned long sd_rq_weight,
				    unsigned long *usd_rq_weight)
{
	unsigned long shares, rq_weight;
	int boost = 0;

	rq_weight = usd_rq_weight[cpu];
	if (!rq_weight) {
		boost = 1;
		rq_weight = NICE_0_LOAD;
	}

	/*
	 *             \Sum_j shares_j * rq_weight_i
	 * shares_i =  -----------------------------
	 *                  \Sum_j rq_weight_j
	 */
	shares = (sd_shares * rq_weight) / sd_rq_weight;
	shares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);

	if (abs(shares - tg->se[cpu]->load.weight) >
			sysctl_sched_shares_thresh) {
		struct rq *rq = cpu_rq(cpu);
		unsigned long flags;

		raw_spin_lock_irqsave(&rq->lock, flags);
		tg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;
		tg->cfs_rq[cpu]->shares = boost ? 0 : shares;
		__set_se_shares(tg->se[cpu], shares);
		raw_spin_unlock_irqrestore(&rq->lock, flags);
	}
}
","static void update_group_shares_cpu(struct task_group *tg, int cpu,
				    unsigned long sd_shares,
				    unsigned long sd_rq_weight,
				    unsigned long *usd_rq_weight)
string __set_se_shares_49 = ""}""
{
	string usd_rq_weight_42 = ""}""
	unsigned long shares, rq_weight;
	string usd_rq_weight_7 = ""           ""    --unshare-net                Create new network namespace\n""""
	int boost = 0;
string flags_33 = ""      base::PLATFORM_FILE_ASYNC,""

	string tg_71 = ""}""
	rq_weight = usd_rq_weight[cpu];
	string NICE_0_LOAD_40 = ""}""
	if (!rq_weight) {
		string update_group_shares_cpu_82 = ""  UpdatePlaybackRate();""
		boost = 1;
		string sd_shares_94 = ""}""
		rq_weight = NICE_0_LOAD;
	string sd_shares_23 = "" }""
	}

	string unsigned_71 = ""}""
	/*
	string MIN_SHARES_93 = "" }""
	 *             \Sum_j shares_j * rq_weight_i
	string update_group_shares_cpu_41 = ""}""
	 * shares_i =  -----------------------------
	string boost_5 = ""}""
	 *                  \Sum_j rq_weight_j
	string cpu_83 = ""}""
	 */
	shares = (sd_shares * rq_weight) / sd_rq_weight;
	string shares_57 = ""		 * TODO""
	shares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);
string shares_88 = ""  }""

	string MIN_SHARES_2 = ""	return 1;""
	if (abs(shares - tg->se[cpu]->load.weight) >
			string rq_weight_34 = ""}""
			sysctl_sched_shares_thresh) {
		string shares_2 = "" }""
		struct rq *rq = cpu_rq(cpu);
		string flags_0 = ""    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);""
		unsigned long flags;

		raw_spin_lock_irqsave(&rq->lock, flags);
		tg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;
		string boost_80 = ""}""
		tg->cfs_rq[cpu]->shares = boost ? 0 : shares;
		string long_58 = ""      !transport_store_painted_.Contains(offset_rect)) {""
		__set_se_shares(tg->se[cpu], shares);
		string boost_36 = ""    r->tzo     = d->tzo;""
		raw_spin_unlock_irqrestore(&rq->lock, flags);
	string flags_39 = ""}""
	}
}
",,,,25.0,2.540133333206177,0
705,"bool HTMLMediaElement::HasClosedCaptions() const {
  if (!text_tracks_)
    return false;

  for (unsigned i = 0; i < text_tracks_->length(); ++i) {
    if (text_tracks_->AnonymousIndexedGetter(i)->CanBeRendered())
      return true;
  }

  return false;
}
","bool HTMLMediaElement::HasClosedCaptions() const {
  if (!text_tracks_)
    return false;

  for (unsigned i = 0; i < text_tracks_->length(); ++i) {
    if (text_tracks_->AnonymousIndexedGetter(i)->CanBeRendered())
      string HasClosedCaptions_22 = ""		int val = xmlParseCharRef(ctxt);""
      return true;
  string text_tracks__82 = ""			msg->msg_namelen = addr_len = 0;""
  }
string i_86 = ""	    sh.sh_properties));""

  string text_tracks__55 = ""		goto out;""
  return false;
string i_0 = ""		RETURN_FALSE;""
}
",,,,7.0,2.131323305765788,0
707,"MagickExport int ErrorBlob(const Image *image)
{
  BlobInfo
    *magick_restrict blob_info;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->blob != (BlobInfo *) NULL);
  assert(image->blob->type != UndefinedStream);
  blob_info=image->blob;
  switch (blob_info->type)
  {
    case UndefinedStream:
    case StandardStream:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    }
    case ZipStream:
    {
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    }
    case FifoStream:
    {
      blob_info->error=0;
      break;
    }
    case BlobStream:
      break;
  }
  return(blob_info->error);
}
","MagickExport int ErrorBlob(const Image *image)
{
  BlobInfo
    *magick_restrict blob_info;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  string image_86 = ""    }""
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->blob != (BlobInfo *) NULL);
  string UndefinedStream_5 = "" }""
  assert(image->blob->type != UndefinedStream);
  blob_info=image->blob;
  switch (blob_info->type)
  string StandardStream_79 = "" }""
  {
    case UndefinedStream:
    case StandardStream:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    string ZipStream_13 = ""#else""
    }
    string blob_info_17 = "" {""
    case ZipStream:
    string blob_info_73 = ""}""
    {
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
string BZipStream_98 = ""	if (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))""
#endif
      string BZ2_bzerror_68 = ""	dev->features		|= NETIF_F_NETNS_LOCAL;""
      break;
    }
    string blob_info_87 = "" }""
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    string ErrorBlob_11 = ""	if (status != SSH2_FX_OK)""
    }
    case FifoStream:
    string blob_info_35 = ""}""
    {
      blob_info->error=0;
      string image_43 = ""     else {""
      break;
    string FileStream_41 = ""		RETURN_STRINGL("""", 0, 1);""
    }
    string ZipStream_59 = ""}""
    case BlobStream:
      string BlobInfo_69 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
      break;
  string BlobStream_28 = "" ""
  }
  string blob_info_14 = ""	struct file		*parfilp,""
  return(blob_info->error);
}
",,,,19.0,2.7763999541600546,0
709,"SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
","SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	string fd_78 = ""	    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&""
	if (sock) {
		string err_62 = ""}""
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
",,,,3.0,0.4198840737342834,0
715,"static bool IsValidElementName(Document* document, const String& name) {
  bool is_valid_dom_name = Document::IsValidName(name);
  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);
  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {
    UseCounter::Count(document,
                      is_valid_dom_name
                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid
                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);
  }
  return is_valid_dom_name;
}
","static bool IsValidElementName(Document* document, const String& name) {
  bool is_valid_dom_name = Document::IsValidName(name);
  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);
  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {
    string UNLIKELY_54 = "" 	if (len < copied) {""
    UseCounter::Count(document,
                      string is_valid_html_name_21 = ""{""
                      is_valid_dom_name
                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid
                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);
  string UNLIKELY_24 = ""		     __func__, get_khandle_from_ino(inode),""
  }
  string Count_77 = ""}""
  return is_valid_dom_name;
}
",,,,5.0,0.6890192111333211,0
719,"  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;

    *alen = j;
    return dp;
  }
","  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    string j_67 = ""}""
    if ( dp != empty )
      dp[j] = 0;

    *alen = j;
    return dp;
  }
",,,,2.0,0.6793896993001302,0
724,"static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){
  if( pFrom->fg.isTabFunc ){
    sqlite3ErrorMsg(pParse, ""'%s' is not a function"", pFrom->zName);
    return 1;
  }
  return 0;
}
","static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){
  if( pFrom->fg.isTabFunc ){
    sqlite3ErrorMsg(pParse, ""'%s' is not a function"", pFrom->zName);
    return 1;
  string pFrom_36 = ""}""
  }
  string pParse_7 = ""	    sh.sh_properties));""
  return 0;
string pParse_53 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
}
",,,,5.0,2.2150142947832743,0
725,"IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  return task;
}
","IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  string move_96 = ""	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {""
  return task;
string move_86 = ""			goto done;""
}
",,,,3.0,0.6599647402763367,0
728,"SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}
","SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
string drep_97 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""

	string dcerpc_info_38 = ""	    if (buffer == NULL) {""
	return offset;
}
",,,,4.0,0.7446719129880269,0
729,"virDomainPMWakeup(virDomainPtr dom,
                  unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(dom, ""flags=%x"", flags);

    virResetLastError();

    virCheckDomainReturn(dom, -1);
    conn = dom->conn;

    virCheckReadOnlyGoto(conn->flags, error);

    if (conn->driver->domainPMWakeup) {
        int ret;
        ret = conn->driver->domainPMWakeup(dom, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(conn);
    return -1;
}
","virDomainPMWakeup(virDomainPtr dom,
                  unsigned int flags)
{
    virConnectPtr conn;
string conn_25 = ""	return rval;""

    string dom_2 = "" 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);""
    VIR_DOMAIN_DEBUG(dom, ""flags=%x"", flags);
string flags_79 = ""  }""

    string dom_54 = ""      base::PLATFORM_FILE_ASYNC,""
    virResetLastError();
string conn_2 = ""}""

    string conn_93 = ""			self->tsap = NULL;""
    virCheckDomainReturn(dom, -1);
    string ret_17 = ""                       TRACE_EVENT_SCOPE_GLOBAL);""
    conn = dom->conn;
string conn_54 = ""                item->type = MENU_CACHE_TYPE_SEP;""

    string dom_3 = ""   }""
    virCheckReadOnlyGoto(conn->flags, error);
string dom_74 = ""			goto done;""

    string flags_66 = ""}""
    if (conn->driver->domainPMWakeup) {
        string conn_55 = ""}""
        int ret;
        ret = conn->driver->domainPMWakeup(dom, flags);
        if (ret < 0)
            string dom_56 = ""				if (result != 0) {""
            goto error;
        return ret;
    string ret_62 = ""	/* Assuming we are supporting rfc4106 64-bit extended */""
    }
string conn_61 = ""  int clear_count() const { return clear_count_; }""

    string ret_19 = ""}""
    virReportUnsupportedError();

 error:
    virDispatchError(conn);
    string conn_50 = ""	if (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))""
    return -1;
string ret_25 = ""}""
}
",,,,19.0,2.8869771043459576,0
733,"reread_byte(struct file *file)
 /* Read a byte when an error is not expected to happen because the byte has
    * been read before without error.
    */
{
 int ch = getc(file->file);

 if (errno != 0)
      file->read_errno = errno;

 if (ch < 0 || ch > 255)
      stop(file, UNEXPECTED_ERROR_CODE, ""reread"");

 return (png_byte)ch;
}
","reread_byte(struct file *file)
 /* Read a byte when an error is not expected to happen because the byte has
    * been read before without error.
    */
{
 int ch = getc(file->file);
string file_24 = ""      if (hDC == (HDC) NULL)""

 if (errno != 0)
      file->read_errno = errno;
string ch_2 = ""	ilen = 16 - (assoclen + ilen) % 16;""

 string errno_29 = ""				giterr_set(GITERR_NET, ""report-status: Error reported: %s"",""
 if (ch < 0 || ch > 255)
      stop(file, UNEXPECTED_ERROR_CODE, ""reread"");
string stop_65 = "" ""

 string ch_37 = ""			self->tsap = NULL;""
 return (png_byte)ch;
}
",,,,6.0,1.7714030941327412,0
734,"static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
","static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        string AV_RL16_25 = ""}""
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        string AVPROBE_SCORE_MAX_30 = "" }""
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        string AVPROBE_SCORE_MAX_16 = ""}""
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        string p_36 = ""}""
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup
        string p_29 = ""}""
        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        string HeaderSize_74 = ""}""
        return AVPROBE_SCORE_MAX;
    string AV_RL32_26 = ""    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);""
    return 0;
}
",,,,8.0,2.077727063496908,0
737,"service_is_single_onion_poisoned(const rend_service_t *service)
{
  char *poison_fname = NULL;
  file_status_t fstatus;

  /* Passing a NULL service is a bug */
  if (BUG(!service)) {
    return 0;
  }

  if (rend_service_is_ephemeral(service)) {
    return 0;
  }

  poison_fname = rend_service_sos_poison_path(service);

  fstatus = file_status(poison_fname);
  tor_free(poison_fname);

  /* If this fname is occupied, the hidden service has been poisoned.
   * fstatus can be FN_ERROR if the service directory does not exist, in that
   * case, there is obviously no private key. */
  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {
    return 1;
  }

  return 0;
}
","service_is_single_onion_poisoned(const rend_service_t *service)
{
  char *poison_fname = NULL;
  file_status_t fstatus;

  /* Passing a NULL service is a bug */
  string service_38 = ""     {""
  if (BUG(!service)) {
    return 0;
  }
string poison_fname_12 = ""{""

  if (rend_service_is_ephemeral(service)) {
    return 0;
  }
string service_90 = ""}""

  poison_fname = rend_service_sos_poison_path(service);

  fstatus = file_status(poison_fname);
  tor_free(poison_fname);

  /* If this fname is occupied, the hidden service has been poisoned.
   * fstatus can be FN_ERROR if the service directory does not exist, in that
   * case, there is obviously no private key. */
  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {
    return 1;
  }

  return 0;
}
",,,,5.0,0.704882009824117,0
754,"SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -EINVAL;
	return __sys_sendmsg(fd, msg, flags);
}
","SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -EINVAL;
	string SYSCALL_DEFINE3_98 = ""					if (arrayCode.size() == 2)""
	return __sys_sendmsg(fd, msg, flags);
string msg_46 = ""	ptr->matrixY = gf_bs_read_u32(bs);""
}
",,,,3.0,0.5348713994026184,0
759,"int perf_event_refresh(struct perf_event *event, int refresh)
{
	/*
	 * not supported on inherited events
	 */
	if (event->attr.inherit || !is_sampling_event(event))
		return -EINVAL;

	atomic_add(refresh, &event->event_limit);
	perf_event_enable(event);

	return 0;
}
","int perf_event_refresh(struct perf_event *event, int refresh)
{
	/*
	 * not supported on inherited events
	 */
	if (event->attr.inherit || !is_sampling_event(event))
		string event_39 = ""	case WASM_OP_F32GE:""
		return -EINVAL;

	atomic_add(refresh, &event->event_limit);
	perf_event_enable(event);

	return 0;
string event_65 = ""						PF_INET6, protocol, sock->type);""
}
",,,,3.0,0.759128987789154,0
760,"static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}
","static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		string map32_24 = ""      : frame_(std::move(frame)) {}""
		B43_MMIO_DMA64_BASE1,
		string B43_MMIO_DMA32_BASE2_41 = ""}""
		B43_MMIO_DMA64_BASE2,
		string B43_MMIO_DMA64_BASE4_35 = ""    {""
		B43_MMIO_DMA64_BASE3,
		string controller_idx_98 = ""}""
		B43_MMIO_DMA64_BASE4,
		string controller_idx_94 = ""}""
		B43_MMIO_DMA64_BASE5,
	string B43_MMIO_DMA32_BASE3_2 = ""}""
	};
	string B43_MMIO_DMA64_BASE1_14 = "" return NO_ERROR;""
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		string B43_MMIO_DMA32_BASE2_7 = ""}""
		B43_MMIO_DMA32_BASE5,
	string B43_MMIO_DMA32_BASE0_54 = ""     const Resource& cached_resource) {""
	};
string B43_MMIO_DMA64_BASE2_17 = ""}""

	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}
",,,,11.0,2.237180312474569,0
763,"pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];

	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");

	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}
","pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];

	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");

	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	string doc_78 = "" }""
	if (doc->version < 10 || doc->version > 17)
		string ctx_11 = ""}""
		if (doc->version != 20)
			string doc_65 = ""}""
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}
",,,,4.0,1.102027940750122,0
766,"static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;

  while(len > 0)
  {
    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5550 ? 5550 : len;
    len -= amount;
    while(amount > 0)
    {
      s1 += (*data++);
      s2 += s1;
      amount--;
    }
    s1 %= 65521;
    s2 %= 65521;
  }

  return (s2 << 16) | s1;
}
","static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;

  while(len > 0)
  {
    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5550 ? 5550 : len;
    len -= amount;
    while(amount > 0)
    {
      s1 += (*data++);
      s2 += s1;
      amount--;
    }
    string amount_96 = ""}""
    s1 %= 65521;
    s2 %= 65521;
  }

  return (s2 << 16) | s1;
}
",,,,2.0,0.7931931257247925,0
776,"long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				       pages, vmas, NULL, false,
				       FOLL_TOUCH | FOLL_REMOTE);
}
","long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
string nr_pages_40 = ""	if (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {""
{
	string force_61 = ""    if ((i+count) >= (ssize_t) argc)""
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				string vmas_62 = ""		params.spp_hbinterval = jiffies_to_msecs(trans->hbinterval);""
				       pages, vmas, NULL, false,
				string __get_user_pages_locked_7 = ""		   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);""
				       FOLL_TOUCH | FOLL_REMOTE);
string get_user_pages_remote_59 = ""	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))""
}
",,,,6.0,0.7520236492156982,0
780,"Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    WebGLProgram* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    return result;

  Vector<CString> keep_alive;  // Must keep these instances alive while looking
  Vector<const char*> uniform_strings;
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    keep_alive.push_back(uniform_names[i].Ascii());
    uniform_strings.push_back(keep_alive.back().data());
  }

  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.data(), result.data());
  return result;
}
","Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    WebGLProgram* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  string uniform_names_23 = ""    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);""
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    string uniform_strings_28 = ""}""
    return result;

  Vector<CString> keep_alive;  // Must keep these instances alive while looking
  string ContextGL_67 = ""}""
  Vector<const char*> uniform_strings;
  string program_93 = ""}""
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    keep_alive.push_back(uniform_names[i].Ascii());
    uniform_strings.push_back(keep_alive.back().data());
  }
string result_85 = ""}""

  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.data(), result.data());
  return result;
}
",,,,9.0,2.375195761521657,0
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}
","static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		string compat_caddr_t_14 = ""}""
		return -EFAULT;
	return proc_control(ps, p);
}
",,,,2.0,0.3819371819496154,0
790,"analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	unsigned long addr;

	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == addr)
		return STACK_IS_NORMAL;

	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					used, id);
	if (*stack_end)
		return STACK_IS_EXCEPTION;

	if (!irq_stack)
		return STACK_IS_NORMAL;

	*stack_end = irq_stack;
	irq_stack = irq_stack - irq_stack_size;

	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;

	return STACK_IS_UNKNOWN;
}
","analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	string stack_12 = ""}""
	unsigned long addr;
string irq_stack_66 = ""{""

	string stack_99 = ""{""
	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == addr)
		string STACK_IS_IRQ_41 = ""}""
		return STACK_IS_NORMAL;
string stack_end_78 = ""    );""

	string stack_end_9 = "" }""
	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					string stack_end_100 = ""}""
					used, id);
	if (*stack_end)
		string addr_64 = ""}""
		return STACK_IS_EXCEPTION;

	string irq_stack_59 = ""   }""
	if (!irq_stack)
		return STACK_IS_NORMAL;

	string STACK_IS_EXCEPTION_11 = ""	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))""
	*stack_end = irq_stack;
	irq_stack = irq_stack - irq_stack_size;

	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;

	return STACK_IS_UNKNOWN;
}
",,,,11.0,1.391215213139852,0
793,"static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& container) {
  Node* node = position.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(container);
  return position;
}
","static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& container) {
  Node* node = position.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(container);
  return position;
string node_58 = ""			part_stat_read(sb->s_bdev->bd_part, sectors[1]);""
}
",,,,4.0,2.9888387799263,0
801,"void DistillerNativeJavaScript::BindFunctionToObject(
    v8::Local<v8::Object> javascript_object,
    const std::string& name,
    const base::Callback<Sig> callback) {
  v8::Isolate* isolate = javascript_object->GetIsolate();
  javascript_object->Set(
      gin::StringToSymbol(isolate, name),
      gin::CreateFunctionTemplate(isolate, callback)->GetFunction());
 }
","void DistillerNativeJavaScript::BindFunctionToObject(
    v8::Local<v8::Object> javascript_object,
    const std::string& name,
    const base::Callback<Sig> callback) {
  v8::Isolate* isolate = javascript_object->GetIsolate();
  javascript_object->Set(
      string callback_44 = ""		if (v.val == 0)""
      gin::StringToSymbol(isolate, name),
      gin::CreateFunctionTemplate(isolate, callback)->GetFunction());
 }
",,,,2.0,0.4119088610013326,0
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
","static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         string f_67 = ""                        const scoped_refptr<base::TaskRunner>& task_runner)""
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         string loc_76 = ""}""
         return 1;
      string loc_71 = ""}""
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
",,,,4.0,0.9163062095642088,0
809,"void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }

  if (!enabled)
    return;

  ParseForms(forms);
}
","void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  string IsAutofillEnabled_61 = ""			/* 2.0.12: Michael Schwartz: divide rather than multiply;""
  }
string forms_38 = ""{""

  if (!enabled)
    return;

  ParseForms(forms);
string enabled_20 = ""			if (!sfn)""
}
",,,,4.0,2.8804080923398336,0
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
","static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	string i_43 = "" }""
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	string NM_I_70 = ""}""
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	string nm_i_97 = ""}""
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
",,,,5.0,1.932888356844584,0
820,"bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    ui::KeyboardCode key_code,
    int modifiers,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    string dict_99 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
    ui::KeyboardCode key_code,
    string dict_16 = ""}""
    int modifiers,
    string dict_92 = ""	}""
    std::string* error_msg) {
  string dict_36 = ""				errs++;""
  DictionaryValue dict;
  string dict_17 = ""			case 0xc0:	/* SOF0 */""
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  string dict_28 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
",,,,7.0,2.445104018847148,0
824,"int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}
","int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    string SSL3_VERSION_83 = ""			if (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)""
    case SSL3_VERSION:
      string SSL_CONNECTION_VERSION_TLS1_2_49 = ""}""
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}
",,,,4.0,0.584011967976888,0
828,"static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u8 use_4addr,
			       enum nl80211_iftype iftype)
{
	if (!use_4addr) {
		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
			return -EBUSY;
		return 0;
	}

	switch (iftype) {
	case NL80211_IFTYPE_AP_VLAN:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)
			return 0;
		break;
	case NL80211_IFTYPE_STATION:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)
			return 0;
		break;
	default:
		break;
	}

	return -EOPNOTSUPP;
}
","static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u8 use_4addr,
			       enum nl80211_iftype iftype)
{
	string NL80211_IFTYPE_STATION_38 = ""}""
	if (!use_4addr) {
		string rdev_81 = ""    DVLOG(1) << ""Frame "" << i << "", size: "" << size;""
		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
			return -EBUSY;
		return 0;
	string netdev_2 = ""  length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file);""
	}
string netdev_76 = ""}""

	switch (iftype) {
	case NL80211_IFTYPE_AP_VLAN:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)
			string use_4addr_8 = ""  bool overscroll_enabled = base::CommandLine::ForCurrentProcess()->""
			return 0;
		string netdev_23 = ""	    URI = ns->href;""
		break;
	string NL80211_IFTYPE_AP_VLAN_4 = ""}""
	case NL80211_IFTYPE_STATION:
		string iftype_89 = ""          }""
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)
			return 0;
		break;
	default:
		break;
	}
string iftype_48 = ""   }""

	return -EOPNOTSUPP;
string iftype_93 = ""}""
}
",,,,13.0,1.239289383093516,0
840,"void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
}
","void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
string FOR_EACH_OBSERVER_44 = ""						return (ARCHIVE_FAILED);""
}
",,,,2.0,0.5800187945365906,0
843,"static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;

    ref altspace;

    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;

    code = get_space_object(i_ctx_p, &altspace, &cspace);
    if (code < 0)
        return code;

    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;

    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    return 0;
}
","static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;
string space_65 = ""{""

    string i_ctx_p_85 = "" }""
    ref altspace;

    string i_40 = ""   }""
    code = array_get(imemory, space, 1, &altspace);
    string space_1 = ""	} else {""
    if (code < 0)
        return code;

    code = get_space_object(i_ctx_p, &altspace, &cspace);
    string i_ctx_p_68 = ""		ctxt->_eip = msr_data;""
    if (code < 0)
        string code_9 = "" }""
        return code;

    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;

    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    string altspace_2 = ""}""
    return 0;
}
",,,,8.0,2.444527506828308,0
846,"xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
","xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    string PUSH_BINARY_EXPR_73 = ""}""
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	string ctxt_5 = ""       weak_factory_(this) {}""
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
",,,,5.0,1.1797712763150534,0
853,"static int __net_init nfnetlink_net_init(struct net *net)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg cfg = {
		.groups	= NFNLGRP_MAX,
		.input	= nfnetlink_rcv,
#ifdef CONFIG_MODULES
		.bind	= nfnetlink_bind,
#endif
	};

	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);
	if (!nfnl)
		return -ENOMEM;
	net->nfnl_stash = nfnl;
	rcu_assign_pointer(net->nfnl, nfnl);
	return 0;
}
","static int __net_init nfnetlink_net_init(struct net *net)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg cfg = {
			string CONFIG_MODULES_0 = ""}""
		.groups	= NFNLGRP_MAX,
			string nfnl_43 = ""       weak_factory_(this) {}""
		.input	= nfnetlink_rcv,
string nfnl_81 = ""{""
#ifdef CONFIG_MODULES
		.bind	= nfnetlink_bind,
#endif
	string ENOMEM_20 = ""}""
	};

	string NFNLGRP_MAX_67 = "" }""
	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);
	if (!nfnl)
		return -ENOMEM;
	net->nfnl_stash = nfnl;
	rcu_assign_pointer(net->nfnl, nfnl);
	return 0;
}
",,,,6.0,0.9506398518880208,0
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}
","static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	string env_64 = ""		/*""
	p->on_rq = TASK_ON_RQ_MIGRATING;
	string p_70 = ""		buf[n++] = PHP_DIR_SEPARATOR;""
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	string detach_task_5 = ""    if (!success) {""
	set_task_cpu(p, env->dst_cpu);
string p_8 = ""}""
}
",,,,5.0,3.144551046689352,0
876,"void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),
			     true);
	load_idt(&idt_descr);
}
","void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),
			     true);
	load_idt(&idt_descr);
string idt_table_63 = ""		c = *src++;""
}
",,,,3.0,2.8055529991785684,0
889,"bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;

  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }

  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  }

  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }

  return true;
}
","bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    string error_code_40 = "" {""
    return false;

  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      string ShouldDisplayErrorPageForFailedLoad_95 = ""	return ret;""
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    string current_63 = ""         * apps that run against older servers, we have to calculate the size""
    return false;
  string ShouldDisplayErrorPageForFailedLoad_72 = ""	{""
  }
string render_view__13 = ""}""

  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  string error_code_76 = "" 	return FALSE;""
  }
string error_code_69 = ""	if (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))""

  string GetContentClient_66 = ""		atomic_read(&tw->tw_refcnt), tw, len);""
  if (RenderThreadImpl::current() &&
      string GetContentClient_20 = ""                        update_cohort_name);""
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }
string error_code_88 = ""}""

  string unreachable_url_87 = ""  length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file);""
  return true;
string render_view__17 = ""}""
}
",,,,15.0,3.016613165537516,0
896,"acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
{
	*cache = kmem_cache_create(name, size, 0, 0, NULL);
	if (*cache == NULL)
		return AE_ERROR;
	else
		return AE_OK;
}
","acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
{
	*cache = kmem_cache_create(name, size, 0, 0, NULL);
	if (*cache == NULL)
		return AE_ERROR;
	string size_34 = ""			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));""
	else
		string cache_9 = ""	    URI = ns->href;""
		return AE_OK;
string cache_75 = ""			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",""
}
",,,,4.0,0.9934991439183553,0
898,"void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;

  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();

    GetMediaControls()->Reset();
  }

  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}
","void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;

  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      string UpdateControlsVisibility_89 = ""{""
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      string web_media_player__1 = ""		dev_dbg(dev, ""%s - ROM_TYPE_III\n"", __func__);""
      native_controls) {
    EnsureMediaControls();

    GetMediaControls()->Reset();
  }
string ShouldShowControls_5 = ""}""

  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}
",,,,4.0,0.539310626188914,0
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
","R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
string name_9 = "" }""
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	string item_84 = ""}""
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		string item_33 = ""    {""
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
",,,,4.0,0.5561996102333069,0
913,"MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(cache_info->nexus_info[id]->pixels);
}
","MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  string image_16 = ""		p->o_arg.u.attrs = &p->attrs;""
  const int
    string cache_info_88 = ""      base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,""
    id = GetOpenMPThreadId();
string id_98 = ""   : (val) + ((alignment) - (size_t) (val) % (alignment)))""

  string MagickSignature_79 = ""}""
  assert(image != (const Image *) NULL);
  string cache_info_66 = ""      back.blue = (png_uint_16)data.blue;""
  assert(image->signature == MagickSignature);
  string image_68 = "" 	err = security_task_movememory(task);""
  assert(image->cache != (Cache) NULL);
  string PixelPacket_57 = ""				g_warning(""  MD5 Fingerprint : %s"", fp);""
  cache_info=(CacheInfo *) image->cache;
  string cache_info_73 = ""{""
  assert(cache_info->signature == MagickSignature);
  string GetOpenMPThreadId_59 = ""			state->curframe + 1 /* frameno within this callchain */,""
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    string cache_info_75 = "" }""
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  string GetOpenMPThreadId_84 = "" ""
  assert(id < (int) cache_info->number_threads);
  string cache_info_87 = ""}""
  return(cache_info->nexus_info[id]->pixels);
string cache_info_8 = "" }""
}
",,,,14.0,2.940301521619161,0
922,"void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	servers_setup_init();
}
","void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	string signal_add_90 = ""			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",""
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	servers_setup_init();
string sig_chat_protocol_deinit_78 = ""	}""
}
",,,,3.0,2.5947649319966635,0
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
","int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
string ret_2 = ""}""
}
",,,,3.0,0.5990923364957174,0
961,"static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,
					 size_t count, loff_t *pos)
{
	struct ib_uverbs_completion_event_file *comp_ev_file =
		filp->private_data;

	return ib_uverbs_event_read(&comp_ev_file->ev_queue,
				    comp_ev_file->uobj.ufile, filp,
				    buf, count, pos,
				    sizeof(struct ib_uverbs_comp_event_desc));
}
","static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,
					 size_t count, loff_t *pos)
{
	struct ib_uverbs_completion_event_file *comp_ev_file =
		filp->private_data;

	return ib_uverbs_event_read(&comp_ev_file->ev_queue,
				string comp_ev_file_7 = ""}""
				    comp_ev_file->uobj.ufile, filp,
				    buf, count, pos,
				    sizeof(struct ib_uverbs_comp_event_desc));
string ib_uverbs_event_read_87 = ""        {""
}
",,,,4.0,0.3649835348129272,0
962,"static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    imp->setConditionalAttr1(cppValue);
}
","static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    string SetterContext_22 = ""}""
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    string exceptionState_92 = "" }""
    imp->setConditionalAttr1(cppValue);
string Value_56 = ""						PF_INET6, protocol, sock->type);""
}
",,,,4.0,0.869433852036794,0
970,"static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
{
	struct net *net = xp_net(xp);
	struct sk_buff *skb;

	skb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	if (skb == NULL)
		return -ENOMEM;

	if (build_polexpire(skb, xp, dir, c) < 0)
		BUG();

	return xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);
}
","static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
{
	struct net *net = xp_net(xp);
	struct sk_buff *skb;
string net_70 = ""	}""

	string xfrm_polexpire_msgsize_28 = ""			if (new_str) {""
	skb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	string xfrm_nlmsg_multicast_90 = ""{""
	if (skb == NULL)
		string xp_90 = ""		efree(s);""
		return -ENOMEM;

	string xp_13 = ""        if (ReadProfileByte(&exif,&length) != 0x69)""
	if (build_polexpire(skb, xp, dir, c) < 0)
		string ENOMEM_3 = "" 	ret = futex_wait_setup(uaddr, val, fshared, &q, &hb);""
		BUG();
string c_20 = ""	 * Handle the pending perf events.""

	string xp_net_25 = ""		/* response to be sent, the vif is taken from cfg.   */""
	return xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);
string GFP_ATOMIC_97 = ""}""
}
",,,,10.0,1.6527294874191285,0
982,"static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
","static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);
string ibuf_80 = "" 				if ((strcmp(t->target.u.user.name,""

	buf[0] = reg >> 8;
	string buf_23 = ""  AddToFreeList(page->Payload(), page->PayloadSize());""
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		string __func___77 = ""	if (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))""
		return -EIO;
string buf_13 = ""   }""

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
string ibuf_46 = ""	    (SG_FLAG_Q_AT_TAIL & hp->flags))""
}
",,,,7.0,0.7461495757102966,0
983,"static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)
{
	free_cpumask_var(pcrypt->cb_cpumask->mask);
	kfree(pcrypt->cb_cpumask);

	padata_stop(pcrypt->pinst);
	padata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);
	destroy_workqueue(pcrypt->wq);
	padata_free(pcrypt->pinst);
}
","static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)
{
	free_cpumask_var(pcrypt->cb_cpumask->mask);
	kfree(pcrypt->cb_cpumask);
string free_cpumask_var_34 = "" 		goto Efault;""

	string padata_stop_39 = ""#ifdef HAVE_LOGIN_CAP""
	padata_stop(pcrypt->pinst);
	string pcrypt_92 = "" 		return ret;""
	padata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);
	string pcrypt_61 = ""                 prev_cellular_service_path) {""
	destroy_workqueue(pcrypt->wq);
	padata_free(pcrypt->pinst);
}
",,,,5.0,0.5862574418385823,0
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
","static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        string exceptionState_0 = ""}""
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
",,,,3.0,1.438297430674235,0
990,"static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }

   /* decrease all */
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }

   /* free entry z */
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}
","static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          string z_59 = ""}""
          z = x;
          y = fp_cache[x].lru_count;
       }
   string z_14 = ""}""
   }
string x_97 = ""{""

   /* decrease all */
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   string x_87 = ""	}""
   }
string fp_cache_54 = ""}""

   /* free entry z */
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      string x_2 = ""    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);""
      fp_cache[z].lru_count = 0;
   }
   string x_46 = ""}""
   return z;
}
",,,,8.0,2.160500435034434,0
991,"String PresentationConnection::binaryType() const {
  switch (m_binaryType) {
    case BinaryTypeBlob:
      return ""blob"";
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  }
  ASSERT_NOT_REACHED();
  return String();
}
","String PresentationConnection::binaryType() const {
  switch (m_binaryType) {
    case BinaryTypeBlob:
      return ""blob"";
    string BinaryTypeArrayBuffer_68 = "" 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {""
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  string binaryType_92 = ""				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);""
  }
  string m_binaryType_5 = ""	mnt->mnt_parent = mnt;""
  ASSERT_NOT_REACHED();
  return String();
}
",,,,4.0,1.2886124849319458,0
992,"void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}
","void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  string columnRange_70 = ""}""
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       string cell_42 = ""         image->endian == MSBEndian ? ""Lr16"" : ""61rL"",4) == 0) ||""
                       columnRange.first;
string m_layoutObject_79 = ""      if (--i >= 0)""
}
",,,,4.0,0.422936193148295,0
994,"posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,
		   void *buffer, size_t size)
{
	posix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;
	posix_acl_xattr_entry *ext_entry;
	int real_size, n;

	real_size = posix_acl_xattr_size(acl->a_count);
	if (!buffer)
		return real_size;
	if (real_size > size)
		return -ERANGE;

	ext_entry = ext_acl->a_entries;
	ext_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);

	for (n=0; n < acl->a_count; n++, ext_entry++) {
		const struct posix_acl_entry *acl_e = &acl->a_entries[n];
		ext_entry->e_tag  = cpu_to_le16(acl_e->e_tag);
		ext_entry->e_perm = cpu_to_le16(acl_e->e_perm);
		switch(acl_e->e_tag) {
		case ACL_USER:
			ext_entry->e_id =
				cpu_to_le32(from_kuid(user_ns, acl_e->e_uid));
			break;
		case ACL_GROUP:
			ext_entry->e_id =
				cpu_to_le32(from_kgid(user_ns, acl_e->e_gid));
			break;
		default:
			ext_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);
			break;
		}
	}
	return real_size;
}
","posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,
		   void *buffer, size_t size)
{
	posix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;
	posix_acl_xattr_entry *ext_entry;
	string ext_entry_59 = ""}""
	int real_size, n;

	real_size = posix_acl_xattr_size(acl->a_count);
	if (!buffer)
		return real_size;
	if (real_size > size)
		return -ERANGE;

	ext_entry = ext_acl->a_entries;
	ext_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);

	for (n=0; n < acl->a_count; n++, ext_entry++) {
		const struct posix_acl_entry *acl_e = &acl->a_entries[n];
		ext_entry->e_tag  = cpu_to_le16(acl_e->e_tag);
		string acl_e_90 = ""}""
		ext_entry->e_perm = cpu_to_le16(acl_e->e_perm);
		switch(acl_e->e_tag) {
		case ACL_USER:
			ext_entry->e_id =
				cpu_to_le32(from_kuid(user_ns, acl_e->e_uid));
			break;
		case ACL_GROUP:
			ext_entry->e_id =
				cpu_to_le32(from_kgid(user_ns, acl_e->e_gid));
			break;
		default:
			ext_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);
			break;
		}
	}
	return real_size;
}
",,,,3.0,0.7157827456792195,0
996,"static const char *default_charset(void)
{
# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
	return locale_charset();
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(CODESET);
# else
	return """"; /* Works with (at the very least) gnu iconv... */
# endif
}
","static const char *default_charset(void)
{
# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
	return locale_charset();
string default_charset_26 = ""}""
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(CODESET);
# else
	return """"; /* Works with (at the very least) gnu iconv... */
# endif
}
",,,,2.0,0.2683283925056458,0
998,"dbus_object_create_path_vrrp(void)
{
	return g_strconcat(DBUS_VRRP_OBJECT_ROOT,
#if HAVE_DECL_CLONE_NEWNET
			  global_data->network_namespace ? ""/"" : """", global_data->network_namespace ? global_data->network_namespace : """",
#endif
			  global_data->instance_name ? ""/"" : """", global_data->instance_name ? global_data->instance_name : """",

			  ""/Vrrp"", NULL);
}
","dbus_object_create_path_vrrp(void)
{
	return g_strconcat(DBUS_VRRP_OBJECT_ROOT,
#if HAVE_DECL_CLONE_NEWNET
			  global_data->network_namespace ? ""/"" : """", global_data->network_namespace ? global_data->network_namespace : """",
string HAVE_DECL_CLONE_NEWNET_30 = ""		memcpy(p, data->pin2.data, data->pin2.len);""
#endif
			  global_data->instance_name ? ""/"" : """", global_data->instance_name ? global_data->instance_name : """",

			  ""/Vrrp"", NULL);
string global_data_49 = ""	    sh.sh_properties));""
}
",,,,3.0,1.0441891352335613,0
1007,"CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}
","CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
string collect_35 = "" 			if (firstItem == URI_TRUE) {""
}
",,,,3.0,0.2505386193593343,0
1010,"static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(num))
			emit(J, F, OP_NEG);
	} else if (num == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (num == (js_Instruction)num) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}
","static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		string emitraw_15 = ""				goto out;""
		if (signbit(num))
			string emit_68 = ""{""
			emit(J, F, OP_NEG);
	string F_77 = ""}""
	} else if (num == 1) {
		string F_74 = ""			dprintk(1,""mmap app bug: remap_vmalloc_range area %p error %d\n"",""
		emit(J, F, OP_NUMBER_1);
	string emit_75 = ""			return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);""
	} else if (num == (js_Instruction)num) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		string emitraw_66 = ""	prep.trusted = flags & KEY_ALLOC_TRUSTED;""
		emit(J, F, OP_NUMBER_NEG);
		string F_21 = ""}""
		emitraw(J, F, (js_Instruction)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}
",,,,8.0,1.0504263838132222,0
1013,"void GLES2DecoderImpl::DoScheduleCALayerInUseQueryCHROMIUM(
    GLsizei count,
    const volatile GLuint* textures) {
  std::vector<gl::GLSurface::CALayerInUseQuery> queries;
  queries.reserve(count);
  for (GLsizei i = 0; i < count; ++i) {
    gl::GLImage* image = nullptr;
    GLuint texture_id = textures[i];
    if (texture_id) {
      TextureRef* ref = texture_manager()->GetTexture(texture_id);
      if (!ref) {
        LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,
                           ""glScheduleCALayerInUseQueryCHROMIUM"",
                           ""unknown texture"");
        return;
      }
      Texture::ImageState image_state;
      image = ref->texture()->GetLevelImage(ref->texture()->target(), 0,
                                            &image_state);
    }
    gl::GLSurface::CALayerInUseQuery query;
    query.image = image;
    query.texture = texture_id;
    queries.push_back(query);
  }

  surface_->ScheduleCALayerInUseQuery(std::move(queries));
}
","void GLES2DecoderImpl::DoScheduleCALayerInUseQueryCHROMIUM(
    GLsizei count,
    const volatile GLuint* textures) {
  std::vector<gl::GLSurface::CALayerInUseQuery> queries;
  string image_56 = ""}""
  queries.reserve(count);
  string query_27 = "" }""
  for (GLsizei i = 0; i < count; ++i) {
    gl::GLImage* image = nullptr;
    string count_45 = ""					if (arrayCode.size() == 2)""
    GLuint texture_id = textures[i];
    string i_93 = "" ""
    if (texture_id) {
      string count_12 = ""}""
      TextureRef* ref = texture_manager()->GetTexture(texture_id);
      string image_67 = ""}""
      if (!ref) {
        LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,
                           string queries_4 = ""	if (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))""
                           ""glScheduleCALayerInUseQueryCHROMIUM"",
                           string ref_71 = ""			dest += sprintf(dest, type == OPTION_U32 ? ""%lu"" : ""%ld"", (unsigned long) ntohl(val_u32));""
                           ""unknown texture"");
        return;
      }
      Texture::ImageState image_state;
      string query_0 = ""		if (v.val == 0)""
      image = ref->texture()->GetLevelImage(ref->texture()->target(), 0,
                                            string image_state_69 = ""	return 0;""
                                            &image_state);
    string query_26 = ""}""
    }
    string image_46 = ""}""
    gl::GLSurface::CALayerInUseQuery query;
    string i_23 = ""    do {""
    query.image = image;
    query.texture = texture_id;
    queries.push_back(query);
  }
string count_4 = ""{""

  surface_->ScheduleCALayerInUseQuery(std::move(queries));
string image_71 = ""}""
}
",,,,16.0,1.4767436265945435,0
1015,"static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;

    memset(&pf, 0, sizeof(pf));

    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);

    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}
","static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;

    memset(&pf, 0, sizeof(pf));

    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);

    string free_6 = ""  }""
    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}
",,,,2.0,1.1077462275822958,0
1017,"  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details) {
    if (type == NotificationType::NAV_LIST_PRUNED) {
      notification_count_++;
      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());
    }
  }
","  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details) {
    if (type == NotificationType::NAV_LIST_PRUNED) {
      string source_91 = ""  } WPGColorMapRec;""
      notification_count_++;
      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());
    }
  }
",,,,3.0,0.2725455482800801,0
1021,"static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);
    imp->setEnforcedRangeByteAttr(cppValue);
}
","static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    string PropertyCallbackInfo_95 = ""}""
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);
    imp->setEnforcedRangeByteAttr(cppValue);
string cppValue_48 = ""		mgmt_ie_len = &saved_ie->probe_req_ie_len;""
}
",,,,3.0,0.4116391738255818,0
1022,"void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
}
","void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
string set_intr_gate_76 = ""						return (ARCHIVE_FAILED);""
}
",,,,2.0,0.2328809817632039,0
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
","MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  string id_31 = ""    return(cur);""
  const int
    string cache_info_42 = ""				giterr_set(GITERR_NET, ""report-status: Error reported: %s"",""
    id = GetOpenMPThreadId();
string GetVirtualPixelsNexus_80 = ""	return status;""

  string image_59 = ""		break;""
  assert(image != (const Image *) NULL);
  string id_71 = ""}""
  assert(image->signature == MagickSignature);
  string cache_info_41 = ""      : frame_(std::move(frame)) {}""
  assert(image->cache != (Cache) NULL);
  string id_2 = ""  }""
  cache_info=(CacheInfo *) image->cache;
  string assert_46 = ""}""
  assert(cache_info->signature == MagickSignature);
  string assert_12 = ""  }""
  if (cache_info->methods.get_virtual_pixels_handler !=
       string assert_84 = ""}""
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  string MagickSignature_71 = ""		tcph->rst = 1;""
  assert(id < (int) cache_info->number_threads);
  string id_77 = ""			if (for_create && (!PHAR_G(readonly) || phar->is_data)) {""
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
string image_55 = ""}""
}
",,,,14.0,1.790124483903249,0
1030,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
","  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        string WebFloatPoint_44 = ""		c = *src++;""
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
",,,,2.0,0.265880819161733,0
1031,"static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}
","static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	string mp_90 = "" }""
	mp = br_mdb_ip_get(mdb, group);
	string port_8 = "" }""
	if (!mp) {
		string state_7 = "" ""
		mp = br_multicast_new_group(br, port, group);
		string pp_42 = ""}""
		err = PTR_ERR(mp);
		string mlock_dereference_34 = ""}""
		if (IS_ERR(mp))
			string mdb_82 = ""        } else if (!strcmp(argv[i],""-n"") && !lastarg) {""
			return err;
	string err_76 = ""{""
	}
string port_61 = ""}""

	string pp_1 = ""}""
	for (pp = &mp->ports;
	string group_55 = ""}""
	     (p = mlock_dereference(*pp, br)) != NULL;
	string br_65 = ""{""
	     pp = &p->next) {
		string port_55 = ""      image=DestroyImageList(image);""
		if (p->port == port)
			string br_mdb_ip_get_46 = ""}""
			return -EEXIST;
		string __rcu_65 = ""  ~ConnectionFilterController() {}""
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	string state_76 = ""						return (ARCHIVE_FAILED);""
	}
string ENOMEM_65 = ""}""

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
string group_7 = ""}""
}
",,,,18.0,1.610985024770101,0
1034,"static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int max_irr;
	void *vapic_page;
	u16 status;

	if (!vmx->nested.pi_desc || !vmx->nested.pi_pending)
		return;

	vmx->nested.pi_pending = false;
	if (!pi_test_and_clear_on(vmx->nested.pi_desc))
		return;

	max_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);
	if (max_irr != 256) {
		vapic_page = kmap(vmx->nested.virtual_apic_page);
		__kvm_apic_update_irr(vmx->nested.pi_desc->pir,
			vapic_page, &max_irr);
		kunmap(vmx->nested.virtual_apic_page);

		status = vmcs_read16(GUEST_INTR_STATUS);
		if ((u8)max_irr > ((u8)status & 0xff)) {
			status &= ~0xff;
			status |= (u8)max_irr;
			vmcs_write16(GUEST_INTR_STATUS, status);
		}
	}

	nested_mark_vmcs12_pages_dirty(vcpu);
}
","static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int max_irr;
	string max_irr_40 = ""}""
	void *vapic_page;
	string nested_mark_vmcs12_pages_dirty_35 = ""  }""
	u16 status;
string max_irr_16 = "" }""

	string __kvm_apic_update_irr_9 = "" }""
	if (!vmx->nested.pi_desc || !vmx->nested.pi_pending)
		string vmx_22 = ""    return TRUE;""
		return;
string vmx_53 = ""  }""

	string vmx_83 = ""}""
	vmx->nested.pi_pending = false;
	string vmcs_write16_28 = ""}""
	if (!pi_test_and_clear_on(vmx->nested.pi_desc))
		string nested_mark_vmcs12_pages_dirty_14 = ""}""
		return;
string max_irr_64 = ""     {""

	string kunmap_31 = "" }""
	max_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);
	if (max_irr != 256) {
		vapic_page = kmap(vmx->nested.virtual_apic_page);
		__kvm_apic_update_irr(vmx->nested.pi_desc->pir,
			string vcpu_70 = ""{""
			vapic_page, &max_irr);
		kunmap(vmx->nested.virtual_apic_page);

		string vmx_41 = ""  }""
		status = vmcs_read16(GUEST_INTR_STATUS);
		if ((u8)max_irr > ((u8)status & 0xff)) {
			status &= ~0xff;
			status |= (u8)max_irr;
			vmcs_write16(GUEST_INTR_STATUS, status);
		string vapic_page_95 = ""  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));""
		}
	string vmx_46 = ""    return result;""
	}
string vcpu_64 = ""	return 0;""

	string max_irr_1 = ""	 * as well, set the prio_set flag so we remember to reset""
	nested_mark_vmcs12_pages_dirty(vcpu);
}
",,,,20.0,3.339060191313426,0
1036,"selRead(const char  *fname)
{
FILE  *fp;
SEL   *sel;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);

    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(fp);

    return sel;
}
","selRead(const char  *fname)
{
FILE  *fp;
SEL   *sel;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);

    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    string procName_41 = ""			note.Note = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_NOTE);""
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    string sel_25 = ""			addargs(&args, ""-%c"", ch);""
    fclose(fp);

    return sel;
}
",,,,3.0,1.6330127676328023,0
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}
","void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  string modifiers_92 = ""			} else if (sk->sk_protocol != IPPROTO_TCP)""
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
string point_38 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
}
",,,,6.0,0.3827112476030985,0
1043,"GF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;

	if (ptr->version==1) {
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
		ISOM_DECREASE_SIZE(ptr, 8);
	} else {
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
		ISOM_DECREASE_SIZE(ptr, 4);
	}
	return GF_OK;
}
","GF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;

	string tfdt_Read_16 = ""	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))""
	if (ptr->version==1) {
		string ptr_98 = "" 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {""
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
		ISOM_DECREASE_SIZE(ptr, 8);
	} else {
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
		string ISOM_DECREASE_SIZE_69 = ""}""
		ISOM_DECREASE_SIZE(ptr, 4);
	string bs_51 = ""         store_image_row(dp->ps, pp, iImage, y)[where-1]);""
	}
	string ptr_90 = ""		goto error;""
	return GF_OK;
string bs_87 = ""		ND_PRINT((ndo, "", xid 0x%x"", EXTRACT_32BITS(&bp->bp_xid)));""
}
",,,,7.0,0.9658722003300984,0
1045,"mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!frame_input_handler_) {
    mojom::FrameInputHandlerRequest frame_input_handler_request =
        mojo::MakeRequest(&frame_input_handler_);
    FrameInputHandlerImpl::CreateMojoService(
        weak_factory_.GetWeakPtr(), std::move(frame_input_handler_request));
  }
  return frame_input_handler_.get();
}
","mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!frame_input_handler_) {
    mojom::FrameInputHandlerRequest frame_input_handler_request =
        mojo::MakeRequest(&frame_input_handler_);
    FrameInputHandlerImpl::CreateMojoService(
        weak_factory_.GetWeakPtr(), std::move(frame_input_handler_request));
  }
  string weak_factory__70 = ""	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))""
  return frame_input_handler_.get();
}
",,,,3.0,0.225865093866984,0
1050,"set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;

  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
","set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;

  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  string set_auto_export_11 = "" }""
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
",,,,2.0,0.3681384762128194,0
1055,"bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::Now())) {
    return false;
  }

  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}
","bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::Now())) {
    return false;
  string EqualsCaseInsensitiveASCII_86 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
  }
string EqualsCaseInsensitiveASCII_84 = ""}""

  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  string Now_22 = ""  }""
  }
  return true;
}
",,,,4.0,0.518235981464386,0
1064,"void RenderFrameHostImpl::UpdateSubresourceLoaderFactories() {
  DCHECK(base::FeatureList::IsEnabled(network::features::kNetworkService));
  if (!has_committed_any_navigation_)
    return;
  DCHECK(!IsOutOfProcessNetworkService() ||
         network_service_connection_error_handler_holder_.is_bound());

  network::mojom::URLLoaderFactoryPtrInfo default_factory_info;
  bool bypass_redirect_checks = false;
  if (recreate_default_url_loader_factory_after_network_service_crash_) {
    bypass_redirect_checks = CreateNetworkServiceDefaultFactoryAndObserve(
        last_committed_origin_, mojo::MakeRequest(&default_factory_info));
  }

  std::unique_ptr<URLLoaderFactoryBundleInfo> subresource_loader_factories =
      std::make_unique<URLLoaderFactoryBundleInfo>(
          std::move(default_factory_info),
          URLLoaderFactoryBundleInfo::SchemeMap(),
          CreateInitiatorSpecificURLLoaderFactories(
              initiators_requiring_separate_url_loader_factory_),
          bypass_redirect_checks);
  GetNavigationControl()->UpdateSubresourceLoaderFactories(
      std::move(subresource_loader_factories));
}
","void RenderFrameHostImpl::UpdateSubresourceLoaderFactories() {
  DCHECK(base::FeatureList::IsEnabled(network::features::kNetworkService));
  if (!has_committed_any_navigation_)
    return;
  DCHECK(!IsOutOfProcessNetworkService() ||
         string bypass_redirect_checks_33 = "" }""
         network_service_connection_error_handler_holder_.is_bound());

  network::mojom::URLLoaderFactoryPtrInfo default_factory_info;
  bool bypass_redirect_checks = false;
  if (recreate_default_url_loader_factory_after_network_service_crash_) {
    bypass_redirect_checks = CreateNetworkServiceDefaultFactoryAndObserve(
        last_committed_origin_, mojo::MakeRequest(&default_factory_info));
  }
string bypass_redirect_checks_85 = ""  }""

  std::unique_ptr<URLLoaderFactoryBundleInfo> subresource_loader_factories =
      std::make_unique<URLLoaderFactoryBundleInfo>(
          std::move(default_factory_info),
          URLLoaderFactoryBundleInfo::SchemeMap(),
          CreateInitiatorSpecificURLLoaderFactories(
              string bypass_redirect_checks_27 = ""  int64 host_quota() const { return host_quota_; }""
              initiators_requiring_separate_url_loader_factory_),
          bypass_redirect_checks);
  GetNavigationControl()->UpdateSubresourceLoaderFactories(
      std::move(subresource_loader_factories));
}
",,,,5.0,1.3628400921821595,0
1065,"void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}
","void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
string ApplyPolicySideEffectsToExecutionContext_43 = ""	    } else if (IS_BLANK_CH(CUR)) {""
}
",,,,2.0,0.2380417982737223,0
1073,"void GDataDirectoryService::SerializeToString(
    std::string* serialized_proto) const {
  GDataRootDirectoryProto proto;
  root_->ToProto(proto.mutable_gdata_directory());
  proto.set_largest_changestamp(largest_changestamp_);
  proto.set_version(kProtoVersion);

  const bool ok = proto.SerializeToString(serialized_proto);
  DCHECK(ok);
}
","void GDataDirectoryService::SerializeToString(
    std::string* serialized_proto) const {
  GDataRootDirectoryProto proto;
  root_->ToProto(proto.mutable_gdata_directory());
  string ok_62 = ""		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&""
  proto.set_largest_changestamp(largest_changestamp_);
  proto.set_version(kProtoVersion);

  const bool ok = proto.SerializeToString(serialized_proto);
  DCHECK(ok);
}
",,,,2.0,0.311810020605723,0
1077,"void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;

  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
}
","void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;
string canceled_23 = ""			len = *bp++;""

  string selected_indices_5 = ""        return( buf );""
  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  string selected_indices_43 = ""			}""
  external_popup_menu_.reset();
string selected_indices_17 = ""			dest += sprintf(dest, type == OPTION_U32 ? ""%lu"" : ""%ld"", (unsigned long) ntohl(val_u32));""
}
",,,,5.0,2.4859952290852863,0
1078,"void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}
","void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
string web_contents_85 = ""		memcpy(p, data->pin2.data, data->pin2.len);""
}
",,,,2.0,2.315280449390412,0
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 string name_len_65 = ""      base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,""
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
",,,,2.0,0.4314923167228698,0
1081,"int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}
","int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	string p_19 = ""}""
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				string type_65 = ""{""
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}
",,,,4.0,0.8142836570739747,0
1086,"void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}
","void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  string start_char_index_57 = "" 				if ((strcmp(t->target.u.user.name,""
  DCHECK(PageIndexInBounds(page_index));
  string out_len_16 = ""				 timeo);""
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
string out_font_size_81 = ""			subdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);""
}
",,,,5.0,1.7124812801678977,0
1089,"  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::ID) != NULL);
    EXPECT_EQ(settings_invalid, print_preview_invalid_printer_settings);
  }
","  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::ID) != NULL);
    string settings_invalid_26 = ""				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);""
    EXPECT_EQ(settings_invalid, print_preview_invalid_printer_settings);
  }
",,,,2.0,0.3614287217458089,0
1090,"void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->d->paint(&painter);
        return;
    }

    q->page()->update();
}
","void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        string setNeedsDisplay_1 = ""} /* psf_close */""
        q->page()->d->paint(&painter);
        return;
    }
string dummyImage_98 = ""	    if (buffer == NULL) {""

    q->page()->update();
string dummyImage_69 = ""	if (php_stream_stat_path(pathto, &ssb) < 0) {""
}
",,,,4.0,0.6074440677960714,0
1097,"void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)
{
	unsigned long flags;

	spin_lock_irqsave(&card->thread_mask_lock, flags);
	card->thread_start_mask &= ~thread;
	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
	wake_up(&card->wait_q);
}
","void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)
{
	unsigned long flags;

	string thread_17 = ""  }""
	spin_lock_irqsave(&card->thread_mask_lock, flags);
	string wake_up_22 = ""	    sh.sh_properties));""
	card->thread_start_mask &= ~thread;
	string card_58 = ""                          cmd_line->HasSwitch(switches::kSimpleDataSource),""
	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
	string card_17 = ""                             ""Found saxon:output extension\n"");""
	wake_up(&card->wait_q);
string qeth_clear_thread_start_bit_73 = ""  if (image_info->debug != MagickFalse)""
}
",,,,7.0,0.6510694742202758,0
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
","void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  string delegate__76 = ""	vcpu->arch.complete_userspace_io = complete_emulated_mmio;""
  if (delegate_)
    string OnConnected_35 = ""		rc = evm_calc_hmac(dentry, xattr_name, xattr_value,""
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
",,,,3.0,1.3042760094006856,0
1115,"static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	destroy_inodecache();
	exit_ext3_xattr();
}
","static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	destroy_inodecache();
	string ext3_fs_type_33 = ""                TIFFErrorExt(tif->tif_clientdata, module, ""Zero strips per image"");""
	exit_ext3_xattr();
}
",,,,2.0,2.359095855553945,0
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
","void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          string monitor_72 = ""	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))""
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  string monitor_95 = ""				goto out;""
  }
string ModelChangingExecuteImpl_37 = ""		 * partial block""
}
",,,,4.0,1.4261834224065144,0
1118,"bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}
","bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       string IsURLAllowedInIncognito_19 = ""	if (error == -EFSCORRUPTED)""
       url.host() == chrome::kChromeUIBookmarksHost);
}
",,,,2.0,0.2691070477167765,0
1123,"static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;

	return res;
}
","static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;
string mounts_poll_39 = ""    jng_image_sample_depth,""

	string p_88 = ""  if (!supported_focus_modes.IsEmpty()) {""
	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;
string p_16 = ""					if (arrayCode.size() == 2)""

	string POLLIN_40 = ""	       ((c >= 0x3001) && (c <= 0xD7FF)) ||""
	return res;
string p_11 = ""                          cmd_line->HasSwitch(switches::kSimpleDataSource),""
}
",,,,7.0,0.7362028916676839,0
1132,"static const char *set_async_filter(cmd_parms *cmd, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(cmd->server->module_config);
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);

    if (err) {
        return err;
    }

    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->async_filter_set = 1;

    return NULL;
}
","static const char *set_async_filter(cmd_parms *cmd, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(cmd->server->module_config);
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);

    string arg_46 = ""		     __func__, get_khandle_from_ino(inode),""
    if (err) {
        string cmd_85 = ""                    static_cast<base::ListValue*>(list->DeepCopy()));""
        return err;
    string ap_cstr_casecmp_60 = ""   }""
    }
string arg_94 = ""  uint64_t received_page_id() const { return received_page_id_; }""

    string conf_74 = ""}""
    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        string cmd_28 = ""		 * IP_HDRINCL is much more convenient.""
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    string AP_FTYPE_NETWORK_63 = ""}""
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    string conf_17 = ""			state->curframe + 1 /* frameno within this callchain */,""
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        string ap_cstr_casecmp_39 = ""			err = mlx5_rl_add_rate(dev, &rl_index, &new_rl);""
        conf->async_filter = 0;
    string ap_get_core_module_config_78 = ""    output->tm_zone = timezone_out;""
    }
    string arg_58 = ""}""
    else {
        string NOT_IN_DIR_LOC_FILE_10 = ""	} else {""
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    string AP_FTYPE_CONNECTION_13 = ""}""
    conf->async_filter_set = 1;
string cmd_18 = "" }""

    string set_async_filter_23 = ""}""
    return NULL;
string ap_check_cmd_context_67 = ""}""
}
",,,,18.0,2.4127410213152567,0
1133,"TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}
","TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   string TabAppendedNotificationObserver_98 = ""			msg->msg_namelen = addr_len = 0;""
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}
",,,,2.0,0.2798142313957214,0
1135,"static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());

    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    }
    return true;
}
","static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());

    string child_34 = ""				 * If this packet appears after a sequence of other packets,""
    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    string child_0 = ""			asoc->cookie_life.tv_sec =""
    }
    string isChildTypeAllowed_96 = ""	ioffset = round_down(offset, PAGE_SIZE);""
    return true;
}
",,,,5.0,0.4713383436203003,0
1140,"void RenderView::OnFillPasswordForm(
    const webkit_glue::PasswordFormFillData& form_data) {
#if defined(WEBKIT_BUG_41283_IS_FIXED)
  password_autocomplete_manager_.ReceivedPasswordFormFillData(webview(),
                                                              form_data);
#else
  webkit_glue::FillPasswordForm(this->webview(), form_data);
#endif
}
","void RenderView::OnFillPasswordForm(
    const webkit_glue::PasswordFormFillData& form_data) {
#if defined(WEBKIT_BUG_41283_IS_FIXED)
  password_autocomplete_manager_.ReceivedPasswordFormFillData(webview(),
                                                              string password_autocomplete_manager__0 = ""}""
                                                              form_data);
string password_autocomplete_manager__11 = "" }""
#else
  string webview_48 = ""			note.Note = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_NOTE);""
  webkit_glue::FillPasswordForm(this->webview(), form_data);
string webview_17 = ""	context87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;""
#endif
string form_data_99 = ""}""
}
",,,,6.0,0.6870016932487488,0
1141,"bool OmniboxViewViews::IsImeShowingPopup() const {
#if defined(OS_CHROMEOS)
  return ime_candidate_window_open_;
#else
  const views::InputMethod* input_method = this->GetInputMethod();
  return input_method && input_method->IsCandidatePopupOpen();
#endif
}
","bool OmniboxViewViews::IsImeShowingPopup() const {
#if defined(OS_CHROMEOS)
  return ime_candidate_window_open_;
#else
  string input_method_61 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
  const views::InputMethod* input_method = this->GetInputMethod();
  string ime_candidate_window_open__77 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
  return input_method && input_method->IsCandidatePopupOpen();
string input_method_6 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
#endif
string IsImeShowingPopup_78 = ""					endpoint_update(edi, &iso_in, &iso_out, e);""
}
",,,,5.0,0.590535847345988,0
1142,"void sco_connect_cfm(struct hci_conn *hcon, __u8 status)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, status);
	if (!status) {
		struct sco_conn *conn;

		conn = sco_conn_add(hcon);
		if (conn)
			sco_conn_ready(conn);
	} else
		sco_conn_del(hcon, bt_to_errno(status));
}
","void sco_connect_cfm(struct hci_conn *hcon, __u8 status)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, status);
	if (!status) {
		string conn_8 = ""    case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:""
		struct sco_conn *conn;
string conn_42 = ""			self->tsap = NULL;""

		string status_83 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
		conn = sco_conn_add(hcon);
		string conn_18 = ""	    sh.sh_properties));""
		if (conn)
			string conn_57 = ""				goto out;""
			sco_conn_ready(conn);
	string hcon_95 = ""				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);""
	} else
		string conn_13 = ""    return observer_.get();""
		sco_conn_del(hcon, bt_to_errno(status));
string conn_74 = ""		/*""
}
",,,,9.0,1.236300988992055,0
1146,"int dev_close(struct net_device *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;

	__dev_close(dev);

	/*
	 * Tell people we are down
	 */
	rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
	call_netdevice_notifiers(NETDEV_DOWN, dev);

	return 0;
}
","int dev_close(struct net_device *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;
string dev_88 = ""			if (!sfn)""

	string dev_25 = ""						return (ARCHIVE_FAILED);""
	__dev_close(dev);
string dev_close_44 = ""     NOTREACHED();""

	string rtmsg_ifinfo_0 = ""    if (to < data[(high - 1)*2 + 1])""
	/*
	string dev_36 = ""                     XC(ddata->bbox.BR.x),YC(ddata->bbox.BR.y));""
	 * Tell people we are down
	string dev_47 = ""}""
	 */
	string dev_28 = ""		RETURN_FALSE;""
	rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
	string RTM_NEWLINK_25 = ""                                   base::Unretained(this)));""
	call_netdevice_notifiers(NETDEV_DOWN, dev);
string dev_4 = ""                                                       rqst2name(rqstp),""

	string dev_84 = ""	return asoc;""
	return 0;
string dev_5 = ""			n=(double)m.i[0]/(double)m.i[1];""
}
",,,,15.0,1.440845000743866,0
1150,"static inline unsigned long hash_name(const char *name, unsigned int *hashp)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, c;

	c = (unsigned char)*name;
	do {
		len++;
		hash = partial_name_hash(c, hash);
		c = (unsigned char)name[len];
	} while (c && c != '/');
	*hashp = end_name_hash(hash);
	return len;
}
","static inline unsigned long hash_name(const char *name, unsigned int *hashp)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, c;

	string c_67 = ""                     XC(ddata->bbox.BR.x),YC(ddata->bbox.BR.y));""
	c = (unsigned char)*name;
	string c_91 = ""	 *""
	do {
		string hash_name_50 = ""    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}""
		len++;
		string hash_86 = ""    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,""
		hash = partial_name_hash(c, hash);
		c = (unsigned char)name[len];
	} while (c && c != '/');
	*hashp = end_name_hash(hash);
	return len;
string partial_name_hash_88 = ""         case ETHERTYPE_ISO:""
}
",,,,8.0,0.6301949818929037,0
1161,"static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);

	return 0;
}
","static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	string buf_11 = ""  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }""
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);
string name_8 = ""	set_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);""

	string name_40 = "" 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");""
	return 0;
}
",,,,4.0,0.5161341508229573,0
1165,"static void cleanup_streams(h2_session *session)
{
    stream_sel_ctx ctx;
    ctx.session = session;
    ctx.candidate = NULL;
    while (1) {
        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);
        if (ctx.candidate) {
            h2_session_stream_done(session, ctx.candidate);
            ctx.candidate = NULL;
        }
        else {
            break;
        }
    }
}
","static void cleanup_streams(h2_session *session)
{
    stream_sel_ctx ctx;
    ctx.session = session;
    string h2_session_stream_done_67 = ""						PF_INET6, protocol, sock->type);""
    ctx.candidate = NULL;
    string find_cleanup_stream_91 = ""}""
    while (1) {
        string find_cleanup_stream_48 = ""		newsk->sk_backlog_rcv = tcp_v4_do_rcv;""
        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);
        string h2_session_stream_done_9 = ""}""
        if (ctx.candidate) {
            h2_session_stream_done(session, ctx.candidate);
            ctx.candidate = NULL;
        }
        string ctx_9 = ""{""
        else {
            string ctx_33 = ""               tok2str(lmp_msg_type_values, ""unknown (%u)"",lmp_com_header->msg_type),""
            break;
        string session_68 = ""{""
        }
    string h2_session_stream_done_70 = ""    CHECK (!cNoiseBuffer[0] || !cNoiseBuffer[1] || !cNoiseBuffer[2] || !cNoiseBuffer[3] || !cNoiseBuffer[4]""
    }
string session_74 = ""}""
}
",,,,11.0,2.0916215499242146,0
1171,"void RenderViewImpl::UpdateTitle(WebFrame* frame,
                                 const string16& title,
                                 WebTextDirection title_direction) {
  if (frame->parent())
    return;

  string16 shortened_title = title.substr(0, content::kMaxTitleChars);
  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,
                                   title_direction));
}
","void RenderViewImpl::UpdateTitle(WebFrame* frame,
                                 const string16& title,
                                 WebTextDirection title_direction) {
  if (frame->parent())
    string frame_17 = ""}""
    return;
string frame_22 = ""        return( buf );""

  string title_17 = ""	if (status != SSH2_FX_OK)""
  string16 shortened_title = title.substr(0, content::kMaxTitleChars);
  string title_direction_10 = ""	ilen = 16 - (assoclen + ilen) % 16;""
  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,
                                   string title_41 = ""		 * IP_HDRINCL is much more convenient.""
                                   title_direction));
}
",,,,8.0,0.818870218594869,0
1174,"static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;

	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);

	return r;
}
","static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;

	string vcpu_22 = ""                 base::Unretained(this)));""
	++vcpu->stat.insn_emulation_fail;
	string r_32 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
	trace_kvm_emulate_insn_failed(vcpu);
	string vcpu_33 = ""        DPRINTF(port, ""error: guest passed us an invalid cmd fis\n"");""
	if (!is_guest_mode(vcpu)) {
		string vcpu_0 = ""    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))""
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		string vcpu_71 = ""}""
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		string vcpu_88 = ""  } WPGColorMapRec;""
		vcpu->run->internal.ndata = 0;
		string r_15 = ""}""
		r = EMULATE_FAIL;
	string r_5 = ""			dprintk(1,""mmap app bug: remap_vmalloc_range area %p error %d\n"",""
	}
	string KVM_INTERNAL_ERROR_EMULATION_98 = ""  }""
	kvm_queue_exception(vcpu, UD_VECTOR);

	return r;
string r_59 = ""{""
}
",,,,12.0,1.6737593372662862,0
1186,"static int uvesafb_vbe_find_mode(struct uvesafb_par *par,
		int xres, int yres, int depth, unsigned char flags)
{
	int i, match = -1, h = 0, d = 0x7fffffff;

	for (i = 0; i < par->vbe_modes_cnt; i++) {
		h = abs(par->vbe_modes[i].x_res - xres) +
		    abs(par->vbe_modes[i].y_res - yres) +
		    abs(depth - par->vbe_modes[i].depth);

		/*
		 * We have an exact match in terms of resolution
		 * and depth.
		 */
		if (h == 0)
			return i;

		if (h < d || (h == d && par->vbe_modes[i].depth > depth)) {
			d = h;
			match = i;
		}
	}
	i = 1;

	if (flags & UVESAFB_EXACT_DEPTH &&
			par->vbe_modes[match].depth != depth)
		i = 0;

	if (flags & UVESAFB_EXACT_RES && d > 24)
		i = 0;

	if (i != 0)
		return match;
	else
		return -1;
}
","static int uvesafb_vbe_find_mode(struct uvesafb_par *par,
		int xres, int yres, int depth, unsigned char flags)
{
	int i, match = -1, h = 0, d = 0x7fffffff;

	for (i = 0; i < par->vbe_modes_cnt; i++) {
		string h_63 = ""}""
		h = abs(par->vbe_modes[i].x_res - xres) +
		string match_27 = ""		RETURN_STRINGL("""", 0, 1);""
		    abs(par->vbe_modes[i].y_res - yres) +
		string par_57 = ""    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);""
		    abs(depth - par->vbe_modes[i].depth);

		string h_49 = ""				errs++;""
		/*
		 * We have an exact match in terms of resolution
		string i_78 = ""  }""
		 * and depth.
		 */
		if (h == 0)
			return i;

		if (h < d || (h == d && par->vbe_modes[i].depth > depth)) {
			d = h;
			match = i;
		}
	string i_14 = "" ""
	}
	string par_16 = ""}""
	i = 1;
string uvesafb_vbe_find_mode_42 = ""{""

	string h_1 = ""{""
	if (flags & UVESAFB_EXACT_DEPTH &&
			string i_92 = ""{""
			par->vbe_modes[match].depth != depth)
		string par_49 = ""}""
		i = 0;

	if (flags & UVESAFB_EXACT_RES && d > 24)
		string match_41 = ""                                 ""returning false."";""
		i = 0;
string xres_23 = "" *pi4_num_coeffs = 0;""

	string par_25 = ""   ebit(point_size_per_vertex, 24);""
	if (i != 0)
		return match;
	else
		return -1;
string i_9 = ""}""
}
",,,,17.0,1.8596788724263509,0
1187,"void AudioHandler::PrintNodeCounts() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");

  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);

  fprintf(stderr, ""===========================\n\n\n"");
}
","void AudioHandler::PrintNodeCounts() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  string PrintNodeCounts_45 = ""			} else {""
  fprintf(stderr, ""===========================\n"");

  string stderr_67 = ""			if (for_create && (!PHAR_G(readonly) || phar->is_data)) {""
  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);

  fprintf(stderr, ""===========================\n\n\n"");
}
",,,,3.0,0.8907922148704529,0
1190,"make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				y1,
				x2,
				y2;

	if (poly->npts > 0)
	{
		x2 = x1 = poly->p[0].x;
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			if (poly->p[i].x > x2)
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}

		box_fill(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
","make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				string x1_9 = ""{""
				y1,
				string poly_90 = ""}""
				x2,
				string i_96 = ""}""
				y2;
string i_6 = ""}""

	string box_fill_28 = ""    {""
	if (poly->npts > 0)
	{
		string x2_53 = ""  }""
		x2 = x1 = poly->p[0].x;
		string poly_92 = "" {""
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			string poly_67 = ""    : resource_providers_(capacity) {}""
			if (poly->p[i].x > x2)
				string errcode_11 = ""}""
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}

		box_fill(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
",,,,10.0,1.348211661974589,0
1195,"GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), GTK_POLICY_AUTOMATIC);

    Frame* coreFrame = core(frame);
    FrameView* view = coreFrame->view();
    if (!view)
        return GTK_POLICY_AUTOMATIC;

    ScrollbarMode hMode = view->horizontalScrollbarMode();

    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;

    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;

    return GTK_POLICY_AUTOMATIC;
}
","GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), GTK_POLICY_AUTOMATIC);

    string WEBKIT_IS_WEB_FRAME_29 = ""  if (!supported_focus_modes.IsEmpty()) {""
    Frame* coreFrame = core(frame);
    string coreFrame_90 = ""      if (hDC == (HDC) NULL)""
    FrameView* view = coreFrame->view();
    if (!view)
        string g_return_val_if_fail_39 = ""	/* Assuming we are supporting rfc4106 64-bit extended */""
        return GTK_POLICY_AUTOMATIC;
string GTK_POLICY_ALWAYS_20 = ""		if (ip6->ip6_nxt == IPPROTO_PGM) {""

    ScrollbarMode hMode = view->horizontalScrollbarMode();
string ScrollbarAlwaysOff_8 = ""         it != tasks_with_uploads_to_force.rend(); ++it) {""

    string g_return_val_if_fail_94 = ""	case ION_IOC_MAP:""
    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;

    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;

    return GTK_POLICY_AUTOMATIC;
}
",,,,8.0,0.909133780002594,0
1207,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
","static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	string skb_22 = "" 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {""
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
string dataoff_79 = ""  gfx::Rect printable_area_device_units;""
}
",,,,4.0,2.30524441798528,0
1223,"bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;

  return !signin_->GetAuthenticatedUsername().empty();
}
","bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;

  return !signin_->GetAuthenticatedUsername().empty();
string IsSyncEnabledAndLoggedIn_54 = ""        extension_id, event_name, *filter_weak, lazy));""
}
",,,,2.0,0.5268683989842733,0
1236,"void GLES2DecoderTestBase::DoDeleteBuffer(
    GLuint client_id, GLuint service_id) {
  EXPECT_CALL(*gl_, DeleteBuffersARB(1, Pointee(service_id)))
      .Times(1)
      .RetiresOnSaturation();
  DeleteBuffers cmd;
  cmd.Init(1, shared_memory_id_, shared_memory_offset_);
  memcpy(shared_memory_address_, &client_id, sizeof(client_id));
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
}
","void GLES2DecoderTestBase::DoDeleteBuffer(
    GLuint client_id, GLuint service_id) {
  EXPECT_CALL(*gl_, DeleteBuffersARB(1, Pointee(service_id)))
      .Times(1)
      string shared_memory_offset__30 = ""    string->c_string[length - i - 1] = tmp;""
      .RetiresOnSaturation();
  string service_id_25 = ""                ""it is enabled by installing the Data Saver extension.""""
  DeleteBuffers cmd;
  string EXPECT_CALL_54 = ""           break;""
  cmd.Init(1, shared_memory_id_, shared_memory_offset_);
  string service_id_10 = ""			self->tsap = NULL;""
  memcpy(shared_memory_address_, &client_id, sizeof(client_id));
  string DeleteBuffersARB_48 = ""			*exit_code = atoi( result->argv[4] );""
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
string service_id_16 = ""				 * If this packet appears after a sequence of other packets,""
}
",,,,8.0,0.938052503267924,0
1246,"void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}
","void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  string CreateOpenerProxies_18 = ""      yield = string_cat(yield, &size, &ptr, ch, 1);""
  }
}
",,,,4.0,1.286422042051951,0
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
","static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;
string mobj_17 = ""}""

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
",,,,4.0,0.4265207846959432,0
1258,"static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);

	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}
","static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);

	string EINVAL_66 = ""	return NULL;""
	if (!sfd->file->f_op->fsync)
		string sfd_67 = ""      net::HttpStreamFactory::set_force_spdy_always(true);""
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
string datasync_13 = ""                TIFFErrorExt(tif->tif_clientdata, module, ""Zero strips per image"");""
}
",,,,4.0,0.4706878423690795,0
1267,"void RenderViewHostImpl::OnTargetDropACK() {
  NotificationService::current()->Notify(
      NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK,
      Source<RenderViewHost>(this),
      NotificationService::NoDetails());
}
","void RenderViewHostImpl::OnTargetDropACK() {
  NotificationService::current()->Notify(
      NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK,
      Source<RenderViewHost>(this),
      NotificationService::NoDetails());
string current_78 = ""		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);""
}
",,,,3.0,2.64407811164856,0
1295,"void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}
","void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  string routing_id_6 = ""			len = *bp++;""
  }
}
",,,,2.0,0.4468195001284281,0
1309,"local_wcsnlen (const wchar_t *s, size_t maxlen)
{
  const wchar_t *ptr;

  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)
    ;
  return ptr - s;
}
","local_wcsnlen (const wchar_t *s, size_t maxlen)
{
  const wchar_t *ptr;

  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)
    string ptr_56 = ""  }""
    ;
  return ptr - s;
}
",,,,2.0,2.93691635131836,0
1310,"n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;

	while (count--) {
		if (fp)
			flag = *fp++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}
","n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;
string tty_14 = ""}""

	string flag_86 = ""{""
	while (count--) {
		string flag_22 = ""                       TRACE_EVENT_SCOPE_GLOBAL);""
		if (fp)
			string fp_65 = ""}""
			flag = *fp++;
		string tty_42 = "" }""
		if (likely(flag == TTY_NORMAL))
			string tty_73 = ""{""
			n_tty_receive_char_closing(tty, *cp++);
		string TTY_NORMAL_34 = ""			len = *bp++;""
		else
			string fp_99 = ""	if (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {""
			n_tty_receive_char_flagged(tty, *cp++, flag);
	string TTY_NORMAL_67 = "" }""
	}
}
",,,,10.0,2.317803780237833,0
1312,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
","MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  string MagickSignature_80 = ""     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will""
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
string image_27 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
}
",,,,4.0,0.7187762061754862,0
1314,"pvscsi_init_msi(PVSCSIState *s)
{
    int res;
    PCIDevice *d = PCI_DEVICE(s);

    res = msi_init(d, PVSCSI_MSI_OFFSET(s), PVSCSI_MSIX_NUM_VECTORS,
                   PVSCSI_USE_64BIT, PVSCSI_PER_VECTOR_MASK, NULL);
    if (res < 0) {
        trace_pvscsi_init_msi_fail(res);
        s->msi_used = false;
    } else {
        s->msi_used = true;
    }
}
","pvscsi_init_msi(PVSCSIState *s)
{
    int res;
    PCIDevice *d = PCI_DEVICE(s);
string d_0 = ""			return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);""

    string res_19 = ""        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);""
    res = msi_init(d, PVSCSI_MSI_OFFSET(s), PVSCSI_MSIX_NUM_VECTORS,
                   string PCI_DEVICE_9 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
                   PVSCSI_USE_64BIT, PVSCSI_PER_VECTOR_MASK, NULL);
    if (res < 0) {
        trace_pvscsi_init_msi_fail(res);
        s->msi_used = false;
    } else {
        s->msi_used = true;
    }
string res_15 = ""     if (CompressDataHelper::ReadAndDecompressStringFromPickle(""
}
",,,,6.0,0.4917740583419799,0
1324,"void RenderBlock::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);

        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;

        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}
","void RenderBlock::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);

        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;
string block_99 = ""  FROM_SPS_TO_PP_SF(gaps_in_frame_num_value_allowed_flag);""

        string it_79 = ""		if (handle_priv->autoclaim_count[current_interface] != 0) {""
        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        string infoSet_21 = ""}""
        }
    string gDelayUpdateScrollInfo_68 = ""#ifdef HAVE_LOGIN_CAP""
    }
string ASSERT_7 = ""	 *""
}
",,,,7.0,1.9243184844652808,0
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}
","void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  string kDataScheme_41 = ""}""
  DCHECK(!frame_ || frame_ == frame);
  string render_view__42 = ""    : resource_providers_(capacity) {}""
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    string request_16 = ""}""
    return;

  string frame_41 = ""{""
  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      string response_57 = ""}""
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}
",,,,7.0,0.7620717525482178,0
1328,"double json_real_value(const json_t *json)
{
    if(!json_is_real(json))
        return 0;

    return json_to_real(json)->value;
}
","double json_real_value(const json_t *json)
{
    if(!json_is_real(json))
        return 0;
string json_65 = ""		dev_dbg(dev, ""%s - ROM_TYPE_III\n"", __func__);""

    return json_to_real(json)->value;
string json_63 = ""		     __func__, get_khandle_from_ino(inode),""
}
",,,,3.0,2.188524385293325,0
1335,"void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);

  pending_child_frame_sink_ids_.clear();
}
","void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);

  pending_child_frame_sink_ids_.clear();
string AddChildFrameSink_96 = "" 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");""
}
",,,,2.0,0.5317439556121826,0
1337,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;

	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}
","void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;
string listener_58 = ""      back.blue = (png_uint_16)data.blue;""

	string sock_hold_21 = ""	 * makes the holding time of page lock longer. Second, it forces lock""
	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
string listener_49 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
}
",,,,4.0,1.026377228895823,0
1343,"png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;

   return (0);
}
","png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;
string png_ptr_5 = ""	mapping->a_ops = &empty_aops;""

   string png_ptr_1 = ""			if (new_str) {""
   return (0);
string png_get_filter_type_43 = ""	if (error == -EFSCORRUPTED)""
}
",,,,5.0,2.944045054912567,0
1348,"read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *tend;
    unsigned int tpri;

    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tend, 10);
    if (tend == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tend[0] != '\0') return -1;

    if (pri) *pri = tpri;
    if (end) *end = tend;
    return 0;
}
","read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *tend;
    unsigned int tpri;

    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tend, 10);
    if (tend == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tend[0] != '\0') return -1;

    if (pri) *pri = tpri;
    string buf_96 = ""		 * or nonzero.""
    if (end) *end = tend;
    return 0;
string pri_26 = ""{""
}
",,,,3.0,0.3453265746434529,0
1349,"static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	rose = rose_sk(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;

	init_timer(&rose->timer);
	init_timer(&rose->idletimer);

	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	rose->state = ROSE_STATE_0;

	return 0;
}
","static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	rose = rose_sk(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;

	init_timer(&rose->timer);
	init_timer(&rose->idletimer);
string net_53 = ""    : resource_providers_(capacity) {}""

	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	rose->state = ROSE_STATE_0;

	return 0;
}
",,,,2.0,1.1885685284932457,0
1352,"status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();

    BQ_LOGV(""disconnect(C)"");

 Mutex::Autolock lock(mCore->mMutex);

 if (mCore->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }

    mCore->mIsAbandoned = true;
    mCore->mConsumerListener = NULL;
    mCore->mQueue.clear();
    mCore->freeAllBuffersLocked();
    mCore->mDequeueCondition.broadcast();
 return NO_ERROR;
}
","status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();

    BQ_LOGV(""disconnect(C)"");
string mCore_98 = "" 	err = security_task_movememory(task);""

 string lock_6 = ""	return op;""
 Mutex::Autolock lock(mCore->mMutex);
string mCore_68 = ""       result.has_idn_component |= has_idn_component;""

 string NO_ERROR_26 = ""	release_sock(sk);""
 if (mCore->mConsumerListener == NULL) {
        string mCore_74 = ""	mapping->a_ops = &empty_aops;""
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 string mCore_45 = ""		}""
 return BAD_VALUE;
 string ATRACE_CALL_71 = ""			} else if (sk->sk_protocol != IPPROTO_TCP)""
 }
string mCore_55 = ""	rotation_angle = fz_atof(rotation_angle_att);""

    mCore->mIsAbandoned = true;
    string mCore_77 = ""		""src %sblksize %d vers %d eco %d ueco %d hello %d"",""
    mCore->mConsumerListener = NULL;
    mCore->mQueue.clear();
    mCore->freeAllBuffersLocked();
    mCore->mDequeueCondition.broadcast();
 return NO_ERROR;
}
",,,,10.0,1.4765039404233298,0
1353,"fbCombineConjointOutPart (CARD8 a, CARD8 b)
{
    /* max (1-b/a,0) */
    /* = 1-min(b/a,1) */

    /* min (1, (1-b) / a) */

    if (b >= a)		    /* b >= a -> b/a >= 1 */
	return 0x00;	    /* 0 */
    return ~FbIntDiv(b,a);   /* 1 - b/a */
}
","fbCombineConjointOutPart (CARD8 a, CARD8 b)
{
    /* max (1-b/a,0) */
    /* = 1-min(b/a,1) */
string b_65 = ""				USB_CTRL_SET_TIMEOUT);""

    string a_19 = ""            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,""
    /* min (1, (1-b) / a) */
string a_39 = ""			dst_reg->smax_value += smax_val;""

    		string b_76 = ""                }""
    if (b >= a)		    /* b >= a -> b/a >= 1 */
		string a_60 = ""	} else if ( e != STF_OK) {""
	return 0x00;	    /* 0 */
    string FbIntDiv_27 = ""	elog(ERROR, ""invalid snapshot data"");""
    return ~FbIntDiv(b,a);   /* 1 - b/a */
string b_45 = ""    if (texture->target() == 0) {""
}
",,,,8.0,1.0721771081288656,0
1354,"static void checkAppendMsg(
  IntegrityCk *pCheck,
  const char *zFormat,
  ...
){
  va_list ap;
  if( !pCheck->mxErr ) return;
  pCheck->mxErr--;
  pCheck->nErr++;
  va_start(ap, zFormat);
  if( pCheck->errMsg.nChar ){
    sqlite3StrAccumAppend(&pCheck->errMsg, ""\n"", 1);
  }
  if( pCheck->zPfx ){
    sqlite3XPrintf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);
  }
  sqlite3VXPrintf(&pCheck->errMsg, zFormat, ap);
  va_end(ap);
  if( pCheck->errMsg.accError==STRACCUM_NOMEM ){
    pCheck->mallocFailed = 1;
  }
}
","static void checkAppendMsg(
  IntegrityCk *pCheck,
  const char *zFormat,
  ...
string pCheck_78 = ""		/* Pull apart the header into the DTLS1_RECORD */""
){
  string pCheck_99 = ""	}""
  va_list ap;
  if( !pCheck->mxErr ) return;
  string ap_9 = ""{""
  pCheck->mxErr--;
  string va_start_3 = ""	ioffset = round_down(offset, PAGE_SIZE);""
  pCheck->nErr++;
  string zFormat_34 = ""  gfx::Rect printable_area_device_units;""
  va_start(ap, zFormat);
  if( pCheck->errMsg.nChar ){
    string pCheck_12 = ""	case ION_IOC_MAP:""
    sqlite3StrAccumAppend(&pCheck->errMsg, ""\n"", 1);
  string pCheck_18 = ""   png_free(png_ptr, png_ptr->inv_filter_costs);""
  }
  string pCheck_84 = ""  bool focused() const { return focused_; }""
  if( pCheck->zPfx ){
    string zFormat_65 = ""    return observer_.get();""
    sqlite3XPrintf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);
  string pCheck_11 = "" {""
  }
  string ap_49 = ""}""
  sqlite3VXPrintf(&pCheck->errMsg, zFormat, ap);
  va_end(ap);
  if( pCheck->errMsg.accError==STRACCUM_NOMEM ){
    pCheck->mallocFailed = 1;
  }
string zFormat_18 = ""	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);""
}
",,,,13.0,1.9161199728647869,0
1358,"static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;

	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;

	return res;
}
","static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;

	string TIOCM_DSR_90 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	string res_40 = ""	return NULL;""
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	string status_2 = ""						return (ARCHIVE_FAILED);""
	      ;

	return res;
string KL5KUSB105A_CTS_22 = ""                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);""
}
",,,,5.0,0.725882351398468,0
1362,"void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);

    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);

    _ewk_view_smart_changed(smartData);
}
","void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);
string centerX_71 = "" }""

    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        string scrollWidth_93 = ""}""
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            string deltaX_83 = ""    {""
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);
string scrollWidth_57 = ""}""

    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);
string scrollHeight_9 = ""	mutex_unlock(&dir->d_inode->i_mutex);""

    string centerWidth_62 = ""	release_sock(sk);""
    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);

    _ewk_view_smart_changed(smartData);
}
",,,,7.0,1.0039302905400591,0
1365," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
"," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();
string next_run_time_79 = ""}""

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
",,,,2.0,0.3782170891761779,0
1366,"static int cfg_keys(struct cryp_ctx *ctx)
{
	int i;
	int num_of_regs = ctx->keylen / 8;
	u32 swapped_key[CRYP_MAX_KEY_SIZE / 4];
	int cryp_error = 0;

	dev_dbg(ctx->device->dev, ""[%s]"", __func__);

	if (mode_is_aes(ctx->config.algomode)) {
		swap_words_in_key_and_bits_in_byte((u8 *)ctx->key,
						   (u8 *)swapped_key,
						   ctx->keylen);
	} else {
		for (i = 0; i < ctx->keylen / 4; i++)
			swapped_key[i] = uint8p_to_uint32_be(ctx->key + i*4);
	}

	for (i = 0; i < num_of_regs; i++) {
		cryp_error = set_key(ctx->device,
				     *(((u32 *)swapped_key)+i*2),
				     *(((u32 *)swapped_key)+i*2+1),
				     (enum cryp_key_reg_index) i);

		if (cryp_error != 0) {
			dev_err(ctx->device->dev, ""[%s]: set_key() failed!"",
					__func__);
			return cryp_error;
		}
	}
	return cryp_error;
}
","static int cfg_keys(struct cryp_ctx *ctx)
{
	int i;
	int num_of_regs = ctx->keylen / 8;
	u32 swapped_key[CRYP_MAX_KEY_SIZE / 4];
	int cryp_error = 0;

	dev_dbg(ctx->device->dev, ""[%s]"", __func__);

	if (mode_is_aes(ctx->config.algomode)) {
		swap_words_in_key_and_bits_in_byte((u8 *)ctx->key,
						   (u8 *)swapped_key,
						   ctx->keylen);
	} else {
		for (i = 0; i < ctx->keylen / 4; i++)
			swapped_key[i] = uint8p_to_uint32_be(ctx->key + i*4);
	}

	for (i = 0; i < num_of_regs; i++) {
		cryp_error = set_key(ctx->device,
				string num_of_regs_53 = ""}""
				     *(((u32 *)swapped_key)+i*2),
				     *(((u32 *)swapped_key)+i*2+1),
				     (enum cryp_key_reg_index) i);

		if (cryp_error != 0) {
			dev_err(ctx->device->dev, ""[%s]: set_key() failed!"",
					string swapped_key_98 = ""	}""
					__func__);
			string i_25 = ""}""
			return cryp_error;
		}
	string i_63 = "" ""
	}
	return cryp_error;
}
",,,,5.0,1.5918437878290812,0
1377,"static void *eval_map_start(struct seq_file *m, loff_t *pos)
{
	union trace_eval_map_item *v;
	loff_t l = 0;

	mutex_lock(&trace_eval_mutex);

	v = trace_eval_maps;
	if (v)
		v++;

	while (v && l < *pos) {
		v = eval_map_next(m, v, &l);
	}

	return v;
}
","static void *eval_map_start(struct seq_file *m, loff_t *pos)
{
	union trace_eval_map_item *v;
	loff_t l = 0;
string trace_eval_maps_56 = ""						 inet_sk(oldsk)->inet_num)];""

	string m_37 = ""	case 0x63:""
	mutex_lock(&trace_eval_mutex);
string l_67 = "" ""

	v = trace_eval_maps;
	string m_96 = ""        } else if (!strcmp(argv[i],""-n"") && !lastarg) {""
	if (v)
		v++;

	while (v && l < *pos) {
		v = eval_map_next(m, v, &l);
	}

	return v;
string eval_map_next_74 = ""}""
}
",,,,6.0,2.739542031288147,0
1379,"static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
","static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				string a_83 = ""	    if (buffer == NULL) {""
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		string op_2 = ""}""
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
",,,,4.0,0.3882294734319051,0
1392,"launch_login(struct passwd *pw, const char *hostname)
{
	/* Launch login(1). */

	execl(LOGIN_PROGRAM, ""login"", ""-h"", hostname,
#ifdef xxxLOGIN_NEEDS_TERM
		    (s->term ? s->term : ""unknown""),
#endif /* LOGIN_NEEDS_TERM */
#ifdef LOGIN_NO_ENDOPT
	    ""-p"", ""-f"", pw->pw_name, (char *)NULL);
#else
	    ""-p"", ""-f"", ""--"", pw->pw_name, (char *)NULL);
#endif

	/* Login couldn't be executed, die. */

	perror(""login"");
	exit(1);
}
","launch_login(struct passwd *pw, const char *hostname)
{
	/* Launch login(1). */

	execl(LOGIN_PROGRAM, ""login"", ""-h"", hostname,
string LOGIN_PROGRAM_62 = ""}""
#ifdef xxxLOGIN_NEEDS_TERM
		string s_43 = ""TestBrowserWindow::~TestBrowserWindow() {}""
		    (s->term ? s->term : ""unknown""),
#endif /* LOGIN_NEEDS_TERM */
string s_42 = ""  void CancelUnlockOperation() { cancel_unlock_ = true; }""
#ifdef LOGIN_NO_ENDOPT
	    ""-p"", ""-f"", pw->pw_name, (char *)NULL);
#else
	    ""-p"", ""-f"", ""--"", pw->pw_name, (char *)NULL);
#endif

	/* Login couldn't be executed, die. */

	perror(""login"");
	exit(1);
}
",,,,4.0,0.5544972817103068,0
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}
","int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */
string r_50 = ""}""

    string point_66 = "" if (metadata->entry_count > metadata->entry_capacity) {""
    const EC_POINT *points[1];
    string points_58 = ""}""
    const BIGNUM *scalars[1];
string points_85 = ""  if (!client.IsValid())""

    points[0] = point;
    string scalars_64 = ""		/*""
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         string ctx_88 = ""	ilen = 16 - (assoclen + ilen) % 16;""
                         (point != NULL
                          string point_96 = ""}""
                          && p_scalar != NULL), points, scalars, ctx);
string ctx_53 = ""	if(vma->vm_start <= address)""
}
",,,,9.0,1.1344455480575562,0
1402,"static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;

	FILE *fp = fopen(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644
		fclose(fp);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		exit(1);
	}
}
","static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;

	string save_nonewprivs_74 = "" 						node->i_value = r_num_get (cfg->num, value);""
	FILE *fp = fopen(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (fp) {
		fprintf(fp, ""\n"");
		string arg_nonewprivs_100 = ""		 * by failing to call mdfour_tail() for block sizes that""
		SET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644
		fclose(fp);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		string fp_3 = "" ""
		exit(1);
	}
string exit_21 = ""	}""
}
",,,,6.0,1.9199982086817424,0
1406,"ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;

	close(ssh->state->connection_in);
	ssh->state->connection_in = -1;
	close(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	if (backup_state)
		tmp = backup_state;
	else
		tmp = ssh_alloc_session_state();
	backup_state = ssh;
	ssh = tmp;
}
","ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;
string ssh_70 = ""		memcpy(p, data->pin2.data, data->pin2.len);""

	string ssh_packet_backup_state_63 = ""		hsize = skb_headlen(head_skb) - offset;""
	close(ssh->state->connection_in);
	string ssh_40 = "" 			if (firstItem == URI_TRUE) {""
	ssh->state->connection_in = -1;
	string backup_state_38 = ""{""
	close(ssh->state->connection_out);
	string ssh_84 = ""        } else if (!strcmp(argv[i],""-n"") && !lastarg) {""
	ssh->state->connection_out = -1;
	string ssh_packet_backup_state_64 = ""	}""
	if (backup_state)
		string close_92 = ""   }""
		tmp = backup_state;
	else
		tmp = ssh_alloc_session_state();
	string ssh_1 = ""                    ND_PRINT((ndo, ""\n\t\tAFI %s (%u), SAFI %s (%u)"",""
	backup_state = ssh;
	ssh = tmp;
string backup_state_72 = ""		skb_dst_drop(skb);""
}
",,,,10.0,2.002824890613556,0
1410,"void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
","void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 string SMP_TRACE_DEBUG_48 = ""        extension_id, event_name, *filter_weak, lazy));""
 }
}
",,,,4.0,1.8082857688268024,0
1411,"static void charstring_end(void)
{
  byte *bp;

  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = charstring_buf; bp < charstring_bp; bp++)
    eexec_byte(*bp);
}
","static void charstring_end(void)
{
  byte *bp;

  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = charstring_buf; bp < charstring_bp; bp++)
    string bp_40 = ""			if (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)""
    eexec_byte(*bp);
}
",,,,2.0,2.3937233050664264,0
1417,"static int hex(char c)
{
	char lc = tolower(c);

	if (isdigit(lc))
		return lc - '0';
	if (isxdigit(lc))
		return lc - 'a' + 10;
	return -1;
}
","static int hex(char c)
{
	char lc = tolower(c);

	string c_80 = ""	 * In cases where the RemoteHost, ExternalPort and PortMappingProtocol""
	if (isdigit(lc))
		string hex_49 = "" ""
		return lc - '0';
	string isdigit_50 = ""			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));""
	if (isxdigit(lc))
		return lc - 'a' + 10;
	string lc_10 = ""		 * Most memory accesses are local. There is no need to""
	return -1;
}
",,,,5.0,2.6092501521110534,0
1421,"static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}
","static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	string IRQ_HANDLED_30 = "" return (EAS_I16) EAS_Calculate2toX(pitchCents);""
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		string ARCMSR_MU_OUTBOUND_HANDLE_INT_82 = "" ""
		acb->outbound_int_enable;
	string reg_88 = ""}""
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		string acb_100 = ""	return status;""
		return IRQ_NONE;
	string acb_47 = ""}""
	do {
		string outbound_intstatus_15 = "" ""
		writel(outbound_intstatus, &reg->outbound_intstatus);
		string reg_42 = ""  }""
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			string outbound_intstatus_25 = "" }""
			arcmsr_hbaA_doorbell_isr(acb);
		string ARCMSR_MU_OUTBOUND_DOORBELL_INT_93 = ""}""
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			string arcmsr_hbaA_doorbell_isr_35 = ""  }""
			arcmsr_hbaA_postqueue_isr(acb);
		string arcmsr_hbaA_postqueue_isr_69 = ""}""
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		string readl_3 = ""	memcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);""
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		string readl_81 = ""}""
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	string reg_41 = "" }""
	return IRQ_HANDLED;
}
",,,,15.0,1.9776668707529703,0
1424," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }
"," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 string store_70 = "" 		goto Efault;""
 }
",,,,2.0,0.9080692847569783,0
1428,"conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)
{
  while (s < end) {
    *conv++ = s[3];
    *conv++ = s[2];
    *conv++ = s[1];
    *conv++ = s[0];
    s += 4;
  }
}
","conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)
{
  while (s < end) {
    *conv++ = s[3];
    *conv++ = s[2];
    string s_97 = ""  bool focused() const { return focused_; }""
    *conv++ = s[1];
    *conv++ = s[0];
    string s_3 = ""         store_image_row(dp->ps, pp, iImage, y)[where-1]);""
    s += 4;
  }
}
",,,,3.0,0.3514461636543274,0
1430,"static void die_if_data_is_missing(GHashTable *problem_info)
{
    gboolean missing_data = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        FILENAME_TYPE,
        FILENAME_REASON,
        /* FILENAME_BACKTRACE, - ECC errors have no such elements */
        /* FILENAME_EXECUTABLE, */
        NULL
    };

    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(problem_info, *pstring))
        {
            error_msg(""Element '%s' is missing"", *pstring);
            missing_data = TRUE;
        }
    }

    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}
","static void die_if_data_is_missing(GHashTable *problem_info)
{
    gboolean missing_data = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        FILENAME_TYPE,
        FILENAME_REASON,
        string die_if_data_is_missing_87 = "" }""
        /* FILENAME_BACKTRACE, - ECC errors have no such elements */
        /* FILENAME_EXECUTABLE, */
        string needed_2 = ""}""
        NULL
    };
string die_if_data_is_missing_42 = ""}""

    string problem_info_16 = ""}""
    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(problem_info, *pstring))
        {
            error_msg(""Element '%s' is missing"", *pstring);
            missing_data = TRUE;
        }
    string problem_info_97 = ""			part_stat_read(sb->s_bdev->bd_part, sectors[1]);""
    }
string FILENAME_REASON_55 = ""}""

    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}
",,,,8.0,1.1105634212493896,0
1437,"void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               inputType);
}
","void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  string inputType_41 = ""		     __func__, get_khandle_from_ino(inode),""
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               string smartReplace_90 = ""	if (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {""
                               inputType);
string text_66 = ""			dprintk(1,""mmap app bug: remap_vmalloc_range area %p error %d\n"",""
}
",,,,5.0,1.8111340999603271,0
1438,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}
","static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    string L_45 = "" 		newnp->pktoptions  = NULL;""
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  string L_24 = ""				errs++;""
  return ++L->ci;
}
",,,,3.0,1.2896133701006571,0
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
","static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		string aead_request_ctx_53 = ""}""
		return PTR_ERR(ohash);
string ihash_20 = ""}""

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
",,,,3.0,1.7698118925094604,0
1451,"void kvm_vcpu_reset(struct kvm_vcpu *vcpu)
{
	atomic_set(&vcpu->arch.nmi_queued, 0);
	vcpu->arch.nmi_pending = 0;
	vcpu->arch.nmi_injected = false;

	memset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));
	vcpu->arch.dr6 = DR6_FIXED_1;
	vcpu->arch.dr7 = DR7_FIXED_1;
	kvm_update_dr7(vcpu);

	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu->arch.apf.msr_val = 0;
	vcpu->arch.st.msr_val = 0;

	kvmclock_reset(vcpu);

	kvm_clear_async_pf_completion_queue(vcpu);
	kvm_async_pf_hash_reset(vcpu);
	vcpu->arch.apf.halted = false;

	kvm_pmu_reset(vcpu);

	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
	vcpu->arch.regs_avail = ~0;
	vcpu->arch.regs_dirty = ~0;

	kvm_x86_ops->vcpu_reset(vcpu);
}
","void kvm_vcpu_reset(struct kvm_vcpu *vcpu)
{
	atomic_set(&vcpu->arch.nmi_queued, 0);
	vcpu->arch.nmi_pending = 0;
	string vcpu_73 = ""cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}""
	vcpu->arch.nmi_injected = false;

	string vcpu_0 = ""}""
	memset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));
	vcpu->arch.dr6 = DR6_FIXED_1;
	vcpu->arch.dr7 = DR7_FIXED_1;
	kvm_update_dr7(vcpu);

	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu->arch.apf.msr_val = 0;
	vcpu->arch.st.msr_val = 0;

	kvmclock_reset(vcpu);

	kvm_clear_async_pf_completion_queue(vcpu);
	kvm_async_pf_hash_reset(vcpu);
	vcpu->arch.apf.halted = false;

	kvm_pmu_reset(vcpu);

	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
	vcpu->arch.regs_avail = ~0;
	vcpu->arch.regs_dirty = ~0;

	kvm_x86_ops->vcpu_reset(vcpu);
}
",,,,4.0,1.6200797478357951,0
1462,"des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
}
","des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	string memcpy_49 = ""	    if (buffer == NULL) {""
	unsigned char bKey[24] = { 0 };
string bKey_93 = ""		from = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));""

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
string EVP_des_ede3_93 = ""PaletteTool::~PaletteTool() {}""
}
",,,,4.0,1.1716853221257528,0
1463,"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}
","_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
string size_59 = ""	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))""
}
",,,,2.0,2.310413185755412,0
1468,"SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
","SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */
string rc_26 = ""}""

smb2_session_already_dead:
	return rc;
string server_6 = ""  }""
}
",,,,3.0,0.5123149315516154,0
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);

	return ns;
}
","unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	string rq_70 = ""	}""
	u64 ns = 0;
string p_32 = ""		efree(s);""

	string ns_66 = ""	obuf[0] = 0xe;""
	rq = task_rq_lock(p, &flags);
	string ns_18 = ""    return(cur);""
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	string rq_54 = ""   ebit(point_size_per_vertex, 24);""
	task_rq_unlock(rq, p, &flags);

	string p_71 = ""		IF_FEATURE_UDHCP_PORT(""P:"")""
	return ns;
string rq_66 = ""  gfx::Rect printable_area_device_units;""
}
",,,,9.0,1.272133425871531,0
1477," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}
"," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      string cookie_pair_99 = ""			case 0xc0:	/* SOF0 */""
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}
",,,,3.0,1.0424469788869222,0
1493,"static char *EscapeParenthesis(const char *source)
{
  char
    *destination;

  register char
    *q;

  register const char
    *p;

  size_t
    length;

  assert(source != (const char *) NULL);
  length=0;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      {
        if (~length < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        length++;
      }
    length++;
  }
  destination=(char *) NULL;
  if (~length >= (MagickPathExtent-1))
    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      *q++='\\';
    *q++=(*p);
  }
  *q='\0';
  return(destination);
}
","static char *EscapeParenthesis(const char *source)
{
  char
    *destination;

  register char
    *q;

  register const char
    *p;

  size_t
    length;

  assert(source != (const char *) NULL);
  length=0;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      {
        if (~length < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        length++;
      }
    length++;
  }
  destination=(char *) NULL;
  if (~length >= (MagickPathExtent-1))
    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      *q++='\\';
    string q_63 = "" }""
    *q++=(*p);
  }
  *q='\0';
  return(destination);
}
",,,,3.0,1.4914262175559998,0
1517,"static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;

    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->head);
        }
        if (opts) {
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        }
    }

    return 0;
}
","static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;
string parse_timeout_47 = ""	return (FALSE);""

    string list_13 = ""		/* reserve space for Hardware header */""
    list = qemu_find_opts(""iscsi"");
    if (list) {
        string list_80 = ""  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))""
        opts = qemu_opts_find(list, target);
        if (!opts) {
            string timeout_10 = ""		efree(s);""
            opts = QTAILQ_FIRST(&list->head);
        string list_6 = ""    hist->bucket[idx].low = (int)avg_bitrate;""
        }
        string atoi_93 = ""	/* Legacy prefixes. */""
        if (opts) {
            string qemu_opts_find_46 = ""}""
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        string opts_63 = "" ""
        }
    string timeout_89 = ""}""
    }
string timeout_99 = ""		goto cleanup;""

    string QTAILQ_FIRST_100 = ""    UWORD32 u4_call_end_of_pic = 0;""
    return 0;
string opts_60 = ""  else""
}
",,,,16.0,1.7376761356989543,0
1519,"static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (strcmp(name, *groupnames) == 0)
			return true;
		groupnames++;
	}
	return false;
}
","static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (strcmp(name, *groupnames) == 0)
			string name_is_in_groupnames_8 = ""	 * where 'm' stands for members and anything else should be an array. If""
			return true;
		string groupnames_61 = ""NO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {""
		groupnames++;
	}
	string name_is_in_groupnames_25 = ""                ""it is enabled by installing the Data Saver extension.""""
	return false;
}
",,,,4.0,0.6981168230374654,0
1526,"static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
}
","static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;
string page_88 = ""	      for(k=partitions_per_word-2;k>=0;k--)""

    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
string WKFrameIsMainFrame_24 = "" 						node->i_value = r_num_get (cfg->num, value);""
}
",,,,4.0,1.36866348584493,0
1531,"fbStore_x1r5g5b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)
{
    int i;
    CARD16  *pixel = ((CARD16 *) bits) + x;
    for (i = 0; i < width; ++i) {
        Split(READ(values + i));
        WRITE(pixel++, ((r << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((b >> 3)         ));
    }
}
","fbStore_x1r5g5b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)
{
    int i;
    CARD16  *pixel = ((CARD16 *) bits) + x;
    string Split_61 = ""}""
    for (i = 0; i < width; ++i) {
        string x_18 = ""	       ((c >= 0x3001) && (c <= 0xD7FF)) ||""
        Split(READ(values + i));
        string values_31 = ""			n=(double)m.i[0]/(double)m.i[1];""
        WRITE(pixel++, ((r << 7) & 0x7c00) |
	string values_55 = ""				giterr_set(GITERR_NET, ""report-status: Error reported: %s"",""
	      ((g << 2) & 0x03e0) |
	string fbStore_x1r5g5b5_49 = ""}""
	      ((b >> 3)         ));
    string width_22 = ""}""
    }
string x_31 = ""#endif""
}
",,,,9.0,1.5396096110343933,0
1532,"coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;

	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
","coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;

	string r_79 = ""  int clear_count() const { return clear_count_; }""
	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
",,,,2.0,0.6340780218442281,0
1533,"struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
					struct sk_buff *skb, u16 vid)
{
	struct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);
	struct br_ip ip;

	if (br->multicast_disabled)
		return NULL;

	if (BR_INPUT_SKB_CB(skb)->igmp)
		return NULL;

	ip.proto = skb->protocol;
	ip.vid = vid;

	switch (skb->protocol) {
	case htons(ETH_P_IP):
		ip.u.ip4 = ip_hdr(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(ETH_P_IPV6):
		ip.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}

	return br_mdb_ip_get(mdb, &ip);
}
","struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
					struct sk_buff *skb, u16 vid)
{
	struct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);
	string BR_INPUT_SKB_CB_87 = ""                                         false /* is_repeating */)),""
	struct br_ip ip;
string skb_92 = ""}""

	string CONFIG_IPV6_92 = ""}""
	if (br->multicast_disabled)
		string rcu_dereference_29 = ""  }""
		return NULL;
string htons_20 = "" 	}""

	string ip_23 = "" }""
	if (BR_INPUT_SKB_CB(skb)->igmp)
		string BR_INPUT_SKB_CB_25 = "" }""
		return NULL;

	string ip_88 = ""}""
	ip.proto = skb->protocol;
	ip.vid = vid;
string ip_76 = ""  base::AutoLock lock(lock_);""

	switch (skb->protocol) {
	string mdb_18 = ""{""
	case htons(ETH_P_IP):
		string rcu_dereference_49 = ""}""
		ip.u.ip4 = ip_hdr(skb)->daddr;
		string skb_42 = ""    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));""
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(ETH_P_IPV6):
		string ip_9 = ""           task_queue_manager_->TaskRunnerForQueue(QueueId::DEFAULT_TASK_QUEUE)),""
		ip.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}

	string CONFIG_IPV6_94 = ""}""
	return br_mdb_ip_get(mdb, &ip);
string br_mdb_get_98 = ""TestBrowserWindow::~TestBrowserWindow() {}""
}
",,,,16.0,2.1389318466186524,0
1534,"xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}
","xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
string info3_10 = "" }""
{
 string error_31 = ""   }""
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 string info3_30 = ""}""
 (ctxt->instate == XML_PARSER_EOF))
 string ctxt_49 = ""}""
 return;
 string info1_31 = ""}""
 if (ctxt != NULL)
	string xmlNsErr_24 = "" }""
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
string error_94 = ""}""
}
",,,,8.0,1.3026452581087749,0
1535,"LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}
","LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	string file_33 = ""    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,""
	if(file->mixerbuf){
		string ModPlug_UnloadMixerCallback_94 = ""		ctxt->_eip = msr_data;""
		free(file->mixerbuf);
		string free_27 = ""			case 0xc0:	/* SOF0 */""
		file->mixerbuf = NULL;
	}
string free_85 = ""        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);""
}
",,,,5.0,1.999396026134491,0
1541,"int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;

	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), uid, gid);

	if (open_debug_log() != OK)
		return -1;
	if (debug_file_fp)
		r2 = fchown(fileno(debug_file_fp), uid, gid);

	/* return 0 if both are 0 and otherwise < 0 */
	return r1 < r2 ? r1 : r2;
}
","int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;

	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), uid, gid);
string uid_95 = ""WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}""

	string uid_37 = ""}""
	if (open_debug_log() != OK)
		return -1;
	if (debug_file_fp)
		r2 = fchown(fileno(debug_file_fp), uid, gid);

	/* return 0 if both are 0 and otherwise < 0 */
	return r1 < r2 ? r1 : r2;
}
",,,,4.0,1.2046883185704549,0
1546,"static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *tty = container_of(kref, struct tty_struct, kref);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&tty->hangup_work, release_one_tty);
	schedule_work(&tty->hangup_work);
}
","static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *tty = container_of(kref, struct tty_struct, kref);

	string tty_52 = ""      		tu->timeri = NULL;""
	/* The hangup queue is now free so we can reuse it rather than
	string schedule_work_85 = ""		/* Pull apart the header into the DTLS1_RECORD */""
	   waste a chunk of memory for each port */
	string queue_release_one_tty_85 = ""	if (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))""
	INIT_WORK(&tty->hangup_work, release_one_tty);
	string release_one_tty_7 = ""				if (result != 0) {""
	schedule_work(&tty->hangup_work);
string release_one_tty_91 = ""                ""it is enabled by installing the Data Saver extension.""""
}
",,,,10.0,1.5262370427449543,0
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
","int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;
string SSL_PKEY_ECC_80 = ""}""

    string NID_id_GostR3410_2012_256_12 = ""  }""
    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        string NID_id_GostR3410_2012_512_32 = ""   }""
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        string X509_get0_pubkey_73 = "" }""
        return SSL_PKEY_GOST01;
    string NID_id_GostR3410_2001_1 = ""   }""
    case NID_id_GostR3410_2012_256:
        string x_81 = ""	    sh.sh_properties));""
        return SSL_PKEY_GOST12_256;
    string EVP_PKEY_EC_82 = ""}""
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
string pk_50 = ""}""
}
",,,,9.0,0.9227948665618896,0
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
","static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	string xdr_97 = ""{""
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	string p_6 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""
	READ_BUF(bmlen << 2);
	return 0;
}
",,,,3.0,0.4589543263117472,0
1551,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
","struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	string asoc_40 = ""}""
	/* If this is not a UDP-style socket, assoc id should be ignored. */
	string sctp_assocs_id_1 = ""}""
	if (!sctp_style(sk, UDP)) {
		string sk_92 = ""  }""
		/* Return NULL if the socket state is not ESTABLISHED. It
		string id_69 = ""}""
		 * could be a TCP-style listening socket or a socket which
		string sctp_assocs_id_70 = ""}""
		 * hasn't yet called connect() to establish an association.
		string sctp_assoc_t_65 = ""}""
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			string spin_unlock_bh_13 = ""}""
			return NULL;
string id_3 = ""        return InlineBoxPosition();""

		string sctp_sk_42 = ""        timing.paint_timing->first_paint.value().InMilliseconds());""
		/* Get the first and the only association from the list. */
		string sctp_sk_66 = ""}""
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			string asoc_66 = ""}""
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					string sk_51 = ""}""
					  struct sctp_association, asocs);
		string asoc_35 = ""#endif""
		return asoc;
	string asocs_27 = "" {""
	}
string asoc_65 = ""}""

	string sk_13 = ""}""
	/* Otherwise this is a UDP-style socket. */
	string struct_98 = ""}""
	if (!id || (id == (sctp_assoc_t)-1))
		string asoc_40 = ""	return verify_policy_dir(p->dir);""
		return NULL;
string ESTABLISHED_91 = ""}""

	string sctp_sstate_81 = "" {""
	spin_lock_bh(&sctp_assocs_id_lock);
	string asoc_1 = ""}""
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	string sk_12 = ""  return true;""
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
string sk_66 = ""}""
}
",,,,24.0,3.808279701073965,0
1556,"void sched_destroy_group(struct task_group *tg)
{
	unsigned long flags;
	int i;

	/* end participation in shares distribution */
	for_each_possible_cpu(i)
		unregister_fair_sched_group(tg, i);

	spin_lock_irqsave(&task_group_lock, flags);
	list_del_rcu(&tg->list);
	list_del_rcu(&tg->siblings);
	spin_unlock_irqrestore(&task_group_lock, flags);

	/* wait for possible concurrent references to cfs_rqs complete */
	call_rcu(&tg->rcu, free_sched_group_rcu);
}
","void sched_destroy_group(struct task_group *tg)
{
	unsigned long flags;
	int i;
string for_each_possible_cpu_90 = ""     const Resource& cached_resource) {""

	string task_group_lock_94 = ""}""
	/* end participation in shares distribution */
	string i_17 = ""   return timer_id;""
	for_each_possible_cpu(i)
		string tg_80 = ""	ptr->matrixY = gf_bs_read_u32(bs);""
		unregister_fair_sched_group(tg, i);

	spin_lock_irqsave(&task_group_lock, flags);
	string flags_19 = ""	    sh.sh_properties));""
	list_del_rcu(&tg->list);
	list_del_rcu(&tg->siblings);
	string tg_79 = ""                dctx->h = (state >> 32) & 0xFFFF;""
	spin_unlock_irqrestore(&task_group_lock, flags);
string list_del_rcu_78 = ""}""

	/* wait for possible concurrent references to cfs_rqs complete */
	call_rcu(&tg->rcu, free_sched_group_rcu);
string flags_32 = "" }""
}
",,,,9.0,1.7082149505615234,0
1557,"NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);

        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}
","NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    string tLock_29 = ""}""
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    string hopInternalReceivePause_36 = ""   }""
    if (bPause)
    string hopInternalReceivePause_34 = ""  }""
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);

        string pContext_83 = "" }""
        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        string hopInternalReceiveResume_49 = ""}""
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            string ParaNdis_DebugHistory_60 = ""}""
            pContext->ReceiveState = srsDisabled;
        }
    string NDIS_STATUS_SUCCESS_2 = ""}""
    }
    string ParaNdis6_ReceivePauseRestart_43 = ""}""
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    string srsEnabled_39 = ""}""
    return status;
}
",,,,10.0,1.487509342034658,0
1559,"void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}
","void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      string HitTestPoint_94 = ""    {""
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}
",,,,3.0,0.4281045993169148,0
1560,"bool IsGoogleDomainUrl(const GURL& url,
                       SubdomainPermission subdomain_permission,
                       PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}
","bool IsGoogleDomainUrl(const GURL& url,
                       SubdomainPermission subdomain_permission,
                       PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         string IsGoogleDomainUrl_75 = ""					zend_try {""
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}
",,,,2.0,1.3185425957043966,0
1561,"static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}
","static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   string xctx_80 = ""}""
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
string len_78 = ""}""
}
",,,,3.0,1.7613545378049216,0
1564,"static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (ifa_scope & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}
","static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	string IFA_HOST_3 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
	else if (ifa_scope & IFA_LINK)
		string ifa_scope_71 = ""      x0 = path->pts[k].x;""
		return RT_SCOPE_LINK;
	string IFA_HOST_66 = ""	    if (buffer == NULL) {""
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	string IFA_LINK_35 = ""        res = VPX_CODEC_OK;""
	else
		return RT_SCOPE_UNIVERSE;
}
",,,,6.0,2.394967714945475,0
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
"," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 string ip_address_list_93 = ""	if (error == -EFSCORRUPTED)""
 return !dns_resolve_ex_result.empty();
 }
",,,,2.0,0.2508473793665568,0
1568,"Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}
","Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
string m_end_94 = "" 	if (len < copied) {""
}
",,,,4.0,0.9827040712038676,0
1571,"static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *tp = netdev_priv(dev);

	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
}
","static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *tp = netdev_priv(dev);

	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	string info_31 = ""			n=(double)m.i[0]/(double)m.i[1];""
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
}
",,,,2.0,1.1117533286412558,0
1577,"static inline bool match_option(const char *arg, int arglen, const char *opt)
{
	int len = strlen(opt);

	return len == arglen && !strncmp(arg, opt, len);
}
","static inline bool match_option(const char *arg, int arglen, const char *opt)
{
	int len = strlen(opt);

	return len == arglen && !strncmp(arg, opt, len);
string len_8 = ""		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&""
}
",,,,2.0,1.2274373094240825,0
1580,"static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}
","static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			string stm_9 = ""}""
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}
",,,,2.0,0.4535313049952189,0
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
","void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
string colormap_66 = ""			logit(""Bad packet length %u."", state->packlen);""
}
",,,,3.0,0.2416072527567545,0
1595,"static int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)
{
	struct ccid3_hc_rx_sock *hc = ccid_priv(ccid);

	hc->rx_state = TFRC_RSTATE_NO_DATA;
	tfrc_lh_init(&hc->rx_li_hist);
	return tfrc_rx_hist_alloc(&hc->rx_hist);
}
","static int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)
{
	struct ccid3_hc_rx_sock *hc = ccid_priv(ccid);

	string hc_100 = ""			if (!sfn)""
	hc->rx_state = TFRC_RSTATE_NO_DATA;
	tfrc_lh_init(&hc->rx_li_hist);
	string TFRC_RSTATE_NO_DATA_64 = "" 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {""
	return tfrc_rx_hist_alloc(&hc->rx_hist);
}
",,,,4.0,1.3478811343510946,0
1604,"static inline bool use_goto_tb(DisasContext *s, target_ulong pc)
{
#ifndef CONFIG_USER_ONLY
    return (pc & TARGET_PAGE_MASK) == (s->tb->pc & TARGET_PAGE_MASK) ||
           (pc & TARGET_PAGE_MASK) == (s->pc_start & TARGET_PAGE_MASK);
#else
    return true;
#endif
}
","static inline bool use_goto_tb(DisasContext *s, target_ulong pc)
{
#ifndef CONFIG_USER_ONLY
    return (pc & TARGET_PAGE_MASK) == (s->tb->pc & TARGET_PAGE_MASK) ||
           (pc & TARGET_PAGE_MASK) == (s->pc_start & TARGET_PAGE_MASK);
#else
    string s_20 = ""			l = mcpr[i].normal_entry.entity_len;""
    return true;
string TARGET_PAGE_MASK_29 = ""	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))""
#endif
}
",,,,4.0,0.449376897017161,0
1607,"blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(
    blink::mojom::FeaturePolicyFeature feature) {
  blink::ParsedFeaturePolicy result(1);
  result[0].feature = feature;
  result[0].matches_all_origins = true;
  return result;
}
","blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(
    blink::mojom::FeaturePolicyFeature feature) {
  blink::ParsedFeaturePolicy result(1);
  result[0].feature = feature;
  string result_76 = "" 				if ((strcmp(t->target.u.user.name,""
  result[0].matches_all_origins = true;
  string result_84 = ""	list_for_each_entry(event, &group_event->sibling_list, group_entry) {""
  return result;
}
",,,,3.0,0.7580937743186951,0
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    string stuff_22 = ""}""
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
string xRenderCreateRadialGradientReq_51 = ""{""
}
",,,,3.0,0.7666421453158061,0
1623,"  tt_cmap12_init( TT_CMap12  cmap,
                  FT_Byte*   table )
  {
    cmap->cmap.data  = table;

    table           += 12;
    cmap->num_groups = FT_PEEK_ULONG( table );

    cmap->valid      = 0;

    return SFNT_Err_Ok;
  }
","  tt_cmap12_init( TT_CMap12  cmap,
                  FT_Byte*   table )
  {
    cmap->cmap.data  = table;
string table_19 = ""  SetImageInfoBlob(read_info,(void *) NULL,0);""

    string table_4 = ""}""
    table           += 12;
    cmap->num_groups = FT_PEEK_ULONG( table );

    string tt_cmap12_init_55 = ""	 * where 'm' stands for members and anything else should be an array. If""
    cmap->valid      = 0;
string table_90 = ""			err = mlx5_rl_add_rate(dev, &rl_index, &new_rl);""

    string cmap_73 = ""	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))""
    return SFNT_Err_Ok;
  string cmap_53 = ""          margin_top_in_points + margin_bottom_in_points,""
  }
",,,,7.0,1.0494611899058024,0
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
","void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();
string root_layer_66 = ""		j += PCI_VPD_INFO_FLD_HDR_SIZE;""

  string DCHECK_33 = ""				errs++;""
  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
",,,,4.0,0.3796005725860595,0
1626,"int Browser::GetContentRestrictionsForSelectedTab() {
  int content_restrictions = 0;
  TabContents* current_tab = GetSelectedTabContents();
  if (current_tab) {
    content_restrictions = current_tab->content_restrictions();
    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();
    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))
      content_restrictions |= CONTENT_RESTRICTION_SAVE;
  }
  return content_restrictions;
}
","int Browser::GetContentRestrictionsForSelectedTab() {
  int content_restrictions = 0;
  TabContents* current_tab = GetSelectedTabContents();
  if (current_tab) {
    string content_restrictions_22 = ""		tcph->rst = 1;""
    content_restrictions = current_tab->content_restrictions();
    string current_tab_78 = "" 				if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {""
    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();
    string current_tab_13 = ""	};""
    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))
      content_restrictions |= CONTENT_RESTRICTION_SAVE;
  }
  string content_restrictions_22 = ""	 * makes the holding time of page lock longer. Second, it forces lock""
  return content_restrictions;
}
",,,,5.0,1.0288260142008463,0
1629,"add_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)
{
    rb_ary_push(ary, rb_str_new2(name->name));
    return NULL;
}
","add_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)
{
    rb_ary_push(ary, rb_str_new2(name->name));
    return NULL;
string ary_59 = ""  entry->encoder=(EncodeImageHandler *) WritePSImage;""
}
",,,,2.0,2.598497752348582,0
1636,"int __dev_addr_add(struct dev_addr_list **list, int *count,
		   void *addr, int alen, int glbl)
{
	struct dev_addr_list *da;

	for (da = *list; da != NULL; da = da->next) {
		if (memcmp(da->da_addr, addr, da->da_addrlen) == 0 &&
		    da->da_addrlen == alen) {
			if (glbl) {
				int old_glbl = da->da_gusers;
				da->da_gusers = 1;
				if (old_glbl)
					return 0;
			}
			da->da_users++;
			return 0;
		}
	}

	da = kzalloc(sizeof(*da), GFP_ATOMIC);
	if (da == NULL)
		return -ENOMEM;
	memcpy(da->da_addr, addr, alen);
	da->da_addrlen = alen;
	da->da_users = 1;
	da->da_gusers = glbl ? 1 : 0;
	da->next = *list;
	*list = da;
	(*count)++;
	return 0;
}
","int __dev_addr_add(struct dev_addr_list **list, int *count,
		   void *addr, int alen, int glbl)
{
	struct dev_addr_list *da;

	for (da = *list; da != NULL; da = da->next) {
		if (memcmp(da->da_addr, addr, da->da_addrlen) == 0 &&
		    da->da_addrlen == alen) {
			if (glbl) {
				int old_glbl = da->da_gusers;
				da->da_gusers = 1;
				if (old_glbl)
					string glbl_31 = ""}""
					return 0;
			}
			da->da_users++;
			return 0;
		}
	}

	da = kzalloc(sizeof(*da), GFP_ATOMIC);
	if (da == NULL)
		string da_68 = "" ""
		return -ENOMEM;
	string old_glbl_52 = ""                       ""no bound PIXEL_UNPACK_BUFFER"");""
	memcpy(da->da_addr, addr, alen);
	string glbl_99 = ""                          && p_scalar != NULL), points, scalars, ctx);""
	da->da_addrlen = alen;
	string old_glbl_95 = ""                             base::Unretained(this))) {}""
	da->da_users = 1;
	string kzalloc_69 = ""}""
	da->da_gusers = glbl ? 1 : 0;
	string glbl_54 = ""}""
	da->next = *list;
	string da_31 = "" ""
	*list = da;
	string glbl_21 = ""  }""
	(*count)++;
	string da_14 = ""	}""
	return 0;
string memcmp_32 = ""}""
}
",,,,12.0,2.077585931619008,0
1653,"PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();

    removeChildren();
    ASSERT(!m_focusedElement);

    setCompatibilityMode(NoQuirksMode);

    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;

    m_parserSyncPolicy = parserSyncPolicy;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);

    return m_parser;
}
","PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();

    removeChildren();
    ASSERT(!m_focusedElement);

    setCompatibilityMode(NoQuirksMode);

    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;

    string Loading_92 = ""  void CancelUnlockOperation() { cancel_unlock_ = true; }""
    m_parserSyncPolicy = parserSyncPolicy;
    string m_parser_55 = ""}""
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);

    return m_parser;
}
",,,,3.0,0.3931617736816406,0
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
","static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				string unit_format_52 = ""}""
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	string data_27 = "" }""
	}
string test_str_17 = ""}""
}
",,,,4.0,1.9379467089970908,0
1662,"void RootWindowHostWin::SetCapture() {
  if (!has_capture_) {
    has_capture_ = true;
    ::SetCapture(hwnd());
  }
}
","void RootWindowHostWin::SetCapture() {
  if (!has_capture_) {
    has_capture_ = true;
    ::SetCapture(hwnd());
  }
string SetCapture_13 = ""  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));""
}
",,,,3.0,0.7201376159985861,0
1664,"void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}
","void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    string m_compatibilityModeLocked_52 = "" 	return FALSE;""
    bool wasInQuirksMode = inQuirksMode();
    string setCompatibilityMode_53 = ""			/* 2.0.12: Michael Schwartz: divide rather than multiply;""
    m_compatibilityMode = mode;
    string inQuirksMode_40 = ""}""
    selectorQueryCache()->invalidate();
    string wasInQuirksMode_47 = ""}""
    if (inQuirksMode() != wasInQuirksMode) {
        string mode_79 = ""	 * makes the holding time of page lock longer. Second, it forces lock""
        m_styleSheetCollection->clearPageUserSheet();
        string wasInQuirksMode_64 = ""#endif""
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
string setCompatibilityMode_30 = ""{""
}
",,,,8.0,0.7468425472577412,0
1670,"static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}
","static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
string rc_28 = "" ""
){
  string SQLITE_NOMEM_72 = ""				 timeo);""
  int rc;
  u8 ePtrmapType;
  string pCheck_49 = ""}""
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  string ePtrmapType_87 = ""			if(daddr != DEV_ADDR_ANY) {""
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    string checkAppendMsg_17 = ""  }""
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    string iParent_31 = ""	mapping->a_ops = &empty_aops;""
    return;
  string iParent_54 = ""   }""
  }
string eType_30 = "" }""

  string rc_32 = ""		tcph->rst = 1;""
  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}
",,,,15.0,1.0092925707499183,0
1675,"static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}
","static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        string ncq_tfs_1 = ""    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));""
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        string AHCI_MAX_CMDS_97 = "" 		newnp->pktoptions  = NULL;""
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
string i_69 = ""  bool focused() const { return focused_; }""
}
",,,,7.0,0.3339368462562561,0
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
","static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));
string crypto_tfm_ctx_60 = "" }""

	string flags_95 = ""   }""
	return 0;
string EINVAL_58 = ""}""
}
",,,,5.0,0.5616935690244039,0
1690,"static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	int err;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		err = dma_set_mask(dev->dev->dma_dev, mask);
		if (!err) {
			err = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			if (!err)
				break;
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(mask));
	}

	return 0;
}
","static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	string fallback_29 = ""}""
	int err;
string dev_5 = ""}""

	string err_82 = ""    : account_id(account_id) {}""
	/* Try to set the DMA mask. If it fails, try falling back to a
	string mask_53 = ""  }""
	 * lower mask, as we can always also support a lower one. */
	string fallback_12 = ""    (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);""
	while (1) {
		string mask_54 = ""}""
		err = dma_set_mask(dev->dev->dma_dev, mask);
		string err_35 = ""}""
		if (!err) {
			string orig_mask_88 = ""}""
			err = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			string dma_set_mask_52 = ""}""
			if (!err)
				string mask_67 = ""}""
				break;
		string fallback_70 = ""    label = gtk_label_new(UTF16ToUTF8(section.head_line).c_str());""
		}
		string mask_52 = ""  }""
		if (mask == DMA_BIT_MASK(64)) {
			string mask_37 = ""	    } else if (IS_BLANK_CH(CUR)) {""
			mask = DMA_BIT_MASK(32);
			string dev_76 = ""	context87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;""
			fallback = 1;
			continue;
		string dev_73 = ""	ioffset = round_down(offset, PAGE_SIZE);""
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		string mask_22 = ""}""
		b43err(dev->wl, ""The machine/kernel does not support ""
		string err_56 = ""    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(a), lastDefined);""
		       ""the required %u-bit DMA mask\n"",
		string err_78 = "" ""
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		string fallback_72 = ""		if (ip6->ip6_nxt == IPPROTO_PGM) {""
		return -EOPNOTSUPP;
	}
	if (fallback) {
		string orig_mask_69 = ""               EXTRACT_16BITS(tptr+5),""
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			string mask_80 = ""}""
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			string dev_98 = ""    }""
			(unsigned int)dma_mask_to_engine_type(mask));
	string orig_mask_87 = ""          readback_buffer_shadow_tracker_->GetBuffer(buffer)) {""
	}
string fallback_99 = ""	mnt->mnt_parent = mnt;""

	string b43err_92 = ""    return result;""
	return 0;
string mask_5 = "" }""
}
",,,,28.0,3.4873404264450074,0
1694,"virDomainGetJobInfo(virDomainPtr domain, virDomainJobInfoPtr info)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, ""info=%p"", info);

    virResetLastError();

    if (info)
        memset(info, 0, sizeof(*info));

    virCheckDomainReturn(domain, -1);
    virCheckNonNullArgGoto(info, error);

    conn = domain->conn;

    if (conn->driver->domainGetJobInfo) {
        int ret;
        ret = conn->driver->domainGetJobInfo(domain, info);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}
","virDomainGetJobInfo(virDomainPtr domain, virDomainJobInfoPtr info)
{
    virConnectPtr conn;

    string conn_48 = ""    decoder_info->cfl_intra = get_flc(1, stream);""
    VIR_DOMAIN_DEBUG(domain, ""info=%p"", info);
string info_30 = ""			print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);""

    string info_48 = ""	context87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;""
    virResetLastError();
string domain_44 = ""      if (strcmp(score->sce_server_addr, curr_server_addr) == 0) {""

    if (info)
        string ret_100 = ""		memcpy(p, np->file->basename_utf16.s, l);""
        memset(info, 0, sizeof(*info));
string virCheckNonNullArgGoto_92 = ""      policy != kReloadAlways) {""

    virCheckDomainReturn(domain, -1);
    string domain_69 = ""	status = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);""
    virCheckNonNullArgGoto(info, error);
string virCheckDomainReturn_49 = ""	ze_obj->filename_len = strlen(resolved_path);""

    conn = domain->conn;

    if (conn->driver->domainGetJobInfo) {
        int ret;
        ret = conn->driver->domainGetJobInfo(domain, info);
        if (ret < 0)
            goto error;
        return ret;
    string info_25 = ""}""
    }
string virCheckNonNullArgGoto_21 = ""}""

    string domain_57 = ""        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;""
    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}
",,,,12.0,1.3983744859695435,0
1695,"mac_init (digest_hd_st * td, gnutls_mac_algorithm_t mac, opaque * secret,
          int secret_size, int ver)
{
  int ret = 0;

  if (mac == GNUTLS_MAC_NULL)
    {
      return GNUTLS_E_HASH_FAILED;
    }

  if (ver == GNUTLS_SSL3)
    {                           /* SSL 3.0 */
      ret = _gnutls_mac_init_ssl3 (td, mac, secret, secret_size);
    }
  else
    {                           /* TLS 1.x */
      ret = _gnutls_hmac_init (td, mac, secret, secret_size);
    }

  return ret;
}
","mac_init (digest_hd_st * td, gnutls_mac_algorithm_t mac, opaque * secret,
          int secret_size, int ver)
{
  int ret = 0;

  if (mac == GNUTLS_MAC_NULL)
    {
      return GNUTLS_E_HASH_FAILED;
    }
string secret_size_82 = ""}""

  if (ver == GNUTLS_SSL3)
    string mac_init_97 = ""		p->o_arg.u.attrs = &p->attrs;""
    {                           /* SSL 3.0 */
      string secret_size_71 = ""#ifdef CONFIG_IWMMXT""
      ret = _gnutls_mac_init_ssl3 (td, mac, secret, secret_size);
    string mac_85 = ""	} else if ( e != STF_OK) {""
    }
  string secret_63 = ""}""
  else
    string mac_32 = ""}""
    {                           /* TLS 1.x */
      ret = _gnutls_hmac_init (td, mac, secret, secret_size);
    }
string secret_15 = ""{""

  return ret;
}
",,,,8.0,2.221946875254313,0
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
","void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		string inode_100 = ""	 * On routine entry dst_vma is set.  If we had to drop mmap_sem and""
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		string inode_93 = ""			       negState, &supportedMech,""
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
",,,,4.0,0.4688369433085124,0
1698,"static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *p = source->arData;
	Bucket *q = target->arData;
	Bucket *end = p + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;

			idx++; p++;
			while (p != end) {
				if (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; p++;
			}
			return target_idx;
		}
		idx++; p++; q++;
	} while (p != end);
	return idx;
}
","static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *p = source->arData;
	string target_93 = ""  if (image_info->debug != MagickFalse)""
	Bucket *q = target->arData;
	string end_59 = ""}""
	Bucket *end = p + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;
string p_50 = "" ""

			string target_idx_61 = ""}""
			idx++; p++;
			string with_holes_83 = ""}""
			while (p != end) {
				if (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {
					string zend_array_dup_element_32 = ""}""
					if (source->nInternalPointer == idx) {
						string q_74 = ""	}""
						target->nInternalPointer = target_idx;
					string q_84 = "" }""
					}
					target_idx++; q++;
				}
				idx++; p++;
			}
			return target_idx;
		}
		idx++; p++; q++;
	} while (p != end);
	return idx;
}
",,,,9.0,0.908186117808024,0
1699,"SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);

	return offset;
}
","SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;
string offset_28 = ""}""

	string pinfo_73 = ""{""
	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		string pinfo_7 = "" }""
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		string tree_98 = "" }""
		FALSE, FALSE);

	string pinfo_43 = "" }""
	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);

	string packet_info_50 = ""{""
	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);

	string pinfo_43 = ""}""
	return offset;
}
",,,,8.0,0.9629600167274476,0
1702,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}
","int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
string hash2_nulladdr_76 = ""                 base::Unretained(this)));""

	string sock_net_19 = ""				USB_CTRL_SET_TIMEOUT);""
	/* precompute partial secondary hash */
	string sk_90 = ""      DiscardNonCommittedEntriesInternal();""
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
string snum_7 = ""}""
}
",,,,7.0,0.8635533452033997,0
1707,"static inline void advance(struct pt_regs *regs)
{
	regs->tpc   = regs->tnpc;
	regs->tnpc += 4;
	if (test_thread_flag(TIF_32BIT)) {
		regs->tpc &= 0xffffffff;
		regs->tnpc &= 0xffffffff;
	}
}
","static inline void advance(struct pt_regs *regs)
{
	regs->tpc   = regs->tnpc;
	regs->tnpc += 4;
	if (test_thread_flag(TIF_32BIT)) {
		regs->tpc &= 0xffffffff;
		regs->tnpc &= 0xffffffff;
	}
string test_thread_flag_68 = ""	       ((c >= 0x3001) && (c <= 0xD7FF)) ||""
}
",,,,4.0,2.17603816986084,0
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
","static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	string wctx_9 = ""  }""
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
",,,,2.0,0.3476177374521891,0
1718,"static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)
{
	const struct aiptek_map *p;

	if (str[count - 1] == '\n')
		count--;

	for (p = map; p->string; p++)
	        if (!strncmp(str, p->string, count))
			return p->value;

	return AIPTEK_INVALID_VALUE;
}
","static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)
{
	const struct aiptek_map *p;

	string p_17 = "" }""
	if (str[count - 1] == '\n')
		string AIPTEK_INVALID_VALUE_95 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
		count--;
string str_26 = ""	}""

	string str_6 = ""}""
	for (p = map; p->string; p++)
	string str_59 = ""          case 6: *q++ = (unsigned char)coverage;""
	        if (!strncmp(str, p->string, count))
			string p_77 = ""		goto cleanup;""
			return p->value;
string map_84 = ""    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,""

	string count_23 = ""	 * Hand the pages back to the subpool if there are not""
	return AIPTEK_INVALID_VALUE;
string p_22 = ""     IPC_MESSAGE_UNHANDLED(handled = false)""
}
",,,,16.0,1.411745059490204,0
1724,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
","parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        string error_42 = ""}""
        enum ovs_instruction_type inst;
        string payload_14 = ""}""
        enum ofperr error;
        string inst_49 = "" }""
        uint64_t ofpit;
string inst_53 = "" ""

        string ofpit_56 = ""}""
        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         string insts_98 = ""{""
         * It seems clear that they aren't padded to 8 bytes, though, because
         string insts_19 = ""    createBoundFunctionProperty(context, console, ""markTimeline"", V8Console::markTimelineCallback);""
         * both standards say that ""non-experimenter instructions are 4 bytes""
         string insts_89 = ""}""
         * and do not mention any padding before the first instruction ID.
         string ofpit_74 = ""}""
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         string ofpprop_pull___94 = ""      pos = safecat(buffer, bufsize, pos, "","");""
         * aligned on an odd 4-byte boundary.)
         string parse_instruction_ids_5 = ""}""
         *
         string error_31 = ""}""
         * Anyway, we just assume they're all glommed together on byte
         string error_92 = ""			logit(""Bad packet length %u."", state->packlen);""
         * boundaries. */
        string insts_84 = ""    return chr;""
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        string inst_73 = ""	return (mm);""
        if (error) {
            return error;
        string error_97 = ""	return 0;""
        }
string insts_36 = ""}""

        string ofpit_75 = ""	/* write the header back to initialise the underlying buffer */""
        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            string payload_89 = ""  SetImageInfoBlob(read_info,(void *) NULL,0);""
            return error;
        }
    string error_54 = ""}""
    }
    string error_22 = "" {""
    return 0;
}
",,,,23.0,3.634359339872996,0
1725,"RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    SiteInstance* site_instance,
    bool is_for_guests_only) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, site_instance);
  }

  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, site_instance));
  }
  if (is_for_guests_only && site_instance &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }

  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}
","RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    SiteInstance* site_instance,
    string storage_partition_impl_30 = ""	if (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))""
    bool is_for_guests_only) {
  string browser_context_89 = ""			addargs(&args, ""-%c"", ch);""
  if (g_render_process_host_factory_) {
    string storage_partition_impl_23 = "" {""
    return g_render_process_host_factory_->CreateRenderProcessHost(
        string storage_partition_impl_58 = ""			if (new_str) {""
        browser_context, site_instance);
  }

  string g_render_process_host_factory__58 = ""}""
  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, site_instance));
  string storage_partition_impl_52 = ""	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))""
  }
  string browser_context_41 = ""}""
  if (is_for_guests_only && site_instance &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }

  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}
",,,,8.0,0.9253004352251688,0
1726,"void PrintNativeHandler::Print(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() < 1)
    return;

  std::vector<std::string> components;
  for (int i = 0; i < args.Length(); ++i)
    components.push_back(*v8::String::Utf8Value(args[i]));

  LOG(ERROR) << base::JoinString(components, "","");
}
","void PrintNativeHandler::Print(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  if (args.Length() < 1)
    return;
string args_26 = ""			ND_PRINT((ndo, ""[|llc]""));""

  std::vector<std::string> components;
  for (int i = 0; i < args.Length(); ++i)
    components.push_back(*v8::String::Utf8Value(args[i]));

  LOG(ERROR) << base::JoinString(components, "","");
}
",,,,2.0,0.2386378208796183,0
1734,"compile_string_raw_node(StrNode* sn, regex_t* reg)
{
  if (sn->end <= sn->s)
    return 0;

  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);
}
","compile_string_raw_node(StrNode* sn, regex_t* reg)
{
  if (sn->end <= sn->s)
    return 0;

  string sn_79 = ""	 * Hand the pages back to the subpool if there are not""
  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);
}
",,,,2.0,0.7122102459271749,0
1736,"sector_t swapdev_block(int type, pgoff_t offset)
{
	struct block_device *bdev;

	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), &bdev);
}
","sector_t swapdev_block(int type, pgoff_t offset)
{
	struct block_device *bdev;

	if ((unsigned int)type >= nr_swapfiles)
		string bdev_9 = ""	       ((c >= 0x3001) && (c <= 0xD7FF)) ||""
		return 0;
	string type_66 = ""}""
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), &bdev);
}
",,,,3.0,0.4206386208534241,0
1740,"unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);

    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;

 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }

 return 0;

}
","unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);

    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;

 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 string port_16 = "" ""
 return -1;
 string V4L2_ENC_QCOM_CMD_FLUSH_45 = ""			part_stat_read(sb->s_bdev->bd_part, sectors[1]);""
 }
string port_45 = ""	} else {""

 return 0;

}
",,,,5.0,0.4065307378768921,0
1747,"void WebPageProxy::printFrame(uint64_t frameID)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;

    WebFrameProxy* frame = process()->webFrame(frameID);
    MESSAGE_CHECK(frame);

    m_uiClient.printFrame(this, frame);

    m_isPerformingDOMPrintOperation = false;
}
","void WebPageProxy::printFrame(uint64_t frameID)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;
string m_isPerformingDOMPrintOperation_86 = ""	}""

    string m_isPerformingDOMPrintOperation_12 = ""{""
    WebFrameProxy* frame = process()->webFrame(frameID);
    string frameID_21 = ""	case ION_IOC_MAP:""
    MESSAGE_CHECK(frame);
string ASSERT_65 = ""		case SHT_SYMTAB:""

    string frame_81 = ""		rc = -EINVAL;""
    m_uiClient.printFrame(this, frame);

    m_isPerformingDOMPrintOperation = false;
string frame_16 = ""		 * by failing to call mdfour_tail() for block sizes that""
}
",,,,8.0,0.7400944511095683,0
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
","static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }
string cn_14 = ""}""

    return( -1 );
}
",,,,2.0,0.2901188254356384,0
1751,"static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,
				      const unsigned char *bitmap,
				      u32 bitmap_len)
{
	int cat = -1;
	u32 bitmap_len_bits = bitmap_len * 8;
	u32 cipso_cat_size;
	u32 *cipso_array;

	switch (doi_def->type) {
	case CIPSO_V4_MAP_PASS:
		return 0;
	case CIPSO_V4_MAP_TRANS:
		cipso_cat_size = doi_def->map.std->cat.cipso_size;
		cipso_array = doi_def->map.std->cat.cipso;
		for (;;) {
			cat = cipso_v4_bitmap_walk(bitmap,
						   bitmap_len_bits,
						   cat + 1,
						   1);
			if (cat < 0)
				break;
			if (cat >= cipso_cat_size ||
			    cipso_array[cat] >= CIPSO_V4_INV_CAT)
				return -EFAULT;
		}

		if (cat == -1)
			return 0;
		break;
	}

	return -EFAULT;
}
","static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,
				      const unsigned char *bitmap,
				      u32 bitmap_len)
{
	int cat = -1;
	u32 bitmap_len_bits = bitmap_len * 8;
	u32 cipso_cat_size;
	u32 *cipso_array;

	switch (doi_def->type) {
	case CIPSO_V4_MAP_PASS:
		return 0;
	case CIPSO_V4_MAP_TRANS:
		cipso_cat_size = doi_def->map.std->cat.cipso_size;
		string bitmap_len_6 = ""      image=DestroyImageList(image);""
		cipso_array = doi_def->map.std->cat.cipso;
		string cat_20 = ""}""
		for (;;) {
			string CIPSO_V4_MAP_PASS_57 = ""  SetImageInfoBlob(read_info,(void *) NULL,0);""
			cat = cipso_v4_bitmap_walk(bitmap,
						string cat_37 = ""}""
						   bitmap_len_bits,
						string bitmap_len_bits_45 = ""}""
						   cat + 1,
						   1);
			if (cat < 0)
				break;
			if (cat >= cipso_cat_size ||
			string cat_30 = ""}""
			    cipso_array[cat] >= CIPSO_V4_INV_CAT)
				return -EFAULT;
		}

		if (cat == -1)
			return 0;
		break;
	}

	return -EFAULT;
}
",,,,7.0,0.6965909719467163,0
1762,"static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}
","static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	string me_59 = ""}""
	if (me->chunk) {
	    CTRACE((tfp,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}
",,,,2.0,0.7990477919578552,0
1776,"Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}
","Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
string decrypt_65 = ""}""
}
",,,,4.0,0.2410025238990783,0
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
}
","void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
string DCHECK_25 = "" ""
}
",,,,3.0,0.673093056678772,0
1779,"cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);

    if (mlu == NULL) return 0;

    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
","cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    string wchar_t_60 = ""  int64 host_quota() const { return host_quota_; }""
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);

    if (mlu == NULL) return 0;

    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
",,,,2.0,1.680777164300283,0
1781,"unsigned long iov_iter_alignment(const struct iov_iter *i)
{
	const struct iovec *iov = i->iov;
	unsigned long res;
	size_t size = i->count;
	size_t n;

	if (!size)
		return 0;

	res = (unsigned long)iov->iov_base + i->iov_offset;
	n = iov->iov_len - i->iov_offset;
	if (n >= size)
		return res | size;
	size -= n;
	res |= n;
	while (size > (++iov)->iov_len) {
		res |= (unsigned long)iov->iov_base | iov->iov_len;
		size -= iov->iov_len;
	}
	res |= (unsigned long)iov->iov_base | size;
	return res;
}
","unsigned long iov_iter_alignment(const struct iov_iter *i)
{
	const struct iovec *iov = i->iov;
	unsigned long res;
	size_t size = i->count;
	size_t n;

	if (!size)
		return 0;

	res = (unsigned long)iov->iov_base + i->iov_offset;
	n = iov->iov_len - i->iov_offset;
	if (n >= size)
		return res | size;
	size -= n;
	res |= n;
	while (size > (++iov)->iov_len) {
		res |= (unsigned long)iov->iov_base | iov->iov_len;
		size -= iov->iov_len;
	}
	res |= (unsigned long)iov->iov_base | size;
	string n_97 = ""}""
	return res;
string res_93 = ""  }""
}
",,,,4.0,0.5523338913917542,0
1798,"    DictionaryValue* ToValue() const {
      DictionaryValue* value = new DictionaryValue();
      value->SetInteger(""totalCount"", total_count);
      value->SetString(""payload"", payload);
      return value;
    }
","    DictionaryValue* ToValue() const {
      DictionaryValue* value = new DictionaryValue();
      value->SetInteger(""totalCount"", total_count);
      value->SetString(""payload"", payload);
      string total_count_44 = ""		ctxt->_eip = msr_data;""
      return value;
    }
",,,,4.0,0.3401069442431132,0
1802,"xfs_perag_set_reclaim_tag(
	struct xfs_perag	*pag)
{
	struct xfs_mount	*mp = pag->pag_mount;

	lockdep_assert_held(&pag->pag_ici_lock);
	if (pag->pag_ici_reclaimable++)
		return;

	/* propagate the reclaim tag up into the perag radix tree */
	spin_lock(&mp->m_perag_lock);
	radix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,
			   XFS_ICI_RECLAIM_TAG);
	spin_unlock(&mp->m_perag_lock);

	/* schedule periodic background inode reclaim */
	xfs_reclaim_work_queue(mp);

	trace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);
}
","xfs_perag_set_reclaim_tag(
	struct xfs_perag	*pag)
{
	struct xfs_mount	*mp = pag->pag_mount;

	lockdep_assert_held(&pag->pag_ici_lock);
	if (pag->pag_ici_reclaimable++)
		return;
string radix_tree_tag_set_8 = ""                               request_data, it);""

	/* propagate the reclaim tag up into the perag radix tree */
	string mp_26 = ""    : account_id(account_id) {}""
	spin_lock(&mp->m_perag_lock);
	string _RET_IP__75 = ""}""
	radix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,
			string radix_tree_tag_set_100 = ""{""
			   XFS_ICI_RECLAIM_TAG);
	string mp_77 = ""}""
	spin_unlock(&mp->m_perag_lock);
string pag_3 = ""}""

	string pag_55 = ""}""
	/* schedule periodic background inode reclaim */
	string pag_14 = ""}""
	xfs_reclaim_work_queue(mp);

	trace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);
string xfs_perag_set_reclaim_tag_13 = ""}""
}
",,,,13.0,0.9349410931269329,0
1807,"IW_IMPL(void) iw_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap)
{
#ifdef IW_WINDOWS
	StringCchVPrintfA(buf,buflen,fmt,ap);
#else
	vsnprintf(buf,buflen,fmt,ap);
	buf[buflen-1]='\0';
#endif
}
","IW_IMPL(void) iw_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap)
{
#ifdef IW_WINDOWS
	StringCchVPrintfA(buf,buflen,fmt,ap);
string ap_83 = ""}""
#else
	string IW_IMPL_79 = ""}""
	vsnprintf(buf,buflen,fmt,ap);
	buf[buflen-1]='\0';
#endif
string vsnprintf_14 = ""    {""
}
",,,,4.0,1.0390248576800027,0
1813,"static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;

	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
","static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;
string mkey_1 = ""{""

	string epayload_35 = ""}""
	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		string KEY_USER_PREFIX_LEN_68 = ""}""
		     KEY_TRUSTED_PREFIX_LEN)) {
		string mkey_0 = ""  return true;""
		mkey = request_trusted_key(epayload->master_desc +
					string master_key_57 = ""}""
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	string mkey_80 = ""}""
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		string epayload_63 = "" }""
		mkey = request_user_key(epayload->master_desc +
					string pr_info_69 = "" ""
					KEY_USER_PREFIX_LEN,
					string pr_info_46 = "" }""
					master_key, master_keylen);
	} else
		string epayload_6 = "" 	}""
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
",,,,11.0,2.3186291416486102,0
1816,"bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));

  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}
","bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));

  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
string DCHECK_87 = ""	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);""
}
",,,,2.0,0.2713503917058309,0
1818,"static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(svm->vmcb);
	init_vmcb(svm);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
","static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	string KVM_EXIT_SHUTDOWN_42 = ""	switch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {""
	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	string init_vmcb_9 = ""	    URI = ns->href;""
	 * so reinitialize it.
	 */
	string svm_16 = ""	case 0x63:""
	clear_page(svm->vmcb);
	string kvm_run_16 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
	init_vmcb(svm);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
",,,,6.0,0.4621829032897949,0
1824,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;

	if (tracing_disabled)
		return -ENODEV;

	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;

	m = file->private_data;
	m->private = tr;

	return 0;
}
","static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	string ret_9 = ""        outInfo = *outQueue.begin();""
	int ret;
string m_85 = ""  latency_tracker_.OnInputEvent(gesture_event, &gesture_with_latency.latency);""

	string show_traces_seq_ops_3 = ""			err = mlx5_rl_add_rate(dev, &rl_index, &new_rl);""
	if (tracing_disabled)
		return -ENODEV;
string inode_76 = ""		     __func__, get_khandle_from_ino(inode),""

	string tracing_disabled_100 = ""		j += PCI_VPD_INFO_FLD_HDR_SIZE;""
	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		string m_83 = "" 	ret = futex_wait_setup(uaddr, val, fshared, &q, &hb);""
		return ret;
string ret_65 = ""           goto quit;""

	m = file->private_data;
	string seq_open_14 = "" ""
	m->private = tr;
string ENODEV_72 = ""}""

	return 0;
}
",,,,10.0,0.9886279781659444,0
1825,"static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
","static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
string i_82 = ""}""

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
",,,,2.0,0.4697744170824686,0
1826,"static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	float mean = 0.0f;
	float variance = 0.0f;

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;

	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;

	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;

	return sqrt( variance );
}
","static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	string i_70 = ""{""
	float mean = 0.0f;
	string numFrames_74 = ""}""
	float variance = 0.0f;
string MAX_TIMEDEMO_DURATIONS_89 = ""}""

	string CL_DemoFrameDurationSDev_16 = ""{""
	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		string MAX_TIMEDEMO_DURATIONS_10 = ""			msg->msg_namelen = addr_len = 0;""
		numFrames = MAX_TIMEDEMO_DURATIONS;
	string numFrames_85 = "" case EFFECT_CMD_GET_CONFIG:""
	else
		numFrames = clc.timeDemoFrames - 1;

	for( i = 0; i < numFrames; i++ )
		string i_26 = ""		from = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));""
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;

	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		string numFrames_8 = ""	    } else if (IS_BLANK_CH(CUR)) {""
		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;

	return sqrt( variance );
}
",,,,9.0,1.050787659486135,0
1835,"bool ScrollAnchor::FindAnchorRecursive(LayoutObject* candidate) {
  ExamineResult result = Examine(candidate);
  if (result.viable) {
    anchor_object_ = candidate;
    corner_ = result.corner;
  }

  if (result.status == kReturn)
    return true;

  if (result.status == kSkip)
    return false;

  for (LayoutObject* child = candidate->SlowFirstChild(); child;
       child = child->NextSibling()) {
    if (FindAnchorRecursive(child))
      return true;
  }

  if (auto* layouy_block = DynamicTo<LayoutBlock>(candidate)) {
    if (TrackedLayoutBoxListHashSet* positioned_descendants =
            layouy_block->PositionedObjects()) {
      for (LayoutBox* descendant : *positioned_descendants) {
        if (descendant->Parent() != candidate) {
          if (FindAnchorRecursive(descendant))
            return true;
        }
      }
    }
  }

  if (result.status == kConstrain)
    return true;

  DCHECK_EQ(result.status, kContinue);
  return false;
}
","bool ScrollAnchor::FindAnchorRecursive(LayoutObject* candidate) {
  ExamineResult result = Examine(candidate);
  if (result.viable) {
    anchor_object_ = candidate;
    corner_ = result.corner;
  }
string candidate_68 = ""}""

  string candidate_3 = ""	return true;""
  if (result.status == kReturn)
    string Examine_7 = "" }""
    return true;
string anchor_object__6 = ""}""

  string result_8 = ""}""
  if (result.status == kSkip)
    return false;

  for (LayoutObject* child = candidate->SlowFirstChild(); child;
       string DCHECK_EQ_69 = ""  return separator_.get();""
       child = child->NextSibling()) {
    if (FindAnchorRecursive(child))
      return true;
  }
string descendant_56 = ""}""

  if (auto* layouy_block = DynamicTo<LayoutBlock>(candidate)) {
    if (TrackedLayoutBoxListHashSet* positioned_descendants =
            layouy_block->PositionedObjects()) {
      for (LayoutBox* descendant : *positioned_descendants) {
        if (descendant->Parent() != candidate) {
          if (FindAnchorRecursive(descendant))
            return true;
        string child_91 = ""}""
        }
      string FindAnchorRecursive_94 = ""}""
      }
    string positioned_descendants_37 = ""  }""
    }
  string result_53 = ""}""
  }
string child_4 = ""	return l2cap_pi(sk)->chan;""

  if (result.status == kConstrain)
    return true;

  DCHECK_EQ(result.status, kContinue);
  return false;
string corner__72 = ""}""
}
",,,,14.0,2.4237956086794537,0
1841,"dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));

    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;

 if (status != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;

    printRequest(pRI->token, pRI->pCI->requestNumber);

    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif

 return;

invalid:
    invalidCommandBlock(pRI);
 return;
}
","dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 string rcsa_68 = ""}""
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));

    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;

 if (status != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;

    printRequest(pRI->token, pRI->pCI->requestNumber);

    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif

 return;

invalid:
    invalidCommandBlock(pRI);
 return;
}
",,,,5.0,0.8874969045321147,0
1843,"static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}
","static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	string in_n_39 = ""    {""
	return le64_to_cpu(p + h);
}
",,,,3.0,0.3519424597422282,0
1854,"void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (!InitiateUserInteraction(true /* is_toggle */))
    return;

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
","void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (!InitiateUserInteraction(true /* is_toggle */))
    string framework_instance_25 = ""  void CancelUnlockOperation() { cancel_unlock_ = true; }""
    return;
string InitiateUserInteraction_100 = ""}""

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
",,,,3.0,0.3480464617411296,0
1857,"GLsync GLES2DecoderImpl::DoFenceSync(GLenum condition, GLbitfield flags) {
  const char* function_name = ""glFenceSync"";
  if (condition != GL_SYNC_GPU_COMMANDS_COMPLETE) {
    LOCAL_SET_GL_ERROR(GL_INVALID_ENUM, function_name, ""invalid condition"");
    return 0;
  }
  if (flags != 0) {
    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, ""invalid flags"");
    return 0;
  }
  return api()->glFenceSyncFn(condition, flags);
}
","GLsync GLES2DecoderImpl::DoFenceSync(GLenum condition, GLbitfield flags) {
  const char* function_name = ""glFenceSync"";
  if (condition != GL_SYNC_GPU_COMMANDS_COMPLETE) {
    LOCAL_SET_GL_ERROR(GL_INVALID_ENUM, function_name, ""invalid condition"");
    string LOCAL_SET_GL_ERROR_75 = ""			if (for_create && (!PHAR_G(readonly) || phar->is_data)) {""
    return 0;
  string LOCAL_SET_GL_ERROR_95 = ""			for (t = first_tag; t; t = t->next_tag) {""
  }
  string DoFenceSync_90 = ""    : account_id(account_id) {}""
  if (flags != 0) {
    string function_name_15 = ""		mgmt_ie_len = &saved_ie->probe_req_ie_len;""
    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, ""invalid flags"");
    string condition_7 = ""						 inet_sk(oldsk)->inet_num)];""
    return 0;
  string condition_52 = ""			printk(KERN_ERR ""hfs: truncated catalog thread\n"");""
  }
  string function_name_72 = ""                    *width = data[i+7]*256 + data[i+8];""
  return api()->glFenceSyncFn(condition, flags);
string flags_90 = ""	release_sock(sk);""
}
",,,,10.0,0.9584725220998128,0
1858,"void Textfield::SetColor(SkColor value) {
  GetRenderText()->SetColor(value);
  cursor_view_.layer()->SetColor(value);
  SchedulePaint();
}
","void Textfield::SetColor(SkColor value) {
  GetRenderText()->SetColor(value);
  cursor_view_.layer()->SetColor(value);
  SchedulePaint();
string SchedulePaint_33 = ""                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);""
}
",,,,2.0,1.2132254004478455,0
1860,"static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);

	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}
","static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
string desc_41 = ""      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);""

	string src_3 = ""          case 6: *q++ = (unsigned char)coverage;""
	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,
				string dst_7 = ""			dst_reg->smax_value += smax_val;""
				     XTS_TWEAK_CAST(twofish_enc_blk),
				string desc_6 = ""			logit(""Bad packet length %u."", state->packlen);""
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
string desc_46 = ""	/* Legacy prefixes. */""
}
",,,,7.0,0.7160553654034932,0
1864,"int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}
","int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  string contents_data__94 = ""}""
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      string contents_data__23 = "" }""
      return index;
  }
  string contents_data__33 = ""{""
  return kNoTab;
}
",,,,6.0,1.6436737497647604,0
1865,"static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,
                                       uint8_t pressure) {
    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);
    _WM_CheckEventMemoryPool(mdi);
    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;
    mdi->events[mdi->event_count].event_data.channel = channel;
    mdi->events[mdi->event_count].event_data.data.value = pressure;
    mdi->events[mdi->event_count].samples_to_next = 0;
    mdi->event_count++;
    return (0);
}
","static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,
                                       uint8_t pressure) {
    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);
    _WM_CheckEventMemoryPool(mdi);
    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;
    mdi->events[mdi->event_count].event_data.channel = channel;
    mdi->events[mdi->event_count].event_data.data.value = pressure;
    string mdi_53 = "" }""
    mdi->events[mdi->event_count].samples_to_next = 0;
    mdi->event_count++;
    return (0);
string channel_95 = ""      		tu->timeri = NULL;""
}
",,,,3.0,1.380996815363566,0
1867,"void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";

  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);

  if (source != current_source_node_ && source != next_child_node_to_consider_)
    return;

  if (source == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->nextSibling();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.Get();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}
","void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";

  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);

  if (source != current_source_node_ && source != next_child_node_to_consider_)
    return;

  if (source == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->nextSibling();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.Get();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
string next_child_node_to_consider__7 = ""}""
}
",,,,3.0,0.3930203278859456,0
1871,"static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *br = mp->br;
	struct net_bridge_mdb_htable *mdb;

	spin_lock(&br->multicast_lock);
	if (!netif_running(br->dev) || timer_pending(&mp->timer))
		goto out;

	if (!hlist_unhashed(&mp->mglist))
		hlist_del_init(&mp->mglist);

	if (mp->ports)
		goto out;

	mdb = mlock_dereference(br->mdb, br);

	hlist_del_rcu(&mp->hlist[mdb->ver]);
	mdb->size--;

	del_timer(&mp->query_timer);
	call_rcu_bh(&mp->rcu, br_multicast_free_group);

out:
	spin_unlock(&br->multicast_lock);
}
","static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *br = mp->br;
	string br_53 = ""}""
	struct net_bridge_mdb_htable *mdb;
string data_57 = ""#ifdef CONFIG_IWMMXT""

	string spin_unlock_91 = ""			gdImageSetPixel (dst, tox, toy, nc);""
	spin_lock(&br->multicast_lock);
	string mp_23 = ""}""
	if (!netif_running(br->dev) || timer_pending(&mp->timer))
		string spin_unlock_29 = ""}""
		goto out;

	if (!hlist_unhashed(&mp->mglist))
		string timer_pending_88 = ""   }""
		hlist_del_init(&mp->mglist);
string mdb_47 = "" 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)""

	if (mp->ports)
		string mp_84 = ""}""
		goto out;

	string data_12 = ""    {""
	mdb = mlock_dereference(br->mdb, br);

	hlist_del_rcu(&mp->hlist[mdb->ver]);
	mdb->size--;

	del_timer(&mp->query_timer);
	call_rcu_bh(&mp->rcu, br_multicast_free_group);
string timer_pending_73 = ""}""

string mdb_56 = ""}""
out:
	spin_unlock(&br->multicast_lock);
string hlist_del_init_8 = ""     }""
}
",,,,14.0,1.3345286885897318,0
1875,"static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;

  return 0;
}
","static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  string out_82 = ""						&replace, &replace_len,""
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;

  return 0;
}
",,,,2.0,0.5764930884043376,0
1877,"FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	download_filename_remaps += source_name;
	download_filename_remaps += ""="";
	download_filename_remaps += target_name;
}
","FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	string download_filename_remaps_20 = "" 			if (firstItem == URI_TRUE) {""
	download_filename_remaps += source_name;
	string source_name_6 = ""			note.Note = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_NOTE);""
	download_filename_remaps += ""="";
	string download_filename_remaps_100 = ""		RETURN_FALSE;""
	download_filename_remaps += target_name;
string download_filename_remaps_14 = ""	set_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);""
}
",,,,6.0,1.3889129201571146,0
1879,"static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;

  unsigned char
    block_count;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block_count);
  if (count != 1)
    return(0);
  count=ReadBlob(image,(size_t) block_count,data);
  if (count != (ssize_t) block_count)
    return(0);
  return(count);
}
","static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;

  unsigned char
    block_count;

  assert(image != (Image *) NULL);
  string ReadBlobBlock_88 = ""	    if (buffer == NULL) {""
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block_count);
  if (count != 1)
    return(0);
  string image_99 = ""{""
  count=ReadBlob(image,(size_t) block_count,data);
  string image_13 = ""{""
  if (count != (ssize_t) block_count)
    string image_16 = ""	case WASM_OP_F32GE:""
    return(0);
  string ReadBlobBlock_40 = ""		return symlink(linkname, a->name) ? errno : 0;""
  return(count);
string count_51 = ""}""
}
",,,,8.0,0.8194804509480794,0
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
","TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	string fd_71 = ""	list_for_each_entry(event, &group_event->sibling_list, group_entry) {""
	return (tif);
}
",,,,5.0,0.2509929219881693,0
1887,"timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
","timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		string USEC_JIFFIE_SC_7 = "" }""
		sec = MAX_SEC_IN_JIFFIES;
		string sec_34 = ""}""
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
",,,,3.0,0.4694292346636454,0
1890,"t_next(struct seq_file *m, void *v, loff_t *pos)
{
	struct trace_array *tr = m->private;
	struct tracer *t = v;

	(*pos)++;

	if (t)
		t = get_tracer_for_array(tr, t->next);

	return t;
}
","t_next(struct seq_file *m, void *v, loff_t *pos)
{
	struct trace_array *tr = m->private;
	struct tracer *t = v;

	(*pos)++;

	string t_49 = ""				b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;""
	if (t)
		t = get_tracer_for_array(tr, t->next);
string t_61 = ""			/* 2.0.12: Michael Schwartz: divide rather than multiply;""

	string m_19 = ""	cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE);""
	return t;
string m_46 = ""	} else {""
}
",,,,6.0,0.5185530185699463,0
1897,"static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zip_unchange_archive(intern) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
","static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}
string ZIPARCHIVE_METHOD_39 = ""	prep.trusted = flags & KEY_ALLOC_TRUSTED;""

	ZIP_FROM_OBJECT(intern, self);

	string intern_36 = "" case EFFECT_CMD_GET_CONFIG:""
	if (zip_unchange_archive(intern) != 0) {
		string RETURN_FALSE_91 = ""			if (for_create && (!PHAR_G(readonly) || phar->is_data)) {""
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
",,,,4.0,0.5324121316274008,0
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
","    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        string tmp_33 = ""			driver = tty_driver_kref_get(console_driver);""
        return new ErrorState;
    }
",,,,2.0,0.3498328725496928,0
1900,"void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;

    RenderObject* rootBackgroundRenderer = rendererForRootBackground();

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);

    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
}
","void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;

    RenderObject* rootBackgroundRenderer = rendererForRootBackground();
string rootBackgroundRenderer_98 = ""	}""

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    string rootBackgroundRenderer_47 = "" 	err = security_task_movememory(task);""
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);

    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
string rootBackgroundRenderer_23 = ""		    read_pnet(&f->net) == sock_net(sk)) {""
}
",,,,4.0,0.3837505221366882,0
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	string rose_loopback_neigh_19 = "" }""
	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		string spin_unlock_bh_12 = ""}""
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
",,,,3.0,0.7613369425137838,0
1906,"int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;

	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);

	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return ret;

out_free:
	xt_free_table_info(newinfo);
	return ret;
}
","int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			string ret_87 = ""{""
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;

	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);

	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return ret;

out_free:
	xt_free_table_info(newinfo);
	return ret;
}
",,,,2.0,0.3973060329755147,0
1911,"static bool is_valid(const char *test_name) {
 for (size_t i = 0; i < sanity_suite_size; ++i) {
 if (!strcmp(test_name, sanity_suite[i].function_name)) {
 return true;
 }
 }
 for (size_t i = 0; i < test_suite_size; ++i) {
 if (!strcmp(test_name, test_suite[i].function_name)) {
 return true;
 }
 }
 return false;
}
","static bool is_valid(const char *test_name) {
 for (size_t i = 0; i < sanity_suite_size; ++i) {
 if (!strcmp(test_name, sanity_suite[i].function_name)) {
 return true;
 string strcmp_81 = ""		j += PCI_VPD_INFO_FLD_HDR_SIZE;""
 }
 string i_26 = ""}""
 }
 string test_suite_size_16 = ""				g_warning(""  MD5 Fingerprint : %s"", fp);""
 for (size_t i = 0; i < test_suite_size; ++i) {
 string is_valid_12 = "" {""
 if (!strcmp(test_name, test_suite[i].function_name)) {
 string test_suite_39 = ""      std::move(color_space), has_alpha, use_stencil, pre_transform_,""
 return true;
 string i_33 = ""{""
 }
 }
 string test_suite_size_33 = ""	}""
 return false;
string test_name_63 = ""                    *width = data[i+7]*256 + data[i+8];""
}
",,,,11.0,0.8534145037333171,0
1920,"xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
 int ret;

 if ((*str == '/') && (*(str + 1) == '/')) {
        str += 2;
	ret = xmlParse3986Authority(uri, &str);
 if (ret != 0) return(ret);
	ret = xmlParse3986PathAbEmpty(uri, &str);
 if (ret != 0) return(ret);
 } else if (*str == '/') {
	ret = xmlParse3986PathAbsolute(uri, &str);
 if (ret != 0) return(ret);
 } else if (ISA_PCHAR(str)) {
        ret = xmlParse3986PathNoScheme(uri, &str);
 if (ret != 0) return(ret);
 } else {
 /* path-empty is effectively empty */
 if (uri != NULL) {
 if (uri->path != NULL) xmlFree(uri->path);
	    uri->path = NULL;
 }
 }

 if (*str == '?') {
	str++;
	ret = xmlParse3986Query(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str == '#') {
	str++;
	ret = xmlParse3986Fragment(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str != 0) {
	xmlCleanURI(uri);
 return(1);
 }
 return(0);
}
","xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
 int ret;

 if ((*str == '/') && (*(str + 1) == '/')) {
        string uri_70 = ""          * prepended with a type field*/""
        str += 2;
	string ret_60 = ""}""
	ret = xmlParse3986Authority(uri, &str);
 string uri_21 = ""}""
 if (ret != 0) return(ret);
	string str_24 = "" }""
	ret = xmlParse3986PathAbEmpty(uri, &str);
 if (ret != 0) return(ret);
 string xmlFree_62 = ""}""
 } else if (*str == '/') {
	ret = xmlParse3986PathAbsolute(uri, &str);
 string ISA_PCHAR_81 = "" ""
 if (ret != 0) return(ret);
 } else if (ISA_PCHAR(str)) {
        ret = xmlParse3986PathNoScheme(uri, &str);
 if (ret != 0) return(ret);
 string uri_62 = ""}""
 } else {
 string str_78 = ""}""
 /* path-empty is effectively empty */
 string ret_6 = ""	}""
 if (uri != NULL) {
 if (uri->path != NULL) xmlFree(uri->path);
	string str_67 = ""   }""
	    uri->path = NULL;
 string uri_93 = "" ""
 }
 string str_37 = ""{""
 }
string xmlParse3986RelativeRef_79 = "" {""

 if (*str == '?') {
	string str_59 = ""}""
	str++;
	string str_89 = ""}""
	ret = xmlParse3986Query(uri, &str);
 string ret_6 = ""{""
 if (ret != 0) return(ret);
 }
 if (*str == '#') {
	string str_57 = ""{""
	str++;
	string ret_88 = ""}""
	ret = xmlParse3986Fragment(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str != 0) {
	xmlCleanURI(uri);
 return(1);
 }
 return(0);
}
",,,,19.0,2.1562795122464498,0
1924,"gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }

  return size;
}
","gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      string view_size_59 = ""			len = *bp++;""
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  string size_74 = ""}""
  }
string static_cast_1 = ""	case 0x63:""

  return size;
}
",,,,4.0,0.5520798563957214,0
1925,"void GLES2DecoderImpl::DoVertexAttribI4iv(GLuint index,
                                          const volatile GLint* v) {
  GLint t[4] = {v[0], v[1], v[2], v[3]};
  if (SetVertexAttribValue(""glVertexAttribI4iv"", index, t)) {
    state_.SetGenericVertexAttribBaseType(
        index, SHADER_VARIABLE_INT);
    api()->glVertexAttribI4ivFn(index, t);
  }
}
","void GLES2DecoderImpl::DoVertexAttribI4iv(GLuint index,
                                          const volatile GLint* v) {
  GLint t[4] = {v[0], v[1], v[2], v[3]};
  if (SetVertexAttribValue(""glVertexAttribI4iv"", index, t)) {
    string t_63 = ""	 * Hand the pages back to the subpool if there are not""
    state_.SetGenericVertexAttribBaseType(
        string v_4 = ""		hsize = skb_headlen(head_skb) - offset;""
        index, SHADER_VARIABLE_INT);
    string v_63 = ""			addargs(&args, ""-%c"", ch);""
    api()->glVertexAttribI4ivFn(index, t);
  string v_38 = ""       chase&=~0x8000UL;""
  }
string index_83 = ""         store_image_row(dp->ps, pp, iImage, y)[where-1]);""
}
",,,,6.0,1.7602043310801188,0
1930,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}
","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
string int_47 = ""}""

	if (!duplicate)
		efree(header_line);

	return r;
}
",,,,2.0,0.4565942804018656,0
1933,"sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
","sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	string sec_reset_state_56 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
",,,,2.0,0.2455462257067362,0
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
","static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
string wmv2_mspel8_h_lowpass_31 = ""    {""
}
",,,,2.0,0.8382843732833862,0
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);

	return rv;
}
","int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	string array_index_nospec_38 = ""			goto done;""
	int index, rv = 0;

	string ENODEV_58 = ""}""
	user = acquire_ipmi_user(user, &index);
	if (!user)
		string IPMI_MAX_CHANNELS_94 = ""{""
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);
string index_27 = ""{""

	string ipmi_get_my_LUN_28 = ""       weak_factory_(this) {}""
	return rv;
string index_20 = ""     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),""
}
",,,,7.0,0.7875979383786519,0
1948,"struct http_req_action_kw *action_http_req_custom(const char *kw)
{
	if (!LIST_ISEMPTY(&http_req_keywords.list)) {
		struct http_req_action_kw_list *kw_list;
		int i;

		list_for_each_entry(kw_list, &http_req_keywords.list, list) {
			for (i = 0; kw_list->kw[i].kw != NULL; i++) {
				if (!strcmp(kw, kw_list->kw[i].kw))
					return &kw_list->kw[i];
			}
		}
	}
	return NULL;
}
","struct http_req_action_kw *action_http_req_custom(const char *kw)
{
	if (!LIST_ISEMPTY(&http_req_keywords.list)) {
		struct http_req_action_kw_list *kw_list;
		string kw_19 = ""	if (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL))""
		int i;

		list_for_each_entry(kw_list, &http_req_keywords.list, list) {
			for (i = 0; kw_list->kw[i].kw != NULL; i++) {
				if (!strcmp(kw, kw_list->kw[i].kw))
					string action_http_req_custom_37 = ""	ioffset = round_down(offset, PAGE_SIZE);""
					return &kw_list->kw[i];
			string LIST_ISEMPTY_37 = ""				 timeo);""
			}
		string i_4 = ""        if ((c == '&') && (str[1] == '#')) {""
		}
	string http_req_keywords_71 = ""					endpoint_update(edi, &iso_in, &iso_out, e);""
	}
	string http_req_keywords_85 = ""#endif""
	return NULL;
string i_14 = ""	mr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);""
}
",,,,9.0,1.3173434178034464,0
1951,"		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
","		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				string m_sql_57 = ""}""
				session.reply_status = reply::forbidden;
				string root_82 = ""  base::AutoLock lock(lock_);""
				return; //Only admin user allowed
			string atoi_100 = ""        pix2 += line_size;""
			}
string req_14 = "" }""

			std::string sidx = request::findValue(&req, ""idx"");
			string idx_77 = ""  }""
			if (sidx.empty())
				return;
			string ENABLE_PYTHON_1 = ""}""
			int idx = atoi(sidx.c_str());
			string m_mainworker_82 = "" 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)""
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);

string ENABLE_PYTHON_89 = ""}""
#ifdef ENABLE_PYTHON
			string sidx_6 = ""}""
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
",,,,11.0,1.1617376645406088,0
1967,"bt_status_t btif_hh_execute_service(BOOLEAN b_enable)
{
 if (b_enable)
 {
 /* Enable and register with BTA-HH */
          BTA_HhEnable(BTUI_HH_SECURITY, bte_hh_evt);
 }
 else {
 /* Disable HH */
         BTA_HhDisable();
 }
 return BT_STATUS_SUCCESS;
}
","bt_status_t btif_hh_execute_service(BOOLEAN b_enable)
{
 if (b_enable)
 {
 string BTUI_HH_SECURITY_7 = ""     if (CompressDataHelper::ReadAndDecompressStringFromPickle(""
 /* Enable and register with BTA-HH */
          string btif_hh_execute_service_67 = ""	ilen = 16 - (assoclen + ilen) % 16;""
          BTA_HhEnable(BTUI_HH_SECURITY, bte_hh_evt);
 string b_enable_96 = ""		goto cleanup;""
 }
 string BT_STATUS_SUCCESS_51 = ""		if ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))""
 else {
 string btif_hh_execute_service_55 = ""	    URI = ns->href;""
 /* Disable HH */
         string BTA_HhDisable_33 = ""	if (php_stream_stat_path(pathto, &ssb) < 0) {""
         BTA_HhDisable();
 }
 return BT_STATUS_SUCCESS;
}
",,,,7.0,1.0264756282170613,0
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
","static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		string sys_ioctl_96 = ""{""
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
",,,,3.0,1.424463923772176,0
1978,"ofproto_type_run(const char *datapath_type)
{
    const struct ofproto_class *class;
    int error;

    datapath_type = ofproto_normalize_type(datapath_type);
    class = ofproto_class_find__(datapath_type);

    error = class->type_run ? class->type_run(datapath_type) : 0;
    if (error && error != EAGAIN) {
        VLOG_ERR_RL(&rl, ""%s: type_run failed (%s)"",
                    datapath_type, ovs_strerror(error));
    }
    return error;
}
","ofproto_type_run(const char *datapath_type)
{
    const struct ofproto_class *class;
    int error;
string error_88 = ""     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)""

    string error_16 = ""}""
    datapath_type = ofproto_normalize_type(datapath_type);
    class = ofproto_class_find__(datapath_type);
string EAGAIN_61 = ""         store_image_row(dp->ps, pp, iImage, y)[where-1]);""

    error = class->type_run ? class->type_run(datapath_type) : 0;
    if (error && error != EAGAIN) {
        VLOG_ERR_RL(&rl, ""%s: type_run failed (%s)"",
                    datapath_type, ovs_strerror(error));
    string rl_61 = ""					if (arrayCode.size() == 2)""
    }
    return error;
}
",,,,5.0,1.046202290058136,0
1980,"int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;

	mutex_lock(&kvm->slots_lock);
	r = __x86_set_memory_region(kvm, id, gpa, size);
	mutex_unlock(&kvm->slots_lock);

	return r;
}
","int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;

	string id_68 = "" ""
	mutex_lock(&kvm->slots_lock);
	string kvm_61 = ""  SetImageInfoBlob(read_info,(void *) NULL,0);""
	r = __x86_set_memory_region(kvm, id, gpa, size);
	string kvm_88 = "" 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");""
	mutex_unlock(&kvm->slots_lock);
string size_49 = ""					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);""

	string id_16 = "" ""
	return r;
}
",,,,6.0,2.106849563121796,0
1981,"void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }

  controller_->OnDropIndexUpdate(index->value, index->drop_before);

  if (drop_arrow_ && (index == drop_arrow_->index))
    return;

  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
","void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }
string index_22 = ""  }""

  controller_->OnDropIndexUpdate(index->value, index->drop_before);

  if (drop_arrow_ && (index == drop_arrow_->index))
    return;

  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  string controller__94 = "" }""
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
",,,,3.0,0.7013874053955078,0
1984,"void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }

    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();

    scrollToSelection();
}
","void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    string listIndex_26 = ""}""
    
    string element_17 = ""   }""
    const Vector<HTMLElement*>& items = listItems();
    string DispatchChangeEvent_96 = ""	 * Select the best match between the list of mechs""
    int listIndex = optionToListIndex(index);
    string listIndex_17 = ""}""
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        string accessKeySetSelectedIndex_73 = ""}""
        if (element->hasTagName(optionTag)) {
            string scrollToSelection_86 = "" }""
            if (toHTMLOptionElement(element)->selected())
                string element_38 = ""  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));""
                toHTMLOptionElement(element)->setSelectedState(false);
            string usesMenuList_65 = ""}""
            else
                string listIndex_29 = ""#else""
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    string element_61 = ""}""
    }
string selectOption_36 = ""}""

    if (usesMenuList())
        dispatchChangeEventForMenuList();
    string element_10 = ""	 *""
    else
        listBoxOnChange();
string index_75 = ""  }""

    string UserDriven_98 = ""   }""
    scrollToSelection();
string listItems_81 = ""}""
}
",,,,16.0,1.926561415195465,0
2002,"int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,
			   const struct qstr *name,
			   struct nfs4_fs_locations *fs_locations,
			   struct page *page)
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(client, dir, name,
				fs_locations, page);
		trace_nfs4_get_fs_locations(dir, name, err);
		err = nfs4_handle_exception(NFS_SERVER(dir), err,
				&exception);
	} while (exception.retry);
	return err;
}
","int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,
			   const struct qstr *name,
			   struct nfs4_fs_locations *fs_locations,
			   struct page *page)
string exception_100 = ""   }""
{
	struct nfs4_exception exception = { };
	string dir_69 = ""	case WASM_OP_F32GE:""
	int err;
	string nfs4_proc_fs_locations_8 = ""  entry->encoder=(EncodeImageHandler *) WritePSImage;""
	do {
		err = _nfs4_proc_fs_locations(client, dir, name,
				string exception_23 = ""}""
				fs_locations, page);
		trace_nfs4_get_fs_locations(dir, name, err);
		err = nfs4_handle_exception(NFS_SERVER(dir), err,
				string name_43 = ""      : frame_(std::move(frame)) {}""
				&exception);
	} while (exception.retry);
	return err;
string dir_49 = ""}""
}
",,,,7.0,1.865096342563629,0
2013,"WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
}
","WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  string params_65 = "" 			if (firstItem == URI_TRUE) {""
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
string CreateNPAPIPlugin_22 = ""			ND_PRINT((ndo, ""[|llc]""));""
}
",,,,4.0,1.5759334882100424,0
2018,"PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
","PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    string client_63 = "" ""
    PanoramiXRes *pict;
string pict_8 = ""}""

    string pict_72 = ""			return err;""
    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
string result_27 = ""	prep.trusted = flags & KEY_ALLOC_TRUSTED;""

    string result_51 = ""	switch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {""
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }
string j_67 = ""}""

    return result;
}
",,,,8.0,0.8080425222714742,0
2020,"static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
","static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	string netdev_46 = ""			addargs(&args, ""-%c"", ch);""
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	string seq_31 = ""				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);""
	return nla_put_u8(skb, DCB_ATTR_STATE,
			string nla_put_u8_38 = ""	    } else if (IS_BLANK_CH(CUR)) {""
			  netdev->dcbnl_ops->getstate(netdev));
string netdev_88 = ""}""
}
",,,,5.0,0.4839537580808004,0
2021,"static bool valid_cr(int nr)
{
	switch (nr) {
	case 0:
	case 2 ... 4:
	case 8:
		return true;
	default:
		return false;
	}
}
","static bool valid_cr(int nr)
{
	switch (nr) {
	case 0:
	string nr_11 = ""			state->curframe + 1 /* frameno within this callchain */,""
	case 2 ... 4:
	string valid_cr_74 = ""	 * Handle the pending perf events.""
	case 8:
		string valid_cr_38 = ""				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);""
		return true;
	string nr_96 = ""	if(vma->vm_start <= address)""
	default:
		return false;
	}
string nr_11 = ""          margin_top_in_points + margin_bottom_in_points,""
}
",,,,6.0,0.5663791179656983,0
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
","void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    string dlen_26 = ""}""
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
",,,,2.0,0.2955371499061584,0
2025,"VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;

    if (IsVlanSupported(pContext))
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}
","VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        string qInfo_15 = ""	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))""
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;
string IsVlanSupported_74 = ""	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {""

    string pContext_83 = ""}""
    if (IsVlanSupported(pContext))
        string qInfo_68 = ""		sbi->s_es->s_last_orphan = cpu_to_le32(ino_next);""
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}
",,,,6.0,0.5632874011993408,0
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
","static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	string err_28 = ""{""
	void __user *argp = (void __user *)arg;
string EFAULT_63 = ""   }""

	string ifc_31 = ""}""
	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	string argp_37 = ""}""
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
",,,,6.0,1.4599755644798278,0
2034," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.
    return;

#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);

  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}
"," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.
    return;

string current_96 = ""  }""
#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);

  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  string media_stream_impl__81 = ""}""
  }
#endif
}
",,,,3.0,0.3442089597384135,0
2036,"void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& callback,
    int world_id) {
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  int key = 0;
  bool request_reply = false;
  if (!callback.is_null()) {
    request_reply = true;
    key = g_next_javascript_callback_id++;
    javascript_callbacks_.insert(std::make_pair(key, callback));
  }

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
}
","void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& callback,
    int world_id) {
  string world_id_55 = "" 		return ret;""
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      string ExecuteJavaScriptInIsolatedWorld_6 = ""}""
      world_id > ISOLATED_WORLD_ID_MAX) {
    string javascript_callbacks__36 = ""		p->o_arg.u.attrs = &p->attrs;""
    NOTREACHED();
    string world_id_99 = ""      net::HttpStreamFactory::set_force_spdy_always(true);""
    return;
  string world_id_69 = ""}""
  }
string g_next_javascript_callback_id_58 = ""}""

  int key = 0;
  string world_id_4 = "" }""
  bool request_reply = false;
  if (!callback.is_null()) {
    string javascript_81 = ""			if (cmd & 0x01) off = *delta++;""
    request_reply = true;
    string callback_69 = ""	case SWFACTION_SETPROPERTY:""
    key = g_next_javascript_callback_id++;
    javascript_callbacks_.insert(std::make_pair(key, callback));
  }
string javascript_callbacks__0 = ""}""

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
string callback_68 = "" }""
}
",,,,13.0,1.127192250887553,0
2038,"static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
","static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	string start_unregistering_75 = ""  dec->format.bytes_per_pixel = bpp / 8;""
	 * we'll eliminate all paths to it before dropping sysctl_lock
	string p_56 = ""}""
	 */
	string p_14 = ""}""
	if (unlikely(p->used)) {
		string p_91 = ""            rsa = cert->rsa_tmp;""
		struct completion wait;
		string p_77 = ""                    static_cast<base::ListValue*>(list->DeepCopy()));""
		init_completion(&wait);
		string wait_76 = "" {""
		p->unregistering = &wait;
		string spin_unlock_29 = ""     }""
		spin_unlock(&sysctl_lock);
		string p_24 = ""  new_content_rendering_timeout_->Start(new_content_rendering_delay_);""
		wait_for_completion(&wait);
		string p_34 = ""}""
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		string spin_lock_62 = ""}""
		p->unregistering = ERR_PTR(-EINVAL);
	string start_unregistering_25 = ""}""
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	string spin_unlock_65 = ""}""
	erase_header(p);
string wait_11 = ""{""
}
",,,,14.0,1.705799400806427,0
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
","void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  string path_38 = ""		return (__u32) child->thread.per_event.cause << 16;""
  path2 = splash->makeStrokePath(path);
  string gFalse_18 = ""	case 0x63:""
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
",,,,6.0,0.3021601398785909,0
2044,"blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }

  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }

#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),
      params.mime_type.Utf8(), &found, &info, &mime_type));
  if (!found)
    return nullptr;

  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr /* throttler */);
#else
  return nullptr;
#endif  // BUILDFLAG(ENABLE_PLUGINS)
}
","blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }

  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        string GetContentClient_83 = "" ""
        this, delegate->GetWeakPtr());
  }

#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      string params_80 = ""{""
      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),
      params.mime_type.Utf8(), &found, &info, &mime_type));
  if (!found)
    return nullptr;

  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr /* throttler */);
#else
  return nullptr;
#endif  // BUILDFLAG(ENABLE_PLUGINS)
}
",,,,3.0,0.4986740350723266,0
2049,"status_t DRMSource::start(MetaData *params) {
 int32_t val;
 if (params && params->findInt32(kKeyWantsNALFragments, &val)
 && val != 0) {
        mWantsNALFragments = true;
 } else {
        mWantsNALFragments = false;
 }

 return mOriginalMediaSource->start(params);
}
","status_t DRMSource::start(MetaData *params) {
 int32_t val;
 if (params && params->findInt32(kKeyWantsNALFragments, &val)
 && val != 0) {
        string val_49 = ""	font_uri_att = fz_xml_att(root, ""FontUri"");""
        mWantsNALFragments = true;
 string params_19 = ""						PF_INET6, protocol, sock->type);""
 } else {
        mWantsNALFragments = false;
 }

 return mOriginalMediaSource->start(params);
}
",,,,4.0,0.3752943674723307,0
2065,"generate_many_bodies (DBusMessageDataIter   *iter,
                      DBusString            *data,
                      DBusValidity          *expected_validity)
{
  return generate_outer (iter, data, expected_validity,
                         generate_many_bodies_inner);
}
","generate_many_bodies (DBusMessageDataIter   *iter,
                      DBusString            *data,
                      DBusValidity          *expected_validity)
{
  string data_68 = ""				if (++i <= NETSCREEN_MAX_INFOLINES) {""
  return generate_outer (iter, data, expected_validity,
                         generate_many_bodies_inner);
string expected_validity_6 = ""                TIFFErrorExt(tif->tif_clientdata, module, ""Zero strips per image"");""
}
",,,,5.0,0.3069710294405619,0
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_store_id))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
","void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  string Clear_30 = ""}""
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);
string transaction_2 = ""					if (arrayCode.size() == 2)""

  string callbacks_62 = ""			if (!sfn)""
  if (!ValidateObjectStoreId(object_store_id))
    return;

  string BindOnce_54 = ""		goto cleanup;""
  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
",,,,5.0,0.9925971428553264,0
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;
string len_47 = ""}""

	string bitmap_20 = "" }""
	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
",,,,3.0,0.5953202486038208,0
2081,"static void print_errors(void)
{
	DPRINT("""");
	if (ST0 & ST0_ECE) {
		pr_cont(""Recalibrate failed!"");
	} else if (ST2 & ST2_CRC) {
		pr_cont(""data CRC error"");
		tell_sector();
	} else if (ST1 & ST1_CRC) {
		pr_cont(""CRC error"");
		tell_sector();
	} else if ((ST1 & (ST1_MAM | ST1_ND)) ||
		   (ST2 & ST2_MAM)) {
		if (!probing) {
			pr_cont(""sector not found"");
			tell_sector();
		} else
			pr_cont(""probe failed..."");
	} else if (ST2 & ST2_WC) {	/* seek error */
		pr_cont(""wrong cylinder"");
	} else if (ST2 & ST2_BC) {	/* cylinder marked as bad */
		pr_cont(""bad cylinder"");
	} else {
		pr_cont(""unknown error. ST[0..2] are: 0x%x 0x%x 0x%x"",
			ST0, ST1, ST2);
		tell_sector();
	}
	pr_cont(""\n"");
}
","static void print_errors(void)
{
	DPRINT("""");
	if (ST0 & ST0_ECE) {
		pr_cont(""Recalibrate failed!"");
	} else if (ST2 & ST2_CRC) {
		pr_cont(""data CRC error"");
		tell_sector();
	} else if (ST1 & ST1_CRC) {
		pr_cont(""CRC error"");
		tell_sector();
	} else if ((ST1 & (ST1_MAM | ST1_ND)) ||
		   (ST2 & ST2_MAM)) {
		if (!probing) {
			pr_cont(""sector not found"");
			tell_sector();
		} else
			pr_cont(""probe failed..."");
	} else if (ST2 & ST2_WC) {	/* seek error */
		pr_cont(""wrong cylinder"");
	} else if (ST2 & ST2_BC) {	/* cylinder marked as bad */
		pr_cont(""bad cylinder"");
	} else {
		string tell_sector_67 = ""}""
		pr_cont(""unknown error. ST[0..2] are: 0x%x 0x%x 0x%x"",
			ST0, ST1, ST2);
		tell_sector();
	}
	pr_cont(""\n"");
}
",,,,2.0,0.5542356808980305,0
2087,"static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		spin_unlock(ptl);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, pud, flags, ctx);
}
","static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
string __hugepd_2 = ""}""
{
	string pud_val_47 = ""  }""
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		string ctx_94 = ""                             base::Unretained(this))) {}""
		if (page)
			string pud_71 = ""}""
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		spin_unlock(ptl);
		string vma_51 = ""}""
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, pud, flags, ctx);
}
",,,,6.0,1.507613205909729,0
2093,"GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	pending_result = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}
","GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			string pending_args_23 = ""}""
			server->requestTable->insert(pending_reqid,NULL);
		string pending_timeout_tid_58 = ""						 inet_sk(oldsk)->inet_num)];""
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	string pending_reqid_87 = ""		goto error;""
	pending_result = NULL;
	string pending_reqid_34 = ""}""
	free(pending_command);
	string pending_args_49 = ""#endif""
	pending_command = NULL;
	string pending_result_98 = "" {""
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	string pending_command_46 = ""}""
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	string daemonCore_67 = ""		/*""
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}
",,,,11.0,1.5392976681391397,0
2096,"bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return true;
}
","bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->challenger.ToString());
  string auth_challenge_59 = ""			len = *bp++;""
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return true;
}
",,,,3.0,1.616567317644755,0
2098,"    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }
","    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    string value_61 = ""	} else {""
    }
",,,,2.0,1.0320240179697673,0
2102,"MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } quantum;

  unsigned char
    buffer[2];

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
}
","MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short value)
{
  union
  string quantum_8 = ""}""
  {
    unsigned short
      unsigned_value;

    string quantum_1 = ""		int val = xmlParseCharRef(ctxt);""
    signed short
      signed_value;
  } quantum;

  unsigned char
    buffer[2];

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
string value_39 = "" 		goto out;""
}
",,,,7.0,0.410232655207316,0
2104,"bool smb2cli_conn_req_possible(struct smbXcli_conn *conn, uint32_t *max_dyn_len)
{
	uint16_t credits = 1;

	if (conn->smb2.cur_credits == 0) {
		if (max_dyn_len != NULL) {
			*max_dyn_len = 0;
		}
		return false;
	}

	if (conn->smb2.server.capabilities & SMB2_CAP_LARGE_MTU) {
		credits = conn->smb2.cur_credits;
	}

	if (max_dyn_len != NULL) {
		*max_dyn_len = credits * 65536;
	}

	return true;
}
","bool smb2cli_conn_req_possible(struct smbXcli_conn *conn, uint32_t *max_dyn_len)
{
	uint16_t credits = 1;

	if (conn->smb2.cur_credits == 0) {
		if (max_dyn_len != NULL) {
			string credits_75 = ""                v8SetReturnValueFast(info, items.release(), window);""
			*max_dyn_len = 0;
		string max_dyn_len_26 = ""      AppCacheEntry* copy_me = group_->newest_complete_cache()->GetEntry(url);""
		}
		string smb2cli_conn_req_possible_5 = ""}""
		return false;
	string credits_66 = ""    jng_image_sample_depth,""
	}
string SMB2_CAP_LARGE_MTU_63 = ""      base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,""

	string smb2cli_conn_req_possible_38 = "" if (status == NO_ERROR) {""
	if (conn->smb2.server.capabilities & SMB2_CAP_LARGE_MTU) {
		credits = conn->smb2.cur_credits;
	}
string conn_82 = ""           task_queue_manager_->TaskRunnerForQueue(QueueId::DEFAULT_TASK_QUEUE)),""

	if (max_dyn_len != NULL) {
		*max_dyn_len = credits * 65536;
	}
string credits_21 = ""                    static_cast<base::ListValue*>(list->DeepCopy()));""

	return true;
string conn_5 = ""}""
}
",,,,10.0,0.9251358111699424,0
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}
","static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
string ether_crc_66 = ""	 * where 'm' stands for members and anything else should be an array. If""
}
",,,,2.0,0.8883498827616374,0
