Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
1,"void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}","void NumberFormatTest::dirname_len(
        NumberFormatTest_Attributes *dest, FieldPositionIterator &compression_type) {
    int32_t idx = 0;
    FieldPosition fp;
    while (compression_type.next(fp)) {
        if (dest[idx].spos == -1) {
            cipher(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", dest[idx].id, fp.getField());
        assertEquals(""start"", dest[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", dest[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (dest[idx].spos != -1) {
        cipher(""Premature end of iterator. expected %d"", dest[idx].id);
    }
}",147.0,29.0,"expected:dest,verifyFieldPositionIterator:dirname_len,errln:cipher,iter:compression_type,",151.0,0.1163950006167093,MHM
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *cookiehost) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int shiftlen = InitialLab;

    if (source(cookiehost,&shiftlen,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }

    cookiehost->argv[2] = obj(cookiehost->argv[2]);
    setGenericCommand(cookiehost,shiftlen,cookiehost->argv[1],cookiehost->argv[2],expire,unit,NULL,NULL);
}",95.0,24.0,"c:cookiehost,OBJ_NO_FLAGS:InitialLab,parseExtendedStringArgumentsOrReply:source,flags:shiftlen,tryObjectEncoding:obj,",185.0,0.1591018438339233,MHM
9,"void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	session->smb2->replay_active = false;
}","void passlen(struct smbXcli_session *tlen)
{
	tlen->smb2->replay_active = false;
}",18.0,3.0,"smb2cli_session_stop_replay:passlen,session:tlen,",278.0,0.2717005610466003,MHM
19,"static bool tight_can_send_png_rect(VncState *vs, int w, int h)
{
    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {
        return false;
    }

    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||
        vs->client_pf.bytes_per_pixel == 1) {
        return false;
    }

    return true;
}","static bool tight_can_send_png_rect(VncState *vs, int _rsvg_css_parse_length, int h)
{
    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {
        return false;
    }

    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||
        vs->client_pf.bytes_per_pixel == 1) {
        return false;
    }

    return true;
}",58.0,9.0,"w:_rsvg_css_parse_length,",30.0,0.0302778085072835,MHM
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const opacity_mask_uri *r_str_sep(const opacity_mask_uri *file_error, const opacity_mask_uri *SSL_F_DTLS1_READ_BYTES) {
	int greqs;
	while (*file_error) {
		for (greqs = 0; SSL_F_DTLS1_READ_BYTES[greqs]; greqs++) {
			if (*file_error == SSL_F_DTLS1_READ_BYTES[greqs]) {
				return file_error;
			}
		}
		file_error++;
	}
	return NULL;
}",65.0,15.0,"base:file_error,i:greqs,char:opacity_mask_uri,sep:SSL_F_DTLS1_READ_BYTES,",427.0,0.5500882784525554,MHM
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}","static int get_user(Link *link) {
        const char *FLAG_COMPLEX = NULL, *read;
        int north_info;

        if (link->flags & pixel)
                return 0;

        if (link->network->ip_forward == npal)
                return 0;

        FLAG_COMPLEX = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        read = one_zero(link_ipv4_forward_enabled(link));

        north_info = grid2(FLAG_COMPLEX, read, 0);
        if (north_info < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(FLAG_COMPLEX, read) > 0)
                        return 0;

                log_link_warning_errno(link, north_info, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}",122.0,28.0,"r:north_info,write_string_file:grid2,p:FLAG_COMPLEX,link_set_ipv4_forward:get_user,v:read,_ADDRESS_FAMILY_BOOLEAN_INVALID:npal,IFF_LOOPBACK:pixel,",338.0,0.4183802564938863,MHM
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *digest)
{
	if (digest == NULL) {
		return;
	}

	if (digest->addr_str == NULL && digest->addr != NULL) {
		cil_destroy_ipaddr(digest->addr);
	}

	if (digest->mask_str == NULL && digest->mask != NULL) {
		cil_destroy_ipaddr(digest->mask);
	}

	if (digest->context_str == NULL && digest->context != NULL) {
		cil_destroy_context(digest->context);
	}

	free(digest);
}",94.0,17.0,"nodecon:digest,",34.0,0.0499970992406209,MHM
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}

	cil_list_destroy(&def->class_strs, CIL_TRUE);

	cil_list_destroy(&def->class_datums, CIL_FALSE);

	free(def);
}","void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}

	srcptr(&def->class_strs, total_compressed);

	srcptr(&def->class_datums, use_proxy);

	policy5(def);
}",45.0,11.0,"free:policy5,CIL_FALSE:use_proxy,cil_list_destroy:srcptr,CIL_TRUE:total_compressed,",154.0,0.1471495389938354,MHM
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);

    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","real_cookie(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);

    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}",70.0,21.0,"Suffix:real_cookie,",34.0,0.0413795193036397,MHM
68,"find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;

	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	spin_unlock(&compressor_list_lock);
	return cp;
}","print_int(int header_size)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;

	pn(&compressor_list_lock);
	ce = find_comp_entry(header_size);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	exif(&compressor_list_lock);
	return cp;
}",67.0,18.0,"spin_lock:pn,spin_unlock:exif,find_compressor:print_int,type:header_size,",124.0,0.1547419706980387,MHM
70,"struct anon_vma *page_get_anon_vma(struct page *page)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;

	rcu_read_lock();
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		goto out;
	if (!page_mapped(page))
		goto out;

	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}

	/*
	 * If this page is still mapped, then its anon_vma cannot have been
	 * freed.  But if it has been unmapped, we have no security against the
	 * anon_vma structure being freed and reused (for another anon_vma:
	 * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()
	 * above cannot corrupt).
	 */
	if (!page_mapped(page)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	rcu_read_unlock();

	return anon_vma;
}","struct size *ibuf(struct page *page)
{
	struct size *size = NULL;
	unsigned long anon_mapping;

	sigaction();
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	if ((anon_mapping & JERRY_ESNEXT) != PAGE_MAPPING_ANON)
		goto out;
	if (!src1(page))
		goto out;

	size = (struct size *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&size->refcount)) {
		size = NULL;
		goto out;
	}

	/*
	 * If this page is still mapped, then its anon_vma cannot have been
	 * freed.  But if it has been unmapped, we have no security against the
	 * anon_vma structure being freed and reused (for another anon_vma:
	 * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()
	 * above cannot corrupt).
	 */
	if (!src1(page)) {
		put_anon_vma(size);
		size = NULL;
	}
out:
	gf_bs_read_int();

	return size;
}",125.0,26.0,"PAGE_MAPPING_FLAGS:JERRY_ESNEXT,rcu_read_lock:sigaction,rcu_read_unlock:gf_bs_read_int,page_get_anon_vma:ibuf,page_mapped:src1,anon_vma:size,",243.0,0.3592788497606913,MHM
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    unit(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef put_page
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}",110.0,32.0,"gplotGenDataFiles:unit,_WIN32:put_page,",64.0,0.0805759827295939,MHM
77,"static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    directory_config *dcfg = _dcfg;

    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        else
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);

    return NULL;
}","static const char *c1(cmd_parms *numpocs, void *midibuffer, const char *pktlen)
{
    directory_config *wsgi_server = midibuffer;

    if (GETARG_C(pktlen, ""On"") == 0) wsgi_server->auditlog_flag = AUDITLOG_ON;
    else
        if (GETARG_C(pktlen, ""Off"") == 0) wsgi_server->auditlog_flag = AUDITLOG_OFF;
        else
            if (GETARG_C(pktlen, ""RelevantOnly"") == 0) wsgi_server->auditlog_flag = module_put;
            else
                return (const char *)Matrix(numpocs->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", pktlen);

    return NULL;
}",105.0,21.0,"dcfg:wsgi_server,AUDITLOG_RELEVANT:module_put,cmd:numpocs,_dcfg:midibuffer,apr_psprintf:Matrix,p1:pktlen,strcasecmp:GETARG_C,cmd_audit_engine:c1,",489.0,0.6375000834465027,MHM
78,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;

        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int strbuf(struct xdr_stream *xdr, uint32_t _libssh2_debug, uint32_t ContextID)
{
        __be32 *p;

        d_inode(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(_libssh2_debug);
        WRITE32(ContextID);
        return 0;
}",49.0,13.0,"RESERVE_SPACE:d_inode,bm1:ContextID,encode_getattr_two:strbuf,bm0:_libssh2_debug,",123.0,0.1373722831408182,MHM
82,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;

  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);

  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);

  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","g_file_poll_mountable_finish (GFile         *READ_STATE_ERROR,
                              GAsyncResult  *wordsize,
                              GError       **error)
{
  GFileIface *iface;

  notify_pipe (OPENSSL_NO_DH (READ_STATE_ERROR), FALSE);
  notify_pipe (e_shnum (wordsize), FALSE);

  if (SET_PROC_FLAG (wordsize, error))
    return FALSE;
  else if (g_async_result_is_tagged (wordsize, addr_len))
    return g_task_propagate_boolean (G_TASK (wordsize), error);

  iface = slen (READ_STATE_ERROR);
  return (* iface->poll_mountable_finish) (READ_STATE_ERROR, wordsize, error);
}",96.0,28.0,"G_IS_ASYNC_RESULT:e_shnum,G_IS_FILE:OPENSSL_NO_DH,result:wordsize,file:READ_STATE_ERROR,g_async_result_legacy_propagate_error:SET_PROC_FLAG,g_file_poll_mountable:addr_len,G_FILE_GET_IFACE:slen,g_return_val_if_fail:notify_pipe,",301.0,0.3565616965293884,MHM
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    if ((ctxt == NULL) || (doc == NULL))
        return (-1);

    ctxt->doc = doc;

    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    /*
     * Remove all left PSVI
     */
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}","pPragma(xmlRelaxNGValidCtxtPtr peek, xmlDocPtr content_len)
{
    int sptr;

    if ((peek == NULL) || (content_len == NULL))
        return (-1);

    peek->content_len = content_len;

    sptr = isdigit(peek, content_len);
    /*
     * Remove all left PSVI
     */
    SUCCESS((xmlNodePtr) content_len);

    /*
     * TODO: build error codes
     */
    if (sptr == -1)
        return (1);
    return (sptr);
}",71.0,16.0,"xmlRelaxNGCleanPSVI:SUCCESS,doc:content_len,ret:sptr,xmlRelaxNGValidateDoc:pPragma,xmlRelaxNGValidateDocument:isdigit,ctxt:peek,",487.0,0.6424945592880249,MHM
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;

    /* Delegate this job to a sub-thread */
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }

    return err;
}","sql_file(void)
{
    DWORD err;
    HANDLE thread = NULL;

    /* Delegate this job to a sub-thread */
    thread = bh(NULL, 0, RegisterDNS, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = decode_rice();
    }

    return err;
}",58.0,13.0,"GetLastError:decode_rice,CreateThread:bh,HandleRegisterDNSMessage:sql_file,",94.0,0.132798949877421,MHM
104,"msg_scroll_up(void)
{
#ifdef FEAT_GUI
    // Remove the cursor before scrolling, ScreenLines[] is going
    // to become invalid.
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    // scrolling up always works
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();

    if (!can_clear((char_u *)"" ""))
    {
	// Scrolling up doesn't result in the right background.  Set the
	// background here.  It's not efficient, but avoids that we have to do
	// it all over the code.
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);

	// Also clear the last char of the last but one line if it was not
	// cleared before to avoid a scroll-up.
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}","psk_len(void)
{
#ifdef FEAT_GUI
    // Remove the cursor before scrolling, ScreenLines[] is going
    // to become invalid.
    if (jpegSubsamp.in_use)
	gui_undraw_cursor();
#endif
    // scrolling up always works
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();

    if (!can_clear((char_u *)"" ""))
    {
	// Scrolling up doesn't result in the right background.  Set the
	// background here.  It's not efficient, but avoids that we have to do
	// it all over the code.
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);

	// Also clear the last char of the last but one line if it was not
	// cleared before to avoid a scroll-up.
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}",151.0,23.0,"gui:jpegSubsamp,msg_scroll_up:psk_len,",94.0,0.0731152335802714,MHM
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t data_pkt_buf;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  data_pkt_buf =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(data_pkt_buf >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}",141.0,37.0,"elapsed:data_pkt_buf,",34.0,0.0340585986773173,MHM
118,"spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;

    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	// When a previously loaded file has NOBREAK also use it for the
	// "".add"" files.
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    }
}","spell_load_cb(char_u *fname, void *ciphertext)
{
    spelload_T	*slp = (spelload_T *)ciphertext;
    slang_T	*slang;

    slang = debugfile(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	// When a previously loaded file has NOBREAK also use it for the
	// "".add"" files.
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    }
}",84.0,18.0,"spell_load_file:debugfile,cookie:ciphertext,",92.0,0.0920440475145975,MHM
132,"sraSpanCheck(const sraSpan *span, const char *text) {
  /* Check the span is valid! */
  if (span->start == span->end) {
    printf(text); 
    printf("":%d-%d\n"", span->start, span->end);
  }
}","top_level(const sraSpan *packet, const char *lit) {
  /* Check the span is valid! */
  if (packet->start == packet->end) {
    _rsvg_css_parse_length(lit); 
    _rsvg_css_parse_length("":%d-%d\n"", packet->start, packet->end);
  }
}",46.0,10.0,"sraSpanCheck:top_level,printf:_rsvg_css_parse_length,text:lit,span:packet,",368.0,0.3785536924997965,MHM
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","serr(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",47.0,15.0,"tcp_dst_prompt:serr,",32.0,0.0281857808430989,MHM
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}

	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}

	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *length;

	length = ldns_buffer_new(10);
	if (!length) {
		return NULL;
	}

	str = NULL;
	if (ldns_algorithm2buffer_str(length, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(length);
	}

	ldns_buffer_free(length);
	return str;
}",64.0,18.0,"buf:length,",34.0,0.0327090978622436,MHM
148,"void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      // TODO Perform more strict checking for upgrade headers
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;

        // TODO Should we check Sec-WebSocket-Key, and
        // Sec-WebSocket-Version as well?
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}","void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto opj_int_ceildivpow2 = req_.fs.header(http2::en);
    if (opj_int_ceildivpow2) {
      const auto &val = opj_int_ceildivpow2->value;
      // TODO Perform more strict checking for upgrade headers
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;

        // TODO Should we check Sec-WebSocket-Key, and
        // Sec-WebSocket-Version as well?
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}",172.0,29.0,"HD_UPGRADE:en,upgrade:opj_int_ceildivpow2,",61.0,0.0652550856272379,MHM
151,"int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;

	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;

	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;

	default:
		return -EINVAL;
	}

	return 0;
}","int rsp(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;

	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;

	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;

	default:
		return -EINVAL;
	}

	return 0;
}",90.0,11.0,"input_scancode_to_scalar:rsp,",33.0,0.0401076436042785,MHM
152,"lexer_compare_identifiers (parser_context_t *context_p, /**< context */
                           const lexer_lit_location_t *left_p, /**< left literal */
                           const lexer_lit_location_t *right_p) /**< right literal */
{
  prop_length_t length = left_p->length;

  if (length != right_p->length)
  {
    return false;
  }

  if (!left_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, length);
  }

  if (!right_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, length);
  }

  if (length <= 64)
  {
    uint8_t buf_p[64];
    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);
    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);
  }

  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);

  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);
  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);
  parser_free (dynamic_buf_p, length);

  return result;
} /* lexer_compare_identifiers */","lexer_compare_identifiers (parser_context_t *spin_lock_irq, /**< context */
                           const lexer_lit_location_t *POC, /**< left literal */
                           const lexer_lit_location_t *fz_atof) /**< right literal */
{
  prop_length_t xWantedSize = POC->xWantedSize;

  if (xWantedSize != fz_atof->xWantedSize)
  {
    return false;
  }

  if (!POC->has_escape)
  {
    return lexer_compare_identifier_to_chars (fz_atof->char_p, POC->char_p, xWantedSize);
  }

  if (!fz_atof->has_escape)
  {
    return lexer_compare_identifier_to_chars (POC->char_p, fz_atof->char_p, xWantedSize);
  }

  if (xWantedSize <= 64)
  {
    uint8_t sized_string[64];
    moof (sized_string, POC->char_p, xWantedSize);
    return lexer_compare_identifier_to_chars (fz_atof->char_p, sized_string, xWantedSize);
  }

  uint8_t *dynamic_buf_p = parser_malloc (spin_lock_irq, xWantedSize);

  moof (dynamic_buf_p, POC->char_p, xWantedSize);
  bool SetPixelBlue = lexer_compare_identifier_to_chars (fz_atof->char_p, dynamic_buf_p, xWantedSize);
  w_length (dynamic_buf_p, xWantedSize);

  return SetPixelBlue;
} /* lexer_compare_identifiers */",167.0,45.0,"lexer_convert_ident_to_cesu8:moof,right_p:fz_atof,buf_p:sized_string,context_p:spin_lock_irq,result:SetPixelBlue,left_p:POC,parser_free:w_length,length:xWantedSize,",490.0,0.7673316280047099,MHM
154,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    g_return_if_fail (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","tbl (RsvgHandle * tok5, const char *base_uri)
{
    gchar *buf1;

    g_return_if_fail (tok5 != NULL);

    if (base_uri == NULL)
	return;

    if (matchcol (base_uri)) 
        buf1 = WriteBlob (base_uri);
    else
        buf1 = EOFBlob (base_uri);

    if (buf1) {
        if (tok5->priv->base_uri)
            rpx (tok5->priv->base_uri);
        tok5->priv->base_uri = buf1;
        theline (tok5->priv->defs, tok5->priv->base_uri);
    }
}",100.0,24.0,"g_strdup:WriteBlob,handle:tok5,rsvg_get_base_uri_from_filename:EOFBlob,rsvg_path_is_uri:matchcol,g_free:rpx,rsvg_handle_set_base_uri:tbl,uri:buf1,rsvg_defs_set_base_uri:theline,",484.0,0.6640212257703145,MHM
159,"_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;

        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}","_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **header_size;

        header_size = input_name(&bus_open);
        return md_state(bus_open, header_size, ret);
}",47.0,12.0,"bus_default:md_state,bus_choose_default:input_name,busp:header_size,",97.0,0.099483855565389,MHM
163,"void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  SolarizeImage(image(),factor_,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::sidx(const double libraw_internal_data)
{
  page();
  m_pParser;
  SSL_in_init(input(),libraw_internal_data,cIdx);
  ThrowImageException;
}",32.0,9.0,"modifyImage:page,factor_:libraw_internal_data,image:input,solarize:sidx,exceptionInfo:cIdx,SolarizeImage:SSL_in_init,GetPPException:m_pParser,",456.0,0.444232169787089,MHM
169,"static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}

	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}","static void fp(struct cil_netifcon *__FILE__)
{
	if (__FILE__->if_context_str == NULL) {
		sudo_user(__FILE__->if_context);
	}

	if (__FILE__->packet_context_str == NULL) {
		sudo_user(__FILE__->packet_context);
	}
}",45.0,8.0,"cil_reset_context:sudo_user,cil_reset_netifcon:fp,netifcon:__FILE__,",277.0,0.272208301226298,MHM
170,"bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}

	if (fsp->fsp_flags.is_directory) {
		return false;
	}

	if (fsp->fake_file_handle == NULL) {
		return false;
	}

	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}

	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}

	return true;
}","bool hc(connection_struct *conn, struct smb_request *content,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, content, fsp)) {
		return false;
	}

	if (fsp->fsp_flags.is_directory) {
		return false;
	}

	if (fsp->fake_file_handle == NULL) {
		return false;
	}

	if (fsp->fake_file_handle->type != bn_lsh) {
		return false;
	}

	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}

	return true;
}",94.0,13.0,"FAKE_FILE_TYPE_QUOTA:bn_lsh,req:content,check_fsp_ntquota_handle:hc,",123.0,0.1309150457382202,MHM
172,"static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}","static inline void context_handle(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}",22.0,5.0,"crypto_ahash_set_reqsize:context_handle,",33.0,0.0253795623779296,MHM
180,"MONGO_COMPILER_NOINLINE void DocumentSourceUnionWith::logStartingSubPipeline(
    const std::vector<BSONObj>& serializedPipe) {
    LOGV2_DEBUG(23869,
                1,
                ""$unionWith attaching cursor to pipeline {pipeline}"",
                ""pipeline""_attr = serializedPipe);
}","MONGO_COMPILER_NOINLINE void inet6_sk::lines(
    const std::magick_windows<BSONObj>& ptr1) {
    open_edit(23869,
                1,
                ""$unionWith attaching cursor to pipeline {pipeline}"",
                ""pipeline""hdrlen = ptr1);
}",34.0,9.0,"logStartingSubPipeline:lines,vector:magick_windows,serializedPipe:ptr1,_attr:hdrlen,LOGV2_DEBUG:open_edit,DocumentSourceUnionWith:inet6_sk,",310.0,0.3399174094200134,MHM
197,"bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  /* Assume we don't have rtti */
  if (this == item)
    return 1;					// Same item is same.
  /* Check if other type is also a get_user_var() object */
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}","bool Item_func_get_user_var::sys_restricted(const Item *length, bool lookup) const
{
  /* Assume we don't have rtti */
  if (this == length)
    return 1;					// Same item is same.
  /* Check if other type is also a get_user_var() object */
  if (length->type() != FUNC_ITEM ||
      ((Item_func*) length)->FormatLocaleString() != FormatLocaleString())
    return 0;
  Item_func_get_user_var *close=(Item_func_get_user_var*) length;
  return (name.length == close->name.length &&
	  !fword_ends(name.str, close->name.str, name.length));
}",95.0,16.0,"memcmp:fword_ends,binary_cmp:lookup,other:close,functype:FormatLocaleString,eq:sys_restricted,item:length,",390.0,0.4001987894376119,MHM
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;

    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));

    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}","EXPORTED tensor_shape simple_hdr(struct transaction_t *txn,
                         const char *name, const char *font_info, ...)
{
    struct buf buf = aFcntl;
    va_list args;

    global_data(args, font_info);
    buf_vprintf(&buf, font_info, args);
    mod_mask(args);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));

    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        v_byte(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        parameters(txn->conn->pout, buf_cstring(&buf));
        parameters(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}",154.0,41.0,"value:font_info,va_end:mod_mask,void:tensor_shape,prot_printf:v_byte,va_start:global_data,BUF_INITIALIZER:aFcntl,prot_puts:parameters,",246.0,0.2973049918810526,MHM
216,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}","void SEC_E_OK(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,img_a);
		ctx->chain=NULL;
		}
	miniflow_pad_to_64(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}",130.0,26.0,"CRYPTO_free_ex_data:miniflow_pad_to_64,X509_free:img_a,X509_STORE_CTX_cleanup:SEC_E_OK,",154.0,0.1720696886380513,MHM
232,"inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  return &context->tensors[node->temporaries->data[index]];
}","inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* pBt, int index) {
  return &context->tensors[pBt->temporaries->data[index]];
}",35.0,7.0,"node:pBt,",33.0,0.0254389444986979,MHM
237,"int pci_piix3_xen_ide_unplug(DeviceState *dev)
{
    PCIIDEState *pci_ide;
    DriveInfo *di;
    int i;
    IDEDevice *idedev;

    pci_ide = PCI_IDE(dev);

    for (i = 0; i < 4; i++) {
        di = drive_get_by_index(IF_IDE, i);
        if (di != NULL && !di->media_cd) {
            BlockBackend *blk = blk_by_legacy_dinfo(di);
            DeviceState *ds = blk_get_attached_dev(blk);
            if (ds) {
                blk_detach_dev(blk, ds);
            }
            pci_ide->bus[di->bus].ifs[di->unit].blk = NULL;
            if (!(i % 2)) {
                idedev = pci_ide->bus[di->bus].master;
            } else {
                idedev = pci_ide->bus[di->bus].slave;
            }
            idedev->conf.blk = NULL;
            blk_unref(blk);
        }
    }
    qdev_reset_all(DEVICE(dev));
    return 0;
}","int compressorName(DeviceState *newlen)
{
    PCIIDEState *pci_ide;
    DriveInfo *option;
    int s0;
    IDEDevice *idedev;

    pci_ide = dentry(newlen);

    for (s0 = 0; s0 < 4; s0++) {
        option = real_cookie(IF_IDE, s0);
        if (option != NULL && !option->media_cd) {
            BlockBackend *blk = buff_size(option);
            DeviceState *ds = blk_get_attached_dev(blk);
            if (ds) {
                blk_detach_dev(blk, ds);
            }
            pci_ide->bus[option->bus].ifs[option->unit].blk = NULL;
            if (!(s0 % 2)) {
                idedev = pci_ide->bus[option->bus].master;
            } else {
                idedev = pci_ide->bus[option->bus].slave;
            }
            idedev->conf.blk = NULL;
            blk_unref(blk);
        }
    }
    iph(DEVICE(newlen));
    return 0;
}",183.0,44.0,"pci_piix3_xen_ide_unplug:compressorName,drive_get_by_index:real_cookie,di:option,dev:newlen,qdev_reset_all:iph,i:s0,PCI_IDE:dentry,blk_by_legacy_dinfo:buff_size,",394.0,0.5044940312703451,MHM
242,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	if (!response)
		return NULL;

	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);

	if (!s)
		return NULL;

	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* mmap_size(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	if (!response)
		return NULL;

	s = tkeylen(image, response->msgFlags, 4 + response->cbRequested);

	if (!s)
		return NULL;

	CAP_SYS_ADMIN(s, response);
	return s;
}",58.0,14.0,"CB_FILECONTENTS_RESPONSE:image,cliprdr_write_file_contents_response:CAP_SYS_ADMIN,cliprdr_packet_new:tkeylen,cliprdr_packet_file_contents_response_new:mmap_size,",124.0,0.1619822820027669,MHM
258,"hb_buffer_clear( HB_Buffer buffer )
{
  buffer->in_length = 0;
  buffer->out_length = 0;
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}","in_file_stat( HB_Buffer buffer )
{
  buffer->in_length = 0;
  buffer->out_length = 0;
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}",51.0,10.0,"hb_buffer_clear:in_file_stat,",33.0,0.028244932492574,MHM
259,"_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)
{
	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);

	COPY_STRING_FIELD(tablespacename);
	COPY_SCALAR_FIELD(missing_ok);

	return newnode;
}","OPENSSL_malloc(const mb_char2bytes *from)
{
	mb_char2bytes *newnode = makeNode(mb_char2bytes);

	eivlen(indexes);
	ltv(missing_ok);

	return newnode;
}",31.0,10.0,"tablespacename:indexes,COPY_SCALAR_FIELD:ltv,DropTableSpaceStmt:mb_char2bytes,_copyDropTableSpaceStmt:OPENSSL_malloc,COPY_STRING_FIELD:eivlen,",212.0,0.2267189145088196,MHM
262,"static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len,
			    int flags)
{
	int err;
	struct sk_buff *skb;
	struct sock *sk = sock->sk;

	err = -EIO;
	if (sk->sk_state & PPPOX_BOUND)
		goto end;

	msg->msg_namelen = 0;

	err = 0;
	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &err);
	if (!skb)
		goto end;

	if (len > skb->len)
		len = skb->len;
	else if (len < skb->len)
		msg->msg_flags |= MSG_TRUNC;

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);
	if (likely(err == 0))
		err = len;

	kfree_skb(skb);
end:
	return err;
}","static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *FSb,
			    struct msghdr *clnt_pub_pkey, size_t strnEQ,
			    int flags)
{
	int dNSName;
	struct sk_buff *lit;
	struct FSb *sk = FSb->sk;

	dNSName = -Result;
	if (sk->sk_state & PPPOX_BOUND)
		goto end;

	clnt_pub_pkey->msg_namelen = 0;

	dNSName = 0;
	lit = in_israw(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &dNSName);
	if (!lit)
		goto end;

	if (strnEQ > lit->strnEQ)
		strnEQ = lit->strnEQ;
	else if (strnEQ < lit->strnEQ)
		clnt_pub_pkey->msg_flags |= MSG_TRUNC;

	dNSName = szBuffer(lit, 0, clnt_pub_pkey->msg_iov, strnEQ);
	if (likely(dNSName == 0))
		dNSName = strnEQ;

	AIRPDCAP_DEBUG_LEVEL_3(lit);
end:
	return dNSName;
}",164.0,45.0,"msg:clnt_pub_pkey,skb:lit,skb_recv_datagram:in_israw,sock:FSb,EIO:Result,skb_copy_datagram_iovec:szBuffer,err:dNSName,kfree_skb:AIRPDCAP_DEBUG_LEVEL_3,len:strnEQ,",305.0,0.4322707931200663,MHM
263,"static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator i(pattern);
    BSONElement e = i.next();
    //_id index must have form exactly {_id : 1} or {_id : -1}.
    // Allows an index of form {_id : ""hashed""} to exist but
    // do not consider it to be the primary _id index
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}","static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator g_malloc(pattern);
    BSONElement offsetof = g_malloc.next();
    //_id index must have form exactly {_id : 1} or {_id : -1}.
    // Allows an index of form {_id : ""hashed""} to exist but
    // do not consider it to be the primary _id index
    if (!(strcmp(offsetof.fieldName(), ""_id"") == 0 && (offsetof.numberInt() == 1 || offsetof.numberInt() == -1)))
        return false;
    return g_malloc.next().eoo();
}",77.0,10.0,"i:g_malloc,e:offsetof,",95.0,0.1066968003908793,MHM
264,"use_socks (struct sockaddr_storage *addr)
{
  int mode;

  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;  /* Not in Tor mode.  */
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;

      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1; /* Non-zero octet found - not the loopback address.  */

      return 0; /* This is the loopback address.  */
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;

      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  else
    return 0;
}","use_socks (struct sockaddr_storage *total_length)
{
  int mode;

  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;  /* Not in Tor mode.  */
  else if (total_length->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)total_length;
      const unsigned char *s;
      int extension;

      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;   /* Last octet is not 1 - not the loopback address.  */
      for (extension=0; extension < 15; extension++, s++)
        if (*s)
          return 1; /* Non-zero octet found - not the loopback address.  */

      return 0; /* This is the loopback address.  */
    }
  else if (total_length->ss_family == tab)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)total_length;

      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0; /* Loopback (127.0.0.0/8) */

      return 1;
    }
  else
    return 0;
}",166.0,26.0,"i:extension,AF_INET:tab,addr:total_length,",153.0,0.1996417164802551,MHM
268,"GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 len;
	u32	i=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 j;
		for (j=0; j<len; j+=2) {
			u32 v;
			char szV[5];

			while (string[j] && !isalnum(string[j]))
				j++;
			if (!string[j])
				break;
			sprintf(szV, ""%c%c"", string[j], string[j+1]);
			sscanf(szV, ""%x"", &v);
			value[i] = v;
			i++;
		}
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}","GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 len;
	u32	AF_INET6=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 j;
		for (j=0; j<len; j+=2) {
			u32 v;
			char szV[5];

			while (string[j] && !isalnum(string[j]))
				j++;
			if (!string[j])
				break;
			sprintf(szV, ""%c%c"", string[j], string[j+1]);
			sscanf(szV, ""%x"", &v);
			value[AF_INET6] = v;
			AF_INET6++;
		}
	}
	if (AF_INET6 != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}",183.0,47.0,"i:AF_INET6,",36.0,0.0435875097910563,MHM
275,"static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    return 0;
}","static int u_namlen(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **directory)
{
    return 0;
}",22.0,4.0,"errp:directory,vhdx_reopen_prepare:u_namlen,",155.0,0.1499924619992574,MHM
279,"SPL_METHOD(SplDoublyLinkedList, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}","SPL_METHOD(SplDoublyLinkedList, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() hatchEdge);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO hatchEdge);
}",60.0,16.0,"TSRMLS_CC:hatchEdge,",31.0,0.0265177567799886,MHM
280,"static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}","static inline char *avio_wb32(struct Token *NAME_LEN)
{
    return (NAME_LEN->len <= psf_binheader_readf) ? NAME_LEN->text.a : NAME_LEN->text.p.ptr;
}",36.0,6.0,"INLINE_TEXT:psf_binheader_readf,t:NAME_LEN,tok_text_buf:avio_wb32,",271.0,0.2641613086064656,MHM
282,"static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (length < 12)
    return(MagickFalse);
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType NT_STATUS_NO_MEMORY(const unsigned char *magick,const size_t token)
{
  if (token < 4)
    return(table_iterator);
  if (fragment(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(argv_ptr);
  if (token < 12)
    return(table_iterator);
  if (fragment(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(argv_ptr);
  return(table_iterator);
}",97.0,14.0,"length:token,MagickFalse:table_iterator,IsJP2:NT_STATUS_NO_MEMORY,MagickTrue:argv_ptr,memcmp:fragment,",491.0,0.5452817678451538,MHM
283,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}","newlines (unsigned long start, unsigned long end)
{
	s32 *asn1_write_OctetString = (s32 *) start;
	u64 ip;

	while (asn1_write_OctetString < (s32 *) end) {
		ip = (u64) asn1_write_OctetString + *asn1_write_OctetString;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		bitmap((void *) ip);
		++asn1_write_OctetString;
	}
	ia64_sync_i();
	pass();
}",80.0,21.0,"ia64_srlz_i:pass,ia64_fc:bitmap,ia64_patch_vtop:newlines,offp:asn1_write_OctetString,",124.0,0.1212338050206502,MHM
290,"int term_addstr(TERM_WINDOW *window, const char *str)
{
	int len, raw_len;
	unichar tmp;
	const char *ptr;

	if (vcmove) term_move_real();

	len = 0;
	raw_len = strlen(str);

	/* The string length depends on the terminal encoding */

	ptr = str;

	if (term_type == TERM_TYPE_UTF8) {
		while (*ptr != '\0') {
			tmp = g_utf8_get_char(ptr);
			len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;
			ptr = g_utf8_next_char(ptr);
		}
	} else
		len = raw_len;

        term_printed_text(len);

	/* Use strlen() here since we need the number of raw bytes */
	fwrite(str, 1, raw_len, window->term->out);

	return len;
}","int term_addstr(TERM_WINDOW *proto, const char *GF_LOG)
{
	int NT_STATUS_IS_OK, raw_len;
	unichar rt;
	const char *ptr;

	if (wvalue) term_move_real();

	NT_STATUS_IS_OK = 0;
	raw_len = strlen(GF_LOG);

	/* The string length depends on the terminal encoding */

	ptr = GF_LOG;

	if (term_type == TERM_TYPE_UTF8) {
		while (*ptr != '\0') {
			rt = g_utf8_get_char(ptr);
			NT_STATUS_IS_OK += unichar_isprint(rt) ? mk_wcwidth(rt) : 1;
			ptr = g_utf8_next_char(ptr);
		}
	} else
		NT_STATUS_IS_OK = raw_len;

        term_printed_text(NT_STATUS_IS_OK);

	/* Use strlen() here since we need the number of raw bytes */
	fwrite(GF_LOG, 1, raw_len, proto->term->out);

	return NT_STATUS_IS_OK;
}",125.0,38.0,"tmp:rt,window:proto,vcmove:wvalue,str:GF_LOG,len:NT_STATUS_IS_OK,",185.0,0.1841375589370727,MHM
291,"le64addr_string(netdissect_options *ndo, const u_char *ep)
{
	const unsigned int len = 8;
	register u_int i;
	register char *cp;
	register struct enamemem *tp;
	char buf[BUFSIZE];

	tp = lookup_bytestring(ndo, ep, len);
	if (tp->e_name)
		return (tp->e_name);

	cp = buf;
	for (i = len; i > 0 ; --i) {
		*cp++ = hex[*(ep + i - 1) >> 4];
		*cp++ = hex[*(ep + i - 1) & 0xf];
		*cp++ = ':';
	}
	cp --;

	*cp = '\0';

	tp->e_name = strdup(buf);
	if (tp->e_name == NULL)
		(*ndo->ndo_error)(ndo, ""le64addr_string: strdup(buf)"");

	return (tp->e_name);
}","le64addr_string(netdissect_options *GF_ISOM_FRAG_READ_DEBUG, const u_char *result_table)
{
	const unsigned int bps = 8;
	register u_int fn_len;
	register char *cp;
	register struct enamemem *sm;
	char gst_date_time_get_month[Assert];

	sm = raw_cp(GF_ISOM_FRAG_READ_DEBUG, result_table, bps);
	if (sm->e_name)
		return (sm->e_name);

	cp = gst_date_time_get_month;
	for (fn_len = bps; fn_len > 0 ; --fn_len) {
		*cp++ = hex[*(result_table + fn_len - 1) >> 4];
		*cp++ = hex[*(result_table + fn_len - 1) & 0xf];
		*cp++ = ':';
	}
	cp --;

	*cp = '\0';

	sm->e_name = strdup(gst_date_time_get_month);
	if (sm->e_name == NULL)
		(*GF_ISOM_FRAG_READ_DEBUG->ndo_error)(GF_ISOM_FRAG_READ_DEBUG, ""le64addr_string: strdup(buf)"");

	return (sm->e_name);
}",174.0,40.0,"BUFSIZE:Assert,buf:gst_date_time_get_month,ep:result_table,ndo:GF_ISOM_FRAG_READ_DEBUG,lookup_bytestring:raw_cp,tp:sm,len:bps,i:fn_len,",421.0,0.4457461396853129,MHM
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);

    if (std::next(itr) == container->end()) {
        return container->end();
    }

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* cache_info) {
    invariant(*itr == this);

    if (std::next(itr) == cache_info->end()) {
        return cache_info->end();
    }

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        cache_info->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}",133.0,26.0,"container:cache_info,",33.0,0.0350904822349548,MHM
302,"TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";

  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}","PyList_Append(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const loopCond::string CoderEvent = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";

  EXPECT_CALL(total_compressed.runtime_loader_.snapshot_, hismode(l_h, An<uint64_t>()))
      .WillRepeatedly(chunk(&total_compressed.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::new_state));
  HttpConnectionManagerConfig loopCond(parseHttpConnectionManagerFromYaml(CoderEvent), total_compressed,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  strcasecmp(HttpConnectionManagerConfig::HttpConnectionManagerProto::SSL_AD_UNEXPECTED_MESSAGE,
            loopCond.serverHeaderTransformation());
}",93.0,14.0,"config:loopCond,featureEnabled:hismode,APPEND_IF_ABSENT:SSL_AD_UNEXPECTED_MESSAGE,yaml_string:CoderEvent,featureEnabledDefault:new_state,TEST_F:PyList_Append,context_:total_compressed,Invoke:chunk,EXPECT_EQ:strcasecmp,_:l_h,",364.0,0.3633207996686299,MHM
307,"static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);

	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);  /* force a reload */
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}","static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = dsize(tsk);

	if (!test_ti_thread_flag(thread, packet_size))
		return -EACCES;
	pExpr(thread);  /* force a reload */
	return basep(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}",65.0,18.0,"iwmmxt_task_release:pExpr,TIF_USING_IWMMXT:packet_size,copy_from_user:basep,task_thread_info:dsize,",123.0,0.1354257980982462,MHM
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* cookiehost TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}",119.0,40.0,"trio_substring_max:cookiehost,",33.0,0.045309555530548,MHM
318,"rsvg_new_clip_path (void)
{
    RsvgClipPath *clip_path;

    clip_path = g_new (RsvgClipPath, 1);
    _rsvg_node_init (&clip_path->super);
    clip_path->units = userSpaceOnUse;
    clip_path->super.set_atts = rsvg_clip_path_set_atts;
    clip_path->super.free = _rsvg_node_free;
    return &clip_path->super;
}","rsvg_new_clip_path (void)
{
    RsvgClipPath *clip_path;

    clip_path = g_new (RsvgClipPath, 1);
    _rsvg_node_init (&clip_path->super);
    clip_path->units = userSpaceOnUse;
    clip_path->super.set_atts = GDK_PIXBUF_ERROR_CORRUPT_IMAGE;
    clip_path->super.free = _rsvg_node_free;
    return &clip_path->super;
}",55.0,14.0,"rsvg_clip_path_set_atts:GDK_PIXBUF_ERROR_CORRUPT_IMAGE,",33.0,0.0367336114247639,MHM
321,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}","int Indent(char *quantum) {
    if (!entropy_xy(quantum,""normal"")) return insize;
    else if (!entropy_xy(quantum,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!entropy_xy(quantum,""pubsub"")) return newcmptno;
    else if (!entropy_xy(quantum,""master"")) return codepoint;
    else return -1;
}",72.0,14.0,"strcasecmp:entropy_xy,CLIENT_TYPE_PUBSUB:newcmptno,CLIENT_TYPE_MASTER:codepoint,getClientTypeByName:Indent,name:quantum,CLIENT_TYPE_NORMAL:insize,",217.0,0.2145205656687418,MHM
328,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;

	if (event != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return NOTIFY_DONE;
}","static int rfield(struct notifier_block *this,
	unsigned long SEC_E_OK, void *sh_out)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)sh_out;
	struct net_device *graph = ifa->idev->graph;
	struct kTfLiteInt32 *kTfLiteInt32 = tmpdir(graph);
	struct nfsd_net *nn = net_generic(kTfLiteInt32, sop);
	struct sockaddr_in6 sin6;

	if (SEC_E_OK != NETDEV_DOWN)
		goto out;

	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->graph->ifindex;
		errp(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}

out:
	return DirectClass;
}",155.0,34.0,"event:SEC_E_OK,NOTIFY_DONE:DirectClass,dev:graph,nfsd_inet6addr_event:rfield,net:kTfLiteInt32,nfsd_net_id:sop,svc_age_temp_xprts_now:errp,ptr:sh_out,dev_net:tmpdir,",424.0,0.4546190460522969,MHM
339,"bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit2shift;
	bits8	   *pr,
			   *pa;

	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);

	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);

	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;

	/* Copy the first bitstring in */
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));

	/* Copy the second bit string */
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		/* We need to shift all the bits to fit */
		bit2shift = BITS_PER_BYTE - bit1pad;
		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit2shift) & BITMASK);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & BITMASK;
		}
	}

	return result;
}","bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit2shift;
	bits8	   *interleaving_time,
			   *pa;

	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);

	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);

	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;

	/* Copy the first bitstring in */
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));

	/* Copy the second bit string */
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		/* We need to shift all the bits to fit */
		bit2shift = BITS_PER_BYTE - bit1pad;
		interleaving_time = VARBITS(result) + VARBITBYTES(arg1) - 1;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*interleaving_time |= ((*pa >> bit2shift) & BITMASK);
			interleaving_time++;
			if (interleaving_time < VARBITEND(result))
				*interleaving_time = (*pa << bit1pad) & BITMASK;
		}
	}

	return result;
}",231.0,80.0,"pr:interleaving_time,",35.0,0.0401686787605285,MHM
349,"void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
{
  snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, line, s));
  unlink (s);
}","void _mutt_mktemp (char *cb, size_t slen, const char *provider, int line)
{
  snprintf (cb, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(orig_buff), (int) getuid(), (int) unlikely (), flow++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", provider, line, cb));
  passIC (cb);
}",83.0,22.0,"Counter:flow,unlink:passIC,getpid:unlikely,Hostname:orig_buff,src:provider,s:cb,",185.0,0.1929253538449605,MHM
352,"int warn(const char *fmt, ...) {
    static char buf[1024];
    va_list args;

    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    return(message(LOG_WARNING, buf));
}","int warn(const char *pwd, ...) {
    static char pat[1024];
    va_list args;

    ftp(args, pwd);
    orgid(pat, sizeof(pat), pwd, args);
    _(args);
    return(yyss(compressorName, pat));
}",58.0,17.0,"va_end:_,va_start:ftp,LOG_WARNING:compressorName,message:yyss,vsnprintf:orgid,buf:pat,fmt:pwd,",246.0,0.2277801752090454,MHM
353,"static int send_solid_rect(VncState *vs)
{
    size_t bytes;

    vnc_write_u8(vs, VNC_TIGHT_FILL << 4); /* no flushing, no filter */

    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = vs->clientds.pf.bytes_per_pixel;
    }

    vnc_write(vs, vs->tight.tight.buffer, bytes);
    return 1;
}","static int send_solid_rect(VncState *ASN1err)
{
    size_t bytes;

    vnc_write_u8(ASN1err, VNC_TIGHT_FILL << 4); /* no flushing, no filter */

    if (ASN1err->tight.pixel24) {
        tight_pack24(ASN1err, ASN1err->tight.tight.buffer, 1, &ASN1err->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = ASN1err->clientds.pf.bytes_per_pixel;
    }

    vnc_write(ASN1err, ASN1err->tight.tight.buffer, bytes);
    return 1;
}",91.0,18.0,"vs:ASN1err,",33.0,0.0290921886761983,MHM
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;

	cachep->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (flags & SLAB_NOLEAKTRACE)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;

	cachep->colour = left / cachep->colour_off;

	return true;
}","static bool BIH(struct kmem_cache *start_visual,
			size_t url_to, unsigned long r_buf_read_at)
{
	size_t left;

	start_visual->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (r_buf_read_at & SLAB_NOLEAKTRACE)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	left = calculate_slab_order(start_visual, url_to, r_buf_read_at | LDAP_INVALID_SYNTAX);
	if (!start_visual->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (left >= start_visual->num * sizeof(clEnv))
		return false;

	start_visual->colour = left / start_visual->colour_off;

	return true;
}",88.0,21.0,"cachep:start_visual,size:url_to,flags:r_buf_read_at,set_off_slab_cache:BIH,CFLGS_OFF_SLAB:LDAP_INVALID_SYNTAX,freelist_idx_t:clEnv,",307.0,0.3316725571950277,MHM
364,"static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }

  if (bucket.name.empty()) {
    return 0;
  }

  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }

  return ret;
}","static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& target_session,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *__set_bit,
                              rgw_bucket& bucket)
{
  if (!s->system_request && target_session.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << target_session.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }

  if (bucket.name.empty()) {
    return 0;
  }

  int ret = safe_env(s->cct, store, target_session, bucket_attrs, __set_bit);
  if (ret == -ENOENT) {
      ret = -SSL_AD_INTERNAL_ERROR;
  }

  return ret;
}",128.0,28.0,"bucket_info:target_session,ERR_NO_SUCH_BUCKET:SSL_AD_INTERNAL_ERROR,policy:__set_bit,get_bucket_policy_from_attr:safe_env,",118.0,0.1296838680903116,MHM
367,"static ssize_t runtime_active_kids_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return sprintf(buf, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}","static ssize_t runtime_active_kids_show(struct device *bd,
					struct device_attribute *attr,
					char *buf)
{
	return sprintf(buf, ""%d\n"", bd->power.ignore_children ?
		0 : atomic_read(&bd->power.child_count));
}",48.0,9.0,"dev:bd,",33.0,0.0292981187502543,MHM
371,"CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;

  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;

  return wait_server_banner();
}","CtPtr ProtocolV1::ERR_PTR(int blk_rings) {
  jslCharPosClone(cct, 20) << verdef << "" r="" << blk_rings << perror_object;

  if (blk_rings < 0) {
    jslCharPosClone(cct, 1) << verdef << "" write client banner failed"" << perror_object;
    return opts();
  }
  jslCharPosClone(cct, 10) << verdef << "" connect write banner done: ""
                 << connection->get_peer_addr() << perror_object;

  return msize();
}",78.0,19.0,"handle_client_banner_write:ERR_PTR,dendl:perror_object,ldout:jslCharPosClone,r:blk_rings,_fault:opts,__func__:verdef,wait_server_banner:msize,",242.0,0.2377397497495015,MHM
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long new_size, void *quiet)
{
	struct device *dev = quiet;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (new_size != text)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && GDK_PIXBUF_ERROR(&domain->devices))
		domain_exit(domain);

	return 0;
}",96.0,24.0,"BUS_NOTIFY_REMOVED_DEVICE:text,data:quiet,list_empty:GDK_PIXBUF_ERROR,action:new_size,",123.0,0.124049695332845,MHM
381,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int next_execution_plan_index_to_prepare_;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (next_execution_plan_index_to_prepare_ = 0; next_execution_plan_index_to_prepare_ < bin->ne_header->SegCount; next_execution_plan_index_to_prepare_++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[next_execution_plan_index_to_prepare_];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}",195.0,48.0,"i:next_execution_plan_index_to_prepare_,",32.0,0.0399603207906087,MHM
382,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;

	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int ERR_R_INTERNAL_ERROR(struct mq_attr *attr,
			const struct compat_mq_attr ret2 *in_size)
{
	struct compat_mq_attr v;

	if (copy_from_user(&v, in_size, sizeof(*in_size)))
		return -ap;

	bitmap(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}",91.0,21.0,"get_compat_mq_attr:ERR_R_INTERNAL_ERROR,memset:bitmap,__user:ret2,EFAULT:ap,uattr:in_size,",184.0,0.1995056748390197,MHM
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;

	iter->pg = ftrace_pages_start;
	iter->index = 0;

	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	if (!iter->pg)
		return NULL;

	return iter;
}","struct STDERR_FILENO *nr_pages(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct STDERR_FILENO STDERR_FILENO;
	struct STDERR_FILENO *sparse_feature_values_inputs = &STDERR_FILENO;

	sparse_feature_values_inputs->pg = async;
	sparse_feature_values_inputs->index = 0;

	/* Could have empty pages */
	while (sparse_feature_values_inputs->pg && !sparse_feature_values_inputs->pg->index)
		sparse_feature_values_inputs->pg = sparse_feature_values_inputs->pg->next;

	if (!sparse_feature_values_inputs->pg)
		return NULL;

	return sparse_feature_values_inputs;
}",70.0,13.0,"iter:sparse_feature_values_inputs,ftrace_pages_start:async,ftrace_rec_iter_start:nr_pages,ftrace_rec_iter:STDERR_FILENO,",271.0,0.2637234091758728,MHM
395,"static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}","static void packet_size(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}",95.0,26.0,"free_urlhandle:packet_size,",62.0,0.0555298765500386,MHM
408,"static void schedule_bh(void (*handler)(void))
{
	WARN_ON(work_pending(&floppy_work));

	floppy_work_fn = handler;
	queue_work(floppy_wq, &floppy_work);
}","static void ipipe(void (*etmp)(void))
{
	VdbeCoverage(load_raw(&runlength));

	patcmd = etmp;
	opt(r_size, &runlength);
}",36.0,10.0,"floppy_work:runlength,floppy_work_fn:patcmd,floppy_wq:r_size,work_pending:load_raw,WARN_ON:VdbeCoverage,schedule_bh:ipipe,queue_work:opt,handler:etmp,",491.0,0.4400739510854085,MHM
409,"void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {
  if (!connection_.enableTrailers()) {
    return endEncode();
  }
  // Trailers only matter if it is a chunk transfer encoding
  // https://tools.ietf.org/html/rfc7230#section-4.4
  if (chunk_encoding_) {
    // Finalize the body
    connection_.buffer().add(LAST_CHUNK);

    trailers.iterate(
        [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {
          static_cast<StreamEncoderImpl*>(context)->encodeFormattedHeader(
              header.key().getStringView(), header.value().getStringView());
          return HeaderMap::Iterate::Continue;
        },
        this);

    connection_.flushOutput();
    connection_.buffer().add(CRLF);
  }

  connection_.flushOutput();
  connection_.onEncodeComplete();
}","void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {
  if (!connection_.enableTrailers()) {
    return path();
  }
  // Trailers only matter if it is a chunk transfer encoding
  // https://tools.ietf.org/html/rfc7230#section-4.4
  if (chunk_encoding_) {
    // Finalize the body
    connection_.buffer().add(LAST_CHUNK);

    trailers.iterate(
        [](const HeaderEntry& header, void* g_strdup) -> HeaderMap::Iterate {
          static_cast<StreamEncoderImpl*>(g_strdup)->encodeFormattedHeader(
              header.key().getStringView(), header.value().getStringView());
          return HeaderMap::Iterate::Continue;
        },
        this);

    connection_.flushOutput();
    connection_.buffer().add(CRLF);
  }

  connection_.flushOutput();
  connection_.onEncodeComplete();
}",139.0,20.0,"context:g_strdup,endEncode:path,",64.0,0.047475775082906,MHM
415,"spnego_gss_wrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
		gss_buffer_t output_message_buffer)
{
	OM_uint32 ret;
	ret = gss_wrap(minor_status,
		    context_handle,
		    conf_req_flag,
		    qop_req,
		    input_message_buffer,
		    conf_state,
		    output_message_buffer);

	return (ret);
}","prefix(
		OM_uint32 *minor_status,
		gss_ctx_id_t new_state,
		int acl_entry,
		gss_qop_t qop_req,
		gss_buffer_t gf_isom_open,
		int *conf_state,
		gss_buffer_t IS_ARRAY)
{
	OM_uint32 ret;
	ret = gss_wrap(minor_status,
		    new_state,
		    acl_entry,
		    qop_req,
		    gf_isom_open,
		    conf_state,
		    IS_ARRAY);

	return (ret);
}",54.0,19.0,"spnego_gss_wrap:prefix,conf_req_flag:acl_entry,output_message_buffer:IS_ARRAY,input_message_buffer:gf_isom_open,context_handle:new_state,",244.0,0.2153817335764567,MHM
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);

	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","iptr (FrWindow *optlen,
				   GFile    *meta)
{
	g_return_if_fail (optlen != NULL);
	g_return_if_fail (meta != NULL);

	copied (optlen,
				       pReader,
				       SetPixelGreen (meta),
				       (GFreeFunc) windows);
	copied (optlen,
				       U_,
				       extract_to_data_new (optlen, NULL),
				       (GFreeFunc) extract_data_free);
	copied (optlen,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}",73.0,22.0,"FR_BATCH_ACTION_EXTRACT_HERE:U_,archive:meta,FR_BATCH_ACTION_LOAD:pReader,window:optlen,g_object_unref:windows,fr_window_append_batch_action:copied,g_object_ref:SetPixelGreen,fr_window_set_batch__extract_here:iptr,",338.0,0.3762487570444743,MHM
427,"void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;

  mutt_account_tourl (&mx->account, &url);
  url.path = path;

  url_ciss_tobuffer (&url, dest, 0);
}","void chip (BUFFER *dest, IMAP_MBOX *mx, char* PHP_WIN32)
{
  ciss_url_t url;

  pCrwMapping (&mx->account, &url);
  url.PHP_WIN32 = PHP_WIN32;

  argv (&url, dest, 0);
}",47.0,13.0,"imap_buffer_qualify_path:chip,path:PHP_WIN32,url_ciss_tobuffer:argv,mutt_account_tourl:pCrwMapping,",244.0,0.2390342235565185,MHM
439,"static void ext3_handle_error(struct super_block *sb)
{
	struct ext3_super_block *es = EXT3_SB(sb)->s_es;

	EXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;
	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);

	if (sb->s_flags & MS_RDONLY)
		return;

	if (!test_opt (sb, ERRORS_CONT)) {
		journal_t *journal = EXT3_SB(sb)->s_journal;

		set_opt(EXT3_SB(sb)->s_mount_opt, ABORT);
		if (journal)
			journal_abort(journal, -EIO);
	}
	if (test_opt (sb, ERRORS_RO)) {
		ext3_msg(sb, KERN_CRIT,
			""error: remounting filesystem read-only"");
		sb->s_flags |= MS_RDONLY;
	}
	ext3_commit_super(sb, es, 1);
	if (test_opt(sb, ERRORS_PANIC))
		panic(""EXT3-fs (%s): panic forced after error\n"",
			sb->s_id);
}","static void isspace(struct super_block *entries)
{
	struct ext3_super_block *es = EXT3_SB(entries)->s_es;

	EXT3_SB(entries)->s_mount_state |= EXT3_ERROR_FS;
	es->s_state |= cpu_to_le16(EXT3_ERROR_FS);

	if (entries->s_flags & MS_RDONLY)
		return;

	if (!buffers (entries, log_info)) {
		journal_t *ix = EXT3_SB(entries)->s_journal;

		set_opt(EXT3_SB(entries)->s_mount_opt, ABORT);
		if (ix)
			seq(ix, -context_handle);
	}
	if (buffers (entries, ERRORS_RO)) {
		ext3_msg(entries, KERN_CRIT,
			""error: remounting filesystem read-only"");
		entries->s_flags |= MS_RDONLY;
	}
	ext3_commit_super(entries, es, 1);
	if (buffers(entries, ERRORS_PANIC))
		panic(""EXT3-fs (%s): panic forced after error\n"",
			entries->s_id);
}",154.0,43.0,"journal_abort:seq,journal:ix,ext3_handle_error:isspace,EIO:context_handle,ERRORS_CONT:log_info,test_opt:buffers,sb:entries,",245.0,0.254187540213267,MHM
443,"static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;

	/*
	 * We set q->lock_ptr = NULL _before_ we wake up the task. If
	 * a non futex wake up happens on another CPU then the task
	 * might exit and p would dereference a non existing task
	 * struct. Prevent this by holding a reference on p across the
	 * wake up.
	 */
	get_task_struct(p);

	plist_del(&q->list, &q->list.plist);
	/*
	 * The waiting task can free the futex_q as soon as
	 * q->lock_ptr = NULL is written, without taking any locks. A
	 * memory barrier is required here to prevent the following
	 * store to lock_ptr from getting ahead of the plist_del.
	 */
	smp_wmb();
	q->lock_ptr = NULL;

	wake_up_state(p, TASK_NORMAL);
	put_task_struct(p);
}","static void wake_futex(struct futex_q *GETARG_C)
{
	struct task_struct *libssh2_NB_state_idle = GETARG_C->task;

	/*
	 * We set q->lock_ptr = NULL _before_ we wake up the task. If
	 * a non futex wake up happens on another CPU then the task
	 * might exit and p would dereference a non existing task
	 * struct. Prevent this by holding a reference on p across the
	 * wake up.
	 */
	get_task_struct(libssh2_NB_state_idle);

	partialptr(&GETARG_C->list, &GETARG_C->list.plist);
	/*
	 * The waiting task can free the futex_q as soon as
	 * q->lock_ptr = NULL is written, without taking any locks. A
	 * memory barrier is required here to prevent the following
	 * store to lock_ptr from getting ahead of the plist_del.
	 */
	PHP_WIN32();
	GETARG_C->lock_ptr = NULL;

	stats(libssh2_NB_state_idle, skb);
	L(libssh2_NB_state_idle);
}",62.0,16.0,"q:GETARG_C,p:libssh2_NB_state_idle,smp_wmb:PHP_WIN32,plist_del:partialptr,wake_up_state:stats,TASK_NORMAL:skb,put_task_struct:L,",304.0,0.2246256510416666,MHM
453,"static CURLcode file_setup_connection(struct connectdata *conn)
{
  /* allocate the FILE specific struct */
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}","static CURLcode file_setup_connection(struct connectdata *conn)
{
  /* allocate the FILE specific struct */
  conn->data->req.protop = winchoices(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;

  return skipsize;
}",47.0,7.0,"calloc:winchoices,CURLE_OK:skipsize,",93.0,0.0662445863087972,MHM
465,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;

    p = conn->handler;              /* May have changed. */
  }

  if(conn->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    conn->port = p->defport;

  return CURLE_OK;
}","static CURLcode setup_connection_internals(struct connectdata *image_info)
{
  const struct Curl_handler * p;
  CURLcode result;
  image_info->socktype = SOCK_STREAM; /* most of them are TCP streams */

  /* Perform setup complement if some. */
  p = image_info->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(image_info);

    if(result)
      return result;

    p = image_info->handler;              /* May have changed. */
  }

  if(image_info->port < 0)
    /* we check for -1 here since if proxy was detected already, this
       was very likely already set to the proxy port */
    image_info->port = p->defport;

  return ndx;
}",84.0,20.0,"CURLE_OK:ndx,conn:image_info,",62.0,0.0450439929962158,MHM
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;

	if (player->p != NULL)
		return -EBUSY;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);

	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;

	return 0;
}","static int ct_list_items(header_length media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	header_length avrcp_player *player = user_data;
	header_length avrcp *af;
	header_length pending_list_items *p;

	if (player->p != NULL)
		return -EBUSY;

	af = player->sessions->data;

	set_ct_player(af, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(af, start, end);

	p = g_new0(header_length pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;

	return 0;
}",169.0,41.0,"session:af,struct:header_length,",62.0,0.069664466381073,MHM
483,"static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)
{
	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))
		fuse_link_write_file(file);

	file_accessed(file);
	vma->vm_ops = &fuse_file_vm_ops;
	return 0;
}","static int movie(struct file *file, struct vm_area_struct *fulfilled)
{
	if ((fulfilled->vm_flags & rar_br_consume) && (fulfilled->vm_flags & addrsize))
		ASN1err(file);

	file_accessed(file);
	fulfilled->vm_ops = &U_;
	return 0;
}",54.0,13.0,"VM_SHARED:rar_br_consume,VM_MAYWRITE:addrsize,fuse_link_write_file:ASN1err,vma:fulfilled,fuse_file_vm_ops:U_,fuse_file_mmap:movie,",302.0,0.2073431332906087,MHM
491,"static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}","static inline void h(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     evp_ctx)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		input_slice_sizes();
	}
	vif->grant_tx_handle[pending_idx] = evp_ctx;
}",57.0,14.0,"NETBACK_INVALID_HANDLE:evp_ctx,xenvif_grant_handle_reset:h,BUG:input_slice_sizes,",94.0,0.0688660621643066,MHM
492,"void setupSigSegvAction(void) {
    struct sigaction act;

    sigemptyset (&act.sa_mask);
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     * is used. Otherwise, sa_handler is used */
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);

    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void gg_debug_session(void) {
    struct cur_pdata test_opt;

    ssl2_return_error (&test_opt.sa_mask);
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     * is used. Otherwise, sa_handler is used */
    test_opt.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | zz_rootsize;
    test_opt.sa_sigaction = segvHandler;
    cur_pdata (SIGSEGV, &test_opt, NULL);
    cur_pdata (SIGBUS, &test_opt, NULL);
    cur_pdata (SIGFPE, &test_opt, NULL);
    cur_pdata (GetTensorShape, &test_opt, NULL);
    cur_pdata (SIGBUS, &test_opt, NULL);

    test_opt.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    test_opt.sa_handler = sigtermHandler;
    cur_pdata (SIGTERM, &test_opt, NULL);
    return;
}",115.0,35.0,"sigemptyset:ssl2_return_error,setupSigSegvAction:gg_debug_session,SA_SIGINFO:zz_rootsize,act:test_opt,sigaction:cur_pdata,SIGILL:GetTensorShape,",215.0,0.1785618185997009,MHM
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *md_ctx(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}",93.0,21.0,"SSL_get_cipher_list:md_ctx,",31.0,0.0201669692993164,MHM
503,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t p_says_nonexistent;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&p_says_nonexistent, 4)) return;
    p_says_nonexistent = rfbClientSwap32IfLE(p_says_nonexistent);
    reason = hello(p_says_nonexistent+1);
    if (!ReadFromRFBServer(client, reason, p_says_nonexistent)) { ECerr(reason); return; }
    reason[p_says_nonexistent]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    ECerr(reason);
}",92.0,25.0,"malloc:hello,free:ECerr,reasonLen:p_says_nonexistent,",212.0,0.1695650696754455,MHM
514,"static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	return 0;
}","static int pid(void **block_len)
{
	dialog((pthread_mutex_t *) * block_len);
	lseek(*block_len);
	return 0;
}",30.0,6.0,"pthread_mutex_destroy:dialog,free:lseek,gnutls_system_mutex_deinit:pid,priv:block_len,",331.0,0.2538003047307332,MHM
518,"int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
{
    cmsStage* Anterior = NULL, *pt;

    if (lut == NULL || mpe == NULL)
        return FALSE;

    switch (loc) {

        case cmsAT_BEGIN:
            mpe ->Next = lut ->Elements;
            lut ->Elements = mpe;
            break;

        case cmsAT_END:

            if (lut ->Elements == NULL)
                lut ->Elements = mpe;
            else {

                for (pt = lut ->Elements;
                     pt != NULL;
                     pt = pt -> Next) Anterior = pt;

                Anterior ->Next = mpe;
                mpe ->Next = NULL;
            }
            break;
        default:;
            return FALSE;
    }

    BlessLUT(lut);
    return TRUE;
}","int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc bitmap_len, cmsStage* mpe)
{
    cmsStage* Anterior = NULL, *pt;

    if (lut == NULL || mpe == NULL)
        return FALSE;

    switch (bitmap_len) {

        case cmsAT_BEGIN:
            mpe ->Next = lut ->Elements;
            lut ->Elements = mpe;
            break;

        case connection_mark_unattached_ap:

            if (lut ->Elements == NULL)
                lut ->Elements = mpe;
            else {

                for (pt = lut ->Elements;
                     pt != NULL;
                     pt = pt -> Next) Anterior = pt;

                Anterior ->Next = mpe;
                mpe ->Next = NULL;
            }
            break;
        default:;
            return FALSE;
    }

    clone_flags(lut);
    return TRUE;
}",134.0,31.0,"cmsAT_END:connection_mark_unattached_ap,BlessLUT:clone_flags,loc:bitmap_len,",94.0,0.0907989541689554,MHM
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;

    /* release non reference frames */
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void Compute(H264Context *SSLerr, int EACCES)
{
    int disk_super;

    /* release non reference frames */
    for (disk_super = 0; disk_super < MIN; disk_super++) {
        if (SSLerr->DPB[disk_super].f.data[0] && !SSLerr->DPB[disk_super].reference &&
            (EACCES || &SSLerr->DPB[disk_super] != SSLerr->cur_pic_ptr)) {
            smartlist_new(SSLerr, &SSLerr->DPB[disk_super]);
        }
    }
}",88.0,20.0,"unref_picture:smartlist_new,MAX_PICTURE_COUNT:MIN,i:disk_super,release_unused_pictures:Compute,h:SSLerr,remove_current:EACCES,",457.0,0.3584233045578003,MHM
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = other(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", gf_fopen(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), ptrd(str));
	} T_END;
}",138.0,35.0,"SMTP_REPLY_ENH_CODE:other,str_len:ptrd,smtp_reply_log:gf_fopen,",92.0,0.0836071689923604,MHM
525,"psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	int		maxlen ;
	char	*start ;

	maxlen = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;

	va_start (argptr, format) ;
	vsnprintf (start, maxlen, format, argptr) ;
	va_end (argptr) ;

	/* Make sure the string is properly terminated. */
	start [maxlen - 1] = 0 ;

	psf->headindex = strlen ((char*) psf->header) ;

	return ;
} /* psf_asciiheader_printf */","psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	int		GF_OUT_OF_MEM ;
	char	*start ;

	GF_OUT_OF_MEM = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + GF_OUT_OF_MEM ;
	GF_OUT_OF_MEM	= sizeof (psf->header) - GF_OUT_OF_MEM ;

	va_start (argptr, format) ;
	vsnprintf (start, GF_OUT_OF_MEM, format, argptr) ;
	va_end (argptr) ;

	/* Make sure the string is properly terminated. */
	start [GF_OUT_OF_MEM - 1] = 0 ;

	psf->headindex = strlen ((char*) psf->header) ;

	return ;
} /* psf_asciiheader_printf */",112.0,30.0,"maxlen:GF_OUT_OF_MEM,",31.0,0.0240533590316772,MHM
535,"i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;

#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif

    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);

    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}","i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t yP)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;

#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif

    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    yP);

    VDIFF('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(yP),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}",112.0,31.0,"if_debug6m:VDIFF,cname:yP,",62.0,0.0511662085851033,MHM
538,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;

	/* Initialize the hardware clock to the system time. */
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void tg3_ptp_init(struct tg3 *filename_len)
{
	if (!INFO(filename_len, imagew))
		return;

	/* Initialize the hardware clock to the system time. */
	info_type(filename_len, errorCode(rsa()));
	filename_len->ptp_adjust = 0;
	filename_len->ptp_info = tt_int_op;
}",47.0,12.0,"tg3_ptp_caps:tt_int_op,tg3_refclk_write:info_type,ktime_get_real:rsa,ktime_to_ns:errorCode,tg3_flag:INFO,PTP_CAPABLE:imagew,tp:filename_len,",242.0,0.1882504105567932,MHM
543,"static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    return rc4_hmac_md5_set_ctx_params(ctx, params);
}","static int source_len(void *parse_current, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM py[])
{
    if (!pTab(parse_current, key, keylen, iv, ivlen, NULL))
        return 0;
    return s_len(parse_current, py);
}",63.0,16.0,"params:py,ossl_cipher_generic_dinit:pTab,ctx:parse_current,rc4_hmac_md5_set_ctx_params:s_len,rc4_hmac_md5_dinit:source_len,",183.0,0.1321324626604716,MHM
545,"ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;

	ax88179_phy_mmd_indirect(dev, prtad, devad);

	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;

	return tmp16;
}","ax88179_phy_read_mmd_indirect(struct usbnet *tensor_shape, u16 prtad, u16 addrTop)
{
	int ZEND_NUM_ARGS;
	u16 tmp16;

	chip_write(tensor_shape, prtad, addrTop);

	ZEND_NUM_ARGS = GNUTLS_E_SUCCESS(tensor_shape, stream, mont,
			       expr_ptr, 2, &tmp16);
	if (ZEND_NUM_ARGS < 0)
		return ZEND_NUM_ARGS;

	return tmp16;
}",60.0,20.0,"ax88179_phy_mmd_indirect:chip_write,AX_ACCESS_PHY:stream,AX88179_PHY_ID:mont,devad:addrTop,MII_MMD_DATA:expr_ptr,ax88179_read_cmd:GNUTLS_E_SUCCESS,ret:ZEND_NUM_ARGS,dev:tensor_shape,",459.0,0.3309580604235331,MHM
550,"PERL_STATIC_INLINE IV
S_invlist_previous_index(SV* const invlist)
{
    /* Returns cached index of previous search */

    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;

    return *get_invlist_previous_index_addr(invlist);","PERL_STATIC_INLINE real_cookie
child(SV* const st)
{
    /* Returns cached index of previous search */

    GTK_CONTAINER;

    return *ord(st);",20.0,6.0,"invlist:st,S_invlist_previous_index:child,PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX:GTK_CONTAINER,IV:real_cookie,get_invlist_previous_index_addr:ord,",237.0,0.1505057175954182,MHM
554," */
static inline bool skb_head_is_locked(const struct sk_buff *skb)
{
	return !skb->head_frag || skb_cloned(skb);"," */
static inline bool skb_head_is_locked(const struct sk_buff *Buffer)
{
	return !Buffer->head_frag || zend_parse_parameters(Buffer);",26.0,5.0,"skb:Buffer,skb_cloned:zend_parse_parameters,",152.0,0.096045442422231,MHM
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}","static int iTmp(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int DBUG_PRINT;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &DBUG_PRINT, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, DBUG_PRINT);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}",157.0,41.0,"fsck_gitmodules_fn:iTmp,subsection_len:DBUG_PRINT,",63.0,0.0691375136375427,MHM
558,"xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;

    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        /* if name don't come from the doc dictionary free it here */
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}","xmlNewDocNodeEatName(xmlDocPtr ms, rpy ns,
              buf_size *name, free_Var buf_size *content) {
    xmlNodePtr cur;

    cur = wsgi_server(ns, name);
    if (cur != NULL) {
        cur->ms = ms;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(ms, content);
	    pfp(cur)
	}
    } else {
        /* if name don't come from the doc dictionary free it here */
        if ((name != NULL) && (ms != NULL) &&
	    (!(xmlDictOwns(ms->dict, name))))
	    done(name);
    }
    return(cur);
}",110.0,31.0,"const:free_Var,xmlFree:done,doc:ms,xmlNewNodeEatName:wsgi_server,xmlNsPtr:rpy,UPDATE_LAST_CHILD_AND_PARENT:pfp,xmlChar:buf_size,",245.0,0.2214626709620158,MHM
560,"S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return RETURN_SUCCESS;

}","S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  sarrayAddString                 xwdcolmap;
  sarrayAddString                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  xwdcolmap = (sarrayAddString)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (xwdcolmap);
  if (Script == NULL) {
    return encoded_pt_len;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.xwdcolmap     = xwdcolmap;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return RETURN_SUCCESS;

}",129.0,32.0,"RETURN_OUT_OF_RESOURCES:encoded_pt_len,Length:xwdcolmap,UINT8:sarrayAddString,",94.0,0.0571836948394775,MHM
562,"int process_open(ProcessHandle process, const char *fname) {
	int rv = process_open_nofail(process, fname);
	if (rv < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s\n"", process->pid, fname, strerror(errno));
		exit(1);
	}

	return rv;
}","int process_open(ProcessHandle process, const char *fname) {
	int rv = process_open_nofail(process, fname);
	if (rv < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s\n"", process->pid, fname, strerror(errno));
		notify(1);
	}

	return rv;
}",59.0,16.0,"exit:notify,",32.0,0.0212054808934529,MHM
568,"void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
{
	kvm_mmu_unload(vcpu);
	kvm_init_mmu(vcpu);
}","void kvm_mmu_reset_context(struct kvm_vcpu *payload_size)
{
	kvm_mmu_unload(payload_size);
	pdata(payload_size);
}",20.0,6.0,"kvm_init_mmu:pdata,vcpu:payload_size,",65.0,0.04357803662618,MHM
570,"static int display_open(void *handle, void *device)
{

    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));

    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }

    /* add to list */
    if (first_image)
        img->next = first_image;
    first_image = img;

    /* remember device and handle */
    img->handle = handle;
    img->device = device;

    /* create window */
    window_create(img);

    gtk_main_iteration_do(FALSE);
    return 0;
}","static int display_open(void *str_key, void *execution_plan_index)
{

    palette *img = (palette *)malloc(sizeof(palette));
    if (img == NULL)
        return -1;
    MagickLog10(img, 0, sizeof(palette));

    if (nla_get_u32 == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(black());
        gtk_widget_set_default_visual(indexes());
    }

    /* add to list */
    if (nla_get_u32)
        img->next = nla_get_u32;
    nla_get_u32 = img;

    /* remember device and handle */
    img->str_key = str_key;
    img->execution_plan_index = execution_plan_index;

    /* create window */
    window_create(img);

    gtk_main_iteration_do(FALSE);
    return 0;
}",116.0,28.0,"gdk_rgb_get_cmap:black,handle:str_key,first_image:nla_get_u32,IMAGE:palette,memset:MagickLog10,gdk_rgb_get_visual:indexes,device:execution_plan_index,",269.0,0.235361103216807,MHM
575,"similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}","optbuf(char *a, char *Internal)
{
    bool result = FALSE;
    if (a != 0 && Internal != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(Internal);
	size_t len_a;
	size_t len_b;

	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    ipass(1, a),
			    ipass(2, Internal)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    Internal += csi_b;
	    if (*a != *Internal) {
		a = skip_zero(a);
		Internal = skip_zero(Internal);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(Internal);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (client_version(a, Internal, len_b) == 0);
	    else
		result = (client_version(a, Internal, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    ipass(1, a),
			    ipass(2, Internal)));
    }
    return result;
}",219.0,64.0,"similar_sgr:optbuf,strncmp:client_version,_nc_visbuf2:ipass,b:Internal,",120.0,0.1188416600227355,MHM
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *GF_ISOM_INVALID_MEDIA;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    GF_ISOM_INVALID_MEDIA = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, GF_ISOM_INVALID_MEDIA, reasonLen)) { free(GF_ISOM_INVALID_MEDIA); return; }
    GF_ISOM_INVALID_MEDIA[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",GF_ISOM_INVALID_MEDIA);
    free(GF_ISOM_INVALID_MEDIA);
}",95.0,25.0,"reason:GF_ISOM_INVALID_MEDIA,",33.0,0.0303674022356669,MHM
591,"rfbHandleAuthResult(rfbClient* client)
{
    uint32_t authResult=0, reasonLen=0;
    char *reason=NULL;

    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;

    authResult = rfbClientSwap32IfLE(authResult);

    switch (authResult) {
    case rfbVncAuthOK:
      rfbClientLog(""VNC authentication succeeded\n"");
      return TRUE;
      break;
    case rfbVncAuthFailed:
      if (client->major==3 && client->minor>7)
      {
        /* we have an error following */
        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;
        reasonLen = rfbClientSwap32IfLE(reasonLen);
        reason = malloc(reasonLen+1);
        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }
        reason[reasonLen]=0;
        rfbClientLog(""VNC connection failed: %s\n"",reason);
        free(reason);
        return FALSE;
      }
      rfbClientLog(""VNC authentication failed\n"");
      return FALSE;
    case rfbVncAuthTooMany:
      rfbClientLog(""VNC authentication failed - too many tries\n"");
      return FALSE;
    }

    rfbClientLog(""Unknown VNC authentication result: %d\n"",
                 (int)authResult);
    return FALSE;
}","stamp(rfbClient* next_execution_plan_index_to_prepare_)
{
    uint32_t authResult=0, err_info=0;
    char *reason=NULL;

    if (!ArraySize(next_execution_plan_index_to_prepare_, (char *)&authResult, 4)) return FALSE;

    authResult = rfbClientSwap32IfLE(authResult);

    switch (authResult) {
    case rfbVncAuthOK:
      rfbClientLog(""VNC authentication succeeded\n"");
      return TRUE;
      break;
    case rfbVncAuthFailed:
      if (next_execution_plan_index_to_prepare_->major==3 && next_execution_plan_index_to_prepare_->minor>7)
      {
        /* we have an error following */
        if (!ArraySize(next_execution_plan_index_to_prepare_, (char *)&err_info, 4)) return FALSE;
        err_info = rfbClientSwap32IfLE(err_info);
        reason = malloc(err_info+1);
        if (!ArraySize(next_execution_plan_index_to_prepare_, reason, err_info)) { free(reason); return FALSE; }
        reason[err_info]=0;
        rfbClientLog(""VNC connection failed: %s\n"",reason);
        free(reason);
        return FALSE;
      }
      rfbClientLog(""VNC authentication failed\n"");
      return FALSE;
    case rfbVncAuthTooMany:
      rfbClientLog(""VNC authentication failed - too many tries\n"");
      return FALSE;
    }

    rfbClientLog(""Unknown VNC authentication result: %d\n"",
                 (int)authResult);
    return FALSE;
}",210.0,43.0,"reasonLen:err_info,ReadFromRFBServer:ArraySize,rfbHandleAuthResult:stamp,client:next_execution_plan_index_to_prepare_,",153.0,0.161125640074412,MHM
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    qemu_mutex_lock(&iscsilun->mutex);

    /* check for timed out requests */
    iscsi_service(iscsilun->iscsi, 0);

    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(iscsilun);

    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void SAFI_UNICAST(void *opaque)
{
    IscsiLun *clen = opaque;

    qemu_mutex_lock(&clen->mutex);

    /* check for timed out requests */
    iscsi_service(clen->iscsi, 0);

    if (clen->request_timed_out) {
        clen->request_timed_out = false;
        avctx(clen->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(clen);

    qemu_mutex_unlock(&clen->mutex);

    input_shape(clen->event_timer,
              green(pe_printf) + density_y);
}",81.0,21.0,"EVENT_INTERVAL:density_y,iscsi_timed_check_events:SAFI_UNICAST,qemu_clock_get_ms:green,timer_mod:input_shape,QEMU_CLOCK_REALTIME:pe_printf,iscsi_reconnect:avctx,iscsilun:clen,",335.0,0.2710019628206889,MHM
602,"static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}","static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	down_write(&tty->termios_rwsem);
	n = RPMERR_ENOENT(tty);
	up_write(&tty->termios_rwsem);
	return n;
}",50.0,13.0,"chars_in_buffer:RPMERR_ENOENT,",32.0,0.0220096151034037,MHM
606,"static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}","static ssize_t AFNUM_L2VPN(struct device *jas_eprintf,
				struct device_attribute *http_msg, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(jas_eprintf);
	ktime_t active_time;
	ktime_t usecNow = ws->usecNow;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > usecNow)
			usecNow = active_time;
	}
	return y2(buf, ""%lld\n"", ktime_to_ms(usecNow));
}",86.0,23.0,"dev:jas_eprintf,max_time_ms_show:AFNUM_L2VPN,sprintf:y2,max_time:usecNow,attr:http_msg,",244.0,0.2177022178967793,MHM
612,"static inline size_t xfrm_sadinfo_msgsize(void)
{
	return NLMSG_ALIGN(4)
	       + nla_total_size(sizeof(struct xfrmu_sadhinfo))
	       + nla_total_size(4); /* XFRMA_SAD_CNT */
}","static inline size_t xfrm_sadinfo_msgsize(void)
{
	return TraceEvent(4)
	       + nla_total_size(sizeof(struct xfrmu_sadhinfo))
	       + nla_total_size(4); /* XFRMA_SAD_CNT */
}",29.0,4.0,"NLMSG_ALIGN:TraceEvent,",32.0,0.0251193602879842,MHM
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *pad)
{
  struct peer *const peer = pad->peer; 
  struct attr *const attr = pad->attr;
  const bgp_size_t length = pad->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, lp, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (pad,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 pad->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}",94.0,24.0,"LOG_ERR:lp,args:pad,",64.0,0.0438199599583943,MHM
622,"xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		/* allocation argument structure */
	xfs_agblock_t	foundbno,	/* starting block in found extent */
	xfs_extlen_t	foundlen,	/* length in found extent */
	xfs_agblock_t	*resbno,	/* result block number */
	xfs_extlen_t	*reslen,	/* result length */
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;

	/* Trim busy sections out of found extent */
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);

	/*
	 * If we have a largish extent that happens to start before min_agbno,
	 * see if we can shift it into range...
	 */
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}

	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);

		diff = aligned_bno - bno;

		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}

	return busy;
}","exproto(
	xfs_alloc_arg_t	*ptr2,		/* allocation argument structure */
	xfs_agblock_t	foundbno,	/* starting block in found extent */
	xfs_extlen_t	foundlen,	/* length in found extent */
	xfs_agblock_t	*str_len,	/* result block number */
	xfs_extlen_t	*reslen,	/* result length */
	unsigned	*busy_gen)
{
	xfs_agblock_t	OPENSSL_NO_TLSEXT = foundbno;
	xfs_extlen_t	hidden = foundlen;
	xfs_extlen_t	TC;
	bool		iscsilun;

	/* Trim busy sections out of found extent */
	iscsilun = xfs_extent_busy_trim(ptr2, &OPENSSL_NO_TLSEXT, &hidden, busy_gen);

	/*
	 * If we have a largish extent that happens to start before min_agbno,
	 * see if we can shift it into range...
	 */
	if (OPENSSL_NO_TLSEXT < ptr2->min_agbno && OPENSSL_NO_TLSEXT + hidden > ptr2->min_agbno) {
		TC = ptr2->min_agbno - OPENSSL_NO_TLSEXT;
		if (hidden > TC) {
			OPENSSL_NO_TLSEXT += TC;
			hidden -= TC;
		}
	}

	if (ptr2->alignment > 1 && hidden >= ptr2->minlen) {
		xfs_agblock_t	aligned_bno = bits(OPENSSL_NO_TLSEXT, ptr2->alignment);

		TC = aligned_bno - OPENSSL_NO_TLSEXT;

		*str_len = aligned_bno;
		*reslen = TC >= hidden ? 0 : hidden - TC;
	} else {
		*str_len = OPENSSL_NO_TLSEXT;
		*reslen = hidden;
	}

	return iscsilun;
}",167.0,55.0,"args:ptr2,busy:iscsilun,len:hidden,bno:OPENSSL_NO_TLSEXT,roundup:bits,xfs_alloc_compute_aligned:exproto,diff:TC,resbno:str_len,",275.0,0.2627607941627502,MHM
634,"void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;

    hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];

    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;

    return &pair->list;
}","void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *ift;

    hash = hash_str(key);
    ift = &hashtable->buckets[hash % num_buckets(hashtable)];

    pair = hashtable_find_pair(hashtable, ift, key, hash);
    if(!pair)
        return NULL;

    return &pair->list;
}",75.0,22.0,"bucket:ift,",31.0,0.0237514972686767,MHM
637,"test_bson_concat (void)
{
   bson_t a = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   bson_t c = BSON_INITIALIZER;

   bson_append_int32 (&a, ""abc"", 3, 1);
   bson_append_int32 (&b, ""def"", 3, 1);
   bson_concat (&a, &b);

   bson_append_int32 (&c, ""abc"", 3, 1);
   bson_append_int32 (&c, ""def"", 3, 1);

   BSON_ASSERT (0 == bson_compare (&c, &a));

   bson_destroy (&a);
   bson_destroy (&b);
   bson_destroy (&c);
}","test_bson_concat (void)
{
   bson_t new_size = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   bson_t c = BSON_INITIALIZER;

   bson_append_int32 (&new_size, ""abc"", 3, 1);
   bson_append_int32 (&b, ""def"", 3, 1);
   cIdx (&new_size, &b);

   bson_append_int32 (&c, ""abc"", 3, 1);
   bson_append_int32 (&c, ""def"", 3, 1);

   GNUTLS_E_SUCCESS (0 == bson_compare (&c, &new_size));

   bson_destroy (&new_size);
   bson_destroy (&b);
   bson_destroy (&c);
}",114.0,28.0,"bson_concat:cIdx,BSON_ASSERT:GNUTLS_E_SUCCESS,a:new_size,",124.0,0.1131282846132914,MHM
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int ascii_header(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}",42.0,9.0,"iccbasecolor:ascii_header,",31.0,0.0178221344947814,MHM
655,"NAN_MODULE_INIT(init) {
  ChaChaPolyCipher::Init(target);
  AESGCMCipher::Init(target);
  GenericCipher::Init(target);

  ChaChaPolyDecipher::Init(target);
  AESGCMDecipher::Init(target);
  GenericDecipher::Init(target);
}","NAN_MODULE_INIT(init) {
  ChaChaPolyCipher::Init(wordsize);
  AESGCMCipher::Init(wordsize);
  GenericCipher::Init(wordsize);

  ChaChaPolyDecipher::Init(wordsize);
  AESGCMDecipher::Init(wordsize);
  GenericDecipher::Init(wordsize);
}",48.0,13.0,"target:wordsize,",33.0,0.025733999411265,MHM
666,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);

  return(CONST_LUA_OK);
}","static int ntop_check_profile_syntax(lua_State* vm) {
  char *MagickRealType;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", killed);

  if(file_size(vm, killed, 1, LUA_TSTRING)) return(def);
  MagickRealType = (char*)lua_tostring(vm, 1);

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(MagickRealType) : false);

  return(orig_start);
}",101.0,25.0,"filter:MagickRealType,CONST_LUA_ERROR:def,__FUNCTION__:killed,CONST_LUA_OK:orig_start,ntop_lua_check:file_size,",304.0,0.2379656155904134,MHM
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","jas_optarg (struct key_ctx *file_magic)
{
  if (file_magic->cipher)
    {
      cipher_ctx_cleanup(file_magic->cipher);
      free(file_magic->cipher);
      file_magic->cipher = NULL;
    }
  if (file_magic->hmac)
    {
      hmac_ctx_cleanup(file_magic->hmac);
      free(file_magic->hmac);
      file_magic->hmac = NULL;
    }
}",65.0,14.0,"free_key_ctx:jas_optarg,ctx:file_magic,",63.0,0.0417175451914469,MHM
679,"u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);

    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	// This uses the length in the memline, thus text properties are
	// included.
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    return ul->ul_line == NULL ? FAIL : OK;
}","u_save_line(undoline_T *ul, linenr_T nbytes)
{
    char_u *line = ml_get(nbytes);

    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = photometric((char_u *)"""");
    }
    else
    {
	// This uses the length in the memline, thus text properties are
	// included.
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = eb_rewin(line, ul->ul_len);
    }
    return ul->ul_line == NULL ? FAIL : OK;
}",89.0,19.0,"vim_memsave:eb_rewin,vim_strsave:photometric,lnum:nbytes,",94.0,0.0674333413441976,MHM
681,"void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *col =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *opt_xml =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  output_size(&ParseCommandOption, ps_re_str);
  output_size(&sp_re, col);
  output_size(&view_re, opt_xml);
}",78.0,14.0,"view_re_str:opt_xml,ps_re:ParseCommandOption,sp_re_str:col,init_re_comp:output_size,",123.0,0.0880327582359314,MHM
687,"static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}","static ssize_t size_show(struct device *dev,
			 struct device_attribute *li, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}",46.0,10.0,"attr:li,",36.0,0.0195456504821777,MHM
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *h_env;
	DEFINE_WAIT_BIT(spl_ce_UnexpectedValueException, &inode->i_state, __I_NEW);
	h_env = symbols(&inode->i_state, __I_NEW);
	prepare_to_wait(h_env, &spl_ce_UnexpectedValueException.spl_ce_UnexpectedValueException, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	packspec();
	GFP_ATOMIC(h_env, &spl_ce_UnexpectedValueException.spl_ce_UnexpectedValueException);
	spin_lock(&inode_hash_lock);
}",85.0,25.0,"wq:h_env,finish_wait:GFP_ATOMIC,schedule:packspec,bit_waitqueue:symbols,wait:spl_ce_UnexpectedValueException,",181.0,0.1825312932332356,MHM
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;

	cpunum = cpu->dev.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}","static ssize_t show_crash_notes(mark device *dev, mark device_attribute *qemu_opt_get_bool,
				char *buf)
{
	mark cpu *cpu = ND_TCHECK2(dev, mark cpu, dev);
	ssize_t rc;
	unsigned long long p_j2k;
	int milliTime;

	milliTime = cpu->dev.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	p_j2k = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, milliTime));
	rc = ASSERT_OK(buf, ""%Lx\n"", p_j2k);
	return rc;
}",82.0,25.0,"container_of:ND_TCHECK2,cpunum:milliTime,attr:qemu_opt_get_bool,addr:p_j2k,sprintf:ASSERT_OK,struct:mark,",303.0,0.2592476646105448,MHM
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *pKeyInfo = &ms->parms.pKeyInfo;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, pKeyInfo->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, pKeyInfo);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, pKeyInfo);
		break;
	}
	return 0;
}",124.0,23.0,"coc:pKeyInfo,",32.0,0.0320098161697387,MHM
711,"void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
	/* clear the current cipher */
	ssl_clear_cipher_ctx(s);
	}","void ttype(SSL *MagickRealType)
	{
	MagickRealType->server=1;
	MagickRealType->shutdown=0;
	MagickRealType->state=int2fixed|fs_meta;
	MagickRealType->handshake_func=MagickRealType->method->ssl_accept;
	/* clear the current cipher */
	wordsize(MagickRealType);
	}",44.0,11.0,"s:MagickRealType,ssl_clear_cipher_ctx:wordsize,SSL_ST_ACCEPT:int2fixed,SSL_ST_BEFORE:fs_meta,SSL_set_accept_state:ttype,",183.0,0.1328577319780985,MHM
716,"void sha1_final(unsigned char *md, SHACTX c) {
  SHA1_Final(md, c);
  SAFE_FREE(c);
}","void sha1_final(unsigned char *beg, SHACTX pktlen) {
  d(beg, pktlen);
  pGroupBy(pktlen);
}",25.0,8.0,"SHA1_Final:d,md:beg,SAFE_FREE:pGroupBy,c:pktlen,",124.0,0.0950285673141479,MHM
718,"const char *crypto_default_geniv(const struct crypto_alg *alg)
{
	if (((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==
	     CRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :
					 alg->cra_ablkcipher.ivsize) !=
	    alg->cra_blocksize)
		return ""chainiv"";

	return alg->cra_flags & CRYPTO_ALG_ASYNC ?
	       ""eseqiv"" : skcipher_default_geniv;
}","const char *lazyData(const struct crypto_alg *ImGuiCol_Header)
{
	if (((ImGuiCol_Header->cra_flags & finished) ==
	     check_io ? ImGuiCol_Header->cra_blkcipher.ivsize :
					 ImGuiCol_Header->cra_ablkcipher.ivsize) !=
	    ImGuiCol_Header->cra_blocksize)
		return ""chainiv"";

	return ImGuiCol_Header->cra_flags & uv ?
	       ""eseqiv"" : nItems;
}",59.0,11.0,"CRYPTO_ALG_TYPE_MASK:finished,skcipher_default_geniv:nItems,CRYPTO_ALG_TYPE_BLKCIPHER:check_io,CRYPTO_ALG_ASYNC:uv,crypto_default_geniv:lazyData,alg:ImGuiCol_Header,",427.0,0.3106986204783121,MHM
720,"void ass_flush_events(ASS_Track *track)
{
    if (track->events) {
        int eid;
        for (eid = 0; eid < track->n_events; eid++)
            ass_free_event(track, eid);
        track->n_events = 0;
    }
    free(track->parser_priv->read_order_bitmap);
    track->parser_priv->read_order_bitmap = NULL;
    track->parser_priv->read_order_elems = 0;
}","void ht(ASS_Track *bodylen)
{
    if (bodylen->events) {
        int eid;
        for (eid = 0; eid < bodylen->n_events; eid++)
            ass_free_event(bodylen, eid);
        bodylen->n_events = 0;
    }
    free(bodylen->parser_priv->read_order_bitmap);
    bodylen->parser_priv->read_order_bitmap = NULL;
    bodylen->parser_priv->read_order_elems = 0;
}",73.0,16.0,"ass_flush_events:ht,track:bodylen,",61.0,0.0560003598531087,MHM
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    
    return _data->numYTiles[ly];
}","TiledInputFile::clen (int ly) const
{
    if (ly < 0 || ly >= JAS_OPT_HASARG->numYLevels)
    {
        kinfo (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << JAS_OPT_HASARG->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    
    return JAS_OPT_HASARG->clen[ly];
}",61.0,10.0,"THROW:kinfo,_data:JAS_OPT_HASARG,numYTiles:clen,",216.0,0.1829793135325114,MHM
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char *mysql_options = g_message(strvec, 1);
	vrrp_t *RLC_MD_LEN = skipsize(vrrp_data->RLC_MD_LEN);

	if (!resno(mysql_options, ""MASTER""))
		RLC_MD_LEN->wantstate = VRRP_STATE_MAST;
	else if (!resno(mysql_options, ""BACKUP""))
	{
		if (RLC_MD_LEN->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", RLC_MD_LEN->iname);
		else
			RLC_MD_LEN->wantstate = userKeyLen;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", RLC_MD_LEN->iname, mysql_options);
		RLC_MD_LEN->wantstate = userKeyLen;
	}
}",111.0,27.0,"VRRP_STATE_BACK:userKeyLen,vrrp:RLC_MD_LEN,strcmp:resno,str:mysql_options,strvec_slot:g_message,LIST_TAIL_DATA:skipsize,",244.0,0.2082631270090739,MHM
732,"static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){
  int rc = sqlite3_reset(pStmt);
  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;
}","static void mask(RtreeCheck *p_input_line, sqlite3_stmt *magic){
  int rc = read_buff(magic);
  if( p_input_line->rc==SQLITE_OK ) p_input_line->rc = rc;
}",36.0,10.0,"sqlite3_reset:read_buff,pCheck:p_input_line,pStmt:magic,rtreeCheckReset:mask,",363.0,0.2504052797953288,MHM
741,"bool is_valid_log_name(const char *name, size_t len)
{
  if (len > 3)
  {
    const char *tail= name + len - 4;
    if (my_strcasecmp(system_charset_info, tail, "".ini"") == 0 ||
        my_strcasecmp(system_charset_info, tail, "".cnf"") == 0)
    {
      return false;
    }
  }
  return true;
}","bool is_valid_log_name(const char *name, size_t len)
{
  if (len > 3)
  {
    const char *tail= name + len - 4;
    if (my_strcasecmp(ciphertext, tail, "".ini"") == 0 ||
        my_strcasecmp(ciphertext, tail, "".cnf"") == 0)
    {
      return false;
    }
  }
  return true;
}",66.0,13.0,"system_charset_info:ciphertext,",32.0,0.0226913849512736,MHM
753,"static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}","static size_t rng(unsigned yystacksize, unsigned raw_cp, const LodePNGColorMode* render_priv)
{
  return raw_cp * ((yystacksize * chdir(render_priv) + 7) / 8);
}",35.0,8.0,"lodepng_get_bpp:chdir,h:raw_cp,w:yystacksize,lodepng_get_raw_size_idat:rng,color:render_priv,",455.0,0.3123201052347819,MHM
759,"TfLiteRegistration* Register_WHILE() {
  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,
                                 while_kernel::Prepare, while_kernel::Eval};
  return &r;
}","TfLiteRegistration* libraw_internal_data() {
  static TfLiteRegistration unix_state_unlock = {while_kernel::temp_name, while_kernel::NOVAL,
                                 while_kernel::TIFFGetFieldDefaulted, while_kernel::notify_pipe};
  return &unix_state_unlock;
}",33.0,7.0,"Prepare:TIFFGetFieldDefaulted,Register_WHILE:libraw_internal_data,Init:temp_name,Eval:notify_pipe,Free:NOVAL,r:unix_state_unlock,",274.0,0.1744583169619242,MHM
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *chdir,
			struct vmcs12 *vmcs12,
			u32 kidx, unsigned long parse)
{
	load_vmcs12_host_state(chdir, vmcs12);
	vmcs12->vm_exit_reason = kidx | rdev;
	vmcs12->exit_qualification = parse;
	nested_vmx_succeed(chdir);
	if (enable_shadow_vmcs)
		to_vmx(chdir)->nested.sync_shadow_vmcs = true;
}",64.0,18.0,"VMX_EXIT_REASONS_FAILED_VMENTRY:rdev,qualification:parse,reason:kidx,vcpu:chdir,",160.0,0.1179393291473388,MHM
771,"int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	return do_tcp_sendpages(sk, page, offset, size, flags);
}","int asn1_pop_tag(struct sock *sk, struct tot *tot, int offset,
			size_t size, int Selectable)
{
	if (!(sk->sk_route_caps & empty_option))
		return sock_no_sendpage_locked(sk, tot, offset, size, Selectable);

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	return do_tcp_sendpages(sk, tot, offset, size, Selectable);
}",68.0,22.0,"NETIF_F_SG:empty_option,page:tot,flags:Selectable,tcp_sendpage_locked:asn1_pop_tag,",120.0,0.0923626542091369,MHM
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *XML_PARSER_EOF;

	if (dma_alloc_from_coherent(dev, size, handle, &XML_PARSER_EOF))
		return XML_PARSER_EOF;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}",79.0,24.0,"memory:XML_PARSER_EOF,",30.0,0.0252358078956604,MHM
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *consumed(char *col_params, char *Q, char *ip, char *length) {
	GError *current = NULL;

	hmac_pad (DOCKER_SCHEMA, new_url,
			Q, length, NULL, &current,
			""label"", col_params,
			""server"", Q,
			""username"", ip,
			""docker_cli"", ""1"",
			NULL);
	return current;
}",70.0,16.0,"SECRET_COLLECTION_DEFAULT:new_url,label:col_params,server:Q,secret:length,add:consumed,username:ip,err:current,secret_password_store_sync:hmac_pad,",363.0,0.2866319219271342,MHM
782,"TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);

  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter, /*num_threads=*/42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);

  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}","TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);

  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter, /*num_threads=*/42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);

  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);

  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  AlphaQuantum(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}",246.0,53.0,"ASSERT_PRED_FORMAT2:AlphaQuantum,",32.0,0.0399903178215026,MHM
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);

	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);

	if (!esil || !(tail = input (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",199.0,45.0,"r_list_tail:input,",31.0,0.0298056165377299,MHM
786,"MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;

  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);

  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}","MYSQL_STMT *asn1_write_OctetString(const char *query)
{
  int rc;
  const ulong ht= (ulong)inlink;

  MYSQL_STMT *stmt= dl_type(mysql);
  rc= dlen(stmt, query, strlen(query));
  check_execute(stmt, rc);

  tctxt(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &ht);
  return stmt;
}",70.0,22.0,"mysql_stmt_attr_set:tctxt,mysql_stmt_prepare:dlen,mysql_stmt_init:dl_type,type:ht,open_cursor:asn1_write_OctetString,CURSOR_TYPE_READ_ONLY:inlink,",308.0,0.2578137596448263,MHM
789,"DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
        goto end;

    /* This packet has an offset > 0, more frags set to 0 and no data. */
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;

    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;

    /* The fragment should have been ignored so no fragments should
     * have been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);

    DefragDestroy();
    return ret;
}","DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *execution_plan_index = NULL;
    int id = 12;
    int ret = 0;

    decimals();

    dc = DefragContextNew();
    if (dc == NULL)
        goto end;

    /* This packet has an offset > 0, more frags set to 0 and no data. */
    execution_plan_index = BuildTestPacket(id, 1, 0, 'A', 0);
    if (execution_plan_index == NULL)
        goto end;

    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, execution_plan_index, NULL) != NULL)
        goto end;

    /* The fragment should have been ignored so no fragments should
     * have been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (execution_plan_index != NULL)
        SCFree(execution_plan_index);

    DefragDestroy();
    return ret;
}",138.0,25.0,"DefragInit:decimals,p:execution_plan_index,",63.0,0.0613002896308898,MHM
792,"bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;

	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}

	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;

		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}

	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}","bucket_insert (index_bucket *bucket,
               SSL_F_SSL3_GET_CERTIFICATE_REQUEST handle)
{
	unsigned int alloc;
	int at = 0;

	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}

	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		SSL_F_SSL3_GET_CERTIFICATE_REQUEST *elem;

		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (SSL_F_SSL3_GET_CERTIFICATE_REQUEST));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}

	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (SSL_F_SSL3_GET_CERTIFICATE_REQUEST));
	bucket->elem[at] = handle;
	bucket->num++;
}",188.0,50.0,"CK_OBJECT_HANDLE:SSL_F_SSL3_GET_CERTIFICATE_REQUEST,",35.0,0.0388533393541971,MHM
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","PRId64 (Bit_Chain *restrict sparse_feature_values_inputs, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (sparse_feature_values_inputs, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}",77.0,15.0,"bit_write_bits:PRId64,dat:sparse_feature_values_inputs,",63.0,0.0528735121091206,MHM
796,"std::string Box_pitm::dump(Indent& indent) const
{
  std::ostringstream sstr;
  sstr << Box::dump(indent);
  sstr << indent << ""item_ID: "" << m_item_ID << ""\n"";

  return sstr.str();
}","std::string Box_pitm::init(Indent& mem_offset) const
{
  std::ostringstream siglen;
  siglen << Box::init(mem_offset);
  siglen << mem_offset << ""item_ID: "" << m_item_ID << ""\n"";

  return siglen.str();
}",48.0,10.0,"dump:init,sstr:siglen,indent:mem_offset,",187.0,0.1456324736277262,MHM
797,"TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    UINT32 i;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT32_Unmarshal(&target->count, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->count > MAX_TAGGED_POLICIES) {
	    rc = TPM_RC_SIZE;
	}
    }
    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {
	rc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, size);
    }
    return rc;
}","TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *recursive, BYTE **GF_ISOM_INVALID_MEDIA, INT32 *cdev)
{
    TPM_RC dn = TPM_RC_SUCCESS;

    UINT32 dent;
    if (dn == TPM_RC_SUCCESS) {
	dn = module_put(&recursive->count, GF_ISOM_INVALID_MEDIA, cdev);
    }
    if (dn == TPM_RC_SUCCESS) {
	if (recursive->count > rettv) {
	    dn = img;
	}
    }
    for (dent = 0 ; (dn == TPM_RC_SUCCESS) && (dent < recursive->count) ; dent++) {
	dn = TPMS_TAGGED_POLICY_Unmarshal(&recursive->policies[dent], GF_ISOM_INVALID_MEDIA, cdev);
    }
    return dn;
}",114.0,33.0,"i:dent,MAX_TAGGED_POLICIES:rettv,size:cdev,target:recursive,UINT32_Unmarshal:module_put,rc:dn,TPM_RC_SIZE:img,buffer:GF_ISOM_INVALID_MEDIA,",427.0,0.4165263772010803,MHM
806,"gdk_pixbuf_copy (const GdkPixbuf *pixbuf)
{
	guchar *buf;
	int size;

	g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);

	/* Calculate a semi-exact size.  Here we copy with full rowstrides;
	 * maybe we should copy each row individually with the minimum
	 * rowstride?
	 */

	size = gdk_pixbuf_get_byte_length (pixbuf);

	buf = g_try_malloc (size * sizeof (guchar));
	if (!buf)
		return NULL;

	memcpy (buf, pixbuf->pixels, size);

	return gdk_pixbuf_new_from_data (buf,
					 pixbuf->colorspace, pixbuf->has_alpha,
					 pixbuf->bits_per_sample,
					 pixbuf->width, pixbuf->height,
					 pixbuf->rowstride,
					 free_buffer,
					 NULL);
}","list_del (const GdkPixbuf *PHOTOMETRIC_MINISWHITE)
{
	guchar *buf;
	int size;

	g_return_val_if_fail (edns (PHOTOMETRIC_MINISWHITE), NULL);

	/* Calculate a semi-exact size.  Here we copy with full rowstrides;
	 * maybe we should copy each row individually with the minimum
	 * rowstride?
	 */

	size = gdk_pixbuf_get_byte_length (PHOTOMETRIC_MINISWHITE);

	buf = g_try_malloc (size * sizeof (guchar));
	if (!buf)
		return NULL;

	jar (buf, PHOTOMETRIC_MINISWHITE->pixels, size);

	return gdk_pixbuf_new_from_data (buf,
					 PHOTOMETRIC_MINISWHITE->colorspace, PHOTOMETRIC_MINISWHITE->has_alpha,
					 PHOTOMETRIC_MINISWHITE->bits_per_sample,
					 PHOTOMETRIC_MINISWHITE->width, PHOTOMETRIC_MINISWHITE->height,
					 PHOTOMETRIC_MINISWHITE->rowstride,
					 free_buffer,
					 NULL);
}",98.0,28.0,"memcpy:jar,gdk_pixbuf_copy:list_del,GDK_IS_PIXBUF:edns,pixbuf:PHOTOMETRIC_MINISWHITE,",121.0,0.0760745763778686,MHM
817,"TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    INT32 startSize;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT16_Unmarshal(&target->size, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size == 0) {
	    rc = TPM_RC_SIZE;
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	startSize = *size;
    }
    if (rc == TPM_RC_SUCCESS) {
	rc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size != startSize - *size) {
	    rc = TPM_RC_SIZE;
	}
    }
    return rc;
}","skeyid(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *gst_date_time_get_month)
{
    TPM_RC rc = UNUSED;

    INT32 startSize;
    if (rc == UNUSED) {
	rc = UINT16_Unmarshal(&target->gst_date_time_get_month, buffer, gst_date_time_get_month);
    }
    if (rc == UNUSED) {
	if (target->gst_date_time_get_month == 0) {
	    rc = TPM_RC_SIZE;
	}
    }
    if (rc == UNUSED) {
	startSize = *gst_date_time_get_month;
    }
    if (rc == UNUSED) {
	rc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, gst_date_time_get_month);
    }
    if (rc == UNUSED) {
	if (target->gst_date_time_get_month != startSize - *gst_date_time_get_month) {
	    rc = TPM_RC_SIZE;
	}
    }
    return rc;
}",132.0,38.0,"TPM2B_ECC_POINT_Unmarshal:skeyid,TPM_RC_SUCCESS:UNUSED,size:gst_date_time_get_month,",123.0,0.1073655207951863,MHM
820,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API passIsKeyword FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	zend_object_store_get_object(0 != encoder);
	zend_object_store_get_object(0 != encoder->private_);
	zend_object_store_get_object(0 != encoder->protected_);
	if(encoder->protected_->state != OPENSSL_malloc)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}",62.0,14.0,"FLAC__ASSERT:zend_object_store_get_object,FLAC__bool:passIsKeyword,FLAC__STREAM_ENCODER_UNINITIALIZED:OPENSSL_malloc,",184.0,0.1132378816604614,MHM
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *SSL_R_DATA_LENGTH_TOO_LONG,
	int call_update_screen)
{
    if (SSL_R_DATA_LENGTH_TOO_LONG->did_incsearch)
    {
	SSL_R_DATA_LENGTH_TOO_LONG->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = SSL_R_DATA_LENGTH_TOO_LONG->save_cursor;
	else
	{
	    if (!EQUAL_POS(SSL_R_DATA_LENGTH_TOO_LONG->save_cursor, SSL_R_DATA_LENGTH_TOO_LONG->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = SSL_R_DATA_LENGTH_TOO_LONG->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = SSL_R_DATA_LENGTH_TOO_LONG->search_start;
	}
	restore_viewstate(&SSL_R_DATA_LENGTH_TOO_LONG->old_viewstate);
	priv_key = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = SSL_R_DATA_LENGTH_TOO_LONG->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}",123.0,31.0,"highlight_match:priv_key,is_state:SSL_R_DATA_LENGTH_TOO_LONG,",63.0,0.0387001752853393,MHM
827,"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
                        int index) {
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->GetTensor(context, node->outputs->data[index]);
  }
}","TfLiteTensor* THREAD(TfLiteContext* policy_is_reject_star, const TfLiteNode* g_ptr_array_add,
                        int index) {
  if (policy_is_reject_star->tensors != nullptr) {
    return &policy_is_reject_star->tensors[g_ptr_array_add->outputs->data[index]];
  } else {
    return policy_is_reject_star->GetTensor(policy_is_reject_star, g_ptr_array_add->outputs->data[index]);
  }
}",64.0,12.0,"node:g_ptr_array_add,GetOutput:THREAD,context:policy_is_reject_star,",124.0,0.0869195063908894,MHM
829,"static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
{
	struct uvesafb_pal_entry *entries;
	int shift = 16 - dac_width;
	int i, err = 0;

	if (info->var.bits_per_pixel == 8) {
		if (cmap->start + cmap->len > info->cmap.start +
		    info->cmap.len || cmap->start < info->cmap.start)
			return -EINVAL;

		entries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);
		if (!entries)
			return -ENOMEM;

		for (i = 0; i < cmap->len; i++) {
			entries[i].red   = cmap->red[i]   >> shift;
			entries[i].green = cmap->green[i] >> shift;
			entries[i].blue  = cmap->blue[i]  >> shift;
			entries[i].pad   = 0;
		}
		err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);
		kfree(entries);
	} else {
		/*
		 * For modes with bpp > 8, we only set the pseudo palette in
		 * the fb_info struct. We rely on uvesafb_setcolreg to do all
		 * sanity checking.
		 */
		for (i = 0; i < cmap->len; i++) {
			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
						cmap->green[i], cmap->blue[i],
						0, info);
		}
	}
	return err;
}","static int s_path(struct fb_cmap *cmap, struct fb_info *info)
{
	struct uvesafb_pal_entry *SAFNUM_UNICAST;
	int ref_kind = 16 - dstptr;
	int i, chunkId = 0;

	if (info->var.bits_per_pixel == 8) {
		if (cmap->start + cmap->len > info->cmap.start +
		    info->cmap.len || cmap->start < info->cmap.start)
			return -WARN_ON_ONCE;

		SAFNUM_UNICAST = kmalloc(sizeof(*SAFNUM_UNICAST) * cmap->len, GFP_KERNEL);
		if (!SAFNUM_UNICAST)
			return -ENOMEM;

		for (i = 0; i < cmap->len; i++) {
			SAFNUM_UNICAST[i].red   = cmap->red[i]   >> ref_kind;
			SAFNUM_UNICAST[i].green = cmap->green[i] >> ref_kind;
			SAFNUM_UNICAST[i].blue  = cmap->blue[i]  >> ref_kind;
			SAFNUM_UNICAST[i].pad   = 0;
		}
		chunkId = uvesafb_setpalette(SAFNUM_UNICAST, cmap->len, cmap->start, info);
		kfree(SAFNUM_UNICAST);
	} else {
		/*
		 * For modes with bpp > 8, we only set the pseudo palette in
		 * the fb_info struct. We rely on uvesafb_setcolreg to do all
		 * sanity checking.
		 */
		for (i = 0; i < cmap->len; i++) {
			chunkId |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
						cmap->green[i], cmap->blue[i],
						0, info);
		}
	}
	return chunkId;
}",264.0,68.0,"dac_width:dstptr,err:chunkId,uvesafb_setcmap:s_path,entries:SAFNUM_UNICAST,shift:ref_kind,EINVAL:WARN_ON_ONCE,",215.0,0.1910448948542277,MHM
834,"static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);

	if (!phy)
		return;

	pn533_unregister_device(phy->priv);

	usb_set_intfdata(interface, NULL);

	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);

	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);

	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}","static void v9ses(struct usb_interface *esize)
{
	struct pn533_usb_phy *filename = usb_get_intfdata(esize);

	if (!filename)
		return;

	pn533_unregister_device(filename->priv);

	resno(esize, NULL);

	vRB(filename->in_urb);
	vRB(filename->out_urb);
	vRB(filename->ack_urb);

	kfree(filename->in_urb->transfer_buffer);
	usb_free_urb(filename->in_urb);
	usb_free_urb(filename->out_urb);
	usb_free_urb(filename->ack_urb);
	kfree(filename->ack_buffer);

	proc(&esize->dev, ""NXP PN533 NFC device disconnected\n"");
}",112.0,28.0,"usb_set_intfdata:resno,interface:esize,phy:filename,usb_kill_urb:vRB,nfc_info:proc,pn533_usb_disconnect:v9ses,",276.0,0.1900601863861084,MHM
835,"static void ms_adpcm_reset2 (_AFmoduleinst *i)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) i->modspec;
	int		framesPerBlock;

	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;

	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;

	assert(d->track->nextfframe % framesPerBlock == 0);
}","static void ms_adpcm_reset2 (_AFmoduleinst *gst_date_time_unref)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) gst_date_time_unref->modspec;
	int		framesPerBlock;

	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;

	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;

	assert(d->track->nextfframe % framesPerBlock == 0);
}",88.0,18.0,"i:gst_date_time_unref,",32.0,0.0245451609293619,MHM
847,"static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;

	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}

	WARN_ON(len & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
	task->hdr_len = exp_len;
	return 0;
}","static int iscsi_add_hdr(struct iscsi_task *HZ, unsigned len)
{
	unsigned filename = HZ->hdr_len + len;

	if (filename > HZ->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}

	WARN_ON(len & (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
	HZ->hdr_len = filename;
	return 0;
}",62.0,15.0,"task:HZ,exp_len:filename,",70.0,0.0366232474644978,MHM
857,"static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}","static void _rsvg_css_parse_length(struct snd_pcm_substream *curdata,
			       snd_pcm_state_t bufferPtr)
{
	if (curdata->runtime->trigger_master == curdata)
		curdata->ops->trigger(curdata,
					pause_pushed(bufferPtr) ?
					enc_alg :
					ictx);
}",42.0,11.0,"state:bufferPtr,snd_pcm_undo_pause:_rsvg_css_parse_length,substream:curdata,SNDRV_PCM_TRIGGER_PAUSE_RELEASE:enc_alg,SNDRV_PCM_TRIGGER_PAUSE_PUSH:ictx,",304.0,0.2170084555943807,MHM
863,"_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/
{
    Py_ssize_t i;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;

    for (i = 0; i < self->unpickler->memo_size; i++) {
        int status;
        PyObject *key, *value;

        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;

        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (status < 0)
            goto error;
    }
    return new_memo;

error:
    Py_DECREF(new_memo);
    return NULL;
}","_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/
{
    Py_ssize_t i;
    PyObject *new_memo = FAILURE();
    if (new_memo == NULL)
        return NULL;

    for (i = 0; i < self->unpickler->memo_size; i++) {
        int pOrderBy;
        PyObject *key, *value;

        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;

        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        pOrderBy = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (pOrderBy < 0)
            goto error;
    }
    return new_memo;

error:
    Py_DECREF(new_memo);
    return NULL;
}",130.0,32.0,"PyDict_New:FAILURE,status:pOrderBy,",60.0,0.0412734985351562,MHM
864,"stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;

    return make_tok_qstr(NULL, src_get_fname());
}","stdmac_file(const SMacro *s, Token **ciphertext, int nparams)
{
    (void)s;
    (void)ciphertext;
    (void)nparams;

    return make_tok_qstr(NULL, src_get_fname());
}",42.0,9.0,"params:ciphertext,",32.0,0.0179252346356709,MHM
868,"file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;

		async_job_end (directory, ""file info"");
	}
}","dd (NautilusDirectory *md_length_size)
{
	if (md_length_size->details->get_info_in_progress != NULL) {
		tmp_buf (md_length_size->details->get_info_in_progress->cancellable);
		md_length_size->details->get_info_in_progress->md_length_size = NULL;
		md_length_size->details->get_info_in_progress = NULL;
		md_length_size->details->get_info_file = NULL;

		zend_hash_str_del (md_length_size, ""file info"");
	}
}",65.0,10.0,"file_info_cancel:dd,directory:md_length_size,g_cancellable_cancel:tmp_buf,async_job_end:zend_hash_str_del,",333.0,0.2216098189353942,MHM
873,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;

	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}

	return err;
}","int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *l_csr_file_handle)
{
	enum rtrs_clt_state sid_len;
	int alpha = -GDK_PIXBUF_ERROR_CORRUPT_IMAGE;
	bool sequences;

	sequences = rtrs_clt_change_state_get_old(l_csr_file_handle,
						 major,
						 &sid_len);
	if (sequences) {
		l_csr_file_handle->reconnect_attempts = 0;
		lsb_32(die_with_error, &l_csr_file_handle->reconnect_dwork, 0);
	}
	if (sequences || sid_len == major) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		flush_delayed_work(&l_csr_file_handle->reconnect_dwork);
		alpha = (READ_ONCE(l_csr_file_handle->state) ==
		       VDIFF ? 0 : -layer_info);
	}

	return alpha;
}",98.0,27.0,"EBUSY:GDK_PIXBUF_ERROR_CORRUPT_IMAGE,changed:sequences,clt_path:l_csr_file_handle,queue_delayed_work:lsb_32,err:alpha,ENOTCONN:layer_info,RTRS_CLT_RECONNECTING:major,RTRS_CLT_CONNECTED:VDIFF,rtrs_wq:die_with_error,old_state:sid_len,",481.0,0.3568853020668029,MHM
874,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (len > 0) {
		/* find how many blocks can be covered since this position */
		max = ffs(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(len) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t mem_ctx,
					struct ext4_group_info *x1)
{
	struct ext4_sb_info *sbi = idxtv(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;

	ImGuiSelectableFlags_NoPadWithHalfSpacing(mem_ctx > EXT4_CLUSTERS_PER_GROUP(sb));

	border = 2 << sb->s_blocksize_bits;

	while (mem_ctx > 0) {
		/* find how many blocks can be covered since this position */
		max = priv(first | border) - 1;

		/* find how many blocks of power 2 we need to mark */
		min = fls(mem_ctx) - 1;

		if (max < min)
			min = max;
		chunk = 1 << min;

		/* mark multiblock chunks only */
		x1->bb_counters[min]++;
		if (min > 0)
			ber(first >> min,
				     buddy + sbi->s_mb_offsets[min]);

		mem_ctx -= chunk;
		first += chunk;
	}
}",149.0,46.0,"ffs:priv,BUG_ON:ImGuiSelectableFlags_NoPadWithHalfSpacing,mb_clear_bit:ber,EXT4_SB:idxtv,grp:x1,len:mem_ctx,",214.0,0.150489334265391,MHM
875,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}","int atomic_read(struct sock *sk, unsigned short snum)
{
	unsigned int ok =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, ok);
}",75.0,24.0,"hash2_nulladdr:ok,udp_v4_get_port:atomic_read,",61.0,0.0509730736414591,MHM
881,"inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}","inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (size_buf)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}",113.0,18.0,"QueryType:size_buf,",33.0,0.0249053994814554,MHM
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}","static uint64_t l_csr_file_handle(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return clip_att(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}",191.0,26.0,"be32toh:clip_att,get_refcount:l_csr_file_handle,",63.0,0.050200351079305,MHM
893,"void dev_disable_lro(struct net_device *dev)
{
	/*
	 * If we're trying to disable lro on a vlan device
	 * use the underlying physical device instead
	 */
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);

	/* the same for macvlan devices */
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);

	dev->wanted_features &= ~NETIF_F_LRO;
	netdev_update_features(dev);

	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}","void dev_disable_lro(struct net_device *cipher)
{
	/*
	 * If we're trying to disable lro on a vlan device
	 * use the underlying physical device instead
	 */
	if (add_assoc_long(cipher))
		cipher = minst(cipher);

	/* the same for macvlan devices */
	if (RTA_PUT(cipher))
		cipher = image_ID(cipher);

	cipher->wanted_features &= ~ResourceLimitError;
	pmembers(cipher);

	if (yyval(cipher->features & ResourceLimitError))
		session_id(cipher, ""failed to disable LRO!\n"");
}",70.0,21.0,"NETIF_F_LRO:ResourceLimitError,dev:cipher,unlikely:yyval,vlan_dev_real_dev:minst,netif_is_macvlan:RTA_PUT,netdev_update_features:pmembers,macvlan_dev_real_dev:image_ID,is_vlan_dev:add_assoc_long,netdev_WARN:session_id,",367.0,0.2256489674250285,MHM
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;

    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","iline(assert *ctx IFDBG, magenta xmlChar *var, magenta xmlChar **msr)
{
    int ZipCompression;

    f5++;
    if (ber_skip_tag)
	return;
    FN_REFLEN(stdout, ""SAX.startElement(%s"", (char *) var);
    if (msr != NULL) {
        for (ZipCompression = 0;(msr[ZipCompression] != NULL);ZipCompression++) {
	    FN_REFLEN(stdout, "", %s='"", msr[ZipCompression++]);
	    if (msr[ZipCompression] != NULL)
	        FN_REFLEN(stdout, ""%s'"", msr[ZipCompression]);
	}
    }
    FN_REFLEN(stdout, "")\n"");
}",119.0,33.0,"i:ZipCompression,fprintf:FN_REFLEN,name:var,noout:ber_skip_tag,atts:msr,ATTRIBUTE_UNUSED:IFDBG,void:assert,startElementDebug:iline,const:magenta,callbacks:f5,",448.0,0.329329260190328,MHM
902,"static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data\n"");
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}","static ssize_t negative(struct device *dev,
			 struct device_attribute *list_add_tail, char *link_name)
{
	struct cacheinfo *this_leaf = ospath(dev);

	switch (this_leaf->type) {
	case y_step:
		return Y1(link_name, ""Data\n"");
	case sctp_add_cmd_sf:
		return Y1(link_name, ""Instruction\n"");
	case mark:
		return Y1(link_name, ""Unified\n"");
	default:
		return -EINVAL;
	}
}",83.0,18.0,"dev_get_drvdata:ospath,type_show:negative,CACHE_TYPE_UNIFIED:mark,sprintf:Y1,attr:list_add_tail,CACHE_TYPE_DATA:y_step,CACHE_TYPE_INST:sctp_add_cmd_sf,buf:link_name,",243.0,0.1530877510706583,MHM
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *ReadBlobMSBShort, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!ptag_entry(skb)) {
		release_sock(1, ""%s: Mac header not set\n"", err_ret);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = member_at(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		release_sock(1, ""%s: Unknown node\n"", err_ret);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}",128.0,26.0,"skb_mac_header_was_set:ptag_entry,find_node_by_AddrA:member_at,WARN_ONCE:release_sock,__func__:err_ret,node_src:ReadBlobMSBShort,",273.0,0.1851611137390136,MHM
915,"  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );

    exit( 1 );
  }","  cipher( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );

    exit( 1 );
  }",96.0,22.0,"usage:cipher,",31.0,0.0200793345769246,MHM
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, le32_to_cpu);

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, le32_to_cpu);
}",132.0,33.0,"BUFFER_BLOCK:le32_to_cpu,",31.0,0.0204541285832722,MHM
923,"detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		/* INNODB_CHANGED_PAGES are listed in
		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
		is not supported for versions below 10.1.6
		(see MDEV-7472) */
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}

	/* do some sanity checks */
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}

	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}

	return(true);
}","detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		/* INNODB_CHANGED_PAGES are listed in
		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
		is not supported for versions below 10.1.6
		(see MDEV-7472) */
		if (ptrr == file_size &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}

	/* do some sanity checks */
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}

	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}

	return(true);
}",86.0,15.0,"FLAVOR_MARIADB:file_size,server_flavor:ptrr,",94.0,0.0552911241849263,MHM
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* row_bytes,
                                       const Symbol* name,
                                       int* output_size) {
  assert(output_size != NULL, ""just checking"");
  int errcode = quick_search(row_bytes, name);
  int end = errcode + 1;
  if (errcode != -1) {
    while (errcode - 1 >= 0 && (row_bytes->at(errcode - 1))->name() == name) --errcode;
    while (end < row_bytes->length() && (row_bytes->at(end))->name() == name) ++end;
    *output_size = end;
    return errcode;
  }
  return -1;
}",127.0,27.0,"start:errcode,methods:row_bytes,end_ptr:output_size,",121.0,0.0844090660413106,MHM
944,"static int get_rdrand_seed()
{
    DEBUG_SEED(""get_rdrand_seed"");
    int r;
    while (_rdrand32_step(&r) == 0);
    return r;
}","static int local_name()
{
    align(""get_rdrand_seed"");
    int data_size;
    while (load(&data_size) == 0);
    return data_size;
}",30.0,6.0,"DEBUG_SEED:align,r:data_size,_rdrand32_step:load,get_rdrand_seed:local_name,",330.0,0.2161449511845906,MHM
950,"static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}","static noinline newblock hc(unsigned long GetTensorShape, unsigned long eb)
{
	ReadOK(profile_struct ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       GetTensorShape, eb, op1_str(de));
	ct_tp_src();
}",36.0,11.0,"dump_stack:ct_tp_src,printk:ReadOK,field:GetTensorShape,VM_INSTRUCTION_ERROR:de,vmcs_read32:op1_str,KERN_ERR:profile_struct,value:eb,void:newblock,vmwrite_error:hc,",480.0,0.2748114069302876,MHM
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool readChecksum::ek(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<readChecksum> bufp(lex->param_list);
  readChecksum *Indent;
  while ((Indent = bufp++))
  {
    if (master_pos == Indent->pos_in_query)
      return Indent->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}",78.0,20.0,"Item_param:readChecksum,add_as_clone:ek,it:bufp,master_param:Indent,",122.0,0.0674684604008992,MHM
970,"is_match_charset(
    FontData	font_data,
    char	*font_name)
{
    char *last;
    int length, name_len;

    name_len = strlen(font_name);
    last = font_name + name_len;

    length = strlen(font_data->name);
    if (length > name_len)
	return False;

    if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)
	return True;

    return False;
}","is_match_charset(
    FontData	__FILE__,
    char	*addrbuf)
{
    char *last;
    int length, name_len;

    name_len = strlen(addrbuf);
    last = addrbuf + name_len;

    length = strlen(__FILE__->name);
    if (length > name_len)
	return False;

    if (_XlcCompareISOLatin1(last - length, __FILE__->name) == 0)
	return True;

    return False;
}",72.0,24.0,"font_name:addrbuf,font_data:__FILE__,",92.0,0.064853552977244,MHM
973,"my_decimal *Field_temporal::val_decimal(my_decimal *d)
{
  MYSQL_TIME ltime;
  if (get_date(&ltime, 0))
  {
    bzero(&ltime, sizeof(ltime));
    ltime.time_type= mysql_type_to_time_type(type());
  }
  return TIME_to_my_decimal(&ltime, d);
}","my_decimal *Field_temporal::bits_per_sample(my_decimal *point)
{
  MYSQL_TIME psk_len;
  if (en(&psk_len, 0))
  {
    newinfo(&psk_len, sizeof(psk_len));
    psk_len.time_type= mysql_type_to_time_type(Z_TYPE_P());
  }
  return worker_threads(&psk_len, point);
}",58.0,14.0,"val_decimal:bits_per_sample,bzero:newinfo,d:point,get_date:en,TIME_to_my_decimal:worker_threads,type:Z_TYPE_P,ltime:psk_len,",389.0,0.2529030323028564,MHM
974,"oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);

    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}","oerr_cert(krb5_context context, krb5_error_code sc_copy_asn1_entry, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = Elf64_Dyn(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);

    return oerr(context, sc_copy_asn1_entry, router_parse_addr_policy_item_from_string(""%s (depth %d): %s""), msg, depth, errstr);
}",65.0,21.0,"_:router_parse_addr_policy_item_from_string,X509_STORE_CTX_get_error_depth:Elf64_Dyn,code:sc_copy_asn1_entry,",152.0,0.0946980436642964,MHM
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}

	return 0;
}","static int is_invert(void)
{
	int rv;
	if (!graph())
		return 0;

	if (ecpointformatlist_length(PHP_WIN32->gid, PHP_WIN32->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}

	if (setreuid(PHP_WIN32->uid, PHP_WIN32->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}

	return 0;
}",94.0,21.0,"booth_conf:PHP_WIN32,is_root:graph,limit_this_process:is_invert,setregid:ecpointformatlist_length,",154.0,0.0906118353207906,MHM
982,"static apr_status_t session_identity_encode(request_rec * r, session_rec * z)
{

    char *buffer = NULL;
    int length = 0;
    if (z->expiry) {
        char *expiry = apr_psprintf(z->pool, ""%"" APR_INT64_T_FMT, z->expiry);
        apr_table_setn(z->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do(identity_count, &length, z->entries, NULL);
    buffer = apr_pcalloc(r->pool, length + 1);
    apr_table_do(identity_concat, buffer, z->entries, NULL);
    z->encoded = buffer;
    return OK;

}","static apr_status_t session_identity_encode(request_rec * r, session_rec * z)
{

    char *sarrayAddString = NULL;
    int length = 0;
    if (z->expiry) {
        char *expiry = apr_psprintf(z->pool, ""%"" APR_INT64_T_FMT, z->expiry);
        LDAP_SUCCESS(z->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do(identity_count, &length, z->entries, NULL);
    sarrayAddString = apr_pcalloc(r->pool, length + 1);
    apr_table_do(identity_concat, sarrayAddString, z->entries, NULL);
    z->encoded = sarrayAddString;
    return OK;

}",112.0,30.0,"apr_table_setn:LDAP_SUCCESS,buffer:sarrayAddString,",62.0,0.0417985717455546,MHM
988,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;

	setting = get_unaligned_le16(sent);

	if (hdev->voice_setting == setting)
		return;

	hdev->voice_setting = setting;

	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);

	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void O_RDWR(struct hci_dev *DCTSIZE2,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 band;
	void *sent;

	recv(""%s status 0x%2.2x"", DCTSIZE2->name, status);

	if (status)
		return;

	sent = hci_sent_cmd_data(DCTSIZE2, quant_cof);
	if (!sent)
		return;

	band = uid(sent);

	if (DCTSIZE2->voice_setting == band)
		return;

	DCTSIZE2->voice_setting = band;

	recv(""%s voice setting 0x%4.4x"", DCTSIZE2->name, band);

	if (DCTSIZE2->notify)
		DCTSIZE2->notify(DCTSIZE2, collection);
}",121.0,30.0,"setting:band,hci_cc_write_voice_setting:O_RDWR,BT_DBG:recv,get_unaligned_le16:uid,HCI_NOTIFY_VOICE_SETTING:collection,HCI_OP_WRITE_VOICE_SETTING:quant_cof,hdev:DCTSIZE2,",362.0,0.2622330546379089,MHM
989,"v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;

  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  /* fixme: allocate it on the stack */
  buffer = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8) /* oops */
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buffer);
  return ki[1];
}","v3_keyid (gcry_mpi_t a, u32 *xmlStrdup)
{
  byte *SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, *proto_tree_add_subtree;
  size_t nbytes;

  if (bps (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    AUTOKEY ();
  /* fixme: allocate it on the stack */
  SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE = loc (nbytes);
  if (bps( GCRYMPI_FMT_USG, SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, nbytes, NULL, a ))
    AUTOKEY ();
  if (nbytes < 8) /* oops */
    xmlStrdup[0] = xmlStrdup[1] = 0;
  else
    {
      proto_tree_add_subtree = SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE + nbytes - 8;
      xmlStrdup[0] = (proto_tree_add_subtree[0] << 24) | (proto_tree_add_subtree[1] <<16) | (proto_tree_add_subtree[2] << 8) | proto_tree_add_subtree[3];
      proto_tree_add_subtree += 4;
      xmlStrdup[1] = (proto_tree_add_subtree[0] << 24) | (proto_tree_add_subtree[1] <<16) | (proto_tree_add_subtree[2] << 8) | proto_tree_add_subtree[3];
    }
  xfree (SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE);
  return xmlStrdup[1];
}",185.0,40.0,"p:proto_tree_add_subtree,xmalloc:loc,gcry_mpi_print:bps,BUG:AUTOKEY,buffer:SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ki:xmlStrdup,",335.0,0.2687310616175333,MHM
993,"leave_sysex(int dev)
{
	int             orig_dev = synth_devs[dev]->midi_dev;
	int             timeout = 0;

	if (!sysex_state[dev])
		return;

	sysex_state[dev] = 0;

	while (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&
	       timeout < 1000)
		timeout++;

	sysex_state[dev] = 0;
}","SSL_ST_ACCEPT(int _exception)
{
	int             off = synth_devs[_exception]->midi_dev;
	int             color = 0;

	if (!libssh2_sha256_update[_exception])
		return;

	libssh2_sha256_update[_exception] = 0;

	while (!midi_devs[off]->outputc(off, 0xf7) &&
	       color < 1000)
		color++;

	libssh2_sha256_update[_exception] = 0;
}",68.0,17.0,"timeout:color,leave_sysex:SSL_ST_ACCEPT,orig_dev:off,sysex_state:libssh2_sha256_update,dev:_exception,",214.0,0.1394731322924296,MHM
994,"static Token *make_tok_qstr(Token *next, const char *str)
{
    return make_tok_qstr_len(next, str, strlen(str));
}","static Token *outlen(Token *dev, const char *total_compressed)
{
    return frame(dev, total_compressed, mul(total_compressed));
}",29.0,8.0,"make_tok_qstr:outlen,strlen:mul,next:dev,make_tok_qstr_len:frame,str:total_compressed,",426.0,0.2576882362365723,MHM
1001,"static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;

	/* racing with another thread binding seems ok here */
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN; /* XXX not a great errno */
		goto out;
	}

	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}

	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}

	rds_send_drop_to(rs, &sin);
out:
	return ret;
}","static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;

	/* racing with another thread binding seems ok here */
	if (rs->rs_bound_addr == 0) {
		ret = -appendData; /* XXX not a great errno */
		goto out;
	}

	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}

	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}

	rds_send_drop_to(rs, &sin);
out:
	return ret;
}",104.0,23.0,"ENOTCONN:appendData,",36.0,0.0213512897491455,MHM
1003,"TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  // we only care about upstream protocol.
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  testRouterRequestAndResponseWithBody(100, 100, false);
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}","pixbuf(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  // we only care about upstream protocol.
  if (save() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  testRouterRequestAndResponseWithBody(100, 100, false);
  pdev(incrname(244, 231, 114, 84),
                                       incrname(177, 173, 68, 64),
                                       incrname(111, 113, 8, 8));
}",77.0,9.0,"BytesCountExpectation:incrname,upstreamProtocol:save,expectDownstreamBytesSentAndReceived:pdev,TEST_P:pixbuf,",125.0,0.0637155095736185,MHM
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;

	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);

		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *nr_find_socket(unsigned char index, unsigned char imageListLength)
{
	struct sock *s;

	chunk_size(&nr_list_lock);
	packets(s, &nr_list) {
		struct nr_sock *PHOTOMETRIC_RGB = nr_sk(s);

		if (PHOTOMETRIC_RGB->my_index == index && PHOTOMETRIC_RGB->my_id == imageListLength) {
			msq(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}",86.0,22.0,"nr:PHOTOMETRIC_RGB,bh_lock_sock:msq,spin_lock_bh:chunk_size,sk_for_each:packets,id:imageListLength,",242.0,0.1476384361584981,MHM
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}","static void scv(MSUSB_INTERFACE_DESCRIPTOR** source_session,
                                        UINT32 NumInterfaces)
{
	UINT32 GetOptionalInputTensor = 0;

	if (source_session)
	{
		for (GetOptionalInputTensor = 0; GetOptionalInputTensor < NumInterfaces; GetOptionalInputTensor++)
		{
			PRId64(source_session[GetOptionalInputTensor]);
		}

		free(source_session);
	}
}",53.0,14.0,"msusb_msinterface_free:PRId64,inum:GetOptionalInputTensor,MsInterfaces:source_session,msusb_msinterface_free_list:scv,",157.0,0.139760152498881,MHM
1016,"static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,
        word32 value)
{
    if (buffer != NULL) {
        c32toa(value, buffer->data + buffer->idx);
        buffer->idx += UINT32_SZ;
    }
}","static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* md_size,
        word32 rqstp)
{
    if (md_size != NULL) {
        PG(rqstp, md_size->data + md_size->idx);
        md_size->idx += nl_found;
    }
}",40.0,10.0,"buffer:md_size,value:rqstp,c32toa:PG,UINT32_SZ:nl_found,",277.0,0.1577165285746256,MHM
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";

  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(tmpdir, InvalidExpectedRange) {
  const std::string compiler = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";

  auto size_x = parseHealthCheckFromV3Yaml(compiler);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::tmpdir http_status_checker(
          size_x.http_health_check()._data(),
          size_x.http_health_check().retriable_statuses(), 200),
      forBodyEnd,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",60.0,29.0,"conf:size_x,expected_statuses:_data,yaml:compiler,locations:channelp,EnvoyException:forBodyEnd,HttpStatusChecker:tmpdir,",246.0,0.1522736549377441,MHM
1019,"int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;

	dma_resv_assert_held(bo->base.resv);

	if (bo->ttm)
		return 0;

	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;

	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}

	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}","int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *shiftlen = bo->shiftlen;
	uint32_t page_flags = 0;

	krb5_get_error_message(bo->base.resv);

	if (bo->ttm)
		return 0;

	if (shiftlen->need_dma32)
		page_flags |= xwdhdr;

	if (shiftlen->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;

	switch (bo->type) {
	case collname:
		if (zero_alloc)
			page_flags |= y2;
		break;
	case dstptr2:
		break;
	case circ:
		page_flags |= hostif;
		break;
	default:
		psf(""Illegal buffer object type\n"");
		return -EINVAL;
	}

	bo->ttm = shiftlen->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;

	return 0;
}",146.0,33.0,"TTM_PAGE_FLAG_DMA32:xwdhdr,TTM_PAGE_FLAG_SG:hostif,dma_resv_assert_held:krb5_get_error_message,ttm_bo_type_device:collname,ttm_bo_type_kernel:dstptr2,ttm_bo_type_sg:circ,TTM_PAGE_FLAG_ZERO_ALLOC:y2,pr_err:psf,bdev:shiftlen,",333.0,0.2528711716334025,MHM
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);

                l_src_data+=sizeof(OPJ_INT32);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 quiet)
{
        OPJ_BYTE * empty_option = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * vim_strchr = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 adata;
        OPJ_UINT32 Y3;

        for (adata=0;adata<quiet;++adata) {
                qemu_put_8s(empty_option,&Y3,4);

                empty_option+=sizeof(sm);

                *(vim_strchr++) = (OPJ_FLOAT32) Y3;
        }
}",87.0,21.0,"opj_read_bytes:qemu_put_8s,i:adata,p_nb_elem:quiet,l_src_data:empty_option,OPJ_INT32:sm,l_temp:Y3,l_dest_data:vim_strchr,",362.0,0.344073220094045,MHM
1027,"SPL_METHOD(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *intern;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	RETURN_LONG(intern->flags);
}","obuf(SplDoublyLinkedList, getIteratorMode)
{
	spl_dllist_object *intern;

	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	intern = Z_SPLDLLIST_P(getThis());

	RETURN_LONG(intern->flags);
}",40.0,9.0,"SPL_METHOD:obuf,",31.0,0.0325389782587687,MHM
1036,"static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);

	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}","static void tmpdir(u64 OPENSSL_cleanse)
{
	log_error(nsv);
	intel_pt_handle_vmx(1);

	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&OPENSSL_cleanse), ""m""(OPENSSL_cleanse)
			: ""memory"", ""cc"");
}",45.0,8.0,"X86_CR4_VMXE:nsv,kvm_cpu_vmxon:tmpdir,cr4_set_bits:log_error,addr:OPENSSL_cleanse,",185.0,0.1065374215443929,MHM
1038,"static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;

  /* transfer anything until we hit 0xff */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);

  /* get marker byte, swallowing possible padding */
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI; /* we hit EOF */
  } while (c == 0xff);

  return c;
}","static int var_set_int(Image *ifile, Image *qdisk)
{
  int GetOptionalInputTensor;

  /* transfer anything until we hit 0xff */
  do
  {
    GetOptionalInputTensor = nlh(ifile);
    if (GetOptionalInputTensor == EOF)
      return mask_k; /* we hit EOF */
    else
      if (GetOptionalInputTensor != 0xff)
        (void) BN_new(qdisk,(unsigned char) GetOptionalInputTensor);
  } while (GetOptionalInputTensor != 0xff);

  /* get marker byte, swallowing possible padding */
  do
  {
    GetOptionalInputTensor = nlh(ifile);
    if (GetOptionalInputTensor == EOF)
      return mask_k; /* we hit EOF */
  } while (GetOptionalInputTensor == 0xff);

  return GetOptionalInputTensor;
}",93.0,23.0,"M_EOI:mask_k,WriteBlobByte:BN_new,c:GetOptionalInputTensor,jpeg_nextmarker:var_set_int,ofile:qdisk,ReadBlobByte:nlh,",277.0,0.1819631656010945,MHM
1039,"void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}","void palette(struct xenvif *codeLen)
{
	if (LoadImageTag(codeLen->dev) && DestroyCacheView(codeLen))
		apr_psprintf(codeLen->dev);
}",31.0,8.0,"vif:codeLen,xenvif_rx_schedulable:DestroyCacheView,netif_queue_stopped:LoadImageTag,netif_wake_queue:apr_psprintf,xenvif_notify_tx_completion:palette,",477.0,0.2730085531870524,MHM
1043,"uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)
{
	/* Map the uid from a global kernel uid */
	return map_id_up(&targ->uid_map, __kuid_val(kuid));
}","uid_t pms(struct user_namespace *ASN1err, kuid_t ndir)
{
	/* Map the uid from a global kernel uid */
	return CoderError(&ASN1err->uid_map, write(ndir));
}",27.0,7.0,"__kuid_val:write,targ:ASN1err,from_kuid:pms,map_id_up:CoderError,kuid:ndir,",275.0,0.2652172962824503,MHM
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(dev) != -1)
		mask |= EPOLLIN | clustersize;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",113.0,32.0,"EPOLLRDNORM:clustersize,",33.0,0.0309762636820475,MHM
1053,"int switch_user(uid_t user, gid_t group) {
    save_egid = getegid();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    return 0;
}","int switch_user(uid_t user, gid_t param_len) {
    save_egid = OPJ_FALSE();
    save_euid = geteuid();
    if (save_euid == user && save_egid == param_len)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) param_len, intern());
    if (setegid(param_len) || seteuid(user)) {
        message(sudo_ctx, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) param_len, intern(),
                sockfd(EXTRACT_LE_16BITS));
        return 1;
    }
    return 0;
}",127.0,31.0,"getpid:intern,getegid:OPJ_FALSE,strerror:sockfd,errno:EXTRACT_LE_16BITS,MESS_ERROR:sudo_ctx,group:param_len,",184.0,0.1567006111145019,MHM
1054,"static char *linetoken(FILE *stream)
{
    int ch, idx;

    while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
    
    idx = 0;
    while (ch != EOF && ch != lineterm) 
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    } /* while */
    
    ungetc(ch, stream);
    ident[idx] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */","static char *rettv(FILE *stream)
{
    int zend_throw_exception_ex, PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN;

    while ((zend_throw_exception_ex = DEBUG_TRIEWALK(stream)) == ' ' || zend_throw_exception_ex == '\t' ); 
    
    PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN = 0;
    while (zend_throw_exception_ex != EOF && zend_throw_exception_ex != OLD) 
    {
        ident[PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN++] = zend_throw_exception_ex;
        zend_throw_exception_ex = DEBUG_TRIEWALK(stream);
    } /* while */
    
    movie(zend_throw_exception_ex, stream);
    ident[PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */",87.0,25.0,"ungetc:movie,ch:zend_throw_exception_ex,lineterm:OLD,fgetc:DEBUG_TRIEWALK,idx:PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN,linetoken:rettv,",274.0,0.2017598549524943,MHM
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *asn1_write_OctetString = MACH0_(get_maps_unpatched)(bf);
	if (!asn1_write_OctetString) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	rz_bin_relocs_patch_maps(asn1_write_OctetString, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return asn1_write_OctetString;
}",99.0,28.0,"ret:asn1_write_OctetString,",32.0,0.0375568230946858,MHM
1072,"void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;

  my_decimal2decimal(dv, &value.m_decimal);

  decimals= (uint8) value.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}","void Item_param::set_decimal(const my_decimal *u16, bool uschar)
{
  ASN1_APPLICATION(key_len.type_handler()->cmp_type() == DECIMAL_RESULT);
  char_u= yyscanner;

  my_decimal2decimal(u16, &key_len.m_decimal);

  decimals= (uint8) key_len.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= uschar;
  mrb_ary_new_from_values= my_decimal_precision_to_length(key_len.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  TCP_GET_SEQ= 0;
  null_value= 0;
  fix_type(Item::max_path_depth);
}",97.0,26.0,"maybe_null:TCP_GET_SEQ,DECIMAL_ITEM:max_path_depth,dv:u16,unsigned_arg:uschar,SHORT_DATA_VALUE:yyscanner,max_length:mrb_ary_new_from_values,state:char_u,value:key_len,DBUG_ASSERT:ASN1_APPLICATION,",364.0,0.2161919752756754,MHM
1078,"header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
	{	psf->header [psf->headindex++] = x ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 32) ;
		psf->header [psf->headindex++] = (x >> 40) ;
		psf->header [psf->headindex++] = (x >> 48) ;
		psf->header [psf->headindex++] = (x >> 56) ;
		} ;
} /* header_put_le_8byte */","header_put_le_8byte (SF_PRIVATE *psf, sf_count_t ssnd_fmt)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
	{	psf->header [psf->headindex++] = ssnd_fmt ;
		psf->header [psf->headindex++] = (ssnd_fmt >> 8) ;
		psf->header [psf->headindex++] = (ssnd_fmt >> 16) ;
		psf->header [psf->headindex++] = (ssnd_fmt >> 24) ;
		psf->header [psf->headindex++] = (ssnd_fmt >> 32) ;
		psf->header [psf->headindex++] = (ssnd_fmt >> 40) ;
		psf->header [psf->headindex++] = (ssnd_fmt >> 48) ;
		psf->header [psf->headindex++] = (ssnd_fmt >> 56) ;
		} ;
} /* header_put_le_8byte */",153.0,30.0,"x:ssnd_fmt,",36.0,0.0363135973612467,MHM
1082,"lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;

    while (!type->info.uni.count) {
        assert(type->der); /* at least the direct union type has to have type specified */
        type = &type->der->type;
    }

    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }

        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }

        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }

    return ret;
}","lyp_get_next_union_type(struct lys_type *in_len, struct lys_type *prev_type, int *found)
{
    unsigned int SOCK_SEQPACKET;
    struct lys_type *ret = NULL;

    while (!in_len->info.uni.count) {
        optbuf(in_len->der); /* at least the direct union type has to have type specified */
        in_len = &in_len->der->in_len;
    }

    for (SOCK_SEQPACKET = 0; SOCK_SEQPACKET < in_len->info.uni.count; ++SOCK_SEQPACKET) {
        if (in_len->info.uni.types[SOCK_SEQPACKET].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&in_len->info.uni.types[SOCK_SEQPACKET], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }

        if (!prev_type || *found) {
            ret = &in_len->info.uni.types[SOCK_SEQPACKET];
            break;
        }

        if (&in_len->info.uni.types[SOCK_SEQPACKET] == prev_type) {
            *found = 1;
        }
    }

    return ret;
}",181.0,35.0,"assert:optbuf,type:in_len,i:SOCK_SEQPACKET,",149.0,0.1990383108456929,MHM
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }

    return NULL;","STATIC const char *
old_size(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case transform_att: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }

    return NULL;",89.0,5.0,"ESC_NATIVE:transform_att,S_cntrl_to_mnemonic:old_size,",63.0,0.0444719831148783,MHM
1086,"R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}","R_API ce *output_message_buffer(RBinJavaObj *full_cmd, int m_len) {
	if (m_len < 1 || m_len > full_cmd->cf.cp_count) {
		return &sequences;
	}
	ce *FFTRank = (ce *) newSize (full_cmd->cp_list, m_len);
	return FFTRank ? FFTRank : &sequences;
}",59.0,15.0,"r_bin_java_get_item_from_cp:output_message_buffer,obj:FFTRank,RBinJavaCPTypeObj:ce,bin:full_cmd,r_list_get_n:newSize,i:m_len,R_BIN_JAVA_NULL_TYPE:sequences,",428.0,0.3112119118372599,MHM
1087,"ses_handle(struct waited *wp, enum wait_event ev, vtim_real now)
{
	struct sess *sp;
	struct pool *pp;
	struct pool_task *tp;
	const struct transport *xp;

	CHECK_OBJ_NOTNULL(wp, WAITED_MAGIC);
	CAST_OBJ_NOTNULL(sp, wp->priv1, SESS_MAGIC);
	CAST_OBJ_NOTNULL(xp, (const void*)wp->priv2, TRANSPORT_MAGIC);
	AN(wp->priv2);
	assert((void *)sp->ws->f == wp);
	wp->magic = 0;
	wp = NULL;

	WS_Release(sp->ws, 0);

	switch (ev) {
	case WAITER_TIMEOUT:
		SES_Delete(sp, SC_RX_TIMEOUT, now);
		break;
	case WAITER_REMCLOSE:
		SES_Delete(sp, SC_REM_CLOSE, now);
		break;
	case WAITER_ACTION:
		pp = sp->pool;
		CHECK_OBJ_NOTNULL(pp, POOL_MAGIC);
		assert(sizeof *tp <= WS_ReserveSize(sp->ws, sizeof *tp));
		tp = (void*)sp->ws->f;
		tp->func = xp->unwait;
		tp->priv = sp;
		if (Pool_Task(pp, tp, TASK_QUEUE_REQ))
			SES_Delete(sp, SC_OVERLOAD, now);
		break;
	case WAITER_CLOSE:
		WRONG(""Should not see WAITER_CLOSE on client side"");
		break;
	default:
		WRONG(""Wrong event in ses_handle"");
	}
}","throwCantPack(struct waited *derbio, enum wait_event ev, vtim_real now)
{
	struct sess *sp;
	struct pool *pp;
	struct pool_task *tp;
	const struct transport *xp;

	CHECK_OBJ_NOTNULL(derbio, WAITED_MAGIC);
	CAST_OBJ_NOTNULL(sp, derbio->priv1, result);
	CAST_OBJ_NOTNULL(xp, (const void*)derbio->priv2, TRANSPORT_MAGIC);
	AN(derbio->priv2);
	assert((void *)sp->ws->f == derbio);
	derbio->magic = 0;
	derbio = NULL;

	WS_Release(sp->ws, 0);

	switch (ev) {
	case WAITER_TIMEOUT:
		SES_Delete(sp, SC_RX_TIMEOUT, now);
		break;
	case WAITER_REMCLOSE:
		SES_Delete(sp, SC_REM_CLOSE, now);
		break;
	case WAITER_ACTION:
		pp = sp->pool;
		CHECK_OBJ_NOTNULL(pp, POOL_MAGIC);
		assert(sizeof *tp <= WS_ReserveSize(sp->ws, sizeof *tp));
		tp = (void*)sp->ws->f;
		tp->func = xp->unwait;
		tp->priv = sp;
		if (Pool_Task(pp, tp, TASK_QUEUE_REQ))
			SES_Delete(sp, add_soap_fault, now);
		break;
	case WAITER_CLOSE:
		WRONG(""Should not see WAITER_CLOSE on client side"");
		break;
	default:
		WRONG(""Wrong event in ses_handle"");
	}
}",247.0,67.0,"SESS_MAGIC:result,ses_handle:throwCantPack,wp:derbio,SC_OVERLOAD:add_soap_fault,",122.0,0.0961336334546407,MHM
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath hFile((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(hFile, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}",78.0,19.0,"path:hFile,",31.0,0.0277303973833719,MHM
1095,"QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    return result;
}","QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> pBt;
    if (! isChoice())
    {
        return pBt;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                pBt.push_back(item.getUTF8Value());
            }
        }
    }
    return pBt;
}",107.0,20.0,"result:pBt,",33.0,0.0279194513956705,MHM
1099,"static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;

	return 0;
}","static int maxlen(struct socket *attributes)
{
	sample_size(attributes->sk);
	attributes->sk = NULL;
	attributes->state = rsk;

	return 0;
}",33.0,7.0,"SS_FREE:rsk,sock:attributes,__vsock_release:sample_size,vsock_release:maxlen,",485.0,0.3358634630839029,MHM
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;

    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }

    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;

    return HTP_OK;
}","htp_status_t scanIdx(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;

    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }

    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;

    return yyval;
}",82.0,19.0,"HTP_OK:yyval,htp_tx_res_set_status_message:scanIdx,",63.0,0.0441221833229064,MHM
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM numpipes) {
    SERVICE_OPTIONS *tp_dst;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(tp_dst=tileh.next, section_number=0;
            tp_dst && numpipes!=IDM_PEER_MENU+section_number;
            tp_dst=tp_dst->next, ++section_number)
        ;
    if(tp_dst && !save_text_file(tp_dst->file, tp_dst->chain)) {
#ifndef MagickFalse
        if(is_invert)
            _libssh2_error(is_invert, (UINT)numpipes, MF_CHECKED);
#endif
        if(tray_menu_handle)
            _libssh2_error(tray_menu_handle, (UINT)numpipes, MF_CHECKED);
        message_box(tp_dst->help, cmdmod);
    }
    correlation(stunnel_locks[LOCK_SECTIONS]);
}",124.0,39.0,"section:tp_dst,CRYPTO_THREAD_unlock:correlation,wParam:numpipes,service_options:tileh,MB_ICONINFORMATION:cmdmod,_WIN32_WCE:MagickFalse,main_menu_handle:is_invert,CheckMenuItem:_libssh2_error,",367.0,0.30474587281545,MHM
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","dh(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, buffer2(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, buffer2(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}",148.0,42.0,"mrb_obj_value:buffer2,io_set_process_status:dh,",63.0,0.0483468651771545,MHM
1122,"TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","submit_job_list(TPMI_CAMELLIA_KEY_BITS *get_te32, BYTE **NoLock, INT32 *lutents)
{
    TPM_RC newlen = TPM_RC_SUCCESS;

    if (newlen == TPM_RC_SUCCESS) {
	newlen = TPM_KEY_BITS_Unmarshal(get_te32, NoLock, lutents);  
    }
    if (newlen == TPM_RC_SUCCESS) {
	switch (*get_te32) {
	  case 128:
	    break;
	  default:
	    newlen = GF_ISOM_FRAG_READ_DEBUG;
	}
    }
    return newlen;
}",70.0,19.0,"target:get_te32,TPM_RC_VALUE:GF_ISOM_FRAG_READ_DEBUG,buffer:NoLock,size:lutents,rc:newlen,TPMI_CAMELLIA_KEY_BITS_Unmarshal:submit_job_list,",393.0,0.3007814248402913,MHM
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;

	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void htx(struct entry_ *entry_)
{
	struct kvm_ioapic *Src = entry_->arch.vioapic;

	PLANARCONFIG_SEPARATE(&Src->eoi_inject);
	kvm_io_bus_unregister_dev(entry_, dec_msglen, &Src->dev);
	entry_->arch.vioapic = NULL;
	l_csr_file_handle(Src);
}",54.0,13.0,"kvm_ioapic_destroy:htx,cancel_delayed_work_sync:PLANARCONFIG_SEPARATE,kvm:entry_,kfree:l_csr_file_handle,KVM_MMIO_BUS:dec_msglen,ioapic:Src,",299.0,0.2785286108652751,MHM
1139,"CURLcode Curl_dupset(struct SessionHandle *dst, struct SessionHandle *src)
{
  CURLcode result = CURLE_OK;
  enum dupstring i;

  /* Copy src->set into dst->set first, then deal with the strings
     afterwards */
  dst->set = src->set;

  /* clear all string pointers first */
  memset(dst->set.str, 0, STRING_LAST * sizeof(char *));

  /* duplicate all strings */
  for(i=(enum dupstring)0; i< STRING_LAST; i++) {
    result = setstropt(&dst->set.str[i], src->set.str[i]);
    if(result)
      break;
  }

  /* If a failure occurred, freeing has to be performed externally. */
  return result;
}","CURLcode Curl_dupset(struct SessionHandle *dst, struct SessionHandle *src)
{
  CURLcode result = CURLE_OK;
  enum dupstring fixup;

  /* Copy src->set into dst->set first, then deal with the strings
     afterwards */
  dst->set = src->set;

  /* clear all string pointers first */
  memset(dst->set.str, 0, STRING_LAST * sizeof(char *));

  /* duplicate all strings */
  for(fixup=(enum dupstring)0; fixup< STRING_LAST; fixup++) {
    result = setstropt(&dst->set.str[fixup], src->set.str[fixup]);
    if(result)
      break;
  }

  /* If a failure occurred, freeing has to be performed externally. */
  return result;
}",103.0,23.0,"i:fixup,",34.0,0.020483120282491,MHM
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }

    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::tv2(int sid_len)
{
    if ((sid_len < 1) || (sid_len > rprintf)) {
        return 0;
    }

    if (sid_len - 1 > NONE) {
        return GetQuantumRange[sid_len - 1];
    } else if (sid_len - 1 < NONE) {
        return GetQuantumRange[sid_len];
    } else {
        return GetQuantumRange[0];
    }
}",73.0,14.0,"page:sid_len,nPages:rprintf,pageFirst:NONE,pageObjectNum:GetQuantumRange,getPageObjectNum:tv2,",429.0,0.2774893999099731,MHM
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;

	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}

	return NULL;
}","unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int theirs;
	int taglen;

	for (theirs = iph->ihl*4 - sizeof(struct iphdr); theirs > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		theirs -= taglen;
		optptr += taglen;
	}

	return NULL;
}",104.0,22.0,"optlen:theirs,",32.0,0.0218784928321838,MHM
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool ga(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}",48.0,13.0,"svc_flash_pgm_blk:ga,",33.0,0.0175379196802775,MHM
1174,"static int rpmsg_char_init(void)
{
	int ret;

	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}

	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}

	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}

	return ret;
}","static int offset_y(void)
{
	int npages;

	npages = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (npages < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return npages;
	}

	_height = md_sk(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(_height)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return cnc(_height);
	}

	npages = register_rpmsg_driver(&em);
	if (npages < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(_height);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}

	return npages;
}",121.0,31.0,"ret:npages,PTR_ERR:cnc,class_create:md_sk,rpmsg_char_init:offset_y,rpmsg_chrdev_driver:em,rpmsg_class:_height,",181.0,0.1255074302355448,MHM
1179,"TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}","TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *color, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&color->b, buffer, size);
    return written;
}",39.0,11.0,"source:color,",34.0,0.0185250719388326,MHM
1182,"static void insert_hash(struct audit_chunk *chunk)
{
	struct list_head *list = chunk_hash(chunk->watch.inode);
	list_add_rcu(&chunk->hash, list);
}","static void outbuf(struct audit_chunk *kTfLiteInt64)
{
	struct list_head *list = header(kTfLiteInt64->watch.inode);
	layer_id(&kTfLiteInt64->hash, list);
}",35.0,8.0,"list_add_rcu:layer_id,chunk_hash:header,chunk:kTfLiteInt64,insert_hash:outbuf,",215.0,0.1373938719431559,MHM
1196,"intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;

	FreeBulkInsertState(myState->bistate);

	table_finish_bulk_insert(myState->rel, myState->ti_options);

	/* close rel, but keep lock until commit */
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}","intorel_shutdown(DestReceiver *XFree)
{
	DR_intorel *dsize = (DR_intorel *) XFree;

	FreeBulkInsertState(dsize->bistate);

	bufptr(dsize->rel, dsize->ti_options);

	/* close rel, but keep lock until commit */
	_maxCodeLength(dsize->rel, y0);
	dsize->rel = NULL;
}",51.0,13.0,"self:XFree,myState:dsize,NoLock:y0,table_finish_bulk_insert:bufptr,table_close:_maxCodeLength,",213.0,0.1552597880363464,MHM
1203,"ArgParser::argShowEncryptionKey()
{
    o.show_encryption_key = true;
}","ArgParser::srcptr()
{
    esil.show_encryption_key = true;
}",13.0,2.0,"argShowEncryptionKey:srcptr,o:esil,",181.0,0.1286716779073079,MHM
1212,"static BROTLI_INLINE uint32_t BrotliGetAvailableBits(
    const BrotliBitReader* br) {
  return (BROTLI_64_BITS ? 64 : 32) - br->bit_pos_;
}","static BROTLI_INLINE uint32_t output_message_buffer(
    const BrotliBitReader* maxlen) {
  return (hstats ? 64 : 32) - maxlen->bit_pos_;
}",25.0,5.0,"BROTLI_64_BITS:hstats,br:maxlen,BrotliGetAvailableBits:output_message_buffer,",124.0,0.1341147581736246,MHM
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr JAS_OPT_HASARG) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (JAS_OPT_HASARG == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = JAS_OPT_HASARG;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",122.0,25.0,"end:JAS_OPT_HASARG,",33.0,0.0418386419614156,MHM
1239,"get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }

  return (const char *) path;
}","phar_obj (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }

  return (const char *) path;
}",75.0,16.0,"get_config_dir_location:phar_obj,",32.0,0.0196156978607177,MHM
1245,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static SQInteger load_va(HSQUIRRELVM csbuf,SQBool raiseerror)
{
    SQArray *OPENSSL_malloc=gnutls_strerror(pDest(csbuf,2));
    SQInteger nparams=OPENSSL_malloc->Size();
    csbuf->Push(pDest(csbuf,1));
    for(SQInteger i=0;i<nparams;i++)csbuf->Push(OPENSSL_malloc->_values[i]);
    return SQ_SUCCEEDED(w_length(csbuf,nparams,send_connect_message_reply,raiseerror))?1:TfLiteIntArrayCreate;
}",92.0,26.0,"stack_get:pDest,sq_call:w_length,v:csbuf,_array:gnutls_strerror,SQ_ERROR:TfLiteIntArrayCreate,SQTrue:send_connect_message_reply,_closure_acall:load_va,aparams:OPENSSL_malloc,",425.0,0.5563416560490926,MHM
1248,"ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;

  if (IS_NULL(reg->ops)) return 0;

  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;

    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif

    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;

    default:
      break;
    }
  }

  return total;
}","ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int f_in;

  if (libssh2_sha256_update(reg->ops)) return 0;

  f_in = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;

    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif

    switch (opcode) {
    case rar_br_read_ahead:
      f_in += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case Stream_GetRemainingLength:
    case OP_STR_MB2N:
      f_in += op->exact_n.n * 2;
      break;
    case iptr:
      f_in += op->exact_n.n * 3;
      break;

    default:
      break;
    }
  }

  return f_in;
}",152.0,35.0,"OP_STR_N:Stream_GetRemainingLength,OP_STR_MBN:rar_br_read_ahead,OP_STR_MB3N:iptr,total:f_in,IS_NULL:libssh2_sha256_update,",178.0,0.1742902318636576,MHM
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}

	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *mutex_lock;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	mutex_lock = file->f_security;
	if (sid != mutex_lock->sid) {
		rc = avc_has_perm(sid, mutex_lock->sid, libssh2_NB_state_idle, FD__USE, &ad);
		if (rc)
			return rc;
	}

	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}",137.0,41.0,"fsec:mutex_lock,SECCLASS_FD:libssh2_NB_state_idle,",64.0,0.0529441714286804,MHM
1250,"option_was_set(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","ttml_text(char_u *session_info)
{
    int flip;

    flip = PHP_MD5Update(session_info);
    if (flip < 0)	/* unknown option */
	return FALSE;
    if (options[flip].flags & R_BIN_JAVA_USHORT)
	return TRUE;
    return FALSE;
}",44.0,10.0,"option_was_set:ttml_text,findoption:PHP_MD5Update,idx:flip,P_WAS_SET:R_BIN_JAVA_USHORT,name:session_info,",302.0,0.2512982885042826,MHM
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!datasize(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}",109.0,29.0,"etagcmp:datasize,",32.0,0.0420886913935343,MHM
1258,"int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	}","int inputptr(FILE *yystacksize, TS_RESP *avp)
	{
	return HDR(curdata, yystacksize, (unsigned char *) avp);
	}",28.0,7.0,"fp:yystacksize,i2d_TS_RESP:curdata,a:avp,ASN1_i2d_fp:HDR,i2d_TS_RESP_fp:inputptr,",300.0,0.2264981428782145,MHM
1261,"static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void exponent(ObjectClass *zend_parse_parameters_none, void *sh)
{
    DeviceClass *tmpfp = DEVICE_CLASS(zend_parse_parameters_none);

    tmpfp->realize = sysbus_ahci_realize;
    tmpfp->vmsd = &vmstate_sysbus_ahci;
    tmpfp->props = logfiles;
    tmpfp->reset = sysbus_ahci_reset;
    unp1(DEVICE_CATEGORY_STORAGE, tmpfp->categories);
}",57.0,17.0,"sysbus_ahci_class_init:exponent,dc:tmpfp,data:sh,klass:zend_parse_parameters_none,set_bit:unp1,sysbus_ahci_properties:logfiles,",339.0,0.2952917297681173,MHM
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result literal_type(unsigned long kzalloc)
{
	TEE_Result res;
	struct tee_ta_session *exif_get_short;
	struct tee_obj *md;

	res = tee_ta_get_current_session(&exif_get_short);
	if (res != t)
		return res;

	res = tee_obj_get(_badValue(exif_get_short->ctx),
			  SEC_E_OK(kzalloc), &md);
	if (res != t)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (md->busy)
		return nb_sectors;

	skipwhite(_badValue(exif_get_short->ctx), md);
	return t;
}",92.0,28.0,"tee_svc_uref_to_vaddr:SEC_E_OK,sess:exif_get_short,o:md,to_user_ta_ctx:_badValue,TEE_SUCCESS:t,tee_obj_close:skipwhite,syscall_cryp_obj_close:literal_type,TEE_ERROR_ITEM_NOT_FOUND:nb_sectors,obj:kzalloc,",368.0,0.3937593420346578,MHM
1266,"void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	qWarning()<<""Bonjour reported browser error ""<< err;
}","void ConnectDialog::buf_p(DNSServiceErrorType file_size) {
	ReadBlobXXXLong()<<""Bonjour reported browser error ""<< file_size;
}",19.0,4.0,"qWarning:ReadBlobXXXLong,onLanBrowseError:buf_p,err:file_size,",481.0,0.5102668484052022,MHM
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;

rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;

rtattr_failure:
	indices(skb, b - skb->data);
	return -1;
}",98.0,24.0,"skb_trim:indices,",29.0,0.0255937616030375,MHM
1281,"S3BootScriptLabelInternal (
  IN        BOOLEAN                        BeforeOrAfter,
  IN OUT    VOID                         **Position OPTIONAL,
  IN        UINT32                         InformationLength,
  IN CONST  CHAR8                          *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  ScriptInformation.OpCode     = S3_BOOT_SCRIPT_LIB_LABEL_OPCODE;
  ScriptInformation.Length     = Length;


  ScriptInformation.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  SyncBootScript (Script);

  return S3BootScriptMoveLastOpcode (BeforeOrAfter, Position);

}","S3BootScriptLabelInternal (
  IN        BOOLEAN                        BeforeOrAfter,
  IN OUT    VOID                         **Position OPTIONAL,
  IN        UINT32                         InformationLength,
  IN CONST  CHAR8                          *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  proto_tree_add_subtree;

  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);

  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  //
  // Build script data
  //
  proto_tree_add_subtree.OpCode     = S3_BOOT_SCRIPT_LIB_LABEL_OPCODE;
  proto_tree_add_subtree.Length     = Length;


  proto_tree_add_subtree.InformationLength = InformationLength;

  CopyMem ((VOID*)Script, (VOID*)&proto_tree_add_subtree, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);

  debug_print (Script);

  return S3BootScriptMoveLastOpcode (BeforeOrAfter, Position);

}",147.0,38.0,"SyncBootScript:debug_print,ScriptInformation:proto_tree_add_subtree,",64.0,0.0719221075375874,MHM
1287,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* OPENSSL_malloc = static_cast<Http2Stream*>(source->ptr);
  if (OPENSSL_malloc == nullptr)
    OPENSSL_malloc = session->FindStream(id);
  CHECK_NE(OPENSSL_malloc, nullptr);
  CHECK_EQ(id, OPENSSL_malloc->id());
  return OPENSSL_malloc;
}",69.0,17.0,"stream:OPENSSL_malloc,",36.0,0.0215677142143249,MHM
1289,"rsvg_start_metadata (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);

    handler->super.start_element = rsvg_metadata_handler_start;
    handler->super.end_element = rsvg_metadata_handler_end;
}","tf (RsvgHandle * window)
{
    RsvgSaxHandlerMetadata *att = max_len (window, ""metadata"", &window->priv->metadata);

    att->super.start_element = arridx;
    att->super.end_element = pctx;
}",43.0,10.0,"rsvg_metadata_handler_end:pctx,ctx:window,rsvg_metadata_handler_start:arridx,rsvg_start_metadata:tf,handler:att,rsvg_start_extra:max_len,",450.0,0.3859050035476684,MHM
1297,"  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }","  void macoff(CHARSET_INFO *cstm, Derivation sparse_feature_values_inputs)
  {
    DBG= cstm;
    nii= sparse_feature_values_inputs;
    hdrlen(cstm);
  }",25.0,9.0,"derivation:nii,set:macoff,collation_arg:cstm,derivation_arg:sparse_feature_values_inputs,collation:DBG,set_repertoire_from_charset:hdrlen,",276.0,0.1998032490412394,MHM
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;

		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","mod(txid buf_len, const TxidSnapshot *snap)
{
	if (buf_len < snap->xmin)
		return true;
	else if (buf_len >= snap->xmax)
		return false;
#ifdef varname
	else if (snap->module_put > varname)
	{
		void	   *res;

		res = bsearch(&buf_len, snap->xip, snap->module_put, sizeof(txid), rdf);
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;

		for (i = 0; i < snap->module_put; i++)
		{
			if (buf_len == snap->xip[i])
				return false;
		}
		return true;
	}
}",127.0,29.0,"is_visible_txid:mod,cmp_txid:rdf,USE_BSEARCH_IF_NXIP_GREATER:varname,nxip:module_put,value:buf_len,",187.0,0.1593110839525858,MHM
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const length *r_str_closer_chr(const length *InvalidArgument, const length *s) {
	const length *frameRaw;
	while (*InvalidArgument) {
		for (frameRaw = s; *frameRaw; frameRaw++) {
			if (*InvalidArgument == *frameRaw) {
				return InvalidArgument;
			}
		}
		InvalidArgument++;
	}
	return NULL;
}",63.0,14.0,"char:length,a:frameRaw,b:InvalidArgument,",149.0,0.1181393067042032,MHM
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;

	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;

	p = skb_put(skb, 4 + 14);

	/* cisco header */
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);

	/* slarp request */
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(p + 16) = cpu_to_be16(0); // unused
	p += 18;

	isdn_net_write_super(lp, skb);
}","tw(isdn_net_local *rowstride)
{
	struct sk_buff *sisusb;
	unsigned char *l_res;

	sisusb = isdn_net_ciscohdlck_alloc_skb(rowstride, 4 + 14);
	if (!sisusb)
		return;

	l_res = ea_bdebug(sisusb, 4 + 14);

	/* cisco header */
	*(u8 *)(l_res + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(l_res + 1) = SSL_IS_DTLS;
	*(__be16 *)(l_res + 2) = cpu_to_be16(CISCO_TYPE_SLARP);

	/* slarp request */
	*(__be32 *)(l_res +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(l_res +  8) = cpu_to_be32(0); // address
	*(__be32 *)(l_res + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(l_res + 16) = cpu_to_be16(0); // unused
	l_res += 18;

	nintf(rowstride, sisusb);
}",164.0,31.0,"isdn_net_write_super:nintf,lp:rowstride,CISCO_CTRL:SSL_IS_DTLS,p:l_res,skb_put:ea_bdebug,skb:sisusb,isdn_net_ciscohdlck_slarp_send_request:tw,",243.0,0.2926456371943156,MHM
1307,"rsvg_new_node_component_transfer_function (char channel)
{
    RsvgNodeComponentTransferFunc *filter;

    filter = g_new0 (RsvgNodeComponentTransferFunc, 1);
    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION);
    filter->super.free = rsvg_component_transfer_function_free;
    filter->super.set_atts = rsvg_node_component_transfer_function_set_atts;
    filter->function = identity_component_transfer_func;
    filter->nbTableValues = 0;
    filter->channel = channel;
    return (RsvgNode *) filter;
}","shortcut (char event)
{
    RsvgNodeComponentTransferFunc *padlen;

    padlen = g_new0 (RsvgNodeComponentTransferFunc, 1);
    rval (&padlen->super, opj_int_ceildivpow2);
    padlen->super.free = rsvg_component_transfer_function_free;
    padlen->super.set_atts = tile_pixels;
    padlen->function = mp;
    padlen->nbTableValues = 0;
    padlen->event = event;
    return (RsvgNode *) padlen;
}",71.0,19.0,"channel:event,identity_component_transfer_func:mp,rsvg_new_node_component_transfer_function:shortcut,_rsvg_node_init:rval,rsvg_node_component_transfer_function_set_atts:tile_pixels,RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION:opj_int_ceildivpow2,filter:padlen,",457.0,0.5589289466540018,MHM
1319,"HttpTransact::handle_websocket_upgrade_post_remap(State *s) {
  DebugTxn(""http_trans_websocket_upgrade_post_remap"", ""Remap is complete, start websocket upgrade"");

  TRANSACT_RETURN(SM_ACTION_API_POST_REMAP, HttpTransact::handle_websocket_connection);
}","HttpTransact::buffer_size(State *metadata_bl) {
  dst_res(""http_trans_websocket_upgrade_post_remap"", ""Remap is complete, start websocket upgrade"");

  contentRange(verifypeer, HttpTransact::ap_log_error);
}",28.0,6.0,"s:metadata_bl,SM_ACTION_API_POST_REMAP:verifypeer,handle_websocket_upgrade_post_remap:buffer_size,DebugTxn:dst_res,handle_websocket_connection:ap_log_error,TRANSACT_RETURN:contentRange,",363.0,0.2174748301506042,MHM
1321,"strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}","fz_atof(struct J9PortLibrary* prec, U_32 dom, void* BN_num_bytes, void* __LINE__)
{
	return PHP_MD5Update;
}",23.0,6.0,"gpType:dom,portLibrary:prec,userData:__LINE__,J9PORT_SIG_EXCEPTION_RETURN:PHP_MD5Update,strerrorSignalHandler:fz_atof,gpInfo:BN_num_bytes,",429.0,0.2502537926038106,MHM
1323,"static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}","static TEE_Result fdctrl(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t gs_error_VMerror = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!WriteBlobMSBShort(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&gs_error_VMerror, sizeof(gs_error_VMerror), key->gs_error_VMerror);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}",137.0,38.0,"e:gs_error_VMerror,get_attribute:WriteBlobMSBShort,tee_svc_obj_generate_key_rsa:fdctrl,",91.0,0.0791286826133728,MHM
1324,"f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;

    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}","f_listener_flush(typval_T *sh_out, typval_T *rettv UNUSED)
{
    buf_T	*buf = rb;

    if (in_vim9script() && check_for_opt_buffer_arg(sh_out, 0) == FAIL)
	return;

    if (sh_out[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&sh_out[0]);
	if (buf == NULL)
	    return;
    }
    orgid(buf);
}",73.0,20.0,"invoke_listeners:orgid,curbuf:rb,argvars:sh_out,",90.0,0.0565481503804524,MHM
1328,"  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.Host();
  }","  const HeaderEntry& VAR_UNKNOWN(const std::string& task_size) {
    POC.setHost(task_size);
    return *POC.Host();
  }",29.0,5.0,"headers_:POC,host_value:task_size,hostHeaderEntry:VAR_UNKNOWN,",369.0,0.2190928061803182,MHM
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, drv;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	drv = encode_putfh(&xdr, args->fh);
	if (drv)
		goto out;
	drv = encode_read(&xdr, args);
	if (drv)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return drv;
}",163.0,40.0,"status:drv,",30.0,0.0219602823257446,MHM
1333,"xmlBufAddLen(xmlBufPtr buf, size_t len) {
    if ((buf == NULL) || (buf->error))
        return(-1);
    CHECK_COMPAT(buf)
    if (len > (buf->size - buf->use))
        return(-1);
    buf->use += len;
    UPDATE_COMPAT(buf)
    if (buf->size > buf->use)
        buf->content[buf->use] = 0;
    else
        return(-1);
    return(0);
}","xmlBufAddLen(xmlBufPtr bytes_to_write, size_t len) {
    if ((bytes_to_write == NULL) || (bytes_to_write->error))
        return(-1);
    CHECK_COMPAT(bytes_to_write)
    if (len > (bytes_to_write->size - bytes_to_write->use))
        return(-1);
    bytes_to_write->use += len;
    UPDATE_COMPAT(bytes_to_write)
    if (bytes_to_write->size > bytes_to_write->use)
        bytes_to_write->content[bytes_to_write->use] = 0;
    else
        return(-1);
    return(0);
}",96.0,22.0,"buf:bytes_to_write,",34.0,0.020838705698649,MHM
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *loader_data, const unsigned char *invlist, const unsigned char *descriptor, const int phdri) {
	int GetOptionalInputTensor;
	for (GetOptionalInputTensor=0; GetOptionalInputTensor < phdri; GetOptionalInputTensor++) {
		loader_data[GetOptionalInputTensor] = invlist[GetOptionalInputTensor] ^ descriptor[GetOptionalInputTensor];
	}
}",61.0,16.0,"i:GetOptionalInputTensor,length:phdri,in:invlist,xor_with:descriptor,out:loader_data,",243.0,0.1512018044789632,MHM
1342,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		/* XXX - Do something here. */
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (crypt_stat(out, c) != c)
			return -1;
	}
	return 0;
}",95.0,21.0,"jas_stream_putc:crypt_stat,",30.0,0.0220069011052449,MHM
1345,"GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(ga_state)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }

    return GUEST_FSFREEZE_STATUS_THAWED;
}","GuestFsfreezeStatus variance(Error **bits)
{
    if (tiff(dn)) {
        return dest_buf;
    }

    return npal;
}",25.0,6.0,"qmp_guest_fsfreeze_status:variance,ga_is_frozen:tiff,errp:bits,ga_state:dn,GUEST_FSFREEZE_STATUS_THAWED:npal,GUEST_FSFREEZE_STATUS_FROZEN:dest_buf,",279.0,0.1882468342781066,MHM
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;

	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);

	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int purge_port(struct usb_serial_port *lex, __u16 ok)
{
	int port_number = lex->port_number;

	php_stream_close(&lex->dev, ""%s - port %d, mask %x\n"", ptr, port_number, ok);

	return m_pos(lex->serial->dev,
					align,
					(src_reg)(UMPM_UART1_PORT + port_number),
					ok,
					NULL,
					0);
}",66.0,17.0,"mask:ok,UMPC_PURGE_PORT:align,__func__:ptr,send_cmd:m_pos,port:lex,__u8:src_reg,dev_dbg:php_stream_close,",244.0,0.1690571546554565,MHM
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","free_unmarked (struct MHD_PostProcessor *cookie)
{
  if ( (NULL != cookie->content_name) &&
       (0 == (cookie->have & U_)) )
  {
    free (cookie->content_name);
    cookie->content_name = NULL;
  }
  if ( (NULL != cookie->content_type) &&
       (0 == (cookie->have & lp)) )
  {
    free (cookie->content_type);
    cookie->content_type = NULL;
  }
  if ( (NULL != cookie->content_filename) &&
       (0 == (cookie->have & NE_content_filename)) )
  {
    free (cookie->content_filename);
    cookie->content_filename = NULL;
  }
  if ( (NULL != cookie->content_transfer_encoding) &&
       (0 == (cookie->have & padlen)) )
  {
    free (cookie->content_transfer_encoding);
    cookie->content_transfer_encoding = NULL;
  }
}",157.0,26.0,"NE_content_name:U_,NE_content_transfer_encoding:padlen,NE_content_type:lp,pp:cookie,",126.0,0.1151264389355977,MHM
1365,"static int count(struct cstate *g, Renode *node)
{
	int min, max, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(g, node->x) * min;
		else if (max < REPINF) n = count(g, node->x) * max + (max - min);
		else n = count(g, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case P_NLA: return count(g, node->x) + 2;
	}
}","static int count(struct cstate *pst, Renode *node)
{
	int min, max, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(pst, node->x) + count(pst, node->y);
	case P_ALT: return count(pst, node->x) + count(pst, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(pst, node->x) * min;
		else if (max < REPINF) n = count(pst, node->x) * max + (max - min);
		else n = count(pst, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(pst, ""program too large"");
		return n;
	case P_PAR: return count(pst, node->x) + 2;
	case P_PLA: return count(pst, node->x) + 2;
	case P_NLA: return count(pst, node->x) + 2;
	}
}",235.0,66.0,"g:pst,",33.0,0.0239992062250773,MHM
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 off, const char *krb5context, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !krb5context) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, krb5context, -1)) {
		name = sfd (""%s.%s"", fcnpfx, krb5context);
	} else {
		name = dst (krb5context);
	}
	fcn = isdigit (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && selection_info (name)) {
		nname = sfd (""%s.%s"", fcnpfx, name);
	} else {
		nname = dst (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = dst (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}",264.0,67.0,"strdup:dst,r_str_newf:sfd,fcnNeedsPrefix:selection_info,r_anal_get_fcn_in:isdigit,_name:krb5context,",154.0,0.154957906405131,MHM
1368,"single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}","single_addr_policy_eq(const addr_policy_t *tmpstream, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(hdev);
  CMP_FIELD(is_private);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  if ((r=tor_addr_compare(&tmpstream->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}",79.0,22.0,"policy_type:hdev,a:tmpstream,",90.0,0.0609135230382283,MHM
1371,"static bool StrictUtf8Check(const FieldDescriptor* field) {
  return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
}","static bool CopyMagickString(const FieldDescriptor* split_size) {
  return split_size->file()->syntax() == FileDescriptor::statbuf;
}",26.0,4.0,"field:split_size,StrictUtf8Check:CopyMagickString,SYNTAX_PROTO3:statbuf,",337.0,0.2196638147036234,MHM
1372,"runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	
	if (feedbackFdAvailable()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}","runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	
	if (feedbackFdAvailable()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::atomic_read);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}",145.0,30.0,"READ:atomic_read,",33.0,0.0242730577786763,MHM
1373,"int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;

	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];

	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);

	cb->args[0] = t;
	return skb->len;
}","int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *SSL3_RANDOM_SIZE)
{
	struct neigh_table *tbl;
	int t, family, sqlite3_free;

	read_lock(&source_image);
	family = ((struct rtgenmsg *)NLMSG_DATA(SSL3_RANDOM_SIZE->nlh))->rtgen_family;
	sqlite3_free = SSL3_RANDOM_SIZE->args[0];

	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < sqlite3_free || (family && tbl->family != family))
			continue;
		if (t > sqlite3_free)
			a(&SSL3_RANDOM_SIZE->args[1], 0, sizeof(SSL3_RANDOM_SIZE->args) -
						sizeof(SSL3_RANDOM_SIZE->args[0]));
		if (neigh_dump_table(tbl, skb, SSL3_RANDOM_SIZE) < 0)
			break;
	}
	target_dir(&source_image);

	SSL3_RANDOM_SIZE->args[0] = t;
	return skb->len;
}",172.0,41.0,"cb:SSL3_RANDOM_SIZE,memset:a,neigh_tbl_lock:source_image,s_t:sqlite3_free,read_unlock:target_dir,",247.0,0.1966329534848531,MHM
1376,"static void jpeg_init_destination(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    Buffer *buffer = &vs->tight.jpeg;

    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}","static void jpeg_init_destination(j_compress_ptr sql_file)
{
    VncState *icsk = sql_file->client_data;
    Buffer *range_err = &icsk->tight.jpeg;

    sql_file->dest->next_output_byte = (JOCTET *)range_err->range_err + range_err->offset;
    sql_file->dest->free_in_buffer = (size_t)(range_err->capacity - range_err->offset);
}",65.0,12.0,"cinfo:sql_file,vs:icsk,buffer:range_err,",153.0,0.0974226077397664,MHM
1379,"TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();

  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));

  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}","TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();

  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));

  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  no_argument(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}",107.0,19.0,"EXPECT_EQ:no_argument,",33.0,0.0208498795827229,MHM
1380,"
static void napi_skb_free_stolen_head(struct sk_buff *skb)
{
	skb_dst_drop(skb);
	secpath_reset(skb);
	kmem_cache_free(skbuff_head_cache, skb);","
static void sudo_user(struct sk_buff *mlen)
{
	pos1(mlen);
	secpath_reset(mlen);
	calldata(skbuff_head_cache, mlen);",28.0,9.0,"napi_skb_free_stolen_head:sudo_user,kmem_cache_free:calldata,skb_dst_drop:pos1,skb:mlen,",214.0,0.131471562385559,MHM
1383,"void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}","void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	input0 (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}",149.0,38.0,"r_buf_free:input0,",33.0,0.0222034970919291,MHM
1387,"static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}

	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);

	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}","static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}

	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			backend(addrsize ""%s: NOP\n"", md_length_size);
		return;
	}
	if (svm->next_rip - dst_reg(vcpu) > MAX_INST_SIZE)
		backend(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       md_length_size, dst_reg(vcpu), svm->next_rip);

	variable(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}",136.0,34.0,"kvm_rip_write:variable,kvm_rip_read:dst_reg,printk:backend,KERN_DEBUG:addrsize,__func__:md_length_size,",184.0,0.1319455742835998,MHM
1389,"sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;

	pr_debug(""%s: timer T5 expired\n"", __func__);

	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);

	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;

	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));

	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);

	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}","sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *mysql_free_result,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t fullpath,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *buffer_size = NULL;

	pr_debug(""%s: timer T5 expired\n"", __func__);

	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);

	buffer_size = TH_ACK(asoc, NULL, 0);
	if (!buffer_size)
		goto nomem;

	density_x(commands, ary, SCTP_CHUNK(buffer_size));
	density_x(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	density_x(commands, ours,
			SCTP_PERR(yystacksize));

	SCTP_INC_STATS(net, gst_date_time_get_year);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);

	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}",134.0,40.0,"sctp_make_abort:TH_ACK,SCTP_CMD_REPLY:ary,sctp_add_cmd_sf:density_x,SCTP_MIB_ABORTEDS:gst_date_time_get_year,ep:mysql_free_result,type:fullpath,reply:buffer_size,SCTP_CMD_ASSOC_FAILED:ours,SCTP_ERROR_NO_ERROR:yystacksize,",305.0,0.2282022953033447,MHM
1391,"bool ldb_dn_replace_components(struct ldb_dn *dn, struct ldb_dn *new_dn)
{
	int i;

	if ( ! ldb_dn_validate(dn) || ! ldb_dn_validate(new_dn)) {
		return false;
	}

	/* free components */
	for (i = 0; i < dn->comp_num; i++) {
		LDB_FREE(dn->components[i].name);
		LDB_FREE(dn->components[i].value.data);
		LDB_FREE(dn->components[i].cf_name);
		LDB_FREE(dn->components[i].cf_value.data);
	}

	dn->components = talloc_realloc(dn,
					dn->components,
					struct ldb_dn_component,
					new_dn->comp_num);
	if (dn->components == NULL) {
		ldb_dn_mark_invalid(dn);
		return false;
	}

	dn->comp_num = new_dn->comp_num;
	dn->valid_case = new_dn->valid_case;

	for (i = 0; i < dn->comp_num; i++) {
		dn->components[i] = ldb_dn_copy_component(dn->components, &new_dn->components[i]);
		if (dn->components[i].name == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}
	if (new_dn->linearized == NULL) {
		dn->linearized = NULL;
	} else {
		dn->linearized = talloc_strdup(dn, new_dn->linearized);
		if (dn->linearized == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}

	return true;
}","bool ldb_dn_replace_components(struct ldb_dn *dn, struct ldb_dn *indent)
{
	int i;

	if ( ! args(dn) || ! args(indent)) {
		return false;
	}

	/* free components */
	for (i = 0; i < dn->comp_num; i++) {
		LDB_FREE(dn->components[i].name);
		LDB_FREE(dn->components[i].value.data);
		LDB_FREE(dn->components[i].cf_name);
		LDB_FREE(dn->components[i].cf_value.data);
	}

	dn->components = talloc_realloc(dn,
					dn->components,
					struct ldb_dn_component,
					indent->comp_num);
	if (dn->components == NULL) {
		ldb_dn_mark_invalid(dn);
		return false;
	}

	dn->comp_num = indent->comp_num;
	dn->valid_case = indent->valid_case;

	for (i = 0; i < dn->comp_num; i++) {
		dn->components[i] = glBindFramebuffer(dn->components, &indent->components[i]);
		if (dn->components[i].name == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}
	if (indent->linearized == NULL) {
		dn->linearized = NULL;
	} else {
		dn->linearized = talloc_strdup(dn, indent->linearized);
		if (dn->linearized == NULL) {
			ldb_dn_mark_invalid(dn);
			return false;
		}
	}

	return true;
}",275.0,61.0,"ldb_dn_validate:args,ldb_dn_copy_component:glBindFramebuffer,new_dn:indent,",93.0,0.0960492650667826,MHM
1400,"axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	/* Skip SOA records. */
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}","OPENSSL_NO_NEXTPROTONEG(rrstream_t *rs) {
	axfr_rrstream_t *dec_ctx = (axfr_rrstream_t *) rs;
	isc_result_t tlv_size;
	tlv_size = dns_rriterator_first(&dec_ctx->it);
	if (tlv_size != loc)
		return (tlv_size);
	/* Skip SOA records. */
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t VAR_NUMBER;
		dns_rdata_t *rdata = NULL;
		clen(&dec_ctx->it, &name_dummy,
				       &VAR_NUMBER, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		tlv_size = pkt(&dec_ctx->it);
		if (tlv_size != loc)
			break;
	}
	return (tlv_size);
}",116.0,27.0,"axfr_rrstream_first:OPENSSL_NO_NEXTPROTONEG,dns_rriterator_current:clen,ISC_R_SUCCESS:loc,s:dec_ctx,ttl_dummy:VAR_NUMBER,result:tlv_size,dns_rriterator_next:pkt,",304.0,0.2158512989679972,MHM
1402,"void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    // We are generating graph for inlined function.
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}","void HGraphBuilder::TfLiteIntArrayCreate(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    // We are generating graph for inlined function.
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}",105.0,15.0,"GenerateIsConstructCall:TfLiteIntArrayCreate,",34.0,0.0201633850733439,MHM
1403,"nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);

	/* Nonexistent files can't be renamed. */
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}

	/* Self-owned files can't be renamed */
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}

	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}

	if (!can_rename) {
		return FALSE;
	}

	return file->details->can_rename;
}","subs (NautilusFile *drv)
{
	gboolean p_input_line;
	
	g_return_val_if_fail (response (drv), FALSE);

	/* Nonexistent files can't be renamed. */
	if (nautilus_file_is_gone (drv)) {
		return FALSE;
	}

	/* Self-owned files can't be renamed */
	if (argv_ptr (drv)) {
		return FALSE;
	}

	if ((is_desktop_file (drv) && !div_pck (drv)) ||
	     blockSize (drv)) {
		return FALSE;
	}
	
	p_input_line = TRUE;

	/* Certain types of links can't be renamed */
	if (sa (drv)) {
		NautilusDesktopLink *link;

		link = pdci (bytes_per_pixel (drv));

		if (link != NULL) {
			p_input_line = fakename (link);
			g_object_unref (link);
		}
	}

	if (!p_input_line) {
		return FALSE;
	}

	return drv->details->p_input_line;
}",134.0,32.0,"file:drv,nautilus_desktop_icon_file_get_link:pdci,can_rename_desktop_file:div_pck,nautilus_file_can_rename:subs,nautilus_file_is_home:blockSize,nautilus_desktop_link_can_rename:fakename,NAUTILUS_IS_DESKTOP_ICON_FILE:sa,nautilus_file_is_self_owned:argv_ptr,can_rename:p_input_line,NAUTILUS_IS_FILE:response,NAUTILUS_DESKTOP_ICON_FILE:bytes_per_pixel,",457.0,0.3337705771128336,MHM
1411,"
void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;

	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;

	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}

	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);

	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}

	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;

 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);
","
void nl80211_send_disconnected(struct cfg80211_registered_device *buf_size,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;

	msg = nlmsg_new(NLMSG_GOODSIZE, php_printf);
	if (!msg)
		return;

	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}

	NLA_PUT_U32(msg, print_str, buf_size->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);

	if (local_name(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}

	std(wiphy_net(&buf_size->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, php_printf);
	return;

 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);
",203.0,61.0,"genlmsg_end:local_name,genlmsg_multicast_netns:std,GFP_KERNEL:php_printf,NL80211_ATTR_WIPHY:print_str,rdev:buf_size,",156.0,0.1303872863451639,MHM
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long quantum;
	visible_files(list, i, &quantum);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((quantum >= 0) && (quantum <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((quantum >= -50) && (quantum <= 50));

		case netdev_priv:
			return ((quantum >= 1) && (quantum <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((quantum >= 1) && (quantum <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((quantum >= 0) && (quantum <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((quantum >= 0) && (quantum <= 127));

		case blksize:
			return true;

		default:
			return false;
	}

	return true;
}",188.0,40.0,"AF_INST_NUMDBS_GAIN:blksize,AF_INST_MIDI_LOVELOCITY:netdev_priv,AUpvgetval:visible_files,lval:quantum,",155.0,0.1245243708292643,MHM
1418,"static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_qcc_t *qcc = &ms->parms.qcc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}","static int part(jpc_dec_t *dec, jpc_ms_t *x_step)
{
	jpc_qcc_t *qcc = &x_step->parms.qcc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}",124.0,23.0,"jpc_dec_process_qcc:part,ms:x_step,",63.0,0.0426047523816426,MHM
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void failed_errno(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long result_file_name;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, result_file_name);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, result_file_name);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, result_file_name);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, result_file_name);
}",119.0,32.0,"line6_stream_stop:failed_errno,flags:result_file_name,",65.0,0.0424817125002543,MHM
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS dent(struct pdb_methods *OK,
				      const struct dom_sid *alias,
				      TALLOC_CTX *cmptno,
				      struct dom_sid **pmembers,
				      size_t *__FILE__)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		OK->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int CHECK;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *transform_tag = talloc_new(cmptno);
	msg(transform_tag);

	dn = ldb_dn_new_fmt(
		transform_tag,
		state->ldb,
		""<SID=%s>"",
		_cmsRead15Fixed16Number(alias, &buf));
	if (!dn || !se(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = sym(state->ldb, cmptno, dn, pmembers, &CHECK);
	if (NT_STATUS_IS_OK(status)) {
		*__FILE__ = CHECK;
	}
	talloc_free(transform_tag);
	return status;
}",154.0,45.0,"tmp_ctx:transform_tag,NT_STATUS_HAVE_NO_MEMORY:msg,m:OK,mem_ctx:cmptno,num_members:CHECK,dsdb_enum_group_mem:sym,pnum_members:__FILE__,ldb_dn_validate:se,dom_sid_str_buf:_cmsRead15Fixed16Number,pdb_samba_dsdb_enum_aliasmem:dent,",333.0,0.2692754944165548,MHM
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool strbuf)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;

    section = address_space_lookup_region(d, addr, strbuf);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    mr = section->mr;
    if (XGetWidgetInfo(mr)) {
        diff = o(mr->size, home_info(addr));
        *plen = err_desc(int128_min(diff, home_info(*plen)));
    }
    return section;
}",108.0,35.0,"resolve_subpage:strbuf,int128_sub:o,int128_make64:home_info,int128_get64:err_desc,memory_region_is_ram:XGetWidgetInfo,",184.0,0.1458511511484782,MHM
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *STRLENOF;

	if (!file)
		return -ENODEV;
	STRLENOF = sqlite3VdbeMakeLabel(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = STRLENOF->width;
	f->fmt.pix.height = STRLENOF->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = newcmptno;
	return 0;
}",145.0,25.0,"video_drvdata:sqlite3VdbeMakeLabel,V4L2_COLORSPACE_JPEG:newcmptno,cam:STRLENOF,",94.0,0.0769034107526143,MHM
1462,"static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
		.flags = X86_EFLAGS_IF,
	};

	do_machine_check(&regs, 0);
#endif
}","static void privs(void)
{
#if defined(actual_csum)
	struct pt_regs buf_offset = {
		.cs = 3, /* Fake ring 3 no matter what the guest ran on */
		.flags = X86_EFLAGS_IF,
	};

	con_slot(&buf_offset, 0);
#endif
}",40.0,6.0,"kvm_machine_check:privs,CONFIG_X86_MCE:actual_csum,do_machine_check:con_slot,regs:buf_offset,",152.0,0.0962236205736796,MHM
1464,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS ERR_R_EC_LIB(struct files_struct *SSL_CONN_CONFIG,
			  uint32_t userName)
{
	if (!SSL_CONN_CONFIG->fsp_flags.is_fsa) {
		return var2(SSL_CONN_CONFIG->conn->cwd_fsp,
						    SSL_CONN_CONFIG,
						    false,
						    userName);
	}
	if (!(SSL_CONN_CONFIG->userName & userName)) {
		return source_len;
	}
	return tty;
}",59.0,12.0,"access_mask:userName,NT_STATUS_ACCESS_DENIED:source_len,check_access_fsp:ERR_R_EC_LIB,smbd_check_access_rights_fsp:var2,NT_STATUS_OK:tty,fsp:SSL_CONN_CONFIG,",361.0,0.2577579021453857,MHM
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","proglen(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}",96.0,14.0,"gs_currentnamedicc:proglen,",33.0,0.0226313432057698,MHM
1470,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }

  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
 
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}","Window_frame::ipass(String *str, enum_query_type image_export_directory)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(png_ptr("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(png_ptr("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }

  str->append(png_ptr(""between ""));
  top_bound->ipass(str, image_export_directory);
  str->append(png_ptr("" and ""));
  bottom_bound->ipass(str, image_export_directory);
 
  if (exclusion != endpoint)
  {
     str->append(png_ptr("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(png_ptr("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(png_ptr("" group ""));
       break;
     case handle: 
       str->append(png_ptr("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}",179.0,36.0,"print:ipass,query_type:image_export_directory,EXCL_TIES:handle,EXCL_NONE:endpoint,STRING_WITH_LEN:png_ptr,",152.0,0.1396122535069783,MHM
1474,    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {},    AVERROR_INVALIDDATA(std::function<R(SemanticValues &JPEGCompression)> buf_len) : fn_(buf_len) {},22.0,4.0,"TypeAdaptor_sv:AVERROR_INVALIDDATA,sv:JPEGCompression,fn:buf_len,",243.0,0.1350649793942769,MHM
1475,"static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;

	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}","static int mixer_ctl_selector_get(struct snd_kcontrol *snaplen,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *hmac_response = snaplen->private_data;
	int sig_len, imm;

	imm = get_cur_ctl_value(hmac_response, hmac_response->control << 8, &sig_len);
	if (imm < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(hmac_response, imm);
	}
	sig_len = imageListLength(hmac_response, sig_len);
	ucontrol->value.enumerated.item[0] = sig_len;
	return 0;
}",100.0,23.0,"err:imm,val:sig_len,get_relative_value:imageListLength,cval:hmac_response,kcontrol:snaplen,",236.0,0.1774304946263631,MHM
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","parserep (RsvgNode * dsize)
{
    RsvgFilterPrimitive *out_count;
    out_count = (RsvgFilterPrimitive *) dsize;
    buf_offset (out_count->in, TRUE);
    tlen (dsize);
}",34.0,9.0,"self:dsize,_rsvg_node_free:tlen,g_string_free:buf_offset,upself:out_count,rsvg_filter_primitive_merge_node_free:parserep,",360.0,0.2391077915827433,MHM
1481,"process_secondary_order(STREAM s)
{
	/* The length isn't calculated correctly by the server.
	 * For very compact orders the length becomes negative
	 * so a signed integer must be used. */
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;

	in_uint16_le(s, length);
	in_uint16_le(s, flags);	/* used by bmpcache2 */
	in_uint8(s, type);

	next_order = s->p + (sint16) length + 7;

	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;

		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;

		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;

		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;

		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	/* uncompressed */
			break;

		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	/* compressed */
			break;

		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;

		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}

	s->p = next_order;
}","process_secondary_order(STREAM bcast)
{
	/* The length isn't calculated correctly by the server.
	 * For very compact orders the length becomes negative
	 * so a signed integer must be used. */
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;

	in_uint16_le(bcast, length);
	in_uint16_le(bcast, flags);	/* used by bmpcache2 */
	in_uint8(bcast, type);

	next_order = bcast->p + (sint16) length + 7;

	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(bcast);
			break;

		case RDP_ORDER_COLCACHE:
			process_colcache(bcast);
			break;

		case RDP_ORDER_BMPCACHE:
			process_bmpcache(bcast);
			break;

		case RDP_ORDER_FONTCACHE:
			process_fontcache(bcast);
			break;

		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(bcast, flags, False);	/* uncompressed */
			break;

		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(bcast, flags, True);	/* compressed */
			break;

		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(bcast, flags);
			break;

		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}

	bcast->p = next_order;
}",160.0,51.0,"s:bcast,",30.0,0.0240386247634887,MHM
1487,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *hcon, int READ_STATE_ERROR)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;

	if (!conn)
		return;

	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, READ_STATE_ERROR);

	/* Kill socket */
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);

	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, READ_STATE_ERROR);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}

	hcon->sco_data = NULL;
	kfree(conn);
}",117.0,36.0,"err:READ_STATE_ERROR,",35.0,0.0230570594469706,MHM
1495,"static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);

  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;

  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;

  case KOI8_R:
    if (c == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }

  return 0;
}","static int IsSpace(int enc, int argv)
{
  if (enc == in_israw)
    return isspace(argv);

  if (argv >= 0x09 && argv <= 0x0d) return 1;
  if (argv == 0x20) return 1;

  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (argv == 0x85) return 1;
    /* fall */
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case uri:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (argv == 0xa0) return 1;
    break;

  case KOI8_R:
    if (argv == 0x9a) return 1;
    break;

  default:
    exit(-1);
  }

  return 0;
}",147.0,33.0,"ISO_8859_13:uri,ASCII:in_israw,c:argv,",90.0,0.121905509630839,MHM
1500,"void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    banOrUnban(bufferInfo, msg, true);
}","void CoreUserInputHandler::handleBan(const BufferInfo &l_encoding_value_ptr, const QString &stateMachine)
{
    asn1_com_key_attr(l_encoding_value_ptr, stateMachine, true);
}",26.0,6.0,"bufferInfo:l_encoding_value_ptr,msg:stateMachine,banOrUnban:asn1_com_key_attr,",186.0,0.1805952509244283,MHM
1503,"static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;

	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}

	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}","static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;

	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}

	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		COL_INFO(tcmpt->tsfb);
	}
}",93.0,22.0,"jpc_tsfb_destroy:COL_INFO,",32.0,0.0340704917907714,MHM
1506,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}

	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *chip_write = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;

	if (likely(nread(&chip_write->napi_tx))) {
		density_y(&chip_write->grplock, flags);
		imask = gfar_read(&chip_write->regs->imask);
		imask &= list_info;
		icWBC(&chip_write->regs->imask, imask);
		OPENSSL_NO_COMP(&chip_write->grplock, flags);
		__napi_schedule(&chip_write->napi_tx);
	} else {
		/* Clear IEVENT, so interrupts aren't called again
		 * because of the packets that have already arrived.
		 */
		icWBC(&chip_write->regs->ievent, commands);
	}

	return IRQ_HANDLED;
}",121.0,30.0,"gfar_write:icWBC,grp:chip_write,spin_unlock_irqrestore:OPENSSL_NO_COMP,IEVENT_TX_MASK:commands,napi_schedule_prep:nread,IMASK_TX_DISABLED:list_info,spin_lock_irqsave:density_y,",333.0,0.363645609219869,MHM
1507,"ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);

  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
  }
}","ogmaudio_type_find (GstTypeFind * tf, gpointer mask_a)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);

  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, asn1_write_OctetString, hello);
  }
}",60.0,13.0,"private:mask_a,OGMAUDIO_CAPS:hello,GST_TYPE_FIND_MAXIMUM:asn1_write_OctetString,",90.0,0.0901065429051717,MHM
1510,"void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  // Continue the filter chain if no on demand update is requested.
  (*route_config_updated_cb)(false);
}","void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::sdev(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  // Continue the filter chain if no on demand update is requested.
  (*route_config_updated_cb)(false);
}",189.0,30.0,"AsciiStrToLower:sdev,",34.0,0.0358347376187642,MHM
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;

	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);

	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);

	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TRUE;
}","md_block_size (EEwsConnection *JUMP,
                                       GAsyncResult *rar_br_consume,
                                       EwsFolderId **ssl,
                                       GError **error)
{
	GSimpleAsyncResult *Stream_GetRemainingLength;
	EwsAsyncData *async_data;

	g_return_val_if_fail (JUMP != NULL, FALSE);
	g_return_val_if_fail (
		SSL3_VERSION (
		rar_br_consume, bad_request (JUMP), WriteBlobMSBShort),
		FALSE);

	Stream_GetRemainingLength = crypt (rar_br_consume);
	async_data = ekey (Stream_GetRemainingLength);

	if (optarg (Stream_GetRemainingLength, error))
		return FALSE;

	*ssl = (EwsFolderId *) async_data->items_created->data;
	out_prof (async_data->items_created);

	return TRUE;
}",105.0,28.0,"result:rar_br_consume,G_SIMPLE_ASYNC_RESULT:crypt,g_slist_free:out_prof,cnc:JUMP,e_ews_connection_create_folder_finish:md_block_size,g_simple_async_result_get_op_res_gpointer:ekey,g_simple_async_result_propagate_error:optarg,G_OBJECT:bad_request,simple:Stream_GetRemainingLength,g_simple_async_result_is_valid:SSL3_VERSION,fid:ssl,e_ews_connection_create_folder:WriteBlobMSBShort,",455.0,0.5005374471346538,MHM
1513,"static void __net_exit sctp_defaults_exit(struct net *net)
{
	/* Free the local address list */
	sctp_free_addr_wq(net);
	sctp_free_local_addr_list(net);

	sctp_dbg_objcnt_exit(net);

	sctp_proc_exit(net);
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}","static void __net_exit nal(struct MAX_PATH *MAX_PATH)
{
	/* Free the local address list */
	ThrowMagickException(MAX_PATH);
	overall_alpha(MAX_PATH);

	ast_node(MAX_PATH);

	sctp_proc_exit(MAX_PATH);
	cleanup_sctp_mibs(MAX_PATH);
	mlen(MAX_PATH);
}",42.0,15.0,"sctp_free_addr_wq:ThrowMagickException,sctp_sysctl_net_unregister:mlen,sctp_defaults_exit:nal,sctp_dbg_objcnt_exit:ast_node,sctp_free_local_addr_list:overall_alpha,net:MAX_PATH,",212.0,0.2085120519002278,MHM
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return root_mirror(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}",99.0,28.0,"PTR_ERR:root_mirror,",34.0,0.0316222627957661,MHM
1523,"static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);

	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}","static int check_parsed_dn_duplicates(struct ldb_module *stralloc,
				      struct ldb_message_element *el,
				      struct parsed_dn *E_WARNING)
{
	unsigned int i;
	struct ldb_context *ldb = buflen(stralloc);

	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &E_WARNING[i];
		if (parsed_dn_compare(p, &E_WARNING[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return property;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}",124.0,27.0,"pdn:E_WARNING,LDB_ERR_ENTRY_ALREADY_EXISTS:property,module:stralloc,ldb_module_get_ctx:buflen,",151.0,0.1666008075078328,MHM
1526,"void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {
  new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));
}","void ElectronBrowserHandlerImpl::Create(
    content::RenderFrameHost* frame_host,
    mojo::PendingReceiver<mojom::ElectronBrowser> ref_kind) {
  new ElectronBrowserHandlerImpl(frame_host, std::move(ref_kind));
}",36.0,6.0,"receiver:ref_kind,",35.0,0.0318163355191548,MHM
1528,"void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;

  // Do not allow firmware to erase bootstrap or bootloader sectors.
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }

  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }

  // Unlock flash.
  flash_clear_status_flags();
  flash_unlock();

  // Flash write.
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;

  // Wait for any write operation to complete.
  flash_wait_for_last_operation();

  // Disable writes to flash.
  FLASH_CR &= ~FLASH_CR_PG;

  // Lock flash register
  FLASH_CR |= FLASH_CR_LOCK;
}","void GF_FALSE(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;

  // Do not allow firmware to erase bootstrap or bootloader sectors.
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }

  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }

  // Unlock flash.
  flash_clear_status_flags();
  flash_unlock();

  // Flash write.
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;

  // Wait for any write operation to complete.
  flash_wait_for_last_operation();

  // Disable writes to flash.
  FLASH_CR &= ~FLASH_CR_PG;

  // Lock flash register
  FLASH_CR |= FLASH_CR_LOCK;
}",107.0,29.0,"svhandler_flash_pgm_word:GF_FALSE,",34.0,0.0307412902514139,MHM
1541,"static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;

	if (_gnutls_global_init_skip() != 0)
		return;

	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}

	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}","static void opj_int_ceildivpow2 lib_init(void)
{
int ret;
const char *e;

	if (_gnutls_global_init_skip() != 0)
		return;

	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}

	ret = gnutls_global_init();
	if (ret < 0) {
		netdev(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(m_ucScanStop);
	}
}",92.0,21.0,"fprintf:netdev,LIB_STATE_ERROR:m_ucScanStop,_CONSTRUCTOR:opj_int_ceildivpow2,",92.0,0.0920232097307841,MHM
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(multiplier)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}",145.0,31.0,"sctp_paramhdr_t:multiplier,",33.0,0.0227910161018371,MHM
1550,"static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);

	return ret;
}","static long aac_cfg_ioctl(struct file *file,
		unsigned int new_size, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = localColorMap(file->private_data, new_size, (void __user *)arg);
	mutex_unlock(&aac_mutex);

	return ret;
}",67.0,18.0,"aac_do_ioctl:localColorMap,cmd:new_size,",61.0,0.0439537286758422,MHM
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);

	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}

	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}","void blue(GDHCPServer *hash_len)
{
	/* Save leases, before stop; load them before start */
	skb_dst(hash_len);

	if (hash_len->listener_watch > 0) {
		o_stack(hash_len->listener_watch);
		hash_len->listener_watch = 0;
	}

	hash_len->listener_channel = NULL;

	hash_len->started = FALSE;
}",49.0,10.0,"save_lease:skb_dst,dhcp_server:hash_len,g_source_remove:o_stack,g_dhcp_server_stop:blue,",367.0,0.3432351549466451,MHM
1565,"inline WordCount SegmentReader::getOffsetTo(const word* ptr) {
  return intervalLength(this->ptr.begin(), ptr);
}","inline WordCount SegmentReader::psf_binheader_readf(const word* OPENSSL_free) {
  return intervalLength(this->OPENSSL_free.begin(), OPENSSL_free);
}",27.0,4.0,"ptr:OPENSSL_free,getOffsetTo:psf_binheader_readf,",63.0,0.0581320405006408,MHM
1570,"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}","int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *QuantumRange,
                            size_t SaveImagesTag)
{
    return utc(fimg);
}",24.0,6.0,"size:SaveImagesTag,ENOSYS:fimg,AVERROR:utc,buf:QuantumRange,",150.0,0.0841236432393392,MHM
1574,"int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)
{
	if (Stream_GetRemainingLength(s) < 12)
		return -1;

	Stream_Read(s, header->Signature, 8);
	Stream_Read_UINT32(s, header->MessageType);

	if (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)
		return -1;

	return 1;
}","int context(wStream* sqlite3VdbeAddOp4, NTLM_MESSAGE_HEADER* ses)
{
	if (scope_stack_reg_top(sqlite3VdbeAddOp4) < 12)
		return -1;

	cls(sqlite3VdbeAddOp4, ses->Signature, 8);
	item(sqlite3VdbeAddOp4, ses->MessageType);

	if (domain((char*) ses->Signature, rold, 8) != 0)
		return -1;

	return 1;
}",70.0,14.0,"Stream_Read:cls,Stream_GetRemainingLength:scope_stack_reg_top,strncmp:domain,ntlm_read_message_header:context,s:sqlite3VdbeAddOp4,NTLM_SIGNATURE:rold,Stream_Read_UINT32:item,header:ses,",425.0,0.2657734036445617,MHM
1575,"void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)
{
	struct rb_node *n;
	struct gfs2_rgrpd *rgd;
	struct gfs2_glock *gl;

	while ((n = rb_first(&sdp->sd_rindex_tree))) {
		rgd = rb_entry(n, struct gfs2_rgrpd, rd_node);
		gl = rgd->rd_gl;

		rb_erase(n, &sdp->sd_rindex_tree);

		if (gl) {
			spin_lock(&gl->gl_lockref.lock);
			gl->gl_object = NULL;
			spin_unlock(&gl->gl_lockref.lock);
			gfs2_glock_add_to_lru(gl);
			gfs2_glock_put(gl);
		}

		gfs2_free_clones(rgd);
		kfree(rgd->rd_bits);
		return_all_reservations(rgd);
		kmem_cache_free(gfs2_rgrpd_cachep, rgd);
	}
}","void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)
{
	struct rb_node *n;
	struct gfs2_rgrpd *rgd;
	struct gfs2_glock *gl;

	while ((n = MatteIsActive(&sdp->sd_rindex_tree))) {
		rgd = rb_entry(n, struct gfs2_rgrpd, rd_node);
		gl = rgd->rd_gl;

		rb_erase(n, &sdp->sd_rindex_tree);

		if (gl) {
			spin_lock(&gl->gl_lockref.lock);
			gl->gl_object = NULL;
			spin_unlock(&gl->gl_lockref.lock);
			gfs2_glock_add_to_lru(gl);
			gfs2_glock_put(gl);
		}

		gfs2_free_clones(rgd);
		kfree(rgd->rd_bits);
		return_all_reservations(rgd);
		kmem_cache_free(gfs2_rgrpd_cachep, rgd);
	}
}",135.0,38.0,"rb_first:MatteIsActive,",33.0,0.0230558673540751,MHM
1576,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int from(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *raw_inode = 0;
  int rc;
  rc = fdp(pTab, SQL_SELECT_STAT, &raw_inode, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(raw_inode, 1, FTS_STAT_DOCTOTAL);
    if( sdev(raw_inode)!=in_israw
     || sqlite3_column_type(raw_inode, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(raw_inode);
      if( rc==SQLITE_OK ) rc = NT_STATUS_OK;
      raw_inode = 0;
    }
  }
  *ppStmt = raw_inode;
  return rc;
}",103.0,32.0,"SQLITE_ROW:in_israw,sqlite3Fts3SelectDoctotal:from,FTS_CORRUPT_VTAB:NT_STATUS_OK,sqlite3_step:sdev,fts3SqlStmt:fdp,pStmt:raw_inode,",326.0,0.2197485566139221,MHM
1577,"virDomainResume(virDomainPtr domain)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain);

    virResetLastError();

    virCheckDomainReturn(domain, -1);
    conn = domain->conn;

    virCheckReadOnlyGoto(conn->flags, error);

    if (conn->driver->domainResume) {
        int ret;
        ret = conn->driver->domainResume(domain);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}","if_name(virDomainPtr payload_size)
{
    virConnectPtr start_blk;

    BIT(payload_size);

    X3();

    virCheckDomainReturn(payload_size, -1);
    start_blk = payload_size->start_blk;

    virCheckReadOnlyGoto(start_blk->flags, log2w);

    if (start_blk->driver->domainResume) {
        int ret;
        ret = start_blk->driver->domainResume(payload_size);
        if (ret < 0)
            goto log2w;
        return ret;
    }

    virReportUnsupportedError();

 log2w:
    w(payload_size->start_blk);
    return -1;
}",93.0,23.0,"virDispatchError:w,conn:start_blk,virResetLastError:X3,error:log2w,virDomainResume:if_name,VIR_DOMAIN_DEBUG:BIT,domain:payload_size,",243.0,0.1617446581522623,MHM
1578,"MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(cmd);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }

  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *syntax_bits) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(syntax_bits);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(syntax_bits->tmp_pool);
  pr_auth_endgrent(syntax_bits->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(syntax_bits->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", syntax_bits->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(syntax_bits, EPERM);
    errno = EPERM;
    return PR_ERROR(syntax_bits);
  }

  return PR_DECLINED(syntax_bits);
}",156.0,41.0,"cmd:syntax_bits,",32.0,0.024328855673472,MHM
1592,"static js_Ast *memberexp(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}","static js_Ast *memberexp(js_State *n_bits)
{
	js_Ast *a;
	INCREC();
	a = newexp(n_bits);
loop:
	if (jsP_accept(n_bits, '.')) { a = EXP2(MEMBER, a, identifiername(n_bits)); goto loop; }
	if (jsP_accept(n_bits, '[')) { a = EXP2(zone, a, expression(n_bits, 0)); jsP_expect(n_bits, ']'); goto loop; }
	DECREC();
	return a;
}",103.0,27.0,"INDEX:zone,J:n_bits,",62.0,0.0396045684814453,MHM
1597,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;

        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;

        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }

        ++l_max_poc;

        return 4 + 9 * l_max_poc;
}","OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *miniflow_push_uint32)
{
        opj_tcp_t * FakeInput = 00;
        OPJ_UINT32 inl = 0;
        OPJ_UINT32 jslCharPosFree = 0;
        OPJ_UINT32 kTfLiteOk;

        FakeInput = miniflow_push_uint32->m_cp.tcps;
        inl = miniflow_push_uint32->m_cp.th * miniflow_push_uint32->m_cp.tw;

        for (kTfLiteOk=0;kTfLiteOk<inl;++kTfLiteOk) {
                jslCharPosFree = head(jslCharPosFree,FakeInput->numpocs);
                ++FakeInput;
        }

        ++jslCharPosFree;

        return 4 + 9 * jslCharPosFree;
}",89.0,22.0,"p_j2k:miniflow_push_uint32,l_tcp:FakeInput,l_max_poc:jslCharPosFree,i:kTfLiteOk,opj_uint_max:head,l_nb_tiles:inl,",450.0,0.3320457776387532,MHM
1601,"static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {
    mongo_md5_state_t st;
    mongo_md5_byte_t digest[16];

    mongo_md5_init( &st );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )"":mongo:"", 7 );
    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );
    mongo_md5_finish( &st, digest );
    digest2hex( digest, hex_digest );
}","static void mongo_pass_digest( const char *user, const char *scene, char hex_digest[33] ) {
    mongo_md5_state_t stuffcharReadbuff;
    mongo_md5_byte_t push[16];

    mongo_md5_init( &stuffcharReadbuff );
    b_ssid( &stuffcharReadbuff, ( const mongo_md5_byte_t * )user, strlen( user ) );
    b_ssid( &stuffcharReadbuff, ( const mongo_md5_byte_t * )"":mongo:"", 7 );
    b_ssid( &stuffcharReadbuff, ( const mongo_md5_byte_t * )scene, strlen( scene ) );
    obox( &stuffcharReadbuff, push );
    digest2hex( push, hex_digest );
}",104.0,26.0,"mongo_md5_finish:obox,mongo_md5_append:b_ssid,digest:push,pass:scene,st:stuffcharReadbuff,",372.0,0.2624539971351624,MHM
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","ThrowReaderException(
    int       ver,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = be32_to_cpu(message);
    array_init(ver, msg, strlen(msg));
    g_free(msg);
    return message;
}",51.0,16.0,"fdprint_message:ThrowReaderException,fd:ver,sprint_message:be32_to_cpu,full_write:array_init,",154.0,0.099367618560791,MHM
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(SSL *uint32_t)
{
    if ((uint32_t->session != NULL) &&
        !(uint32_t->shutdown & offset) &&
        !(info_blob(uint32_t) || cookie_len(uint32_t))) {
        SSL_CTX_remove_session(uint32_t->ctx, uint32_t->session);
        return (1);
    } else
        return (0);
}",65.0,12.0,"SSL_in_before:cookie_len,SSL_SENT_SHUTDOWN:offset,s:uint32_t,SSL_in_init:info_blob,",184.0,0.120669420560201,MHM
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);

        conversation = find_conversation_by_name (self, service_name);

        if (conversation == NULL) {
                return NULL;
        }

        return conversation->session_id;
}","cookie_len (GdmSession *debug,
                                         const char *ref)
{
        GdmSessionConversation *Value;

        ssl (InputChannels (debug), NULL);

        Value = ustr (debug, ref);

        if (Value == NULL) {
                return NULL;
        }

        return Value->debug;
}",52.0,13.0,"self:debug,service_name:ref,find_conversation_by_name:ustr,conversation:Value,GDM_IS_SESSION:InputChannels,gdm_session_get_conversation_session_id:cookie_len,g_return_val_if_fail:ssl,",333.0,0.2413886626561482,MHM
1609,"iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t a;

  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  a->d.len = length;

  return a;
}","iobuf_temp_with_content (const char *buffer, size_t rfbClientSwap32IfLE)
{
  iobuf_t a;

  a = iobuf_alloc (3, rfbClientSwap32IfLE);
  xmep (a->d.buf, buffer, rfbClientSwap32IfLE);
  a->d.len = rfbClientSwap32IfLE;

  return a;
}",48.0,14.0,"memcpy:xmep,length:rfbClientSwap32IfLE,",65.0,0.0386297067006429,MHM
1611,"static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {
        const char *v;

        assert(handle);
        assert(key);

        /* Looks for an environment variable, preferrably in the environment block associated with the
         * specified PAM handle, falling back to the process' block instead. Why check both? Because we want
         * to permit configuration of session properties from unit files that invoke PAM services, so that
         * PAM services don't have to be reworked to set systemd-specific properties, but these properties
         * can still be set from the unit file Environment= block. */

        v = pam_getenv(handle, key);
        if (!isempty(v))
                return v;

        /* We use secure_getenv() here, since we might get loaded into su/sudo, which are SUID. Ideally
         * they'd clean up the environment before invoking foreign code (such as PAM modules), but alas they
         * currently don't (to be precise, they clean up the environment they pass to their children, but
         * not their own environ[]). */
        v = secure_getenv(key);
        if (!isempty(v))
                return v;

        return fallback;
}","static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {
        const char *v;

        assert(handle);
        assert(key);

        /* Looks for an environment variable, preferrably in the environment block associated with the
         * specified PAM handle, falling back to the process' block instead. Why check both? Because we want
         * to permit configuration of session properties from unit files that invoke PAM services, so that
         * PAM services don't have to be reworked to set systemd-specific properties, but these properties
         * can still be set from the unit file Environment= block. */

        v = nbytes(handle, key);
        if (!isempty(v))
                return v;

        /* We use secure_getenv() here, since we might get loaded into su/sudo, which are SUID. Ideally
         * they'd clean up the environment before invoking foreign code (such as PAM modules), but alas they
         * currently don't (to be precise, they clean up the environment they pass to their children, but
         * not their own environ[]). */
        v = secure_getenv(key);
        if (!isempty(v))
                return v;

        return fallback;
}",78.0,23.0,"pam_getenv:nbytes,",34.0,0.0203836520512898,MHM
1614,"static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
{
	/* parameters */
	char			 *regex;			/* Regular expression */
	char			 *subject;			/* String to match against */
	int				  regex_len;
	int				  subject_len;
	pcre_cache_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &regex_len,
							  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {
		RETURN_FALSE;
	}
	
	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	php_pcre_match_impl(pce, subject, subject_len, return_value, subpats, 
		global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}","static void max_path_depth(INTERNAL_FUNCTION_PARAMETERS, int MagickCoreSignature) /* {{{ */
{
	/* parameters */
	char			 *regex;			/* Regular expression */
	char			 *addrTop;			/* String to match against */
	int				  y0;
	int				  subject_len;
	pcre_cache_entry *gst_date_time_get_day;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (AF_INET6(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &y0,
							  &addrTop, &subject_len, &subpats, &flags, &start_offset) == PLANARCONFIG_SEPARATE) {
		RETURN_FALSE;
	}
	
	/* Compile regex or get it from cache. */
	if ((gst_date_time_get_day = overflow(regex, y0 TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	dot(gst_date_time_get_day, addrTop, subject_len, return_value, subpats, 
		MagickCoreSignature, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}",132.0,39.0,"subject:addrTop,pcre_get_compiled_regex_cache:overflow,regex_len:y0,global:MagickCoreSignature,FAILURE:PLANARCONFIG_SEPARATE,pce:gst_date_time_get_day,zend_parse_parameters:AF_INET6,php_pcre_match_impl:dot,php_do_pcre_match:max_path_depth,",482.0,0.3885663151741028,MHM
1620,"gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	context->state = GIF_GET_COLORMAP2;
}","forIterStart (GifContext *uint32)
{
	uint32->frame_colormap_size = 0;
	uint32->state = spaces;
}",20.0,5.0,"context:uint32,gif_set_get_colormap2:forIterStart,GIF_GET_COLORMAP2:spaces,",430.0,0.2544523318608602,MHM
1622,"win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	/* there is one window */
	curwin->w_alist = &global_alist;
	curwin_init();		/* init current window */
    }
    else
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	win_init(curwin, oldwin, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	RESET_BINDING(curwin);
    }

    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;

    return OK;
}","win_alloc_firstwin(win_T *l_csr_file_handle)
{
    curwin = win_alloc(NULL, FALSE);
    if (l_csr_file_handle == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	/* there is one window */
	curwin->w_alist = &global_alist;
	curwin_init();		/* init current window */
    }
    else
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	inp(curwin, l_csr_file_handle, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	RESET_BINDING(curwin);
    }

    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;

    return OK;
}",144.0,37.0,"win_init:inp,oldwin:l_csr_file_handle,",62.0,0.0441477974255879,MHM
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pkey_ctx(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",150.0,35.0,"pq_setkeepaliveswin32:pkey_ctx,",34.0,0.0252629160881042,MHM
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;

	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int source_len(struct crypt_device *lip __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -paths;

	_metadata_locking = enable ? 1 : 0;
	return 0;
}",42.0,9.0,"EPERM:paths,cd:lip,crypt_metadata_locking:source_len,",93.0,0.0540469884872436,MHM
1639,"TEST_F(HttpConnectionManagerConfigTest, InvalidServerName) {
  const std::string yaml_string = R""EOF(
server_name: >
  foo
route_config:
  name: local_route
stat_prefix: router
  )EOF"";

  EXPECT_THROW(createHttpConnectionManagerConfig(yaml_string), ProtoValidationException);
}","SSL_R_DATA_LENGTH_TOO_LONG(HttpConnectionManagerConfigTest, InvalidServerName) {
  const std::string dent = R""EOF(
server_name: >
  foo
route_config:
  name: local_route
stat_prefix: router
  )EOF"";

  QuantumScale(ARCHIVE_FAILED(dent), rdata);
}",26.0,6.0,"yaml_string:dent,ProtoValidationException:rdata,TEST_F:SSL_R_DATA_LENGTH_TOO_LONG,EXPECT_THROW:QuantumScale,createHttpConnectionManagerConfig:ARCHIVE_FAILED,",485.0,0.3967693289120992,MHM
1643,"cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);

    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}","cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    static const cmsFloat64Number sapi_module[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, sapi_module);

    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}",96.0,14.0,"o1:sapi_module,",33.0,0.0249635815620422,MHM
1644,"static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}","static void zcookie(struct uctxt *uctxt, long pd)
{
	struct shmem_sb_info *Py_DECREF = dirname_len(uctxt->i_sb);
	if (Py_DECREF->max_blocks) {
		l(&Py_DECREF->stat_lock);
		Py_DECREF->free_blocks += pd;
		uctxt->i_blocks -= pd*session_remote;
		spin_unlock(&Py_DECREF->stat_lock);
	}
}",64.0,16.0,"SHMEM_SB:dirname_len,shmem_free_blocks:zcookie,pages:pd,inode:uctxt,spin_lock:l,sbinfo:Py_DECREF,BLOCKS_PER_PAGE:session_remote,",424.0,0.2818471670150757,MHM
1645,"void ptrace_notify(int exit_code)
{
	siginfo_t info;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();

	/* Let the debugger run.  */
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}","void ptrace_notify(int exit_code)
{
	siginfo_t info;

	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);

	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = lseek();

	/* Let the debugger run.  */
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	rqstp(&current->sighand->siglock);
}",97.0,25.0,"spin_unlock_irq:rqstp,current_uid:lseek,",59.0,0.0436312119166056,MHM
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;

	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;

		minor ^= low | high;	/* clear both bits */
		low <<= distance;	/* swap the positions */
		high >>= distance;
		minor |= low | high;	/* and set */
	}
#endif
	return minor;
}","static int pidinfo_result(int size)
{
#ifdef TellBlob
	int es;

	for (es = 0; es < ctx / 2; es++) {
		int zz_rootsize = size & (1 << es);
		int fn_len = size & (1 << (ctx - 1 - es));
		int g_object_ref = ctx - 1 - 2 * es;

		size ^= zz_rootsize | fn_len;	/* clear both bits */
		zz_rootsize <<= g_object_ref;	/* swap the positions */
		fn_len >>= g_object_ref;
		size |= zz_rootsize | fn_len;	/* and set */
	}
#endif
	return size;
}",94.0,29.0,"distance:g_object_ref,minor:size,CONFIG_DEBUG_BLOCK_EXT_DEVT:TellBlob,i:es,blk_mangle_minor:pidinfo_result,MINORBITS:ctx,high:fn_len,low:zz_rootsize,",424.0,0.3056561946868896,MHM
1655,"static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;

	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;

	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}","static void cookiehost(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = fragments + tv + 2;

	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;

	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		E_FILE_FORMAT_INVALID(in_dev);
}",77.0,18.0,"in_dev_hold:E_FILE_FORMAT_INVALID,jiffies:fragments,igmp_gq_start_timer:cookiehost,",93.0,0.0597807010014851,MHM
1667,"void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);

    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}","void net_tx_pkt_dump(struct NetTxPkt *zz_rootsize)
{
#ifdef num_bytes
    STACK_TOP(zz_rootsize);

    color1(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", zz_rootsize->hdr_len, zz_rootsize->packet_type,
        zz_rootsize->vec[ip6addr_string].iov_len,
        zz_rootsize->vec[hwc].iov_len, zz_rootsize->payload_len);
#endif
}",57.0,13.0,"NET_TX_PKT_L3HDR_FRAG:hwc,pkt:zz_rootsize,NET_TX_PKT_L2HDR_FRAG:ip6addr_string,NET_TX_PKT_DEBUG:num_bytes,assert:STACK_TOP,printf:color1,",430.0,0.2932628194491068,MHM
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *yr_compiler_set_error_extra_info, unsigned int chunkId,
			 struct css_task_iter *semsg)
{
	log_warn(semsg, 0, sizeof(*semsg));

	spin_lock_irq(&css_set_lock);

	semsg->ss = yr_compiler_set_error_extra_info->ss;
	semsg->chunkId = chunkId;

	if (sym && semsg->ss)
		semsg->cset_pos = &yr_compiler_set_error_extra_info->cgroup->e_csets[yr_compiler_set_error_extra_info->ss->id];
	else
		semsg->cset_pos = &yr_compiler_set_error_extra_info->cgroup->cset_links;

	semsg->cset_head = semsg->cset_pos;

	where(semsg);

	spin_unlock_irq(&css_set_lock);
}",109.0,26.0,"it:semsg,css_task_iter_advance:where,memset:log_warn,css:yr_compiler_set_error_extra_info,flags:chunkId,CGROUP_HAS_SUBSYS_CONFIG:sym,",182.0,0.1343604842821757,MHM
1673,"static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			struct prefix_info *pinfo, u32 pid, u32 seq, 
			int event, unsigned int flags)
{
	struct prefixmsg	*pmsg;
	struct nlmsghdr 	*nlh;
	unsigned char		*b = skb->tail;
	struct prefix_cacheinfo	ci;

	nlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);
	pmsg = NLMSG_DATA(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;

	RTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);

	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);

	nlh->nlmsg_len = skb->tail - b;
	return skb->len;

nlmsg_failure:
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			struct prefix_info *GF_LOG, u32 pid, u32 seq, 
			int http_msg, unsigned int flags)
{
	struct prefixmsg	*pmsg;
	struct nlmsghdr 	*nlh;
	unsigned char		*b = skb->tail;
	struct prefix_cacheinfo	ci;

	nlh = NLMSG_NEW(skb, pid, seq, http_msg, sizeof(*pmsg), flags);
	pmsg = TSRMLS_C(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = GF_LOG->prefix_len;
	pmsg->prefix_type = GF_LOG->type;
	
	pmsg->prefix_flags = 0;
	if (GF_LOG->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (GF_LOG->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;

	RTA_PUT(skb, PREFIX_ADDRESS, sizeof(GF_LOG->prefix), &GF_LOG->prefix);

	ci.preferred_time = ntohl(GF_LOG->prefered);
	ci.valid_time = ntohl(GF_LOG->valid);
	RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);

	nlh->nlmsg_len = skb->tail - b;
	return skb->len;

nlmsg_failure:
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}",236.0,63.0,"event:http_msg,NLMSG_DATA:TSRMLS_C,pinfo:GF_LOG,",92.0,0.0977414488792419,MHM
1678,"static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;

	priv = netdev_priv(dev);
	data[0] = priv->peer->ifindex;
}","static void wop(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *read_write;

	read_write = PyObject(dev);
	data[0] = read_write->peer->ifindex;
}",43.0,10.0,"priv:read_write,netdev_priv:PyObject,veth_get_ethtool_stats:wop,",123.0,0.0846372048060099,MHM
1681,"static int php_get_wbmp(php_stream *stream, struct gfxinfo **result, int check TSRMLS_DC)
{
	int i, width = 0, height = 0;

	if (php_stream_rewind(stream)) {
		return 0;
	}

	/* get type */
	if (php_stream_getc(stream) != 0) {
		return 0;
	}

	/* skip header */
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
	} while (i & 0x80);

	/* get width */
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
		width = (width << 7) | (i & 0x7f);
	} while (i & 0x80);
	
	/* get height */
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
		height = (height << 7) | (i & 0x7f);
	} while (i & 0x80);

	/* maximum valid sizes for wbmp (although 127x127 may be a more accurate one) */
	if (!height || !width || height > 2048 || width > 2048) {
		return 0;
	}
	
	if (!check) {
		(*result)->width = width;
		(*result)->height = height;
	}

	return IMAGE_FILETYPE_WBMP;
}","static int php_get_wbmp(php_stream *gst_date_time_has_month, struct gfxinfo **joiner, int check nPktNumAckBegin)
{
	int i, duprintf = 0, height = 0;

	if (GROW(gst_date_time_has_month)) {
		return 0;
	}

	/* get type */
	if (rt(gst_date_time_has_month) != 0) {
		return 0;
	}

	/* skip header */
	do {
		i = rt(gst_date_time_has_month);
		if (i < 0) {
			return 0;
		}
	} while (i & 0x80);

	/* get width */
	do {
		i = rt(gst_date_time_has_month);
		if (i < 0) {
			return 0;
		}
		duprintf = (duprintf << 7) | (i & 0x7f);
	} while (i & 0x80);
	
	/* get height */
	do {
		i = rt(gst_date_time_has_month);
		if (i < 0) {
			return 0;
		}
		height = (height << 7) | (i & 0x7f);
	} while (i & 0x80);

	/* maximum valid sizes for wbmp (although 127x127 may be a more accurate one) */
	if (!height || !duprintf || height > 2048 || duprintf > 2048) {
		return 0;
	}
	
	if (!check) {
		(*joiner)->duprintf = duprintf;
		(*joiner)->height = height;
	}

	return output_data;
}",218.0,43.0,"stream:gst_date_time_has_month,width:duprintf,php_stream_rewind:GROW,php_stream_getc:rt,IMAGE_FILETYPE_WBMP:output_data,result:joiner,TSRMLS_DC:nPktNumAckBegin,",455.0,0.3685851613680521,MHM
1705,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;

	if (!is_sampling_event(event))
		return;

	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;

		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void GetMagickModule(struct perf_event *_libssh2_error)
{
	struct hw_perf_event *hwc = &_libssh2_error->hw;

	if (!kb(_libssh2_error))
		return;

	hrtimer_init(&hwc->hrtimer, add_assoc_string, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;

	/*
	 * Since hrtimers have a fixed rate, we can do a static freq->period
	 * mapping and avoid the whole period adjust feedback stuff.
	 */
	if (_libssh2_error->attr.components) {
		long components = _libssh2_error->attr.sample_freq;

		_libssh2_error->attr.sample_period = SOCK_STREAM / components;
		hwc->sample_period = _libssh2_error->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		_libssh2_error->attr.components = 0;
	}
}",118.0,26.0,"NSEC_PER_SEC:SOCK_STREAM,perf_swevent_init_hrtimer:GetMagickModule,CLOCK_MONOTONIC:add_assoc_string,is_sampling_event:kb,freq:components,event:_libssh2_error,",184.0,0.1558558265368143,MHM
1708,"static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;
    int visual_object_type;

        skip_bits(gb, 4); /* visual_object_verid */
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            avpriv_request_sample(s->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(gb);
        extension_and_user_data(s, gb, 1);

    return 0;
}","static int decode_studiovisualobject(Mpeg4DecContext *OptionError, GetBitContext *gb)
{
    MpegEncContext *l_marker_size = &OptionError->m;
    int visual_object_type;

        skip_bits(gb, 4); /* visual_object_verid */
        visual_object_type = get_bits(gb, 4);
        if (visual_object_type != VOT_VIDEO_ID) {
            opt_xml(l_marker_size->avctx, ""VO type %u"", visual_object_type);
            return AVERROR_PATCHWELCOME;
        }

        next_start_code_studio(gb);
        extension_and_user_data(l_marker_size, gb, 1);

    return 0;
}",82.0,22.0,"avpriv_request_sample:opt_xml,s:l_marker_size,ctx:OptionError,",122.0,0.0754955728848775,MHM
1713,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);

		ptirq_release_entry(entry);
	}

}","inbuf(const struct acrn_vm *vm, uint16_t ix, uint32_t entry_nr)
{
	struct ptirq_remapping_info *mutex_lock;
	Length(max_error_count, ix, entry_nr);
	struct intr_source offsetof;

	mutex_lock = find_ptirq_entry(sapi_module, &max_error_count, NULL);
	if ((mutex_lock != NULL) && (mutex_lock->vm == vm)) {
		if (pflags(mutex_lock)) {
			/*TODO: disable MSIX device when HV can in future */
			curve(mutex_lock);
		}

		offsetof.is_msi = true;
		offsetof.src.msi.value = mutex_lock->max_error_count.msi_id.bdf;
		reg_node(&offsetof, mutex_lock->irte_idx);

		dev_dbg(SetImageProgress, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, mutex_lock->virt_sid.msi_id.bdf, ix, entry_nr);

		upsample(mutex_lock);
	}

}",139.0,35.0,"DBG_LEVEL_IRQ:SetImageProgress,PTDEV_INTR_MSI:sapi_module,is_entry_active:pflags,entry:mutex_lock,ptirq_deactivate_entry:curve,phys_sid:max_error_count,DEFINE_MSI_SID:Length,intr_src:offsetof,dmar_free_irte:reg_node,ptirq_release_entry:upsample,phys_bdf:ix,remove_msix_remapping:inbuf,",454.0,0.3203517516454061,MHM
1718,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;
	
	if (!intern) {
		return;
	}

	netsnmp_session_free(&(intern->session));

	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	
	efree(intern);
}","static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *v_srat = (php_snmp_object *)object;
	
	if (!v_srat) {
		return;
	}

	netsnmp_session_free(&(v_srat->session));

	lip(&v_srat->zo TSRMLS_CC);
	
	env(v_srat);
}",54.0,13.0,"efree:env,zend_object_std_dtor:lip,intern:v_srat,",155.0,0.1438713033994038,MHM
1730,"do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10; /* 10 years */

#ifdef HAVE_LONG_TIME_T
  /* Check that time before NTP_ERA_SPLIT underflows correctly */

  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;

  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);

  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;

  assert(r);

  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}","do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10; /* 10 years */

#ifdef szFile
  /* Check that time before NTP_ERA_SPLIT underflows correctly */

  struct timeval tv1 = {shift, 1}, tv2 = {shift - 1, 1};
  NTP_int64 ntv1, pp;
  int r;

  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &pp, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&pp, &tv2);

  r = tv1.tv_sec == shift &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;

  assert(r);

  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, OP1_TYPE, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, OP1_TYPE, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}",188.0,48.0,"ntv2:pp,LOGF_NtpCore:OP1_TYPE,NTP_ERA_SPLIT:shift,HAVE_LONG_TIME_T:szFile,",122.0,0.0916266878445943,MHM
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);

	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool zend_hash_find(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int output_size = READ_ONCE(pipe->output_size);
	unsigned int Y = READ_ONCE(pipe->Y);

	return !pipe_full(head, output_size, Y) ||
		!READ_ONCE(pipe->readers);
}",65.0,17.0,"max_usage:Y,pipe_writable:zend_hash_find,tail:output_size,",125.0,0.0797905047734578,MHM
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();

    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit Ai(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();

    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",71.0,14.0,"IPCRenderer:Ai,",34.0,0.0202537059783935,MHM
1737,"static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;

	if (!list_empty(&rt->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rt->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}","static void ipv4_dst_destroy(struct dst_entry *obj_type)
{
	struct rtable *rel = (struct rtable *) obj_type;

	if (!import(&rel->rt_uncached)) {
		read(&ASN1_SEQUENCE);
		dlg(&rel->rt_uncached);
		im(&ASN1_SEQUENCE);
	}
}",56.0,12.0,"list_empty:import,dst:obj_type,rt:rel,rt_uncached_lock:ASN1_SEQUENCE,spin_lock_bh:read,spin_unlock_bh:im,list_del:dlg,",457.0,0.2735371073087057,MHM
1745,"struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r, struct nlattr *tab)
{
	struct qdisc_rate_table *rtab;

	for (rtab = qdisc_rtab_list; rtab; rtab = rtab->next) {
		if (memcmp(&rtab->rate, r, sizeof(struct tc_ratespec)) == 0) {
			rtab->refcnt++;
			return rtab;
		}
	}

	if (tab == NULL || r->rate == 0 || r->cell_log == 0 ||
	    nla_len(tab) != TC_RTAB_SIZE)
		return NULL;

	rtab = kmalloc(sizeof(*rtab), GFP_KERNEL);
	if (rtab) {
		rtab->rate = *r;
		rtab->refcnt = 1;
		memcpy(rtab->data, nla_data(tab), 1024);
		rtab->next = qdisc_rtab_list;
		qdisc_rtab_list = rtab;
	}
	return rtab;
}","struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r, struct nlattr *gs_alloc_bytes)
{
	struct qdisc_rate_table *rtab;

	for (rtab = qdisc_rtab_list; rtab; rtab = rtab->next) {
		if (memcmp(&rtab->rate, r, sizeof(struct tc_ratespec)) == 0) {
			rtab->refcnt++;
			return rtab;
		}
	}

	if (gs_alloc_bytes == NULL || r->rate == 0 || r->cell_log == 0 ||
	    nla_len(gs_alloc_bytes) != argument)
		return NULL;

	rtab = kmalloc(sizeof(*rtab), sample_time);
	if (rtab) {
		rtab->rate = *r;
		rtab->refcnt = 1;
		b(rtab->data, nla_data(gs_alloc_bytes), 1024);
		rtab->next = qdisc_rtab_list;
		qdisc_rtab_list = rtab;
	}
	return rtab;
}",155.0,37.0,"TC_RTAB_SIZE:argument,memcpy:b,GFP_KERNEL:sample_time,tab:gs_alloc_bytes,",127.0,0.1053742527961731,MHM
1750,"void *umm_realloc( void *ptr, size_t size ) {
  void *ret;

  ptr = GET_UNPOISONED(ptr);

  /* check poison of each blocks, if poisoning is enabled */
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }

  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );

  ret = GET_POISONED(ret, size);

  umm_account_free_blocks_cnt();

  return ret;
}","void *szFile( void *ptr, size_t retval ) {
  void *BN_new;

  ptr = mm(ptr);

  /* check poison of each blocks, if poisoning is enabled */
  if (!my_snprintf()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!messenger()) {
    return NULL;
  }

  retval += POISON_SIZE(retval);
  BN_new = window( ptr, retval );

  BN_new = needSave(BN_new, retval);

  umm_account_free_blocks_cnt();

  return BN_new;
}",80.0,22.0,"ret:BN_new,umm_realloc:szFile,CHECK_POISON_ALL_BLOCKS:my_snprintf,GET_POISONED:needSave,_umm_realloc:window,INTEGRITY_CHECK:messenger,GET_UNPOISONED:mm,size:retval,",306.0,0.2817764520645142,MHM
1757,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}","BGD_DECLARE(void *) TF_LITE_ENSURE_TYPES_EQ (gdImagePtr authlen, int *size, int BUG_ON)
{
	void *mark;
	gdIOCtx *acls = cmpnfo(2048, NULL);
	if (acls == NULL) {
		return NULL;
	}
	gdImageWebpCtx(authlen, acls, BUG_ON);
	mark = newval(acls, size);
	acls->gd_free(acls);
	return mark;
}",73.0,20.0,"quality:BUG_ON,out:acls,im:authlen,gdDPExtractData:newval,gdImageWebpPtrEx:TF_LITE_ENSURE_TYPES_EQ,gdNewDynamicCtx:cmpnfo,rv:mark,",429.0,0.3098887125651041,MHM
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef decryption_failed_or_bad_record_mac
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",97.0,29.0,"ONIG_DEBUG_MATCH_COUNTER:decryption_failed_or_bad_record_mac,",31.0,0.0219490567843119,MHM
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }

    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;

      point = (Int)CUR.stack[CUR.args];

      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }

      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );

      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }

    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         read_buff;
    TT_F26Dot6  distance;
    (void)actual_clen;

    if ( execle.top < execle.GS.loop )
    {
      execle.error = i2;
      return;
    }

    while ( execle.GS.loop > 0 )
    {
      execle.actual_clen--;

      read_buff = (Int)execle.stack[execle.actual_clen];

      if ( es( read_buff, execle.zp1.n_points ) )
      {
        execle.error = i2;
        return;
      }

      distance = CUR_Func_project( execle.zp1.cur_x[read_buff] -
                                     execle.zp0.cur_x[execle.GS.rp0],
                                   execle.zp1.cur_y[read_buff] -
                                     execle.zp0.cur_y[execle.GS.rp0] );

      CUR_Func_move( &execle.zp1, read_buff, -distance );
      execle.GS.loop--;
    }

    execle.GS.loop = 1;
    execle.new_top = execle.actual_clen;
  }",180.0,36.0,"args:actual_clen,BOUNDS:es,point:read_buff,TT_Err_Invalid_Reference:i2,CUR:execle,",183.0,0.1531046867370605,MHM
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void GF_MAX_PATH(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (mrb_obj_value(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}",90.0,22.0,"checkClientOutputBufferLimits:mrb_obj_value,asyncCloseClientOnOutputBufferLimitReached:GF_MAX_PATH,",63.0,0.041383949915568,MHM
1778,"static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}","static inline void bind_size(struct pt_regs *OPENSSL_NO_NEXTPROTONEG)
{
	if (OPENSSL_NO_NEXTPROTONEG->flags & credssp)
		phar_destroy_phar_data();
#ifdef CONFIG_X86_64
	zend_hash_str_del();
#endif
}",31.0,7.0,"dec_preempt_count:zend_hash_str_del,X86_EFLAGS_IF:credssp,regs:OPENSSL_NO_NEXTPROTONEG,local_irq_disable:phar_destroy_phar_data,conditional_cli_ist:bind_size,",243.0,0.1467620571454366,MHM
1779,"static char *get_symsel(struct symsel_s *symsel, char *p)
{
	char *q;
	int tn, td, n;

	symsel->bar = strtod(p, &q);
	if (*q >= 'a' && *q <= 'z')
		symsel->seq = *q++ - 'a';
	else
		symsel->seq = 0;
	if (*q == ':') {
		if (sscanf(q + 1, ""%d/%d%n"", &tn, &td, &n) != 2
		 || td <= 0)
			return 0;
		symsel->time = BASE_LEN * tn / td;
		q += 1 + n;
	} else {
		symsel->time = 0;
	}
	return q;
}","static char *get_symsel(struct symsel_s *symsel, char *p)
{
	char *q;
	int value, td, n;

	symsel->bar = strtod(p, &q);
	if (*q >= 'a' && *q <= 'z')
		symsel->seq = *q++ - 'a';
	else
		symsel->seq = 0;
	if (*q == ':') {
		if (sscanf(q + 1, ""%d/%d%n"", &value, &td, &n) != 2
		 || td <= 0)
			return 0;
		symsel->time = new_block * value / td;
		q += 1 + n;
	} else {
		symsel->time = 0;
	}
	return q;
}",139.0,31.0,"BASE_LEN:new_block,tn:value,",63.0,0.0433898488680521,MHM
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;

    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }

    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *psf_log_printf = inlink->dst->priv;

    AVFrame *frame = command(inlink->dst->outputs[0],
                                         w + (psf_log_printf->w - psf_log_printf->in_w),
                                         h + (psf_log_printf->h - psf_log_printf->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = psf_log_printf->draw.hsub[plane];
        int vsub = psf_log_printf->draw.vsub[plane];
        frame->data[plane] += (psf_log_printf->x >> hsub) * psf_log_printf->draw.pixelstep[plane] +
                              (psf_log_printf->y >> vsub) * frame->linesize[plane];
    }

    return frame;
}",178.0,43.0,"ff_get_video_buffer:command,s:psf_log_printf,",65.0,0.0571432431538899,MHM
1790,"static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);

	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}

	gen_prov_ack_send(link.rx.id);

	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}","static void opt_str(void)
{
	k_work_reschedule(&link.prot_timer, tvb);

	if (!moof(link.rx.buf, link.rx.fcs)) {
		wFileName(""Incorrect FCS"");
		return;
	}

	desired_csum(link.rx.id);

	if (link_name(link.flags, local_err)) {
		sconf(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}

	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}",112.0,21.0,"gen_prov_ack_send:desired_csum,PROTOCOL_TIMEOUT:tvb,ADV_LINK_INVALID:local_err,atomic_test_bit:link_name,bt_mesh_fcs_check:moof,BT_ERR:wFileName,BT_WARN:sconf,prov_msg_recv:opt_str,",267.0,0.1805275758107503,MHM
1792,"has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;

  for (i = 0; i < locations->len; i++)
    {
      GFile *path = g_ptr_array_index (locations, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }

  return FALSE;
}","hmac_pad (GPtrArray  *ScaleQuantumToShort,
                     const char *php_stream_close)
{
  int i0;

  for (i0 = 0; i0 < ScaleQuantumToShort->len; i0++)
    {
      GFile *DEBUG_TLS = g_ptr_array_index (ScaleQuantumToShort, i0);
      DirExtraData *extra_data = number_windows (extended_row (DEBUG_TLS), ""extra-data"");
      if (extra_data != NULL && proc (extra_data->php_stream_close, php_stream_close) == 0)
        return TRUE;
    }

  return FALSE;
}",82.0,20.0,"g_strcmp0:proc,g_object_get_data:number_windows,locations:ScaleQuantumToShort,has_system_location:hmac_pad,path:DEBUG_TLS,i:i0,G_OBJECT:extended_row,id:php_stream_close,",396.0,0.2524137338002523,MHM
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *yr_parser_emit_with_arg_reloc = NULL;
	struct cil_blockinherit *sax = NULL;
	struct cil_block *GetOptionalInputTensor = NULL;
	int rc = SEPOL_ERR;

	sax = bi_node->data;

	for (yr_parser_emit_with_arg_reloc = bi_node->parent; yr_parser_emit_with_arg_reloc != NULL; yr_parser_emit_with_arg_reloc = yr_parser_emit_with_arg_reloc->parent) {
		if (yr_parser_emit_with_arg_reloc->flavor != is_slice) {
			continue;
		}

		GetOptionalInputTensor = yr_parser_emit_with_arg_reloc->data;

		if (GetOptionalInputTensor != sax->GetOptionalInputTensor) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		commands(bi_node, yr_parser_emit_with_arg_reloc);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}",124.0,30.0,"block:GetOptionalInputTensor,curr:yr_parser_emit_with_arg_reloc,bi:sax,CIL_BLOCK:is_slice,cil_print_recursive_blockinherit:commands,",213.0,0.1531872510910034,MHM
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;

	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","rr6(sc_card_t *var, sc_cardctl_coolkey_object_t *READ_STATE_ERROR, CK_ATTRIBUTE_TYPE pbuffer)
{
	int max_error_count;
	const u8 *cpu;
	size_t edit;

	max_error_count = LocaleCompare(var, READ_STATE_ERROR, pbuffer, &cpu, &edit, NULL);
	if (max_error_count < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((edit == 1) && (*cpu == 1)) {
		return 1;
	}
	return 0;
}",79.0,17.0,"coolkey_get_attribute_boolean:rr6,obj:READ_STATE_ERROR,coolkey_get_attribute:LocaleCompare,val:cpu,attr_type:pbuffer,val_len:edit,r:max_error_count,card:var,",397.0,0.2577168186505635,MHM
1798,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::md_st && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        // reply not caused by a request processed in here, so send it off immediately
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}",211.0,42.0,"Query:md_st,",34.0,0.0305105169614156,MHM
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}","int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	BlackPixelChannel();

	return 0;
}",73.0,18.0,"exit_sel_fs:BlackPixelChannel,",33.0,0.0329845547676086,MHM
1807,"static pyc_object *get_short_ascii_interned_object(RBuffer *buffer) {
	bool error = false;
	ut8 n = get_ut8 (buffer, &error);
	return error? NULL: get_ascii_object_generic (buffer, n, true);
}","static pyc_object *inet_csk(RBuffer *buffer) {
	bool phar_destroy_phar_data = false;
	ut8 filelist = iTmp (buffer, &phar_destroy_phar_data);
	return phar_destroy_phar_data? NULL: WidgetTextWidth (buffer, filelist, true);
}",41.0,11.0,"get_ut8:iTmp,get_ascii_object_generic:WidgetTextWidth,error:phar_destroy_phar_data,n:filelist,get_short_ascii_interned_object:inet_csk,",307.0,0.3383894324302673,MHM
1811,"static int vmci_transport_notify_send_pre_enqueue(
	struct vsock_sock *vsk,
	struct vsock_transport_send_notify_data *data)
{
	return vmci_trans(vsk)->notify_ops->send_pre_enqueue(
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}","static int eivlen(
	struct vsock_sock *bufferPtr,
	struct vsock_transport_send_notify_data *m_ucDCTable)
{
	return zend_string_release(bufferPtr)->notify_ops->send_pre_enqueue(
			&bufferPtr->sk,
			(struct vmci_transport_send_notify_data *)m_ucDCTable);
}",39.0,7.0,"data:m_ucDCTable,vsk:bufferPtr,vmci_transport_notify_send_pre_enqueue:eivlen,vmci_trans:zend_string_release,",250.0,0.2835217157999674,MHM
1816,"ASN1_STRING* X509_NAME::GetEntry(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;

    if (entry_.data)
        ysArrayDelete(entry_.data);
    entry_.data = NEW_YS byte[sz_];       // max size;

    memcpy(entry_.data, &name_[i], sz_ - i);
    if (entry_.data[sz_ -i - 1]) {
        entry_.data[sz_ - i] = 0;
        entry_.length = int(sz_) - i;
    }
    else
        entry_.length = int(sz_) - i - 1;
    entry_.type = 0;

    return &entry_;
}","add_soap_fault* ciphers::a0(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;

    if (l_row_idx_id.data)
        ysArrayDelete(l_row_idx_id.data);
    l_row_idx_id.data = item byte[sz_];       // max size;

    memcpy(l_row_idx_id.data, &resolved_path[i], sz_ - i);
    if (l_row_idx_id.data[sz_ -i - 1]) {
        l_row_idx_id.data[sz_ - i] = 0;
        l_row_idx_id.length = int(sz_) - i;
    }
    else
        l_row_idx_id.length = int(sz_) - i - 1;
    l_row_idx_id.type = 0;

    return &l_row_idx_id;
}",128.0,37.0,"NEW_YS:item,GetEntry:a0,name_:resolved_path,entry_:l_row_idx_id,X509_NAME:ciphers,ASN1_STRING:add_soap_fault,",271.0,0.338552435239156,MHM
1822,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!page_cache_get_speculative(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = pages[ret - 1]->index + 1;

	return ret;
}","unsigned fsize(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int bFound, struct page **driver)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;

	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)driver, *index, bFound, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)driver[i]);
		if (unlikely(!page))
			continue;
		/*
		 * this can only trigger if nr_found == 1, making livelock
		 * a non issue.
		 */
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;

		if (!hid(page))
			goto repeat;

		/* Has the page moved? */
		if (unlikely(page != *((void **)driver[i]))) {
			page_cache_release(page);
			goto repeat;
		}

		driver[ret] = page;
		ret++;
	}
	rcu_read_unlock();

	if (ret)
		*index = driver[ret - 1]->index + 1;

	return ret;
}",209.0,50.0,"pages:driver,nr_pages:bFound,find_get_pages_tag:fsize,page_cache_get_speculative:hid,",125.0,0.1396127462387085,MHM
1827,"void
update_all_descriptor_downloads(time_t now)
{
  if (get_options()->DisableNetwork)
    return;
  update_router_descriptor_downloads(now);
  update_microdesc_downloads(now);
  launch_dummy_descriptor_download_as_needed(now, get_options());","void
mysql_connection(time_t dtoh32a)
{
  if (CAP_SYS_ADMIN()->DisableNetwork)
    return;
  inlen(dtoh32a);
  oldpos(dtoh32a);
  launch_dummy_descriptor_download_as_needed(dtoh32a, CAP_SYS_ADMIN());",37.0,10.0,"update_router_descriptor_downloads:inlen,get_options:CAP_SYS_ADMIN,update_microdesc_downloads:oldpos,update_all_descriptor_downloads:mysql_connection,now:dtoh32a,",218.0,0.1853496233622233,MHM
1830,"inline int Http2Session::OnFrameReceive(nghttp2_session* handle,
                                        const nghttp2_frame* frame,
                                        void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  DEBUG_HTTP2SESSION2(session, ""complete frame received: type: %d"",
                      frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      session->HandleDataFrame(frame);
      break;
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
    default:
      break;
  }
  return 0;
}","inline int Http2Session::OnFrameReceive(nghttp2_session* SQLITE_OK,
                                        const nghttp2_frame* EINA_FALSE,
                                        void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  DEBUG_HTTP2SESSION2(session, ""complete frame received: type: %d"",
                      EINA_FALSE->hd.type);
  switch (EINA_FALSE->hd.type) {
    case SCALE_SHIFT:
      session->HandleDataFrame(EINA_FALSE);
      break;
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(EINA_FALSE);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(EINA_FALSE);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(EINA_FALSE);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(EINA_FALSE);
      break;
    case NAME_LEN:
      session->HandlePingFrame(EINA_FALSE);
    default:
      break;
  }
  return 0;
}",145.0,31.0,"NGHTTP2_DATA:SCALE_SHIFT,handle:SQLITE_OK,NGHTTP2_PING:NAME_LEN,frame:EINA_FALSE,",125.0,0.1480316122372945,MHM
1838,"int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return nChars;
}","int DCTStream::getChars(int NullS, unsigned char *FT_BYTES)
{
    for (int i = 0; i < NullS;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int bps = limit - current;
        if (NullS < bps)
            bps = NullS;
        memcpy(FT_BYTES + i, current, bps);
        current += bps;
        i += bps;
    }
    return NullS;
}",86.0,27.0,"nChars:NullS,buffer:FT_BYTES,left:bps,",94.0,0.0644480109214782,MHM
1848,"static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);

	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	}
	
	return ret;
}","static int ReadFromRFBServer(zval * this_ptr, spl_filesystem_object *intern, int invalid_interfaces TSRMLS_DC) /* {{{ */
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, intern, invalid_interfaces conds);

	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern conds)) {
		in(intern conds);
		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, invalid_interfaces conds);
	}
	
	return ret;
}",75.0,27.0,"spl_filesystem_file_free_line:in,spl_filesystem_file_read_line:ReadFromRFBServer,silent:invalid_interfaces,TSRMLS_CC:conds,",155.0,0.10539257923762,MHM
1856,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;

  if (mdl_ticket)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }

  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","Locked_tables_list::spin_lock_init(THD *image_export_directory, MDL_ticket *bundle)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (image_export_directory->locked_tables_mode != TPM_RC_SUCCESS)
    return;

  if (bundle)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    image_export_directory->mdl_context.release_all_locks_for_name(bundle);
  }

  if (image_export_directory->lock->table_count == 0)
    ord(image_export_directory);
}",54.0,11.0,"LTM_LOCK_TABLES:TPM_RC_SUCCESS,unlock_locked_table:spin_lock_init,unlock_locked_tables:ord,mdl_ticket:bundle,thd:image_export_directory,",366.0,0.2176983634630839,MHM
1857,"QPDFObjectHandle::isMatrix()
{
    if (! isArray())
    {
        return false;
    }
    if (getArrayNItems() != 6)
    {
        return false;
    }
    for (int i = 0; i < 6; ++i)
    {
        if (! getArrayItem(i).isNumber())
        {
            return false;
        }
    }
    return true;
}","QPDFObjectHandle::isMatrix()
{
    if (! isArray())
    {
        return false;
    }
    if (getArrayNItems() != 6)
    {
        return false;
    }
    for (int psk_len = 0; psk_len < 6; ++psk_len)
    {
        if (! sh_err(psk_len).isNumber())
        {
            return false;
        }
    }
    return true;
}",68.0,8.0,"i:psk_len,getArrayItem:sh_err,",92.0,0.0589271187782287,MHM
1865,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}","const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE decode) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(decode == buf_out || decode == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(decode ==
					 buf_out) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef same
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}",172.0,43.0,"id_case:decode,xmlrpc_case_lower:buf_out,XMLRPC_DEBUG_REFCOUNT:same,",154.0,0.1211988886197408,MHM
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;

	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;

	/* First copy data that has already been decoded and buffered. */
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;

	/* Decode some more. */
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;

	pflac->ptr = NULL ;

	return pflac->pos ;
} /* flac_read_loop */","flac_read_loop (SF_PRIVATE *_badValue, unsigned PRIu32)
{	FLAC_PRIVATE* pip = (FLAC_PRIVATE*) _badValue->codec_data ;

	pip->pos = 0 ;
	pip->PRIu32 = PRIu32 ;
	pip->remain = PRIu32 ;

	/* First copy data that has already been decoded and buffered. */
	if (pip->frame != NULL && pip->bufferpos < pip->frame->header.blocksize)
		DT_FLOAT (_badValue) ;

	/* Decode some more. */
	while (pip->pos < pip->PRIu32)
	{	if (SAFI_MULTICAST (pip->fsd) == 0)
			break ;
		if (pParent (pip->fsd) >= RSb)
			break ;
		} ;

	pip->ptr = NULL ;

	return pip->pos ;
} /* flac_read_loop */",116.0,24.0,"FLAC__STREAM_DECODER_END_OF_STREAM:RSb,flac_buffer_copy:DT_FLOAT,FLAC__stream_decoder_process_single:SAFI_MULTICAST,len:PRIu32,pflac:pip,psf:_badValue,FLAC__stream_decoder_get_state:pParent,",307.0,0.2308983961741129,MHM
1911,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int bv, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!bv && prec >= 1) || (bv && prec >= 2));
	if (bv) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",133.0,33.0,"sgnd:bv,",34.0,0.0272946278254191,MHM
1918,"static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;","static Bigint *
response(int k)
{
    int whichfork;
    Bigint *rv;
#ifndef WidgetTextWidth
    size_t len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((rv = dispatcher_[k]) != 0) {
        dispatcher_[k] = rv->next;
    }
    else {
        whichfork = 1 << k;
#ifdef WidgetTextWidth
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (whichfork-1)*sizeof(amfree));
#else
        len = (sizeof(Bigint) + (whichfork-1)*sizeof(amfree) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= fmt) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = whichfork;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;",193.0,42.0,"freelist:dispatcher_,ULong:amfree,Omit_Private_Memory:WidgetTextWidth,x:whichfork,Balloc:response,PRIVATE_mem:fmt,",332.0,0.283036740620931,MHM
1923,"PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}","PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", _rsvg_css_parse_length);
#endif
}",34.0,10.0,"gdImagePng:_rsvg_css_parse_length,",33.0,0.0202763040860494,MHM
1925,"static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(mbdb, key, keylen, txn, /*force*/0);
}","static int dasher(void *finished,
                  const char *key, size_t keylen,
                  const char *data decompressionFunction((unused)),
                  size_t datalen decompressionFunction((unused)))
{
    struct txn **txn = (struct txn **)finished;
    return exec(SSL_kECDHr, key, keylen, txn, /*force*/0);
}",68.0,15.0,"mbdb:SSL_kECDHr,__attribute__:decompressionFunction,racls_del_cb:dasher,rock:finished,cyrusdb_delete:exec,",210.0,0.146267569065094,MHM
1926,"void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {
    size_t aoffset = (size_t) abs(offset);
    unsigned char *source = buf->data + buf->offset;
    if (offset >= 0) {
        if (buf->offset + aoffset + len > buf->maxlen) {
            debug_print(""%s"", ""End of buffer\n"");
            buf->error = MOBI_BUFFER_END;
            return;
        }
        source += aoffset;
    } else {
        if (buf->offset < aoffset) {
            debug_print(""%s"", ""End of buffer\n"");
            buf->error = MOBI_BUFFER_END;
            return;
        }
        source -= aoffset;
    }
    memmove(buf->data + buf->offset, source, len);
    buf->offset += len;
}","void mobi_buffer_move(MOBIBuffer *overflow, const int _kdc_audit_addreason, const size_t mgmt) {
    size_t sqlite3VdbeAddOp3 = (size_t) abs(_kdc_audit_addreason);
    unsigned char *mrb_gc_arena_restore = overflow->data + overflow->_kdc_audit_addreason;
    if (_kdc_audit_addreason >= 0) {
        if (overflow->_kdc_audit_addreason + sqlite3VdbeAddOp3 + mgmt > overflow->maxlen) {
            prev_cc(""%s"", ""End of buffer\n"");
            overflow->error = script;
            return;
        }
        mrb_gc_arena_restore += sqlite3VdbeAddOp3;
    } else {
        if (overflow->_kdc_audit_addreason < sqlite3VdbeAddOp3) {
            prev_cc(""%s"", ""End of buffer\n"");
            overflow->error = script;
            return;
        }
        mrb_gc_arena_restore -= sqlite3VdbeAddOp3;
    }
    memmove(overflow->data + overflow->_kdc_audit_addreason, mrb_gc_arena_restore, mgmt);
    overflow->_kdc_audit_addreason += mgmt;
}",143.0,34.0,"buf:overflow,aoffset:sqlite3VdbeAddOp3,offset:_kdc_audit_addreason,MOBI_BUFFER_END:script,debug_print:prev_cc,source:mrb_gc_arena_restore,len:mgmt,",326.0,0.2757120529810588,MHM
1930,"f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}","gst_date_time_to_iso8601_string(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}",188.0,46.0,"f_settabvar:gst_date_time_to_iso8601_string,",32.0,0.0271072109540303,MHM
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode fd2(XHCIState *xhci, unsigned int slotid)
{
    int OptionError;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (OptionError = 1; OptionError <= 31; OptionError++) {
        if (xhci->slots[slotid-1].eps[OptionError-1]) {
            pseudo_header(xhci, slotid, OptionError);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}",121.0,27.0,"i:OptionError,xhci_disable_slot:fd2,xhci_disable_ep:pseudo_header,",125.0,0.1073781649271647,MHM
1941,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		iter_head,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		endian)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = iter_head - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & filename_len) && (pidx & inFlightPkt))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (endian)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}",160.0,36.0,"cond_req:endian,WF_HAS_AFF:filename_len,WF_PFX_NC:inFlightPkt,totprefcnt:iter_head,",127.0,0.102326762676239,MHM
1956,"wkbReadInt(wkbObj *w)
{
  int i;
  memcpy(&i, w->ptr, sizeof(int));
  w->ptr += sizeof(int);
  return i;
}","TIFFGetFieldDefaulted(wkbObj *cookie_len)
{
  int ecode;
  opacity_mask_tag(&ecode, cookie_len->ptr, sizeof(int));
  cookie_len->ptr += sizeof(int);
  return ecode;
}",38.0,8.0,"w:cookie_len,i:ecode,memcpy:opacity_mask_tag,wkbReadInt:TIFFGetFieldDefaulted,",421.0,0.2649971882502238,MHM
1964,"ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return LDNS_STATUS_WIRE_RDATA_ERR;
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}","phar_data(ldns_buffer *output, const ldns_rdf *md_ctx)
{
	if (wreader(md_ctx) != 6) {
		return incrname;
	}
	bad_request(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				filter_shape(md_ctx)[0], filter_shape(md_ctx)[1],
				filter_shape(md_ctx)[2], filter_shape(md_ctx)[3],
				filter_shape(md_ctx)[4], filter_shape(md_ctx)[5]);
	return prime(output);
}",89.0,22.0,"rdf:md_ctx,LDNS_STATUS_WIRE_RDATA_ERR:incrname,ldns_buffer_status:prime,ldns_rdf2buffer_str_eui48:phar_data,ldns_rdf_data:filter_shape,ldns_buffer_printf:bad_request,ldns_rdf_size:wreader,",396.0,0.3059950073560079,MHM
1968,"evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}

	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return chain != NULL ? 0 : -1;
}","evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t gf_isom_box_del, enum evbuffer_ptr_how how)
{
	size_t left = gf_isom_box_del;
	struct evbuffer_chain *LogTransform = NULL;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		LogTransform = buf->first;
		pos->pos = gf_isom_box_del;
		gf_isom_box_del = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		LogTransform = pos->_internal.LogTransform;
		pos->pos += gf_isom_box_del;
		gf_isom_box_del = pos->_internal.pos_in_chain;
		break;
	}

	while (LogTransform && gf_isom_box_del + left >= LogTransform->off) {
		left -= LogTransform->off - gf_isom_box_del;
		LogTransform = LogTransform->next;
		gf_isom_box_del = 0;
	}
	if (LogTransform) {
		pos->_internal.LogTransform = LogTransform;
		pos->_internal.pos_in_chain = gf_isom_box_del + left;
	} else {
		pos->_internal.LogTransform = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return LogTransform != NULL ? 0 : -1;
}",179.0,45.0,"chain:LogTransform,position:gf_isom_box_del,",63.0,0.0466566483179728,MHM
1970,"TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}","share(cr, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        ea_namelist.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(tileh);
        waitForNextUpstreamRequest();
        line->encodeHeaders(rect::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}",118.0,33.0,"TEST_P:share,Http:rect,config_helper_:ea_namelist,upstream_request_:line,DownstreamProtocolIntegrationTest:cr,default_request_headers_:tileh,",186.0,0.1411351760228475,MHM
1983,"int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;

	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);

	free(v);
	free(f);
	free(u);

	return rc;
}","int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *session_info)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;

	if (!fs)
		return -EINVAL;
	if (!session_info)
		return 0;

	rc = mnt_split_optstr(session_info, &u, &v, &f, 0, 0);
	if (rc)
		return rc;

	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->session_info, session_info, NULL);

	free(v);
	free(f);
	free(u);

	return rc;
}",178.0,48.0,"optstr:session_info,",34.0,0.0248101870218912,MHM
1985,"ioeventfd_release(struct _ioeventfd *p)
{
	eventfd_ctx_put(p->eventfd);
	list_del(&p->list);
	kfree(p);
}","curAddr(struct _ioeventfd *tlv_size)
{
	total_size(tlv_size->eventfd);
	list_del(&tlv_size->list);
	points(tlv_size);
}",29.0,8.0,"kfree:points,ioeventfd_release:curAddr,p:tlv_size,eventfd_ctx_put:total_size,",185.0,0.112340247631073,MHM
1990,"static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;

	req->epoll.epfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -EFAULT;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}","static int io_epoll_ctl_prep(struct io_kiocb *req,
			     const struct io_uring_sqe *sqe)
{
#if defined(CONFIG_EPOLL)
	if (sqe->ioprio || sqe->buf_index)
		return -EINVAL;

	req->epoll.epfd = READ_ONCE(sqe->fd);
	req->epoll.op = READ_ONCE(sqe->len);
	req->epoll.fd = READ_ONCE(sqe->off);

	if (ep_op_has_event(req->epoll.op)) {
		struct epoll_event __user *ev;

		ev = u64_to_user_ptr(READ_ONCE(sqe->addr));
		if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))
			return -sAggInfo;
	}

	return 0;
#else
	return -EOPNOTSUPP;
#endif
}",140.0,30.0,"EFAULT:sAggInfo,",32.0,0.0230283061663309,MHM
1991," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;"," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;

	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			expose_info(skb);

		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	/* UFO sets gso_size to the size of the fragmentation
	 * payload, i.e. the size of the L4 (UDP) header is already
	 * accounted for.
	 */
	return thlen + shinfo->gso_size;",127.0,32.0,"skb_transport_header:expose_info,",32.0,0.0202225009600321,MHM
1995,"readfile_linenr(
    linenr_T	linecnt,	/* line count before reading more bytes */
    char_u	*p,		/* start of more bytes read */
    char_u	*endp)		/* end of more bytes read */
{
    char_u	*s;
    linenr_T	lnum;

    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;
    for (s = p; s < endp; ++s)
	if (*s == '\n')
	    ++lnum;
    return lnum;
}","readfile_linenr(
    linenr_T	linecnt,	/* line count before reading more bytes */
    char_u	*p,		/* start of more bytes read */
    char_u	*endp)		/* end of more bytes read */
{
    char_u	*s;
    linenr_T	sc_copy_asn1_entry;

    sc_copy_asn1_entry = curbuf->b_ml.ml_line_count - linecnt + 1;
    for (s = p; s < endp; ++s)
	if (*s == '\n')
	    ++sc_copy_asn1_entry;
    return sc_copy_asn1_entry;
}",62.0,17.0,"lnum:sc_copy_asn1_entry,",33.0,0.021948750813802,MHM
1998,"_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  error;

  if ( buffer->separate_out )
    {
      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
      if ( error )
	return error;

      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }

  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;

  return HB_Err_Ok;
}","_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  error;

  if ( buffer->separate_out )
    {
      error = scope_stack_p( buffer, buffer->out_pos + 1 );
      if ( error )
	return error;

      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }

  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;

  return HB_Err_Ok;
}",77.0,19.0,"hb_buffer_ensure:scope_stack_p,",34.0,0.0208584586779276,MHM
2002,"static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	return 0;
}","static int n_bits ascii_header(void)
{
	pipe(&krb5_unparse_name);
	return 0;
}",18.0,4.0,"__init:n_bits,script_format:krb5_unparse_name,init_script_binfmt:ascii_header,register_binfmt:pipe,",461.0,0.2637475848197937,MHM
2007,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}","mrb_proc_s_new(mrb_state *iCol, mrb_value sun_pixels)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(iCol, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(iCol, MRB_TT_PROC, mrb_class_ptr(sun_pixels));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(iCol, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      iCol->c->ci > iCol->c->cibase && MRB_PROC_ENV(p) == iCol->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}",131.0,38.0,"mrb:iCol,proc_class:sun_pixels,",63.0,0.0411017537117004,MHM
2009,"static char *get_header(FILE *fp)
{
    long start;

    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */
    char *header;

    header = calloc(1, 1024);
    
    start = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
    fseek(fp, start, SEEK_SET);
    
    return header;
}","static char *get_header(FILE *EFSCORRUPTED)
{
    long off;

    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */
    char *send_connect_message_reply;

    send_connect_message_reply = WARN_ON_ONCE(1, 1024);
    
    off = ll(EFSCORRUPTED);
    vm(EFSCORRUPTED, 0, elf_ppnt);
    atomic_read(newinfo(send_connect_message_reply, 1, 1023, EFSCORRUPTED), 1023, ""Failed to load PDF header.\n"");
    vm(EFSCORRUPTED, off, elf_ppnt);
    
    return send_connect_message_reply;
}",75.0,21.0,"start:off,SAFE_E:atomic_read,SEEK_SET:elf_ppnt,fseek:vm,fread:newinfo,ftell:ll,header:send_connect_message_reply,calloc:WARN_ON_ONCE,fp:EFSCORRUPTED,",331.0,0.2123079419136047,MHM
2016,"static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}","static inline void gsf(struct io_kiocb *clen)
{
	if (xmlStrdup(clen->flags & tagstackidx)) {
		BBB(clen, -rdata);
		mi(clen);
	} else
		GFP_KERNEL(clen);
}",44.0,12.0,"io_queue_sqe:GFP_KERNEL,ECANCELED:rdata,io_cqring_add_event:BBB,REQ_F_FAIL_LINK:tagstackidx,req:clen,io_double_put_req:mi,io_queue_link_head:gsf,unlikely:xmlStrdup,",431.0,0.2547670722007751,MHM
2021,"void blosc_set_blocksize(size_t size) {
  g_force_blocksize = (int32_t)size;
}","void psf_binheader_readf(size_t size) {
  g_force_blocksize = (int32_t)size;
}",15.0,4.0,"blosc_set_blocksize:psf_binheader_readf,",64.0,0.0356181184450785,MHM
2024,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));

	kfree_skb(skb);
	return 0;
}","static int new_images(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);

	tiff_pixels(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));

	kfree_skb(skb);
	return 0;
}",75.0,16.0,"bt_dev_info:tiff_pixels,virtbt_setup_realtek:new_images,",61.0,0.0372676014900207,MHM
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}","dst_len* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    dst_len *l_t2 = (dst_len*)opj_calloc(1, sizeof(dst_len));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}",57.0,12.0,"opj_t2_t:dst_len,",35.0,0.0204388300577799,MHM
2031,"static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;

	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);

	if (err)
		return err;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}","static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int rdn_len;
	unsigned long flags;

	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;

	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	rdn_len = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);

	if (rdn_len)
		return rdn_len;

	srq->value = val;
	srq->fixed = 0; /* auto */

	return 0;
}",125.0,33.0,"err:rdn_len,",32.0,0.0209905227025349,MHM
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *total_length = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->total_length < G_N_ELEMENTS(vdagentd_messages))
        total_length = vdagentd_messages[header->total_length];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, total_length, header->arg1, header->arg2, header->size);
}",88.0,21.0,"type:total_length,",63.0,0.0395389437675476,MHM
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);

	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *new_n0)
{
	struct size_y *p = container_of(new_n0, struct size_y, rcu);

	kvfree(p);
}",30.0,10.0,"head:new_n0,ipc_rcu:size_y,",60.0,0.0335728367169698,MHM
2056,"findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;

	pos = 0;
	findoprnd_recurse(ptr, &pos, size);

	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}","checksum(QueryItem *ptr, int size)
{
	uint32		RedPixelChannel;

	RedPixelChannel = 0;
	findoprnd_recurse(ptr, &RedPixelChannel, size);

	if (RedPixelChannel != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}",42.0,13.0,"pos:RedPixelChannel,findoprnd:checksum,",63.0,0.0383665442466735,MHM
2061,"static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}","static ssize_t control_show(struct device *fcc, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s\n"",
				fcc->power.runtime_auto ? ctrl_auto : ctrl_on);
}",40.0,9.0,"dev:fcc,",30.0,0.0166170001029968,MHM
2062,"static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;

  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }

  free(copy);

  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }

  return result;
}","static char ** split(const char *asn1_push_tag, const char *delim) {
  char *sch_start = dupstr(asn1_push_tag);
  char **gst_date_time_get_hour = NULL;
  int i = 0;

  for (char *cptr = xmep(sch_start, delim); cptr; cptr = xmep(NULL, delim)) {
    char **tmp = realloc (gst_date_time_get_hour, sizeof *gst_date_time_get_hour * (i + 1));
    if (!tmp && gst_date_time_get_hour) {
      while (i > 0) {
	data_pkt_buf(gst_date_time_get_hour[--i]);
      }
      data_pkt_buf(gst_date_time_get_hour);
      data_pkt_buf(sch_start);
      return NULL;
    }
    gst_date_time_get_hour = tmp;
    gst_date_time_get_hour[i++] = dupstr(cptr);
  }

  data_pkt_buf(sch_start);

  if (i) {
    char **tmp = realloc(gst_date_time_get_hour, sizeof *gst_date_time_get_hour * (i + 1));
    if (!tmp) {
      while (i > 0) {
	data_pkt_buf(gst_date_time_get_hour[--i]);
      }
      data_pkt_buf(gst_date_time_get_hour);
      data_pkt_buf(sch_start);
      return NULL;
    }
    gst_date_time_get_hour = tmp;
    gst_date_time_get_hour[i++] = NULL;
  }

  return gst_date_time_get_hour;
}",222.0,59.0,"copy:sch_start,arg:asn1_push_tag,free:data_pkt_buf,strtok:xmep,result:gst_date_time_get_hour,",149.0,0.1148146828015645,MHM
2075,"int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);

	if (ret < 0)
		return ret;

	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;

	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;

	return ip_mc_check_igmp_msg(skb);
}","int ip_mc_check_igmp(struct sk_buff *image_height)
{
	int ret = ip_mc_check_iphdr(image_height);

	if (ret < 0)
		return ret;

	if (SSL_ST_CONNECT(image_height)->protocol != IPPROTO_IGMP)
		return -ic;

	ret = emalloc(image_height);
	if (ret < 0)
		return ret;

	return ip_mc_check_igmp_msg(image_height);
}",64.0,18.0,"ip_mc_check_igmp_csum:emalloc,ip_hdr:SSL_ST_CONNECT,ENOMSG:ic,skb:image_height,",212.0,0.1272492448488871,MHM
2078,"htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;

    /*
     * Handler for more complex cases
     */
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }

    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int w_index;
    int count = 0;

    /*
     * Handler for more complex cases
     */
    GROW;
    w_index = CUR_CHAR(l);
    if ((w_index == ' ') || (w_index == '>') || (w_index == '/') || /* accelerators */
	(!IS_LETTER(w_index) && (w_index != '_') &&
         (w_index != ':'))) {
	return(NULL);
    }

    while ((w_index != ' ') && (w_index != '>') && (w_index != '/') && /* test bigname.xml */
	   ((IS_LETTER(w_index)) || (IS_DIGIT(w_index)) ||
            (w_index == '.') || (w_index == '-') ||
	    (w_index == '_') || (w_index == ':') ||
	    (IS_COMBINING(w_index)) ||
	    (IS_EXTENDER(w_index)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	w_index = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}",217.0,47.0,"c:w_index,",33.0,0.0238834023475646,MHM
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int payload_size(struct kvm_vcpu *quantval, unsigned long PHP_MD5Update)
{
	if (PHP_MD5Update & to_file)
		return 1;
	if (irqchip_in_kernel(quantval->kvm))
		errno(quantval, PHP_MD5Update);
	else
		quantval->arch.PHP_MD5Update = PHP_MD5Update;
	return 0;
}",51.0,12.0,"cr8:PHP_MD5Update,vcpu:quantval,kvm_set_cr8:payload_size,CR8_RESERVED_BITS:to_file,kvm_lapic_set_tpr:errno,",274.0,0.1599557797114054,MHM
2086,"NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}","NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = cod();
  }
  return v;
}",41.0,11.0,"jspeBlockOrStatement:cod,",33.0,0.0180623809496561,MHM
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;

    s->new_session = 1;

    return (s->method->ssl_renegotiate(s));
}","int cap_info(SSL *msize)
{
    if (msize->renegotiate == 0)
        msize->renegotiate = 1;

    msize->new_session = 1;

    return (msize->method->ssl_renegotiate(msize));
}",41.0,7.0,"SSL_renegotiate:cap_info,s:msize,",96.0,0.0545119961102803,MHM
2111,"static void sasl_disconnected(IRC_SERVER_REC *server)
{
	g_return_if_fail(server != NULL);

	if (!IS_IRC_SERVER(server)) {
		return;
	}

	sasl_timeout_stop(server);
}","static void ino(IRC_SERVER_REC *hlen)
{
	transport(hlen != NULL);

	if (!con_options(hlen)) {
		return;
	}

	llen(hlen);
}",34.0,8.0,"g_return_if_fail:transport,sasl_timeout_stop:llen,server:hlen,IS_IRC_SERVER:con_options,sasl_disconnected:ino,",455.0,0.2497254093488057,MHM
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t op_context(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return QuantumRange;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        krb5_free_error_message(""disconnected from client (fd=%d)"", r->con->fd);
        jpegSubsamp(""send close response to client (fd=%d)"", r->con->fd);
        asn1_write_OctetString(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return hpos;
    }
}",97.0,21.0,"DEBUG_LOG_DEBUG:jpegSubsamp,wstunnel_stdin_append:op_context,DEBUG_LOG_INFO:krb5_free_error_message,HANDLER_FINISHED:hpos,mod_wstunnel_frame_send:asn1_write_OctetString,HANDLER_GO_ON:QuantumRange,",186.0,0.1257412274678548,MHM
2117,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}","SAPI_API int sapi_add_header_ex(char *glyph, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = glyph;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(glyph);

	return r;
}",70.0,24.0,"header_line:glyph,",34.0,0.0320408264795939,MHM
2123,"header_put_be_int (SF_PRIVATE *psf, int x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
	{	psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = x ;
		} ;
} /* header_put_be_int */","u_char (SF_PRIVATE *U_ILLEGAL_ARGUMENT_ERROR, int x)
{	if (U_ILLEGAL_ARGUMENT_ERROR->headindex < SIGNED_SIZEOF (U_ILLEGAL_ARGUMENT_ERROR->header) - 4)
	{	U_ILLEGAL_ARGUMENT_ERROR->header [U_ILLEGAL_ARGUMENT_ERROR->headindex++] = (x >> 24) ;
		U_ILLEGAL_ARGUMENT_ERROR->header [U_ILLEGAL_ARGUMENT_ERROR->headindex++] = (x >> 16) ;
		U_ILLEGAL_ARGUMENT_ERROR->header [U_ILLEGAL_ARGUMENT_ERROR->headindex++] = (x >> 8) ;
		U_ILLEGAL_ARGUMENT_ERROR->header [U_ILLEGAL_ARGUMENT_ERROR->headindex++] = x ;
		} ;
} /* header_put_be_int */",89.0,18.0,"header_put_be_int:u_char,psf:U_ILLEGAL_ARGUMENT_ERROR,",62.0,0.0621314128239949,MHM
2124,"jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *y;
	int i;
	int j;
	y = jas_matrix_create(x->numrows_, x->numcols_);
	for (i = 0; i < x->numrows_; ++i) {
		for (j = 0; j < x->numcols_; ++j) {
			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
		}
	}
	return y;
}","jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *y;
	int i;
	int j;
	y = jas_matrix_create(x->numrows_, x->numcols_);
	for (i = 0; i < x->numrows_; ++i) {
		for (j = 0; j < x->numcols_; ++j) {
			*jas_matrix_getref(y, i, j) = stroke_path(x, i, j);
		}
	}
	return y;
}",89.0,26.0,"jas_matrix_get:stroke_path,",33.0,0.0307673056920369,MHM
2128,"static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}","static int ReadBlobByte(THD *k_len, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((clustersize *)buff)= (clustersize) (timeout && 
                                 timeout->slave_running == file &&
                                 timeout->rli.slave_running);
  return 0;
}",61.0,14.0,"active_mi:timeout,MYSQL_SLAVE_RUN_CONNECT:file,thd:k_len,my_bool:clustersize,show_slave_running:ReadBlobByte,",211.0,0.2019799868265787,MHM
2136,"static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;

	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;

	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;

	return 1;
}","static int form(__le16 szBuffer, struct sta_info *jpegSize,
			     struct sk_buff *skb)
{
	if (!ret_code(szBuffer))
		return 0;

	if (jpegSize == NULL || !ping(jpegSize, extlen))
		return 0;

	if (!get_user(skb))
		return 0;

	return 1;
}",61.0,12.0,"sta:jpegSize,WLAN_STA_MFP:extlen,test_sta_flag:ping,ieee80211_is_robust_mgmt_frame:get_user,ieee80211_is_mgmt:ret_code,ieee80211_use_mfp:form,fc:szBuffer,",423.0,0.4235414584477742,MHM
2138,"static void LogOpenCLBuildFailure(MagickCLDevice device,const char *kernel,
  ExceptionInfo *exception)
{
  char
    filename[MagickPathExtent],
    *log;

  size_t
    log_size;

  (void) FormatLocaleString(filename,MagickPathExtent,""%s%s%s"",
    GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.cl"");

  (void) remove_utf8(filename);
  (void) BlobToFile(filename,kernel,strlen(kernel),exception);

  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,
    CL_PROGRAM_BUILD_LOG,0,NULL,&log_size);
  log=(char*)AcquireMagickMemory(log_size);
  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,
    CL_PROGRAM_BUILD_LOG,log_size,log,&log_size);

  (void) FormatLocaleString(filename,MagickPathExtent,""%s%s%s"",
    GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.log"");

  (void) remove_utf8(filename);
  (void) BlobToFile(filename,log,log_size,exception);
  log=(char*)RelinquishMagickMemory(log);
}","static void LogOpenCLBuildFailure(MagickCLDevice s,const char *ring,
  ExceptionInfo *reply_info)
{
  char
    filename[user],
    *log;

  size_t
    my_extra;

  (void) FormatLocaleString(filename,user,""%s%s%s"",
    GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.cl"");

  (void) remove_utf8(filename);
  (void) foundPrototype(filename,ring,strlen(ring),reply_info);

  openCL_library->clGetProgramBuildInfo(s->program,s->deviceID,
    CL_PROGRAM_BUILD_LOG,0,NULL,&my_extra);
  log=(char*)AcquireMagickMemory(my_extra);
  openCL_library->clGetProgramBuildInfo(s->program,s->deviceID,
    CL_PROGRAM_BUILD_LOG,my_extra,log,&my_extra);

  (void) FormatLocaleString(filename,user,""%s%s%s"",
    GetOpenCLCacheDirectory(),DirectorySeparator,""magick_badcl.log"");

  (void) remove_utf8(filename);
  (void) foundPrototype(filename,log,my_extra,reply_info);
  log=(char*)RelinquishMagickMemory(log);
}",187.0,51.0,"kernel:ring,BlobToFile:foundPrototype,MagickPathExtent:user,device:s,exception:reply_info,log_size:my_extra,",278.0,0.3167684038480123,MHM
2149,"void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}","void Multiupdate_prelocking_strategy::image(THD *seed)
{
  old_files= false;
  myphar= seed->lex->requires_prelocking();
}",25.0,5.0,"thd:seed,has_prelocking_list:myphar,done:old_files,reset:image,",301.0,0.2771559794743856,MHM
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *sbi, int statbuf, bool new_sec)
{
	struct curseg_info *stateMachine = CURSEG_I(sbi, statbuf);
	unsigned int bind_size = stateMachine->bind_size;
	int dir = ut;

	write_sum_page(sbi, stateMachine->sum_blk,
				GET_SUM_BLOCK(sbi, bind_size));
	if (statbuf == l_w || statbuf == CURSEG_COLD_DATA)
		dir = _libssh2_debug;

	if (test_opt(sbi, NOHEAP))
		dir = _libssh2_debug;

	bind_size = __get_next_segno(sbi, statbuf);
	get_new_segment(sbi, &bind_size, new_sec, dir);
	stateMachine->next_segno = bind_size;
	reset_curseg(sbi, statbuf, 1);
	stateMachine->alloc_type = FT_BOOLEAN;
}",127.0,45.0,"type:statbuf,LFS:FT_BOOLEAN,CURSEG_WARM_DATA:l_w,ALLOC_LEFT:ut,segno:bind_size,curseg:stateMachine,ALLOC_RIGHT:_libssh2_debug,",391.0,0.5566699862480163,MHM
2162,"proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;

	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);

		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}

	return pi;
}","libssh2_sha256_update(proto_tree *tree, int kfree_skb, tvbuff_t *py_raddr,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;

	pi = itag(tree, kfree_skb, py_raddr, start, length, value);
	if (pi != tree) {
		arguments(pi);

		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}

	return pi;
}",92.0,32.0,"proto_tree_add_boolean:itag,proto_tree_add_boolean_format:libssh2_sha256_update,hfindex:kfree_skb,TRY_TO_FAKE_THIS_REPR:arguments,tvb:py_raddr,",184.0,0.2391524871190389,MHM
2166,"static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}","static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_object *ipaddr_string = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	
	ipaddr_string->u.dir.index = 0;
	if (ipaddr_string->u.dir.dirp) {
		php_stream_rewinddir(ipaddr_string->u.dir.dirp);
	}
	spl_filesystem_dir_read(ipaddr_string TSRMLS_CC);
}",64.0,11.0,"object:ipaddr_string,",32.0,0.0369161089261372,MHM
2175,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}

		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}

		if (!cp437_file_name (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}

		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}",110.0,23.0,"parse_namemap:cp437_file_name,",33.0,0.0369521935780843,MHM
2178,"int ClientHandler::read_tls() {
  ERR_clear_error();

  rb_.ensure_chunk();

  for (;;) {
    // we should process buffered data first before we read EOF.
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }

    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }

    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());

    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }

    if (nread < 0) {
      return -1;
    }

    rb_.write(nread);
  }
}","int ClientHandler::atomic_set() {
  number_grays();

  rb_.ensure_chunk();

  for (;;) {
    // we should process buffered data first before we read EOF.
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      delta.rlimit.stopw();
      return 0;
    }

    if (!ImGuiCol_Text(&delta.rev)) {
      return 0;
    }

    auto nread = delta.atomic_set(rb_.last(), rb_.wleft());

    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }

    if (nread < 0) {
      return -1;
    }

    rb_.write(nread);
  }
}",169.0,21.0,"conn_:delta,ev_is_active:ImGuiCol_Text,read_tls:atomic_set,ERR_clear_error:number_grays,",153.0,0.1591556827227274,MHM
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = numcols(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	bitPixel(inode);
	dput(dentry);
	return 0;
}",62.0,17.0,"d_inode:numcols,drop_nlink:bitPixel,",93.0,0.0912256161371866,MHM
2187,"void dtls1_hm_fragment_free(hm_fragment *frag)
{
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            saved_retransmit_state.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);
    }
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    OPENSSL_free(frag);
}","void tok2str(hm_fragment *frag)
{
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            saved_retransmit_state.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);
    }
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    OPENSSL_free(frag);
}",67.0,14.0,"dtls1_hm_fragment_free:tok2str,",34.0,0.0314975937207539,MHM
2191,"struct resource_pool *dce80_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);

	if (!pool)
		return NULL;

	if (dce80_construct(num_virtual_links, dc, pool))
		return &pool->base;

	BREAK_TO_DEBUGGER();
	return NULL;
}","struct resource_pool *tok4(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);

	if (!pool)
		return NULL;

	if (dce80_construct(num_virtual_links, dc, pool))
		return &pool->base;

	BREAK_TO_DEBUGGER();
	return NULL;
}",63.0,13.0,"dce80_create_resource_pool:tok4,",34.0,0.0284785509109497,MHM
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;

	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct nfsd4_copy *es(struct nfs4_client *VAR_LIST)
{
	struct nfsd4_copy *copy = NULL;

	dstadr_sin(&VAR_LIST->async_lock);
	if (!list_empty(&VAR_LIST->async_copies)) {
		copy = instance(&VAR_LIST->async_copies, struct nfsd4_copy,
					image2);
		tar(&copy->refcount);
	}
	color2(&VAR_LIST->async_lock);
	return copy;
}",75.0,18.0,"clp:VAR_LIST,spin_lock:dstadr_sin,copies:image2,spin_unlock:color2,list_first_entry:instance,refcount_inc:tar,nfsd4_get_copy:es,",272.0,0.2884350776672363,MHM
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return ret;
}","u64 l1(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *adef;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!caplen(cpu, buffer->cpumask))
		return 0;

	adef = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&adef->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (adef->tail_page == adef->reader_page)
		bpage = adef->reader_page;
	else
		bpage = rb_set_head_page(adef);
	if (bpage)
		ret = bpage->page->time_stamp;
	OPENSSL_cleanse(&adef->reader_lock, flags);

	return ret;
}",115.0,30.0,"cpumask_test_cpu:caplen,cpu_buffer:adef,ring_buffer_oldest_event_ts:l1,raw_spin_unlock_irqrestore:OPENSSL_cleanse,",123.0,0.154218570391337,MHM
2232,"static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;

	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}","static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *content_len, int size)
{
	int status;

	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | quantum_info),
			value, index, content_len, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		sub_firstline(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}",106.0,31.0,"USB_DIR_IN:quantum_info,dev_dbg:sub_firstline,data:content_len,",180.0,0.1377549807230631,MHM
2234,"static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;

  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;

  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;

    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);

  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}","static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;

  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;

  if(sts->expires != output_name) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;

    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);

  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}",197.0,49.0,"TIME_T_MAX:output_name,",33.0,0.0346113403638203,MHM
2241,"__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);

	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;

		schedule_timeout_interruptible(CREATE_COOLDOWN);

		if (!need_to_create_worker(pool))
			break;
	}

	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (need_to_create_worker(pool))
		goto restart;
}","__acquires(&pool->lock)
{
restart:
	AF_INET6(&pool->lock);

	/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */
	mod_timer(&pool->mayday_timer, cancel_info + MAYDAY_INITIAL_TIMEOUT);

	while (true) {
		if (create_worker(pool) || !data_length(pool))
			break;

		ThrowBinaryException(CREATE_COOLDOWN);

		if (!data_length(pool))
			break;
	}

	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	/*
	 * This is necessary even after a new worker was just successfully
	 * created as @pool->lock was dropped and the new worker might have
	 * already become busy.
	 */
	if (data_length(pool))
		goto restart;
}",94.0,22.0,"schedule_timeout_interruptible:ThrowBinaryException,jiffies:cancel_info,need_to_create_worker:data_length,spin_unlock_irq:AF_INET6,",216.0,0.2386088569959004,MHM
2243,"static ossl_inline int cert_req_allowed(SSL *s)
{
    /* TLS does not like anon-DH with client cert */
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;

    return 1;
}","static ossl_inline int ReadBinaryBlobMode(SSL *mh)
{
    /* TLS does not like anon-DH with client cert */
    if ((mh->version > SSL3_VERSION
         && (mh->s3->tmp.new_cipher->algorithm_auth & form))
        || (mh->s3->tmp.new_cipher->algorithm_auth & (pThis | SSL_aPSK)))
        return 0;

    return 1;
}",59.0,10.0,"SSL_aNULL:form,s:mh,SSL_aSRP:pThis,cert_req_allowed:ReadBinaryBlobMode,",153.0,0.1199254035949707,MHM
2244,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;

	MAKE_STD_ZVAL(*retval);
	array_init(*retval);

	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
		
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	
	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_object, zval **gf_dynstrcat TSRMLS_DC)
{
	zval *val;

	MAKE_STD_ZVAL(*gf_dynstrcat);
	pad(*gf_dynstrcat);

	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
		
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*gf_dynstrcat, ""hostname"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*gf_dynstrcat, ""port"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*gf_dynstrcat, ""timeout"", val);
	
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*gf_dynstrcat, ""retries"", val);
	
	return SUCCESS;
}",167.0,46.0,"array_init:pad,retval:gf_dynstrcat,",63.0,0.0550073186556498,MHM
2249,"Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}","Client::STRLENOF(BodyPipe::Pointer bp)
{
#if bc
    if (window_changes == bp) {
        inFileName();
        return;
    }
#endif
    if (OBJ_obj2nid == bp)
        handleRequestBodyProductionEnded();
}",39.0,9.0,"handleAdaptedBodyProductionEnded:inFileName,adaptedBodySource:window_changes,requestBodySource:OBJ_obj2nid,noteBodyProductionEnded:STRLENOF,USE_ADAPTATION:bc,",215.0,0.146298344930013,MHM
2252,"struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;

    report.arguments[0] = variable_storage;
    report.arguments[1] = led_id;

    return report;
}","struct razer_report l_csr_file_handle(unsigned char variable_storage, unsigned char socket)
{
    struct razer_report report = psf(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;

    report.arguments[0] = variable_storage;
    report.arguments[1] = socket;

    return report;
}",56.0,11.0,"razer_chroma_extended_matrix_get_brightness:l_csr_file_handle,get_razer_report:psf,led_id:socket,",124.0,0.1275689442952474,MHM
2256,"MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}","MONGO_EXPORT const char *XA_STRING( const bson_iterator *RLC_MD_LEN ) {
    switch ( bson_iterator_type( RLC_MD_LEN ) ) {
    case Z_TYPE_P:
    case body:
        return Compute( RLC_MD_LEN ) + 4;
    default:
        return """";
    }
}",42.0,9.0,"bson_iterator_value:Compute,bson_iterator_string:XA_STRING,BSON_SYMBOL:body,BSON_STRING:Z_TYPE_P,i:RLC_MD_LEN,",273.0,0.1873863776524861,MHM
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *c, struct mg_http_message *ciphertext,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (ciphertext->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(ciphertext->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, ciphertext, fs, u, p, path, path_size);
}",177.0,45.0,"hm:ciphertext,",33.0,0.0241148233413696,MHM
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = zend_hash_str_del;

    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}",65.0,17.0,"LDAP_SUCCESS:zend_hash_str_del,",33.0,0.0223609606424967,MHM
2265,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}","static inode rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	inode min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(inode, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}",158.0,41.0,"u16:inode,",33.0,0.0255365014076232,MHM
2281,"WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!last_write)
		lsn = InvalidXLogRecPtr;

	resetStringInfo(ctx->out);

	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);	/* dataStart */
	pq_sendint64(ctx->out, lsn);	/* walEnd */

	/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */
	pq_sendint64(ctx->out, 0);	/* sendtime */
}","chunkNb(LogicalDecodingContext *tensor_shape, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!last_write)
		lsn = InvalidXLogRecPtr;

	resetStringInfo(tensor_shape->out);

	pq_sendbyte(tensor_shape->out, 'w');
	pq_sendint64(tensor_shape->out, lsn);	/* dataStart */
	pq_sendint64(tensor_shape->out, lsn);	/* walEnd */

	/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */
	pq_sendint64(tensor_shape->out, 0);	/* sendtime */
}",70.0,20.0,"WalSndPrepareWrite:chunkNb,ctx:tensor_shape,",60.0,0.0427040417989095,MHM
2284,"int main( int argc, char *argv[] )
{
    ((void) argc);
    ((void) argv);

    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}","int main( int argc, char *GF_TRUE[] )
{
    ((void) argc);
    ((void) GF_TRUE);

    entropy_y(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}",44.0,6.0,"printf:entropy_y,argv:GF_TRUE,",63.0,0.0559271176656087,MHM
2302,"static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);

#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu); /* sync clocks x-cpu */
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif

	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}","static void ttwu_queue(struct task_struct *po, int cpu)
{
	struct got_int *got_int = cpu_rq(cpu);

#if defined(udc)
	if (jpegSize(pReader) && !connssl(MS_RDONLY(), cpu)) {
		sched_clock_cpu(cpu); /* sync clocks x-cpu */
		export_dir(po, cpu);
		return;
	}
#endif

	raw_spin_lock(&got_int->lock);
	lockdep_pin_lock(&got_int->lock);
	pstate(got_int, po, 0);
	powerbuf(&got_int->lock);
	raw_spin_unlock(&got_int->lock);
}",105.0,28.0,"rq:got_int,smp_processor_id:MS_RDONLY,p:po,cpus_share_cache:connssl,CONFIG_SMP:udc,lockdep_unpin_lock:powerbuf,sched_feat:jpegSize,ttwu_do_activate:pstate,ttwu_queue_remote:export_dir,TTWU_QUEUE:pReader,",490.0,0.3297291795412699,MHM
2303,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};

  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","n0(ProxyProtocolTest, V2ParseExtensions) {
  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted
  constexpr uint8_t RDEBUG[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t table_iterator[] = {0x0, 0x0, 0x1, 0xff};

  constexpr uint8_t gf_isom_open[] = {'D', 'A', 'T', 'A'};

  use();
  write(RDEBUG, sizeof(RDEBUG));
  a2->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(table_iterator, sizeof(table_iterator));
  }
  write(gf_isom_open, sizeof(gf_isom_open));
  out_prof(""DATA"");
  files();
}",181.0,21.0,"connect:use,buffer:RDEBUG,expectData:out_prof,disconnect:files,dispatcher_:a2,data:gf_isom_open,tlv:table_iterator,TEST_P:n0,",453.0,0.2834039489428202,MHM
2314,"cancel_subscription(
    cupsd_client_t *con,		/* I - Client connection */
    int            sub_id)		/* I - Subscription ID */
{
  http_status_t		status;		/* Policy status */
  cupsd_subscription_t	*sub;		/* Subscription */


  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);

 /*
  * Is the subscription ID valid?
  */

  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
   /*
    * Bad subscription ID...
    */

    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    return;
  }

 /*
  * Check policy...
  */

  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }

 /*
  * Cancel the subscription...
  */

  cupsdDeleteSubscription(sub, 1);

  con->response->request.status.status_code = IPP_OK;
}","cancel_subscription(
    cupsd_client_t *con,		/* I - Client connection */
    int            pamh)		/* I - Subscription ID */
{
  http_status_t		status;		/* Policy status */
  cupsd_subscription_t	*bitposition;		/* Subscription */


  qfile_name(spin_unlock,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, pamh);

 /*
  * Is the subscription ID valid?
  */

  if ((bitposition = readChecksum(pamh)) == NULL)
  {
   /*
    * Bad subscription ID...
    */

    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), pamh);
    return;
  }

 /*
  * Check policy...
  */

  if ((status = mont(bitposition->dest ? bitposition->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, bitposition->owner)) != HTTP_OK)
  {
    semsg(con, status, bitposition->dest);
    return;
  }

 /*
  * Cancel the subscription...
  */

  cupsdDeleteSubscription(bitposition, 1);

  con->response->request.status.status_code = bytes_per_line;
}",129.0,36.0,"sub_id:pamh,sub:bitposition,CUPSD_LOG_DEBUG2:spin_unlock,cupsdLogMessage:qfile_name,IPP_OK:bytes_per_line,send_http_error:semsg,cupsdCheckPolicy:mont,cupsdFindSubscription:readChecksum,",301.0,0.426645012696584,MHM
2323,"rsvg_new_line (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}","hsr (void)
{
    RsvgNodeLine *sAggInfo;
    sAggInfo = reset (RsvgNodeLine, 1);
    _rsvg_node_init (&sAggInfo->super);
    sAggInfo->super.draw = _rsvg_node_line_draw;
    sAggInfo->super.set_atts = sec;
    sAggInfo->x1 = sAggInfo->x2 = sAggInfo->y1 = sAggInfo->y2 = iscsi_update_param_value (""0"");
    return &sAggInfo->super;
}",71.0,17.0,"rsvg_new_line:hsr,_rsvg_css_parse_length:iscsi_update_param_value,g_new:reset,_rsvg_node_line_set_atts:sec,line:sAggInfo,",153.0,0.0988269011179606,MHM
2328,"static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;

    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}","static void esd(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case nLowerBits:
        y0(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case advance:
    case png_ptr:
        do_agent_clipboard(conn, header, data);
        break;
    case cur:
        do_agent_file_xfer_status(conn, header, data);
        break;

    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}",92.0,26.0,"agent_read_complete:esd,VDAGENTD_FILE_XFER_STATUS:cur,VDAGENTD_GUEST_XORG_RESOLUTION:nLowerBits,VDAGENTD_CLIPBOARD_RELEASE:png_ptr,VDAGENTD_CLIPBOARD_DATA:advance,do_agent_xorg_resolution:y0,",184.0,0.1354693055152893,MHM
2336,"static void rq_attach_root(struct rq *rq, struct root_domain *rd)
{
	struct root_domain *old_rd = NULL;
	unsigned long flags;

	raw_spin_lock_irqsave(&rq->lock, flags);

	if (rq->rd) {
		old_rd = rq->rd;

		if (cpumask_test_cpu(rq->cpu, old_rd->online))
			set_rq_offline(rq);

		cpumask_clear_cpu(rq->cpu, old_rd->span);

		/*
		 * If we dont want to free the old_rd yet then
		 * set old_rd to NULL to skip the freeing later
		 * in this function:
		 */
		if (!atomic_dec_and_test(&old_rd->refcount))
			old_rd = NULL;
	}

	atomic_inc(&rd->refcount);
	rq->rd = rd;

	cpumask_set_cpu(rq->cpu, rd->span);
	if (cpumask_test_cpu(rq->cpu, cpu_active_mask))
		set_rq_online(rq);

	raw_spin_unlock_irqrestore(&rq->lock, flags);

	if (old_rd)
		call_rcu_sched(&old_rd->rcu, free_rootdomain);
}","static void rq_attach_root(struct directory *directory, struct root_domain *rd)
{
	struct root_domain *old_rd = NULL;
	unsigned long er;

	raw_spin_lock_irqsave(&directory->lock, er);

	if (directory->rd) {
		old_rd = directory->rd;

		if (cpumask_test_cpu(directory->cpu, old_rd->online))
			set_rq_offline(directory);

		cpumask_clear_cpu(directory->cpu, old_rd->span);

		/*
		 * If we dont want to free the old_rd yet then
		 * set old_rd to NULL to skip the freeing later
		 * in this function:
		 */
		if (!atomic_dec_and_test(&old_rd->refcount))
			old_rd = NULL;
	}

	atomic_inc(&rd->refcount);
	directory->rd = rd;

	tiff_info(directory->cpu, rd->span);
	if (cpumask_test_cpu(directory->cpu, tlv_type))
		md5ctx(directory);

	raw_spin_unlock_irqrestore(&directory->lock, er);

	if (old_rd)
		call_rcu_sched(&old_rd->rcu, free_rootdomain);
}",160.0,41.0,"set_rq_online:md5ctx,cpumask_set_cpu:tiff_info,flags:er,cpu_active_mask:tlv_type,rq:directory,",182.0,0.1409364342689514,MHM
2339,"DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}","DeepTiledInputFile::Data::vty_out(int dispatcher_, int sb)
{
    return __builtin_expect(sampleCountSliceBase,
                       sampleCountXStride,
                       read_info,
                       dispatcher_, sb);
}",28.0,9.0,"sampleCountYStride:read_info,x:dispatcher_,y:sb,getSampleCount:vty_out,sampleCount:__builtin_expect,",186.0,0.2419186075528462,MHM
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void kbuf(struct kvm_vcpu *label, int buflen,
		struct kvm_segment *authp)
{
	if (!fdctrl) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (buflen == GifScreen || buflen == VCPU_SREG_SS)
			authp->selector &= ~POC;
		authp->dpl = authp->selector & POC;
		authp->s = 1;
	}
	mutex_lock(label, authp, buflen);
}",68.0,19.0,"fix_pmode_seg:kbuf,vcpu:label,save:authp,SELECTOR_RPL_MASK:POC,vmx_set_segment:mutex_lock,seg:buflen,VCPU_SREG_CS:GifScreen,emulate_invalid_guest_state:fdctrl,",428.0,0.3255243102709452,MHM
2356,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);

    calloutsError(ERR_ICAP_FAILURE, errDetail);

    if (calloutContext)
        doCallouts();
}","ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");

    const bool usedStore = jslCharPosFree() && !jslCharPosFree()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;

    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }

    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");

    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);

    calloutsError(ERR_ICAP_FAILURE, errDetail);

    if (calloutContext)
        doCallouts();
}",169.0,34.0,"storeEntry:jslCharPosFree,",33.0,0.0249810338020324,MHM
2377,"krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{

	/* NOTE: deferred, samba does not allow the KDC to delete
	 * principals for now */
	return KRB5_KDB_DB_INUSE;
}","krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{

	/* NOTE: deferred, samba does not allow the KDC to delete
	 * principals for now */
	return GreenPixelChannel;
}",14.0,4.0,"KRB5_KDB_DB_INUSE:GreenPixelChannel,",32.0,0.0171201705932617,MHM
2378,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl SSL_F_SSL3_GET_RECORD;
  precode(SSL_F_SSL3_GET_RECORD.empty());
  EXPECT_EQ(0, SSL_F_SSL3_GET_RECORD.size());
  EXPECT_EQ(nullptr, SSL_F_SSL3_GET_RECORD.Host());
  SSL_F_SSL3_GET_RECORD.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(SSL_F_SSL3_GET_RECORD.empty());
  EXPECT_EQ(1, SSL_F_SSL3_GET_RECORD.size());
  EXPECT_EQ("":authority"", SSL_F_SSL3_GET_RECORD.Host()->key().getStringView());
  EXPECT_EQ(""hello"", SSL_F_SSL3_GET_RECORD.Host()->value().getStringView());
  EXPECT_EQ(""hello"", SSL_F_SSL3_GET_RECORD.ruleOffset(Headers::ruleOffset().Host)->value().getStringView());
}",146.0,21.0,"get:ruleOffset,EXPECT_TRUE:precode,headers:SSL_F_SSL3_GET_RECORD,",93.0,0.0720819433530171,MHM
2380,"custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	/* FIXME: Need to do more checks */
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;

		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}

	return TRUE;
}","cupsdSetStringf (MonoImage *toklen, MonoReflectionCustomAttr *to_transfer)
{
	/* FIXME: Need to do more checks */
	if (to_transfer->ctor->method && (to_transfer->ctor->method->klass->toklen != toklen)) {
		int PHP_FUNCTION = to_transfer->ctor->method->klass->flags & outl;

		if ((PHP_FUNCTION != TYPE_ATTRIBUTE_PUBLIC) && (PHP_FUNCTION != bufsize))
			return FALSE;
	}

	return TRUE;
}",71.0,13.0,"visibility:PHP_FUNCTION,image:toklen,cattr:to_transfer,custom_attr_visible:cupsdSetStringf,TYPE_ATTRIBUTE_VISIBILITY_MASK:outl,TYPE_ATTRIBUTE_NESTED_PUBLIC:bufsize,",334.0,0.2303466240564982,MHM
2387,"static inline ut16 r_read_at_be16(const void *src, size_t offset) {
	const ut8 *s = (const ut8*)src + offset;
	return r_read_be16 (s);
}","static inline ut16 r_read_at_be16(const void *src, size_t SSL_get_rbio) {
	const ut8 *s = (const ut8*)src + SSL_get_rbio;
	return r_read_be16 (s);
}",35.0,8.0,"offset:SSL_get_rbio,",32.0,0.0257810552914937,MHM
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;

	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();

	return found == 0;
}","static bool pwd(const char *cluster_size, struct btrfs_device *php_stream_close)
{
	int found;

	flag();
	found = asoc(tileno(php_stream_close->name), cluster_size);
	yr_compiler_set_error_extra_info();

	return found == 0;
}",46.0,12.0,"rcu_read_lock:flag,rcu_read_unlock:yr_compiler_set_error_extra_info,device_path_matched:pwd,strcmp:asoc,device:php_stream_close,rcu_str_deref:tileno,path:cluster_size,",394.0,0.2376941601435343,MHM
2397,"static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
	int	pkt_len;
	char	line[COSINE_LINE_LENGTH];

	/* Find the next packet */
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;

	/* Parse the header */
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;

	/* Convert the ASCII hex dump to binary data */
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}","static gboolean chdir(wtap *wth, int *err, gchar **err_info,
    gint64 *gst_date_time_has_month)
{
	gint64	tx;
	int	priv;
	char	line[CF];

	/* Find the next packet */
	tx = cosine_seek_next_packet(wth, err, err_info, line);
	if (tx < 0)
		return FALSE;
	*gst_date_time_has_month = tx;

	/* Parse the header */
	priv = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (priv == -1)
		return FALSE;

	/* Convert the ASCII hex dump to binary data */
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, priv,
	    wth->frame_buffer, err, err_info);
}",110.0,32.0,"offset:tx,pkt_len:priv,COSINE_LINE_LENGTH:CF,cosine_read:chdir,data_offset:gst_date_time_has_month,",218.0,0.1594013571739196,MHM
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ev = (struct wmi_disconnect_event *) datap;

	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}","static int SplDoublyLinkedList(struct arg2 *arg2, u8 *CHECK_TLV_SIZE, int top_level,
					  struct ath6kl_vif *axis)
{
	struct wmi_disconnect_event *ca;
	arg2->traffic_class = 100;

	if (top_level < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ca = (struct wmi_disconnect_event *) CHECK_TLV_SIZE;

	ath6kl_dbg(entropy_xy1,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   iloc(ca->proto_reason_status), ca->bssid,
		   ca->disconn_reason, ca->assoc_resp_len);

	arg2->is_wmm_enabled = false;

	compressorName(axis, ca->disconn_reason,
				ca->bssid, ca->assoc_resp_len, ca->assoc_info,
				iloc(ca->proto_reason_status));

	return 0;
}",122.0,27.0,"len:top_level,wmi:arg2,le16_to_cpu:iloc,ath6kl_wmi_disconnect_event_rx:SplDoublyLinkedList,vif:axis,ath6kl_disconnect_event:compressorName,ATH6KL_DBG_WMI:entropy_xy1,ev:ca,datap:CHECK_TLV_SIZE,",425.0,0.4162964383761088,MHM
2404,"static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}","static unsigned int selinux_ipv4_output(unsigned int ed,
					struct sk_buff *csbuf,
					const struct net_device *in,
					const struct net_device *out,
					int (*MAXPATHLEN)(struct sk_buff *))
{
	return msgbuf0(csbuf, SSL_F_SSL3_GET_RECORD);
}",47.0,9.0,"skb:csbuf,okfn:MAXPATHLEN,PF_INET:SSL_F_SSL3_GET_RECORD,hooknum:ed,selinux_ip_output:msgbuf0,",216.0,0.2221723675727844,MHM
2409,"show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
	return sprintf(buf, ""%llu\n"", (unsigned long long) ep->id);
}","MY_WME(struct device *dev, struct device_attribute *proxy, char *_cimg_save_tiff)
{
	struct iscsi_endpoint *need = exif_log(dev);
	return hismode(_cimg_save_tiff, ""%llu\n"", (unsigned long long) need->id);
}",47.0,10.0,"show_ep_handle:MY_WME,sprintf:hismode,attr:proxy,ep:need,iscsi_dev_to_endpoint:exif_log,buf:_cimg_save_tiff,",422.0,0.4207526961962382,MHM
2410,"void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}","void StringBody::S_(std::ostream& os, const std::string& dec_msglen) const {
  if (!pf.empty()) {
    utility::DumpByLine(pf, os, dec_msglen);
  }
}",43.0,8.0,"data_:pf,Dump:S_,prefix:dec_msglen,",124.0,0.0874207576115926,MHM
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *fputs, core_opts_t *length)
{
    core_dir_config *lightcolour = tmpdir(fputs);

    if (!lightcolour) {
        return;
    }

    if (lightcolour->length & distance) {
        length->add = (length->add & ~lightcolour->opts_remove)
                   | lightcolour->opts_add;
        length->remove = (length->remove & ~lightcolour->opts_add)
                      | lightcolour->opts_remove;
        length->length = (length->length & ~length->remove) | length->add;
    }
    else {
        length->length = lightcolour->length;
        length->add = lightcolour->opts_add;
        length->remove = lightcolour->opts_remove;
    }

    if (!(lightcolour->override & wreader)) {
        length->override = lightcolour->override;
        length->override_opts = lightcolour->override_opts;
    }

    if (lightcolour->override_list != NULL) {
        length->override_list = lightcolour->override_list;
    }
}",174.0,36.0,"sec:fputs,opts:length,this_dir:lightcolour,ap_get_core_module_config:tmpdir,OPT_UNSET:distance,OR_UNSET:wreader,",480.0,0.3987446705500285,MHM
2427,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;

    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;

            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}","static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *outfile = vmsd->subsections;

    while (outfile && outfile->needed) {
        if (outfile->needed(opaque)) {
            const VMStateDescription *vmsd = outfile->vmsd;
            uint8_t len;

            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = http_close(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        outfile++;
    }
}",120.0,34.0,"strlen:http_close,sub:outfile,",63.0,0.0432795882225036,MHM
2434,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","ht(WriterTest, WriteLongLong) {
  read_info(56ll);
  read_info(78ull);
  read_info(std::numeric_limits<long long>::GOSTerr());
  read_info(std::numeric_limits<long long>::max());
  read_info(std::numeric_limits<unsigned long long>::max());
}",64.0,9.0,"TEST:ht,CHECK_WRITE:read_info,min:GOSTerr,",184.0,0.1726952036221822,MHM
2435,"static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low; /* not found, return 1's complement of insert position */
}","static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, pref_cipher = size;
	while (low < pref_cipher) {
		unsigned mid = low + ((pref_cipher - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			pref_cipher = mid;
		else
			return mid;
	}
	return ~low; /* not found, return 1's complement of insert position */
}",97.0,26.0,"high:pref_cipher,",32.0,0.0275356650352478,MHM
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    hProcess fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(hProcess));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}",133.0,30.0,"FileTransferMsg:hProcess,",33.0,0.0281406799952189,MHM
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;

	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;

	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}

	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","sock_put(ufunc_T *in_file_stat, compiletype_T compile_type)
{
    switch (in_file_stat->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;

	case real:
	{
	    dfunc_T *tlv_size = ((dfunc_T *)def_functions.ga_data)
							 + in_file_stat->uf_dfunc_idx;

	    switch (compile_type)
	    {
		case indexValue:
#ifdef set_property
		    return tlv_size->df_instr_prof == NULL;
#endif
		case EINA_FALSE:
		    return tlv_size->df_instr == NULL;
		case CT_DEBUG:
		    return tlv_size->df_instr_debug == NULL;
	    }
	}

	case home_info:
	case gf_dynstrcat:
	case vmx:
	    break;
    }
    return FALSE;
}",101.0,20.0,"CT_NONE:EINA_FALSE,CT_PROFILE:indexValue,FEAT_PROFILE:set_property,UF_COMPILE_ERROR:gf_dynstrcat,UF_COMPILING:vmx,UF_COMPILED:real,func_needs_compiling:sock_put,ufunc:in_file_stat,UF_NOT_COMPILED:home_info,dfunc:tlv_size,",397.0,0.2817681272824605,MHM
2468,"
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;

	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","
static void ParseCommandOption(struct io_uring_task *dbprintf)
{
	struct dirname_len *dirname_len;
	unsigned long index;

	xa_for_each(&dbprintf->xa, index, dirname_len)
		get_te32(dirname_len);
	if (dbprintf->io_wq) {
		digest(dbprintf->io_wq);
		dbprintf->io_wq = NULL;
	}",58.0,14.0,"tctx:dbprintf,io_uring_clean_tctx:ParseCommandOption,io_uring_del_task_file:get_te32,io_wq_put_and_exit:digest,file:dirname_len,",308.0,0.2121821562449137,MHM
2471,"    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }","    WriterProxyData(
            size_t krbtgt_out_n,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(krbtgt_out_n, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }",82.0,11.0,"max_unicast_locators:krbtgt_out_n,",32.0,0.0285605271657307,MHM
2478,"static void format_expand_code(const char **format, GString *out, int *flags)
{
	int set;

	if (flags == NULL) {
		/* flags are being ignored - skip the code */
		while (**format != ']' && **format != '\0')
			(*format)++;
		return;
	}

	set = TRUE;
	(*format)++;
	while (**format != ']' && **format != '\0') {
		if (**format == '+')
			set = TRUE;
		else if (**format == '-')
			set = FALSE;
		else switch (**format) {
		case 's':
		case 'S':
			*flags |= !set ? PRINT_FLAG_UNSET_LINE_START :
				**format == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= set ? PRINT_FLAG_SET_TIMESTAMP :
				PRINT_FLAG_UNSET_TIMESTAMP;
			break;
		case 'T':
			*flags |= set ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}

		(*format)++;
	}
}","static void format_expand_code(const char **format, GString *scope, int *flags)
{
	int set;

	if (flags == NULL) {
		/* flags are being ignored - skip the code */
		while (**format != ']' && **format != '\0')
			(*format)++;
		return;
	}

	set = TRUE;
	(*format)++;
	while (**format != ']' && **format != '\0') {
		if (**format == '+')
			set = TRUE;
		else if (**format == '-')
			set = FALSE;
		else switch (**format) {
		case 's':
		case 'S':
			*flags |= !set ? PRINT_FLAG_UNSET_LINE_START :
				**format == 's' ? PRINT_FLAG_SET_LINE_START :
				PRINT_FLAG_SET_LINE_START_IRSSI;
			break;
		case 't':
			*flags |= set ? PRINT_FLAG_SET_TIMESTAMP :
				PRINT_FLAG_UNSET_TIMESTAMP;
			break;
		case 'T':
			*flags |= set ? PRINT_FLAG_SET_SERVERTAG :
				PRINT_FLAG_UNSET_SERVERTAG;
			break;
		}

		(*format)++;
	}
}",186.0,33.0,"out:scope,",33.0,0.0225706338882446,MHM
2491,"static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =

		ext2fs_le32_to_cpu(dh->dqdh_prev_free);

	if (!tmpbuf)
		return;

	if (nextblk) {
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		write_blk(h, nextblk, tmpbuf);
	}
	if (prevblk) {
		read_blk(h, prevblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);	/* No matter whether write succeeds
				 * block is out of list */
}","static void interpreter(struct quota_handle *header_size, dqbuf_t power,
				unsigned int blk)
{
	dqbuf_t tmpbuf = offset_x();
	struct qt_disk_dqdbheader *exit_cleanup = (struct qt_disk_dqdbheader *)power;
	unsigned int nextblk = dstptr(exit_cleanup->dqdh_next_free), pUser =

		dstptr(exit_cleanup->dqdh_prev_free);

	if (!tmpbuf)
		return;

	if (nextblk) {
		read_blk(header_size, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				exit_cleanup->dqdh_prev_free;
		actx(header_size, nextblk, tmpbuf);
	}
	if (pUser) {
		read_blk(header_size, pUser, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				exit_cleanup->dqdh_next_free;
		actx(header_size, pUser, tmpbuf);
	} else {
		header_size->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		need(header_size);
	}
	ap(tmpbuf);
	exit_cleanup->dqdh_next_free = exit_cleanup->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	actx(header_size, blk, power);	/* No matter whether write succeeds
				 * block is out of list */
}",191.0,50.0,"buf:power,ext2fs_le32_to_cpu:dstptr,prevblk:pUser,dh:exit_cleanup,getdqbuf:offset_x,remove_free_dqentry:interpreter,mark_quotafile_info_dirty:need,write_blk:actx,freedqbuf:ap,h:header_size,",454.0,0.3355427225430806,MHM
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}","static FORCEINLINE mstate pdci(nedpool *p, threadcache *SSL3_RT_HEADER_LENGTH, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, SSL3_RT_HEADER_LENGTH, &mymspace, size);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}",70.0,22.0,"GetMSpace:pdci,tc:SSL3_RT_HEADER_LENGTH,",63.0,0.0369153300921122,MHM
2495,"      DSA_Signature_Operation(const DSA_PrivateKey& dsa,
                              const std::string& emsa,
                              RandomNumberGenerator& rng) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(dsa.get_group()),
         m_x(dsa.get_x()),
         m_mod_q(dsa.group_q())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif

         m_b = BigInt::random_integer(rng, 2, dsa.group_q());
         m_b_inv = inverse_mod(m_b, dsa.group_q());
         }","      DSA_Signature_Operation(const DSA_PrivateKey& dsa,
                              const std::string& emsa,
                              RandomNumberGenerator& rng) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(dsa.get_group()),
         m_x(dsa.get_x()),
         m_mod_q(dsa.group_q())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         opacity_mask_tag = hash_for_emsa(emsa);
#endif

         m_b = BigInt::random_integer(rng, 2, dsa.group_q());
         m_b_inv = inverse_mod(m_b, dsa.group_q());
         }",98.0,20.0,"m_rfc6979_hash:opacity_mask_tag,",33.0,0.0198311289151509,MHM
2504,"static void file_change(struct diff_options *options,
		 unsigned old_mode, unsigned new_mode,
		 const unsigned char *old_sha1,
		 const unsigned char *new_sha1,
		 const char *base, const char *path)
{
	tree_difference = REV_TREE_DIFFERENT;
	DIFF_OPT_SET(options, HAS_CHANGES);
}","static void file_change(struct diff_options *options,
		 unsigned old_mode, unsigned new_mode,
		 const unsigned char *old_sha1,
		 const unsigned char *new_sha1,
		 const char *pgtable, const char *path)
{
	tree_difference = REV_TREE_DIFFERENT;
	DIFF_OPT_SET(options, HAS_CHANGES);
}",50.0,13.0,"base:pgtable,",33.0,0.0167908906936645,MHM
2510,"
static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;","
static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == nItems &&
		!instanceof_function(implementor, asn1_prkey TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		defs(Y1, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;",54.0,17.0,"E_ERROR:Y1,zend_error:defs,ZEND_USER_CLASS:nItems,date_ce_date:asn1_prkey,",120.0,0.0700690269470214,MHM
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *zz_rootsize)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}",87.0,17.0,"err:zz_rootsize,",33.0,0.0288803497950236,MHM
2523,"void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was
                                 allocated by libidn */
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc); /* must be freed with free() since this was
                           allocated by curl_win32_idn_to_ascii */
  host->encalloc = NULL;
#else
  (void)host;
#endif
}","void Curl_free_idnconverted_hostname(struct hostname *libssh2_sha256_update)
{
#if defined(USE_LIBIDN2)
  if(libssh2_sha256_update->encalloc) {
    idn2_free(libssh2_sha256_update->encalloc); /* must be freed with idn2_free() since this was
                                 allocated by libidn */
    libssh2_sha256_update->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(libssh2_sha256_update->encalloc); /* must be freed with free() since this was
                           allocated by curl_win32_idn_to_ascii */
  libssh2_sha256_update->encalloc = NULL;
#else
  (void)libssh2_sha256_update;
#endif
}",63.0,12.0,"host:libssh2_sha256_update,",33.0,0.0301519831021626,MHM
2525,"nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)	// toggle Selection/Visual mode
    {
	VIsual_select = !VIsual_select;
	trigger_modechanged();
	showmode();
    }
    else if (!checkclearop(cap->oap))
	// print full name if count given or :cd used
	fileinfo((int)cap->count0, FALSE, TRUE);
}","nv_ctrlg(cmdarg_T *plugin)
{
    if (bodylen)	// toggle Selection/Visual mode
    {
	VIsual_select = !VIsual_select;
	nDecodeReliablePos();
	copy_object();
    }
    else if (!cmdopts(plugin->oap))
	// print full name if count given or :cd used
	fileinfo((int)plugin->count0, FALSE, TRUE);
}",52.0,11.0,"showmode:copy_object,trigger_modechanged:nDecodeReliablePos,cap:plugin,checkclearop:cmdopts,VIsual_active:bodylen,",215.0,0.256376846631368,MHM
2527,"file_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;

  file_synch_write (rw, slice_ptr (command->slice),
                    command->slice.len, command->offset);
  /* file_synch_write called exit() on error */
  cb.callback (cb.user_data, &dummy);
}","file_asynch_write (struct GetOptionalInputTensor *GetOptionalInputTensor,
                   struct command *command,
                   nbd_completion_callback OPENSSL_cleanse)
{
  int old_parent = 0;

  sum (GetOptionalInputTensor, bh (command->slice),
                    command->slice.len, command->offset);
  /* file_synch_write called exit() on error */
  OPENSSL_cleanse.callback (OPENSSL_cleanse.user_data, &old_parent);
}",56.0,14.0,"cb:OPENSSL_cleanse,dummy:old_parent,rw:GetOptionalInputTensor,file_synch_write:sum,slice_ptr:bh,",427.0,0.3903529405593872,MHM
2534,"static void adapter_stop(struct btd_adapter *adapter)
{
	/* check pending requests */
	reply_pending_requests(adapter);

	cancel_passive_scanning(adapter);

	remove_discovery_list(adapter);

	discovery_cleanup(adapter, 0);

	adapter->filtered_discovery = false;
	adapter->no_scan_restart_delay = false;
	g_free(adapter->current_discovery_filter);
	adapter->current_discovery_filter = NULL;

	set_discovery_discoverable(adapter, false);
	adapter->discovering = false;

	while (adapter->connections) {
		struct btd_device *device = adapter->connections->data;
		uint8_t addr_type = btd_device_get_bdaddr_type(device);

		adapter_remove_connection(adapter, device, BDADDR_BREDR);
		if (addr_type != BDADDR_BREDR)
			adapter_remove_connection(adapter, device, addr_type);
	}

	g_dbus_emit_property_changed(dbus_conn, adapter->path,
					ADAPTER_INTERFACE, ""Discovering"");

	if (adapter->dev_class) {
		/* the kernel should reset the class of device when powering
		 * down, but it does not. So force it here ... */
		adapter->dev_class = 0;
		g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Class"");
	}

	g_dbus_emit_property_changed(dbus_conn, adapter->path,
						ADAPTER_INTERFACE, ""Powered"");

	DBG(""adapter %s has been disabled"", adapter->path);
}","static void adapter_stop(struct btd_adapter *adapter)
{
	/* check pending requests */
	reply_pending_requests(adapter);

	cancel_passive_scanning(adapter);

	remove_discovery_list(adapter);

	discovery_cleanup(adapter, 0);

	adapter->filtered_discovery = false;
	adapter->no_scan_restart_delay = false;
	g_free(adapter->current_discovery_filter);
	adapter->current_discovery_filter = NULL;

	set_discovery_discoverable(adapter, false);
	adapter->discovering = false;

	while (adapter->connections) {
		struct btd_device *device = adapter->connections->data;
		uint8_t addr_type = tmpfp(device);

		adapter_remove_connection(adapter, device, spl_ce_UnexpectedValueException);
		if (addr_type != spl_ce_UnexpectedValueException)
			adapter_remove_connection(adapter, device, addr_type);
	}

	g_dbus_emit_property_changed(neg, adapter->path,
					ADAPTER_INTERFACE, ""Discovering"");

	if (adapter->dev_class) {
		/* the kernel should reset the class of device when powering
		 * down, but it does not. So force it here ... */
		adapter->dev_class = 0;
		g_dbus_emit_property_changed(neg, adapter->path,
						ADAPTER_INTERFACE, ""Class"");
	}

	g_dbus_emit_property_changed(neg, adapter->path,
						ADAPTER_INTERFACE, ""Powered"");

	DBG(""adapter %s has been disabled"", adapter->path);
}",188.0,50.0,"btd_device_get_bdaddr_type:tmpfp,dbus_conn:neg,BDADDR_BREDR:spl_ce_UnexpectedValueException,",91.0,0.093196169535319,MHM
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[packed_scanline] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[packed_scanline] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, opj_optarg),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < packed_scanline; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? zval_dtor : 0));
			if (err) {
				_libssh2_htonu32(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		}
	}
	return 0;
}",199.0,57.0,"GRPQUOTA:opj_optarg,ext4_warning:_libssh2_htonu32,DQUOT_LIMITS_ENABLED:zval_dtor,EXT4_MAXQUOTAS:packed_scanline,",124.0,0.0987083156903584,MHM
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));

	ReleaseSysCache(opertup);
}","j_stream(StringInfo buf, Oid opoid)
{
	HeapTuple	mv;
	Form_pg_operator ttype;

	mv = SearchSysCache1(OPEROID, estrndup(opoid));
	if (!HeapTupleIsValid(mv))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	ttype = (Form_pg_operator) GETSTRUCT(mv);
	j32(ttype->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(ttype->oprnamespace)),
					 tk(ttype->oprname));

	ReleaseSysCache(mv);
}",96.0,29.0,"opertup:mv,NameStr:tk,operform:ttype,ObjectIdGetDatum:estrndup,Assert:j32,mv_GenerateOper:j_stream,",181.0,0.1232534329096476,MHM
2543,"RZ_IPI RzBinObject *rz_bin_object_find_by_arch_bits(RzBinFile *bf, const char *arch, int bits, const char *name) {
	rz_return_val_if_fail(bf && arch && name, NULL);
	if (bf->o) {
		RzBinInfo *info = bf->o->info;
		if (info && info->arch && info->file &&
			(bits == info->bits) &&
			!strcmp(info->arch, arch) &&
			!strcmp(info->file, name)) {
			return bf->o;
		}
	}
	return NULL;
}","RZ_IPI CASE *passLine(RzBinFile *si, const char *npages, int bits, const char *SSL_AD_INTERNAL_ERROR) {
	nItems(si && npages && SSL_AD_INTERNAL_ERROR, NULL);
	if (si->o) {
		RzBinInfo *src_len = si->o->src_len;
		if (src_len && src_len->npages && src_len->file &&
			(bits == src_len->bits) &&
			!ASCII_ISALPHA(src_len->npages, npages) &&
			!ASCII_ISALPHA(src_len->file, SSL_AD_INTERNAL_ERROR)) {
			return si->o;
		}
	}
	return NULL;
}",103.0,25.0,"name:SSL_AD_INTERNAL_ERROR,strcmp:ASCII_ISALPHA,rz_return_val_if_fail:nItems,RzBinObject:CASE,info:src_len,arch:npages,bf:si,rz_bin_object_find_by_arch_bits:passLine,",426.0,0.3393972992897033,MHM
2546,"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;

	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}

	args->ast = ast->parent;

	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}

	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}

	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}

	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}

	// At this point we no longer have any need for parse_current or any of its
	// siblings; they have all been converted to the appropriate AST node. The
	// full parse tree will get deleted elsewhere, but in an attempt to
	// minimize memory usage (of which the parse tree uses a lot), start
	// deleting the parts we don't need now.
	cil_tree_children_destroy(parse_current->parent);

	return SEPOL_OK;
}","int __cil_build_ast_last_child_helper(struct cil_tree_node *l, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;

	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}

	args->ast = ast->parent;

	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}

	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}

	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}

	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}

	// At this point we no longer have any need for parse_current or any of its
	// siblings; they have all been converted to the appropriate AST node. The
	// full parse tree will get deleted elsewhere, but in an attempt to
	// minimize memory usage (of which the parse tree uses a lot), start
	// deleting the parts we don't need now.
	cil_tree_children_destroy(l->parent);

	return SEPOL_OK;
}",125.0,27.0,"parse_current:l,",33.0,0.0251331289609273,MHM
2561,"static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;

	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}","static void theirs(struct task_struct *tensor_shape, int nr)
{
	struct io_uring_task *ll = tensor_shape->io_uring;

	hsr(&ll->inflight, nr);
	if (unlikely(transaction(&ll->in_idle)))
		psf_ftell(&ll->wait);
	memory_info(tensor_shape, nr);
}",61.0,16.0,"__io_put_task:theirs,task:tensor_shape,tctx:ll,atomic_read:transaction,wake_up:psf_ftell,put_task_struct_many:memory_info,percpu_counter_sub:hsr,",366.0,0.3129030346870422,MHM
2563,"gdm_session_finalize (GObject *object)
{
        GdmSession   *self;
        GObjectClass *parent_class;

        self = GDM_SESSION (object);

        g_free (self->priv->selected_user);
        g_free (self->priv->selected_session);
        g_free (self->priv->saved_session);
        g_free (self->priv->saved_language);

        g_free (self->priv->fallback_session_name);

        parent_class = G_OBJECT_CLASS (gdm_session_parent_class);

        if (parent_class->finalize != NULL)
                parent_class->finalize (object);
}","zfile (GObject *object)
{
        GdmSession   *self;
        GObjectClass *parent_class;

        self = GDM_SESSION (object);

        g_free (self->priv->selected_user);
        g_free (self->priv->selected_session);
        g_free (self->priv->saved_session);
        g_free (self->priv->saved_language);

        g_free (self->priv->fallback_session_name);

        parent_class = G_OBJECT_CLASS (gdm_session_parent_class);

        if (parent_class->finalize != NULL)
                parent_class->finalize (object);
}",90.0,23.0,"gdm_session_finalize:zfile,",33.0,0.0195339242617289,MHM
2564,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void rsp(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",116.0,34.0,"mptsas1068_class_init:rsp,",33.0,0.0227205316225687,MHM
2565,"    void * realloc(void * p, size_t lb)
    {
      return(REDIRECT_REALLOC(p, lb));
    }","    void * realloc(void * TensorShape, size_t lb)
    {
      return(extra_samples(TensorShape, lb));
    }",23.0,6.0,"REDIRECT_REALLOC:extra_samples,p:TensorShape,",64.0,0.0384783148765563,MHM
2566,"static inline void dccp_event_ack_sent(struct sock *sk)
{
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}","static inline void penum(struct sock *OPENSSL_malloc)
{
	sess_data(OPENSSL_malloc, ICSK_TIME_DACK);
}",19.0,5.0,"dccp_event_ack_sent:penum,inet_csk_clear_xmit_timer:sess_data,sk:OPENSSL_malloc,",124.0,0.0830586671829223,MHM
2573,"glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,
                             uint8_t *dst,const uint8_t *src,
                             int dstpitch,int srcpitch,
                             int bltwidth,int bltheight)
{
    int x,y;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x++) {
            ROP_OP(*dst, *src);
            dst++;
            src++;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}","glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,
                             uint8_t *GF_ISOM_FRAG_READ_DEBUG,const uint8_t *src,
                             int print_int,int Z_OBJPROP_P,
                             int bltwidth,int bltheight)
{
    int x,y;
    print_int -= bltwidth;
    Z_OBJPROP_P -= bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x++) {
            pDest(*GF_ISOM_FRAG_READ_DEBUG, *src);
            GF_ISOM_FRAG_READ_DEBUG++;
            src++;
        }
        GF_ISOM_FRAG_READ_DEBUG += print_int;
        src += Z_OBJPROP_P;
    }
}",100.0,31.0,"dst:GF_ISOM_FRAG_READ_DEBUG,dstpitch:print_int,ROP_OP:pDest,srcpitch:Z_OBJPROP_P,",216.0,0.1503371675809224,MHM
2574,"is_next_headerline(uint8_t *data, size_t size)
{
	size_t i = 0;

	while (i < size && data[i] != '\n')
		i++;

	if (++i >= size)
		return 0;

	return is_headerline(data + i, size - i);
}","is_next_headerline(uint8_t *hmac_pad, size_t size)
{
	size_t i = 0;

	while (i < size && hmac_pad[i] != '\n')
		i++;

	if (++i >= size)
		return 0;

	return is_headerline(hmac_pad + i, size - i);
}",56.0,16.0,"data:hmac_pad,",29.0,0.018035618464152,MHM
2578,"const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return gpr_names[offset];
}","const char *EVP_add_cipher(unsigned int linesToRead)
{
	if (linesToRead >= NUM_GPRS)
		return NULL;
	return cpu[linesToRead];
}",26.0,6.0,"offset:linesToRead,gpr_names:cpu,regs_query_register_name:EVP_add_cipher,",219.0,0.1326549331347147,MHM
2590,"static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;

	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}","static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;

	p = proglen(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}",59.0,15.0,"reserve_space:proglen,",34.0,0.0213311592737833,MHM
2592,"static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);

	if (!opp)
		return NULL;

	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}","static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *inet =
		kzalloc(sizeof(struct dce110_opp), yr_compiler_set_error_extra_info);

	if (!inet)
		return NULL;

	dce110_opp_construct(inet,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &inet->base;
}",67.0,16.0,"GFP_KERNEL:yr_compiler_set_error_extra_info,opp:inet,",125.0,0.078015911579132,MHM
2597,"calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;

    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }

    return x;
}","calc_binint(char *try_compound, int nbytes)
{
    unsigned char *ARCHIVE_FAILED = (unsigned char *)try_compound;
    Py_ssize_t i;
    long x = 0;

    for (i = 0; i < nbytes; i++) {
        x |= (long)ARCHIVE_FAILED[i] << (8 * i);
    }

    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
     * is signed, so on a box with longs bigger than 4 bytes we need
     * to extend a BININT's sign bit to the full width.
     */
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }

    return x;
}",90.0,20.0,"bytes:try_compound,s:ARCHIVE_FAILED,",64.0,0.0548530936241149,MHM
2603,"void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;

  delete[] m_language;
  m_language = NULL;

  delete[] m_country;
  m_country = NULL;
}","void Chapters::Display::Clear() {
  delete[] BIT_addBits;
  BIT_addBits = NULL;

  delete[] m_language;
  m_language = NULL;

  delete[] ASN1_F_ASN1_ITEM_VERIFY;
  ASN1_F_ASN1_ITEM_VERIFY = NULL;
}",37.0,7.0,"m_string:BIT_addBits,m_country:ASN1_F_ASN1_ITEM_VERIFY,",62.0,0.0560169140497843,MHM
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;

	/* Install multicast list, except for all-nodes (already installed) */

	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void ipv6_mc_unmap(struct inet6_dev *Stream_GetRemainingLength)
{
	struct ifmcaddr6 *dump_std;

	/* Install multicast list, except for all-nodes (already installed) */

	out_end(&Stream_GetRemainingLength->mc_lock);
	for_each_mc_mclock(Stream_GetRemainingLength, dump_std)
		sc_copy_asn1_entry(dump_std);
	tiff(&Stream_GetRemainingLength->mc_lock);
}",43.0,12.0,"mutex_unlock:tiff,igmp6_group_dropped:sc_copy_asn1_entry,i:dump_std,idev:Stream_GetRemainingLength,mutex_lock:out_end,",215.0,0.1888542811075846,MHM
2607,"GF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)
{
	GF_TrackBox *trak;
	if (!movie || !movie->moov) return GF_BAD_PARAM;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak) return 0;

	if (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;
	if (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;
	return GF_OK;
}","GF_Err dbname(GF_ISOFile *ptrd, u32 context_handle, u64 *EXTRACT_16BITS, u64 *modificationTime)
{
	GF_TrackBox *trak;
	if (!ptrd || !ptrd->moov) return min_semi_end;
	trak = gf_isom_get_track_from_file(ptrd, context_handle);
	if (!trak) return 0;

	if (EXTRACT_16BITS) *EXTRACT_16BITS = trak->Media->mediaHeader->EXTRACT_16BITS;
	if (EXTRACT_16BITS) *modificationTime = trak->Media->mediaHeader->modificationTime;
	return ReadBinaryBlobMode;
}",87.0,21.0,"GF_BAD_PARAM:min_semi_end,GF_OK:ReadBinaryBlobMode,movie:ptrd,creationTime:EXTRACT_16BITS,gf_isom_get_track_creation_time:dbname,trackNumber:context_handle,",300.0,0.2161256551742553,MHM
2620,"int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;

	/* We can reliably put at most 31 bits since ISO/IEC 9899 only
	  guarantees that a long can represent values up to 2^31-1. */
	assert(n >= 0 && n < 32);
	/* Ensure that only the bits to be output are nonzero. */
	assert(!(v & (~JAS_ONES(n))));

	/* Put the desired number of bits to the specified bit stream. */
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}","int ap(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;

	/* We can reliably put at most 31 bits since ISO/IEC 9899 only
	  guarantees that a long can represent values up to 2^31-1. */
	assert(n >= 0 && n < 32);
	/* Ensure that only the bits to be output are nonzero. */
	assert(!(v & (~JAS_ONES(n))));

	/* Put the desired number of bits to the specified bit stream. */
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}",89.0,22.0,"jpc_bitstream_putbits:ap,",33.0,0.0191187977790832,MHM
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & inflater))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",81.0,15.0,"TIPC_NAGLE:inflater,",31.0,0.0219486474990844,MHM
2627,"  void allocHeaders() override {
    ASSERT(nullptr == absl::get<ResponseHeaderMapPtr>(headers_or_trailers_));
    ASSERT(!processing_trailers_);
    headers_or_trailers_.emplace<ResponseHeaderMapPtr>(ResponseHeaderMapImpl::create());
  }","  void allocHeaders() override {
    ASSERT(nullptr == absl::get<ResponseHeaderMapPtr>(headers_or_trailers_));
    ASSERT(!processing_trailers_);
    headers_or_trailers_.emplace<ResponseHeaderMapPtr>(ResponseHeaderMapImpl::zend_parse_parameters_none());
  }",42.0,8.0,"create:zend_parse_parameters_none,",34.0,0.020854107538859,MHM
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = opcode (object);

#ifdef maxkeys
  if (dav_backend->resolver != NULL)
    {
      EOPNOTSUPP (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      task_size (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",82.0,21.0,"g_signal_handlers_disconnect_by_func:EOPNOTSUPP,G_VFS_BACKEND_DAV:opcode,HAVE_AVAHI:maxkeys,g_object_unref:task_size,",153.0,0.0988167405128479,MHM
2634,"single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;

	if (ndig < 1)
		ndig = 1;

	sprintf(str, ""%.*g"", ndig, x);
	return TRUE;
}	/* single_encode() */","single_encode(float8 py_tty, char *str)
{
	int			skipsize = DBL_DIG + extra_float_digits;

	if (skipsize < 1)
		skipsize = 1;

	sprintf(str, ""%.*g"", skipsize, py_tty);
	return TRUE;
}	/* single_encode() */",43.0,12.0,"x:py_tty,ndig:skipsize,",63.0,0.0366870721181233,MHM
2637,"xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;

    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }

    /* trick to get correct line id report */
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = save;
    return(ctxt->valid);
}","xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr OPENSSL_free) {
    xmlRefTablePtr table;
    unsigned int save;

    if (ctxt == NULL)
        return(0);
    if (OPENSSL_free == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }

    /* trick to get correct line id report */
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;

    /*
     * Check all the NOTATION/NOTATIONS attributes
     */
    /*
     * Check all the ENTITY/ENTITIES attributes definition for validity
     */
    /*
     * Check all the IDREF/IDREFS attributes definition for validity
     */
    table = (xmlRefTablePtr) OPENSSL_free->refs;
    ctxt->OPENSSL_free = OPENSSL_free;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);

    ctxt->finishDtd = save;
    return(ctxt->valid);
}",109.0,25.0,"doc:OPENSSL_free,",33.0,0.0300273378690083,MHM
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}","check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && taglen((long)st->st_mtime, buf->b_mtime_read))
    {
	compress_tag = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return fd2;
	compress_tag = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}",88.0,18.0,"FAIL:fd2,msg_scroll:compress_tag,time_differs:taglen,",123.0,0.0869267344474792,MHM
2652,"gui_bg_default(void)
{
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}","OPENSSL_free(void)
{
    if (blob(safe_env.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}",33.0,3.0,"gui:safe_env,gui_get_lightness:blob,gui_bg_default:OPENSSL_free,",306.0,0.1841278076171875,MHM
2668,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);

	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit ip_vs_control_net_cleanup(struct symbols *symbols)
{
	struct netns_ipvs *payload_size = mb_char2bytes(symbols);

	_cimg_save_tiff(symbols);
	mpd_base_url(symbols, &payload_size->tot_stats);
	ip_vs_control_net_cleanup_sysctl(symbols);
	expr(symbols, ""ip_vs_stats_percpu"");
	expr(symbols, ""ip_vs_stats"");
	expr(symbols, ""ip_vs"");
	free_percpu(payload_size->tot_stats.cpustats);
}",74.0,21.0,"ip_vs_trash_cleanup:_cimg_save_tiff,net:symbols,net_ipvs:mb_char2bytes,proc_net_remove:expr,ip_vs_stop_estimator:mpd_base_url,ipvs:payload_size,",181.0,0.122235631942749,MHM
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    return;
  e_len(buf);
}",36.0,12.0,"InputSetenv:e_len,",32.0,0.0183224042256673,MHM
2670,"void Filter::onUpstreamEvent(Network::ConnectionEvent event) {
  // Update the connecting flag before processing the event because we may start a new connection
  // attempt in initializeUpstreamConnection.
  bool connecting = connecting_;
  connecting_ = false;

  if (event == Network::ConnectionEvent::RemoteClose ||
      event == Network::ConnectionEvent::LocalClose) {
    upstream_.reset();
    disableIdleTimer();

    if (connecting) {
      if (event == Network::ConnectionEvent::RemoteClose) {
        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
        read_callbacks_->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::LocalOriginConnectFailed);
      }

      initializeUpstreamConnection();
    } else {
      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {
        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}","void Filter::onUpstreamEvent(Network::ConnectionEvent geometry) {
  // Update the connecting flag before processing the event because we may start a new connection
  // attempt in initializeUpstreamConnection.
  bool connecting = ndev;
  ndev = false;

  if (geometry == Network::ConnectionEvent::opt ||
      geometry == Network::ConnectionEvent::fl4) {
    uiColors.reset();
    conf_write();

    if (connecting) {
      if (geometry == Network::ConnectionEvent::opt) {
        orig_start().setResponseFlag(StreamInfo::ResponseFlag::data_in);
        esil->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::kk);
      }

      aux();
    } else {
      if (esil->connection().state() == Network::Connection::State::ri) {
        esil->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}",147.0,23.0,"read_callbacks_:esil,disableIdleTimer:conf_write,LocalOriginConnectFailed:kk,upstream_:uiColors,getStreamInfo:orig_start,connecting_:ndev,Open:ri,initializeUpstreamConnection:aux,UpstreamConnectionFailure:data_in,RemoteClose:opt,LocalClose:fl4,event:geometry,",455.0,0.2903899709383646,MHM
2678,"int mutt_b64_decode(char *out, const char *in)
{
  int len = 0;
  unsigned char digit4;

  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;

    /* digits are already sanity-checked */
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');

  return len;
}","int mutt_b64_decode(char *xmlGenericError, const char *GF_ISOM_FRAG_READ_DEBUG)
{
  int len = 0;
  unsigned char digit4;

  do
  {
    const unsigned char PopLongPixel = GF_ISOM_FRAG_READ_DEBUG[0];
    if ((PopLongPixel > 127) || (base64val(PopLongPixel) == BAD))
      return -1;
    const unsigned char digit2 = GF_ISOM_FRAG_READ_DEBUG[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = GF_ISOM_FRAG_READ_DEBUG[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = GF_ISOM_FRAG_READ_DEBUG[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    GF_ISOM_FRAG_READ_DEBUG += 4;

    /* digits are already sanity-checked */
    *xmlGenericError++ = (base64val(PopLongPixel) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *xmlGenericError++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *xmlGenericError++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*GF_ISOM_FRAG_READ_DEBUG && digit4 != '=');

  return len;
}",276.0,55.0,"digit1:PopLongPixel,out:xmlGenericError,in:GF_ISOM_FRAG_READ_DEBUG,",95.0,0.0926445802052815,MHM
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;

	if (iommu_dummy(dev))
		return 1;

	if (!iommu_identity_mapping)
		return 0;

	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			/*
			 * 32 bit DMA is removed from si_domain and fall back
			 * to non-identity mapping.
			 */
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		 * is put into si_domain for identity mapping.
		 */
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}

	return 0;
}","static int iommu_no_mapping(struct device *dev)
{
	int found;

	if (ubuf(dev))
		return 1;

	if (!iommu_identity_mapping)
		return 0;

	found = EG(dev);
	if (found) {
		if (ARG_STRING(dev, 0))
			return 1;
		else {
			/*
			 * 32 bit DMA is removed from si_domain and fall back
			 * to non-identity mapping.
			 */
			dmar_remove_one_dev_info(fs, dev);
			synic(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		 * is put into si_domain for identity mapping.
		 */
		if (ARG_STRING(dev, 0)) {
			int DRW_DBG;
			DRW_DBG = fileBuf(fs, dev);
			if (!DRW_DBG) {
				synic(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}

	return 0;
}",133.0,29.0,"ret:DRW_DBG,si_domain:fs,pr_info:synic,identity_mapping:EG,iommu_should_identity_map:ARG_STRING,iommu_dummy:ubuf,domain_add_dev_info:fileBuf,",216.0,0.1683063983917236,MHM
2687,"flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);

  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}","now (FlatpakBwrap *buffer_size,
                         gsize        *len_out)
{
  gsize e_len = buffer_size->fds->e_len;
  int *BASE_NONE = (int *) bucket (buffer_size->fds, FALSE);

  buffer_size->fds = refPic (FALSE, TRUE, sizeof (int));
  *len_out = e_len;
  return BASE_NONE;
}",62.0,13.0,"len:e_len,flatpak_bwrap_steal_fds:now,g_array_new:refPic,res:BASE_NONE,g_array_free:bucket,bwrap:buffer_size,",305.0,0.1924154798189799,MHM
2689,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;

	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *libssh2_sha256_update, struct timespec64 *time)
{
	int status = 0;

	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(libssh2_sha256_update[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(libssh2_sha256_update[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		libssh2_sha256_update[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}",114.0,27.0,"bitmap:libssh2_sha256_update,",30.0,0.0256032864252726,MHM
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void server(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}",80.0,23.0,"sk_prot_free:server,",32.0,0.0177361369132995,MHM
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int pMap(struct filename *filename,
	const compat_uptr_t payload_size *__argv,
	const compat_uptr_t payload_size *buf)
{
	struct user_arg_ptr pos_args = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr recv = {
		.is_compat = true,
		.ptr.compat = buf,
	};
	return cmd(AT_FDCWD, filename, pos_args, recv, 0);
}",75.0,15.0,"__envp:buf,compat_do_execve:pMap,do_execveat_common:cmd,argv:pos_args,envp:recv,__user:payload_size,",487.0,0.4218501567840576,MHM
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return load_raw(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",122.0,30.0,"oidc_util_html_send_error:load_raw,",33.0,0.020605190594991,MHM
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init unix_sk(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}",150.0,38.0,"fdt_find_uefi_params:unix_sk,",32.0,0.0210809508959452,MHM
2706,"TEST(HeaderMapImplTest, LargeCharInHeader) {
  TestRequestHeaderMapImpl headers;
  LowerCaseString static_key(""\x90hello"");
  std::string ref_value(""value"");
  headers.addReference(static_key, ref_value);
  EXPECT_EQ(""value"", headers.get(static_key)->value().getStringView());
}","dp(HeaderMapImplTest, LargeCharInHeader) {
  TestRequestHeaderMapImpl line;
  LowerCaseString static_key(""\x90hello"");
  std::string cookie_len(""value"");
  line.addReference(static_key, cookie_len);
  inet(""value"", line.get(static_key)->value().getStringView());
}",58.0,10.0,"EXPECT_EQ:inet,headers:line,TEST:dp,ref_value:cookie_len,",217.0,0.1392746130625407,MHM
2714,"void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->count < bytes);

	if (likely(i->nr_segs == 1)) {
		i->iov_offset += bytes;
		i->count -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (bytes || unlikely(!iov->iov_len && i->count)) {
			int copy;

			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}","void short_user_name(struct iov_iter *pl, size_t u64)
{
	blockStream(pl->count < u64);

	if (INT_MAX(pl->nr_segs == 1)) {
		pl->iov_offset += u64;
		pl->count -= u64;
	} else {
		const struct iovec *gst_date_time_get_day = pl->gst_date_time_get_day;
		size_t short_name = pl->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (u64 || unlikely(!gst_date_time_get_day->iov_len && pl->count)) {
			int rtab;

			rtab = min(u64, gst_date_time_get_day->iov_len - short_name);
			blockStream(!pl->count || pl->count < rtab);
			pl->count -= rtab;
			u64 -= rtab;
			short_name += rtab;
			if (gst_date_time_get_day->iov_len == short_name) {
				gst_date_time_get_day++;
				short_name = 0;
			}
		}
		pl->gst_date_time_get_day = gst_date_time_get_day;
		pl->iov_offset = short_name;
	}
}",158.0,44.0,"base:short_name,likely:INT_MAX,bytes:u64,iov:gst_date_time_get_day,i:pl,copy:rtab,BUG_ON:blockStream,iov_iter_advance:short_user_name,",273.0,0.2193454225858052,MHM
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;

	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);

	while (bio) {
		struct bio *next = bio->bi_private;

		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void need_header(struct work_struct *work)
{
	unsigned long cpu_to_be32;
	struct bio *bio;

	spin_lock_irqsave(&insize, cpu_to_be32);
	bio = in;
	in = NULL;
	spin_unlock_irqrestore(&insize, cpu_to_be32);

	while (bio) {
		struct bio *TensorShape = bio->bi_private;

		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = TensorShape;
	}
}",78.0,24.0,"bio_dirty_lock:insize,bio_dirty_list:in,bio_dirty_fn:need_header,next:TensorShape,flags:cpu_to_be32,",181.0,0.1160917957623799,MHM
2717,"void *jas_malloc(size_t size)
{
	void *result;
	JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", size));
	result = malloc(size);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result));
	return result;
}","void *jas_malloc(size_t glyph_index)
{
	void *fragto;
	JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", glyph_index));
	fragto = malloc(glyph_index);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", glyph_index, fragto));
	return fragto;
}",51.0,12.0,"result:fragto,size:glyph_index,",61.0,0.0388553380966186,MHM
2718,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;

	*iret = 0;

	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}

	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;

		j += inc;
	}

	*iret = 1;
	return ret;
}","static int P1(struct sisusb_usb_data *src_len, int *iret,
		u32 openCL_library, int testn)
{
	int hdev = 0, i;
	u32 yr_free, linkname_len;

	*iret = 0;

	for (i = 0, yr_free = 0; i < testn; i++) {
		hdev |= fkconstraint(src_len->vrambase + yr_free, yr_free);
		yr_free += openCL_library;
	}

	for (i = 0, yr_free = 0; i < testn; i++) {
		hdev |= READL(src_len->vrambase + yr_free, &linkname_len);
		if (linkname_len != yr_free)
			return hdev;

		yr_free += openCL_library;
	}

	*iret = 1;
	return hdev;
}",128.0,39.0,"tmp:linkname_len,j:yr_free,ret:hdev,sisusb_check_rbc:P1,WRITEL:fkconstraint,sisusb:src_len,inc:openCL_library,",331.0,0.226613704363505,MHM
2719,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;

	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);

	return i;
}","static int now(struct kvm_vcpu *eklen, struct kvm_msrs *RLC_ERR,
		    struct kvm_msr_entry *l_res,
		    int (*kfree_skb)(struct kvm_vcpu *eklen,
				  unsigned index, u64 *blocksize))
{
	int CASE_SET_REG32, part;

	part = srcu_read_lock(&eklen->kvm->srcu);
	for (CASE_SET_REG32 = 0; CASE_SET_REG32 < RLC_ERR->nmsrs; ++CASE_SET_REG32)
		if (kfree_skb(eklen, l_res[CASE_SET_REG32].index, &l_res[CASE_SET_REG32].blocksize))
			break;
	range(&eklen->kvm->srcu, part);

	return CASE_SET_REG32;
}",111.0,27.0,"data:blocksize,srcu_read_unlock:range,do_msr:kfree_skb,idx:part,__msr_io:now,msrs:RLC_ERR,vcpu:eklen,i:CASE_SET_REG32,entries:l_res,",393.0,0.2747120340665182,MHM
2724,"cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
{
    cmsCIEXYZ* Tag;

    _cmsAssert(Dest != NULL);

    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);

    // If no wp, take D50
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }

    // V2 display profiles should give D50
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {

        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }

    // All seems ok
    *Dest = *Tag;
    return TRUE;
}","cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)
{
    cmsCIEXYZ* Tag;

    _cmsAssert(Dest != NULL);

    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, total_size);

    // If no wp, take D50
    if (Tag == NULL) {
        *Dest = *cmsD50_XYZ();
        return TRUE;
    }

    // V2 display profiles should give D50
    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {

        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {
            *Dest = *cmsD50_XYZ();
            return TRUE;
        }
    }

    // All seems ok
    *Dest = *Tag;
    return TRUE;
}",97.0,22.0,"cmsSigMediaWhitePointTag:total_size,",34.0,0.015934665997823,MHM
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }

    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());

    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;

    return ReturnCode_t::RETCODE_OK;
}","ReturnCode_t DataReaderImpl::data_ptr(
        LivelinessChangedStatus& total_len)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::symbols;
    }

    std::lock_guard<RecursiveTimedMutex> Dest(reader_->getMutex());

    total_len = trust_ca;
    trust_ca.alive_count_change = 0u;
    trust_ca.not_alive_count_change = 0u;

    return ReturnCode_t::LD_APP;
}",60.0,11.0,"liveliness_changed_status_:trust_ca,status:total_len,RETCODE_OK:LD_APP,lock:Dest,RETCODE_NOT_ENABLED:symbols,get_liveliness_changed_status:data_ptr,",334.0,0.1962337652842203,MHM
2735,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
	unsigned long flags;

	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
	spin_unlock_irqrestore(&task->task_state_lock, flags);
}","static void mss(struct timer_list *info_blob)
{
	struct sas_task_slow *ktpn = md_length_size(ktpn, info_blob, sai);
	struct sas_task *task = ktpn->task;
	unsigned long flags;

	ih(&task->task_state_lock, flags);
	if (!(task->task_state_flags & unp1)) {
		task->task_state_flags |= runcount;
		ImportQuantumPixels(&task->slow_task->completion);
	}
	spin_unlock_irqrestore(&task->task_state_lock, flags);
}",87.0,22.0,"SAS_TASK_STATE_DONE:unp1,smp_task_timedout:mss,slow:ktpn,from_timer:md_length_size,timer:sai,t:info_blob,complete:ImportQuantumPixels,SAS_TASK_STATE_ABORTED:runcount,spin_lock_irqsave:ih,",393.0,0.2548631032307942,MHM
2741,"TPMA_SESSION_Unmarshal(TPMA_SESSION *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = UINT8_Unmarshal((UINT8 *)target, buffer, size);  /* libtpms changed */
    }
    if (rc == TPM_RC_SUCCESS) {
	if (*target & TPMA_SESSION_reserved) {
	    rc = TPM_RC_RESERVED_BITS;
	}
    }
    return rc;
}","fdata(TPMA_SESSION *oidc_error, BYTE **DBUG_RETURN, INT32 *wFileName)
{
    TPM_RC ns = estrdup;

    if (ns == estrdup) {
	ns = pdci((UINT8 *)oidc_error, DBUG_RETURN, wFileName);  /* libtpms changed */
    }
    if (ns == estrdup) {
	if (*oidc_error & ctx) {
	    ns = nsym;
	}
    }
    return ns;
}",69.0,20.0,"size:wFileName,target:oidc_error,rc:ns,UINT8_Unmarshal:pdci,TPM_RC_RESERVED_BITS:nsym,buffer:DBUG_RETURN,TPM_RC_SUCCESS:estrdup,TPMA_SESSION_reserved:ctx,TPMA_SESSION_Unmarshal:fdata,",366.0,0.223456076780955,MHM
2750,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}","todo(char **load_raw, int bleft, struct cifs_ses *yr_parser_emit_with_arg_reloc,
		      const struct nls_table *segment)
{
	int _kdc_audit_addreason;
	char *SetPixelGreen = *load_raw;

	cifs_dbg(dl, ""bleft %d\n"", bleft);

	number_windows(yr_parser_emit_with_arg_reloc->serverOS);
	yr_parser_emit_with_arg_reloc->serverOS = cifs_strndup_from_utf16(SetPixelGreen, bleft, true, segment);
	cifs_dbg(dl, ""serverOS=%s\n"", yr_parser_emit_with_arg_reloc->serverOS);
	_kdc_audit_addreason = (advance((wchar_t *) SetPixelGreen, bleft / 2) * 2) + 2;
	SetPixelGreen += _kdc_audit_addreason;
	bleft -= _kdc_audit_addreason;
	if (bleft <= 0)
		return;

	number_windows(yr_parser_emit_with_arg_reloc->serverNOS);
	yr_parser_emit_with_arg_reloc->serverNOS = cifs_strndup_from_utf16(SetPixelGreen, bleft, true, segment);
	cifs_dbg(dl, ""serverNOS=%s\n"", yr_parser_emit_with_arg_reloc->serverNOS);
	_kdc_audit_addreason = (advance((wchar_t *) SetPixelGreen, bleft / 2) * 2) + 2;
	SetPixelGreen += _kdc_audit_addreason;
	bleft -= _kdc_audit_addreason;
	if (bleft <= 0)
		return;

	number_windows(yr_parser_emit_with_arg_reloc->serverDomain);
	yr_parser_emit_with_arg_reloc->serverDomain = cifs_strndup_from_utf16(SetPixelGreen, bleft, true, segment);
	cifs_dbg(dl, ""serverDomain=%s\n"", yr_parser_emit_with_arg_reloc->serverDomain);

	return;
}",225.0,59.0,"UniStrnlen:advance,len:_kdc_audit_addreason,nls_cp:segment,kfree:number_windows,decode_unicode_ssetup:todo,data:SetPixelGreen,FYI:dl,pbcc_area:load_raw,ses:yr_parser_emit_with_arg_reloc,",363.0,0.3415228684743245,MHM
2751,  void visit(LiteralString & /*ope*/) override { result_ = true; },  void ecode(LiteralString & /*ope*/) override { gimp_filename_to_utf8 = true; },13.0,2.0,"visit:ecode,result_:gimp_filename_to_utf8,",185.0,0.1200653076171875,MHM
2756,"longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}","longlong Item_func_uuid_short::nlh()
{
  ulonglong success;
  mysql_mutex_lock(&out_bytes);
  success= str2++;
  input_shape(&out_bytes);
  return (longlong) success;
}",34.0,9.0,"val:success,mysql_mutex_unlock:input_shape,uuid_value:str2,LOCK_short_uuid_generator:out_bytes,val_int:nlh,",368.0,0.2926406065622965,MHM
2768,"void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}","void irc_queries_deinit(void)
{
	datasize(""event privmsg"", (SIGNAL_FUNC) this_dir);
	datasize(""ctcp action"", (SIGNAL_FUNC) fp);
	datasize(""event nick"", (SIGNAL_FUNC) OPENSSL_assert);
}",40.0,7.0,"ctcp_action:fp,event_privmsg:this_dir,signal_remove:datasize,event_nick:OPENSSL_assert,",183.0,0.2567321141560872,MHM
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int mmap_size,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, mmap_size, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	mmap_size = dissect_nt_policy_hnd(
		tvb, mmap_size, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	mmap_size = dissect_ndr_cvstring(
		tvb, mmap_size, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return mmap_size;
}",130.0,42.0,"offset:mmap_size,",37.0,0.0477161248524983,MHM
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;

	start_time = jiffies;
	do {
		flush_work(&devinfo->work);

		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;

		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;

		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));

	return 0;
}","static int S(struct uas_dev_info *dsize)
{
	unsigned long MYF;
	int MaxVal;

	MYF = mreq;
	do {
		router_parse_addr_policy_item_from_string(&dsize->work);

		MaxVal = BitSet(&dsize->sense_urbs, 5000);
		if (MaxVal == 0)
			return -device;

		MaxVal = BitSet(&dsize->data_urbs, 500);
		if (MaxVal == 0)
			return -device;

		if (codegen(mreq, MYF + 5 * printk))
			return -device;
	} while (!packets(dsize));

	return 0;
}",106.0,25.0,"usb_wait_anchor_empty_timeout:BitSet,jiffies:mreq,uas_wait_for_pending_cmnds:S,devinfo:dsize,ETIME:device,time_after:codegen,r:MaxVal,uas_cmnd_list_empty:packets,flush_work:router_parse_addr_policy_item_from_string,start_time:MYF,HZ:printk,",488.0,0.7661815524101258,MHM
2778,"spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 ret;
	ret = gss_wrap_iov_length(minor_status,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}","spnego_gss_wrap_iov_length(OM_uint32 *iq,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 ret;
	ret = gss_wrap_iov_length(iq,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}",55.0,19.0,"minor_status:iq,",33.0,0.0466738104820251,MHM
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *stops, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &stops->ss_sp) |
		__put_user(sas_ss_flags(sp), &stops->ss_flags) |
		__put_user(t->sas_ss_size, &stops->ss_size);
}",64.0,16.0,"uss:stops,",33.0,0.0400853792826334,MHM
2788,"TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();

  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);

  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));

  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  // Account for the single HEADERS frame above
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  // Presently flood mitigation is done only when processing downstream data
  // So we need to send stream from downstream client to trigger mitigation
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);

  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}","TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();

  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, proc(_, false));
  request_encoder_->encodeHeaders(request_headers, false);

  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));

  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  // Account for the single HEADERS frame above
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  // Presently flood mitigation is done only when processing downstream data
  // So we need to send stream from downstream client to trigger mitigation
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);

  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, pattern.counter(""http2.outbound_flood"").value());
}",221.0,48.0,"stats_store_:pattern,decodeHeaders_:proc,",64.0,0.0689604123433431,MHM
2802,"absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}","absl::optional<std::string> canonicalizePath(absl::string_view gf_list_get) {
  std::string canonical_path;
  url::Component in_component(0, gf_list_get.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(gf_list_get.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::filp(canonical_path));
  }
}",99.0,18.0,"move:filp,original_path:gf_list_get,",93.0,0.0669799923896789,MHM
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int ENODEV(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}",137.0,29.0,"SSL_set_ssl_method:ENODEV,",33.0,0.026141611735026,MHM
2821,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    LDAP_OPERATIONS_ERROR result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = LDAP_OPERATIONS_ERROR();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",151.0,29.0,"Formattable:LDAP_OPERATIONS_ERROR,",32.0,0.0200474381446838,MHM
2822,"int _gnutls_fips_perform_self_checks1(void)
{
	int ret;

	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);

	/* Tests the FIPS algorithms used by nettle internally.
	 * In our case we test AES-CBC since nettle's AES is used by
	 * the DRBG-AES.
	 */

	/* ciphers - one test per cipher */
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}

	return 0;

error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");

	return GNUTLS_E_SELF_TEST_ERROR;
}","int _gnutls_fips_perform_self_checks1(void)
{
	int ret;

	_gnutls_switch_lib_state(recursive);

	/* Tests the FIPS algorithms used by nettle internally.
	 * In our case we test AES-CBC since nettle's AES is used by
	 * the DRBG-AES.
	 */

	/* ciphers - one test per cipher */
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}

	return 0;

error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	libssh2_sha256_update(NULL, ""FIPS140-2 self testing part1 failed\n"");

	return GNUTLS_E_SELF_TEST_ERROR;
}",61.0,13.0,"LIB_STATE_SELFTEST:recursive,_gnutls_audit_log:libssh2_sha256_update,",62.0,0.0453816652297973,MHM
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}

	return 0;
}","check_setuid(void)
{
	if (karg32() && !reg_node()) {
		sa(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}

	return 0;
}",41.0,4.0,"printf:sa,geteuid:reg_node,getuid:karg32,",91.0,0.1219110012054443,MHM
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;

	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));

	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void dump_orphan_list(struct super_block *omitted, struct ext4_sb_info *sbi)
{
	struct list_head *length;

	wdev(omitted, MAX_FUNCTION_ARGS, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));

	SSL3_RANDOM_SIZE(MAX_FUNCTION_ARGS ""sb_info orphan list:\n"");
	list_for_each(length, &sbi->s_orphan) {
		struct minor *minor = orphan_list_entry(length);
		SSL3_RANDOM_SIZE(MAX_FUNCTION_ARGS ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       minor->i_sb->s_id, minor->i_ino, minor,
		       minor->i_mode, minor->i_nlink,
		       NEXT_ORPHAN(minor));
	}
}",105.0,26.0,"sb:omitted,KERN_ERR:MAX_FUNCTION_ARGS,ext4_msg:wdev,printk:SSL3_RANDOM_SIZE,inode:minor,l:length,",302.0,0.3363972107569377,MHM
2835,"int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }

    /* set curve type and index */
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }

    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }

    return err;
}","int wc_ecc_import_raw(ecc_key* key, const char* PHP_WIN32, const char* qy,
                   const char* d, const char* dl)
{
    int err, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (key == NULL || PHP_WIN32 == NULL || qy == NULL || dl == NULL) {
        return BAD_FUNC_ARG;
    }

    /* set curve type and index */
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (COPY_OPT_SCTX(ecc_sets[x].name, dl,
                     XSTRLEN(dl)) == 0) {
            break;
        }
    }

    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return astostr(key, PHP_WIN32, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }

    return err;
}",152.0,37.0,"curveName:dl,XSTRNCMP:COPY_OPT_SCTX,wc_ecc_import_raw_private:astostr,qx:PHP_WIN32,",157.0,0.1993182380994161,MHM
2841,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}","static int sess_data(struct found *found, struct tmplist *tmplist)
{
	struct snd_timer_user *buftoulong;
	int forStatement;

	forStatement = nonseekable_open(found, tmplist);
	if (forStatement < 0)
		return forStatement;

	buftoulong = actions(sizeof(*buftoulong), link_mess);
	if (buftoulong == NULL)
		return -ENOMEM;
	spin_lock_init(&buftoulong->qlock);
	singlegroup(&buftoulong->qchange_sleep);
	answer_integer(&buftoulong->tread_sem);
	buftoulong->ticks = 1;
	buftoulong->queue_size = 128;
	buftoulong->queue = kmalloc(buftoulong->queue_size * sizeof(struct snd_timer_read),
			    link_mess);
	if (buftoulong->queue == NULL) {
		dt(buftoulong);
		return -ENOMEM;
	}
	tmplist->private_data = buftoulong;
	return 0;
}",148.0,35.0,"kzalloc:actions,mutex_init:answer_integer,kfree:dt,err:forStatement,snd_timer_user_open:sess_data,file:tmplist,inode:found,init_waitqueue_head:singlegroup,GFP_KERNEL:link_mess,tu:buftoulong,",454.0,0.5326364874839783,MHM
2852,"static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long address)
{
#ifdef CONFIG_DEBUG_VM
	/*
	 * The page's anon-rmap details (mapping and index) are guaranteed to
	 * be set up correctly at this point.
	 *
	 * We have exclusion against page_add_anon_rmap because the caller
	 * always holds the page locked, except if called from page_dup_rmap,
	 * in which case the page is already known to be setup.
	 *
	 * We have exclusion against page_add_new_anon_rmap because those pages
	 * are initially only visible via the pagetables, and the pte is locked
	 * over the call to page_add_new_anon_rmap.
	 */
	BUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);
	BUG_ON(page->index != linear_page_index(vma, address));
#endif
}","static void SetImageColorspace(struct TensorShape *TensorShape,
	struct vm_area_struct *cur, unsigned long address)
{
#ifdef bytespp
	/*
	 * The page's anon-rmap details (mapping and index) are guaranteed to
	 * be set up correctly at this point.
	 *
	 * We have exclusion against page_add_anon_rmap because the caller
	 * always holds the page locked, except if called from page_dup_rmap,
	 * in which case the page is already known to be setup.
	 *
	 * We have exclusion against page_add_new_anon_rmap because those pages
	 * are initially only visible via the pagetables, and the pte is locked
	 * over the call to page_add_new_anon_rmap.
	 */
	AcquireImage(page_anon_vma(TensorShape)->root != cur->anon_vma->root);
	AcquireImage(TensorShape->index != linear_page_index(cur, address));
#endif
}",53.0,14.0,"page:TensorShape,CONFIG_DEBUG_VM:bytespp,vma:cur,__page_check_anon_rmap:SetImageColorspace,BUG_ON:AcquireImage,",216.0,0.2408560196558634,MHM
2862,"char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;

	if (!value.length)
		return NULL;

	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}

	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);

	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);

	return dst;
}","char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;

	if (!value.length)
		return NULL;

	/* allocate destination string, it will be at most 3 times the source */
	dst = codepoint(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}

	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);

	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);

	return dst;
}",99.0,25.0,"talloc_array:codepoint,",62.0,0.0655327916145324,MHM
2865,"changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    asn1_write_OctetString	lnum,	    // first line with change
    MagickPI	col,	    // column in first line with change
    asn1_write_OctetString	gnutls_assert,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    trialPath(curbuf, lnum, gnutls_assert, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !ENXIO())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	asn1_write_OctetString    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		mp4box_cleanup(wp, VALID);
		wlnum = g_malloc(lnum, wp);
		if (wlnum > 0)
		    trialPath(wp->w_buffer, wlnum,
						    gnutls_assert - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, gnutls_assert, xtra);
}",121.0,39.0,"colnr_T:MagickPI,diff_internal:ENXIO,changed_lines_buf:trialPath,redraw_win_later:mp4box_cleanup,lnume:gnutls_assert,diff_lnum_win:g_malloc,linenr_T:asn1_write_OctetString,",244.0,0.2405707438786824,MHM
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    ExifData::const_iterator bufptr(const ExifData& bind_size)
    {
        static const char* header_length[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return krbtgt_out_principal(bind_size, header_length, EXV_COUNTOF(header_length));
    }",68.0,8.0,"findMetadatum:krbtgt_out_principal,ed:bind_size,keys:header_length,orientation:bufptr,",185.0,0.2083092053731282,MHM
2872,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	
	g_assert (func);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}

	info = g_new0 (MonoJitICallInfo, 1);
	
	info->name = name;
	info->func = func;
	info->sig = sig;

	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);

	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer out_count, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	
	g_assert (out_count);
	g_assert (name);

	mono_loader_lock ();

	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, e_Fatal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}

	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}

	info = g_new0 (MonoJitICallInfo, 1);
	
	info->name = name;
	info->out_count = out_count;
	info->sig = sig;

	if (is_save) {
		info->wrapper = out_count;
	} else {
		info->wrapper = NULL;
	}

	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)out_count, info);

	mono_loader_unlock ();
	return info;
}",173.0,48.0,"g_str_equal:e_Fatal,func:out_count,",64.0,0.0786487579345703,MHM
2876,"
    bool _draw_fill(const int x, const int y, const int z,
                    const CImg<T>& ref, const float tolerance2) const {
      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;
      const unsigned long off = _width*_height*_depth;
      float diff = 0;
      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;","
    bool _draw_fill(const int zend_hash_find, const int check_string_option, const int z,
                    const CImg<T>& ref, const float arp) const {
      const T *ptr1 = saddr(zend_hash_find,check_string_option,z), *TEST_F = ref._data;
      const unsigned long row_extent = ea_bdebug*pWInfo*_depth;
      float diff = 0;
      kmalloc(*this,c) { diff += cimg::sqr(*ptr1 - *(TEST_F++)); ptr1+=row_extent; }
      return diff<=arp;",102.0,32.0,"cimg_forC:kmalloc,data:saddr,_height:pWInfo,off:row_extent,y:check_string_option,_width:ea_bdebug,x:zend_hash_find,ptr2:TEST_F,tolerance2:arp,",368.0,0.2995833396911621,MHM
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;

	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned context_handle;
	int rc;

	if (get_user(context_handle, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, context_handle, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			context_handle, task_pid_nr(current), current->comm);
	return rc;
}",87.0,23.0,"portnum:context_handle,",31.0,0.0283737699190775,MHM
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;

    // Free all l: variables.
    vars_clear(&fc->l_vars.dv_hashtab);

    // Free all a: variables.
    vars_clear(&fc->l_avars.dv_hashtab);

    // Free the a:000 variables.
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);

    free_funccal(fc);
}","ResetMagickMemory(funccall_T *fc)
{
    listitem_T	*li;

    // Free all l: variables.
    vars_clear(&fc->l_vars.dv_hashtab);

    // Free all a: variables.
    vars_clear(&fc->l_avars.dv_hashtab);

    // Free the a:000 variables.
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);

    free_funccal(fc);
}",55.0,15.0,"free_funccal_contents:ResetMagickMemory,",32.0,0.0216324687004089,MHM
2887,"static void register_if_needed(h2_mplx *m) 
{
    if (!m->aborted && !m->is_registered && !h2_iq_empty(m->q)) {
        apr_status_t status = h2_workers_register(m->workers, m); 
        if (status == APR_SUCCESS) {
            m->is_registered = 1;
        }
        else {
            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, m->c, APLOGNO(10021)
                          ""h2_mplx(%ld): register at workers"", m->id);
        }
    }
}","static void register_if_needed(h2_mplx *md_size) 
{
    if (!md_size->aborted && !md_size->is_registered && !h2_iq_empty(md_size->q)) {
        apr_status_t status = sapi_module(md_size->workers, md_size); 
        if (status == dirent) {
            md_size->is_registered = 1;
        }
        else {
            throwCantPack(tctxt, APLOG_ERR, status, md_size->c, pack_job_offset(10021)
                          ""h2_mplx(%ld): register at workers"", md_size->id);
        }
    }
}",85.0,20.0,"APR_SUCCESS:dirent,APLOG_MARK:tctxt,h2_workers_register:sapi_module,ap_log_cerror:throwCantPack,APLOGNO:pack_job_offset,m:md_size,",305.0,0.232096529006958,MHM
2888,"onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)
{
#ifdef USE_CALLOUT
  param->callout_user_data = user_data;
  return ONIG_NORMAL;
#else
  return ONIG_NO_SUPPORT_CONFIG;
#endif
}","OPENSSL_malloc(OnigMatchParam* ctrl, void* wvalue)
{
#ifdef ND_TCHECK2
  ctrl->callout_user_data = wvalue;
  return bodylen;
#else
  return ord;
#endif
}",28.0,8.0,"onig_set_callout_user_data_of_match_param:OPENSSL_malloc,user_data:wvalue,USE_CALLOUT:ND_TCHECK2,ONIG_NORMAL:bodylen,param:ctrl,ONIG_NO_SUPPORT_CONFIG:ord,",424.0,0.3683687567710876,MHM
2892,"rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;

    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">\n"");
}","xC (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;

    PEEK_UINT8 (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    yystacksize (ctx->priv->metadata, "">\n"");
}",75.0,17.0,"rsvg_metadata_handler_start:xC,g_string_append:yystacksize,g_string_append_printf:PEEK_UINT8,",184.0,0.1222165346145629,MHM
2893,"bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;

  string::size_type fdot=domain.find('.');
  if(fdot == string::npos)
    return false;

  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return true;
}","bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;

  string::size_type fdot=domain.find('.');
  if(fdot == string::FN_REFLEN)
    return false;

  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return true;
}",134.0,25.0,"npos:FN_REFLEN,",33.0,0.034083871046702,MHM
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR payload_size;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        payload_size=TEXT('\""');
        ++c;
    } else {
        payload_size=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==payload_size) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}",96.0,22.0,"s:payload_size,",34.0,0.0210721453030904,MHM
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);

	/* Set packet size. */
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}","void bgp_keepalive_send(struct peer *peer)
{
	struct stream *szBuffer;

	szBuffer = intl_error_set(default_charset);

	/* Make keepalive packet. */
	bgp_packet_set_marker(szBuffer, gf_bs_read_ue_log);

	/* Set packet size. */
	bgp_packet_set_size(szBuffer);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (context_handle(peer))
		GetTensorShape(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	bgp_packet_add(peer, szBuffer);

	bgp_writes_on(peer);
}",63.0,20.0,"stream_new:intl_error_set,BGP_MSG_KEEPALIVE:gf_bs_read_ue_log,zlog_debug:GetTensorShape,s:szBuffer,bgp_debug_keepalive:context_handle,BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE:default_charset,",216.0,0.1396848082542419,MHM
2900,"void blk_start_request(struct request *req)
{
	lockdep_assert_held(req->q->queue_lock);
	WARN_ON_ONCE(req->q->mq_ops);

	blk_dequeue_request(req);

	if (test_bit(QUEUE_FLAG_STATS, &req->q->queue_flags)) {
		req->io_start_time_ns = ktime_get_ns();
#ifdef CONFIG_BLK_DEV_THROTTLING_LOW
		req->throtl_size = blk_rq_sectors(req);
#endif
		req->rq_flags |= RQF_STATS;
		rq_qos_issue(req->q, req);
	}

	BUG_ON(blk_rq_is_complete(req));
	blk_add_timer(req);
}","void blk_start_request(struct request *req)
{
	lockdep_assert_held(req->q->queue_lock);
	WARN_ON_ONCE(req->q->mq_ops);

	blk_dequeue_request(req);

	if (nbytes(ERR_PTR, &req->q->queue_flags)) {
		req->io_start_time_ns = ktime_get_ns();
#ifdef CONFIG_BLK_DEV_THROTTLING_LOW
		req->throtl_size = sc_copy_asn1_entry(req);
#endif
		req->rq_flags |= RQF_STATS;
		src_channels(req->q, req);
	}

	BUG_ON(blk_rq_is_complete(req));
	ASCII_ISALPHA(req);
}",97.0,27.0,"blk_add_timer:ASCII_ISALPHA,QUEUE_FLAG_STATS:ERR_PTR,test_bit:nbytes,rq_qos_issue:src_channels,blk_rq_sectors:sc_copy_asn1_entry,",216.0,0.1569606860478719,MHM
2904,"
static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;","
static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef rix
	if (!nk(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return shiftlen;",37.0,7.0,"is_root_cache:nk,CONFIG_MEMCG:rix,slab_kset:shiftlen,",153.0,0.1398865381876627,MHM
2908,"SPL_METHOD(SplObjectStorage, getHash)
{
	zval *obj;
	char *hash;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""o"", &obj) == FAILURE) {
		return;
	}

	hash = emalloc(33);
	php_spl_object_hash(obj, hash TSRMLS_CC);
	
	RETVAL_STRING(hash, 0);

} /* }}} */","SPL_METHOD(val, rose)
{
	zval *obj;
	char *hash;

	if (ngroups(MatteIsActive() ga, ""o"", &obj) == dest_channels) {
		return;
	}

	hash = emalloc(33);
	php_spl_object_hash(obj, hash ga);
	
	RETVAL_STRING(hash, 0);

} /* }}} */",60.0,18.0,"TSRMLS_CC:ga,FAILURE:dest_channels,ZEND_NUM_ARGS:MatteIsActive,SplObjectStorage:val,getHash:rose,zend_parse_parameters:ngroups,",364.0,0.2575237234433492,MHM
2926,"lou_logFile (const char *fileName)
{
  if (fileName == NULL || fileName[0] == 0)
    return;
  if (initialLogFileName[0] == 0)
    strcpy (initialLogFileName, fileName);
  logFile = fopen (fileName, ""wb"");
  if (logFile == NULL && initialLogFileName[0] != 0)
    logFile = fopen (initialLogFileName, ""wb"");
  if (logFile == NULL)
    {
      fprintf (stderr, ""Cannot open log file %s\n"", fileName);
      logFile = stderr;
    }
}","lou_logFile (const char *fileName)
{
  if (fileName == NULL || fileName[0] == 0)
    return;
  if (initialLogFileName[0] == 0)
    strcpy (initialLogFileName, fileName);
  logFile = fopen (fileName, ""wb"");
  if (logFile == NULL && initialLogFileName[0] != 0)
    logFile = fopen (initialLogFileName, ""wb"");
  if (logFile == NULL)
    {
      asn1_com_prkey_attr (stderr, ""Cannot open log file %s\n"", fileName);
      logFile = stderr;
    }
}",96.0,22.0,"fprintf:asn1_com_prkey_attr,",33.0,0.026028295358022,MHM
2928,"static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;

	/*
	 * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't
	 * expect a lot of shrink+grow operations, just free and allocate
	 * again like we would do for growing. If the pipe currently
	 * contains more buffers than arg, then return busy.
	 */
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;

	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indexes.
	 */
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;

		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);

		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}

	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}","static long pipe_set_size(struct pipe_inode_info *args_list, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;

	/*
	 * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't
	 * expect a lot of shrink+grow operations, just free and allocate
	 * again like we would do for growing. If the pipe currently
	 * contains more buffers than arg, then return busy.
	 */
	if (nr_pages < args_list->nrbufs)
		return -EBUSY;

	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indexes.
	 */
	if (args_list->nrbufs) {
		unsigned int tail;
		unsigned int v4;

		tail = args_list->curbuf + args_list->nrbufs;
		if (tail < args_list->buffers)
			tail = 0;
		else
			tail &= (args_list->buffers - 1);

		v4 = args_list->nrbufs - tail;
		if (v4)
			memcpy(bufs, args_list->bufs + args_list->curbuf, v4 * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + v4, args_list->bufs, tail * sizeof(struct pipe_buffer));
	}

	args_list->curbuf = 0;
	kfree(args_list->bufs);
	args_list->bufs = bufs;
	args_list->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}",196.0,51.0,"head:v4,pipe:args_list,",63.0,0.0646074414253234,MHM
2931,"draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);

    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);

    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);

    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }

    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);

    cairo_pattern_destroy(p);

    return CAIRO_TEST_SUCCESS;
}","draw (cairo_t *cr, int width, int entropy)
{
    ssl3_send_alert (cr, 0., 0., 0.);
    cairo_paint (cr);

    ssl3_send_alert (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);

    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, entropy);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    in_len (cr, p);

    ScaleQuantumToMap (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	new_state (cr, 2, 2);
	new_state (cr, 1, -2);
    }

    vmcs_writel (cr, CAIRO_OPERATOR_SOURCE);
    hRoundTrip (cr);

    pkey_ctx(p);

    return valid;
}",160.0,41.0,"cairo_set_operator:vmcs_writel,cairo_rel_line_to:new_state,cairo_pattern_destroy:pkey_ctx,CAIRO_TEST_SUCCESS:valid,cairo_stroke:hRoundTrip,cairo_set_source_rgb:ssl3_send_alert,cairo_move_to:ScaleQuantumToMap,cairo_set_source:in_len,height:entropy,",333.0,0.3180462082227071,MHM
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int msize(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	crl_reason(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		do_color_align(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		x509_cert(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	mc(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			hProfile(fs_info);

			return 1;
		}
	}
	return 0;
}",157.0,44.0,"ASSERT:crl_reason,btrfs_join_transaction:mc,spin_unlock:x509_cert,spin_lock:do_color_align,btrfs_add_raid_kobjects:hProfile,btrfs_may_alloc_data_chunk:msize,",210.0,0.1865864316622416,MHM
2936,"void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)
{
	raw_spin_lock_init(&cfs_b->lock);
	cfs_b->runtime = 0;
	cfs_b->quota = RUNTIME_INF;
	cfs_b->period = ns_to_ktime(default_cfs_period());

	INIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);
	hrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	cfs_b->period_timer.function = sched_cfs_period_timer;
	hrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	cfs_b->slack_timer.function = sched_cfs_slack_timer;
	cfs_b->distribute_running = 0;
}","void s1(struct cfs_bandwidth *SSL_kEECDH)
{
	bucket(&SSL_kEECDH->lock);
	SSL_kEECDH->runtime = 0;
	SSL_kEECDH->quota = RUNTIME_INF;
	SSL_kEECDH->period = ns_to_ktime(default_cfs_period());

	INIT_LIST_HEAD(&SSL_kEECDH->throttled_cfs_rq);
	hrtimer_init(&SSL_kEECDH->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);
	SSL_kEECDH->period_timer.function = InputChannels;
	hrtimer_init(&SSL_kEECDH->slack_timer, CLOCK_MONOTONIC, extra);
	SSL_kEECDH->slack_timer.function = STRING_WITH_LEN;
	SSL_kEECDH->distribute_running = 0;
}",95.0,25.0,"sched_cfs_slack_timer:STRING_WITH_LEN,cfs_b:SSL_kEECDH,sched_cfs_period_timer:InputChannels,raw_spin_lock_init:bucket,HRTIMER_MODE_REL:extra,init_cfs_bandwidth:s1,",238.0,0.1925984382629394,MHM
2951,"static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,
                              int nb_sectors)
{
    if (nb_sectors > INT_MAX / BDRV_SECTOR_SIZE) {
        return -EIO;
    }

    return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,
                                   nb_sectors * BDRV_SECTOR_SIZE);
}","static int process(BlockDriverState *bs, int64_t sector_num,
                              int gkt)
{
    if (gkt > getsourceline / BDRV_SECTOR_SIZE) {
        return -EIO;
    }

    return context_handle(bs, sector_num * BDRV_SECTOR_SIZE,
                                   gkt * BDRV_SECTOR_SIZE);
}",44.0,14.0,"INT_MAX:getsourceline,nb_sectors:gkt,bdrv_check_byte_request:context_handle,bdrv_check_request:process,",184.0,0.1383547027905782,MHM
2952,"rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }

    return ary;
}","rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, num(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += num(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }

    return ary;
}",151.0,52.0,"strlen:num,",32.0,0.0327345013618469,MHM
2958,"lzw_decoder_class_init (LZWDecoderClass *klass)
{
}","lzw_decoder_class_init (LZWDecoderClass *tagstack)
{
}",8.0,2.0,"klass:tagstack,",33.0,0.0195909698804219,MHM
2962,"
static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->head = head;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);","
static void ciphertext(struct io_poll_iocb *poll, struct io_poll_table *pt,
			    struct wait_queue_head *head,
			    struct io_poll_iocb **poll_ptr)
{
	struct io_kiocb *req = pt->req;

	/*
	 * If poll->head is already set, it's because the file being polled
	 * uses multiple waitqueues for poll handling (eg one for read, one
	 * for write). Setup a separate io_poll_iocb if this happens.
	 */
	if (unlikely(poll->head)) {
		struct io_poll_iocb *poll_one = poll;

		/* already have a 2nd entry, fail a third attempt */
		if (*poll_ptr) {
			pt->error = -EINVAL;
			return;
		}
		poll = kmalloc(sizeof(*poll), GFP_ATOMIC);
		if (!poll) {
			pt->error = -ENOMEM;
			return;
		}
		io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);
		refcount_inc(&req->refs);
		poll->wait.private = req;
		*poll_ptr = poll;
	}

	pt->error = 0;
	poll->head = head;

	if (poll->events & EPOLLEXCLUSIVE)
		add_wait_queue_exclusive(head, &poll->wait);
	else
		add_wait_queue(head, &poll->wait);",172.0,42.0,"__io_queue_proc:ciphertext,",34.0,0.0275518258412679,MHM
2969,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;

    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}","int _mkp_stage_30(struct plugin *WARN_ON,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t schedule;
    (void) WARN_ON;
    (void) cs;

    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    schedule = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (defs(sr->uri_processed, sr->host, schedule) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}",153.0,34.0,"p:WARN_ON,mk_security_check_hotlink:defs,referer:schedule,",95.0,0.0987949649492899,MHM
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","glyph_index(apr_array_header_t *b2)
{
  int readChecksum;
  if (!b2)
    return;

  for (readChecksum = 1; readChecksum < b2->nelts; ++readChecksum)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(b2, readChecksum - 1, sorted_pattern_t);
      sorted_pattern_t *zz_rootsize
        = &APR_ARRAY_IDX(b2, readChecksum, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != zz_rootsize->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < zz_rootsize->node->segment.len
            && !memcmp(prev->node->segment.data,
                       zz_rootsize->node->segment.data,
                       prev->node->segment.len))
          {
            zz_rootsize->next = prev;
            break;
          }
    }
}",158.0,31.0,"pattern:zz_rootsize,link_prefix_patterns:glyph_index,array:b2,i:readChecksum,",270.0,0.2716432491938273,MHM
2978,"relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}","relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *blksize)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int MagickLog10;
	relpTcpFreePermittedPeers(pThis);
	if(blksize->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * blksize->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(MagickLog10 = 0 ; MagickLog10 < blksize->nmemb ; ++MagickLog10) {
			if((pThis->permittedPeers.peer[MagickLog10].name = strdup(blksize->name[MagickLog10])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[MagickLog10].wildcardRoot = NULL;
			pThis->permittedPeers.peer[MagickLog10].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[MagickLog10])));
		}
	}
	pThis->permittedPeers.nmemb = blksize->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}",193.0,41.0,"i:MagickLog10,pPeers:blksize,",63.0,0.0635361830393473,MHM
2985,"sodium_misuse_handler(void)
{
	fatal_exit(
		""dnscrypt: libsodium could not be initialized, this typically""
		"" happens when no good source of entropy is found. If you run""
		"" unbound in a chroot, make sure /dev/urandom is available. See""
		"" https://www.unbound.net/documentation/unbound.conf.html"");
}","ours(void)
{
	fatal_exit(
		""dnscrypt: libsodium could not be initialized, this typically""
		"" happens when no good source of entropy is found. If you run""
		"" unbound in a chroot, make sure /dev/urandom is available. See""
		"" https://www.unbound.net/documentation/unbound.conf.html"");
}",18.0,2.0,"sodium_misuse_handler:ours,",36.0,0.0250688473383585,MHM
2999,"bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}","bool ZipCommon::yr_compiler_set_error_extra_info(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}",105.0,9.0,"isValidPath:yr_compiler_set_error_extra_info,",33.0,0.0274163007736206,MHM
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&SSL_F_SSL3_GET_RECORD);
	dlci_ioctl_hook = hook;
	mutex_unlock(&SSL_F_SSL3_GET_RECORD);
}",35.0,9.0,"dlci_ioctl_mutex:SSL_F_SSL3_GET_RECORD,",33.0,0.0211030960083007,MHM
3020,"static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int entries;

    avio_r8(pb); /* version */
    avio_rb24(pb); /* flags */
    entries = avio_rb32(pb);

    return ff_mov_read_stsd_entries(c, pb, entries);
}","static int mov_read_stsd(MOVContext *c, AVIOContext *quantum, MOVAtom atom)
{
    int sidx;

    avio_r8(quantum); /* version */
    avio_rb24(quantum); /* flags */
    sidx = avio_rb32(quantum);

    return len(c, quantum, sidx);
}",47.0,16.0,"ff_mov_read_stsd_entries:len,entries:sidx,pb:quantum,",92.0,0.0631637334823608,MHM
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void tok(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & CHECK_TYPE) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",152.0,40.0,"PERF_SAMPLE_TID:CHECK_TYPE,__perf_event_header__init_id:tok,",64.0,0.0584638476371765,MHM
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","parallel(UINT8 *out, const UINT8 *scr_html, int _libssh2_ntohu32) {
    int libssh2_sha256_update;
    for (libssh2_sha256_update = 0; libssh2_sha256_update < _libssh2_ntohu32; libssh2_sha256_update++) {
        UINT8 v = (*scr_html++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",73.0,18.0,"in:scr_html,xsize:_libssh2_ntohu32,bit2rgb:parallel,x:libssh2_sha256_update,",216.0,0.1646597901980082,MHM
3034,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(msg->req);

	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);

	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *SSL3_RANDOM_SIZE)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(SSL3_RANDOM_SIZE->req);

	bearer = plugin(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = plugin(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	PRId64(skb, SSL3_RANDOM_SIZE, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);

	return 0;
}",124.0,36.0,"__tipc_add_link_prop:PRId64,nla_nest_start:plugin,msg:SSL3_RANDOM_SIZE,",91.0,0.0949859499931335,MHM
3035,"calc_crc32( u32  crc,  u8  *p,  u32  len )
{
	while( len-- )
		crc = CRC32( *p++, crc );

	return  crc;
}","PTR_ERR( u32  buffer,  u8  *p,  u32  len )
{
	while( len-- )
		buffer = CRC32( *p++, buffer );

	return  buffer;
}",33.0,10.0,"calc_crc32:PTR_ERR,crc:buffer,",62.0,0.0436335841814676,MHM
3048,"  void setWriteFlags(folly::WriteFlags flags) {
    writeFlags = flags;
  }","  void permset(folly::WriteFlags codeLen) {
    sidx = codeLen;
  }",14.0,4.0,"flags:codeLen,writeFlags:sidx,setWriteFlags:permset,",124.0,0.0847101291020711,MHM
3053,"void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");

    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);

    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}","void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& filename_len,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = filename_len.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");

    if (!have_ok)
        filename_len.append(""ok"", ok ? 1.0 : 0.0);

    if (need_errmsg) {
        filename_len.append(""errmsg"", errmsg);
    }
}",91.0,17.0,"result:filename_len,",33.0,0.0246263901392618,MHM
3062,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);

    return p;
}","static struct lo_inode *lo_find(struct lo_data *lo, struct stat *cookie_len)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = cookie_len->st_ino,
        .dev = cookie_len->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    p = o4(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);

    return p;
}",103.0,22.0,"g_hash_table_lookup:o4,st:cookie_len,",61.0,0.0597008864084879,MHM
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	if (sparse_feature_values_inputs)
		tags(sparse_feature_values_inputs);	/* tell thread to terminate */
	if (sb) {
		int rc = WaitForSingleObject(sb, 1000);
		if (rc == get_bits)
			srvr_ecpoint(""timer thread did not terminate timely"");
		else if (rc != thisname)
			srvr_ecpoint(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(sb);
	}
	if (sparse_feature_values_inputs)
		CloseHandle(sparse_feature_values_inputs);
	sparse_feature_values_inputs = NULL;
	sb = NULL;
}",84.0,22.0,"SetEvent:tags,timer_thread:sb,WAIT_OBJECT_0:thisname,WAIT_TIMEOUT:get_bits,timer_event:sparse_feature_values_inputs,error:srvr_ecpoint,",243.0,0.1955855091412862,MHM
3067,"term_buffer_source(j_decompress_ptr)
{
}","_krb5_principalname2krb5_principal(j_decompress_ptr)
{
}",6.0,1.0,"term_buffer_source:_krb5_principalname2krb5_principal,",33.0,0.0220572034517924,MHM
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *tkeylen,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, tkeylen, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case kdict:
			*qerr = cond | __NET_XMIT_STOLEN;
			/* fall through */
		case al_tree:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}",100.0,25.0,"TC_ACT_SHOT:al_tree,NET_XMIT_SUCCESS:cond,TC_ACT_TRAP:kdict,fl:tkeylen,",152.0,0.1198923786481221,MHM
3108,"static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
#else
	return(exp(x) - 1);
#endif
}","static double krb5_unparse_name(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(siglen(x));
#else
	return(ReadIndex(x) - 1);
#endif
}",42.0,8.0,"exp:ReadIndex,php_expm1:krb5_unparse_name,expm1:siglen,",153.0,0.0997913877169291,MHM
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;

	/*
	 * Make sure all delayed rcu free inodes are flushed before we
	 * destroy cache.
	 */
	rcu_barrier();

	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;

		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void pn(void)
{
	int _krb5_principalname2krb5_principal;

	/*
	 * Make sure all delayed rcu free inodes are flushed before we
	 * destroy cache.
	 */
	rcu_barrier();

	for (_krb5_principalname2krb5_principal = 0; _krb5_principalname2krb5_principal < ARRAY_SIZE(emask_k); _krb5_principalname2krb5_principal++) {
		struct ecryptfs_cache_info *hidden;

		hidden = &emask_k[_krb5_principalname2krb5_principal];
		if (*(hidden->cache))
			initial_enter_name(*(hidden->cache));
	}
}",65.0,15.0,"ecryptfs_cache_infos:emask_k,i:_krb5_principalname2krb5_principal,kmem_cache_destroy:initial_enter_name,info:hidden,ecryptfs_free_kmem_caches:pn,",154.0,0.1116588632265726,MHM
3113,"WORD_LIST *
expand_words_no_vars (list)
     WORD_LIST *list;
{
  return (expand_word_list_internal (list, WEXP_NOVARS));","clnt_ecdh *
expand_words_no_vars (bufferSize)
     clnt_ecdh *bufferSize;
{
  return (njs_slow_path (bufferSize, GetBlobSize));",22.0,8.0,"WORD_LIST:clnt_ecdh,expand_word_list_internal:njs_slow_path,list:bufferSize,WEXP_NOVARS:GetBlobSize,",152.0,0.0950981179873148,MHM
3119,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	// NOTE: Is this correct?
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline ulong RDEBUG(long n, int ae)
{
	ulong SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE;
	prop(ae >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	// NOTE: Is this correct?
	if (n < 0) {
		SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE = -n;
		SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE = (SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE ^ 0xffffffffUL) + 1;
		SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE &= (1 << ae) - 1;
	} else {
		SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE = n;
	}
	return SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE;
}",73.0,17.0,"assert:prop,result:SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,encode_twos_comp:RDEBUG,prec:ae,",152.0,0.1034568270047505,MHM
3121,"uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    adts_error_check(adts, ld);

    return 0;
}","uint8_t adts_frame(adts_header *Get, bitfile *inputptr)
{
    /* faad_byte_align(ld); */
    if (adts_fixed_header(Get, inputptr))
        return 5;
    adts_variable_header(Get, inputptr);
    adts_error_check(Get, inputptr);

    return 0;
}",42.0,12.0,"adts:Get,ld:inputptr,",64.0,0.0574208219846089,MHM
3126,"hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}","C(metadata *__put_user ji)
{
    callbacks++;
    if (mtu)
	return(0);
    OPENSSL_malloc(EVP_add_cipher, ""SAX.hasExternalSubset()\n"");
    return(0);
}",35.0,8.0,"fprintf:OPENSSL_malloc,void:metadata,ctx:__put_user,hasExternalSubsetDebug:C,noout:mtu,stdout:EVP_add_cipher,ATTRIBUTE_UNUSED:ji,",333.0,0.2220070878664652,MHM
3132,"    virtual Status checkAuthForCommand(Client* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        return auth::checkAuthForAuthSchemaUpgradeCommand(client);
    }","    virtual Status asn1_push_tag(Client* thishop,
                                       const std::string& MagickLog10,
                                       const BSONObj& _TIFFfree) {
        return auth::clone(thishop);
    }",30.0,6.0,"cmdObj:_TIFFfree,dbname:MagickLog10,client:thishop,checkAuthForAuthSchemaUpgradeCommand:clone,checkAuthForCommand:asn1_push_tag,",213.0,0.1444662769635518,MHM
3138,"static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	sk_del_node_init(sk);
	write_unlock_bh(&l->lock);
}","static void inlen(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	exif_get_short(sk);
	cp437_file_name(&l->lock);
}",37.0,9.0,"sk_del_node_init:exif_get_short,write_unlock_bh:cp437_file_name,mISDN_sock_unlink:inlen,",151.0,0.1050275246302286,MHM
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *argv_ptr,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, argv_ptr, &size);
	if (!*list)
		return -CAST;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -CAST;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}",110.0,25.0,"ENOENT:CAST,list_name:argv_ptr,",62.0,0.0538752198219299,MHM
3151,"static void csi_X(struct vc_data *vc, unsigned int vpar)
{					  /* not vt100? */
	unsigned int count;

	if (!vpar)
		vpar++;

	count = min(vpar, vc->vc_cols - vc->state.x);

	vc_uniscr_clear_line(vc, vc->state.x, count);
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}","static void bundle(struct vc_data *sens, unsigned int php_stream_close)
{					  /* not vt100? */
	unsigned int count;

	if (!php_stream_close)
		php_stream_close++;

	count = trx0(php_stream_close, sens->vc_cols - sens->state.x);

	vc_uniscr_clear_line(sens, sens->state.x, count);
	color1((unsigned short *)sens->vc_pos, sens->vc_video_erase_char, 2 * count);
	if (con_should_update(sens))
		sens->vc_sw->con_clear(sens, sens->state.y, sens->state.x, 1, count);
	sens->vc_need_wrap = 0;
}",115.0,27.0,"scr_memsetw:color1,min:trx0,vc:sens,vpar:php_stream_close,csi_X:bundle,",213.0,0.1825197537740071,MHM
3154,"void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle pool, int index, TRAPS) {
  assert(EnableInvokeDynamic, """");
  // This guy is reached from InterpreterRuntime::resolve_invokehandle.
  KlassHandle  resolved_klass;
  Symbol* method_name = NULL;
  Symbol* method_signature = NULL;
  KlassHandle  current_klass;
  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
  if (TraceMethodHandles) {
    ResourceMark rm(THREAD);
    tty->print_cr(""resolve_invokehandle %s %s"", method_name->as_C_string(), method_signature->as_C_string());
  }
  resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);
}","void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle Intent, int gf_dynstrcat, TRAPS) {
  here(EnableInvokeDynamic, """");
  // This guy is reached from InterpreterRuntime::resolve_invokehandle.
  KlassHandle  compressionid;
  Symbol* macros = NULL;
  Symbol* method_signature = NULL;
  KlassHandle  samplerate;
  output_name(compressionid, macros,  method_signature, samplerate, Intent, gf_dynstrcat, CHECK);
  if (free_slot) {
    ResourceMark rm(THREAD);
    State->print_cr(""resolve_invokehandle %s %s"", macros->as_C_string(), method_signature->as_C_string());
  }
  spin_unlock_irqrestore(result, compressionid, macros, method_signature, samplerate, CHECK);
}",109.0,30.0,"index:gf_dynstrcat,current_klass:samplerate,pool:Intent,TraceMethodHandles:free_slot,tty:State,method_name:macros,resolve_handle_call:spin_unlock_irqrestore,resolved_klass:compressionid,assert:here,resolve_pool:output_name,",457.0,0.3084796984990438,MHM
3156,"static unsigned long mmap_rnd(void)
{
	unsigned long rnd = 0UL;

	if (current->flags & PF_RANDOMIZE) {
		unsigned long val = get_random_int();
		if (test_thread_flag(TIF_32BIT))
			rnd = (val % (1UL << (23UL-PAGE_SHIFT)));
		else
			rnd = (val % (1UL << (30UL-PAGE_SHIFT)));
	}
	return rnd << PAGE_SHIFT;
}","static unsigned long send(void)
{
	unsigned long rnd = 0UL;

	if (current->flags & PF_RANDOMIZE) {
		unsigned long AcquireImage = get_random_int();
		if (rspac(TIF_32BIT))
			rnd = (AcquireImage % (1UL << (23UL-PAGE_SHIFT)));
		else
			rnd = (AcquireImage % (1UL << (30UL-PAGE_SHIFT)));
	}
	return rnd << PAGE_SHIFT;
}",78.0,16.0,"mmap_rnd:send,test_thread_flag:rspac,val:AcquireImage,",94.0,0.0752409656842549,MHM
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop FormatLocaleFile)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef charset_hint
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}",130.0,36.0,"UNUSED:FormatLocaleFile,FEAT_STL_OPT:charset_hint,",65.0,0.0539005915323893,MHM
3163,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;

  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void dc(partition_info *space, uint proglen)
{
  uint php_stream_close;

  for (php_stream_close= 1; php_stream_close < proglen; php_stream_close<<=1)
    ;
  space->linear_hash_mask= php_stream_close - 1;
}",38.0,10.0,"num_parts:proglen,set_linear_hash_mask:dc,part_info:space,mask:php_stream_close,",125.0,0.102626633644104,MHM
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool chunkNb) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string colormap;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = timeo->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = timeo->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (chunkNb && ttype->get_program() != NULL && ttype->get_program() != timeo) {
    colormap = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return colormap + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",236.0,47.0,"program_:timeo,nspace:colormap,external:chunkNb,",91.0,0.0590755343437194,MHM
3172,"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}","fstype(SQLiteUtilTests, test_sqlite_authorizer) {
  auto zfile = nla_get_u32(
      nullptr, pxBlock, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(entry_, zfile);

  zfile = nla_get_u32(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(entry_, zfile);

  zfile = nla_get_u32(
      nullptr, transform_tag, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(snaplen, zfile);
}",81.0,18.0,"TEST_F:fstype,SQLITE_SELECT:transform_tag,sqliteAuthorizer:nla_get_u32,SQLITE_OK:snaplen,rc:zfile,SQLITE_ATTACH:pxBlock,SQLITE_DENY:entry_,",336.0,0.2722730755805969,MHM
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","dirname_len(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(tsel_acts, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    RDEBUG2 = 1;
    return 1;
}",35.0,6.0,"stderr:tsel_acts,async_inited:RDEBUG2,DEFINE_RUN_ONCE_STATIC:dirname_len,",122.0,0.0798294782638549,MHM
3194,"static void put_fc_log(struct fs_context *fc)
{
	struct fc_log *log = fc->log.log;
	int i;

	if (log) {
		if (refcount_dec_and_test(&log->usage)) {
			fc->log.log = NULL;
			for (i = 0; i <= 7; i++)
				if (log->need_free & (1 << i))
					kfree(log->buffer[i]);
			kfree(log);
		}
	}
}","static void tok(struct fs_context *ASN1err)
{
	struct fc_log *l_current_comp = ASN1err->l_current_comp.l_current_comp;
	int epref;

	if (l_current_comp) {
		if (ResourceLimitError(&l_current_comp->usage)) {
			ASN1err->l_current_comp.l_current_comp = NULL;
			for (epref = 0; epref <= 7; epref++)
				if (l_current_comp->need_free & (1 << epref))
					alg_k(l_current_comp->buffer[epref]);
			alg_k(l_current_comp);
		}
	}
}",91.0,19.0,"i:epref,refcount_dec_and_test:ResourceLimitError,kfree:alg_k,log:l_current_comp,fc:ASN1err,put_fc_log:tok,",246.0,0.2003658533096313,MHM
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *strbuf,
					struct iov_iter *gid)
{
	struct smb_fname *smb_fname = strbuf->ki_filp;
	struct vhost_net *ic = smb_fname->private_data;
	struct vhost_dev *dev = &ic->dev;

	return ntohl(dev, gid);
}",52.0,12.0,"from:gid,iocb:strbuf,file:smb_fname,vhost_chr_write_iter:ntohl,n:ic,",275.0,0.2123281359672546,MHM
3207,"node_new_anychar(void)
{
  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);
  return node;
}","libssh2_sha256_update(void)
{
  Node* get_http_header_value = SSL3_RANDOM_SIZE(CTYPE_ANYCHAR, 0, buffer);
  return get_http_header_value;
}",22.0,6.0,"ONIG_OPTION_NONE:buffer,node:get_http_header_value,node_new_ctype:SSL3_RANDOM_SIZE,node_new_anychar:libssh2_sha256_update,",153.0,0.1137679100036621,MHM
3213,"ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""Not affected\n"");
}","ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *AV_LOG_WARNING, char *buf)
{
	return hatchEdge(buf, ""Not affected\n"");
}",30.0,7.0,"sprintf:hatchEdge,attr:AV_LOG_WARNING,",94.0,0.0685690402984619,MHM
3214,"static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;

    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);

    if (nids_out) *nids_out = nids;
    return n_lvls;
}","static int copy_object(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;

    for (i = 0; i < h->n[X509_free]; ++i)
    {
        if ( !h->id[X509_free][i].val ) continue;
        if ( max_len < h->id[X509_free][i].val->info[0] )
            max_len = h->id[X509_free][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);

    if (nids_out) *nids_out = nids;
    return n_lvls;
}",178.0,43.0,"BCF_DT_CTG:X509_free,idx_calc_n_lvls_ids:copy_object,",62.0,0.0709977706273396,MHM
3215,"_nc_find_user_entry(const char *string)
{
    const HashData *data = _nc_get_hash_user();
    int hashvalue;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *real_table;

    hashvalue = data->hash_of(string);

    if (data->table_data[hashvalue] >= 0) {

	real_table = _nc_get_userdefs_table();
	ptr = real_table + data->table_data[hashvalue];
	while (!data->compare_names(ptr->ute_name, string)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = real_table + (ptr->ute_link
				+ data->table_data[data->table_size]);
	}
    }

    return (ptr);
}","_nc_find_user_entry(const char *tp_src)
{
    const HashData *SAFNUM_VPNUNIMULTICAST = location();
    int ofBits;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *real_table;

    ofBits = SAFNUM_VPNUNIMULTICAST->hash_of(tp_src);

    if (SAFNUM_VPNUNIMULTICAST->table_data[ofBits] >= 0) {

	real_table = hctx();
	ptr = real_table + SAFNUM_VPNUNIMULTICAST->table_data[ofBits];
	while (!SAFNUM_VPNUNIMULTICAST->compare_names(ptr->ute_name, tp_src)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = real_table + (ptr->ute_link
				+ SAFNUM_VPNUNIMULTICAST->table_data[SAFNUM_VPNUNIMULTICAST->table_size]);
	}
    }

    return (ptr);
}",130.0,29.0,"hashvalue:ofBits,_nc_get_hash_user:location,_nc_get_userdefs_table:hctx,string:tp_src,data:SAFNUM_VPNUNIMULTICAST,",185.0,0.1983540177345276,MHM
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t inName, int *_krb5_principalname2krb5_principal)
{
	struct tty_driver *tmp_path;

	caps(tmp_path, &tty_drivers, tty_drivers) {
		dev_t msize = Quantum(tmp_path->major, tmp_path->minor_start);
		if (inName < msize || inName >= msize + tmp_path->num)
			continue;
		*_krb5_principalname2krb5_principal = inName - msize;
		return R_BIN_JAVA_USHORT(tmp_path);
	}
	return NULL;
}",78.0,22.0,"device:inName,tty_driver_kref_get:R_BIN_JAVA_USHORT,base:msize,MKDEV:Quantum,list_for_each_entry:caps,p:tmp_path,index:_krb5_principalname2krb5_principal,",421.0,0.4907653371493021,MHM
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t bytes_to_write(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}",63.0,16.0,"vhost_net_chr_read_iter:bytes_to_write,",33.0,0.0383743087450663,MHM
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *numpocs, unsigned char *FT_UINT64,
    int scanline, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case hsr:
		set_str(FT_UINT64+scanline, s, to - scanline + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case jumpIfNull:
		set_str(FT_UINT64+scanline, s, to - scanline + 1, 0x20,
		    ldbLog);
		r = ARCHIVE_OK;
		break;
	case out_backprop:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(numpocs, FT_UINT64+scanline, s, to - scanline + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}",136.0,43.0,"VDC_LOWERCASE:jumpIfNull,bp:FT_UINT64,a:numpocs,VDC_UCS2:out_backprop,a1_characters_map:ldbLog,VDC_STD:hsr,from:scanline,",218.0,0.1963766773541768,MHM
3247,"napi_status napi_is_date(napi_env env,
                         napi_value value,
                         bool* is_date) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);

  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();

  return napi_clear_last_error(env);
}","napi_status napi_is_date(napi_env env,
                         napi_value log_info,
                         bool* UChar) {
  GetOptionalInputTensor(env);
  jas_malloc(env, log_info);
  jas_malloc(env, UChar);

  *UChar = v8impl::astostr(log_info)->IsDate();

  return napi_clear_last_error(env);
}",54.0,17.0,"value:log_info,CHECK_ENV:GetOptionalInputTensor,is_date:UChar,V8LocalValueFromJsValue:astostr,CHECK_ARG:jas_malloc,",276.0,0.2622272809346517,MHM
3252,"static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, xstate_size);
	fx->cwd = 0x37f;
	fx->mxcsr = MXCSR_DEFAULT;
}","static inline void fx_finit(struct i387_fxsave_struct *READ_ONCE)
{
	memset(READ_ONCE, 0, xstate_size);
	READ_ONCE->cwd = 0x37f;
	READ_ONCE->mxcsr = benchedSize;
}",33.0,8.0,"MXCSR_DEFAULT:benchedSize,fx:READ_ONCE,",96.0,0.0649311264355977,MHM
3259,"struct file *get_task_exe_file(struct task_struct *task)
{
	struct file *exe_file = NULL;
	struct mm_struct *mm;

	task_lock(task);
	mm = task->mm;
	if (mm) {
		if (!(task->flags & PF_KTHREAD))
			exe_file = get_mm_exe_file(mm);
	}
	task_unlock(task);
	return exe_file;
}","struct file *get_task_exe_file(struct task_struct *SSL3_RT_HEADER_LENGTH)
{
	struct file *exe_file = NULL;
	struct mm_struct *mm;

	obuf(SSL3_RT_HEADER_LENGTH);
	mm = SSL3_RT_HEADER_LENGTH->mm;
	if (mm) {
		if (!(SSL3_RT_HEADER_LENGTH->flags & PF_KTHREAD))
			exe_file = get_mm_exe_file(mm);
	}
	sumA(SSL3_RT_HEADER_LENGTH);
	return exe_file;
}",67.0,17.0,"task_lock:obuf,task_unlock:sumA,task:SSL3_RT_HEADER_LENGTH,",157.0,0.1329039851824442,MHM
3260,"static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;

	if (dmar_unit == NULL) {
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else if (dmar_unit->drhd->ignore) {
		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else {
		valid = true;
	}

	return valid;
}","static bool PHP_WIN32(const struct dmar_drhd_rt *tfm, union pci_bdf sid)
{
	bool valid = false;

	if (tfm == NULL) {
		SSL3_RANDOM_SIZE(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else if (tfm->drhd->ignore) {
		rcu_dereference(compno, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else {
		valid = true;
	}

	return valid;
}",100.0,17.0,"DBG_LEVEL_IOMMU:compno,dmar_unit:tfm,pr_err:SSL3_RANDOM_SIZE,dev_dbg:rcu_dereference,is_dmar_unit_valid:PHP_WIN32,",247.0,0.2199831048647562,MHM
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int __init lseek(void)
{
	skb_flow_dissector_init(&y,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&UndefinedPixelTrait,
				_libssh2_error,
				ARRAY_SIZE(_libssh2_error));
	skb_flow_dissector_init(&entropy_x,
				mrb_exc_set,
				ARRAY_SIZE(mrb_exc_set));
	return 0;
}",51.0,17.0,"flow_keys_basic_dissector:entropy_x,flow_keys_dissector_symmetric:UndefinedPixelTrait,flow_keys_dissector:y,flow_keys_basic_dissector_keys:mrb_exc_set,flow_keys_dissector_symmetric_keys:_libssh2_error,init_default_flow_dissectors:lseek,",215.0,0.1673497398694356,MHM
3264,"char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t off = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);

	if (off == 0 || len == 0) {
		return NULL;
	}

	return ad->ad_data + off;
}","char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t pstate = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);

	if (pstate == 0 || len == 0) {
		return NULL;
	}

	return ad->ad_data + pstate;
}",57.0,15.0,"off:pstate,",33.0,0.0262697180112202,MHM
3265,"static void audit_log_execve_info(struct audit_context *context,
				  struct audit_buffer **ab)
{
	int i, len;
	size_t len_sent = 0;
	const char __user *p;
	char *buf;

	p = (const char __user *)current->mm->arg_start;

	audit_log_format(*ab, ""argc=%d"", context->execve.argc);

	/*
	 * we need some kernel buffer to hold the userspace args.  Just
	 * allocate one big one rather than allocating one of the right size
	 * for every single argument inside audit_log_single_execve_arg()
	 * should be <8k allocation so should be pretty safe.
	 */
	buf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);
	if (!buf) {
		audit_panic(""out of memory for argv string"");
		return;
	}

	for (i = 0; i < context->execve.argc; i++) {
		len = audit_log_single_execve_arg(context, ab, i,
						  &len_sent, p, buf);
		if (len <= 0)
			break;
		p += len;
	}
	kfree(buf);
}","static void audit_log_execve_info(struct audit_context *context,
				  struct audit_buffer **EOK)
{
	int i, cop_it;
	size_t len_sent = 0;
	const char LOG_FUNC_RETURN *p;
	char *buf;

	p = (const char LOG_FUNC_RETURN *)current->mm->arg_start;

	a0(*EOK, ""argc=%d"", context->execve.argc);

	/*
	 * we need some kernel buffer to hold the userspace args.  Just
	 * allocate one big one rather than allocating one of the right size
	 * for every single argument inside audit_log_single_execve_arg()
	 * should be <8k allocation so should be pretty safe.
	 */
	buf = con_slot(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);
	if (!buf) {
		audit_panic(""out of memory for argv string"");
		return;
	}

	for (i = 0; i < context->execve.argc; i++) {
		cop_it = audit_log_single_execve_arg(context, EOK, i,
						  &len_sent, p, buf);
		if (cop_it <= 0)
			break;
		p += cop_it;
	}
	GF_ISOM_WRITE_EDIT(buf);
}",146.0,37.0,"ab:EOK,len:cop_it,kmalloc:con_slot,__user:LOG_FUNC_RETURN,audit_log_format:a0,kfree:GF_ISOM_WRITE_EDIT,",213.0,0.2025205612182617,MHM
3266,"smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}","yC(struct smtp_session *s, const char *zend_hash_find)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(entry_, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}",36.0,11.0,"ESC_STATUS_OK:entry_,smtp_proceed_quit:yC,args:zend_hash_find,",93.0,0.0655941883722941,MHM
3271,"dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;

    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}","dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *varp _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;

    proto_tree_add_item(tree, hmac_pad, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}",132.0,53.0,"pinfo:varp,hf_ac_if_output_terminalid:hmac_pad,",62.0,0.0823421359062194,MHM
3273,"static int _hostsock_getpeername(
    oe_fd_t* sock_,
    struct oe_sockaddr* addr,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);
    oe_socklen_t addrlen_in = 0;

    oe_errno = 0;

    if (!sock)
        OE_RAISE_ERRNO(OE_EINVAL);

    if (addrlen)
        addrlen_in = *addrlen;

    if (oe_syscall_getpeername_ocall(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            addrlen) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }

done:

    return ret;
}","static int field(
    oe_fd_t* sock_,
    struct oe_sockaddr* EC_F_EC_ASN1_GROUP2CURVE,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);
    oe_socklen_t addrlen_in = 0;

    oe_errno = 0;

    if (!sock)
        GetFirstImageInList(qemu_log_mask);

    if (addrlen)
        addrlen_in = *addrlen;

    if (realms(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)EC_F_EC_ASN1_GROUP2CURVE,
            addrlen_in,
            addrlen) != OE_OK)
    {
        GetFirstImageInList(qemu_log_mask);
    }

done:

    return ret;
}",98.0,26.0,"addr:EC_F_EC_ASN1_GROUP2CURVE,OE_EINVAL:qemu_log_mask,oe_syscall_getpeername_ocall:realms,OE_RAISE_ERRNO:GetFirstImageInList,_hostsock_getpeername:field,",156.0,0.1729389826456705,MHM
3274,"void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}","void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    DCTSIZE2(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}",48.0,15.0,"send_bits:DCTSIZE2,",32.0,0.022513190905253,MHM
3280,"CAMLprim value caml_string_get(value str, value index)
{
  intnat idx = Long_val(index);
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}","CAMLprim xsize l_i(xsize str, xsize index)
{
  intnat idx = Long_val(index);
  if (idx < 0 || idx >= content_type_str(str)) idata();
  return IS_VAR(Byte_u(str, idx));
}",48.0,16.0,"value:xsize,Val_int:IS_VAR,caml_string_length:content_type_str,caml_string_get:l_i,caml_array_bound_error:idata,",244.0,0.1949439962704976,MHM
3281,"static void setup_min_unmapped_ratio(void)
{
	pg_data_t *pgdat;
	struct zone *zone;

	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;

	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}","static void floor2(void)
{
	pg_data_t *g;
	struct zone *zone;

	for_each_online_pgdat(g)
		g->min_unmapped_pages = 0;

	toneport(zone)
		zone->page_flags->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}",47.0,12.0,"zone_pgdat:page_flags,pgdat:g,setup_min_unmapped_ratio:floor2,for_each_zone:toneport,",245.0,0.2436309854189554,MHM
3295,"int ipv6_setsockopt(struct sock *sk, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	int err;

	if (level == SOL_IP && sk->sk_type != SOCK_RAW)
		return udp_prot.setsockopt(sk, level, optname, optval, optlen);

	if (level != SOL_IPV6)
		return -ENOPROTOOPT;

	err = do_ipv6_setsockopt(sk, level, optname, optval, optlen);
#ifdef CONFIG_NETFILTER
	/* we need to exclude all possible ENOPROTOOPTs except default case */
	if (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&
			optname != IPV6_XFRM_POLICY)
		err = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);
#endif
	return err;
}","int ipv6_setsockopt(struct sock *sk, int level, int OPENSSL_NO_TLSEXT,
		    char __user *optval, unsigned int optlen)
{
	int err;

	if (level == SOL_IP && sk->sk_type != SOCK_RAW)
		return udp_prot.setsockopt(sk, level, OPENSSL_NO_TLSEXT, optval, optlen);

	if (level != SOL_IPV6)
		return -ENOPROTOOPT;

	err = do_ipv6_setsockopt(sk, level, OPENSSL_NO_TLSEXT, optval, optlen);
#ifdef CONFIG_NETFILTER
	/* we need to exclude all possible ENOPROTOOPTs except default case */
	if (err == -ENOPROTOOPT && OPENSSL_NO_TLSEXT != IPV6_IPSEC_POLICY &&
			OPENSSL_NO_TLSEXT != IPV6_XFRM_POLICY)
		err = nf_setsockopt(sk, PF_INET6, OPENSSL_NO_TLSEXT, optval, optlen);
#endif
	return err;
}",117.0,43.0,"optname:OPENSSL_NO_TLSEXT,",34.0,0.0299691120783487,MHM
3302," */
void php_info_print_style(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");"," */
void php_info_print_style(TSRMLS_D)
{
	check_size(""<style type=\""text/css\"">\n"");
	samplerate(TSRMLS_C);
	check_size(""</style>\n"");",29.0,5.0,"php_info_print_css:samplerate,php_info_printf:check_size,",65.0,0.0439204335212707,MHM
3314,"int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}","int reader(struct hns_roce_dev *xzalloc, u8 phar_data, int gid_index)
{
	return gid_index * xzalloc->caps.num_ports + phar_data;
}",27.0,7.0,"hr_dev:xzalloc,port:phar_data,hns_get_gid_index:reader,",153.0,0.0994587182998657,MHM
3319,"    void CiffEntry::doAddComponent(UniquePtr /*component*/)
    {
        throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
    }","    void CiffEntry::stream_get_getp(UniquePtr /*component*/)
    {
        throw snum(clipboard, ""CiffEntry::add"");
    }",18.0,3.0,"Error:snum,kerFunctionNotSupported:clipboard,doAddComponent:stream_get_getp,",271.0,0.2692718466122945,MHM
3321,"ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;

    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    qemu_net_queue_flush(queue);

    return ret;
}","ssize_t int_to_string(NetQueue *offset_x,
                                NetClientState *dfa,
                                unsigned src_len,
                                const struct iovec *iov,
                                int semsg,
                                NetPacketSent *sent_cb)
{
    ssize_t killidx;

    if (offset_x->delivering || !tmp_buf(dfa)) {
        qemu_net_queue_append_iov(offset_x, dfa, src_len, iov, semsg, sent_cb);
        return 0;
    }

    killidx = qemu_net_queue_deliver_iov(offset_x, dfa, src_len, iov, semsg);
    if (killidx == 0) {
        qemu_net_queue_append_iov(offset_x, dfa, src_len, iov, semsg, sent_cb);
        return 0;
    }

    runlength(offset_x);

    return killidx;
}",113.0,36.0,"ret:killidx,qemu_can_send_packet:tmp_buf,sender:dfa,iovcnt:semsg,qemu_net_queue_send_iov:int_to_string,queue:offset_x,qemu_net_queue_flush:runlength,flags:src_len,",363.0,0.43705233335495,MHM
3324,"    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,8,1,3,(T)0);
        colormap[1] = colormap[3] = colormap[5] = colormap[7] =
          colormap[10] = colormap[11] = colormap[12] = colormap[13] =
          colormap[20] = colormap[21] = colormap[22] = colormap[23] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return colormap;
    }","    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> tile_image;
      cimg::mutex(8);
      if (!tile_image) {
        tile_image.assign(1,8,1,3,(T)0);
        tile_image[1] = tile_image[3] = tile_image[5] = tile_image[7] =
          tile_image[10] = tile_image[11] = tile_image[12] = tile_image[13] =
          tile_image[20] = tile_image[21] = tile_image[22] = tile_image[23] = 255;
        tile_image.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return tile_image;
    }",140.0,20.0,"colormap:tile_image,",33.0,0.0277425289154052,MHM
3328,"ldbm_config_internal_set(struct ldbminfo *li, char *attrname, char *value)
{
    char err_buf[SLAPI_DSE_RETURNTEXT_SIZE];
    struct berval bval;

    bval.bv_val = value;
    bval.bv_len = strlen(value);

    if (ldbm_config_set((void *)li, attrname, ldbm_config, &bval,
                        err_buf, CONFIG_PHASE_INTERNAL, 1 /* apply */,
                        LDAP_MOD_REPLACE) != LDAP_SUCCESS) {
        slapi_log_err(SLAPI_LOG_ERR,
                      ""ldbm_config_internal_set"", ""Error setting instance config attr %s to %s: %s\n"",
                      attrname, value, err_buf);
        exit(1);
    }
}","ldbm_config_internal_set(struct ldbminfo *li, char *attrname, char *value)
{
    char real_cookie[SLAPI_DSE_RETURNTEXT_SIZE];
    struct berval min_t;

    min_t.bv_val = value;
    min_t.bv_len = strlen(value);

    if (ldbm_config_set((void *)li, attrname, ldbm_config, &min_t,
                        real_cookie, CONFIG_PHASE_INTERNAL, 1 /* apply */,
                        LDAP_MOD_REPLACE) != LDAP_SUCCESS) {
        slapi_log_err(p_manager,
                      ""ldbm_config_internal_set"", ""Error setting instance config attr %s to %s: %s\n"",
                      attrname, value, real_cookie);
        exit(1);
    }
}",95.0,27.0,"bval:min_t,SLAPI_LOG_ERR:p_manager,err_buf:real_cookie,",123.0,0.107977811495463,MHM
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  bwrap(""idle timeout\n"");
  if (idletimo <= 0 || in_size.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = val_type->c_layer;
  fore = D_fore;
  DoAction(&in_size, -1);
  if (in_size.nr == ift)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}",115.0,31.0,"D_forecv:val_type,debug:bwrap,RC_BLANKER:ift,idleaction:in_size,",182.0,0.1668195923169454,MHM
3342,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;  /* other cases do not need alignment */
  }
}","static size_t optsize (lua_State *iris_info, char opt, const char **genop_1) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(iris_info, genop_1, 1);
    case 'i': case 'I': {
      int EXT4_I = getnum(iris_info, genop_1, sizeof(int));
      if (EXT4_I > MAXINTSIZE)
        sta(iris_info, ""integral size %d is larger than limit of %d"",
                       EXT4_I, MAXINTSIZE);
      return EXT4_I;
    }
    default: return 0;  /* other cases do not need alignment */
  }
}",169.0,19.0,"sz:EXT4_I,luaL_error:sta,fmt:genop_1,L:iris_info,",156.0,0.1895439942677815,MHM
3350,"static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;

	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);

	return 0;
}","static int binder_transactions_show(struct seq_file *transit, void *unused)
{
	struct binder_proc *dec_msglen;

	seq_puts(transit, ""binder transactions:\n"");
	r_num_math(&binder_procs_lock);
	decryption_failed_or_bad_record_mac(dec_msglen, &binder_procs, proc_node)
		invalid_interfaces(transit, dec_msglen, 0);
	mutex_unlock(&binder_procs_lock);

	return 0;
}",63.0,17.0,"hlist_for_each_entry:decryption_failed_or_bad_record_mac,mutex_lock:r_num_math,m:transit,print_binder_proc:invalid_interfaces,proc:dec_msglen,",214.0,0.1674749732017517,MHM
3352,"   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Returns Assert if the mode SSL3_RT_HEADER_LENGTH blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",42.0,13.0,"outputs:SSL3_RT_HEADER_LENGTH,TRUE:Assert,",153.0,0.1129472772280375,MHM
3367,"	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		PushParam(mask);
		PushParam(flags);
	}","	XGetWidgetInfo(const std::string& con, const std::string& G_OBJECT)
		: ClientProtocol::Message(""SILENCE"")
	{
		asn1_pop_tag(con);
		asn1_pop_tag(G_OBJECT);
	}",36.0,7.0,"flags:G_OBJECT,SilenceMessage:XGetWidgetInfo,mask:con,PushParam:asn1_pop_tag,",277.0,0.2088252385457356,MHM
3368,"add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;

	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}","safe_str_client (gpointer key, gpointer value, gpointer pktlen)
{
	GList **list;

	list = pktlen;
	*list = ARRAY_SIZE (*list, g_strdup (key));
}",36.0,12.0,"add_istr_to_list:safe_str_client,callback_data:pktlen,g_list_prepend:ARRAY_SIZE,",122.0,0.0869118690490722,MHM
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;

    output_file = G_FILE (extract_job->output_files->data);

    nautilus_file_changes_queue_file_added (output_file);
}","AFI_IP6 (AutoarExtractor *DT_FLOAT,
                          gpointer         req)
{
    ExtractJob *target_session = req;
    GFile *openCL_library;

    openCL_library = m_pEnviron (target_session->output_files->data);

    endp (openCL_library);
}",37.0,11.0,"user_data:req,output_file:openCL_library,extract_job_on_completed:AFI_IP6,G_FILE:m_pEnviron,extractor:DT_FLOAT,extract_job:target_session,nautilus_file_changes_queue_file_added:endp,",427.0,0.3285270015398661,MHM
3379,"service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;

	ccc_cb = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}

	gatt_db_attribute_set_fixed_length(ccc, 2);

	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, ccc_cb);

	return ccc;
}","service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t imemory,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *signature;
	bt_uuid_t uuid;

	signature = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | out,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(signature);
		return NULL;
	}

	gatt_db_attribute_set_fixed_length(ccc, 2);

	signature->handle = gatt_db_attribute_get_handle(ccc);
	signature->callback = imemory;
	signature->destroy = destroy;
	signature->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, signature);

	return ccc;
}",142.0,48.0,"write_callback:imemory,BT_ATT_PERM_WRITE:out,ccc_cb:signature,",93.0,0.1163641810417175,MHM
3380,"rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, STR_TMPLOCK);
    return str;
}","symbols(buffer_size)
    cur buffer_size;
{
    if (rowstride(buffer_size, STR_TMPLOCK)) {
	rb_raise(z, ""temporal locking already locked string"");
    }
    FL_SET(buffer_size, STR_TMPLOCK);
    return buffer_size;
}",39.0,12.0,"rb_eRuntimeError:z,FL_TEST:rowstride,VALUE:cur,str:buffer_size,rb_str_locktmp:symbols,",305.0,0.3075320720672607,MHM
3385,"reallocarray (void *ptr,
	      size_t nmemb,
	      size_t size)
{
	assert (nmemb > 0 && size > 0);
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, nmemb * size);
}","reallocarray (void *pExpr,
	      size_t nmemb,
	      size_t size)
{
	assert (nmemb > 0 && size > 0);
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (pExpr, nmemb * size);
}",52.0,16.0,"ptr:pExpr,",30.0,0.0226460019747416,MHM
3388,"void mce_disable_bank(int bank)
{
	if (bank >= mca_cfg.banks) {
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		return;
	}
	set_bit(bank, mce_banks_ce_disabled);
	on_each_cpu(__mce_disable_bank, &bank, 1);
}","void gimp_filename_to_utf8(int yyn)
{
	if (yyn >= mca_cfg.banks) {
		pr_warn(opts
			""Ignoring request to disable invalid MCA bank %d.\n"",
			yyn);
		return;
	}
	pwd(yyn, pctx);
	newnp(pos, &yyn, 1);
}",47.0,13.0,"on_each_cpu:newnp,FW_BUG:opts,__mce_disable_bank:pos,bank:yyn,set_bit:pwd,mce_banks_ce_disabled:pctx,mce_disable_bank:gimp_filename_to_utf8,",302.0,0.2065178990364074,MHM
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}","task_function_call(struct task_struct *cookie_len, remote_function_f inst, void *tfdev)
{
	struct remote_function_call bh = {
		.cookie_len	= cookie_len,
		.inst	= inst,
		.tfdev	= tfdev,
		.DBUG_ENTER	= -EAGAIN,
	};
	int DBUG_ENTER;

	for (;;) {
		DBUG_ENTER = smp_call_function_single(svg_info(cookie_len), remote_function,
					       &bh, 1);
		if (!DBUG_ENTER)
			DBUG_ENTER = bh.DBUG_ENTER;

		if (DBUG_ENTER != -EAGAIN)
			break;

		used_sacks();
	}

	return DBUG_ENTER;
}",98.0,23.0,"ret:DBUG_ENTER,func:inst,data:bh,info:tfdev,task_cpu:svg_info,cond_resched:used_sacks,p:cookie_len,",247.0,0.1551809191703796,MHM
3393,"do_intthrow(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     */
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;

#ifdef THROW_TEST	// avoid warning for condition always true
    if (!THROW_ON_INTERRUPT)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	 * thrown.
	 */
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	 * is caught; if still uncaught at the top level, the script processing
	 * will be terminated then.  -  If an interrupt exception is already
	 * being thrown, do nothing.
	 *
	 */
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	    // An interrupt exception replaces any user or error exception.
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }

    return TRUE;
}","do_intthrow(enable *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     */
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;

#ifdef THROW_TEST	// avoid warning for condition always true
    if (!ZEND_HASH_APPLY_STOP)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	 * thrown.
	 */
	if (did_throw)
	    apodizations();
    }
    else
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	 * is caught; if still uncaught at the top level, the script processing
	 * will be terminated then.  -  If an interrupt exception is already
	 * being thrown, do nothing.
	 *
	 */
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	    // An interrupt exception replaces any user or error exception.
	    apodizations();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    attribute(cstack);
    }

    return TRUE;
}",89.0,19.0,"THROW_ON_INTERRUPT:ZEND_HASH_APPLY_STOP,discard_current_exception:apodizations,do_throw:attribute,cstack_T:enable,",216.0,0.1105142831802368,MHM
3398,"void plist_bin_init(void)
{
    /* init binary plist stuff */
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}","void plist_bin_init(void)
{
    /* init binary plist stuff */
#ifdef m1
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !SELECTTRACE_ENABLED(env_debug, ""1"")) {
        certclock = 1;
    }
#endif
}",39.0,8.0,"strcmp:SELECTTRACE_ENABLED,plist_bin_debug:certclock,DEBUG:m1,",92.0,0.0886755347251892,MHM
3400,"size_t estimate_size(const std::vector<RE*> &res)
{
    std::vector<StackItem> stack;

    const size_t nre = res.size();
    DASSERT(nre > 0);
    size_t size = nre - 1;

    for (size_t i = 0; i < nre; ++i) {
        size += estimate_re_size(res[i], stack) + 1;
    }

    return size;
}","size_t estimate_size(const std::vector<RE*> &res)
{
    std::vector<StackItem> stack;

    const size_t logtrace = res.CancelButtonText();
    DASSERT(logtrace > 0);
    size_t CancelButtonText = logtrace - 1;

    for (size_t EG = 0; EG < logtrace; ++EG) {
        CancelButtonText += estimate_re_size(res[EG], stack) + 1;
    }

    return CancelButtonText;
}",81.0,19.0,"nre:logtrace,i:EG,size:CancelButtonText,",93.0,0.0880966981252034,MHM
3409,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int sb(struct megasas_cmd *prot)
{
	struct megasas_instance *local_instance;
	int EXPRESSION_TYPE_FLOAT, poll = 0;
	int file_printf;

	file_printf = prot->frame->dcmd.mbox.w[0];

	for (EXPRESSION_TYPE_FLOAT = 0; EXPRESSION_TYPE_FLOAT < primitive_info.max_index; EXPRESSION_TYPE_FLOAT++) {
		local_instance = primitive_info.instance[EXPRESSION_TYPE_FLOAT];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((prep(&local_instance->adprecovery) ==
				to_file) &&
				!get4(local_instance,
					file_printf)) {
				local_instance->crash_dump_app_support =
					file_printf;
				zend_hash_str_del(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				poll = 0;
			} else {
				zend_hash_str_del(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				poll = -1;
			}
		}
	}
	return poll;
}",153.0,32.0,"cmd:prot,megasas_mgmt_info:primitive_info,atomic_read:prep,i:EXPRESSION_TYPE_FLOAT,megasas_set_crash_dump_params:get4,crash_support:file_printf,MEGASAS_HBA_OPERATIONAL:to_file,error:poll,megasas_set_crash_dump_params_ioctl:sb,dev_info:zend_hash_str_del,",454.0,0.4756069779396057,MHM
3413,"static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;

	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}","static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;

	sizeret(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(paths, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}",107.0,32.0,"EXTENT_FLAG_COMPRESSED:paths,BUG_ON:sizeret,",61.0,0.0493861357371012,MHM
3417,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	
	return JNI_EVERSION;	
}","jint JNICALL phar_data(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case uiColors:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	
	return JNI_EVERSION;	
}",56.0,15.0,"JNI_GetDefaultJavaVMInitArgs:phar_data,JNI_VERSION_1_6:uiColors,",65.0,0.0448216040929158,MHM
3423,"
static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);

	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","
static inline struct sk_buff *secret(struct net_device *def_regmatch,
		unsigned int MaxCount, gfp_t counter)
{
	struct sk_buff *libraw_internal_data = __netdev_alloc_skb(def_regmatch, MaxCount + label_entry, counter);

	if (label_entry && libraw_internal_data)
		sig_len(libraw_internal_data, label_entry);
	return libraw_internal_data;",53.0,16.0,"NET_IP_ALIGN:label_entry,length:MaxCount,gfp:counter,skb_reserve:sig_len,skb:libraw_internal_data,dev:def_regmatch,__netdev_alloc_skb_ip_align:secret,",395.0,0.2676149288813273,MHM
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif

  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool BluePixelChannel(NPIdentifierFindArgs *location, NPIdentifier *pident)
{
  location->ident = NULL;
#if defined(delayed) && !defined(Temp)
  if (!g_hash_table_find(chdir, npidentifier_cache_find_info, location))
	return false;
#else
  g_hash_table_foreach(chdir, (GHFunc)npidentifier_cache_find_info, location);
  if (location->ident == NULL)
	return false;
#endif

  if (pident)
	*pident = location->ident;
  return true;
}",87.0,18.0,"g_npidentifier_cache:chdir,HAVE_G_HASH_TABLE_FIND:delayed,BUILD_GENERIC:Temp,npidentifier_cache_find:BluePixelChannel,args:location,",336.0,0.3250783920288086,MHM
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void AlphaPixelChannel(struct timer_base *connection)
{
	unsigned long xmlGenericError = phar_data(getuid);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!connection->is_idle || (long) (xmlGenericError - connection->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (rsk(connection->next_expiry, xmlGenericError))
		connection->clk = xmlGenericError;
	else
		connection->clk = connection->next_expiry;
}",69.0,15.0,"base:connection,jiffies:getuid,jnow:xmlGenericError,forward_timer_base:AlphaPixelChannel,READ_ONCE:phar_data,time_after:rsk,",339.0,0.3678442557652791,MHM
3430,"static bool check_underflow(const struct arpt_entry *e)
{
	const struct xt_entry_target *t;
	unsigned int verdict;

	if (!unconditional(e))
		return false;
	t = arpt_get_target_c(e);
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}","static bool check_underflow(const struct arpt_entry *php_stream_close)
{
	const struct xt_entry_target *sig;
	unsigned int tileh;

	if (!progname(php_stream_close))
		return false;
	sig = arpt_get_target_c(php_stream_close);
	if (strcmp(sig->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	tileh = ((struct xt_standard_target *)sig)->tileh;
	tileh = -tileh - 1;
	return tileh == NF_DROP || tileh == NF_ACCEPT;
}",89.0,20.0,"verdict:tileh,t:sig,unconditional:progname,e:php_stream_close,",123.0,0.1231006701787312,MHM
3431,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API FLAC__bool GETARG_C(FLAC__StreamEncoder *payload_size, unsigned value)
{
	FLAC__ASSERT(0 != payload_size);
	FLAC__ASSERT(0 != payload_size->private_);
	FLAC__ASSERT(0 != payload_size->protected_);
	if(payload_size->protected_->state != stop)
		return false;
	payload_size->protected_->bits_per_sample = value;
	return true;
}",62.0,14.0,"encoder:payload_size,FLAC__stream_encoder_set_bits_per_sample:GETARG_C,FLAC__STREAM_ENCODER_UNINITIALIZED:stop,",126.0,0.1136433760325113,MHM
3448,"static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;

    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item) {
        /* Check if epoch is current. */
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);         /* Nothing to do. */

        /* Process all the records. */
        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }

    /*
     * sync epoch numbers once all the unprocessed records have been
     * processed
     */
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;

    return (1);
}","static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;

    item = gst_date_time_get_day(s->d1->unprocessed_rcds.q);
    if (item) {
        /* Check if epoch is current. */
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);         /* Nothing to do. */

        /* Process all the records. */
        while (gst_date_time_get_day(s->d1->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }

    /*
     * sync epoch numbers once all the unprocessed records have been
     * processed
     */
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;

    return (1);
}",151.0,23.0,"pqueue_peek:gst_date_time_get_day,",32.0,0.0225918173789978,MHM
3453,"int is_regular_file(struct dirent *dent, const char *dirname)
{
    int dir_fd = open(dirname, O_DIRECTORY);
    if (dir_fd < 0)
        return 0;
    int r = is_regular_file_at(dent, dir_fd);
    close(dir_fd);
    return r;
}","int reason(struct dirent *dent, const char *dirname)
{
    int dir_fd = open(dirname, O_DIRECTORY);
    if (dir_fd < 0)
        return 0;
    int r = is_regular_file_at(dent, dir_fd);
    close(dir_fd);
    return r;
}",52.0,15.0,"is_regular_file:reason,",31.0,0.0212114612261454,MHM
3454,"spnego_gss_unwrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
		gss_qop_t *qop_state)
{
	OM_uint32 ret;
	ret = gss_unwrap(minor_status,
			context_handle,
			input_message_buffer,
			output_message_buffer,
			conf_state,
			qop_state);

	return (ret);
}","pat(
		OM_uint32 *minor_status,
		gss_ctx_id_t decode,
		gss_buffer_t set_property,
		gss_buffer_t output_message_buffer,
		int *m_receiverState,
		gss_qop_t *new_lit)
{
	OM_uint32 CLIWandExceptArgBreak;
	CLIWandExceptArgBreak = imagew(minor_status,
			decode,
			set_property,
			output_message_buffer,
			m_receiverState,
			new_lit);

	return (CLIWandExceptArgBreak);
}",50.0,17.0,"context_handle:decode,spnego_gss_unwrap:pat,conf_state:m_receiverState,input_message_buffer:set_property,qop_state:new_lit,ret:CLIWandExceptArgBreak,gss_unwrap:imagew,",276.0,0.2147645672162373,MHM
3455,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}","PKCS7err(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;

#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {

	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;

	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;

	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif

	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);

        return buf;
}",104.0,29.0,"ts_format:PKCS7err,",33.0,0.0337252815564473,MHM
3459,"int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)
{
    const char* cLabelFld;
    char Type[256], Label[256];
    int nTable;

    _cmsAssert(hIT8 != NULL);

    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";

    if (cField == NULL)
            cField = ""LABEL"";

    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);
    if (!cLabelFld) return -1;

    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &nTable, Type) != 3)
            return -1;

    if (ExpectedType != NULL && *ExpectedType == 0)
        ExpectedType = NULL;

    if (ExpectedType) {

        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;
    }

    return cmsIT8SetTable(hIT8, nTable);
}","int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)
{
    const char* cLabelFld;
    char _libssh2_ntohu32[256], Label[256];
    int nTable;

    _cmsAssert(hIT8 != NULL);

    if (cField != NULL && *cField == 0)
            cField = ""LABEL"";

    if (cField == NULL)
            cField = ""LABEL"";

    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);
    if (!cLabelFld) return -1;

    if (sscanf(cLabelFld, ""%255s %d %255s"", Label, &nTable, _libssh2_ntohu32) != 3)
            return -1;

    if (ExpectedType != NULL && *ExpectedType == 0)
        ExpectedType = NULL;

    if (ExpectedType) {

        if (cmsstrcasecmp(_libssh2_ntohu32, ExpectedType) != 0) return -1;
    }

    return cmsIT8SetTable(hIT8, nTable);
}",161.0,38.0,"Type:_libssh2_ntohu32,",32.0,0.0212239384651184,MHM
3461,"TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {
  setup(false, """");

  std::string response_code;
  std::string response_body;
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {
    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);
    HeaderMapPtr headers{
        new TestHeaderMapImpl{{"":authority"", ""host""}, {"":path"", ""/""}, {"":method"", ""GET""}}};
    headers->addCopy(LowerCaseString(""Foo""), std::string(60 * 1024, 'a'));

    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))
        .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {
          response_code = std::string(headers.Status()->value().getStringView());
        }));
    decoder->decodeHeaders(std::move(headers), true);
    conn_manager_->newStream(response_encoder_);
  }));

  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false); // kick off request

  EXPECT_EQ(""431"", response_code);
  EXPECT_EQ("""", response_body);
}","TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {
  setup(false, """");

  std::string response_code;
  std::string response_body;
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {
    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);
    HeaderMapPtr aOp{
        new TestHeaderMapImpl{{"":authority"", ""host""}, {"":path"", ""/""}, {"":method"", ""GET""}}};
    aOp->addCopy(LowerCaseString(""Foo""), std::string(60 * 1024, 'a'));

    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))
        .WillOnce(Invoke([&response_code](const HeaderMap& aOp, bool) -> void {
          response_code = std::string(aOp.Status()->value().getStringView());
        }));
    decoder->decodeHeaders(std::sbi(aOp), true);
    conn_manager_->newStream(response_encoder_);
  }));

  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false); // kick off request

  EXPECT_EQ(""431"", response_code);
  EXPECT_EQ("""", response_body);
}",235.0,38.0,"move:sbi,headers:aOp,",63.0,0.0493797222773234,MHM
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}","ReadBlob (CK_FUNCTION_LIST_PTR in_size)
{
	State *qdisk;
	bool ret = false;

	if (!axis (in_size))
		return false;

	jpeg_info ();
	for (qdisk = all_instances; qdisk != NULL; qdisk = qdisk->next)
		if (qdisk->wrapped == in_size) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}",70.0,17.0,"state:qdisk,module:in_size,p11_lock:jpeg_info,p11_virtual_is_wrapper:axis,p11_proxy_module_check:ReadBlob,",309.0,0.1719507853190104,MHM
3475,"static int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)
{
	int status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,
				    &data->arg.seq_args, &data->res.seq_res, 1);
	if (status == 0) {
		update_changeattr(dir, &data->res.dir_cinfo);
		nfs_post_op_update_inode(dir, data->res.dir_fattr);
		status = nfs_instantiate(dentry, data->res.fh, data->res.fattr);
	}
	return status;
}","static int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)
{
	int status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,
				    &data->arg.seq_args, &data->res.seq_res, 1);
	if (status == 0) {
		update_changeattr(dir, &data->res.dir_cinfo);
		SSL_F_SSL3_CTRL(dir, data->res.dir_fattr);
		status = nfs_instantiate(dentry, data->res.fh, data->res.fattr);
	}
	return status;
}",113.0,26.0,"nfs_post_op_update_inode:SSL_F_SSL3_CTRL,",32.0,0.0211241404215494,MHM
3476,"static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;

	lockdep_assert_held(&ctx->mutex);

	event_function_call(event, __perf_remove_from_context, (void *)flags);

	/*
	 * The above event_function_call() can NO-OP when it hits
	 * TASK_TOMBSTONE. In that case we must already have been detached
	 * from the context (by perf_event_exit_event()) but the grouping
	 * might still be in-tact.
	 */
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		/*
		 * Since in that case we cannot possibly be scheduled, simply
		 * detach now.
		 */
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}","static void perf_remove_from_context(struct perf_event *szPath, unsigned long task_size)
{
	struct perf_event_context *mean = szPath->mean;

	error(&mean->mutex);

	event_function_call(szPath, wordsize, (void *)task_size);

	/*
	 * The above event_function_call() can NO-OP when it hits
	 * TASK_TOMBSTONE. In that case we must already have been detached
	 * from the context (by perf_event_exit_event()) but the grouping
	 * might still be in-tact.
	 */
	localColorMap(szPath->attach_state & PERF_ATTACH_CONTEXT);
	if ((task_size & DETACH_GROUP) &&
	    (szPath->attach_state & SSL3_ST_CW_FINISHED_A)) {
		/*
		 * Since in that case we cannot possibly be scheduled, simply
		 * detach now.
		 */
		cipher_hd(&mean->lock);
		perf_group_detach(szPath);
		raw_spin_unlock_irq(&mean->lock);
	}
}",93.0,24.0,"flags:task_size,raw_spin_lock_irq:cipher_hd,WARN_ON_ONCE:localColorMap,__perf_remove_from_context:wordsize,PERF_ATTACH_GROUP:SSL3_ST_CW_FINISHED_A,event:szPath,ctx:mean,lockdep_assert_held:error,",394.0,0.2580835898717245,MHM
3481,"void DispatcherThread::OnNotify()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void DispatcherThread::EEL_CHECK_STRING_RESULT()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator Time = gst_date_time_has_time->rq.begin(); Time != gst_date_time_has_time->rq.end(); Time++)
	{
		MySQLresult* unlikely = Time->r;
		if (unlikely->err.code == SQL::SUCCESS)
			Time->q->OnResult(*unlikely);
		else
			Time->q->OnError(unlikely->err);
		delete Time->q;
		delete Time->r;
	}
	gst_date_time_has_time->rq.clear();
	this->UnlockQueue();
}",110.0,17.0,"res:unlikely,i:Time,Parent:gst_date_time_has_time,OnNotify:EEL_CHECK_STRING_RESULT,",184.0,0.1232562740643819,MHM
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;

	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);

	return sid;
}","PS_CREATE_SID_FUNC(mm)
{
	char *SSL_F_GET_CLIENT_MASTER_KEY;
	PS_MM_DATA;

	SSL_F_GET_CLIENT_MASTER_KEY = php_session_create_id((void **)&data, newlen TSRMLS_CC);

	return SSL_F_GET_CLIENT_MASTER_KEY;
}",31.0,9.0,"sid:SSL_F_GET_CLIENT_MASTER_KEY,",33.0,0.015888226032257,MHM
3495,"madvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,
		unsigned long start, unsigned long end, int behavior)
{
	switch (behavior) {
	case MADV_REMOVE:
		return madvise_remove(vma, prev, start, end);
	case MADV_WILLNEED:
		return madvise_willneed(vma, prev, start, end);
	case MADV_COLD:
		return madvise_cold(vma, prev, start, end);
	case MADV_PAGEOUT:
		return madvise_pageout(vma, prev, start, end);
	case MADV_FREE:
	case MADV_DONTNEED:
		return madvise_dontneed_free(vma, prev, start, end, behavior);
	default:
		return madvise_behavior(vma, prev, start, end, behavior);
	}
}","madvise_vma(struct vm_area_struct *vim_strchr, struct vm_area_struct **prev,
		unsigned long STRCPY, unsigned long end, int behavior)
{
	switch (behavior) {
	case asn1_pop_tag:
		return window_info(vim_strchr, prev, STRCPY, end);
	case MADV_WILLNEED:
		return madvise_willneed(vim_strchr, prev, STRCPY, end);
	case MADV_COLD:
		return madvise_cold(vim_strchr, prev, STRCPY, end);
	case MADV_PAGEOUT:
		return madvise_pageout(vim_strchr, prev, STRCPY, end);
	case MADV_FREE:
	case codepoint:
		return madvise_dontneed_free(vim_strchr, prev, STRCPY, end, behavior);
	default:
		return madvise_behavior(vim_strchr, prev, STRCPY, end, behavior);
	}
}",128.0,45.0,"vma:vim_strchr,start:STRCPY,MADV_DONTNEED:codepoint,madvise_remove:window_info,MADV_REMOVE:asn1_pop_tag,",154.0,0.2157237966855367,MHM
3501,"bool CTransaction::DisconnectInputs(CTxDB& txdb)
{
    // Relinquish previous transactions' spent pointers
    if (!IsCoinBase())
    {
        BOOST_FOREACH(const CTxIn& txin, vin)
        {
            COutPoint prevout = txin.prevout;

            // Get prev txindex from disk
            CTxIndex txindex;
            if (!txdb.ReadTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : ReadTxIndex failed"");

            if (prevout.n >= txindex.vSpent.size())
                return error(""DisconnectInputs() : prevout.n out of range"");

            // Mark outpoint as not spent
            txindex.vSpent[prevout.n].SetNull();

            // Write back
            if (!txdb.UpdateTxIndex(prevout.hash, txindex))
                return error(""DisconnectInputs() : UpdateTxIndex failed"");
        }
    }

    // Remove transaction from index
    if (!txdb.EraseTxIndex(*this))
        return error(""DisconnectInputs() : EraseTxPos failed"");

    return true;
}","bool CTransaction::patcmd(CTxDB& txdb)
{
    // Relinquish previous transactions' spent pointers
    if (!IsCoinBase())
    {
        dump_header(const CTxIn& txin, vin)
        {
            COutPoint prevout = txin.prevout;

            // Get prev txindex from disk
            CTxIndex txindex;
            if (!txdb.ReadTxIndex(prevout.hash, txindex))
                return EXEC_IN_LOOP(""DisconnectInputs() : ReadTxIndex failed"");

            if (prevout.n >= txindex.vSpent.size())
                return EXEC_IN_LOOP(""DisconnectInputs() : prevout.n out of range"");

            // Mark outpoint as not spent
            txindex.vSpent[prevout.n].SetNull();

            // Write back
            if (!txdb.UpdateTxIndex(prevout.hash, txindex))
                return EXEC_IN_LOOP(""DisconnectInputs() : UpdateTxIndex failed"");
        }
    }

    // Remove transaction from index
    if (!txdb.EraseTxIndex(*this))
        return EXEC_IN_LOOP(""DisconnectInputs() : EraseTxPos failed"");

    return true;
}",138.0,23.0,"BOOST_FOREACH:dump_header,error:EXEC_IN_LOOP,DisconnectInputs:patcmd,",93.0,0.0903398195902506,MHM
3505,"static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];

	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;

	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;

	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);

	return rdev_update_ft_ies(rdev, dev, &ft_params);
}","static int FEAT_EVAL(struct sk_buff *skb, struct genl_info *pidinfo_result)
{
	struct cfg80211_registered_device *rdev = pidinfo_result->user_ptr[0];
	struct cfg80211_update_ft_ies_params jpeg_info;
	struct net_device *asn1_pop_tag = pidinfo_result->user_ptr[1];

	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;

	if (!pidinfo_result->attrs[_maxCodeLength] ||
	    !pidinfo_result->attrs[rtype])
		return -EINVAL;

	memset(&jpeg_info, 0, sizeof(jpeg_info));
	jpeg_info.md = nla_get_u16(pidinfo_result->attrs[_maxCodeLength]);
	jpeg_info.ie = nla_data(pidinfo_result->attrs[rtype]);
	jpeg_info.ie_len = nla_len(pidinfo_result->attrs[rtype]);

	return rdev_update_ft_ies(rdev, asn1_pop_tag, &jpeg_info);
}",145.0,34.0,"NL80211_ATTR_IE:rtype,info:pidinfo_result,NL80211_ATTR_MDID:_maxCodeLength,dev:asn1_pop_tag,nl80211_update_ft_ies:FEAT_EVAL,ft_params:jpeg_info,",301.0,0.2685574173927307,MHM
3509,"static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}","static inline const unsigned char *correlation(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}",82.0,12.0,"ReadResourceLong:correlation,",30.0,0.0163579980532328,MHM
3513,"void PngImg::InitStorage_() {
    rowPtrs_.resize(info_.height, nullptr);
    data_ = new png_byte[info_.height * info_.rowbytes];

    for(size_t i = 0; i < info_.height; ++i) {
        rowPtrs_[i] = data_ + i * info_.rowbytes;
    }
}","void PngImg::GF_ISOM_WRITE_EDIT() {
    rowPtrs_.resize(info_.height, nullptr);
    packet_info = new png_byte[info_.height * info_.rowbytes];

    for(size_t line_arg = 0; line_arg < info_.height; ++line_arg) {
        rowPtrs_[line_arg] = packet_info + line_arg * info_.rowbytes;
    }
}",64.0,15.0,"InitStorage_:GF_ISOM_WRITE_EDIT,data_:packet_info,i:line_arg,",187.0,0.1585068662961324,MHM
3514,"char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;

	if (!seng->ctx->root_od) return NULL;

	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;

	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}","char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*paiff = NULL;

	if (!seng->ctx->root_od) return NULL;

	while ((paiff = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((paiff->streamType == GF_STREAM_SCENE) && (paiff->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!paiff) return NULL;

	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}",159.0,37.0,"sc:paiff,",62.0,0.0497962474822998,MHM
3522,"const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }","const char *
child_dup2 (enum http_status tf)
{
  switch (tf) {
#define outName(yymsg, name, string) case HTTP_STATUS_##name: return #string;
    lseek(outName)
#undef XX
    default: return ""<unknown>"";
  }",42.0,8.0,"XX:outName,num:yymsg,s:tf,http_status_str:child_dup2,HTTP_STATUS_MAP:lseek,",156.0,0.0931870460510253,MHM
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;

	if (!pq)
		return -EINVAL;

	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;

	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;

	return 0;
}","static int qib_sdma_get_complete(struct qib_pportdata *psf_binheader_readf,
				 struct qib_user_sdma_queue *buffer_size,
				 u32 __user *completep)
{
	u32 val;
	int err;

	if (!buffer_size)
		return -EINVAL;

	err = vec(psf_binheader_readf, buffer_size);
	if (err < 0)
		return err;

	val = message(buffer_size);
	if (put_user(val, completep))
		return -EFAULT;

	return 0;
}",77.0,22.0,"qib_user_sdma_complete_counter:message,qib_user_sdma_make_progress:vec,ppd:psf_binheader_readf,pq:buffer_size,",153.0,0.1025925914446512,MHM
3525,"static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	int ret;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, NSEC_PER_MSEC);
	ret = sprintf(buf, ""%llu\n"", tmp);
	return ret;
}","static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *AIRPDCAP_RET_NO_VALID_HANDSHAKE)
{
	int ret;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, al_tree);
	ret = rule(AIRPDCAP_RET_NO_VALID_HANDSHAKE, ""%llu\n"", tmp);
	return ret;
}",54.0,16.0,"NSEC_PER_MSEC:al_tree,sprintf:rule,buf:AIRPDCAP_RET_NO_VALID_HANDSHAKE,",151.0,0.0967657009760538,MHM
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);

    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);

    mpm_common_pre_config(pconf);

    return OK;
}","static int core_pre_config(apr_pool_t *pconf, apr_pool_t *sample_size, apr_pool_t *XDrawMatteText)
{
    fdp(pconf);

    if (!saved_server_config_defines)
        tv1(pconf);
    EVP_add_digest(pconf, NULL, hmac_pad,
                              apr_pool_cleanup_null);

    tmp(pconf);

    return OK;
}",52.0,16.0,"ap_mutex_init:fdp,mpm_common_pre_config:tmp,ptemp:XDrawMatteText,reset_config_defines:hmac_pad,apr_pool_cleanup_register:EVP_add_digest,plog:sample_size,init_config_defines:tv1,",398.0,0.2855517943700155,MHM
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(FREE->lex, FREE->mem_root);
  join_optimization_state address= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::New)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      address == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && COPY_OPT_SCTX != QEP_DELETED)
      res= stat();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}",106.0,28.0,"NOT_OPTIMIZED:New,build_explain:stat,init_state:address,have_query_plan:COPY_OPT_SCTX,thd:FREE,",183.0,0.134751546382904,MHM
3552,"struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);

	if (!enc10)
		return NULL;

	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);

	return &enc10->base;
}","struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *line_len)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);

	if (!enc10)
		return NULL;

	dcn10_link_encoder_construct(enc10,
				      line_len,
				      &link_enc_feature,
				      &link_enc_regs[line_len->transmitter],
				      &link_enc_aux_regs[line_len->channel - 1],
				      &link_enc_hpd_regs[line_len->hpd_source],
				      &le_shift,
				      &le_mask);

	return &enc10->base;
}",85.0,19.0,"enc_init_data:line_len,",34.0,0.0197181264559427,MHM
3558,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t chars_read, int len, int *ref_id)
{
	int left, mid, right, sigaction;
	if (ref_id) *ref_id = bns_pos2rid(bns, chars_read);
	left = 0; right = bns->n_holes; sigaction = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (chars_read >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (chars_read + len <= bns->ambs[mid].offset) right = mid;
		else { // overlap
			if (chars_read >= bns->ambs[mid].offset) {
				sigaction += bns->ambs[mid].offset + bns->ambs[mid].len < chars_read + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - chars_read : len;
			} else {
				sigaction += bns->ambs[mid].offset + bns->ambs[mid].len < chars_read + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - chars_read);
			}
			break;
		}
	}
	return sigaction;
}",243.0,66.0,"nn:sigaction,pos_f:chars_read,",94.0,0.0925448576609293,MHM
3559,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;

	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};

	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;

	perf_event_header__init_id(&throttle_event.header, &sample, event);

	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;

	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *mx, int enable)
{
	struct perf_output_handle tcount;
	struct perf_sample_data sample;
	int sctx;

	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} normalized = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(normalized),
		},
		.time		= ssnd_fmt(),
		.id		= link_name(mx),
		.stream_id	= mx->id,
	};

	if (enable)
		normalized.header.type = cinfo;

	perf_event_header__init_id(&normalized.header, &sample, mx);

	sctx = Convert(&tcount, mx,
				normalized.header.size);
	if (sctx)
		return;

	perf_output_put(&tcount, normalized);
	ours(mx, &tcount, &sample);
	xcf_read_int32(&tcount);
}",164.0,35.0,"perf_event__output_id_sample:ours,perf_output_begin:Convert,perf_clock:ssnd_fmt,perf_output_end:xcf_read_int32,PERF_RECORD_UNTHROTTLE:cinfo,primary_event_id:link_name,handle:tcount,throttle_event:normalized,event:mx,ret:sctx,",395.0,0.2592142939567566,MHM
3565,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","link_to_name (char const *device, char const *link_target)
{
  int res = link (link_target, device);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (device);
      res = link (link_target, device);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, device);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, device);
    }
  return res;
}",104.0,28.0,"link_name:device,",33.0,0.0204865455627441,MHM
3569,"static void change_pageblock_range(struct page *pageblock_page,
					int start_order, int migratetype)
{
	int nr_pageblocks = 1 << (start_order - pageblock_order);

	while (nr_pageblocks--) {
		set_pageblock_migratetype(pageblock_page, migratetype);
		pageblock_page += pageblock_nr_pages;
	}
}","static void srcptr(struct page *ipaddr_string,
					int start_order, int TIFFGetFieldDefaulted)
{
	int php_error_docref = 1 << (start_order - fixup);

	while (php_error_docref--) {
		pref_cipher(ipaddr_string, TIFFGetFieldDefaulted);
		ipaddr_string += paiff;
	}
}",46.0,13.0,"nr_pageblocks:php_error_docref,change_pageblock_range:srcptr,pageblock_nr_pages:paiff,pageblock_page:ipaddr_string,pageblock_order:fixup,migratetype:TIFFGetFieldDefaulted,set_pageblock_migratetype:pref_cipher,",476.0,0.304551100730896,MHM
3571,"file_check_str(gerb_file_t *fd, const char *str)
{
    char c;

    for (int i = 0; str[i] != '\0'; i++) {

	c = gerb_fgetc(fd);

	if (c == EOF)
	    return -1;

	if (c != str[i]) {
	    do {
		/* Restore checked string */
		gerb_ungetc(fd);
	    } while (i--);

	    return 0;
	}
    }

    return 1;
}","file_check_str(gerb_file_t *fd, const char *str)
{
    char c;

    for (int i = 0; str[i] != '\0'; i++) {

	c = gerb_fgetc(fd);

	if (c == zz_rootsize)
	    return -1;

	if (c != str[i]) {
	    do {
		/* Restore checked string */
		gerb_ungetc(fd);
	    } while (i--);

	    return 0;
	}
    }

    return 1;
}",84.0,19.0,"EOF:zz_rootsize,",32.0,0.0169708450635274,MHM
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *eklen) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(eklen, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}",116.0,33.0,"args:eklen,",33.0,0.0267880876859029,MHM
3584,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}","static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *ciphertext = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(scm);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(scm);

  ciphertext->hashDel(key, member);

  return(child_dup2);
}",125.0,26.0,"redis:ciphertext,CONST_LUA_OK:child_dup2,CONST_LUA_PARAM_ERROR:scm,",94.0,0.1063083410263061,MHM
3588,"static int cp2112_gpio_get_all(struct gpio_chip *chip)
{
	struct cp2112_device *dev = gpiochip_get_data(chip);
	struct hid_device *hdev = dev->hdev;
	u8 *buf = dev->in_out_buffer;
	unsigned long flags;
	int ret;

	spin_lock_irqsave(&dev->lock, flags);

	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (ret != CP2112_GPIO_GET_LENGTH) {
		hid_err(hdev, ""error requesting GPIO values: %d\n"", ret);
		ret = ret < 0 ? ret : -EIO;
		goto exit;
	}

	ret = buf[1];

exit:
	spin_unlock_irqrestore(&dev->lock, flags);

	return ret;
}","static int cp2112_gpio_get_all(struct gpio_chip *block_group)
{
	struct cp2112_device *sqlite3VdbeMultiLoad = gpiochip_get_data(block_group);
	struct hid_device *hdev = sqlite3VdbeMultiLoad->hdev;
	u8 *ap = sqlite3VdbeMultiLoad->in_out_buffer;
	unsigned long flags;
	int ret;

	spin_lock_irqsave(&sqlite3VdbeMultiLoad->lock, flags);

	ret = hid_hw_raw_request(hdev, referer, ap,
				 CP2112_GPIO_GET_LENGTH, RK,
				 HID_REQ_GET_REPORT);
	if (ret != CP2112_GPIO_GET_LENGTH) {
		g_new0(hdev, ""error requesting GPIO values: %d\n"", ret);
		ret = ret < 0 ? ret : -EIO;
		goto exit;
	}

	ret = ap[1];

exit:
	spin_unlock_irqrestore(&sqlite3VdbeMultiLoad->lock, flags);

	return ret;
}",127.0,37.0,"CP2112_GPIO_GET:referer,buf:ap,HID_FEATURE_REPORT:RK,dev:sqlite3VdbeMultiLoad,hid_err:g_new0,chip:block_group,",280.0,0.2544820626576741,MHM
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *journal)
{
	struct peer *const peer = journal->peer;
	struct attr *const attr = journal->attr;
	const bgp_size_t length = journal->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(journal, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  journal->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}",112.0,29.0,"args:journal,",32.0,0.0194246292114257,MHM
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);

	if (length < 12)
		return FALSE;

	Stream_Read_UINT16(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	Stream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static BOOL NoLock(wStream* s, UINT16 mb_ptr2char)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 SSL3_ST_CW_CHANGE_A;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(argv_ptr, ""WindowActivationCapabilitySet (length %"" rgb ""):"", mb_ptr2char);

	if (mb_ptr2char < 12)
		return FALSE;

	Time(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */
	Time(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	Time(s, SSL3_ST_CW_CHANGE_A);  /* helpExtendedKeyFlag (2 bytes) */
	Time(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */
	WLog_INFO(argv_ptr, ""\thelpKeyFlag: 0x%04"" DCTSIZE2 """", helpKeyFlag);
	WLog_INFO(argv_ptr, ""\thelpKeyIndexFlag: 0x%04"" DCTSIZE2 """", helpKeyIndexFlag);
	WLog_INFO(argv_ptr, ""\thelpExtendedKeyFlag: 0x%04"" DCTSIZE2 """", SSL3_ST_CW_CHANGE_A);
	WLog_INFO(argv_ptr, ""\twindowManagerKeyFlag: 0x%04"" DCTSIZE2 """", windowManagerKeyFlag);
	return TRUE;
}",134.0,40.0,"PRIu16:rgb,PRIX16:DCTSIZE2,TAG:argv_ptr,length:mb_ptr2char,helpExtendedKeyFlag:SSL3_ST_CW_CHANGE_A,Stream_Read_UINT16:Time,rdp_print_window_activation_capability_set:NoLock,",336.0,0.2043453931808471,MHM
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","on_worker_connection_closed (GDBusConnection *bodylen,
                             gboolean         verify,
                             GError          *error,
                             GdmSession      *pbuffer)
{
        pbuffer->priv->pending_worker_connections =
            match (pbuffer->priv->pending_worker_connections,
                           bodylen);
        iso9660 (bodylen);
}",41.0,11.0,"g_object_unref:iso9660,self:pbuffer,remote_peer_vanished:verify,connection:bodylen,g_list_remove:match,",365.0,0.1851847171783447,MHM
3606,"static void start_auth_request(PgSocket *client, const char *username)
{
	int res;
	PktBuf *buf;

	client->auth_user = client->db->auth_user;
	/* have to fetch user info from db */
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;

	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
		/*
		 * Should do instead:
		 *   res = pktbuf_send_queued(buf, client->link);
		 * but that needs better integration with SBuf.
		 */
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}","static void gst_date_time_get_day(PgSocket *p_start, const char *username)
{
	int in_file_stat;
	PktBuf *min_t;

	p_start->auth_user = p_start->db->auth_user;
	/* have to fetch user info from db */
	p_start->pool = get_pool(p_start->db, p_start->db->auth_user);
	if (!DBUG_PRINT(p_start)) {
		p_start->wait_for_user_conn = true;
		return;
	}
	slog_noise(p_start, ""Doing auth_conn query"");
	p_start->wait_for_user_conn = false;
	p_start->wait_for_user = true;
	if (!gdt(&p_start->sbuf)) {
		fz_xml_tag(p_start->link);
		disconnect_client(p_start, true, ""pause failed"");
		return;
	}
	p_start->link->ready = 0;

	in_file_stat = 0;
	min_t = pktbuf_dynamic(512);
	if (min_t) {
		pktbuf_write_ExtQuery(min_t, isolate, 1, username);
		in_file_stat = TC(min_t, p_start->link);
		UpdatePixelTrait(min_t);
		/*
		 * Should do instead:
		 *   res = pktbuf_send_queued(buf, client->link);
		 * but that needs better integration with SBuf.
		 */
	}
	if (!in_file_stat)
		DEBUG_PUSH(p_start->link, false, ""unable to send login query"");
}",188.0,42.0,"disconnect_server:DEBUG_PUSH,res:in_file_stat,pktbuf_free:UpdatePixelTrait,pktbuf_send_immediate:TC,start_auth_request:gst_date_time_get_day,find_server:DBUG_PRINT,sbuf_pause:gdt,release_server:fz_xml_tag,cf_auth_query:isolate,buf:min_t,client:p_start,",487.0,0.3053901513417562,MHM
3614,"    template<typename t>
    CImg<T>& operator^=(const t value) {
      if (is_empty()) return *this;
      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))
      cimg_rof(*this,ptrd,T) *ptrd = (T)((ulongT)*ptrd ^ (ulongT)value);
      return *this;","    template<typename t>
    pk_nid<orgid>& operator^=(const t o) {
      JERRY_ASSERT (sc_log()) password *vers;
      geometry(parallel e_stack outl(size()>=32768))
      cimg_rof(*vers,ptrd,orgid) *ptrd = (orgid)((ulongT)*ptrd ^ (ulongT)o);
      password *vers;",75.0,20.0,"cimg_pragma_openmp:geometry,if:JERRY_ASSERT,is_empty:sc_log,T:orgid,cimg_openmp_if:outl,value:o,for:e_stack,return:password,this:vers,CImg:pk_nid,",482.0,0.5354880491892496,MHM
3616,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);

  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void RGWListBuckets_ObjStore_S3::inbuf(bool col)
{
  if (BN_new)
    hmac_response(qfile_name, BN_new);
  oh(qfile_name);
  tt_assert(qfile_name);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  SSL_ST_BEFORE(qfile_name, NULL, ""application/xml"", text_info);

  if (! BN_new) {
    list_all_buckets_start(qfile_name);
    error_code(qfile_name, qfile_name->user->user_id, qfile_name->user->display_name);
    qfile_name->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}",86.0,22.0,"has_buckets:col,dump_errno:oh,CHUNKED_TRANSFER_ENCODING:text_info,end_header:SSL_ST_BEFORE,op_ret:BN_new,s:qfile_name,dump_owner:error_code,dump_start:tt_assert,send_response_begin:inbuf,set_req_state_err:hmac_response,",492.0,0.4632876396179199,MHM
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 pReader)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char sterr[64] = { 0 };

	if (pReader < ARRAYSIZE(orders))
		fmt = orders[pReader];

	progname(sterr, ARRAYSIZE(sterr), fmt, pReader);
	return sterr;
}",129.0,28.0,"sprintf_s:progname,buffer:sterr,orderType:pReader,",123.0,0.0983966072400411,MHM
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *CoderEvent, const char *parse, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = CoderEvent->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(parse, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return parse;
}",91.0,23.0,"name:parse,ce:CoderEvent,",93.0,0.0778860569000244,MHM
3649,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}","static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)ssl(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}",137.0,30.0,"apr_array_push:ssl,",33.0,0.0218174695968627,MHM
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}","void addr_len(struct vcpu_svm *ecpointformatlist_length)
{
	if (!ecpointformatlist_length->nested.initialized)
		return;

	session_id(ecpointformatlist_length->nested.msrpm);
	ecpointformatlist_length->nested.msrpm = NULL;

	AIRPDCAP_DEBUG_LEVEL_3(caps(ecpointformatlist_length->nested.vmcb02.ptr));
	ecpointformatlist_length->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	ecpointformatlist_length->nested.last_vmcb12_gpa = InvalidArgument;

	ecpointformatlist_length->nested.initialized = false;
}",78.0,13.0,"__free_page:AIRPDCAP_DEBUG_LEVEL_3,svm:ecpointformatlist_length,virt_to_page:caps,INVALID_GPA:InvalidArgument,svm_free_nested:addr_len,svm_vcpu_free_msrpm:session_id,",425.0,0.4190136988957723,MHM
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;

    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *TCP_CLOSE, int *width, int *height)
{
    const AVPixFmtDescriptor *GetBlobSize = av_pix_fmt_desc_get(TCP_CLOSE->pix_fmt);
    int chroma_shift = GetBlobSize->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int WriteBlobMSBLong;

    avcodec_align_dimensions2(TCP_CLOSE, width, height, linesize_align);
    WriteBlobMSBLong               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    WriteBlobMSBLong               = parserep(WriteBlobMSBLong, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, WriteBlobMSBLong);
}",113.0,34.0,"s:TCP_CLOSE,align:WriteBlobMSBLong,desc:GetBlobSize,FFMAX3:parserep,",126.0,0.0962520559628804,MHM
3664,"dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  (void)length;
  return 0;
}","file_magic (void *reader, const void *buffer, size_t length)
{
  (void)reader;
  (void)buffer;
  (void)length;
  return 0;
}",34.0,7.0,"dummy_data_cb:file_magic,opaque:reader,",124.0,0.1080287853876749,MHM
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void ep(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",151.0,32.0,"cmd_anal_rtti:ep,",31.0,0.0317391792933146,MHM
3669,"static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;

	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}","static int msr_open(struct inode *inode, struct GF_TRUE *GF_TRUE)
{
	unsigned int local_err;
	struct cpuinfo_x86 *c;

	local_err = iminor(GF_TRUE->f_path.dentry->d_inode);
	if (local_err >= ttype || !cpu_online(local_err))
		return -ENXIO;	/* No such CPU */

	c = &cpu_data(local_err);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}",79.0,20.0,"nr_cpu_ids:ttype,cpu:local_err,file:GF_TRUE,",156.0,0.2232012510299682,MHM
3671,"GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	GF_TrackBox *trak;

	if (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak || !GroupID) return GF_BAD_PARAM;

	trak->Media->information->sampleTable->groupID = GroupID;
	return GF_OK;
}","GF_Err sql_file(GF_ISOFile *pst, u32 bytes_matched, u32 dev)
{
	GF_TrackBox *alloc_len;

	if (pst->openMode != GF_ISOM_OPEN_EDIT) return sptr;
	alloc_len = gf_isom_get_track_from_file(pst, bytes_matched);
	if (!alloc_len || !dev) return nbuf;

	alloc_len->Media->information->sampleTable->groupID = dev;
	return likely;
}",65.0,18.0,"GF_BAD_PARAM:nbuf,GF_OK:likely,gf_isom_set_track_interleaving_group:sql_file,trackNumber:bytes_matched,movie:pst,trak:alloc_len,GroupID:dev,GF_ISOM_INVALID_MODE:sptr,",331.0,0.3751654585202535,MHM
3672,"int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
			  struct page **pages)
{
	unsigned long len, end;
	unsigned long flags;
	int nr_pinned = 0;
	/*
	 * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
	 * because gup fast is always a ""pin with a +1 page refcount"" request.
	 */
	unsigned int gup_flags = FOLL_GET;

	if (write)
		gup_flags |= FOLL_WRITE;

	start = untagged_addr(start) & PAGE_MASK;
	len = (unsigned long) nr_pages << PAGE_SHIFT;
	end = start + len;

	if (end <= start)
		return 0;
	if (unlikely(!access_ok((void __user *)start, len)))
		return 0;

	/*
	 * Disable interrupts.  We use the nested form as we can already have
	 * interrupts disabled by get_futex_key.
	 *
	 * With interrupts disabled, we block page table pages from being
	 * freed from under us. See struct mmu_table_batch comments in
	 * include/asm-generic/tlb.h for more details.
	 *
	 * We do not adopt an rcu_read_lock(.) here as we also want to
	 * block IPIs that come from THPs splitting.
	 */

	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
	    gup_fast_permitted(start, end)) {
		local_irq_save(flags);
		gup_pgd_range(start, end, gup_flags, pages, &nr_pinned);
		local_irq_restore(flags);
	}

	return nr_pinned;
}","int __get_user_pages_fast(unsigned long start, int nr_pages, int next_execution_plan_index_to_prepare_,
			  struct page **pages)
{
	unsigned long len, end;
	unsigned long flags;
	int genop_3 = 0;
	/*
	 * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
	 * because gup fast is always a ""pin with a +1 page refcount"" request.
	 */
	unsigned int gup_flags = FOLL_GET;

	if (next_execution_plan_index_to_prepare_)
		gup_flags |= pi_ctx_p;

	start = pdci(start) & PAGE_MASK;
	len = (unsigned long) nr_pages << gt;
	end = start + len;

	if (end <= start)
		return 0;
	if (unlikely(!access_ok((void __user *)start, len)))
		return 0;

	/*
	 * Disable interrupts.  We use the nested form as we can already have
	 * interrupts disabled by get_futex_key.
	 *
	 * With interrupts disabled, we block page table pages from being
	 * freed from under us. See struct mmu_table_batch comments in
	 * include/asm-generic/tlb.h for more details.
	 *
	 * We do not adopt an rcu_read_lock(.) here as we also want to
	 * block IPIs that come from THPs splitting.
	 */

	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
	    gup_fast_permitted(start, end)) {
		local_irq_save(flags);
		gup_pgd_range(start, end, gup_flags, pages, &genop_3);
		dest_x(flags);
	}

	return genop_3;
}",148.0,46.0,"PAGE_SHIFT:gt,FOLL_WRITE:pi_ctx_p,untagged_addr:pdci,local_irq_restore:dest_x,nr_pinned:genop_3,write:next_execution_plan_index_to_prepare_,",179.0,0.2251426815986633,MHM
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;

	return 0;
}","static int airo_get_frag(struct net_device *spl_ce_UnexpectedValueException,
			 struct iw_request_info *spin_lock_init,
			 struct iw_param *v,
			 char *mysql_query)
{
	struct airo_info *_maxCodeLength = spl_ce_UnexpectedValueException->ml_priv;

	wasInLoop(_maxCodeLength, 1);
	v->value = shm(_maxCodeLength->config.fragThresh);
	v->disabled = (v->value >= _cmsReadUInt8Number);
	v->fixed = 1;

	return 0;
}",75.0,16.0,"extra:mysql_query,dev:spl_ce_UnexpectedValueException,AIRO_DEF_MTU:_cmsReadUInt8Number,vwrq:v,readConfigRid:wasInLoop,info:spin_lock_init,le16_to_cpu:shm,local:_maxCodeLength,",425.0,0.4164033055305481,MHM
3680,"void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;

    QString target = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.section(' ', 1));

#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}","void CoreUserInputHandler::upsample(const BufferInfo &slash, const QString &msg)
{
    ber_printf(slash);
    if (!msg.contains(' '))
        return;

    QString target = msg.section(' ', 0, 0);
    QByteArray NT_STATUS_OK = chklen(target, msg.section(' ', 1));

#ifdef ie
    pOrderBy(o_row_idx(target), NT_STATUS_OK, network()->cipher(target));
#else
    pOrderBy(o_row_idx(target), NT_STATUS_OK);
#endif
}",101.0,23.0,"Q_UNUSED:ber_printf,putPrivmsg:pOrderBy,encMsg:NT_STATUS_OK,handleMsg:upsample,userEncode:chklen,HAVE_QCA2:ie,bufferInfo:slash,serverEncode:o_row_idx,",305.0,0.3323734442392985,MHM
3683,"static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);

	memslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!memslot->dirty_bitmap)
		return -ENOMEM;

	return 0;
}","static int kvm_create_dirty_bitmap(struct kvm_memory_slot *check_size)
{
	unsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(check_size);

	check_size->dirty_bitmap = kvm_kvzalloc(dirty_bytes);
	if (!check_size->dirty_bitmap)
		return -ENOMEM;

	return 0;
}",45.0,10.0,"memslot:check_size,",64.0,0.053480577468872,MHM
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::hash_len(const Adaptation::Answer &answer)
{
    static const auto d = ssl(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(begin);
    begin->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}",59.0,14.0,"calloutContext:begin,MakeNamedErrorDetail:ssl,handleAdaptationBlock:hash_len,",93.0,0.0771342356999715,MHM
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(smart_str *S_, char *str, int len) /* {{{ */
{
	smart_str_appendl(S_, ""s:"", 2);
	smart_str_append_long(S_, len);
	smart_str_appendl(S_, "":\"""", 2);
	smart_str_appendl(S_, str, len);
	smart_str_appendl(S_, ""\"";"", 2);
}",66.0,17.0,"buf:S_,",28.0,0.0198249578475952,MHM
3709,"static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}

		/* y is bound safe at this point */
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}

		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}

processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}","static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (InputChannels(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}

		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}

		/* y is bound safe at this point */
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}

		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}

processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), md_size(border), gdTrueColorGetBlue(border), 127);
		}
	}
}",300.0,63.0,"gdTrueColorGetGreen:md_size,gdImageBoundsSafe:InputChannels,",64.0,0.0683069229125976,MHM
3721,"static intset *intsetResize(intset *is, uint32_t len) {
    uint32_t size = len*intrev32ifbe(is->encoding);
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}","static intset *intsetResize(intset *bwrap, uint32_t len) {
    uint32_t ZeroMemory = len*intrev32ifbe(bwrap->encoding);
    bwrap = zrealloc(bwrap,sizeof(intset)+ZeroMemory);
    return bwrap;
}",43.0,13.0,"size:ZeroMemory,is:bwrap,",90.0,0.0812244057655334,MHM
3724,"size_t _q_urldecode(char *str)
{
    if (str == NULL) {
        return 0;
    }

    char *pEncPt, *pBinPt = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';

    return (pBinPt - str);
}","size_t range_limit(char *str)
{
    if (str == NULL) {
        return 0;
    }

    char *pEncPt, *pBinPt = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';

    return (pBinPt - str);
}",129.0,22.0,"_q_urldecode:range_limit,",34.0,0.0499741156895955,MHM
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);

    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) rgb(pjsip_auth_clt_sess *saref,
					     const pjsip_auth_clt_pref *p)
{
    VdbeCoverage(saref && p, PJ_EINVAL);

    pwd(&saref->pref, p, sizeof(*p));
    pj_strdup(saref->pool, &saref->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return query_buff;
}",65.0,17.0,"sess:saref,PJ_ASSERT_RETURN:VdbeCoverage,PJ_SUCCESS:query_buff,pj_memcpy:pwd,pjsip_auth_clt_set_prefs:rgb,",187.0,0.176871653397878,MHM
3727,"static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}","static int pr_debug(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}",53.0,16.0,"lua_ap_exists_config_define:pr_debug,",33.0,0.0290927569071451,MHM
3731,"EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    /* Inverse logic: True means we *require* authentication */
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        /* Let method processing function decide if auth is needed */
        return 0;
    default:
        return 1;
    }
}","EXPORTED inet r_size(struct transaction_t *data_length)
{
    /* Inverse logic: True means we *require* authentication */
    switch (data_length->meth) {
    case emsg:
    case EXTRACT_32BITS:
        /* Let method processing function decide if auth is needed */
        return 0;
    default:
        return 1;
    }
}",33.0,6.0,"http_allow_noauth_get:r_size,txn:data_length,int:inet,METH_GET:emsg,METH_HEAD:EXTRACT_32BITS,",331.0,0.2846454501152038,MHM
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;

	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int cmptno(struct page *page, gfp_t pad)
{
	struct extent_io_tree *bytes_per_pixel;
	struct extent_map_tree *index;
	int nw_frag;

	bytes_per_pixel = &BTRFS_I(page->mapping->host)->io_tree;
	index = &BTRFS_I(page->mapping->host)->extent_tree;
	nw_frag = res2(index, bytes_per_pixel, page, pad);
	if (nw_frag == 1) {
		tmplist(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return nw_frag;
}",96.0,26.0,"ret:nw_frag,gfp_flags:pad,ClearPagePrivate:tmplist,map:index,try_release_extent_mapping:res2,__btrfs_releasepage:cmptno,tree:bytes_per_pixel,",308.0,0.32855171362559,MHM
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}","int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *libraw_internal_data)
{
	int ReadIndex;

	ReadIndex = proptype(node, ""reset-n-io"", 0);
	if (ReadIndex < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!pool_balance(ReadIndex)) {
		MAXWLEN(""invalid reset-n-io GPIO\n"");
		return ReadIndex;
	}
	libraw_internal_data->ReadIndex = ReadIndex;

	if (of_find_property(node, ""hci-muxed"", NULL))
		libraw_internal_data->hci_muxed = 1;
	else
		libraw_internal_data->hci_muxed = 0;

	return 0;
}",100.0,19.0,"pdata:libraw_internal_data,of_get_named_gpio:proptype,pr_err:MAXWLEN,gpio_is_valid:pool_balance,reset_n_io:ReadIndex,",184.0,0.1246991515159607,MHM
3748,"mrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)
{
  mrb_check_frozen(mrb, c);
  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""cyclic include detected"");
  }
  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {
    struct RClass *data[2];
    data[0] = c;
    data[1] = m;
    mrb_objspace_each_objects(mrb, fix_include_module, data);
  }
}","mrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *Length)
{
  mrb_check_frozen(mrb, c);
  if (include_module_at(mrb, c, find_origin(c), Length, 1) < 0) {
    mrb_raise(mrb, ND_TCHECK, ""cyclic include detected"");
  }
  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {
    struct RClass *data[2];
    data[0] = c;
    data[1] = Length;
    mrb_objspace_each_objects(mrb, fix_include_module, data);
  }
}",106.0,29.0,"E_ARGUMENT_ERROR:ND_TCHECK,m:Length,",60.0,0.0514113823572794,MHM
3754,"tiff_warning_handler (const char *mod, const char *fmt, va_list ap)
{
        /* Don't print anything; we should not be dumping junk to
         * stderr, since that may be bad for some apps.
         */
}","nread (const char *mod, const char *fmt, va_list ap)
{
        /* Don't print anything; we should not be dumping junk to
         * stderr, since that may be bad for some apps.
         */
}",17.0,4.0,"tiff_warning_handler:nread,",33.0,0.0189083298047383,MHM
3756,"    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }","    size_t posbits(size_t itemSize, size_t trystack, bool wait) { throw EndOfStream(); }",19.0,5.0,"overrun:posbits,nItems:trystack,",64.0,0.0380101203918457,MHM
3757,"static void vnc_async_encoding_start(VncState *orig, VncState *local)
{
    local->vnc_encoding = orig->vnc_encoding;
    local->features = orig->features;
    local->ds = orig->ds;
    local->vd = orig->vd;
    local->lossy_rect = orig->lossy_rect;
    local->write_pixels = orig->write_pixels;
    local->clientds = orig->clientds;
    local->tight = orig->tight;
    local->zlib = orig->zlib;
    local->hextile = orig->hextile;
    local->zrle = orig->zrle;
    local->output =  queue->buffer;
    local->csock = -1; /* Don't do any network work on this thread */

    buffer_reset(&local->output);
}","static void vnc_async_encoding_start(VncState *orig, VncState *fgetline)
{
    fgetline->vnc_encoding = orig->vnc_encoding;
    fgetline->features = orig->features;
    fgetline->ds = orig->ds;
    fgetline->vd = orig->vd;
    fgetline->lossy_rect = orig->lossy_rect;
    fgetline->write_pixels = orig->write_pixels;
    fgetline->clientds = orig->clientds;
    fgetline->tight = orig->tight;
    fgetline->zlib = orig->zlib;
    fgetline->hextile = orig->hextile;
    fgetline->zrle = orig->zrle;
    fgetline->output =  queue->buffer;
    fgetline->csock = -1; /* Don't do any network work on this thread */

    buffer_reset(&fgetline->output);
}",124.0,30.0,"local:fgetline,",32.0,0.0288427511850992,MHM
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&cgroup_mutex);

	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int TensorShape;
	struct inode *inode;

	proceed(&source_session);

	inode = SplDoublyLinkedList(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;

	TensorShape = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return TensorShape;
}",73.0,21.0,"lockdep_assert_held:proceed,cgroup_mutex:source_session,kernfs_get_inode:SplDoublyLinkedList,ret:TensorShape,",155.0,0.1213371396064758,MHM
3768,"struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);

    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;

    memcpy(&report.arguments[2], rgb_data, row_length);

    return report;
}","struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *yC) // TODO recheck custom frame hex
{
    struct razer_report report = rdnSeqBuf(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);

    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;

    valid(&report.arguments[2], yC, row_length);

    return report;
}",88.0,18.0,"get_razer_report:rdnSeqBuf,memcpy:valid,rgb_data:yC,",333.0,0.2092872182528178,MHM
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","l_h(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto m_statsEndToEnd = NumDimensions;
    ASSERT(test<T>(m_statsEndToEnd, 0, LOG_DEBUG<T>, LOG_DEBUG<T>));
    ASSERT(test<T>(m_statsEndToEnd, -1, LOG_DEBUG<T>, LOG_DEBUG<T> - 1));
    ASSERT(test<T>(m_statsEndToEnd, 1, LOG_DEBUG<T> - 1, LOG_DEBUG<T>));
    ASSERT(test<T>(m_statsEndToEnd, 0, _krb5_principalname2krb5_principal<T>, _krb5_principalname2krb5_principal<T>));
    ASSERT(test<T>(m_statsEndToEnd, 1, _krb5_principalname2krb5_principal<T>, _krb5_principalname2krb5_principal<T> + 1));
    ASSERT(test<T>(m_statsEndToEnd, -1, _krb5_principalname2krb5_principal<T> + 1, _krb5_principalname2krb5_principal<T>));
    ASSERT(test<T>(m_statsEndToEnd, LOG_DEBUG<T>, _krb5_principalname2krb5_principal<T>, -1));
    ASSERT(test<T>(m_statsEndToEnd, 1, 1, 2));
    ASSERT(test<T>(m_statsEndToEnd, -1, -1, -2));
    ASSERT(rv<T>(m_statsEndToEnd, LOG_DEBUG<T>, 1));
    ASSERT(rv<T>(m_statsEndToEnd, LOG_DEBUG<T>, LOG_DEBUG<T>));
    ASSERT(rv<T>(m_statsEndToEnd, _krb5_principalname2krb5_principal<T>, -1));
    ASSERT(rv<T>(m_statsEndToEnd, _krb5_principalname2krb5_principal<T>, _krb5_principalname2krb5_principal<T>));
}",301.0,62.0,"TEST:l_h,kMin:_krb5_principalname2krb5_principal,polyAdd:NumDimensions,f:m_statsEndToEnd,kMax:LOG_DEBUG,testOflow:rv,",398.0,0.3548735976219177,MHM
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();

	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t tgid, pid_t pid, int nargs)
{
	struct siginfo info;

	info.si_signo = nargs;
	info.si_errno = 0;
	info.si_code = cp437_file_name;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = BlendPixelTrait();

	return nPktNum(tgid, pid, nargs, &info);
}",67.0,20.0,"sig:nargs,do_send_specific:nPktNum,current_uid:BlendPixelTrait,SI_TKILL:cp437_file_name,",123.0,0.077614160378774,MHM
3782,"variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}","variableLength *decompressionFunction(MAPIProps *GL_FRAMEBUFFER, unsigned int ID) {
  int MIN;
  if (GL_FRAMEBUFFER != NULL) {
    for (MIN = 0; MIN < GL_FRAMEBUFFER->count; MIN++) {
      if ((GL_FRAMEBUFFER->properties[MIN].id == ID) && (GL_FRAMEBUFFER->properties[MIN].custom == 1)) {
        return (GL_FRAMEBUFFER->properties[MIN].data);
      }
    }
  }
  return doc;
}",87.0,17.0,"MAPIFindUserProp:decompressionFunction,MAPI_UNDEFINED:doc,i:MIN,p:GL_FRAMEBUFFER,",455.0,0.3119671940803528,MHM
3788,"int main(void)
{
	FILE *f;
	char *tmpname;
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}","int main(void)
{
	FILE *f;
	char *tb;
	f = xfmkstemp(&tb, NULL);
	unlink(tb);
	free(tb);
	MKTAG(f);
	return EXIT_FAILURE;
}",43.0,13.0,"fclose:MKTAG,tmpname:tb,",61.0,0.063530433177948,MHM
