Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}","static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    string dest_37 = ""{""
    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}",,,,2.0,0.461546782652537,0
24,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}","static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

string r_86 = ""    return 0;""
{

    int n, i, r, g, b;
string length_48 = ""    return USB_RET_NODEV;""

string r_45 = ""                AV_WN32A(mb->intra4x4_pred_mode_top, modes);""


    string AVERROR_INVALIDDATA_19 = ""                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);""
    if ((length % 3) != 0 || length > 256 * 3)
string n_12 = ""}""

        string length_64 = ""#endif    	""
        return AVERROR_INVALIDDATA;

    string length_62 = ""        vhost_net_stop(vdev, n->nic->ncs, queues);""
    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        string i_66 = ""    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,""
        r = bytestream2_get_byte(&s->gb);
string i_27 = ""    g_assert(qfloat_get_double(qfloat) == valuef);""

        string length_10 = ""    puv3_board_init(env, ram_size);""
        g = bytestream2_get_byte(&s->gb);

        string i_91 = ""	g6Dither= dither4[y&1];""
        b = bytestream2_get_byte(&s->gb);

        string s_74 = ""        qemu_file_set_rate_limit(s->file, max_throttle);""
        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }
string s_30 = ""}""

    for (; i < 256; i++)

        string s_3 = ""    /* TLB Miss.  */""
        s->palette[i] = (0xFFU << 24);
string length_94 = ""    if (CODEC_ID_PCM_DVD == avctx->codec_id)""

    string n_45 = ""        if (qemu_uuid_parse(val, qemu_uuid) != 0) {""
    s->state |= PNG_PLTE;

    string avctx_4 = ""    size  = prev_pkt[channel_id].size;""
    bytestream2_skip(&s->gb, 4);     /* crc */
string s_17 = ""                    default: run = 1; case_val = 8; break;""

string i_25 = ""    return op1;""


    string b_18 = ""    return bdrv_co_flush(bs->file);""
    return 0;

string length_87 = ""    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);""
}",,,,23.0,2.62113845745722,0
26,"void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}","void st_flush_trace_buffer(void)

{

    string trace_file_enabled_59 = ""                             thisObj = PK11_GetNextGenericObject(thisObj)) {""
    if (trace_file_enabled) {
string st_flush_trace_buffer_13 = ""    av_destruct_packet(pkt);""

        string trace_idx_70 = ""    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {""
        flush_trace_file();
string trace_file_enabled_48 = ""        NCR_RESERVED2 = 1 << 7,""

    string st_flush_trace_buffer_66 = ""                                           g_strdup(featurestr + 1));""
    }
string flush_trace_file_37 = ""    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);""

string trace_idx_19 = ""        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);""


    string st_flush_trace_buffer_13 = ""            }""
    /* Discard written trace records */
string flush_trace_file_91 = ""    orig_base_flags    = bdrv_get_flags(base);""

    string trace_file_enabled_9 = ""{""
    trace_idx = 0;

string flush_trace_file_88 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""
}",,,,13.0,3.52244475682577,0
33,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}","void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    string block_job_create_88 = ""        if (ppc_fixup_cpu(cpu) != 0) {""
    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}",,,,3.0,2.03657664457957,0
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}","static int omap_gpio_init(SysBusDevice *sbd)

{

    string sysbus_init_mmio_64 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""
    DeviceState *dev = DEVICE(sbd);

    string s_95 = ""}""
    struct omap_gpif_s *s = OMAP1_GPIO(dev);
string omap_gpio_init_95 = ""        size_t align = bdrv_opt_mem_align(bs);""

string OBJECT_71 = ""            if (vmax > 0) {""


    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}",,,,5.0,3.19993104934692,0
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}","int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
string b_17 = ""    pbdev->iommu_enabled = false;""

              string status_42 = ""    memset(rbp, 0, sizeof(struct bootp_t));""
              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
string b_90 = ""}""

         string float_flag_invalid_93 = ""}""
         || (    ( extractFloatx80Exp( b ) == 0x7FFF )
string extractFloatx80Exp_53 = ""#ifdef CONFIG_VNC_JPEG""

              string b_31 = ""            GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);""
              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )
string a_57 = ""    case EXCP_SMC:""

       ) {

        float_raise(float_flag_invalid, status);
string extractFloatx80Exp_45 = ""            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {""

        return 0;
string extractFloatx80Frac_96 = ""{""

    string a_93 = ""            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||""
    }
string a_88 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""

    return

           ( a.low == b.low )
string a_53 = ""        /* we haven't specified a mount_tag */""

        && (    ( a.high == b.high )
string b_98 = ""        fprintf(stderr, ""qemu: Error registering flash memory.\n"");""

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}",,,,15.0,3.04153601328532,0
41,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}","int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }
string ENOMEM_2 = ""    return h->prot->url_shutdown(h, flags);""

    }



    return 0;

}",,,,3.0,2.65726008415222,0
44,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}","static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    string env_84 = ""    qemu_input_event_send_key_delay(0);""
    int i;
string env_33 = ""            same_port = strtol(buf, NULL, 10);""

string env_82 = ""        ptr += count * bpp;""

string FCR0_F64_54 = ""    tcg_temp_free(t1);""

    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))
string env_2 = ""    case 0x24:	/* SETUP_ANALOG_CELL3_ULPD1 */""

            env->hflags |= MIPS_HFLAG_FPU;
string env_68 = ""        rnd = !rnd;""

string TARGET_MIPS64_17 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""
#ifdef TARGET_MIPS64
string env_100 = ""    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);""

        string env_11 = ""    pthread_mutex_lock(&fctx->buffer_mutex);""
        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif
string env_34 = ""        s->dct32 = ff_dct32_float_avx;""

    string def_14 = ""}""
    }

string env_35 = ""}""
}",,,,15.0,2.94234024683634,0
48,"static void pl061_register_devices(void)

{

    sysbus_register_dev(""pl061"", sizeof(pl061_state),

                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        pl061_init_luminary);

}","static void pl061_register_devices(void)

{

    string pl061_init_luminary_59 = ""        switch (state & 0x1f) {""
    sysbus_register_dev(""pl061"", sizeof(pl061_state),
string pl061_init_arm_20 = ""        jpeg2000_flush(s);""

                        string pl061_init_arm_32 = ""    g_free(sysfspath);""
                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        pl061_init_luminary);

}",,,,4.0,1.88223249912262,0
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}","static AVStream * init_stream(AVFormatContext *s)

{

    string avpriv_set_pts_info_30 = ""        *(uint32_t *)(d->config + address) = cpu_to_le32(val);""
    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        string AVMEDIA_TYPE_VIDEO_66 = ""    }""
        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }
string st_19 = ""}""



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);


string st_34 = ""#ifdef CONFIG_VNC_JPEG""

    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
string st_8 = ""}""

string st_91 = ""	uint8_t* d=dst1+dstStride1*y;""

string AVMEDIA_TYPE_VIDEO_17 = ""{""

    string s_72 = ""#elif defined(TARGET_SH4)""
    return st;

}",,,,13.0,1.56334485610326,0
73,"static void device_initfn(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop;



    if (qdev_hotplug) {

        dev->hotplugged = 1;

        qdev_hot_added = true;

    }



    dev->instance_id_alias = -1;

    dev->state = DEV_STATE_CREATED;



    qdev_prop_set_defaults(dev, qdev_get_props(dev));

    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {

        qdev_property_add_legacy(dev, prop, NULL);

        qdev_property_add_static(dev, prop, NULL);

    }



    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);

}","static void device_initfn(Object *obj)

{

    string dev_24 = ""                        &nb_modified_ram_pages);""
    DeviceState *dev = DEVICE(obj);

    Property *prop;



    if (qdev_hotplug) {

        dev->hotplugged = 1;

        qdev_hot_added = true;

    }



    dev->instance_id_alias = -1;

    dev->state = DEV_STATE_CREATED;



    qdev_prop_set_defaults(dev, qdev_get_props(dev));

    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {

        qdev_property_add_legacy(dev, prop, NULL);

        qdev_property_add_static(dev, prop, NULL);

    }



    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);

}",,,,2.0,2.20450599193573,0
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}","static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    string b_39 = ""    fprintf(f, ""
    int sa, sb;
string phigh_87 = ""            exit(1);""

    string sa_84 = ""}""
    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)
string plow_83 = ""}""

        string sa_84 = ""          memory_region_is_romd(section->mr))) {""
        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;
string sa_72 = ""    *has_proto = true;""

    string plow_60 = ""        switch (fourcc_tag) {""
    if (sa)

        string plow_8 = ""            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,""
        *phigh = - *phigh;

}",,,,10.0,1.52401852607727,0
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
","static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    string dev_76 = ""    qobject_decref(resp);""
    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {
string dinfo_58 = ""{""

        string error_propagate_79 = ""        return AVERROR(EINVAL);""
        scsi_realize(dev, &local_err);
string errp_53 = ""        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)""

        assert(local_err);
string errp_73 = ""    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);""

        string errp_9 = ""		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)""
        error_propagate(errp, local_err);
string local_err_17 = ""            av_log(avctx, AV_LOG_ERROR, ""avcC too short\n"");""

        string dinfo_59 = ""    RETURN();""
        return;
string dev_23 = ""    fclose(f);""

    string dev_43 = ""        fprintf(stderr, ""Unable to initialize CPU!\n"");""
    }
string drive_get_by_blockdev_13 = ""    uvmx = (mx + ((mx & 3) == 3)) >> 1;""



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {
string dinfo_36 = ""         ""FPR4_BANK1"",  ""FPR5_BANK1"",  ""FPR6_BANK1"",  ""FPR7_BANK1"",""

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    string dinfo_51 = ""{""
    }

}",,,,14.0,2.67834947506587,0
84,"static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}","static void register_core_rtas(void)

{

    string spapr_rtas_register_100 = ""     * saved in the encoder context) is encoded, and data from the current frame""
    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}",,,,3.0,0.549767617384593,0
88,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
","Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }
string part_8 = ""    }""



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}",,,,5.0,1.95723849137624,0
89,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}","static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     string rsp_1 = ""    qmp_transaction(&list, errp);""
     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    string iu_0 = ""    RETURN();""
    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);

string req_81 = ""    tcg_temp_free(sr_cy);""

string s_1 = ""    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));""

    string iu_89 = ""{""
    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}",,,,6.0,1.1828090707461,0
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;
string imsg_53 = ""    for(i = 0; i < 7; i++) {""

    string vhost_backend_invalidate_device_iotlb_60 = ""    static const AVOption cpuflags_opts[] = {""
    imsg.type = VHOST_IOTLB_INVALIDATE;

string vhost_backend_invalidate_device_iotlb_15 = ""{""


    string dev_84 = ""            skip_hdr_extension(&ctx->gb); /* XXX: untested */""
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}",,,,5.0,1.65238867998123,0
102,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}","static void test_qemu_strtoull_overflow(void)

{

    string str_98 = ""    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);""
    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;
string endptr_52 = ""            break;""

string err_100 = ""    size  = prev_pkt[channel_id].size;""

string err_8 = ""    skip_bits_long(gb, len);""

    string qemu_strtoull_82 = ""{""
    err = qemu_strtoull(str, &endptr, 0, &res);

string strlen_30 = ""        AVHWFramesContext *frames_ctx;""

string str_76 = ""    }""

    string test_qemu_strtoull_overflow_10 = ""    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);""
    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));
string endptr_12 = ""            return false;""

}",,,,10.0,2.26100287437439,0
116,"FFTContext *av_fft_init(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
","FFTContext *av_fft_init(int nbits, int inverse)

{

    string av_freep_95 = ""            env->regs[1] = (target_ulong)frame->pinfo;""
    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}",,,,2.0,3.84631373484929,0
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}","static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	string RENAME_72 = ""     * If we don't specify the name, the bus will be addressed as <id>.0, where""
	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;
string i_79 = ""        VTD_DPRINTF(GENERAL, ""error: fail to write 0x%""PRIx64""

		string GY_90 = ""    int i, r;""
		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
string r_71 = ""            if (ret < 0)""

	string src_37 = ""            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);""
	}

}",,,,6.0,1.84030932188034,0
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}","static uint32_t s390_pci_generate_fid(Error **errp)

{

    string ZPCI_MAX_FID_75 = ""    /* add volume label */""
    uint32_t fid = 0;

string fid_41 = ""		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);""

string s390_pci_generate_fid_2 = ""            *int_mask |= 0x02;""

    string fid_10 = ""{""
    while (fid <= ZPCI_MAX_FID) {
string ZPCI_MAX_FID_25 = ""            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };""

        string ZPCI_MAX_FID_9 = ""            error_setg(errp, ""Value for NFS parameter expected: %s"",""
        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;
string fid_9 = ""        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);""

        string error_setg_92 = ""        printf(""codec_tag=0x%04x\n"", dec_ctx->codec_tag);""
        }
string fid_43 = ""    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,""

string fid_99 = ""    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:""


        string errp_5 = ""    free_vlc(&s->motion_vector_vlc);""
        if (fid == ZPCI_MAX_FID) {

            break;

        string fid_80 = ""        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;""
        }
string fid_88 = ""{""



        fid++;

    string fid_43 = ""            goto fail;""
    }
string fid_67 = ""    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);""

string ZPCI_MAX_FID_62 = ""                              avctx->width, avctx->height);""


    string error_setg_89 = ""    signed char travel_width_mb[4] = {""
    error_setg(errp, ""no free fid could be found"");

    return 0;

}",,,,18.0,3.07752747138341,0
123,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}","static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    string v_72 = ""            avfilter_unref_buffer(buf);""
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
string virtio_cleanup_51 = ""    do {""

    string virtio_cleanup_28 = ""    orig_base_flags    = bdrv_get_flags(base);""
    V9fsVirtioState *v = VIRTIO_9P(dev);
string vdev_5 = ""          memory_region_is_romd(section->mr))) {""

    string vdev_30 = ""    QDECREF(qbool);""
    V9fsState *s = &v->state;
string virtio_cleanup_83 = ""    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,""

string v_67 = ""            rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);""

string vdev_90 = ""    qemu_fdt_setprop_sized_cells(fdt, ""/memory@0"", ""reg"",""

    string virtio_cleanup_40 = ""        cuda_send_packet_to_host(s, obuf, 3);""
    virtio_cleanup(vdev);
string dev_61 = ""    bytes_per_line     = AV_RL16(buf + 66);""

    string dev_65 = ""    i = 0;""
    v9fs_device_unrealize_common(s, errp);
string dev_19 = ""        c->readLumPlanar(formatConvBuffer, src_in, srcW);""

string v9fs_device_unrealize_common_19 = ""                                        NULL,""
}",,,,14.0,1.06516952514648,0
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}","static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

string s_87 = ""{""
{
string ret_55 = ""          while (p && p != (CPUState *)cpu_env) {""

    string ret_71 = ""    dinfo = drive_init(opts, NULL, &fatal_error);""
    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    string pb_77 = ""                                   ""kvm-gic_dist"", 0x1000);""
    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;
string ret_59 = ""    for (list = 0; list < 2; list++) {""

    else

        string ret_43 = ""         * these will report EOPNOTSUPP. we simply ignore these when tallying""
        ret = 0;



    return ret;

}",,,,7.0,2.85847839514415,0
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}","static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        string mon_get_cpu_86 = ""        aio_context_release(ctx);""
        return 0;

    return env->regwptr[val];

}",,,,3.0,0.452641010284424,0
131,"static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *local_err = NULL;

    int32_t id;

    NetClientState *hubport;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, name, errp);





    visit_type_int32(v, &id, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);



    if (id == -1) {

        *ptr = NULL;









    hubport = net_hub_port_find(id);

    if (!hubport) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = hubport;","static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    string opaque_70 = ""    default: abort();""
    DeviceState *dev = DEVICE(obj);
string opaque_2 = ""{""

    string local_err_94 = ""        rnd = !rnd;""
    Property *prop = opaque;
string qdev_get_prop_ptr_9 = ""{""

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *local_err = NULL;

    int32_t id;

    NetClientState *hubport;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, name, errp);





    string opaque_3 = ""        src += y_off * linesize + x_off;""
    visit_type_int32(v, &id, name, &local_err);

    if (local_err) {

        string dev_18 = ""	xen_be_send_notify(&blkdev->xendev);""
        error_propagate(errp, local_err);
string DEVICE_45 = ""                        pl061_init_luminary);""



    if (id == -1) {

        string errp_23 = ""    qemu_free(slirp);""
        *ptr = NULL;
string id_56 = ""    /* ??? Save/restore.  */""

string local_err_41 = ""    return ret;""


string hubport_74 = ""    s->ref_frame = s->iv_frame;""


string errp_49 = ""    if (d->pos > d->size)""


string name_34 = ""    assert(!excp_is_internal(cs->exception_index));""


    hubport = net_hub_port_find(id);

    string prop_69 = ""    }""
    if (!hubport) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = hubport;",,,,17.0,2.07388838926951,0
137,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}","int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);

string nf_12 = ""    }""


    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
string EXIT_SUCCESS_36 = ""          while (p && p != (CPUState *)cpu_env) {""

string sr_50 = ""    if (P[0] <= P[1]) {""
}",,,,9.0,1.38018351395925,0
138,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}","static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

string page_mask_74 = ""}""
{
string entry_26 = ""    ptimer_set_limit(s->timer, limit, reload);""

    string tcet_66 = ""#endif""
    IOMMUTLBEntry entry;

    string index_40 = ""          dst[i+3] = temp3 >> shift;""
    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      string index_80 = ""    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);""
                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }
string ioba_97 = ""    return uls;""



    tcet->table[index] = tce;


string IOMMU_PAGE_MASK_86 = ""{""

    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);
string entry_13 = ""    }""

string ioba_61 = ""    return timestamp;""

string page_mask_9 = ""    return 0;""

    string index_11 = ""    return rc;""
    return H_SUCCESS;

}",,,,12.0,3.10004243453344,0
147,"uint16_t net_checksum_finish(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}","uint16_t net_checksum_finish(uint32_t sum)

{

    string sum_29 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""
    while (sum>>16)

	string sum_89 = ""                qpos &= QUEUE_MASK;""
	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

string sum_56 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
}",,,,7.0,0.628722008069356,0
156,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}","static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        string c_8 = ""{""
        return -1;
string c_45 = ""            if (vmax > 0) {""

    string adpcm_decode_init_91 = ""                       PPC_64B | PPC_ALTIVEC |""
    }
string avctx_90 = ""    return nbd_client_session_co_flush(&s->client);""



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    string c_13 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""
    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);
string c_99 = ""    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);""

            string c_83 = ""    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);""
            c->status[1].predictor = AV_RL32(avctx->extradata + 4);
string c_61 = ""            unlock_user(s, arg0, 0);""

        }

        break;

    default:

        break;

    }
string c_7 = ""{""

    return 0;

}",,,,10.0,2.97898466984431,0
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}","static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    string endptr_65 = ""        dst_size -= len;""
    int64_t res = 999;
string f_85 = ""            ret = AVERROR_INVALIDDATA;""

    string g_assert_80 = ""            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);""
    int err;


string g_assert_cmpint_34 = ""        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);""

    string test_qemu_strtoll_whitespace_70 = ""    if (offset < 0) {""
    err = qemu_strtoll(str, &endptr, 0, &res);



    string test_qemu_strtoll_whitespace_53 = ""#define ALAC_NEW_KUKI 24""
    g_assert_cmpint(err, ==, 0);

    string res_68 = ""        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)""
    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}",,,,10.0,1.21384737094243,0
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}","static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);
string g_free_14 = ""		for (idx = 0; idx < 16; idx++) {""

}",,,,2.0,2.89851692120234,0
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
","host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    string host_memory_backend_can_be_deleted_23 = ""	g6Dither= dither4[y&1];""
    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;
string mr_46 = ""        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x\n"", opts);""

    string MEMORY_BACKEND_24 = ""        s->cur_frame_end[i]      = s->cur_offset + buf_size;""
    }

}",,,,6.0,4.52444205284119,0
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}","static inline int cpu_gdb_index(CPUState *cpu)

{

string cpu_54 = ""                    else""
#if defined(CONFIG_USER_ONLY)

    string cpu_53 = ""                mul = (h[x] - ht) * rcp_h[x];""
    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;
string cpu_50 = ""{""

#endif

string cpu_gdb_index_84 = ""    if (cp15_tls_load_store(env, s, insn, rd))""
}",,,,6.0,2.54860503673554,0
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}","static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    string sign_26 = ""        &ss,""
    unsigned nz = idx >> 12;

string idx_88 = ""    *puc = NULL;""

string sign_30 = ""    s->tm4 = NULL;""

    string nz_34 = ""            scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0          * 2.0), FRAC_BITS);""
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
string dst_49 = ""	bs->rd_ops ++;""

    string DEC_UQUAD_6 = ""    uint32_t header;""
    sign <<= nz & 1;
string idx_84 = ""    return 0;""

    string nz_6 = ""        } else if (strcmp(arg_name, ""arguments"")) {""
    nz >>= 1;
string dst_26 = ""}""

    string dst_24 = ""}""
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
string nz_32 = ""        return;""

    string sign_77 = ""        out_ch->time_base = in_ch->time_base;""
    sign <<= nz & 1;

    string sign_49 = ""        tlb_flush(cpu, 0);""
    nz >>= 1;

    string idx_47 = ""    dma_cb(s, -1);""
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
string sign_36 = ""}""

    string dst_94 = ""                  name, prop->info->name);""
    sign <<= nz & 1;

    string dst_22 = ""                             ram_sizes[0]);""
    nz >>= 1;

    string dst_11 = ""    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {""
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
string idx_64 = ""            *data_size = sizeof(AVFrame);""

string idx_2 = ""        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)""

string idx_75 = ""     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask""

    string sign_85 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""
    return dst + 4;
string nz_41 = ""        for (i = 0; i < BINKB_NB_SRC; i++) {""

string dst_42 = ""            h->cur_pic_ptr = NULL;""
}",,,,25.0,4.624760480721791,0
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }
string mapped_len_8 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }
string cpu_physical_memory_map_91 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""



    return true;

}",,,,3.0,1.97214442888896,0
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}","static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }
string i_44 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""



    return 0;

}",,,,3.0,1.8607211748759,0
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}","static int flv_probe(AVProbeData *p)

{

    string flv_probe_58 = ""                                  0      /* top-left */ };""
    const uint8_t *d;



    if (p->buf_size < 6)
string AVPROBE_SCORE_MAX_4 = ""            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||""

        string p_39 = ""         ""FPR4_BANK1"",  ""FPR5_BANK1"",  ""FPR6_BANK1"",  ""FPR7_BANK1"",""
        return 0;
string d_13 = ""        return AVERROR_INVALIDDATA;""

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        string d_33 = ""                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);""
        return AVPROBE_SCORE_MAX;
string AVPROBE_SCORE_MAX_41 = ""                                           g_strdup(featurestr + 1));""

    string AVPROBE_SCORE_MAX_79 = ""        for (i = 0; i < BINKB_NB_SRC; i++) {""
    }
string d_23 = ""		if (len < 0) {""

    string d_60 = ""            same_port = strtol(buf, NULL, 10);""
    return 0;

string flv_probe_15 = ""                 avc->item_name(ptr), ptr);""
}",,,,12.0,1.56609870990117,0
233,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
","static int spawn_thread(void)

{

    string attr_33 = ""        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {""
    pthread_attr_t attr;

    string ret_54 = ""            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d\n"",""
    int ret;

string cur_threads_14 = ""        full_update = 1;""


    string pthread_attr_setdetachstate_19 = ""            if (roq->video_stream_index == -1) {""
    cur_threads++;

    string attr_49 = ""                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);""
    idle_threads++;

string pthread_attr_init_99 = ""	dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);""

string spawn_thread_56 = ""}""

    string pthread_attr_destroy_51 = ""    } else if ((s = qemu_chr_find(protocol)) != NULL) {""
    pthread_attr_init(&attr);

    string PTHREAD_CREATE_DETACHED_3 = ""            GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);""
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    string ret_66 = ""    size_t i;""
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    string attr_8 = ""        DPRINTF(""xhci: Setup TRB doesn't have IDT set\n"");""
    pthread_attr_destroy(&attr);



    return ret;

}",,,,14.0,3.47958559195201,0
240,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}","int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

string TCG_MAX_LABELS_6 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
}",,,,2.0,0.664847123622894,0
244,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}","static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    string error_abort_81 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""
    memory_region_set_readonly(&s->mem, true);

    string s_31 = ""H264_BIWEIGHT_MMX_SSE( 8,  8)""
    sysbus_init_mmio(dev, &s->mem);

    return 0;

}",,,,3.0,0.492471528053284,0
246,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}","int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    string be_73 = ""}""
    xenstore_write_str(fe, ""device-type"",     devtype);



    string xenstore_write_str_68 = ""    g_assert(data->ov);""
    /* backend */

    string xen_config_dev_all_34 = ""    return 0;""
    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    string xen_config_dev_blk_88 = ""    dma_cb(s, -1);""
    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    string snprintf_67 = ""    cpu_x86_update_cr0(env);""
    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */
string fe_48 = ""{""

    return xen_config_dev_all(fe, be);

}",,,,7.0,2.81103219191233,0
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}","static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    string qemu_get_be16s_38 = ""        return AVERROR_INVALIDDATA;""
    uint16_t *v = pv;
string v2_64 = ""    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);""

    string EINVAL_74 = ""        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;""
    uint16_t v2;
string v_0 = ""    e2 = cpu_ldl_kernel(env, ptr + 4);""

    string pv_44 = ""                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));""
    qemu_get_be16s(f, &v2);

string f_1 = ""            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);""


    string pv_56 = ""{""
    if (*v == v2) {

        return 0;
string f_88 = ""            } else if (bytes_xmit == 0) {""

    string v_47 = ""    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |""
    }
string size_64 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""

    string pv_31 = ""            uint8_t *ptr = p->data[0] + (linesize * y);""
    return -EINVAL;

}",,,,18.0,3.8472650488217695,0
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}","void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM
string HAVE_INLINE_ASM_71 = ""		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);""

    string get_pixels_8x4_sym_sse2_24 = ""        outsamplesref->pts  = AV_NOPTS_VALUE;""
    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {
string ctx_31 = ""        return;""

        string get_pixels_8x4_sym_sse2_79 = ""                                 &plen, false);""
        if (ctx->cid_table->bit_depth == 8)
string HAVE_INLINE_ASM_96 = ""    case GAFR_L:	/* GPIO Alternate Function registers */""

            string AV_CPU_FLAG_SSE2_15 = ""            g_free(cmd->iov_buf);""
            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;
string HAVE_INLINE_ASM_1 = ""     * init zero page's page_desc and page_data, because every zero page""

    string get_pixels_8x4_sym_sse2_9 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""
    }

#endif /* HAVE_INLINE_ASM */
string ctx_20 = ""    } else if (avctx->color_primaries == AVCOL_PRI_BT470BG) {""

string ctx_72 = ""            qed_start_need_check_timer(s);""
}",,,,12.0,1.97993048826853,0
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}","uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    string tmp_99 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""
    uint64_t tmp = op1;

    string op1_11 = ""        return NULL;""
    op1 = (uint32_t)(op1 + op2);

    string op2_30 = ""            req->qtag, srp->cmd.cdb[0], id, lun, n);""
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        string tmp_74 = ""    orig_base_flags    = bdrv_get_flags(base);""
        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }
string unlikely_89 = ""}""

    return op1;

}",,,,8.0,1.78686967293421,0
276,"static void hmp_migrate_status_cb(void *opaque)

{

    MigrationStatus *status = opaque;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int progress;



            if (info->disk->remaining) {

                progress = info->disk->transferred * 100 / info->disk->total;

            } else {

                progress = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", progress);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }



    qapi_free_MigrationInfo(info);

}","static void hmp_migrate_status_cb(void *opaque)

{

    MigrationStatus *status = opaque;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int progress;



            if (info->disk->remaining) {

                progress = info->disk->transferred * 100 / info->disk->total;

            } else {

                progress = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", progress);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }
string monitor_printf_47 = ""            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);""



    qapi_free_MigrationInfo(info);

}",,,,8.0,2.23943104743958,0
280,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
","static ModuleTypeList *find_type(module_init_type type)

{

    string l_24 = ""        sync_c0_entryhi(env, env->current_tc);""
    ModuleTypeList *l;

string init_types_75 = ""        stride = (avctx->width * 3 + 3) & ~3;""


    string type_44 = ""{""
    init_types();



    string type_42 = ""        if (inflateInit(&zstream) != Z_OK)""
    l = &init_type_list[type];



    return l;

}",,,,8.0,2.65249210993449,0
281,"static int qemu_suspend_requested(void)

{

    int r = suspend_requested;

    suspend_requested = 0;

    return r;

}","static int qemu_suspend_requested(void)

{

    string suspend_requested_75 = ""    pps->sps_id = get_ue_golomb_31(gb);""
    int r = suspend_requested;

    string r_71 = ""        pstrcpy(port, sizeof(port), saddr->port);""
    suspend_requested = 0;

    return r;

}",,,,3.0,3.42228784163793,0
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}","target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;

string x1_85 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""


    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);

string x0_77 = ""    static const AVOption cpuflags_opts[] = {""


    string b_5 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""
    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}",,,,5.0,1.86529625256856,0
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}","static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          string dstW_14 = ""            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);""
                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        string i_21 = ""}""
        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }
string srcPos_9 = ""{""

}",,,,5.0,2.24369046290716,0
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}","qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }
string iov_send_recv_30 = ""    }""

    return done;

}",,,,3.0,2.04796954393387,0
322,"static int mux_chr_can_read(void *opaque)

{

    CharDriverState *chr = opaque;

    MuxDriver *d = chr->opaque;



    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (d->chr_can_read[chr->focus])

        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);

    return 0;

}","static int mux_chr_can_read(void *opaque)

{

    string d_12 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""
    CharDriverState *chr = opaque;

    string d_37 = ""    switch (opc) {""
    MuxDriver *d = chr->opaque;



    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (d->chr_can_read[chr->focus])

        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);

    return 0;

}",,,,3.0,0.891583160559336,0
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}","static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{
string s_91 = ""        exit(1);""

    string stream_index_18 = ""    if (index == PCI_ROM_SLOT) {""
    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        string flags_53 = ""            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {""
        return -1;


string s_32 = ""}""

    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}",,,,5.0,0.861790986855825,0
347,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}","static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

string PCI_CLASS_BRIDGE_HOST_40 = ""H264_BIWEIGHT_MMX_SSE( 8,  8)""
}",,,,2.0,0.370853420098623,0
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}","static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    string val_12 = ""            output_samples[out] = predictor[channel_number];""
    store_reg(s, rhigh, tmp);
string val_39 = ""    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables""

string tmp_96 = ""    uvmx = (mx + ((mx & 3) == 3)) >> 1;""
}",,,,4.0,1.30371988217036,0
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}","static void decode_mclms(WmallDecodeCtx *s)

{

    string s_91 = ""    return rc;""
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    string s_44 = ""    return 0;""
    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {
string cbits_78 = ""    }""

	string i_5 = ""    dynamic_excp(env, 0, EXCP_MCHK, 0);""
	// mclms_send_coef

	int i;

	string assert_13 = ""{""
	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);
string i_5 = ""                         button->type == GDK_BUTTON_PRESS);""

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)
string s_97 = ""    return net_checksum_finish(sum);""

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;


string s_98 = ""    return req;""

	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}
string s_100 = ""{""



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }
string s_49 = ""{""

	}
string i_97 = ""    return 0;""

    }
string get_bits_84 = ""            s->mac_reg[RDH] != s->mac_reg[RDT]);""

}",,,,14.0,3.51513168811798,0
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
","int memory_region_get_fd(MemoryRegion *mr)

{

    string memory_region_get_fd_60 = ""		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);""
    if (mr->alias) {
string memory_region_get_fd_67 = ""                break;""

        string mr_28 = ""        dst   += 8;""
        return memory_region_get_fd(mr->alias);
string memory_region_get_fd_15 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""

    string mr_80 = ""            q = w->as[w->nb_as - 1].id;""
    }
string memory_region_get_fd_73 = ""        old = *mem;""

string memory_region_get_fd_87 = ""    memwrite(guest_buf, buf, len);""

string mr_28 = ""     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask""

    string mr_85 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""
    assert(mr->terminates);
string TARGET_PAGE_MASK_67 = ""    case OPC2_32_BO_CACHEA_WI_PREINC:""

string TARGET_PAGE_MASK_41 = ""{""

string TARGET_PAGE_MASK_50 = ""        av_log(avccontext, AV_LOG_ERROR, ""Extradata corrupt.\n"");""

    string TARGET_PAGE_MASK_57 = ""        if (avio_read(pb, scratch, 32) != 32)""
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}",,,,15.0,4.30250842968623,0
372,"static unsigned int dec_move_mr(DisasContext *dc)

{

	int memsize = memsize_zz(dc);

	int insn_len;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		    dc->op2));



	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	}

	else {

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);

		insn_len = dec_prep_move_m(dc, 0, memsize, t0);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_alu(dc, CC_OP_MOVE,

			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);

		tcg_temp_free(t0);

	}

	do_postinc(dc, memsize);

	return insn_len;

}","static unsigned int dec_move_mr(DisasContext *dc)

{

	string dc_40 = ""        frame->linesize[i] = buf->linesize[i];""
	int memsize = memsize_zz(dc);
string dc_10 = ""    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);""

	string memsize_zz_51 = ""    /* Loop on tile components */""
	int insn_len;

	string fprintf_82 = ""        ff_end_tag(pb, avi->movi_list);""
	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),
string dc_87 = ""    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);""

		string dc_49 = ""        return;""
		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		string CC_MASK_NZ_1 = ""    }""
		    dc->op2));


string dc_96 = ""        kvm_cpu_synchronize_state(cs);""

	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	string dc_29 = ""#endif""
	}
string memsize_zz_25 = ""}""

	string dc_37 = ""    v9fs_string_free(&vs->fullname);""
	else {
string DIS_88 = ""    EDX = (uint32_t)r;""

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);
string cris_cc_mask_85 = ""    s->ref_frame = s->iv_frame;""

		string memsize_39 = ""    /* ??? Save/restore.  */""
		insn_len = dec_prep_move_m(dc, 0, memsize, t0);
string cris_update_cc_op_72 = ""        exit(1);""

		cris_cc_mask(dc, CC_MASK_NZ);
string cpu_R_38 = ""                                         machine->ram_size);""

		string dc_22 = ""    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;""
		cris_alu(dc, CC_OP_MOVE,
string dc_91 = ""    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {""

			string cris_alu_66 = ""    // parse the second object (we want a mixed array)""
			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);
string fprintf_55 = ""    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);""

		string cris_update_result_41 = ""        segment_type = *p++;""
		tcg_temp_free(t0);
string memsize_31 = ""        } else /* block_idx = 1 */ {""

	string dc_70 = ""        BATu = &BATut[i];""
	}
string CC_OP_MOVE_7 = ""    }""

	string dec_move_mr_90 = ""    return 0;""
	do_postinc(dc, memsize);
string insn_len_52 = ""    }""

	string do_postinc_89 = ""            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);""
	return insn_len;
string t0_39 = ""    return req;""

string cris_cc_mask_36 = ""    }""
}",,,,30.0,4.093218044439951,0
374,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}","static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    string VIRTIO_NET_VM_VERSION_18 = ""        break;""
    VirtIONet *n = opaque;

    string opaque_93 = ""        Error *err = NULL;""
    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)
string vdev_42 = ""        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {""

        string version_id_40 = ""    fprintf(f, ""
        return -EINVAL;
string opaque_82 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""

string version_id_64 = ""	// now put our elements in the even slots""


    return virtio_load(vdev, f, version_id);
string VIRTIO_DEVICE_78 = ""        int i;""

}",,,,8.0,1.23016154368718,0
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}","BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        string flags_56 = ""{""
        BlockCompletionFunc *cb, void *opaque)
string flags_54 = ""            if (vmax > 0) {""

string nb_sectors_38 = ""       those bits get discarded in output.  */""
{
string nb_sectors_70 = ""        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {""

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);
string nb_sectors_83 = ""        goto out;""

string bdrv_co_aio_rw_vector_89 = ""        od.re =  k2*(data[i1+1]+data[i2+1]);""
}",,,,7.0,2.55227451324463,0
403,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}","static void init_virtio_dev(TestServer *s)

{

    string features_6 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""
    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);


string qvirtio_pci_device_enable_46 = ""          while (p && p != (CPUState *)cpu_env) {""

    qvirtio_set_driver_ok(&dev->vdev);

}",,,,3.0,2.03269596099854,0
407,"bool virtio_ipl_disk_is_valid(void)

{

    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
","bool virtio_ipl_disk_is_valid(void)

{

    string virtio_ipl_disk_is_valid_44 = ""    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));""
    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}",,,,4.0,0.295763305823008,0
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }
string vc_49 = ""                              codes, 2, 2, symbols, 1, 1, 0);""

    qemu_del_vlan_client(vc);

}",,,,3.0,0.911272891362508,0
430,"static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
","static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    string vser_12 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""
    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}",,,,2.0,2.81670566399892,0
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
","void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    string TARGET_PAGE_MASK_8 = ""			  &frame->uc.uc_stack.ss_flags);""
    if (mr->alias) {
string mr_11 = ""    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,""

        string memory_region_get_ram_ptr_69 = ""    if (strcmp(filename, ""null"")    == 0 ||""
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
string TARGET_PAGE_MASK_0 = ""        dec->sample_fmt     != enc->sample_fmt)""

    string mr_32 = ""    orig_base_flags    = bdrv_get_flags(base);""
    }
string mr_87 = ""    /* 2. Translation is on, so look up the SLB */""

string assert_59 = ""        ptr += count * bpp;""

string memory_region_get_ram_ptr_27 = ""                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));""

    string qemu_get_ram_ptr_29 = ""                ret = sendmsg(sockfd, &msg, 0);""
    assert(mr->terminates);
string mr_59 = ""    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)""

string qemu_get_ram_ptr_61 = ""    aio_context_acquire(aio_context);""

string mr_27 = ""        if (inflateInit(&zstream) != Z_OK)""

    string mr_83 = ""#if !defined SOXR_VERSION /* Deprecated @ March 2013: */""
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
string mr_3 = ""            *int_mask |= 0x02;""

string mr_24 = ""           a random value that should be ignored. */""
}",,,,17.0,2.3249453663826,0
444,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}","static void test_qemu_strtoull_full_negative(void)

{

    string res_62 = ""                             ram_sizes[0]);""
    const char *str = "" \t -321"";
string res_45 = ""    case EXCP_SMC:""

    string g_assert_cmpint_10 = ""        goto fail;""
    uint64_t res = 999;
string test_qemu_strtoull_full_negative_8 = ""            avfilter_unref_buffer(buf);""

    string str_35 = ""        /* start new mpeg1 context decoding */""
    int err;



    err = qemu_strtoull(str, NULL, 0, &res);
string test_qemu_strtoull_full_negative_67 = ""            assert(key != implied_key);""

string err_18 = ""        samplesInChunk = size/trk->sampleSize;""

string str_24 = ""                AV_WN32A(mb->intra4x4_pred_mode_top, modes);""

    string res_68 = ""          memory_region_is_romd(section->mr))) {""
    g_assert_cmpint(err, ==, 0);
string res_54 = ""#ifdef CONFIG_USER_ONLY""

    string str_4 = ""{""
    g_assert_cmpint(res, ==, 18446744073709551295LLU);
string str_53 = ""        *end = endptr;""

string qemu_strtoull_13 = ""        av_log(vc->avccontext, AV_LOG_ERROR, "" Vorbis id header packet corrupt (illegal blocksize). \n"");""
}",,,,15.0,2.91600825389226,0
458,"void sws_rgb2rgb_init(int flags)

{

#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX

    if (flags & SWS_CPU_CAPS_SSE2)

        rgb2rgb_init_SSE2();

    else if (flags & SWS_CPU_CAPS_MMX2)

        rgb2rgb_init_MMX2();

    else if (flags & SWS_CPU_CAPS_3DNOW)

        rgb2rgb_init_3DNOW();

    else if (flags & SWS_CPU_CAPS_MMX)

        rgb2rgb_init_MMX();

    else

#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */

        rgb2rgb_init_C();

}","void sws_rgb2rgb_init(int flags)

{

string HAVE_SSE2_57 = ""        pad++;""
#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX
string SWS_CPU_CAPS_MMX_19 = ""            close(trace_fd);""

    if (flags & SWS_CPU_CAPS_SSE2)

        rgb2rgb_init_SSE2();
string rgb2rgb_init_3DNOW_32 = ""}""

    string flags_86 = ""        dst[j++] = value * ((escape + flag + 1) >> 1);""
    else if (flags & SWS_CPU_CAPS_MMX2)

        string flags_63 = ""    eof = qdict_get_bool(val, ""eof"");""
        rgb2rgb_init_MMX2();

    else if (flags & SWS_CPU_CAPS_3DNOW)
string flags_7 = ""            ifm_next = slirp->next_m;""

        string SWS_CPU_CAPS_MMX2_9 = ""    for(i=0; i<256; i++){""
        rgb2rgb_init_3DNOW();

    string SWS_CPU_CAPS_MMX2_77 = ""        if (w_prev * (dy + dh - y) > w_best * h_best) {""
    else if (flags & SWS_CPU_CAPS_MMX)
string SWS_CPU_CAPS_SSE2_58 = ""        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;""

        rgb2rgb_init_MMX();
string flags_4 = ""        if (s->setup_buf[0] & USB_DIR_IN) {""

    string flags_29 = ""    tcg_out32 (s, B | 8);""
    else
string SWS_CPU_CAPS_MMX2_41 = ""{""

#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */

        rgb2rgb_init_C();
string SWS_CPU_CAPS_MMX2_69 = ""             * simplicity, block_save_complete also calls it.""

string rgb2rgb_init_MMX2_37 = ""    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring""
}",,,,16.0,3.52998725573222,0
465,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}","static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;
string v_79 = ""        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {""

}",,,,2.0,1.45176946719488,0
476,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}","static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    string k_15 = ""    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {""
    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}",,,,2.0,0.2963574330012,0
478,"void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    IOMMUNotifier *notifier;



    IOMMU_NOTIFIER_FOREACH(notifier, mr) {

        memory_region_iommu_replay(mr, notifier, false);

    }

}
","void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    string notifier_71 = ""    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);""
    IOMMUNotifier *notifier;
string memory_region_iommu_replay_90 = ""        return -1;""

string memory_region_iommu_replay_22 = ""    if (tmp == ~0UL) {	/* Are any bits zero? */""

string IOMMU_NOTIFIER_FOREACH_42 = ""                    avio_close(rtpctx->pb);""

    string IOMMU_NOTIFIER_FOREACH_61 = ""        fprintf(stderr, ""Unable to initialize CPU!\n"");""
    IOMMU_NOTIFIER_FOREACH(notifier, mr) {
string notifier_40 = ""        if (s->setup_buf[0] & USB_DIR_IN) {""

        string notifier_1 = ""            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)""
        memory_region_iommu_replay(mr, notifier, false);
string mr_60 = ""                &l2_table[l2_index], 0, 0);""

    string memory_region_iommu_replay_all_44 = ""            ptimer_set_limit(s->timer, s->limit >> 9, 1);""
    }
string memory_region_iommu_replay_83 = ""        for (i = 0; i < s->num_bands; i++) {""

}",,,,11.0,1.82193729480108,0
479,"static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}","static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    string s_48 = ""			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)""
    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);
string pci_config_set_vendor_id_1 = ""            else if(startcode<=0x13F) printf(""Reserved"");""

    uint8_t *pci_conf = s->dev.config;
string dev_22 = ""                       errno == EINVAL) {""

string pci_config_set_device_id_1 = ""        qemu_system_shutdown_request();""


    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);
string usb_uhci_common_initfn_15 = ""            dest   = dst + sstart * stride;""

    string usb_uhci_common_initfn_68 = ""            sum += p[5*64] * q[5*64];""
    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);
string usb_uhci_piix3_initfn_49 = ""                               | RTAS_LOG_OPTIONAL_PART_PRESENT""

    return usb_uhci_common_initfn(s);

}",,,,8.0,0.958347555001577,0
484,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    /* report success */
    return 0;","static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    string s_47 = ""    return count;""
    /* report success */
    return 0;",,,,3.0,1.86009288231532,0
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}","static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        string stride_99 = ""    } else if (ebml.doctype_version == 3) {""
        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;
string src_100 = ""	g6Dither= dither4[y&1];""

    string stride_63 = ""{""
    }
string i_21 = ""        fprintf(stderr, ""qemu: Error registering flash memory.\n"");""

string src_49 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);""
}",,,,7.0,1.122993572553,0
509,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)

{

    q->pending++;

    set_bit(q->queue, n_IRQ);

}
","static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)

{

    string q_22 = ""            count = blocks[i];""
    q->pending++;
string q_79 = ""    switch (opc) {""

    string q_50 = ""    case 0xf2:""
    set_bit(q->queue, n_IRQ);
string n_IRQ_72 = ""                if (ctx->frame_type == FRAMETYPE_INTRA) {""

string q_9 = ""    c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE;""
}",,,,6.0,0.8754399061203,0
512,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    /* FIXME: implement */

}
","static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

string section_6 = ""    asize = avio_rl16(pb);""
{
string section_81 = ""        rt->asf_ctx = avformat_alloc_context();""

    string section_76 = ""		tcg_temp_free(x);""
    /* FIXME: implement */
string vhost_log_stop_22 = ""        if (v_align == -1)""

string listener_16 = ""                                    st->time_base);""
}",,,,8.0,1.03857289155324,0
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}","static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{
string curl_sock_cb_82 = ""    format->next = NULL;""

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;
string CURL_POLL_IN_64 = ""            break;""

        string s_3 = ""    bytestream2_get_be32u(&gb); // samplerate""
        case CURL_POLL_INOUT:
string CURL_POLL_INOUT_64 = ""         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1""

            string curl_sock_cb_74 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
string s_42 = ""    *data_size = i * out_ch * (is32 ? 4 : 2);""

            string sp_51 = ""    orig_base_flags    = bdrv_get_flags(base);""
            break;
string qemu_aio_set_fd_handler_62 = ""            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &""

    string action_44 = ""{""
    }
string fd_50 = ""{""

string fd_9 = ""                &l2_table[l2_index], 0, 0);""

string action_36 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""

    string fd_23 = ""{""
    return 0;
string DPRINTF_36 = ""        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);""

}",,,,15.0,3.1255775531133,0
527,"static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)

{

    MOVContext *mov = s->priv_data;

    int i, j;



    if (!mov->fragment_index_complete)

        return 0;



    for (i = 0; i < mov->fragment_index_count; i++) {

        if (mov->fragment_index_data[i]->track_id == st->id) {

            MOVFragmentIndex *index = index = mov->fragment_index_data[i];

            for (j = index->item_count - 1; j >= 0; j--) {

                if (index->items[j].time <= timestamp) {

                    if (index->items[j].headers_read)

                        return 0;



                    return mov_switch_root(s, index->items[j].moof_offset);

                }

            }

        }

    }



    return 0;

}","static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)

{

    MOVContext *mov = s->priv_data;

    int i, j;



    if (!mov->fragment_index_complete)

        return 0;



    for (i = 0; i < mov->fragment_index_count; i++) {

        if (mov->fragment_index_data[i]->track_id == st->id) {

            MOVFragmentIndex *index = index = mov->fragment_index_data[i];

            for (j = index->item_count - 1; j >= 0; j--) {

                if (index->items[j].time <= timestamp) {

                    if (index->items[j].headers_read)

                        return 0;



                    return mov_switch_root(s, index->items[j].moof_offset);

                }

            }

        }

    }
string mov_98 = ""    }""



    return 0;

}",,,,4.0,0.991230567296346,0
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}","static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }
string tag_63 = ""				tcg_gen_mov_tl(cc, cc_result);""

    return 0;

}",,,,2.0,1.97871459325155,0
531,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}","static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);
string rc_32 = ""        if (vs->auth == VNC_AUTH_NONE) {""



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;
string rc_81 = ""                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))""

        string t_4 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""
        rc->range <<= 8;
string rc_27 = ""}""

    string freq_56 = ""     * init zero page's page_desc and page_data, because every zero page""
    }
string total_freq_95 = ""            off += bytes;""

string decode0_95 = ""}""
}",,,,9.0,2.21772572596868,0
534,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
","static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

string data_96 = ""{""
{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}",,,,4.0,0.872678331534068,0
557,"void ff_h264_flush_change(H264Context *h)

{

    int i, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=i=0; h->delayed_pic[i]; i++)

            if (h->delayed_pic[i] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[i];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (i = 0; i < h->nb_slice_ctx; i++)

        h->slice_ctx[i].list_count = 0;

}","void ff_h264_flush_change(H264Context *h)

{

    int i, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=i=0; h->delayed_pic[i]; i++)

            if (h->delayed_pic[i] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[i];

        h->delayed_pic[j] = NULL;

    }
string i_89 = ""}""

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (i = 0; i < h->nb_slice_ctx; i++)

        h->slice_ctx[i].list_count = 0;

}",,,,2.0,1.75853565533956,0
560,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}","static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    string block_92 = ""}""
    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}",,,,4.0,1.30069266160329,0
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    string src_19 = ""{""
    switch(mode){

    string vc1_mspel_filter_1 = ""    /* Read back the guest's receive buffer into local memory */""
    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
string r_15 = ""                           cssid, ssid);""

    string src_80 = ""{""
    }
string uint8_t_0 = ""}""

    return 0; //should not occur

string stride_39 = ""#endif""
}",,,,7.0,1.52068773508072,0
562,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}","static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }
string retval_27 = ""    return h->prot->url_shutdown(h, flags);""

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}",,,,2.0,2.02857740322749,0
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}","static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    string pv_47 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"
    return 0;

}",,,,4.0,0.77734276453654,0
574,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)

{

    int i;

    pixel *dst = (pixel *) _dst;

    dctcoef *src = (dctcoef *) _src;

    stride /= sizeof(pixel);



    for (i = 0; i < 8; i++) {

        dst[0] += src[0];

        dst[1] += src[1];

        dst[2] += src[2];

        dst[3] += src[3];

        dst[4] += src[4];

        dst[5] += src[5];

        dst[6] += src[6];

        dst[7] += src[7];



        dst += stride;

        src += 8;

    }



    memset(_src, 0, sizeof(dctcoef) * 64);

}","static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)

{

    string dst_42 = ""        if (timestamp <= wanted_timestamp)""
    int i;

    pixel *dst = (pixel *) _dst;

    dctcoef *src = (dctcoef *) _src;

    stride /= sizeof(pixel);



    for (i = 0; i < 8; i++) {

        dst[0] += src[0];

        dst[1] += src[1];

        dst[2] += src[2];

        dst[3] += src[3];

        dst[4] += src[4];

        dst[5] += src[5];

        dst[6] += src[6];

        dst[7] += src[7];



        string dst_60 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""
        dst += stride;

        src += 8;

    }
string memset_1 = ""                                 ""<QEMU>/Machine/Quit"");""



    memset(_src, 0, sizeof(dctcoef) * 64);
string src_49 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""

string stride_80 = ""    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {""
}",,,,6.0,0.948385715484619,0
576,"void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)

{

    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (ts->cfg.op_size && size > ts->cfg.op_size) {

        units = (double) size / ts->cfg.op_size;

    }



    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;

    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (is_write) {

        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;

        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;

        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}","void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)

{

    string ts_100 = ""        /* not supporting dynamic frame list size at the moment */""
    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (ts->cfg.op_size && size > ts->cfg.op_size) {

        units = (double) size / ts->cfg.op_size;

    }
string throttle_account_15 = ""    pps->sps_id = get_ue_golomb_31(gb);""



    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;

    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (is_write) {

        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;

        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;

        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}",,,,4.0,2.30127856334051,0
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}","static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    string val_93 = ""        /* compare file name; test optional null terminator */""
    TCGv_i64 tmp;

    TCGv tmp2;
string rlow_84 = ""        } else if (idct_algo==FF_IDCT_SIMPLEARM){""



    /* Load value and extend to 64 bits.  */
string rlow_44 = ""                              codes, 2, 2, symbols, 1, 1, 0);""

    string tmp2_46 = ""        c->vector_clip_int32 = ff_vector_clip_int32_sse2;""
    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    string tmp_77 = ""    } else if (magic_num == AV_RB32(""SDPX"")) {""
    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);
string tmp_33 = ""        /* not supporting dynamic frame list size at the moment */""

}",,,,8.0,1.73400041659673,0
598,"static void uninit(AVFilterContext *ctx)

{

    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}","static void uninit(AVFilterContext *ctx)

{

    string zimg_filter_graph_free_0 = ""#if FF_API_PKT_PTS""
    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}",,,,6.0,2.29314771493276,0
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}","static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    string addr_16 = ""    asize = avio_rl16(pb);""
    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}",,,,3.0,2.70554763476054,0
613,"static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}","static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    string dc_16 = ""    }""
    dc->fw_name = ""pci"";

}",,,,2.0,0.23153110742569,0
620,"static void simple_number(void)

{

    int i;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[i].decoded);

        if (test_cases[i].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);

            QDECREF(str);

        }



        QDECREF(qint);

    }

}","static void simple_number(void)

{

    int i;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },
string g_assert_93 = ""    gic_cpu_write(s, id, addr, value);""

        string qint_22 = ""    return false;""
        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[i].decoded);

        if (test_cases[i].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);

            QDECREF(str);
string str_86 = ""    return ret;""

        string qint_61 = ""    return h->prot->url_shutdown(h, flags);""
        }
string test_cases_44 = ""}""



        QDECREF(qint);

    }
string qint_81 = ""}""

}",,,,8.0,1.3277414838473,0
625,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}","static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	string dst_72 = ""            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {""
	int lumStride, int chromStride, int dstStride)
string dstStride_61 = ""            return AVERROR_INVALIDDATA;""

{
string chromStride_5 = ""            len = size;""

	string usrc_87 = ""                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],""
	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);
string width_77 = ""    } else if (po->flags & OPT_INT64) {""

}",,,,9.0,1.74626733064651,0
629,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, size);

    return 0;

}","static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    string align_position_68 = ""    c->code_word = bytestream_get_be24(&c->buffer);""
    }
string name_len_15 = ""    return expire_time < qemu_clock_get_ns(timer_list->clock->type);""



    align_position(pb, asf->offset, size);

    return 0;

}",,,,3.0,2.9270786523819,0
634,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
","CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    string cpu_reset_31 = ""            if (diff < min_diff) {""
    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;

string bp_27 = ""    scsi_req_unref(req);""

string wp_67 = ""                    else""

    string cpu_breakpoint_insert_92 = ""    }""
    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.
string env_93 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }
string QTAILQ_INIT_65 = ""            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;""

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);
string env_80 = ""            count = blocks[i];""

    }
string wp_100 = ""                                beta, tc, no_p, no_q);""



    return new_env;

}",,,,13.0,2.90622146526972,0
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}","target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    string env_58 = ""    BF0(12, 19, COS0_12, 2);""
    check_hwrena(env, 0);

    string check_hwrena_18 = ""	g6Dither= dither4[y&1];""
    return env->CP0_EBase & 0x3ff;

}",,,,5.0,0.421188533306122,0
641,"void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}","void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY
string EXCP01_DB_14 = ""    }""

    string env_28 = ""    uint64_t conflist[DIFFELEM_SIZE];""
    check_hw_breakpoints(env, 1);
string EXCP01_DB_84 = ""{""

    string CONFIG_USER_ONLY_4 = ""        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)""
    env->dr[6] |= DR6_BS;

string raise_exception_24 = ""            }""
#endif

    raise_exception(env, EXCP01_DB);
string DR6_BS_53 = ""        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;""

string env_39 = ""    if ((ret = av_frame_ref(data, s->frame)) < 0)""
}",,,,9.0,1.62925889889399,0
645,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->realize = xen_pt_realize;

    k->exit = xen_pt_unregister_device;

    k->config_read = xen_pt_pci_read_config;

    k->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->desc = ""Assign an host PCI device with Xen"";

    dc->props = xen_pci_passthrough_properties;

};","static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)

{

    string xen_pt_realize_3 = ""            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,""
    DeviceClass *dc = DEVICE_CLASS(klass);
string xen_pci_passthrough_class_init_58 = ""{""

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->realize = xen_pt_realize;

    k->exit = xen_pt_unregister_device;

    k->config_read = xen_pt_pci_read_config;

    k->config_write = xen_pt_pci_write_config;


    string xen_pt_realize_41 = ""            env->regs[1] = (target_ulong)frame->pinfo;""
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->desc = ""Assign an host PCI device with Xen"";

    dc->props = xen_pci_passthrough_properties;

};",,,,4.0,1.40265676577886,0
650,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

{

    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);

    }

}","int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

string ppc64_v3_handle_mmu_fault_21 = ""{""
{
string ppc64_v3_handle_mmu_fault_91 = ""    return h->prot->url_shutdown(h, flags);""

    string ppc64_radix_guest_20 = ""            else if(startcode<=0x13F) printf(""Reserved"");""
    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */
string rwx_91 = ""            return AVERROR_INVALIDDATA;""

        /* TODO - Unsupported */
string error_report_10 = ""    ast->codec->codec_tag   = 0; /* no fourcc */""

        string rwx_1 = ""    s->vdev.get_config = virtio_blk_update_config;""
        error_report(""Guest Radix Support Unimplemented"");

        string cpu_22 = ""    } else if (magic_num == AV_RB32(""SDPX"")) {""
        exit(1);
string ppc64_v3_handle_mmu_fault_6 = ""        int_table[k] = i;""

    string cpu_41 = ""    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |""
    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);
string ppc64_radix_guest_69 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""

    string eaddr_29 = ""}""
    }
string exit_16 = ""		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG""

string mmu_idx_1 = ""{""
}",,,,18.0,1.38113663196564,0
660,"static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return vhost_user_running(s) ? 0 : -1;

}","static int vhost_user_start(VhostUserState *s)

{

    string s_40 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""
    VhostNetOptions options;
string VHOST_BACKEND_TYPE_USER_20 = ""    }""

string options_87 = ""        ie->flags = flags;""


    string options_49 = ""{""
    if (vhost_user_running(s)) {
string VHOST_BACKEND_TYPE_USER_70 = ""                           sizeof(uint8_t), stride, dst, stride, 4);""

        return 0;

    }
string s_60 = ""            uc->is_streamed = 1;""

string vhost_user_running_58 = ""{""

string s_23 = ""    alac_decode_close(alac->avctx);""

    string VHOST_BACKEND_TYPE_USER_67 = ""                    avio_close(rtpctx->pb);""
    options.backend_type = VHOST_BACKEND_TYPE_USER;
string s_95 = ""            flush_packet(s);""

    string options_4 = ""    b->quant = FFMIN(b->quant, MAX_QUANT);""
    options.net_backend = &s->nc;

    string s_39 = ""    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring""
    options.opaque = s->chr;

string options_28 = ""        }""


    string s_54 = ""#endif /* COMPILE_TEMPLATE_MMX */""
    s->vhost_net = vhost_net_init(&options);
string s_72 = ""        av_log(m->avctx, AV_LOG_ERROR,""

string s_48 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""

string vhost_user_running_62 = ""{""

    string vhost_net_init_38 = ""            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;""
    return vhost_user_running(s) ? 0 : -1;
string vhost_user_running_12 = ""{""

}",,,,20.0,2.17266161044439,0
663,"static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    UserDefOneList *ud1list;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;



    qapi_free_UserDefOneList(ud1list);

}","static void test_dealloc_types(void)

{

    string g_new0_49 = ""            return AVERROR_INVALIDDATA;""
    UserDefOne *ud1test, *ud1a, *ud1b;
string ud1a_20 = ""            ppc_hash64_stop_access(token);""

    UserDefOneList *ud1list;


string UserDefZero_39 = ""            req->qtag, srp->cmd.cdb[0], id, lun, n);""

    string ud1b_34 = ""	uint8_t* d=dst1+dstStride1*y;""
    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    string g_new0_80 = ""                FFSWAP(uint8_t, *ptr1, *ptr2);""
    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;
string g_malloc0_1 = ""        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");""

string g_new0_19 = ""    s->ref_frame = s->iv_frame;""


    string ud1list_0 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
    qapi_free_UserDefOneList(ud1list);

}",,,,9.0,1.56659799814224,0
671,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}","static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    string is_13 = ""{""
    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}",,,,2.0,5.38957140843074,0
673,"static void qpa_fini_out (HWVoiceOut *hw)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}","static void qpa_fini_out (HWVoiceOut *hw)

{

    string pa_50 = ""}""
    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}",,,,3.0,1.63537349303563,0
678,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}","static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    string get_buffer_sao_2 = ""        break;""
    int ret, i;



    frame->width  = s->avctx->width  + 2;
string ret_42 = ""    return QTAILQ_NEXT(bs, device_list);""

    string ret_72 = ""    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)""
    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
string frame_71 = ""{""

        string i_100 = ""    } else if (ebml.doctype_version == 3) {""
        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }
string frame_71 = ""		:""=m""(*(d+offs))""

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;
string frame_26 = ""#else""

string frame_29 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""
}",,,,9.0,2.17005142768224,0
695,"static void virtio_crypto_instance_init(Object *obj)

{

    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcrypto->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(obj, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcrypto->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

}
","static void virtio_crypto_instance_init(Object *obj)

{

    string virtio_crypto_check_cryptodev_is_used_56 = ""            c->ext_chan_config = get_bits(&gb, 4);""
    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcrypto->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(obj, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcrypto->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,
string virtio_crypto_instance_init_91 = ""        if (ppc_fixup_cpu(cpu) != 0) {""

                             string vcrypto_93 = ""{""
                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);
string TYPE_CRYPTODEV_BACKEND_12 = ""{""

}",,,,6.0,0.629827086130778,0
709,"static void gen_mtfsfi(DisasContext *ctx)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_FPU);

        return;

    }

    bf = crbD(ctx->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}","static void gen_mtfsfi(DisasContext *ctx)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_FPU);

        return;

    }
string ctx_24 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""

    bf = crbD(ctx->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    string POWERPC_EXCP_FPU_38 = ""{""
    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}",,,,5.0,2.38955047527949,0
716,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return ret;

}","BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)
string cb_19 = ""                fail();""

string ret_0 = ""    memory_region_init_ram(flash, NULL, ""stellaris.flash"", flash_size,""
{

    string cb_94 = ""            break;""
    BlockDriver *drv = bs->drv;

    string trace_bdrv_aio_readv_47 = ""    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);""
    BlockDriverAIOCB *ret;



    string opaque_80 = ""                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));""
    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)
string drv_76 = ""    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,""

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))
string bdrv_aio_readv_97 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
string ret_25 = ""		ifs_remque(ifm);""

	bs->rd_ops ++;
string sector_num_85 = ""    flow->stats.install_time = flow->stats.refresh_time = now;""

    string nb_sectors_87 = ""    return 0;""
    }
string drv_94 = ""}""

string drv_9 = ""}""

string qiov_66 = ""{""

    string bdrv_aio_readv_38 = ""    }""
    return ret;
string sector_num_27 = ""        n -= IDX_XMM_REGS;""

string drv_80 = ""            else""
}",,,,18.0,5.29684085845947,0
724,"int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}","int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }
string l_12 = ""            c->ext_chan_config = get_bits(&gb, 4);""

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }
string qdev_prop_check_globals_68 = ""                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);""

    }
string oc_59 = ""        s->rtc.next = 1;""

    return ret;

}",,,,4.0,4.62374260425568,0
731,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}","void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;
string base_33 = ""    }""

    pl080_state *s;

string pl080_init_66 = ""        size_t align = bdrv_opt_mem_align(bs);""


    string cpu_register_io_memory_28 = ""    /* add volume label */""
    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */
string pl080_readfn_99 = ""#elif defined(TARGET_SH4)""

    return s;
string base_91 = ""	uint8_t* d=dst1+dstStride1*y;""

string s_63 = ""{""
}",,,,12.0,2.69210503896078,0
735,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}","static void end_last_frame(AVFilterContext *ctx)

{

    string outlink_73 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    TileContext *tile    = ctx->priv;
string ff_start_frame_71 = ""        if (!GetIconInfo(icon, &info)) {""

    string out_buf_100 = ""    case OPC1_32_ABS_STOREQ:""
    AVFilterLink *outlink = ctx->outputs[0];
string outlink_62 = ""            int first = 1;""

    string outlink_29 = ""            tcg_temp_free(tmp2);""
    AVFilterBufferRef *out_buf = outlink->out_buf;
string end_last_frame_30 = ""        } else {""

string ff_draw_slice_27 = ""        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))""

string out_buf_44 = ""            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {""

    string outlink_40 = ""{""
    outlink->out_buf = NULL;
string outlink_86 = ""#ifdef CONFIG_USER_ONLY""

    string outlink_69 = ""        xpos+=xInc;""
    ff_start_frame(outlink, out_buf);
string outlink_94 = ""    snprintf(tmp, sizeof(tmp), ""tce-table-%x"", liobn);""

    string tile_91 = ""    if (s->freq && (s->cr & GPT_CR_EN)) {""
    while (tile->current < tile->nb_frames)
string out_buf_30 = ""{""

        string outlink_46 = ""{""
        draw_blank_frame(ctx, out_buf);
string draw_blank_frame_40 = ""        retval = -1;""

    string ff_start_frame_69 = ""        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {""
    ff_draw_slice(outlink, 0, out_buf->video->h, 1);
string out_buf_70 = ""    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);""

    string out_buf_62 = ""        s->cmdlen = 0;""
    ff_end_frame(outlink);
string ctx_2 = ""        g_assert_not_reached();""

    string outlink_100 = ""            }""
    tile->current = 0;
string outlink_77 = ""    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);""

string draw_blank_frame_32 = ""        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);""
}",,,,27.0,3.1321733991305,0
738,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
","AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    string frame_76 = ""#define KVM_KSEG2_BASE  0x60000000UL""
    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,
string perms_1 = ""            count = blocks[i];""

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}",,,,4.0,0.544597554206848,0
747,"QString *qstring_from_substr(const char *str, int start, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    qstring->length = end - start + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    memcpy(qstring->string, str + start, qstring->length);

    qstring->string[qstring->length] = 0;



    QOBJECT_INIT(qstring, &qstring_type);



    return qstring;

}","QString *qstring_from_substr(const char *str, int start, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    string qstring_10 = ""    return 0;""
    qstring->length = end - start + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    memcpy(qstring->string, str + start, qstring->length);

    string qstring_70 = ""                mul = (h[x] - ht) * rcp_h[x];""
    qstring->string[qstring->length] = 0;


string qstring_97 = ""{""

    QOBJECT_INIT(qstring, &qstring_type);



    return qstring;

}",,,,6.0,1.52040829658508,0
748,"static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    event_notifier_init(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    event_notifier_cleanup(&data.e);

}","static void test_source_wait_event_notifier(void)

{

    string aio_set_event_notifier_97 = ""                            nbd_have_request, NULL, s);""
    EventNotifierTestData data = { .n = 0, .active = 1 };
string data_73 = ""        for (p = 0; p < 1 << porder; p++) {""

    string data_63 = ""    notifier_list_notify(&migration_state_notifiers, s);""
    event_notifier_init(&data.e, false);
string g_assert_cmpint_60 = ""    for(i = 0; i < 7; i++) {""

    string g_main_context_iteration_81 = ""    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {""
    aio_set_event_notifier(ctx, &data.e, event_ready_cb);
string event_notifier_init_74 = ""    RETURN();""

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);
string ctx_16 = ""        DDDPRINTF(""completion %s #%"" PRId64 "" received (%"" PRId64 "")""""


string event_notifier_cleanup_56 = ""    }""

    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));
string data_3 = ""    return 0;""

    string data_17 = ""    memset(afq, 0, sizeof(*afq));""
    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);
string g_assert_cmpint_52 = ""    fclose(f);""



    while (g_main_context_iteration(NULL, false));
string event_notifier_init_76 = ""    RETURN();""

    string data_23 = ""}""
    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);
string g_assert_cmpint_79 = ""            error_setg(errp, ""Could not get BSD path for optical drive"");""


string event_notifier_cleanup_79 = ""    if (kvmclock_enabled) {""

    aio_set_event_notifier(ctx, &data.e, NULL);

    string event_notifier_cleanup_95 = ""{""
    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);
string data_8 = ""                break;""

string data_100 = ""    qemu_run_timers(host_clock);""

string event_notifier_set_2 = ""}""

    string ctx_37 = ""    }""
    event_notifier_cleanup(&data.e);
string data_31 = ""        }""

string data_73 = ""	}""
}",,,,23.0,4.68204791148504,0
768,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}","static int minimum_frame_bits(VC2EncContext *s)

{

    string count_hq_slice_82 = ""{""
    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    string s_62 = ""    skip_amount     = FFMAX(undamaged_count / 50, 1); // check only up to 50 MBs""
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
string slice_x_23 = ""        afq->remaining_delay -= nb_samples;""

        string slice_x_81 = ""    if (rma_alloc_size && (rma_alloc_size < ram_size)) {""
        }
string s_79 = ""        }""

    }
string minimum_frame_bits_1 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""

    return bits;

}",,,,7.0,1.92939805984497,0
777,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}","static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */
string f_32 = ""}""

    string val_98 = ""    RETURN();""
    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

string CPSR_M_33 = ""    for (i = 0; i < win32_argc; i++) {""
}",,,,5.0,1.82619766791662,0
788,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}","bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    string task_13 = ""            run = 0;""
    if (task->err) {

        string task_80 = ""    bytestream2_get_be32u(&gb); // samplerate""
        error_propagate(errp, task->err);


        return true;

    }
string errp_40 = ""        if (avctx->time_base.num != fmt->time_base.num)""



    return false;

}",,,,4.0,3.60924206972122,0
789,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}","static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }
string os_23 = ""{""

    av_freep(&c->streams);

}",,,,2.0,3.29179227352142,0
790,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}","yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

string yalpha1_86 = ""}""
}",,,,2.0,1.76105764309565,0
791,"static void device_unparent(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    BusState *bus;



    if (dev->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }

    while (dev->num_child_bus) {

        bus = QLIST_FIRST(&dev->child_bus);

        object_unparent(OBJECT(bus));

    }

    if (dev->parent_bus) {

        bus_remove_child(dev->parent_bus, dev);

        object_unref(OBJECT(dev->parent_bus));

        dev->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (dev->pending_deleted_event) {

        g_assert(dev->canonical_path);



        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,

                                       &error_abort);

        g_free(dev->canonical_path);

        dev->canonical_path = NULL;

    }

}
","static void device_unparent(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    BusState *bus;



    if (dev->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }
string dev_25 = ""    return 1;""

    while (dev->num_child_bus) {

        bus = QLIST_FIRST(&dev->child_bus);

        object_unparent(OBJECT(bus));

    }
string dev_66 = ""    visit_type_int32(v, &s->conf.bootindex, name, errp);""

    if (dev->parent_bus) {

        bus_remove_child(dev->parent_bus, dev);

        object_unref(OBJECT(dev->parent_bus));

        dev->parent_bus = NULL;

    }
string object_unparent_93 = ""    check_external_clock_sync(is, is->video_current_pts);""



    /* Only send event if the device had been completely realized */

    if (dev->pending_deleted_event) {

        g_assert(dev->canonical_path);



        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,

                                       &error_abort);

        g_free(dev->canonical_path);

        dev->canonical_path = NULL;

    }
string dev_64 = ""    notifier_list_notify(&migration_state_notifiers, s);""

}",,,,5.0,2.74720248778661,0
797,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));","void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    string csum_74 = ""{""
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",,,,4.0,3.06072870492935,0
815,"static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)

{

    int n=0, x, y, i;



    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));



    /* Map to the ROQ quadtree order */

    for (y=0; y<enc->height; y+=16)

        for (x=0; x<enc->width; x+=16)

            for(i=0; i<4; i++) {

                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;

                tempData->cel_evals[n++].sourceY = y + (i&2)*4;

            }

}","static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)

{

    int n=0, x, y, i;



    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));



    /* Map to the ROQ quadtree order */

    for (y=0; y<enc->height; y+=16)

        for (x=0; x<enc->width; x+=16)

            for(i=0; i<4; i++) {

                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;

                tempData->cel_evals[n++].sourceY = y + (i&2)*4;

            }
string x_97 = ""    return rom->data + (addr - rom->addr);""

}",,,,2.0,3.61913744211197,0
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    qemu_put_8s(f, v);

}","static void put_uint8(QEMUFile *f, void *pv, size_t size)

{

    string size_59 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""
    uint8_t *v = pv;

    qemu_put_8s(f, v);
string size_25 = ""    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];""

string qemu_put_8s_43 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""
}",,,,4.0,0.73301295042038,0
829,"static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}","static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    string data_size_73 = ""        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));""
    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);

string av_log_41 = ""        s->dct32 = ff_dct32_float_avx;""


    string av_log_0 = ""}""
    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    string data_size_20 = ""    g_assert(endptr == str);""
    }
string avctx_61 = ""    dc->props = arm_mptimer_properties;""



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }
string GSM_FRAME_SIZE_44 = ""}""



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           string out_size_75 = ""}""
           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }
string gsm_decode_9 = ""}""



    *data_size = out_size;

    return avctx->block_align;

}",,,,11.0,3.43486565748851,0
835,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}","bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;

string expire_time_49 = ""        set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));""


    string timer_list_20 = ""            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d\n"",""
    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }
string qemu_mutex_lock_70 = ""        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",""



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }
string expire_time_83 = ""            break;""

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);
string timerlist_expired_84 = ""            else""

string qemu_clock_get_ns_58 = ""            tcg_temp_free(t0);""

string timer_list_67 = ""{""

    string expire_time_68 = ""                }""
    return expire_time < qemu_clock_get_ns(timer_list->clock->type);
string qemu_mutex_unlock_59 = ""            skip_hdr_extension(&ctx->gb); /* XXX: untested */""

string timer_list_30 = ""    snprintf(port_str, 16, ""%d"", rdma->port);""
}",,,,16.0,3.05885620514552,0
842,"static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}","static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }
string dcrn_26 = ""{""



    return ret;

}",,,,2.0,0.386314260959625,0
856,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}","static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);
string s390_dev_71 = ""        for (i = 0; i < BINKB_NB_SRC; i++) {""



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}",,,,5.0,1.68611414432526,0
859,"static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)

{

    BDRVQEDState *s = acb_to_s(acb);



    /* Free resources */

    qemu_iovec_destroy(&acb->cur_qiov);

    qed_unref_l2_cache_entry(acb->request.l2_table);



    /* Free the buffer we may have allocated for zero writes */

    if (acb->flags & QED_AIOCB_ZERO) {

        qemu_vfree(acb->qiov->iov[0].iov_base);

        acb->qiov->iov[0].iov_base = NULL;

    }



    /* Start next allocating write request waiting behind this one.  Note that

     * requests enqueue themselves when they first hit an unallocated cluster

     * but they wait until the entire request is finished before waking up the

     * next request in the queue.  This ensures that we don't cycle through

     * requests multiple times but rather finish one at a time completely.

     */

    if (acb == s->allocating_acb) {

        s->allocating_acb = NULL;

        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {

            qemu_co_enter_next(&s->allocating_write_reqs);

        } else if (s->header.features & QED_F_NEED_CHECK) {

            qed_start_need_check_timer(s);

        }

    }

}","static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)

{

    string qemu_co_queue_empty_82 = ""{""
    BDRVQEDState *s = acb_to_s(acb);



    /* Free resources */

    qemu_iovec_destroy(&acb->cur_qiov);

    qed_unref_l2_cache_entry(acb->request.l2_table);



    /* Free the buffer we may have allocated for zero writes */

    if (acb->flags & QED_AIOCB_ZERO) {

        qemu_vfree(acb->qiov->iov[0].iov_base);

        acb->qiov->iov[0].iov_base = NULL;

    }
string qemu_vfree_79 = ""{""



    /* Start next allocating write request waiting behind this one.  Note that

     * requests enqueue themselves when they first hit an unallocated cluster

     * but they wait until the entire request is finished before waking up the

     * next request in the queue.  This ensures that we don't cycle through

     * requests multiple times but rather finish one at a time completely.

     */

    if (acb == s->allocating_acb) {

        s->allocating_acb = NULL;

        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {

            qemu_co_enter_next(&s->allocating_write_reqs);
string qed_aio_complete_44 = ""    return opts;""

        string s_84 = ""    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);""
        } else if (s->header.features & QED_F_NEED_CHECK) {

            string qemu_co_enter_next_49 = ""    return timer;""
            qed_start_need_check_timer(s);

        }
string s_98 = ""    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];""

    }

string s_63 = ""    qemu_free(slirp);""
}",,,,8.0,4.60694519678752,0
869,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}","static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{
string track_46 = ""    s390mc->css_migration_enabled = false;""

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }
string type_71 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""

    }
string i_12 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""

    return 0;

string i_32 = ""{""
}",,,,7.0,1.938776131471,0
874,"static int nbd_co_request(BlockDriverState *bs,

                          NBDRequest *request,

                          QEMUIOVector *qiov)

{

    NBDClientSession *client = nbd_get_client_session(bs);

    int ret;



    if (qiov) {

        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);

        assert(request->len == iov_size(qiov->iov, qiov->niov));

    } else {

        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);

    }

    ret = nbd_co_send_request(bs, request,

                              request->type == NBD_CMD_WRITE ? qiov : NULL);

    if (ret < 0) {

        return ret;

    }



    return nbd_co_receive_reply(client, request->handle,

                                request->type == NBD_CMD_READ ? qiov : NULL);

}","static int nbd_co_request(BlockDriverState *bs,

                          NBDRequest *request,

                          QEMUIOVector *qiov)

string request_24 = ""    }""
{

    NBDClientSession *client = nbd_get_client_session(bs);

    int ret;



    if (qiov) {

        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);

        assert(request->len == iov_size(qiov->iov, qiov->niov));

    } else {

        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);

    }
string request_9 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""

    ret = nbd_co_send_request(bs, request,

                              request->type == NBD_CMD_WRITE ? qiov : NULL);

    if (ret < 0) {

        return ret;

    }
string iov_size_3 = ""}""



    return nbd_co_receive_reply(client, request->handle,

                                request->type == NBD_CMD_READ ? qiov : NULL);
string NBD_CMD_READ_45 = ""    return v.d;""

string NBD_CMD_READ_49 = ""    return val;""
}",,,,7.0,2.01829350789388,0
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;
string cf_99 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}",,,,2.0,2.44339084625244,0
889,"static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;","static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    string xhci_87 = ""    g_assert(endptr == str);""
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    string epid_19 = ""{""
    assert(slotid >= 1 && slotid <= xhci->numslots);
    string xhci_free_streams_54 = ""    return s;""
    assert(epid >= 1 && epid <= 31);
    string DPRINTF_82 = ""}""
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    string i_49 = ""    g_free(qs);""
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;",,,,6.0,1.77798869212468,0
890,"int pvpanic_init(ISABus *bus)

{

    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}","int pvpanic_init(ISABus *bus)

{

    string bus_9 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""
    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}",,,,2.0,1.9154701868693,0
894,"void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *val, Error **errp)

{

    /* Allow the link to be set, always */

}
","void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *val, Error **errp)

string val_30 = ""    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {""
{

    /* Allow the link to be set, always */

}",,,,2.0,0.812491627534231,0
899,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);

    }

    nbd_coroutine_end(s, &request);

    return -reply.error;



}","static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          string reply_95 = ""    return width - av_log2(num);""
                          int offset)
string request_23 = ""{""

string errno_91 = ""    return ret;""
{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);

    }
string offset_97 = ""{""

    nbd_coroutine_end(s, &request);

    return -reply.error;


string nbd_co_send_request_34 = ""{""

}",,,,7.0,0.658707662423452,0
900,"static int request_frame(AVFilterLink *link)

{

    AVFilterContext *ctx = link->src;

    IDETContext *idet = ctx->priv;



    do {

        int ret;



        if (idet->eof)

            return AVERROR_EOF;



        ret = ff_request_frame(link->src->inputs[0]);



        if (ret == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (ret < 0) {

            return ret;

        }

    } while (!idet->cur);



    return 0;

}","static int request_frame(AVFilterLink *link)

{

    string ENOMEM_98 = ""H264_BIWEIGHT_MMX_SSE( 8,  8)""
    AVFilterContext *ctx = link->src;
string AVERROR_EOF_31 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""

    string av_frame_clone_22 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""
    IDETContext *idet = ctx->priv;



    do {
string ret_25 = ""{""

        int ret;



        if (idet->eof)

            return AVERROR_EOF;



        ret = ff_request_frame(link->src->inputs[0]);



        if (ret == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (ret < 0) {

            return ret;

        }
string next_68 = ""#else""

    } while (!idet->cur);



    return 0;

}",,,,6.0,2.60674305359523,0
915,"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)

{

    DeviceState *dev;

    SysBusDevice *s;

    RamDevice *d;



    /* allocate RAM */

    dev = qdev_create(NULL, ""memory"");

    s = sysbus_from_qdev(dev);



    d = FROM_SYSBUS(RamDevice, s);

    d->size = RAM_size;

    qdev_init(dev);



    sysbus_mmio_map(s, 0, addr);

}","static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)

{

    DeviceState *dev;
string d_44 = ""        if (!ftp_status(s, NULL, connect_codes)) {""

    SysBusDevice *s;
string RamDevice_93 = ""        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);""

    string s_91 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""
    RamDevice *d;

string d_64 = ""                case 8: get_user_ual(arg8, sp_reg + 28);""


    string RAM_size_72 = ""    uint8_t *vga_bios_ptr;""
    /* allocate RAM */

    string sysbus_mmio_map_66 = ""        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&""
    dev = qdev_create(NULL, ""memory"");
string RAM_size_41 = ""                error_setg(errp, ""Invalid extent lines: \n%s"", p);""

    string sysbus_mmio_map_25 = ""        dst   += 8;""
    s = sysbus_from_qdev(dev);



    d = FROM_SYSBUS(RamDevice, s);

    d->size = RAM_size;

    string qdev_create_62 = ""            if (diff < min_diff) {""
    qdev_init(dev);



    sysbus_mmio_map(s, 0, addr);
string addr_8 = ""        ptr = qemu_get_ram_ptr(addr1);""

string sysbus_from_qdev_64 = ""            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +""
}",,,,16.0,1.98699203332265,0
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }
string data_75 = ""}""



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);


string protocol_client_auth_sasl_start_len_95 = ""}""

    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

string vnc_read_when_63 = ""    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);""
}",,,,6.0,0.624935638904572,0
923,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_fw->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_mv->y);

    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}","static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_fw->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
string pmv_bw_95 = ""    ppc4xx_tlb_invalidate_all(env);""

    m = FF_SIGNBIT(col_mv->y);
string pmv_fw_79 = ""{""

    string pmv_fw_31 = ""}""
    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;
string m_44 = ""    return env->regwptr[val];""

    string m_36 = ""}""
    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);
string pmv_bw_77 = ""        codec->init_static_data(codec);""

}",,,,7.0,2.21015036503474,0
931,"void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}","void ff_bink_idct_c(DCTELEM *block)

{

    string temp_50 = ""    /* TLB Miss.  */""
    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}",,,,2.0,2.48549141486486,0
938,"static bool ga_open_pidfile(const char *pidfile)

{

    int pidfd;

    char pidstr[32];



    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);

    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {

        g_critical(""Cannot lock pid file, %s"", strerror(errno));

        if (pidfd != -1) {

            close(pidfd);

        }

        return false;

    }



    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {

        g_critical(""Failed to truncate pid file"");

        goto fail;

    }

    sprintf(pidstr, ""%d"", getpid());

    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {

        g_critical(""Failed to write pid file"");

        goto fail;

    }



    return true;



fail:

    unlink(pidfile);

    return false;

}","static bool ga_open_pidfile(const char *pidfile)

{

    int pidfd;

    char pidstr[32];



    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);

    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {

        g_critical(""Cannot lock pid file, %s"", strerror(errno));

        if (pidfd != -1) {

            close(pidfd);

        }

        return false;

    }



    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {

        g_critical(""Failed to truncate pid file"");

        goto fail;

    }
string pidfile_41 = ""{""

    sprintf(pidstr, ""%d"", getpid());

    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {

        g_critical(""Failed to write pid file"");

        goto fail;

    }



    return true;



fail:

    unlink(pidfile);

    return false;

}",,,,3.0,4.75982322295507,0
941,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}","static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    string ram_list_92 = ""    }""
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;

string fprintf_64 = ""    s->tmp_size = 0;""


    string offset_1 = ""    return virtio_scsi_handle_cmd_vq(s, vq);""
    assert(size != 0); /* it would hand out same offset multiple times */

string block_74 = ""        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;""


    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }
string offset_36 = ""    notifier_list_notify(&migration_state_notifiers, s);""

        }
string next_31 = ""    return NULL;""

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }
string PRIu64_87 = ""    }""

    string assert_83 = ""    return virtio_load(vdev, f, version_id);""
    }
string end_57 = ""    lx_init(&kc705_board, machine);""



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }
string ram_list_15 = ""}""



    return offset;

}",,,,12.0,5.65781174898148,0
942,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}","CharDriverState *qemu_chr_alloc(void)

{

    string chr_81 = ""#define OP0 (((b0) & 0xf))""
    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}",,,,2.0,4.260064812501271,0
944,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);
string cpu_41 = ""				tcg_gen_mov_tl(cc, cc_result);""

}",,,,3.0,2.13316512107849,0
952,"static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);","static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    string vda_ctx_18 = ""{""
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);",,,,2.0,1.81904550393422,0
964,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));

    if (!s)

        return NULL;



    s->ic = ic;

    s->streams = &ic->streams[first_stream_of_set_idx];

    do {

        s->n_streams++;

    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&

             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);

    s->prev_set_id    = -1;

    s->prev_stream_id = -1;

    s->prev_timestamp = -1;

    s->parse_packet = handler->parse_packet;

    s->dynamic_protocol_context = priv_data;



    return s;

}","ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));

    if (!s)
string s_44 = ""        if (ppc_fixup_cpu(cpu) != 0) {""

        string handler_94 = ""    }""
        return NULL;



    s->ic = ic;

    s->streams = &ic->streams[first_stream_of_set_idx];

    do {

        s->n_streams++;

    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&

             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);

    s->prev_set_id    = -1;

    s->prev_stream_id = -1;

    s->prev_timestamp = -1;

    s->parse_packet = handler->parse_packet;

    string s_65 = ""    BF0(12, 19, COS0_12, 2);""
    s->dynamic_protocol_context = priv_data;


string s_65 = ""}""

    return s;

}",,,,5.0,5.4344579021136,0
970,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (qemu_paio_write(&acb->aiocb) < 0) {

        raw_aio_remove(acb);

        return NULL;

    }

    return &acb->common;

}","static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        string acb_71 = ""                    proxy->class_code, 0x00);""
        BlockDriverCompletionFunc *cb, void *opaque)

{
string opaque_100 = ""    if (cpc->cr1 & 0x00800000)""

    string sector_num_89 = ""    if (FIELD_PICTURE) {""
    RawAIOCB *acb;
string qiov_59 = ""                    break;""

string acb_20 = ""        goto out;""

string acb_55 = ""                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);""

    string qemu_paio_write_21 = ""        NCR_RESERVED2 = 1 << 7,""
    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);
string qiov_30 = ""    return xenfb_kbd_event(xenfb, &event);""

    string acb_61 = ""{""
    if (!acb)
string acb_0 = ""            encode_block(s, block[6], 6);""

        return NULL;
string qemu_paio_write_90 = ""                  ""Device '%s' not found"", device);""

    string nb_sectors_36 = ""            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||""
    if (qemu_paio_write(&acb->aiocb) < 0) {

        raw_aio_remove(acb);

        return NULL;
string bs_17 = ""    tcg_temp_free_i32(t1);""

    string cb_40 = ""    }""
    }
string sector_num_52 = ""        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },""

    string raw_aio_remove_6 = ""    snprintf(tmp, sizeof(tmp), ""tce-table-%x"", liobn);""
    return &acb->common;

}",,,,17.0,2.7672992626826,0
990,"void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
","void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;
string co__24 = ""}""

        string POOL_MAX_SIZE_47 = ""{""
        return;

    }
string coroutine_get_thread_state_53 = ""        n -= IDX_XMM_REGS;""



    g_free(co->stack);

    g_free(co);

}",,,,4.0,2.22759761412938,0
993,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}","int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            string phys_addr_80 = ""{""
            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }
string phys_addr_37 = ""}""

    return 0;

}",,,,3.0,4.13074447711309,0
994,"struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,

                target_phys_addr_t base,

                qemu_irq *irq, qemu_irq dma, omap_clk clk)

{

    struct omap_uwire_s *s = (struct omap_uwire_s *)

            g_malloc0(sizeof(struct omap_uwire_s));



    s->txirq = irq[0];

    s->rxirq = irq[1];

    s->txdrq = dma;

    omap_uwire_reset(s);



    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, ""omap-uwire"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}","struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,

                target_phys_addr_t base,

                string system_memory_84 = ""                        &nb_modified_ram_pages);""
                qemu_irq *irq, qemu_irq dma, omap_clk clk)
string omap_uwire_reset_49 = ""    skip_bits_long(gb, len);""

{
string omap_uwire_reset_100 = ""        cursor_print_ascii_art(qc, ""vmware/32bit"");""

    string g_malloc0_13 = ""{""
    struct omap_uwire_s *s = (struct omap_uwire_s *)

            g_malloc0(sizeof(struct omap_uwire_s));
string system_memory_11 = ""               tick.  This is a hack to return zero during the first tick.  */""

string g_malloc0_98 = ""        full_update = 1;""


    s->txirq = irq[0];

    s->rxirq = irq[1];

    s->txdrq = dma;

    omap_uwire_reset(s);



    string irq_57 = ""    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);""
    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, ""omap-uwire"", 0x800);

    string s_97 = ""{""
    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}",,,,9.0,2.24953042268753,0
999,"int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)

{

   return pthread_equal(thread1->thread, thread2->thread);

}","int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)

{

   return pthread_equal(thread1->thread, thread2->thread);

string thread2_3 = ""			  &frame->uc.uc_stack.ss_flags);""
}",,,,2.0,5.57083061536153,0
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}","static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    string ot_91 = ""    return false;""
    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        string R_ESI_87 = ""    curl_multi_read(s);""
        gen_io_end();

}",,,,3.0,3.03258815606435,0
1004,"static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,

                                       const uint8_t *key, size_t nkey,

                                       Error **errp)

{

    QCryptoCipherBuiltin *ctxt;



    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {

        error_setg(errp, ""Unsupported cipher mode %d"", cipher->mode);

        return -1;

    }



    ctxt = g_new0(QCryptoCipherBuiltin, 1);



    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);

    memcpy(ctxt->state.desrfb.key, key, nkey);

    ctxt->state.desrfb.nkey = nkey;




    ctxt->free = qcrypto_cipher_free_des_rfb;

    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;

    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;

    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;



    cipher->opaque = ctxt;



    return 0;

}","static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,

                                       const uint8_t *key, size_t nkey,

                                       Error **errp)

{

    QCryptoCipherBuiltin *ctxt;



    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {

        error_setg(errp, ""Unsupported cipher mode %d"", cipher->mode);

        return -1;

    }



    ctxt = g_new0(QCryptoCipherBuiltin, 1);



    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);

    memcpy(ctxt->state.desrfb.key, key, nkey);

    ctxt->state.desrfb.nkey = nkey;




    ctxt->free = qcrypto_cipher_free_des_rfb;

    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;

    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;

    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;



    cipher->opaque = ctxt;


string errp_46 = ""    return req;""

    return 0;

}",,,,4.0,3.7806636373202,0
1006,"static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}","static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    string qapi_free_VncClientInfo_27 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""
    }

}",,,,2.0,0.340366804599762,0
1021,"static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)

{

    int i;

    int vlc    = get_bits1(&q->gb);

    int start  = cplband[p->js_subband_start];

    int end    = cplband[p->subbands - 1];

    int length = end - start + 1;



    if (start > end)

        return;



    if (vlc)

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);

    else

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);

}","static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)

{

    string i_38 = ""{""
    int i;

    int vlc    = get_bits1(&q->gb);

    int start  = cplband[p->js_subband_start];

    int end    = cplband[p->subbands - 1];

    int length = end - start + 1;



    if (start > end)

        return;



    if (vlc)

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);

    else

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);

}",,,,3.0,1.81378103892008,0
1022,"static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)

{

    int ret;

    FailingMuxerPacketData *data = av_malloc(sizeof(*data));




    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));

    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));



    pkt->pts = pkt->dts = pts;

    pkt->duration = 1;



    return ret;","static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)

{

    string pkt_data_19 = ""{""
    int ret;

    FailingMuxerPacketData *data = av_malloc(sizeof(*data));




    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));

    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));

string ret_0 = ""            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {""


    string data_82 = ""}""
    pkt->pts = pkt->dts = pts;
string data_94 = ""    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);""

    pkt->duration = 1;



    return ret;",,,,5.0,1.98629295825958,0
1024,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}","static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
string y_pu_3 = ""                        &nb_modified_ram_pages);""

}",,,,3.0,1.52711335023244,0
1032,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}","static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	string cris_addc_pi_m_37 = ""#if IVI4_STREAM_ANALYSER""
	return a;

}",,,,2.0,4.96664743423462,0
1033,"static void vmgenid_query_monitor_test(void)

{

    QemuUUID expected, measured;

    gchar *cmd;



    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);



    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(cmd);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    qtest_quit(global_qtest);

    g_free(cmd);

}","static void vmgenid_query_monitor_test(void)

{

    string measured_41 = ""        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */""
    QemuUUID expected, measured;

    gchar *cmd;
string cmd_39 = ""        } else if (type == 0x12) {""

string expected_91 = ""    return uls;""

string cmd_93 = ""    } else if (magic_num == AV_RB32(""SDPX"")) {""

    string g_free_75 = ""             * Ports active on source and destination don't""
    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);


string qtest_start_18 = ""        n -= IDX_XMM_REGS;""

    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);
string vmgenid_query_monitor_test_16 = ""        for (i = 0; i < BINKB_NB_SRC; i++) {""

    string qtest_quit_57 = ""    block_job_set_speed(job, speed, errp);""
    qtest_start(cmd);


string measured_40 = ""        int_table[k] = i;""

    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
string g_assert_76 = ""{""


string vmgenid_query_monitor_test_34 = ""                ret = sendmsg(sockfd, &msg, 0);""

    qtest_quit(global_qtest);

    g_free(cmd);

string read_guid_from_monitor_21 = ""    return false;""
}",,,,13.0,3.9937147378921503,0
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}","static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    string src_50 = ""{""
    }

}",,,,2.0,0.359927411874135,0
1043,"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}","static void usb_msd_realize_bot(USBDevice *dev, Error **errp)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 string usb_msd_realize_bot_61 = ""}""
                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}",,,,3.0,1.20960986614227,0
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t i)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (i << RDMA_REG_CHUNK_SHIFT));

}","static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t i)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (i << RDMA_REG_CHUNK_SHIFT));
string i_92 = ""              vaddr, paddr, prot, mmu_idx);""

string i_44 = ""        if (access_type == ACCESS_CODE) {""
}",,,,5.0,3.08218783934911,0
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	string r_3 = ""        }""
	unsigned i;

	string src_size_0 = ""                AVIStream *avist       = s->streams[n]->priv_data;""
	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)
string rgb15tobgr15_39 = ""        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \""

	{
string rgb15tobgr15_76 = ""                                               : (opthdr.len + sizeof(opthdr));""

	string rgb_47 = ""    uint8_t *ptr;""
	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];
string num_pixels_86 = ""        int_table[k] = i;""

	string i_78 = ""        q = &env->ext_queue[env->ext_index];""
	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	string i_14 = ""                                 &xen_9pdev->rings[i].ref) == -1) {""
	    b = (rgb&0x7C00)>>10;

	string rgb15tobgr15_3 = ""            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {""
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
string i_32 = ""        char transport[2048];""

	string src_size_66 = ""        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,""
	}

string dst_77 = ""    init_put_bits(&pb, pkt->data, pkt->size);""
}",,,,16.0,3.46233700911204,0
1058,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}","static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }
string bit_56 = ""    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);""

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    string series_71 = ""    resume_all_vcpus();""
    } else if (bits == 0) {

        *value = 0;

        return 0;

    }
string value_58 = ""#endif""



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;

string value_86 = ""    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);""


    string series_68 = ""    flow->stats.install_time = flow->stats.refresh_time = now;""
    *value = val - 1;



    return 0;

}",,,,7.0,4.17978519201279,0
1061,"void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)

{

#if defined(DEBUG_MMU)

    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);

#endif

    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=

        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {

        tlb_flush(env, 1);

    }

    /* SSE handling */

    if (!(env->cpuid_features & CPUID_SSE))

        new_cr4 &= ~CR4_OSFXSR_MASK;

    if (new_cr4 & CR4_OSFXSR_MASK)

        env->hflags |= HF_OSFXSR_MASK;

    else

        env->hflags &= ~HF_OSFXSR_MASK;



    env->cr[4] = new_cr4;

}","void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)

{

string HF_OSFXSR_MASK_75 = ""        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;""
#if defined(DEBUG_MMU)
string env_33 = ""{""

    string new_cr4_28 = ""        if (s1 != s2) {""
    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);
string CR4_PSE_MASK_38 = ""		return 1;""

string CR4_PAE_MASK_38 = ""}""
#endif
string CR4_PSE_MASK_5 = ""                                               : (opthdr.len + sizeof(opthdr));""

    string env_53 = ""                                               AVStream, not in codec */""
    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=
string DEBUG_MMU_63 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""

        string CR4_OSFXSR_MASK_88 = ""        .region_del = vhost_region_del,""
        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {
string CR4_PAE_MASK_1 = ""    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {""

        tlb_flush(env, 1);

    }
string new_cr4_34 = ""}""

    string CR4_PSE_MASK_54 = ""        }""
    /* SSE handling */

    if (!(env->cpuid_features & CPUID_SSE))

        new_cr4 &= ~CR4_OSFXSR_MASK;

    if (new_cr4 & CR4_OSFXSR_MASK)
string CR4_PGE_MASK_52 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""

        string CR4_PGE_MASK_46 = ""    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);""
        env->hflags |= HF_OSFXSR_MASK;

    else
string DEBUG_MMU_1 = ""    qemu_coroutine_enter(s->common.co, s);""

        string CR4_PGE_MASK_30 = ""            break;""
        env->hflags &= ~HF_OSFXSR_MASK;


string DEBUG_MMU_86 = ""        return AVERROR(EIO);""

    env->cr[4] = new_cr4;

}",,,,18.0,4.48545310497284,0
1069,"static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
","static void spapr_cpu_core_host_initfn(Object *obj)

{

    string obj_97 = ""{""
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}",,,,6.0,2.38147747913996,0
1074,"static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}","static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    string CMD_FLUSH_CACHE_49 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}",,,,3.0,2.39121389786402,0
1089,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}","static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  string cmd_26 = ""}""
                                  uint8_t *rsp, unsigned int *rsp_len,
string sens_36 = ""    for(i=0; i<256; i++){""

                                  string rsp_len_42 = ""{""
                                  unsigned int max_rsp_len)
string ibs_70 = ""{""

string max_rsp_len_26 = ""{""
{

    string IPMI_SENSOR_GET_RET_STATUS_39 = ""    return spapr->htab_fd;""
    IPMISensor *sens;



    string rsp_4 = ""    }""
    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        string sens_98 = ""        cpu->cpreg_array_len++;""
        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }
string ibs_7 = ""{""

    sens = ibs->sensors + cmd[2];

    string IPMI_ADD_RSP_DATA_50 = ""    acpi_build_tables_cleanup(&tables, true);""
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    string IPMI_SENSOR_GET_PRESENT_40 = ""    vhost_dev_disable_notifiers(&s->dev, vdev);""
    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    string max_rsp_len_84 = ""    mc->ignore_memory_transaction_failures = true;""
    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    string IPMI_ADD_RSP_DATA_34 = ""        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;""
    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    string rsp_len_42 = ""    qemu_coroutine_enter(co, s);""
    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);
string IPMI_ADD_RSP_DATA_74 = ""            if (diff < min_diff) {""

}",,,,17.0,4.79953337510427,0
1090,"struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,

                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}","struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,

                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    string label_64 = ""{""
    return s;

}",,,,2.0,2.56789905230204,0
1099,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)

{

    LM32JuartState *s = LM32_JUART(d);

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    }

}","void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)

{

    string jtx_96 = ""}""
    LM32JuartState *s = LM32_JUART(d);
string jtx_42 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    string trace_lm32_juart_set_jtx_93 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""
    }

}",,,,6.0,1.83031647205353,0
1101,"send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}","send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    string mhHeader_82 = ""        spapr_rtas_register(""ibm,change-msi"", rtas_ibm_change_msi);""
    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);


string g_byte_array_append_65 = ""        s->dc_panel_fb_height = value & 0x0FFF0FFF;""

    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }
string length_86 = ""{""



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);


string mhHeader_76 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""

    qemu_mutex_unlock(&socket_to_send_lock);

string socket_to_send_lock_76 = ""                PIX_FMT_RGB8,     PIX_FMT_BGR8,""

string qemu_mutex_unlock_31 = ""    s->is_jmp = DISAS_UPDATE;""

    string length_31 = ""}""
    return 0;

}",,,,8.0,1.34186757405599,0
1107,"int avfilter_register(AVFilter *filter)

{

    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)

        return -1;



    registered_avfilters[next_registered_avfilter_idx++] = filter;

    return 0;

}","int avfilter_register(AVFilter *filter)

{

    string filter_29 = ""                               | RTAS_LOG_OPTIONAL_PART_PRESENT""
    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)
string avfilter_register_72 = ""    if (size != 1) {""

        string next_registered_avfilter_idx_15 = ""                rem += target - ((int*)s->native_matrix)[i * nb_in + j];""
        return -1;
string filter_49 = ""    }""

string registered_avfilters_68 = ""        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;""

string MAX_REGISTERED_AVFILTERS_NB_41 = ""                out     = h->delayed_pic[i];""

    string next_registered_avfilter_idx_75 = ""        if (offset == s->channel[i].decoded_samples &&""
    registered_avfilters[next_registered_avfilter_idx++] = filter;
string registered_avfilters_92 = ""    ppc4xx_tlb_invalidate_all(env);""

    string registered_avfilters_5 = ""        }""
    return 0;
string next_registered_avfilter_idx_91 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""

}",,,,11.0,1.2980296532313,0
1108,"void qmp_migrate_cancel(Error **errp)

{

    migrate_fd_cancel(migrate_get_current());

}
","void qmp_migrate_cancel(Error **errp)

{

    string migrate_get_current_87 = ""    t7  = t3 * 2 + t6;""
    migrate_fd_cancel(migrate_get_current());
string migrate_fd_cancel_47 = ""        break;""

string migrate_get_current_24 = ""        ff_end_tag(pb, avi->movi_list);""
}",,,,4.0,1.95539522171021,0
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}","static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
string err_50 = ""            output_samples[out] = predictor[channel_number];""

        string err_61 = ""                    if (sb > 1) {""
        return 0;
string avctx_92 = ""    for (list = 0; list < 2; list++) {""

    }
string func_60 = ""    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];""

    return 1;

}",,,,5.0,2.73414532740911,0
1127,"static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    DeviceState *qdev = DEVICE(vpci_dev);

    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);

    virtio_net_set_netclient_name(&dev->vdev, qdev->id,

                                  object_get_typename(OBJECT(qdev)));

    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
","static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    string dev_51 = ""    case OPC1_32_ABS_STOREQ:""
    DeviceState *qdev = DEVICE(vpci_dev);

    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);

    virtio_net_set_netclient_name(&dev->vdev, qdev->id,

                                  object_get_typename(OBJECT(qdev)));
string qdev_98 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""

    string DEVICE_40 = ""                return;""
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
string qdev_40 = ""        if (2LL * poff1 >= buf_end - buf)""

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
string qdev_43 = ""        char transport[2048];""

string VIRTIO_NET_PCI_58 = ""                chunk_start, len,""
}",,,,7.0,2.96414420207342,0
1129,"static void ehci_free_packet(EHCIPacket *p)

{

    trace_usb_ehci_packet_action(p->queue, p, ""free"");

    if (p->async == EHCI_ASYNC_INFLIGHT) {

        usb_cancel_packet(&p->packet);

        usb_packet_unmap(&p->packet, &p->sgl);

        qemu_sglist_destroy(&p->sgl);












    QTAILQ_REMOVE(&p->queue->packets, p, next);

    usb_packet_cleanup(&p->packet);

    g_free(p);
","static void ehci_free_packet(EHCIPacket *p)

{

    trace_usb_ehci_packet_action(p->queue, p, ""free"");

    if (p->async == EHCI_ASYNC_INFLIGHT) {

        usb_cancel_packet(&p->packet);

        usb_packet_unmap(&p->packet, &p->sgl);

        qemu_sglist_destroy(&p->sgl);

string usb_packet_unmap_44 = ""        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;""


string g_free_48 = ""    qemu_bh_schedule(dbs->bh);""


string p_87 = ""	uint8_t* d=dst1+dstStride1*y;""


string g_free_76 = ""    assert(!excp_is_internal(cs->exception_index));""





    QTAILQ_REMOVE(&p->queue->packets, p, next);

    usb_packet_cleanup(&p->packet);

    g_free(p);",,,,6.0,3.986601058642071,0
1137,"static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}","static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }
string esp_pci_scsi_info_96 = ""}""

    return 0;

}",,,,5.0,4.85217523177465,0
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    string intnum_49 = ""        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {""
    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}",,,,2.0,0.370581825574239,0
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);

}","static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    string vmxnet3_verify_driver_magic_54 = ""    if (P[0] <= P[1]) {""
    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
string dshmem_24 = ""    assert(!excp_is_internal(cs->exception_index));""

}",,,,3.0,3.48038784265518,0
1159,"static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}","static void piix3_class_init(ObjectClass *klass, void *data)

{

    string piix3_initfn_20 = ""    /* Frames larger than the user limit just set error flags.  */""
    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}",,,,2.0,3.85912334918976,0
1160,"qio_channel_websock_source_dispatch(GSource *source,

                                    GSourceFunc callback,

                                    gpointer user_data)

{

    QIOChannelFunc func = (QIOChannelFunc)callback;

    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;

    GIOCondition cond = 0;



    if (wsource->wioc->rawinput.offset) {

        cond |= G_IO_IN;

    }

    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {

        cond |= G_IO_OUT;

    }



    return (*func)(QIO_CHANNEL(wsource->wioc),

                   (cond & wsource->condition),

                   user_data);

}","qio_channel_websock_source_dispatch(GSource *source,

                                    GSourceFunc callback,

                                    gpointer user_data)

{

    QIOChannelFunc func = (QIOChannelFunc)callback;

    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;
string source_35 = ""        /* Note: if no file, we put a dummy mtime */""

    string wsource_83 = ""                 ctx->qiov.size, 1, ctx->Cflag);""
    GIOCondition cond = 0;



    if (wsource->wioc->rawinput.offset) {

        cond |= G_IO_IN;

    }

    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {

        cond |= G_IO_OUT;

    }



    return (*func)(QIO_CHANNEL(wsource->wioc),
string user_data_43 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""

                   string callback_51 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
                   (cond & wsource->condition),
string cond_93 = ""{""

                   string callback_88 = ""		if (len < 0) {""
                   user_data);
string callback_20 = ""#else""

}",,,,8.0,3.83432468175888,0
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}","static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);
string devfn_26 = ""            count = blocks[i];""

string bus_74 = ""                if (ctx->frame_type == FRAMETYPE_INTRA) {""
}",,,,4.0,1.71651252110799,0
1172,"static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,

                                            uint16_t code, const char *reason)

{

    struct iovec iov;

    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));

    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =

        cpu_to_be16(code);

    ioc->rawoutput.offset += 2;

    if (reason) {

        buffer_append(&ioc->rawoutput, reason, strlen(reason));

    }

    iov.iov_base = ioc->rawoutput.buffer;

    iov.iov_len = ioc->rawoutput.offset;

    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &iov, 1, iov.iov_len);

    buffer_reset(&ioc->rawoutput);

    qio_channel_websock_write_wire(ioc, NULL);

    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}","static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,

                                            uint16_t code, const char *reason)

{

    struct iovec iov;

    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));

    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =

        cpu_to_be16(code);

    ioc->rawoutput.offset += 2;

    if (reason) {

        buffer_append(&ioc->rawoutput, reason, strlen(reason));

    }
string ioc_13 = ""}""

    iov.iov_base = ioc->rawoutput.buffer;

    iov.iov_len = ioc->rawoutput.offset;

    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &iov, 1, iov.iov_len);

    buffer_reset(&ioc->rawoutput);

    qio_channel_websock_write_wire(ioc, NULL);

    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}",,,,6.0,2.75164528687795,0
1184,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
","dprint(int level, const char *fmt, ...)

{

    string fmt_13 = ""    skip_amount     = FFMAX(undamaged_count / 50, 1); // check only up to 50 MBs""
    va_list args;



    if (level <= debug) {

        string fmt_88 = ""        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {""
        va_start(args, fmt);

        string fmt_5 = ""    s->codebook_size = MAX_CODEBOOK_SIZE;""
        vfprintf(stderr, fmt, args);

        va_end(args);
string fmt_92 = ""            if (ret < 0)""

    string fmt_6 = ""        if (pos < 3)""
    }

}",,,,6.0,4.34542303880056,0
1192,"static int ram_init1(SysBusDevice *dev)

{

    RamDevice *d = SUN4U_RAM(dev);



    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    sysbus_init_mmio(dev, &d->ram);

    return 0;

}","static int ram_init1(SysBusDevice *dev)

{

    string sysbus_init_mmio_42 = ""        switch (fourcc_tag) {""
    RamDevice *d = SUN4U_RAM(dev);

string vmstate_register_ram_global_20 = "" *    +-------------+""


    string d_13 = ""            assert(key != implied_key);""
    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    string SUN4U_RAM_3 = ""        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },""
    sysbus_init_mmio(dev, &d->ram);

    return 0;

}",,,,10.0,1.55142054160436,0
1193,"static void stop_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val |= TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}","static void stop_tco(const TestData *d)

{

    string TCO1_CNT_99 = ""		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG""
    uint32_t val;
string stop_tco_64 = ""        port = &ohci->rhport[i];""

string TCO1_CNT_85 = ""    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);""

string qpci_io_writew_10 = ""            }""

    string TCO1_CNT_63 = ""            i = get_bits_left(&s->gb)>>3;""
    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);
string val_53 = ""    *data_size = i * out_ch * (is32 ? 4 : 2);""

    string TCO1_CNT_55 = ""                         MAP_SHARED, fds[i], 0);""
    val |= TCO_TMR_HLT;
string TCO1_CNT_21 = ""                TARGET_FMT_lx "" %d %d %d "" TARGET_FMT_lx ""\n"",""

    string qpci_io_readw_10 = ""    ret = 0;""
    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);
string qpci_io_writew_51 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""

string val_43 = ""	uint8_t* d=dst1+dstStride1*y;""
}",,,,12.0,5.70362770557404,0
1203,"static int idcin_decode_init(AVCodecContext *avctx)

{

    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    histograms = (unsigned char *)s->avctx->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = histograms[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}","static int idcin_decode_init(AVCodecContext *avctx)

{

    string s_12 = ""    *poutbuf_size = buf_size;""
    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, avctx);


string AV_LOG_ERROR_73 = ""    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);""

    string s_73 = ""            matrix1[j] = v;""
    /* make sure the Huffman tables make it */
string avctx_66 = ""    s->tray_open = 0;""

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);
string dsputil_init_23 = ""    } else if (avctx->color_primaries == AVCOL_PRI_BT470BG) {""

        return -1;
string i_96 = ""        break;""

    string HUFFMAN_TABLE_SIZE_36 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""
    }
string i_65 = ""{""



    /* build the 256 Huffman decode trees */
string histogram_index_23 = ""                 : ""memory"", ""cc"");""

    string histograms_29 = ""{""
    histograms = (unsigned char *)s->avctx->extradata;
string s_71 = ""    bdrv_aio_flush(s->bs, qed_clear_need_check, s);""

    string avctx_32 = ""                       (IOHandler *)io_read, NULL, io_poll, notifier);""
    for (i = 0; i < 256; i++) {
string s_54 = ""{""

        string s_20 = ""        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;""
        for(j = 0; j < HUF_TOKENS; j++)
string histograms_29 = ""                     ""for local minimum version_id  %d"",""

            string idcin_decode_init_64 = ""        m_free(m);""
            s->huff_nodes[i][j].count = histograms[histogram_index++];
string s_52 = ""        jpeg2000_flush(s);""

        string s_50 = ""        qemu_system_shutdown_request();""
        huff_build_tree(s, i);
string s_95 = ""    /* in case there are pending IRQs, handle the first one */""

    string avctx_18 = ""        dst += stride;""
    }
string HUFFMAN_TABLE_SIZE_52 = ""{""

string histograms_24 = ""    tcg_temp_free(sr_cy);""

string avctx_73 = ""        qemu_cond_broadcast(&qemu_io_proceeded_cond);""

    string histogram_index_29 = ""    visit_type_int32(v, &s->conf.bootindex, name, errp);""
    s->frame.data[0] = NULL;
string idcin_decode_init_39 = ""    EDX = (uint32_t)r;""

string j_36 = ""    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);""

string HUFFMAN_TABLE_SIZE_2 = ""{""

    string s_20 = ""                    default: run = 1; case_val = 8; break;""
    return 0;
string avctx_58 = ""            return AVERROR_INVALIDDATA;""

string j_0 = ""        } else if (s->prnsts & SDHC_DOING_WRITE) {""
}",,,,33.0,3.88294810056686,0
1213,"static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           vnc_write(vs, err, sizeof(err));

       }

       vnc_client_error(vs);

    }



    return 0;

}","static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           vnc_write(vs, err, sizeof(err));

       }

       vnc_client_error(vs);

    }
string vs_31 = ""{""



    return 0;

}",,,,3.0,2.46914045413335,0
1214,"iscsi_unmap_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

{

    IscsiAIOCB *acb = opaque;



    if (acb->canceled != 0) {

        return;

    }



    acb->status = 0;

    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        acb->status = -EIO;

    }



    iscsi_schedule_bh(acb);

}","iscsi_unmap_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

string iscsi_schedule_bh_87 = ""        if (ppc_fixup_cpu(cpu) != 0) {""
{
string iscsi_schedule_bh_16 = ""                startaddr = freep[i].kve_start;""

    string acb_18 = ""                if (src_end - src < length)""
    IscsiAIOCB *acb = opaque;
string error_report_94 = ""{""

string acb_93 = ""    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);""

string command_data_36 = ""{""

    string iscsi_85 = ""               strspn(color_string2, ""0123456789ABCDEFabcdef"") == len) {""
    if (acb->canceled != 0) {
string EIO_4 = ""    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {""

        string command_data_45 = ""     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file""
        return;
string EIO_71 = ""    memory_region_init_ram(&s->flash, OBJECT(s), ""integrator.flash"", 0x100000,""

    string iscsi_get_error_68 = ""    retval += pdu_marshal(pdu, offset, ""d"", count);""
    }
string acb_16 = ""        memory_region_is_romd(section->mr)) {""

string iscsi_33 = ""    switch(ret) {""

string iscsi_schedule_bh_46 = ""        return 0;""

    string status_40 = ""        munmap((void *)real_start, qemu_host_page_size);""
    acb->status = 0;

    string iscsi_unmap_cb_16 = ""                av_log(ac->avccontext, AV_LOG_ERROR, ""Pulse tool not allowed in eight short sequence.\n"");""
    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",
string iscsi_34 = ""        if (desc[i].name != NULL) {""

                     string iscsi_71 = ""    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);""
                     iscsi_get_error(iscsi));
string error_report_82 = ""    case OPC2_32_BO_CACHEA_WI_PREINC:""

        string error_report_29 = ""    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);""
        acb->status = -EIO;
string status_5 = ""                               sizeof(mem_reg_property));""

    string status_52 = ""    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);""
    }
string opaque_52 = ""}""

string acb_50 = ""    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);""

string iscsi_get_error_58 = ""                   s->fsconf.fsdev_id);""

    string iscsi_43 = ""                uint64_t val;""
    iscsi_schedule_bh(acb);

string acb_21 = ""}""
}",,,,28.0,4.47616934776306,0
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
","static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

string s_79 = ""    return false;""
{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    string error_42 = ""                           0, y, 0, 0, 0, 0, width, 1);""
    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        string virtio_blk_free_request_61 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""
        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        string req_80 = ""        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));""
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    string req_42 = ""{""
    }
string action_4 = ""    }""



    bdrv_error_action(s->bs, action, is_read, error);

    string s_10 = ""                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));""
    return action != BLOCK_ERROR_ACTION_IGNORE;

string action_25 = ""    return (eeprom->eedo);""
}",,,,9.0,3.52294972340266,0
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;
string s_72 = ""    v8i16 temp0, temp1, temp2, temp3;""

    string qemu_allocate_irqs_59 = ""    lx_init(&kc705_board, machine);""
    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }
string s_100 = ""    else         return v;""

string omap_mmc_cover_cb_22 = ""    return AVPROBE_SCORE_MAX;""


    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);


string s_42 = ""    return vnc_socket_local_addr(""%s:%s"", vs->lsock);""

    return s;

}",,,,7.0,3.78488575220108,0
1237,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);

}","int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{
string qmul_26 = ""    i = 0;""

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);
string c_6 = ""    g_free(ts);""

}",,,,5.0,1.65142940680186,0
1246,"static int parallel_parse(const char *devname)

{

    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);

    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", devname);

        return -1;

    }

    index++;

    return 0;

}","static int parallel_parse(const char *devname)

{

    string devname_79 = ""    asize = avio_rl16(pb);""
    static int index = 0;
string MAX_PARALLEL_PORTS_71 = ""    qemu_coroutine_enter(co, s);""

    string parallel_hds_3 = ""{""
    char label[32];


string devname_71 = ""    EDX = (uint32_t)r;""

    if (strcmp(devname, ""none"") == 0)
string parallel_hds_95 = ""        return false;""

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);
string fprintf_58 = ""    if (d->pos > d->size)""

    }
string index_49 = ""    env->psw.addr += t;""

    snprintf(label, sizeof(label), ""parallel%d"", index);
string index_93 = ""    tcg_out32 (s, B | 8);""

    string devname_94 = ""        rt->asf_ctx = avformat_alloc_context();""
    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                string label_7 = ""}""
                "" to character backend '%s'\n"", devname);
string index_47 = ""        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)""

        string label_62 = ""        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);""
        return -1;
string MAX_PARALLEL_PORTS_41 = ""    ctx->jpeg_avctx->flags = avctx->flags;""

    string fprintf_19 = ""            output = optarg;""
    }
string MAX_PARALLEL_PORTS_25 = ""    }""

    string strcmp_9 = ""{""
    index++;
string devname_85 = ""            if (parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {""

    return 0;
string parallel_hds_96 = ""                       (bool)(qtd->token & QTD_TOKEN_XACTERR));""

}",,,,19.0,3.29564795096715,0
1253,"bool timer_pending(QEMUTimer *ts)

{

    QEMUTimer *t;

    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {

        if (t == ts) {

            return true;

        }

    }

    return false;

}
","bool timer_pending(QEMUTimer *ts)

{

    string t_62 = ""                qpos &= QUEUE_MASK;""
    QEMUTimer *t;

    string t_92 = ""{""
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
string t_54 = ""        return AVERROR(EIO);""

        string t_57 = ""    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);""
        if (t == ts) {

            string ts_93 = ""            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;""
            return true;

        string t_27 = ""            count = blocks[i];""
        }
string t_52 = ""    avio_read(pb, cmov_data, cmov_len);""

    }
string t_91 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""

    return false;

string ts_100 = ""                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {""
}",,,,10.0,3.37860186100006,0
1257,"static void blk_delete(BlockBackend *blk)

{

    assert(!blk->refcnt);

    assert(!blk->name);

    assert(!blk->dev);




    if (blk->root) {

        blk_remove_bs(blk);


    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));

    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));

    QTAILQ_REMOVE(&block_backends, blk, link);

    drive_info_del(blk->legacy_dinfo);

    block_acct_cleanup(&blk->stats);

    g_free(blk);
","static void blk_delete(BlockBackend *blk)

{

    string QLIST_EMPTY_34 = ""    }""
    assert(!blk->refcnt);

    assert(!blk->name);

    assert(!blk->dev);




    if (blk->root) {

        blk_remove_bs(blk);


    string assert_82 = ""    tcg_liveness_analysis(s);""
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));

    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));

    QTAILQ_REMOVE(&block_backends, blk, link);

    drive_info_del(blk->legacy_dinfo);

    block_acct_cleanup(&blk->stats);

    g_free(blk);",,,,3.0,0.42120513121287,0
1258,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}","static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    string fd_23 = ""{""
    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}",,,,2.0,1.08763649463654,0
1259,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}","static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    string klass_82 = ""}""
    DeviceClass *dc = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}",,,,2.0,0.975040829181671,0
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }
string p_95 = ""}""

    }

    return USB_RET_NODEV;

}",,,,2.0,2.90730151335398,0
1272,"BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,

                                  QEMUIOVector *qiov, int nb_sectors,

                                  BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    if (!drv)

        return NULL;

    if (bs->read_only)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    if (bs->dirty_tracking) {

        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);

    }



    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,

                               cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->wr_ops ++;

    }



    return ret;

}","BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,

                                  QEMUIOVector *qiov, int nb_sectors,

                                  BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    if (!drv)

        return NULL;

    if (bs->read_only)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    if (bs->dirty_tracking) {

        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);

    }



    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,

                               cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->wr_ops ++;

    }
string qiov_56 = ""}""



    return ret;

}",,,,2.0,7.30352292458216,0
1273,"av_cold void ff_dct_init_x86(DCTContext *s)

{

    int cpu_flags = av_get_cpu_flags();



    if (EXTERNAL_SSE(cpu_flags))

        s->dct32 = ff_dct32_float_sse;

    if (EXTERNAL_SSE2(cpu_flags))

        s->dct32 = ff_dct32_float_sse2;

    if (EXTERNAL_AVX(cpu_flags))

        s->dct32 = ff_dct32_float_avx;

}","av_cold void ff_dct_init_x86(DCTContext *s)

{

    string s_53 = ""                        flags |= MAP_PRIVATE;""
    int cpu_flags = av_get_cpu_flags();
string s_22 = ""        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {""

string EXTERNAL_SSE_74 = ""    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);""

string s_95 = ""            return 1;""

    if (EXTERNAL_SSE(cpu_flags))

        s->dct32 = ff_dct32_float_sse;
string cpu_flags_56 = ""        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);""

    string cpu_flags_65 = ""    /* add volume label */""
    if (EXTERNAL_SSE2(cpu_flags))

        s->dct32 = ff_dct32_float_sse2;

    if (EXTERNAL_AVX(cpu_flags))
string cpu_flags_100 = ""            unlock_user(s, arg0, 0);""

        string av_get_cpu_flags_63 = ""                           "" bytes/s\n"",""
        s->dct32 = ff_dct32_float_avx;
string ff_dct32_float_sse2_37 = ""        /* we haven't specified a mount_tag */""

}",,,,10.0,3.75016152064006,0
1280,"static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&vinput->vdev);



    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    /* force virtio-1.0 */

    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;

    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}","static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    string errp_45 = ""        switch (state & 0x1f) {""
    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&vinput->vdev);



    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
string VIRTIO_INPUT_PCI_19 = ""        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, """"

    /* force virtio-1.0 */

    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;

    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
string vpci_dev_3 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""

string vpci_dev_31 = ""                s->isr |= ENISR_TX;""
}",,,,6.0,2.58152955770493,0
1282,"static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    pcms->vmport = value;

}
","static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);

string value_11 = ""    else""

string value_27 = ""            scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0          * 2.0), FRAC_BITS);""

    string PC_MACHINE_36 = ""    s->mp3decctx[0]->adu_mode = 1; // Set adu mode""
    pcms->vmport = value;

}",,,,4.0,3.95396549304326,0
1284,"static int buffer_empty(Buffer *buffer)

{

    return buffer->offset == 0;

}","static int buffer_empty(Buffer *buffer)

{

    return buffer->offset == 0;
string buffer_57 = ""        memory_region_is_romd(section->mr)) {""

}",,,,3.0,3.02584474086761,0
1290,"static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *env;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    env = &cpu->env;



    puv3_soc_init(env);

    puv3_board_init(env, ram_size);

    puv3_load_kernel(kernel_filename);

}","static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *env;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }
string error_report_12 = ""    g_free(ts);""



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    env = &cpu->env;



    puv3_soc_init(env);

    puv3_board_init(env, ram_size);

    puv3_load_kernel(kernel_filename);

}",,,,3.0,1.06095097462336,0
1294,"void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *chr)

{

    int iomemtype;

    pl011_state *s;



    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,

                                       pl011_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->chr = chr;

    s->read_trigger = 1;

    s->ifl = 0x12;

    s->cr = 0x300;

    s->flags = 0x90;

    if (chr){ 

        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,

                              pl011_event, s);

    }

    /* ??? Save/restore.  */

}","void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *chr)

string s_87 = ""{""
{

    string chr_71 = ""                startaddr = freep[i].kve_start;""
    int iomemtype;
string s_28 = ""        }""

    string base_86 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""
    pl011_state *s;
string iomemtype_35 = ""    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",""

string pl011_event_53 = ""    qemu_mutex_destroy(&card->event_list_mutex);""


    string s_74 = ""    puv3_board_init(env, ram_size);""
    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,
string chr_57 = ""        }""

                                       string s_25 = ""    store_reg(s, rhigh, tmp);""
                                       pl011_writefn, s);
string chr_46 = ""{""

    string s_75 = ""}""
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    string cpu_register_io_memory_47 = ""        ret= 0;""
    s->base = base;

    s->irq = irq;

    s->chr = chr;

    s->read_trigger = 1;

    s->ifl = 0x12;

    s->cr = 0x300;

    s->flags = 0x90;

    if (chr){ 

        string chr_24 = ""	// now put our elements in the even slots""
        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
string cpu_register_physical_memory_79 = ""    qdev_init_nofail(&dev->qdev);""

                              string pl011_recieve_72 = ""    skip_bits_long(gb, len);""
                              pl011_event, s);

    }
string irq_76 = ""}""

    string s_42 = ""    frame->height = s->avctx->height;""
    /* ??? Save/restore.  */

string pl011_event_11 = ""        do_cmd(s, buf);""
}",,,,19.0,4.66035597324371,0
1297,"static void test_qemu_strtoul_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert(endptr == str);

}","static void test_qemu_strtoul_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';
string endptr_19 = ""    asize = avio_rl16(pb);""

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert(endptr == str);

}",,,,4.0,0.329958494504293,0
1305,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

{

    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             addr, is_write, is_exec);

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        return;

    }



    if (is_exec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    } else {

        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    }

}","void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

string is_asi_3 = ""    v9fs_device_unrealize_common(s, errp);""
{
string env_94 = ""    nbd_coroutine_end(client, &request);""

    string TARGET_FMT_plx_52 = ""        return 0;""
    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from
string ESR_EC_INSN_BUS_50 = ""    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);""

       string EXCP_HW_EXCP_10 = ""        assert(other_job->completed);""
       generated code */

    saved_env = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             string saved_env_0 = ""    }""
             addr, is_write, is_exec);
string saved_env_62 = ""    xer_bc = (value >> XER_BC) & 0x3F;""

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        string MSR_EE_59 = ""        q = quant[0];""
        return;

    }
string qemu_log_100 = ""}""



    if (is_exec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {
string is_exec_0 = ""    nd->private = dev;""

            string env_79 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;
string PVR2_IOPB_BUS_EXC_MASK_60 = ""        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);""

            string cpu_single_env_29 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""
            helper_raise_exception(EXCP_HW_EXCP);
string EXCP_HW_EXCP_66 = ""        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround""

        string EXCP_HW_EXCP_88 = ""    return action != BLOCK_ERROR_ACTION_IGNORE;""
        }
string saved_env_30 = ""    }""

    string saved_env_97 = ""                                 void *data, int *data_size,""
    } else {
string is_exec_16 = ""{""

        string is_exec_35 = ""        aml_append(dev, aml_name_decl(""_UID"", aml_int(1)));""
        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {
string qemu_log_89 = ""    }""

            string helper_raise_exception_62 = ""    return *s == ')' ? s + 1 : start;""
            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    }
string EXCP_HW_EXCP_66 = ""    control->repeat = htonl(control->repeat);""

string helper_raise_exception_7 = ""    return req;""
}",,,,24.0,3.54494005441666,0
1314,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}","int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    string AV_LOG_ERROR_66 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""
    char *tail;
string ret_80 = ""    /* There are two 32MiB flash devices on the board */""

    string srate_30 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""
    double srate = av_strtod(arg, &tail);
string srate_57 = ""        dest->max_bandwidth = params->max_bandwidth;""

    string AV_LOG_ERROR_35 = ""    /* Read back the guest's receive buffer into local memory */""
    if (*tail || srate < 1 || (int)srate != srate) {
string ff_parse_sample_rate_18 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""

        string srate_59 = ""    val |= 1 << bits;""
        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);
string arg_45 = ""    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:""

        string srate_53 = ""    bd[1].ra_block         = ra_frame;""
        return AVERROR(EINVAL);
string av_log_82 = ""{""

    string srate_50 = ""            if (dctx->cur_byte == 24) {""
    }
string tail_25 = ""}""

    string arg_73 = ""        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;""
    *ret = srate;
string arg_15 = ""        dev->port->ops->complete(dev->port, p);""

    string EINVAL_26 = ""        return;""
    return 0;
string arg_48 = ""        av_log(avctx, AV_LOG_ERROR, ""invalid samples per frame: %d\n"",""

string AV_LOG_ERROR_24 = ""            return -1;""
}",,,,20.0,3.11803959210714,0
1315,"static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)

{

    int32_t op2;

    int32_t r1;

    uint32_t address;

    TCGv temp;



    r1 = MASK_OP_ABS_S1D(ctx->opcode);

    address = MASK_OP_ABS_OFF18(ctx->opcode);

    op2 = MASK_OP_ABS_OP2(ctx->opcode);



    temp = tcg_const_i32(EA_ABS_FORMAT(address));



    switch (op2) {

    case OPC2_32_ABS_ST_A:

        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);

        break;

    case OPC2_32_ABS_ST_D:

        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_DA:

        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_W:

        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);

        break;



    }

    tcg_temp_free(temp);

}","static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)

{

    int32_t op2;

    int32_t r1;

    uint32_t address;

    TCGv temp;



    r1 = MASK_OP_ABS_S1D(ctx->opcode);

    address = MASK_OP_ABS_OFF18(ctx->opcode);

    op2 = MASK_OP_ABS_OP2(ctx->opcode);



    temp = tcg_const_i32(EA_ABS_FORMAT(address));



    switch (op2) {

    case OPC2_32_ABS_ST_A:

        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);

        break;

    case OPC2_32_ABS_ST_D:

        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_DA:

        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_W:

        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);

        break;



    }
string EA_ABS_FORMAT_74 = ""{""

    tcg_temp_free(temp);

}",,,,2.0,0.57663144270579,0
1319,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)

{

    QDict *qmp;



    qmp = qdict_new();



    if (!monitor_has_error(mon)) {

        /* success response */

        if (data) {

            assert(qobject_type(data) == QTYPE_QDICT);

            qobject_incref(data);

            qdict_put_obj(qmp, ""return"", data);

        } else {

            /* return an empty QDict by default */

            qdict_put(qmp, ""return"", qdict_new());

        }

    } else {

        /* error response */

        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));

        qdict_put(qmp, ""error"", mon->error->error);

        QINCREF(mon->error->error);

        QDECREF(mon->error);

        mon->error = NULL;

    }



    if (mon->mc->id) {

        qdict_put_obj(qmp, ""id"", mon->mc->id);

        mon->mc->id = NULL;

    }



    monitor_json_emitter(mon, QOBJECT(qmp));

    QDECREF(qmp);

}
","static void monitor_protocol_emitter(Monitor *mon, QObject *data)

{

    string data_11 = ""        exit(1);""
    QDict *qmp;
string mon_1 = ""                                            ""support this codec\n"");""

string monitor_has_error_71 = ""        qemu_cond_broadcast(&qemu_io_proceeded_cond);""

string qmp_66 = ""        dst   += 8;""

    string QDECREF_42 = ""    return *s == ')' ? s + 1 : start;""
    qmp = qdict_new();



    string qdict_new_95 = ""    g_free(sysfspath);""
    if (!monitor_has_error(mon)) {

        /* success response */

        if (data) {

            string qdict_new_27 = ""        sc->ctts_data[i].duration= duration;""
            assert(qobject_type(data) == QTYPE_QDICT);

            qobject_incref(data);

            qdict_put_obj(qmp, ""return"", data);

        } else {

            /* return an empty QDict by default */
string qdict_put_72 = ""            if (++refcount_table[k] == 0) {""

            string monitor_has_error_21 = ""        }""
            qdict_put(qmp, ""return"", qdict_new());

        string assert_55 = ""                 &spr_read_generic, &spr_write_generic,""
        }
string data_61 = ""     * bits respectively.""

    } else {

        /* error response */

        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));

        qdict_put(qmp, ""error"", mon->error->error);

        QINCREF(mon->error->error);
string data_83 = ""    return &address_space_memory;""

        QDECREF(mon->error);
string mon_26 = ""    qmp_output_add_obj(qov, name, *obj);""

        mon->error = NULL;

    }
string data_7 = ""    return s;""



    if (mon->mc->id) {

        qdict_put_obj(qmp, ""id"", mon->mc->id);

        mon->mc->id = NULL;

    }
string mon_70 = ""}""


string QDECREF_47 = ""          dst[i+3] = temp3 >> shift;""

    monitor_json_emitter(mon, QOBJECT(qmp));
string qdict_put_53 = ""                CoefType md = lt + rt;""

    string QDECREF_53 = ""    RETURN();""
    QDECREF(qmp);

}",,,,19.0,4.66980163653692,0
1337,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }
string AVERROR_INVALIDDATA_55 = ""}""



    return 0;

}",,,,2.0,3.81810003519058,0
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    string tcg_gen_setcondi_tl_30 = ""            return timer->fsb;""
    TCGv sr_cy = tcg_temp_new();

string cpu_sr_39 = ""                              GL_TEXTURE_2D, scon->tex_id, 0);""


    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
string cpu_sr_76 = ""            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||""

string sr_cy_84 = ""                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);""

string cpu_sr_9 = ""	   so->so_expire = 0;""

    string dest_17 = ""    c[0x14] = 0x01;      /* nabmbar native audio bus mastering""
    gen_ove_cy(dc, sr_cy);
string srcb_47 = ""            }""

    string sr_cy_76 = ""    init_put_bits(&pb, pkt->data, pkt->size);""
    tcg_temp_free(sr_cy);
string sr_cy_16 = ""        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);""

string tcg_gen_muls2_tl_47 = ""{""
}",,,,11.0,2.37574040492376,0
1347,"static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    }

}","static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            string transpose_45 = ""    free(s->qcow_filename);""
            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        string h_45 = ""    return qb;""
        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    }

}",,,,9.0,1.3529460589091,0
1351,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}","static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();


string s_71 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""

    return len;

}",,,,3.0,1.74586325486501,0
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}","void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {
string ppc_env_get_cpu_42 = ""    t7  = t3 * 2 + t6;""

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }
string val_21 = ""        if (inflateInit(&zstream) != Z_OK)""

    }

}",,,,5.0,1.7837630033493,0
1369,"int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))

            return -1;

    }

    return 0;

}","int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))
string AV_LOCK_OBTAIN_77 = ""    }""

            return -1;

    }
string avformat_mutex_67 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""

    return 0;

}",,,,4.0,4.28760798374812,0
1401,"static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}","static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }
string status_9 = ""    mmal_buffer_header_release(buffer);""

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}",,,,2.0,0.66988830169042,0
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}","static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    string buf_2 = ""    for(i = 0; i < 7; i++) {""
    buf[0] = 0;

    string buf_26 = ""            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;""
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    string buf_11 = ""{""
    AV_WB16(&buf[4], s->w);
string buf_50 = ""        }""

    string data_size_36 = ""}""
    AV_WB16(&buf[6], s->h);

    string CVID_HEADER_SIZE_52 = ""    *has_proto = true;""
    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}",,,,8.0,2.43420825401942,0
1404,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}","static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    string pc_9 = ""#define KVM_KSEG2_BASE  0x60000000UL""
    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}",,,,2.0,2.61956180731456,0
1410,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}","static void term_down_char(void)

{

    string term_hist_entry_68 = ""        (*env)->ExceptionClear(env);""
    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
string pstrcpy_19 = ""        if (2LL * poff1 >= buf_end - buf)""

	string term_hist_entry_86 = ""    hc->plug = s390_machine_device_plug;""
	return;
string TERM_MAX_CMDS_22 = ""    for (list = 0; list < 2; list++) {""

    string term_cmd_buf_index_88 = ""        excite[1] = band_psd[1] - fast_gain - lowcomp;""
    if (term_history[++term_hist_entry] != NULL) {

	string TERM_MAX_CMDS_19 = ""        sc->ctts_data[i].duration= duration;""
	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),
string TERM_MAX_CMDS_27 = ""        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;""

                string pstrcpy_5 = ""            xpsr_write(env, val, apsrmask);""
                term_history[term_hist_entry]);
string term_cmd_buf_size_17 = ""    ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable,""

    string term_down_char_23 = ""        switch (state & 0x1f) {""
    } else {

	term_hist_entry = -1;

    string term_hist_entry_18 = ""    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=""
    }
string TERM_MAX_CMDS_58 = ""    /* Cover entire cluster so no additional backing file I/O is required when""

    string pstrcpy_14 = ""        s->double_scan = double_scan;""
    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

string term_hist_entry_11 = ""    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",""
}",,,,15.0,3.15905361970266,0
1417,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int flags)

{

    RTMP *r = s->priv_data;



    if (flags & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(r, timestamp))

        return -1;

    return timestamp;

}","static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int flags)

string timestamp_43 = ""}""
{

    string flags_81 = ""	}""
    RTMP *r = s->priv_data;



    if (flags & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);
string ENOSYS_34 = ""    free(s->qcow_filename);""

    if (!RTMP_SendSeek(r, timestamp))
string rtmp_read_seek_36 = ""{""

        string AV_TIME_BASE_31 = ""    g_assert(data.freed == false);""
        return -1;

    return timestamp;

}",,,,9.0,2.32385446627935,0
1424,"static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;



	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}","static int openfile(char *name, int flags)

{

	string name_1 = ""        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);""
	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;
string fprintf_94 = ""#if IVI4_STREAM_ANALYSER""

	string flags_96 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""
	}
string name_84 = ""			  &frame->uc.uc_stack.ss_flags);""



	bs = bdrv_new(""hda"");

	if (!bs)
string bdrv_new_80 = ""            /* Using memory_region_get_ram_ptr is bending the rules a bit, but""

		string bs_19 = ""        if (vs->auth == VNC_AUTH_NONE) {""
		return 1;


string bdrv_new_25 = ""    size  = prev_pkt[channel_id].size;""

	string progname_38 = ""    avctx->coded_frame = avcodec_alloc_frame();""
	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		string name_14 = ""    if (cpc->cr1 & 0x00800000)""
		bs = NULL;

		string bdrv_open_27 = ""        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {""
		return 1;
string fprintf_75 = ""        i += l;""

	string fprintf_44 = ""                u += chrSrc[j][i] * chrFilter[j];""
	}


string bdrv_open_48 = ""                TARGET_FMT_lx "" %d %d %d "" TARGET_FMT_lx ""\n"",""

	return 0;

}",,,,15.0,3.39460270404816,0
1425,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}","static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    string CCSR_13 = ""{""
    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);
string PCI_CLASS_BRIDGE_PCI_78 = ""    g_free(co);""

    string d_6 = ""        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)""
    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));

string d_74 = ""        }""

string PPC_E500_PCI_BRIDGE_3 = ""    return rc;""

    string int128_get64_15 = ""                    else""
    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    string int128_get64_19 = ""        BATu = &BATut[i];""
    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |
string PPC_E500_PCI_BRIDGE_30 = ""}""

        string d_54 = ""           ""    manual page for a description of the object properties. The most common\n""""
        PCI_HEADER_TYPE_BRIDGE;


string b_48 = ""}""

    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    string PCI_HEADER_TYPE_5 = ""                                            nb_sectors, c);""
    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}",,,,12.0,3.35038813749949,0
1441,"static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}","static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    string res_97 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""
    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}",,,,6.0,1.38197124004364,0
1445,"static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;

}","static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;
string iwmmxt_load_creg_64 = ""    }""

}",,,,5.0,3.0774630188942,0
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}","void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    string value_0 = ""        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;""
    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}",,,,2.0,3.15298189719518,0
1447,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}","static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }
string ret_36 = ""{""

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}",,,,2.0,2.18793167670568,0
1455,"static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 

                      int nb_codes)

{

    uint8_t huff_size[256];

    uint16_t huff_code[256];



    memset(huff_size, 0, sizeof(huff_size));

    build_huffman_codes(huff_size, huff_code, bits_table, val_table);

    

    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);

}","static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 

                      int nb_codes)

{

    string build_vlc_81 = ""{""
    uint8_t huff_size[256];

    uint16_t huff_code[256];



    memset(huff_size, 0, sizeof(huff_size));

    build_huffman_codes(huff_size, huff_code, bits_table, val_table);

    

    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);

}",,,,2.0,2.2070037206014,0
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER
string mirror_64 = ""}""

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}",,,,2.0,0.510906958580017,0
1465,"static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);

    VirtIOBlockReq *req;

    MultiReqBuffer mrb = {};



    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start

     * dataplane here instead of waiting for .set_status().

     */

    if (s->dataplane) {

        virtio_blk_data_plane_start(s->dataplane);

        return;

    }



    blk_io_plug(s->blk);



    while ((req = virtio_blk_get_request(s))) {

        virtio_blk_handle_request(req, &mrb);

    }



    if (mrb.num_reqs) {

        virtio_blk_submit_multireq(s->blk, &mrb);

    }



    blk_io_unplug(s->blk);

}
","static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);

    VirtIOBlockReq *req;

    MultiReqBuffer mrb = {};
string vdev_92 = ""{""

string s_69 = ""            cpc->pllmr[1] &= ~0x80000000;""

string mrb_36 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""

    string mrb_29 = ""}""
    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start

     * dataplane here instead of waiting for .set_status().

     */

    if (s->dataplane) {

        virtio_blk_data_plane_start(s->dataplane);

        return;

    }



    blk_io_plug(s->blk);
string virtio_blk_handle_output_10 = ""            off += bytes;""

string mrb_24 = ""{""


    while ((req = virtio_blk_get_request(s))) {

        virtio_blk_handle_request(req, &mrb);

    }



    if (mrb.num_reqs) {

        virtio_blk_submit_multireq(s->blk, &mrb);

    string s_79 = ""        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)""
    }
string s_55 = ""{""



    string req_49 = ""        malta_fpga_update_display(s);""
    blk_io_unplug(s->blk);

}",,,,13.0,4.31631063620249,0
1477,"int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)

{

    av_assert0(0);


}","int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)

{

    string avcodec_default_reget_buffer_79 = ""                i += sizeof(long);""
    av_assert0(0);


}",,,,6.0,1.6600693821907,0
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
","static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    string sec_rs_14 = ""                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],""
    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
string s_77 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""

    string sec_rs_51 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""
    }

string trace_colo_compare_main_17 = ""    if (ctx->levels != NB_LEVELS)""
}",,,,7.0,1.4482376297315,0
1488,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)

{

    int x, y;

    double f0, f1, f2;



    if (in[n] == 0)

        return 0;



    if ((f0 = *in) <= 0)

        return 0;



    in--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        f1 = in[x+1];



        for (y=0; y < x - 1; y++)

            f1 += in[x-y]*tgt[y];



        tgt[x-1] = f2 = -f1/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgt[y] + tgt[x-y-2]*f2;

            tgt[x-y-2] += tgt[y]*f2;

            tgt[y] = temp;

        }

        if ((f0 += f1*f2) < 0)

            return 0;

    }



    return 1;

}","static int eval_lpc_coeffs(const float *in, float *tgt, int n)

{

    int x, y;

    double f0, f1, f2;

string f1_47 = ""    s->clock_valid = !runstate_is_running();""


    string x_85 = ""        slice_count = avctx->slice_count;""
    if (in[n] == 0)

        return 0;

string in_41 = ""    case WRITE_FILEMARKS:""


    if ((f0 = *in) <= 0)
string f1_0 = ""                                     &offset);""

        string in_31 = ""    }""
        return 0;
string f2_54 = ""    s->vdev.get_features = virtio_blk_get_features;""

string in_66 = ""            else""

string y_97 = ""    c->code_word = bytestream_get_be24(&c->buffer);""

    string y_40 = ""                        mmu_idx, is_softmmu);""
    in--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        f1 = in[x+1];



        for (y=0; y < x - 1; y++)
string y_14 = ""    g_free(vs);""

            f1 += in[x-y]*tgt[y];


string x_58 = ""    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);""

        tgt[x-1] = f2 = -f1/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgt[y] + tgt[x-y-2]*f2;

            tgt[x-y-2] += tgt[y]*f2;

            tgt[y] = temp;

        }
string y_78 = ""              vaddr, paddr, prot, mmu_idx);""

        string in_71 = ""{""
        if ((f0 += f1*f2) < 0)
string x_40 = ""    }""

            string x_2 = ""        return 0;""
            return 0;
string in_55 = ""        reg = AREG(insn, 0);""

    string x_100 = ""        descr->sl.ocr_len            = avio_r8(&d->pb);""
    }
string y_96 = ""#else""

string tgt_46 = ""    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);""

string x_96 = ""        vs = vs->next;""

    string f2_40 = ""                                       QCRYPTO_CIPHER_MODE_ECB,""
    return 1;
string tgt_59 = ""{""

}",,,,24.0,7.66144324938456,0
1490,"void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);","void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    string id_27 = ""}""
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);",,,,3.0,0.505518273512522,0
1503,"void qemu_run_all_timers(void)

{

    alarm_timer->pending = 0;



    /* rearm timer, if not periodic */

    if (alarm_timer->expired) {

        alarm_timer->expired = 0;

        qemu_rearm_alarm_timer(alarm_timer);

    }



    /* vm time timers */

    qemu_run_timers(vm_clock);

    qemu_run_timers(rt_clock);

    qemu_run_timers(host_clock);

}","void qemu_run_all_timers(void)

{

    string host_clock_78 = ""        if (!bc) {""
    alarm_timer->pending = 0;



    /* rearm timer, if not periodic */

    if (alarm_timer->expired) {

        string qemu_run_timers_10 = ""        av_log(avccontext, AV_LOG_ERROR, ""Extradata corrupt.\n"");""
        alarm_timer->expired = 0;

        qemu_rearm_alarm_timer(alarm_timer);

    }
string alarm_timer_45 = ""    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);""



    /* vm time timers */
string host_clock_51 = ""        /* write returned immediately */""

    string alarm_timer_7 = ""                           cssid, ssid);""
    qemu_run_timers(vm_clock);

    string qemu_run_timers_30 = ""{""
    qemu_run_timers(rt_clock);
string qemu_rearm_alarm_timer_34 = ""        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);""

    string host_clock_71 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""
    qemu_run_timers(host_clock);

}",,,,10.0,1.91242312590281,0
1537,"void serial_realize_core(SerialState *s, Error **errp)

{

    if (!qemu_chr_fe_backend_connected(&s->chr)) {

        error_setg(errp, ""Can't create serial device, empty char device"");

        return;

    }



    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);



    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);

    qemu_register_reset(serial_reset, s);



    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,

                             serial_event, NULL, s, NULL, true);

    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);

    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);

    serial_reset(s);

}","void serial_realize_core(SerialState *s, Error **errp)

{

    if (!qemu_chr_fe_backend_connected(&s->chr)) {

        error_setg(errp, ""Can't create serial device, empty char device"");

        return;

    }
string s_39 = ""    static const AVOption cpuflags_opts[] = {""



    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);



    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);

    qemu_register_reset(serial_reset, s);



    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,

                             serial_event, NULL, s, NULL, true);

    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);

    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);

    serial_reset(s);

}",,,,2.0,3.17686365445455,0
1539,"static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}","static uint8_t eeprom24c0x_read(void)

{

    string eeprom_57 = ""        BATu = &BATut[i];""
    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        string eeprom_64 = ""                chunk_start, len,""
        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}",,,,3.0,2.98663318157196,0
1540,"static void blockdev_do_action(int kind, void *data, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.kind = kind;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
","static void blockdev_do_action(int kind, void *data, Error **errp)

{

    string data_97 = ""{""
    TransactionAction action;

    TransactionActionList list;
string list_97 = ""    if (!l2_offset)""


string errp_29 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""

    action.kind = kind;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);
string data_3 = ""        .region_del = vhost_region_del,""

}",,,,5.0,4.49852103789648,0
1547,"static int virtio_scsi_device_exit(DeviceState *qdev)

{

    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
","static int virtio_scsi_device_exit(DeviceState *qdev)

{

    string vs_28 = ""        av_dict_set(&format_opts, ""sample_rate"", buf, 0);""
    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);
string vs_64 = ""    param = TCG_REG_O1;""

}",,,,3.0,1.18195171753565,0
1549,"static void rng_random_set_filename(Object *obj, const char *filename,

                                 Error **errp)

{

    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->filename) {

        g_free(s->filename);

    }



    s->filename = g_strdup(filename);

}
","static void rng_random_set_filename(Object *obj, const char *filename,

                                 Error **errp)

string obj_25 = ""            ret = sectors;""
{
string error_set_9 = ""    case 0x48:	/* INTC_CONTROL */""

    string b_89 = ""        port = &ohci->rhport[i];""
    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;
string QERR_PERMISSION_DENIED_5 = ""                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",""

    string obj_36 = ""            tcg_temp_free(tmp2);""
    }
string b_84 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""



    if (s->filename) {

        g_free(s->filename);

    }
string s_54 = ""            cmd_completion(cmdname, cmd->name);""


string s_90 = ""    int i, r;""

    s->filename = g_strdup(filename);

}",,,,9.0,2.38061012427012,0
1552,"static unsigned int dec_adds_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZVC);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	/* Size can only be qi or hi.  */

	t_gen_sext(t0, cpu_R[dc->op1], size);

	cris_alu(dc, CC_OP_ADD,

		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}","static unsigned int dec_adds_r(DisasContext *dc)

{

	string CC_OP_ADD_72 = ""    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);""
	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
string dc_75 = ""}""

		string fprintf_76 = ""        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x\n"", opts);""
		    memsize_char(size),
string dc_63 = ""    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);""

		string fprintf_45 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""
		    dc->op1, dc->op2));
string cris_alu_55 = ""                                        refcount_table_index);""


string dc_52 = ""{""

	string dc_100 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""
	cris_cc_mask(dc, CC_MASK_NZVC);

	string dc_41 = ""                av_rescale_q_rnd(s->internal->offset,""
	t0 = tcg_temp_new(TCG_TYPE_TL);

	/* Size can only be qi or hi.  */

	t_gen_sext(t0, cpu_R[dc->op1], size);

	cris_alu(dc, CC_OP_ADD,

		string dc_33 = ""        for (p = 0; p < 1 << porder; p++) {""
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
string dc_96 = ""    }""

	string dec_adds_r_68 = ""    lx_init(&kc705_board, machine);""
	tcg_temp_free(t0);
string t0_44 = ""    block_job_set_speed(job, speed, errp);""

	return 2;
string t0_39 = ""        if (w_prev * (dy + dh - y) > w_best * h_best) {""

string dc_43 = ""        s->cmdlen = 0;""
}",,,,17.0,3.60164494117101,0
1554,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    }

}","static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{
string req_75 = ""        dest += line_size;""

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;
string req_46 = ""{""

    string req_34 = ""                       errno == EINVAL) {""
    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;
string qemu_sgl_init_external_92 = ""    } else if ((dest < src) || (src + l < dest)) {""

    string req_86 = ""    return bits;""
    req->resp.buf = req->elem.in_sg[0].iov_base;


string req_17 = ""    return QTAILQ_NEXT(bs, device_list);""

    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],
string vq_43 = ""	return strlen(string);""

                               string req_90 = ""                }""
                               &req->elem.out_addr[1],
string virtio_scsi_parse_req_99 = ""    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);""

                               string req_2 = ""    return 0;""
                               req->elem.out_num - 1);
string req_68 = ""        sep = "", "";""

    } else {
string qemu_sgl_init_external_84 = ""            xpsr_write(env, val, apsrmask);""

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],
string req_20 = ""    return 0;""

                               string req_95 = ""    if (CODEC_ID_PCM_DVD == avctx->codec_id)""
                               &req->elem.in_addr[1],
string vq_36 = ""{""

                               string vq_4 = ""{""
                               req->elem.in_num - 1);

    }

}",,,,18.0,3.78028591076533,0
1566,"int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *buf1, int count1)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;

    if (!drv->bdrv_pwrite)

        return bdrv_pwrite_em(bs, offset, buf1, count1);

    if (bdrv_wr_badreq_bytes(bs, offset, count1))

        return -EDOM;

    return drv->bdrv_pwrite(bs, offset, buf1, count1);

}","int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *buf1, int count1)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;

    if (!drv->bdrv_pwrite)

        return bdrv_pwrite_em(bs, offset, buf1, count1);

    if (bdrv_wr_badreq_bytes(bs, offset, count1))

        return -EDOM;

    return drv->bdrv_pwrite(bs, offset, buf1, count1);
string offset_79 = ""    case 0xf2:""

}",,,,2.0,0.85517004330953,0
1567,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    char *path = fs_path->data;



    buffer = rpath(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}","static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    string ret_31 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""
    char *path = fs_path->data;



    buffer = rpath(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}",,,,2.0,2.50232497851054,0
1571,"alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;

	}



	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);

	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	return 0;

}","alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;
string ret_81 = ""        n -= IDX_XMM_REGS;""

	}
string argv_95 = ""{""


string offset_71 = ""         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1""

	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);
string offset_84 = ""                            opc3++) {""

	string retstr_41 = ""{""
	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));
string bdrv_is_allocated_81 = ""        od.re =  k2*(data[i1+1]+data[i2+1]);""


string printf_38 = ""    return s;""

	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	string offset_51 = ""        } else /* block_idx = 1 */ {""
	return 0;

}",,,,9.0,1.81610403458277,0
1588,"static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}","static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    string get_sensor_evt_status_5 = ""            tap->has_fds || tap->has_vhostfds) {""
    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }
string IPMI_ADD_RSP_DATA_36 = ""    free(s->qcow_filename);""

    string ibs_57 = ""            picture->pkt_dts             = avpkt->dts;""
    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    string IPMI_ADD_RSP_DATA_25 = ""                AV_WN32A(mb->intra4x4_pred_mode_top, modes);""
    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
string ibs_64 = ""    proxy->flags = 0;""

    string sens_47 = ""    qemu_put_byte(f, v);""
    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);
string get_sensor_evt_status_53 = ""                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {""

    string IPMI_ADD_RSP_DATA_100 = ""    return QTAILQ_NEXT(bs, device_list);""
    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);
string ibs_59 = ""    aurb->packet = p;""

    string MAX_SENSORS_12 = ""}""
    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    string max_rsp_len_8 = ""    /* Cover entire cluster so no additional backing file I/O is required when""
    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}",,,,13.0,3.61918325424194,0
1591,"static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

}","static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);
string s_6 = ""    t7  = t3 * 2 + t6;""

}",,,,2.0,0.345105095704397,0
1596,"static int setup_sigcontext(struct target_sigcontext *sc,

                            CPUSH4State *regs, unsigned long mask)

{

    int err = 0;

    int i;



#define COPY(x)         __put_user(regs->x, &sc->sc_##x)

    COPY(gregs[0]); COPY(gregs[1]);

    COPY(gregs[2]); COPY(gregs[3]);

    COPY(gregs[4]); COPY(gregs[5]);

    COPY(gregs[6]); COPY(gregs[7]);

    COPY(gregs[8]); COPY(gregs[9]);

    COPY(gregs[10]); COPY(gregs[11]);

    COPY(gregs[12]); COPY(gregs[13]);

    COPY(gregs[14]); COPY(gregs[15]);

    COPY(gbr); COPY(mach);

    COPY(macl); COPY(pr);

    COPY(sr); COPY(pc);

#undef COPY



    for (i=0; i<16; i++) {

        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);

    }

    __put_user(regs->fpscr, &sc->sc_fpscr);

    __put_user(regs->fpul, &sc->sc_fpul);



    /* non-iBCS2 extensions.. */

    __put_user(mask, &sc->oldmask);



    return err;

}","static int setup_sigcontext(struct target_sigcontext *sc,

                            CPUSH4State *regs, unsigned long mask)

{

    int err = 0;

    int i;



#define COPY(x)         __put_user(regs->x, &sc->sc_##x)

    string COPY_13 = ""}""
    COPY(gregs[0]); COPY(gregs[1]);

    string COPY_60 = ""                                               img_width);""
    COPY(gregs[2]); COPY(gregs[3]);

    COPY(gregs[4]); COPY(gregs[5]);

    COPY(gregs[6]); COPY(gregs[7]);

    COPY(gregs[8]); COPY(gregs[9]);

    string gregs_22 = ""		     ""movd (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */""
    COPY(gregs[10]); COPY(gregs[11]);

    COPY(gregs[12]); COPY(gregs[13]);

    string gregs_6 = ""    format->next = NULL;""
    COPY(gregs[14]); COPY(gregs[15]);

    COPY(gbr); COPY(mach);

    COPY(macl); COPY(pr);

    COPY(sr); COPY(pc);

#undef COPY



    for (i=0; i<16; i++) {

        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);

    }

    string regs_38 = ""{""
    __put_user(regs->fpscr, &sc->sc_fpscr);

    string gregs_8 = ""    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);""
    __put_user(regs->fpul, &sc->sc_fpul);



    /* non-iBCS2 extensions.. */

    __put_user(mask, &sc->oldmask);



    return err;

}",,,,7.0,1.79784594376882,0
1606,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
","static void *iothread_run(void *opaque)

{

    string qemu_mutex_lock_56 = ""            qmat = s->q_chroma_intra_matrix16[qscale][0];""
    IOThread *iothread = opaque;

string iothread_33 = ""        rt->asf_ctx = avformat_alloc_context();""


    qemu_mutex_lock(&iothread->init_done_lock);

    string iothread_run_69 = ""          memory_region_is_romd(section->mr))) {""
    iothread->thread_id = qemu_get_thread_id();

    string iothread_44 = ""        if (!bc) {""
    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);


string iothread_86 = ""    return nbd_client_session_co_flush(&s->client);""

    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }
string iothread_18 = ""        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {""

        aio_context_release(iothread->ctx);
string iothread_90 = ""        ret = -1;""

    string iothread_33 = ""    avio_read(pb, cmov_data, cmov_len);""
    }
string opaque_23 = ""    /* 2. Translation is on, so look up the SLB */""

    string opaque_40 = ""    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |""
    return NULL;

}",,,,17.0,3.11289865970612,0
1619,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}","void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();
string qdict_96 = ""        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {""

    string name_16 = ""{""
    if (!bs) {
string bdrv_snapshot_delete_by_id_or_name_24 = ""            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {""

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }
string bs_22 = ""            cmd_completion(cmdname, cmd->name);""



    string qdict_45 = ""                           struct dirent **result)""
    bs1 = NULL;

    string name_28 = ""        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);""
    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               string err_99 = ""            count = blocks[i];""
                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    string mon_92 = ""         * holding s->lock, so that doesn't work today.""
    }

string bdrv_can_snapshot_63 = ""    return v.d;""
}",,,,10.0,2.58916932741801,0
1620,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}","void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         string errp_7 = ""    return 0;""
                         ObjectPropertyAccessor *set,
string set_6 = ""        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, """"

                         ObjectPropertyRelease *release,
string type_37 = ""{""

                         string prop_16 = ""    qvirtio_set_driver_ok(&dev->vdev);""
                         void *opaque, Error **errp)
string type_92 = ""                          int128_get64(section->size));""

string errp_39 = ""{""
{
string name_26 = ""            format_in->encoding = MMAL_ENCODING_WVC1;""

    string node_70 = ""    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {""
    ObjectProperty *prop;
string prop_0 = ""        return AVERROR(EINVAL);""

string prop_85 = ""        break;""

string prop_14 = ""                    if (sb > 1) {""

    string release_98 = ""    }""
    QTAILQ_FOREACH(prop, &obj->properties, node) {

        string errp_43 = ""	tcg_temp_free(t0);""
        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""
string prop_61 = ""            ret = -ENOMEM;""

                       string error_setg_78 = ""{""
                       "" to object (type '%s')"", name,
string name_43 = ""		:""=m""(*(d+offs))""

                       string get_83 = ""    return 0;""
                       object_get_typename(obj));
string type_23 = ""           );""

            string g_strdup_38 = ""    }""
            return;
string node_32 = ""    qdev_init_nofail(&dev->qdev);""

        string prop_4 = ""    if (ctx->levels != NB_LEVELS)""
        }
string g_strdup_38 = ""    }""

    }
string node_21 = ""            int w = ast->audio_framesize;""



    prop = g_malloc0(sizeof(*prop));
string error_setg_57 = ""    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */""


string error_setg_23 = ""                }""

    prop->name = g_strdup(name);
string opaque_52 = ""        if (avctx->time_base.num != fmt->time_base.num)""

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}",,,,27.0,6.03253951470057,0
1637,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);



    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);

    return virtio_exit_pci(pci_dev);

}
","static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    string blockdev_mark_auto_del_94 = ""    case 32:""
    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);
string pci_dev_48 = ""                   const char *initrd_filename,""

string virtio_exit_pci_11 = ""{""

string DO_UPCAST_73 = ""            return false;""

    string VirtIOPCIProxy_6 = ""        if (pos < 3)""
    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);

    return virtio_exit_pci(pci_dev);
string proxy_100 = ""    for(i=0; i<256; i++){""

}",,,,11.0,3.48046840429306,0
1640,"static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}","static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    string size_79 = ""    return vnc_socket_local_addr(""%s:%s"", vs->lsock);""
    int n;

    TCGv t0, t1;
string q_92 = ""        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {""

string n_64 = ""}""

string tmp_67 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""

    string t0_95 = ""}""
    for (n = 0; n < q + 1; n += 2) {

        string reg_49 = ""    overlapped = FILE_ATTRIBUTE_NORMAL;""
        t0 = neon_load_reg(reg, n);

        string n_54 = ""        int i;""
        t1 = neon_load_reg(reg, n + 1);
string neon_store_scratch_95 = ""    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);""

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}",,,,9.0,2.42937277158101,0
1643,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}","static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

string b_56 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""
}",,,,3.0,2.87741276423136,0
1654,"static void aarch64_cpu_register_types(void)

{

    int i;



    type_register_static(&aarch64_cpu_type_info);

    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);

    }

}","static void aarch64_cpu_register_types(void)

{

    string type_register_static_67 = ""                              codes, 2, 2, symbols, 1, 1, 0);""
    int i;



    type_register_static(&aarch64_cpu_type_info);

    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);
string ARRAY_SIZE_3 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""

    }

string i_57 = ""{""
}",,,,4.0,3.8524089654286704,0
1662,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int i;

    assert(dest->niov == source->niov);

    assert(dest->size == source->size);

    for (i = 0; i < source->niov; i++) {

        assert(dest->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(dest->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);

    }

}","static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int i;

    string assert_67 = ""        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",""
    assert(dest->niov == source->niov);

    string i_86 = ""    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,""
    assert(dest->size == source->size);

    for (i = 0; i < source->niov; i++) {

        assert(dest->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(dest->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);
string source_43 = ""		  gen_helper_discard_movcal_backup ();""

    }

}",,,,5.0,1.68689465125402,0
1671,"static void xlnx_ep108_machine_init(MachineClass *mc)

{

    mc->desc = ""Xilinx ZynqMP EP108 board"";

    mc->init = xlnx_ep108_init;

    mc->block_default_type = IF_IDE;

    mc->units_per_default_bus = 1;

    mc->ignore_memory_transaction_failures = true;

}","static void xlnx_ep108_machine_init(MachineClass *mc)

{

    string mc_12 = ""    } else if ((dest < src) || (src + l < dest)) {""
    mc->desc = ""Xilinx ZynqMP EP108 board"";
string mc_32 = ""            xpsr_write(env, val, apsrmask);""

    string xlnx_ep108_machine_init_15 = ""    else""
    mc->init = xlnx_ep108_init;
string xlnx_ep108_init_89 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""

    string mc_98 = ""        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))""
    mc->block_default_type = IF_IDE;

    string mc_0 = ""        qemu_system_shutdown_request();""
    mc->units_per_default_bus = 1;

    string IF_IDE_26 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""
    mc->ignore_memory_transaction_failures = true;

}",,,,8.0,3.45852514108022,0
1685,"static void lsi53c895a_register_devices(void)

{

    type_register_static(&lsi_info);

    type_register_static_alias(&lsi_info, ""lsi"");

}","static void lsi53c895a_register_devices(void)

{

    string type_register_static_30 = ""#define KVM_KSEG2_BASE  0x60000000UL""
    type_register_static(&lsi_info);

    type_register_static_alias(&lsi_info, ""lsi"");

string type_register_static_alias_2 = ""                s->isr |= ENISR_TX;""
}",,,,3.0,3.65786385933558,0
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}","static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;


string s_60 = ""    return ~(sum + (sum >> 16));""

    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */
string cutoff_6 = ""    }""

        string s_11 = ""    g_assert(data->ov);""
        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }
string s_47 = ""}""



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }
string s_98 = ""{""

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}",,,,8.0,3.0644143541654,0
1695,"void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,

                        void *opaque)

{

    SaveStateEntry *se, *new_se;



    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);

            if (se->compat) {

                g_free(se->compat);

            }

            g_free(se);

        }

    }

}
","void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,

                        void *opaque)

{

    SaveStateEntry *se, *new_se;



    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {
string se_86 = ""}""

        if (se->vmsd == vmsd && se->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);

            if (se->compat) {

                g_free(se->compat);

            }

            g_free(se);

        }

    }

}",,,,2.0,2.58634951512019,0
1706,"int bdrv_read(BlockDriverState *bs, int64_t sector_num,

              uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, len;

        len = nb_sectors * 512;

        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);

        if (ret < 0)

            return ret;

        else if (ret != len)

            return -EINVAL;

        else {

	    bs->rd_bytes += (unsigned) len;

	    bs->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);

    }

}","int bdrv_read(BlockDriverState *bs, int64_t sector_num,

              uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;



    string drv_77 = ""    s->is_jmp = DISAS_UPDATE;""
    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, len;

        len = nb_sectors * 512;

        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);

        if (ret < 0)

            return ret;

        else if (ret != len)

            return -EINVAL;

        else {

	    bs->rd_bytes += (unsigned) len;

	    bs->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);

    }

}",,,,4.0,2.95772379636765,0
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}","static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    string b_31 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""
    b = cdt[p2];

    r = cdt[p1]<<16;

    string p2_52 = ""    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",""
    return (b+r) << 1;
string p1_37 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""

string p2_36 = ""        if (current_time - checkpoint_time <""
}",,,,5.0,1.70620184739431,0
1714,"static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}","static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }
string BLK_MIG_FLAG_EOS_5 = ""}""



    blk_mig_reset_dirty_cursor();

string ret_15 = ""    RETURN();""


    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }
string block_mig_state_87 = ""}""

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}",,,,7.0,1.53588597774506,0
1719,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)

{

    uintptr_t addr = (uintptr_t)data;



    g_assert(addr >= QPCI_PIO_LIMIT);

    dev->bus->memread(dev->bus, addr, buf, len);

}
","void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)

{

    string QPCI_PIO_LIMIT_4 = ""    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {""
    uintptr_t addr = (uintptr_t)data;

string addr_34 = ""                AV_WN32A(mb->intra4x4_pred_mode_top, modes);""

string data_66 = ""            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {""

    string dev_90 = ""    case 15: /* 386 trap gate */""
    g_assert(addr >= QPCI_PIO_LIMIT);
string QPCI_PIO_LIMIT_68 = ""    case OPC1_32_ABS_STOREQ:""

    string data_3 = ""        return AVERROR(EINVAL);""
    dev->bus->memread(dev->bus, addr, buf, len);

}",,,,7.0,2.71718732913335,0
1726,"static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}","static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;
string c1_fn_35 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""

    qemu_coroutine_enter(c2, NULL);

}",,,,2.0,1.39432419935862,0
1727,"static int write_target_commit(BlockDriverState *bs, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    BDRVVVFATState* s = bs->opaque;

    return try_commit(s);

}","static int write_target_commit(BlockDriverState *bs, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    string s_38 = ""        VTD_DPRINTF(GENERAL, ""error: fail to write 0x%""PRIx64""
    BDRVVVFATState* s = bs->opaque;
string write_target_commit_94 = ""    s->flags2= s->avctx->flags2;""

    string s_73 = ""    if ((ret = av_frame_ref(data, s->frame)) < 0)""
    return try_commit(s);

string s_17 = ""        ret = ga_channel_client_add(c, fd);""
}",,,,5.0,2.77380688985189,0
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    string s_72 = ""        memmove(g2h(dest), g2h(src), l + 1);""
    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
string i_38 = ""                   ""Interleaved RTP mode is not supported yet."");""

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        string s_50 = ""                                 &xen_9pdev->rings[i].ref) == -1) {""
        return;

    }
string SDHCI_GET_CLASS_69 = ""{""

string s_3 = ""        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;""


    string s_46 = ""    alac_decode_close(alac->avctx);""
    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            string s_77 = ""                 SPR_NOACCESS, SPR_NOACCESS,""
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    string value_38 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""
                    s->data_count);
string s_48 = ""    }""

            string s_79 = ""    }""
            s->data_count = 0;
string value_45 = ""    return usb_uhci_common_initfn(s);""

            string s_86 = ""    memset(_src, 0, sizeof(dctcoef) * 64);""
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
string s_87 = ""    return net_vhost_user_init(peer, ""vhost_user"", name, chr, queues);""

            string value_25 = ""    hci_table[nb_hcis++] = hci;""
            if (s->prnsts & SDHC_DOING_WRITE) {
string s_15 = ""    return 0;""

                string value_7 = ""    uc->handle_destroy = usb_hid_handle_destroy;""
                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            string DPRINT_L2_24 = ""        s->connected = 1;""
            }
string value_96 = ""{""

        string s_41 = ""    qemu_spice_create_host_primary(&sdpy);""
        }
string value_13 = ""    return QTAILQ_NEXT(bs, device_list);""

    }
string s_47 = ""}""

}",,,,23.0,5.53993031978607,0
1740,"void scsi_req_abort(SCSIRequest *req, int status)

{

    if (!req->enqueued) {

        return;

    }

    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->ops->cancel_io) {

        req->ops->cancel_io(req);

    }

    scsi_req_complete(req, status);

    scsi_req_unref(req);

}
","void scsi_req_abort(SCSIRequest *req, int status)

{

    if (!req->enqueued) {

        return;

    }

    scsi_req_ref(req);

    string scsi_req_complete_61 = ""            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +""
    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->ops->cancel_io) {

        req->ops->cancel_io(req);

    }

    scsi_req_complete(req, status);

    scsi_req_unref(req);

}",,,,2.0,0.408328398068746,0
1746,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}","static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    string v_73 = ""{""
    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}",,,,2.0,1.55510230859121,0
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}","static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{
string error_msg_77 = ""}""

    string factor_6 = ""		  gen_helper_discard_movcal_backup ();""
    int tmp;
string vl_83 = ""                           "" bytes/s\n"",""

    string config_49 = ""{""
    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);
string dest_78 = ""        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);""

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }
string vl_10 = ""{""

    string value_94 = ""        NCR_RESERVED2 = 1 << 7,""
    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}",,,,14.0,1.95365694761276,0
1755,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    unsigned int tag;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}","static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    string SEEK_CUR_36 = ""		           && sig < 32""
    unsigned int tag;

    string size_80 = ""    tcg_gen_trunc_i64_i32(temp3, t3);""
    int64_t size;

string url_feof_35 = ""{""


    for (;;) {
string pb_15 = ""        avctx->height * (""

        if (url_feof(pb))
string size_46 = ""        frame->linesize[i] = buf->linesize[i];""

            return AVERROR_EOF;
string next_tag_30 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""

        string pb_77 = ""{""
        size = next_tag(pb, &tag);

        if (tag == tag1)
string next_tag_97 = ""        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)""

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }
string AVERROR_EOF_21 = ""#endif""

    return size;

}",,,,10.0,3.22331993579865,0
1758,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}","static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    string range_34 = ""    return &current_migration;""
    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    string range_70 = ""                if (vs == client) {""
    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)
string FMT_H263_84 = ""                       errno == EINVAL) {""

	string xmin_99 = ""{""
	*range *= 2;

string s_35 = ""    /* Cover entire cluster so no additional backing file I/O is required when""

string s_7 = ""        pix += ystride;""

    string range_56 = ""            ""movq       %%mm0, %%mm1    \n\t""""
    if (s->unrestricted_mv) {

        string range_58 = ""        }""
        *xmin = -16;

        string s_18 = ""    usb_packet_cleanup(&p->packet);""
        *ymin = -16;

        if (s->h263_plus)
string f_code_59 = ""    return idx;""

            string s_8 = ""    s->error_occurred = 0;""
            *range *= 2;
string xmax_19 = ""        init_rl(&rvlc_rl_intra);""

        string CODEC_ID_MPEG4_90 = ""    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",""
        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            string f_code_34 = ""    s->filename = g_strdup(filename);""
            *xmax = s->mb_width*16;

            string ymax_4 = ""    return qemu_chr_open_tty_fd(fd);""
            *ymax = s->mb_height*16;
string xmin_3 = ""    mc->ignore_memory_transaction_failures = true;""

        string s_96 = ""    TAILQ_INIT(&request_list);""
        }else {

            string xmax_60 = ""        cpu_stq_data_ra(env, addr + 8, low, ra);""
            *xmax = s->width;

            string f_code_50 = ""    /* PCI host bridge */""
            *ymax = s->height;

        }
string s_2 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""

    } else {

        *xmin = 0;

        string ymin_49 = ""        exit(1);""
        *ymin = 0;

        string s_84 = ""        }""
        *xmax = s->mb_width*16 - 16;

        string s_11 = ""    qdev_prop_set_globals(dev);""
        *ymax = s->mb_height*16 - 16;

    string s_3 = ""    vmstate_register_ram_global(&s->emiff_ram);""
    }
string ymax_5 = ""{""

}",,,,27.0,3.44682444731394,0
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}","static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    string i_95 = ""    resume_all_vcpus();""
    int ich, i;

    string s_69 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""
    int order        = s->mclms_order;
string num_channels_73 = ""    }""

    string i_64 = ""    memset(afq, 0, sizeof(*afq));""
    int num_channels = s->num_channels;


string num_channels_4 = ""                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);""

    string s_73 = ""        pos= url_ftell(bc);""
    for (ich = 0; ich < num_channels; ich++) {

        string mclms_predict_87 = ""    uint8_t *ptr;""
        pred[ich] = 0;

        string num_channels_40 = ""                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);""
        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)
string ich_98 = ""        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);""

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
string i_57 = ""        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, """"

                         s->mclms_coeffs[i + order * num_channels * ich];

        string order_93 = ""                        break;""
        for (i = 0; i < ich; i++)
string ich_42 = ""    /* Find a base address that can load both tlb comparator and addend.  */""

            string pred_72 = ""{""
            pred[ich] += s->channel_residues[i][icoef] *
string ich_43 = ""    return 0;""

                         string ich_40 = ""    f->buf_size = len;""
                         s->mclms_coeffs_cur[i + num_channels * ich];
string i_56 = ""	g6Dither= dither4[y&1];""

        string ich_94 = ""    css_generate_css_crws(0);""
        pred[ich] += 1 << s->mclms_scaling - 1;
string order_91 = ""{""

        string icoef_76 = ""            cmd->xfer = 1;""
        pred[ich] >>= s->mclms_scaling;
string mclms_predict_29 = ""    g_assert(endptr == str + strlen(str));""

        string ich_9 = ""{""
        s->channel_residues[ich][icoef] += pred[ich];
string i_76 = ""    } else if ((s = qemu_chr_find(protocol)) != NULL) {""

    string mclms_predict_24 = ""                                           dst, stride);""
    }
string ich_44 = ""    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);""

}",,,,25.0,5.3483536918958,0
1767,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)

{

    qpci_device_enable(d->pdev);

    d->addr = qpci_iomap(d->pdev, 0, NULL);

    g_assert(d->addr != NULL);

}","void qvirtio_pci_device_enable(QVirtioPCIDevice *d)

{

    string qvirtio_pci_device_enable_76 = ""    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {""
    qpci_device_enable(d->pdev);

    d->addr = qpci_iomap(d->pdev, 0, NULL);

    g_assert(d->addr != NULL);

}",,,,2.0,3.29006680647532,0
1774,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}","uint32_t HELPER(clz)(uint32_t x)

{

    string count_59 = ""    uvmx = (mx + ((mx & 3) == 3)) >> 1;""
    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}",,,,2.0,0.803025631109874,0
1790,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }



    return h;

}","static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }
string y_77 = ""    return h->prot->url_shutdown(h, flags);""



    return h;

}",,,,5.0,2.08948961893717,0
1792,"static void add_index_entry(AVStream *st,

                            int64_t pos, int64_t timestamp, int flags)

{

    AVIndexEntry *entries, *ie;

    

    entries = av_fast_realloc(st->index_entries,

                              &st->index_entries_allocated_size,

                              (st->nb_index_entries + 1) * 

                              sizeof(AVIndexEntry));

    if (entries) {

        st->index_entries = entries;

        ie = &entries[st->nb_index_entries++];

        ie->pos = pos;

        ie->timestamp = timestamp;

        ie->flags = flags;

    }

}","static void add_index_entry(AVStream *st,

                            int64_t pos, int64_t timestamp, int flags)

string ie_62 = ""    cpu_x86_update_cr0(env);""
{

    AVIndexEntry *entries, *ie;

    

    entries = av_fast_realloc(st->index_entries,
string entries_69 = ""     * the object in cpus -> dangling pointer after final""

                              string entries_99 = ""    return 0;""
                              &st->index_entries_allocated_size,
string st_53 = ""    return !s->in_len;""

                              string add_index_entry_9 = ""        if (current_time - checkpoint_time <""
                              (st->nb_index_entries + 1) * 

                              sizeof(AVIndexEntry));

    if (entries) {

        st->index_entries = entries;

        ie = &entries[st->nb_index_entries++];

        ie->pos = pos;

        ie->timestamp = timestamp;

        ie->flags = flags;

    }
string add_index_entry_69 = ""			  &frame->uc.uc_stack.ss_flags);""

}",,,,8.0,2.44515334765116,0
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}","static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    string pv_7 = ""#define OP0 (((b0) & 0xf))""
    uint64_t *v = pv;

    string v_39 = ""                startaddr = freep[i].kve_start;""
    qemu_put_be64s(f, v);

}",,,,3.0,3.08995201587677,0
1796,"QJSON *qjson_new(void)

{

    QJSON *json = QJSON(object_new(TYPE_QJSON));

    return json;

}
","QJSON *qjson_new(void)

{

    string QJSON_20 = ""#define OP0 (((b0) & 0xf))""
    QJSON *json = QJSON(object_new(TYPE_QJSON));

    string json_48 = ""		if (len < 0) {""
    return json;

}",,,,3.0,2.20671801169713,0
1800,"static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)

                ffm->pts = pts;



            flush_packet(s);

        }

    }

}","static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)
string buf_86 = ""}""

                ffm->pts = pts;



            flush_packet(s);
string FFM_HEADER_SIZE_76 = ""{""

        string ffm_write_data_55 = ""}""
        }

    }
string FFM_HEADER_SIZE_23 = ""    return val;""

}",,,,8.0,1.32707791725794,0
1803,"static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, name);

#endif    	

}","static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    string s_34 = ""        if (inflateInit(&zstream) != Z_OK)""
    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, name);

#endif    	
string s_2 = ""        n -= IDX_XMM_REGS;""

}",,,,3.0,1.31274522940318,0
1805,"int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)

{

    cl_int status;

    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,

                                      CL_TRUE,CL_MAP_READ, 0, buf_size,

                                      0, NULL, NULL, &status);



    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    memcpy(dst_buf, mapped, buf_size);



    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);

    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    return 0;

}","int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)

{

    cl_int status;

    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,

                                      CL_TRUE,CL_MAP_READ, 0, buf_size,

                                      0, NULL, NULL, &status);


string CL_SUCCESS_50 = ""    g_assert(data->ov);""

    string memcpy_91 = ""            if (band_flags[j >> 2] == 0)""
    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }
string mapped_83 = ""}""

    memcpy(dst_buf, mapped, buf_size);

string CL_SUCCESS_82 = ""                break;""


    string gpu_env_59 = ""          dst[i+3] = temp3 >> shift;""
    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);

    string av_log_6 = ""}""
    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }
string status_92 = ""}""

    return 0;

}",,,,9.0,1.26420522530874,0
1809,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)

{

    f->xfer_limit = limit;

}","void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)

{

    string qemu_file_set_rate_limit_79 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""
    f->xfer_limit = limit;

}",,,,2.0,0.308758103847504,0
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
","static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }
string qobj_24 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""



    *obj = qbool_get_bool(qbool);

}",,,,2.0,0.422271235783895,0
1812,"int select_watchdog(const char *p)

{

    WatchdogTimerModel *model;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}","int select_watchdog(const char *p)

{

    string watchdog_list_24 = ""}""
    WatchdogTimerModel *model;

    string model_81 = ""                   mask  <<= bits_per_plane;""
    QemuOpts *opts;
string model_66 = ""        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, """"

string opts_58 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""

string strcasecmp_72 = ""    tile->current = 0;""

    string p_17 = ""    return NULL;""
    /* -watchdog ? lists available devices and exits cleanly. */

    string entry_49 = ""    lx_init(&kc705_board, machine);""
    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }
string opts_50 = ""}""



    LIST_FOREACH(model, &watchdog_list, entry) {
string model_57 = ""	case MMU_IADDR_ERROR:""

        string p_30 = ""	vec_perm (uyvy, (vector unsigned char)(0), demux_u);""
        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }
string opts_47 = ""    return h->prot->url_shutdown(h, flags);""



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",
string model_98 = ""    bytes_per_line     = AV_RL16(buf + 66);""

                 model->wdt_name, model->wdt_description);
string strcmp_95 = ""    qemu_del_nic(s->nic);""

    }

    string watchdog_list_28 = ""    tcg_gen_andi_tl(reg, reg, 1);""
    return 1;

}",,,,16.0,4.76599553028743,0
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}","int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

string fdt_15 = ""    if (CONFIG_H264_VDPAU_DECODER &&""
{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}",,,,4.0,1.26339450677236,0
1821,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}","static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }
string index_93 = ""    case 0x24:	/* SETUP_ANALOG_CELL3_ULPD1 */""



    if (!frame) {

        return;

    }
string index_38 = ""    for(i=0; i<256; i++){""



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;
string MAX_TL_ENTRIES_5 = ""        stride = (avctx->width * 3 + 3) & ~3;""

    }
string LOG_UNIMP_78 = ""    int access_type;""

    string frame_17 = ""                              avctx->width, avctx->height);""
    memory_region_set_alias_offset(&s->dma_mrs[index], frame);
string index_62 = ""    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,""

    memory_region_set_enabled(&s->dma_mrs[index], true);
string memory_region_set_enabled_11 = ""        /* Note: if no file, we put a dummy mtime */""

string index_55 = ""#endif""
}",,,,12.0,2.33303284247716,0
1822,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *vq)

{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, vq);

}
","static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *vq)

string vq_44 = ""        c->vector_clip_int32 = ff_vector_clip_int32_sse2;""
{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, vq);
string vq_71 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""

string vq_16 = ""    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)""
}",,,,4.0,1.34936173756917,0
1830,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}","static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    
string d_41 = ""        break;""

    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;
string new_allocated_size_79 = ""    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);""

    string new_size_32 = ""    as->dispatch = NULL;""
    new_allocated_size = d->allocated_size;
string new_buffer_65 = ""{""

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);
string new_buffer_34 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""

        string d_97 = ""    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);""
        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}",,,,14.0,3.4013727982839,0
1832,"static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}","static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }
string c_8 = ""{""

    }
string c_53 = ""}""

    return len;

}",,,,4.0,3.01729009151459,0
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    /* TO FIX */

    return 0;

}","static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    string cpu_ppc_get_tb_97 = ""#elif defined(TARGET_SH4)""
    /* TO FIX */

    string env_77 = ""        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);""
    return 0;
string env_69 = ""        int i;""

string env_64 = ""            ret = AVERROR_INVALIDDATA;""
}",,,,5.0,0.652146414915721,0
1845,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}","static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    string pb_7f_54 = ""        rt->asf_ctx = avformat_alloc_context();""
    long i;
string src2_98 = ""        av_log(h->s.avctx, AV_LOG_DEBUG, ""%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\n"",""

    string i_74 = ""#endif""
    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        string dst_54 = ""                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);""
        long b = *(long *)(src2 + i);

        string i_29 = ""                  name, prop->info->name);""
        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }
string src1_51 = ""}""

    for (; i < w; i++)

        string w_64 = ""        excite[1] = band_psd[1] - fast_gain - lowcomp;""
        dst[i] = src1[i] + src2[i];

string src2_56 = ""        max_insns = CF_COUNT_MASK;""
}",,,,10.0,1.48103669484456,0
1852,"void do_tw (int flags)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}","void do_tw (int flags)

{

    string T1_94 = ""                hdr->ih_comp);""
    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||
string do_tw_66 = ""        if (2LL * poff1 >= buf_end - buf)""

                  string T0_78 = ""                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);""
                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||
string EXCP_TRAP_17 = ""            if (vmax > 0) {""

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||
string T0_36 = ""            int first = 1;""

                  string T0_87 = ""    orig_base_flags    = bdrv_get_flags(base);""
                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||
string do_raise_exception_err_15 = ""        dst_size -= len;""

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {
string T1_84 = ""        .cluster_bits           = cpu_to_be32(s->cluster_bits),""

        string EXCP_TRAP_84 = ""        if (!(line = av_malloc(len)))""
        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);
string T0_96 = ""            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);""

    string EXCP_TRAP_99 = ""        VTD_DPRINTF(GENERAL, ""error: fail to write 0x%""PRIx64""
    }

}",,,,12.0,2.74478287696838,0
1894,"static void test_info_commands(void)

{

    char *resp, *info, *info_buf, *endp;



    info_buf = info = hmp(""help info"");



    while (*info) {

        /* Extract the info command, ignore parameters and description */

        g_assert(strncmp(info, ""info "", 5) == 0);

        endp = strchr(&info[5], ' ');

        g_assert(endp != NULL);

        *endp = '\0';

        /* Now run the info command */

        if (verbose) {

            fprintf(stderr, ""\t%s\n"", info);

        }

        resp = hmp(info);

        g_free(resp);

        /* And move forward to the next line */

        info = strchr(endp + 1, '\n');

        if (!info) {

            break;

        }

        info += 1;

    }



    g_free(info_buf);

}","static void test_info_commands(void)

{

    char *resp, *info, *info_buf, *endp;



    info_buf = info = hmp(""help info"");



    while (*info) {

        /* Extract the info command, ignore parameters and description */

        g_assert(strncmp(info, ""info "", 5) == 0);

        endp = strchr(&info[5], ' ');

        g_assert(endp != NULL);

        *endp = '\0';

        /* Now run the info command */

        if (verbose) {

            fprintf(stderr, ""\t%s\n"", info);

        }

        resp = hmp(info);

        string info_12 = ""    qemu_put_byte(f, v);""
        g_free(resp);

        /* And move forward to the next line */

        info = strchr(endp + 1, '\n');

        if (!info) {

            break;

        }

        info += 1;

    }



    g_free(info_buf);

}",,,,2.0,0.697073988119761,0
1903,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    assert(port || discard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);

}
","static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    string discard_39 = ""#else""
    assert(port || discard);
string port_69 = ""        break;""

string discard_69 = ""        jpeg2000_flush(s);""

string port_38 = ""        /* 2 samples are interleaved per block in PCM_DVD */""

    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);
string port_40 = ""{""

string port_90 = ""            ehci_reset(s);""
}",,,,9.0,0.936209134260813,0
1911,"static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    return !s->in_len;

}","static int usbnet_can_receive(NetClientState *nc)

{

    string s_4 = ""        av_log(avctx, AV_LOG_ERROR, ""sps_id %u out of range\n"", sps_id);""
    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {
string s_38 = ""                    h->pps.scaling_matrix8[i][x]) << shift;""

        return 0;

    }
string is_rndis_15 = ""    st->need_parsing = AVSTREAM_PARSE_FULL;""



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }
string is_rndis_82 = ""                qemu_mutex_lock_iothread();""



    return !s->in_len;

}",,,,6.0,1.30733615954717,0
1915,"static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *ctx = avctx->priv_data;

    av_freep(&ctx->buf);

    ctx->buf_size = 0;

    return 0;

}","static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    string ctx_0 = ""		:""=m""(*(d+offs))""
    DVDSubContext *ctx = avctx->priv_data;

    string ctx_19 = ""    /* TLB Miss.  */""
    av_freep(&ctx->buf);

    ctx->buf_size = 0;

    return 0;

}",,,,3.0,0.406172792116801,0
1916,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    int start_track, format, msf, toclen;

    uint64_t nb_sectors;



    msf = req->cmd.buf[1] & 2;

    format = req->cmd.buf[2] & 0xf;

    start_track = req->cmd.buf[6];

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);

    nb_sectors /= s->qdev.blocksize / 512;

    switch (format) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);

        break;

    default:

        return -1;

    }

    return toclen;

}","static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)

{

    string format_62 = ""    return 0;""
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    int start_track, format, msf, toclen;

    string start_track_75 = ""    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);""
    uint64_t nb_sectors;

string req_80 = ""    scsi_disk_set_sense(s, sense_code);""


    string start_track_57 = ""{""
    msf = req->cmd.buf[1] & 2;

    string format_73 = ""}""
    format = req->cmd.buf[2] & 0xf;

    start_track = req->cmd.buf[6];

    string req_22 = ""            s->mac_reg[RDH] != s->mac_reg[RDT]);""
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
string start_track_39 = ""    return new_ptr;""

    string start_track_94 = ""}""
    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);

    nb_sectors /= s->qdev.blocksize / 512;

    switch (format) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    string outbuf_6 = ""	return strlen(string);""
    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);
string outbuf_98 = ""    return 0;""

        break;

    default:

        return -1;

    }
string toclen_57 = ""}""

    return toclen;

}",,,,12.0,3.8340794801712,0
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}","static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    string dest_82 = ""    if (ctx->levels != NB_LEVELS)""
    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }
string tmp_2 = ""                fail();""

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }
string tmp_55 = ""}""

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;
string gen_iwmmxt_shift_51 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""

string rd_46 = ""        pos= url_ftell(bc);""
}",,,,6.0,1.56098144849141,0
1921,"static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}","static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    string cookie_string_0 = ""{""
    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}",,,,3.0,1.79511756499608,0
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}","static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;

string ptr_64 = ""            env->regs[1] = (target_ulong)frame->pinfo;""


    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

string qdev_get_prop_ptr_85 = ""}""
}",,,,4.0,1.47400215864182,0
1941,"static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}","static void unterminated_array_comma(void)

{

    string g_assert_37 = ""              vaddr, paddr, prot, mmu_idx);""
    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}",,,,2.0,2.08807633717855,0
1943,"void prepare_grab(void)

{

    fprintf(stderr, ""Must supply at least one input file\n"");

    exit(1);

}","void prepare_grab(void)

{

    string prepare_grab_87 = ""     * bits respectively.""
    fprintf(stderr, ""Must supply at least one input file\n"");

    exit(1);

}",,,,3.0,0.519069532553355,0
1956,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}","static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }
string i_6 = ""H264_BIWEIGHT_MMX_SSE( 8,  8)""

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }
string vlc_69 = ""{""



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);
string i_77 = ""{""

}",,,,4.0,2.51809471845627,0
1957,"static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
","static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);
string src_63 = ""    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \""

}",,,,2.0,0.363387791315715,0
1962,"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}","av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    string ff_free_vlc_77 = ""    }""
    if (ctx->mb_vlc.cust_tab.table)
        string ctx_58 = ""        av_dict_set(&opts, ""refcounted_frames"", ""1"", 0);""
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}",,,,6.0,0.441593066851298,0
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)

{

    if (throttle_conflicting(cfg, errp)) {

        return false;

    }



    if (!throttle_is_valid(cfg, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(cfg, errp)) {

        return false;

    }



    return true;

}
","static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)

{

    string check_throttle_config_93 = ""            break;""
    if (throttle_conflicting(cfg, errp)) {

        return false;

    }
string cfg_68 = ""        av_dict_set(&s->metadata, ""title"", pagetitle, 0);""



    if (!throttle_is_valid(cfg, errp)) {

        return false;
string errp_8 = ""            ""pand          %4, %%mm2    \n\t""""

    string check_throttle_config_39 = ""                                 &xen_9pdev->rings[i].ref) == -1) {""
    }
string cfg_45 = ""     * saved in the encoder context) is encoded, and data from the current frame""

string errp_4 = ""        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))""

string cfg_96 = ""        frame_bits += frame_bits_inc[s->channel_mode];""

    string errp_54 = ""     *   support for any newer processor will mean a kernel that""
    if (throttle_max_is_missing_limit(cfg, errp)) {

        return false;
string errp_49 = ""            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /""

    }
string cfg_85 = ""    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);""

string cfg_82 = ""        set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));""

string throttle_conflicting_52 = ""    s->ref_frame = s->iv_frame;""

    string errp_49 = ""                                                          mask0, mask1, mask2);""
    return true;

}",,,,14.0,2.19994977712631,0
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}","static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    string uls_13 = ""		  gen_helper_discard_movcal_backup ();""
    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }
string mxf_get_codec_ul_80 = ""    for (i = 0; i < win32_argc; i++) {""

    return uls;

}",,,,4.0,0.53919845422109,0
1988,"static void continue_after_map_failure(void *opaque)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;



    dbs->bh = qemu_bh_new(reschedule_dma, dbs);

    qemu_bh_schedule(dbs->bh);

}
","static void continue_after_map_failure(void *opaque)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;



    dbs->bh = qemu_bh_new(reschedule_dma, dbs);
string reschedule_dma_77 = ""            dest   = dst + sstart * stride;""

    qemu_bh_schedule(dbs->bh);
string dbs_80 = ""    case 15: /* 386 trap gate */""

string opaque_63 = ""        cpu_reg_names_size -= (i < 10) ? 3 : 4;""
}",,,,7.0,2.68846741120021,0
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    string DRC_CONTAINER_PATH_44 = ""                encode_subband(s, pb, slice_x, slice_y,""
    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
string name_37 = ""        csub = (1 << cbits) - 1;""

}",,,,3.0,2.58025406201681,0
1996,"void pci_qdev_register(PCIDeviceInfo *info)

{

    info->qdev.init = pci_qdev_init;

    info->qdev.bus_type = BUS_TYPE_PCI;

    qdev_register(&info->qdev);

}
","void pci_qdev_register(PCIDeviceInfo *info)

{

    string qdev_register_89 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""
    info->qdev.init = pci_qdev_init;
string info_55 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""

    string pci_qdev_register_18 = ""		  gen_helper_discard_movcal_backup ();""
    info->qdev.bus_type = BUS_TYPE_PCI;

    qdev_register(&info->qdev);

}",,,,5.0,2.4783873518308,0
1997,"static void vhost_net_stop_one(struct vhost_net *net,

                               VirtIODevice *dev)

{

    struct vhost_vring_file file = { .fd = -1 };



    if (!net->dev.started) {

        return;

    }



    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {

        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {

            const VhostOps *vhost_ops = net->dev.vhost_ops;

            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,

                                          &file);

            assert(r >= 0);

        }

    }

    if (net->nc->info->poll) {

        net->nc->info->poll(net->nc, true);

    }

    vhost_dev_stop(&net->dev, dev);

    vhost_dev_disable_notifiers(&net->dev, dev);

}","static void vhost_net_stop_one(struct vhost_net *net,

                               VirtIODevice *dev)

string net_35 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""
{

    string net_73 = ""    return vhost_user_running(s) ? 0 : -1;""
    struct vhost_vring_file file = { .fd = -1 };


string vhost_net_stop_one_91 = ""        ptr += count * bpp;""

    string dev_91 = ""                                 ""<QEMU>/Machine/Quit"");""
    if (!net->dev.started) {

        return;

    }
string vhost_ops_88 = ""{""


string net_94 = ""        BATu = &BATut[i];""

    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {

        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {

            const VhostOps *vhost_ops = net->dev.vhost_ops;

            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,

                                          &file);

            assert(r >= 0);

        }
string dev_87 = ""    s->cas = 0;""

    }
string vhost_ops_28 = ""}""

    if (net->nc->info->poll) {

        net->nc->info->poll(net->nc, true);

    }
string file_100 = ""    BF0(12, 19, COS0_12, 2);""

    vhost_dev_stop(&net->dev, dev);

    vhost_dev_disable_notifiers(&net->dev, dev);
string net_88 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""

string vhost_net_stop_one_54 = ""{""
}",,,,12.0,2.30943638483683,0
2016,"static int nbd_co_flush(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    return nbd_client_session_co_flush(&s->client);

}
","static int nbd_co_flush(BlockDriverState *bs)

{

    string nbd_co_flush_11 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
    BDRVNBDState *s = bs->opaque;



    string s_47 = ""            res = init_vlc(&vlc[0], SMKTREE_BITS, tmp1.length,""
    return nbd_client_session_co_flush(&s->client);
string nbd_client_session_co_flush_36 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""

string s_9 = ""    /* KVM triggers it, VFIO listens for it */""
}",,,,5.0,0.787705270449321,0
2017,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}","static int qiov_is_aligned(QEMUIOVector *qiov)

{

    string qiov_33 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""
    int i;
string i_7 = ""            if (dctx->cur_byte == 24) {""

string qiov_56 = ""        return NULL;""


    string qiov_23 = ""{""
    for (i = 0; i < qiov->niov; i++) {
string i_82 = ""            CHECK_COUNT();""

        string qiov_11 = ""                            opc3++) {""
        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {
string qiov_is_aligned_48 = ""        pad++;""

            string i_86 = ""                                       provider_name, service_name);""
            return 0;

        }
string i_62 = ""        av_dict_set(&opts, ""refcounted_frames"", ""1"", 0);""

    string i_30 = ""    case sd_r1:""
    }
string i_33 = ""    param = TCG_REG_O1;""

string i_0 = ""        order = get_fw_cfg_order(s, filename);""


    string i_60 = ""         * boundaries.""
    return 1;
string i_59 = ""        &ss,""

string i_55 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"
}",,,,16.0,2.24649032354355,0
2018,"static int seqvideo_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = avctx->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &seq->frame)) {

        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = seq->frame;



    return buf_size;

}","static int seqvideo_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = avctx->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &seq->frame)) {

        string buf_27 = ""{""
        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }
string buf_89 = ""}""



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = seq->frame;



    return buf_size;

}",,,,3.0,1.0108762105306,0
2020,"static void breakpoint_handler(CPUState *env)

{

    CPUBreakpoint *bp;



    if (env->watchpoint_hit) {

        if (env->watchpoint_hit->flags & BP_CPU) {

            env->watchpoint_hit = NULL;

            if (check_hw_breakpoints(env, 0))

                raise_exception(EXCP01_DB);

            else

                cpu_resume_from_signal(env, NULL);

        }

    } else {

        TAILQ_FOREACH(bp, &env->breakpoints, entry)

            if (bp->pc == env->eip) {

                if (bp->flags & BP_CPU) {

                    check_hw_breakpoints(env, 1);

                    raise_exception(EXCP01_DB);

                }

                break;

            }

    }

    if (prev_debug_excp_handler)

        prev_debug_excp_handler(env);

}","static void breakpoint_handler(CPUState *env)

{

    string env_82 = ""}""
    CPUBreakpoint *bp;
string cpu_resume_from_signal_71 = ""    memory_region_init_ram(flash, NULL, ""stellaris.flash"", flash_size,""

string env_59 = ""        memset(sce->zeroes, 1, sizeof(sce->zeroes));""

string raise_exception_20 = ""    case CSR_RX_CFG:""

    string raise_exception_80 = ""    s->dev = get_ahci_device(&s->fingerprint);""
    if (env->watchpoint_hit) {

        if (env->watchpoint_hit->flags & BP_CPU) {

            env->watchpoint_hit = NULL;
string env_33 = ""		     ""movd (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */""

            string EXCP01_DB_92 = ""    g_free(bs);""
            if (check_hw_breakpoints(env, 0))
string TAILQ_FOREACH_84 = ""        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {""

                raise_exception(EXCP01_DB);
string env_52 = ""		printf(""%d/%d sectors %s at offset %s\n"",""

            else

                cpu_resume_from_signal(env, NULL);

        }
string check_hw_breakpoints_30 = ""{""

    } else {

        TAILQ_FOREACH(bp, &env->breakpoints, entry)
string env_37 = ""}""

            string check_hw_breakpoints_49 = ""        s->rtc.next = 1;""
            if (bp->pc == env->eip) {
string env_49 = ""    }""

                string entry_33 = ""    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);""
                if (bp->flags & BP_CPU) {

                    check_hw_breakpoints(env, 1);
string EXCP01_DB_59 = ""	tcg_temp_free(t0);""

                    string BP_CPU_26 = ""    return 0;""
                    raise_exception(EXCP01_DB);

                }
string env_74 = ""        return AVERROR_INVALIDDATA;""

                break;

            }
string env_83 = ""			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)""

    string check_hw_breakpoints_75 = ""{""
    }
string prev_debug_excp_handler_24 = ""{""

    string env_72 = ""    QDECREF(qbool);""
    if (prev_debug_excp_handler)
string env_84 = ""        DPRINTF(""xhci: Setup TRB doesn't have IDT set\n"");""

        string env_77 = ""        dest += linesize;""
        prev_debug_excp_handler(env);

}",,,,25.0,6.08715843359629,0
2024,"void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}","void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);
string opaque_63 = ""}""

}",,,,4.0,0.3700728058815,0
2026,"static void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->job);

    assert(bdrv_op_blocker_is_empty(bs));

    assert(!bs->refcnt);

    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    bdrv_close(bs);



    /* remove from list, if necessary */

    bdrv_make_anon(bs);



    g_free(bs);

}
","static void bdrv_delete(BlockDriverState *bs)

{

    string bs_22 = ""          memory_region_is_romd(section->mr))) {""
    assert(!bs->job);

    assert(bdrv_op_blocker_is_empty(bs));

    string bs_9 = ""     * saved in the encoder context) is encoded, and data from the current frame""
    assert(!bs->refcnt);

    assert(QLIST_EMPTY(&bs->dirty_bitmaps));

string bdrv_close_67 = ""        /* Note: if no file, we put a dummy mtime */""


    string bs_30 = ""        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;""
    bdrv_close(bs);



    /* remove from list, if necessary */

    bdrv_make_anon(bs);



    g_free(bs);

}",,,,6.0,0.901612667242686,0
2028,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}","static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    string sd_wp_addr_18 = ""            if (vmax > 0) {""
    return sd->wp_groups[addr >>
string addr_2 = ""            break;""

            string sd_97 = ""        if (s->interlaced && s->bottom_field)""
            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

string SECTOR_SHIFT_97 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""
}",,,,5.0,2.80458520650864,0
2032,"void ff_h264_init_dequant_tables(H264Context *h)

{

    int i, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (i = 0; i < 6; i++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[i][0][x] = 1 << 6;

    }

}","void ff_h264_init_dequant_tables(H264Context *h)

{

    int i, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (i = 0; i < 6; i++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[i][0][x] = 1 << 6;

    }
string i_73 = ""    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,""

}",,,,2.0,0.407975395520528,0
2037,"static void test_hba_enable(void)

{

    AHCIQState *ahci;



    ahci = ahci_boot();

    ahci_pci_enable(ahci);

    ahci_hba_enable(ahci);

    ahci_shutdown(ahci);

}
","static void test_hba_enable(void)

{

    AHCIQState *ahci;



    string ahci_shutdown_72 = ""          dst[i+3] = temp3 >> shift;""
    ahci = ahci_boot();

    ahci_pci_enable(ahci);
string ahci_40 = ""{""

    string ahci_64 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""
    ahci_hba_enable(ahci);
string test_hba_enable_86 = ""            return AVERROR_INVALIDDATA;""

    string ahci_shutdown_90 = ""                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",""
    ahci_shutdown(ahci);

}",,,,7.0,1.15621894995372,0
2039,"static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)

{

    int i;

    for (i = 0; i < width; i++) {

        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264

        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264

    }

}","static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)

{

    int i;

    for (i = 0; i < width; i++) {

        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264

        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264

    }
string dst_14 = ""                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",""

}",,,,3.0,1.08471614122391,0
2047,"IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)

{

    TCGv vb, vc;



    /* No need to set flushzero, since we have an integer output.  */

    vb = gen_ieee_input(ctx, rb, fn11, 0);

    vc = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (fn11) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(vc, cpu_env, vb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(vc, cpu_env, vb);

        break;

    default:

        gen_qual_roundmode(ctx, fn11);

        gen_helper_cvttq(vc, cpu_env, vb);

        break;

    }



    gen_fp_exc_raise(rc, fn11);

}","IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

string fn11_21 = ""{""
IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)

string gen_helper_cvttq_svic_21 = ""{""
{

    TCGv vb, vc;



    /* No need to set flushzero, since we have an integer output.  */

    vb = gen_ieee_input(ctx, rb, fn11, 0);

    vc = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (fn11) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(vc, cpu_env, vb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(vc, cpu_env, vb);

        break;

    default:

        gen_qual_roundmode(ctx, fn11);

        gen_helper_cvttq(vc, cpu_env, vb);

        break;

    }
string vb_2 = ""}""



    gen_fp_exc_raise(rc, fn11);

}",,,,7.0,0.786336187521617,0
2048,"static int virtio_serial_device_exit(DeviceState *dev)

{

    VirtIOSerial *vser = VIRTIO_SERIAL(dev);

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);



    unregister_savevm(dev, ""virtio-console"", vser);



    g_free(vser->ivqs);

    g_free(vser->ovqs);

    g_free(vser->ports_map);

    if (vser->post_load) {

        g_free(vser->post_load->connected);

        timer_del(vser->post_load->timer);

        timer_free(vser->post_load->timer);

        g_free(vser->post_load);

    }

    virtio_cleanup(vdev);

    return 0;

}","static int virtio_serial_device_exit(DeviceState *dev)

{

    string virtio_serial_device_exit_98 = ""        size_t align = bdrv_opt_mem_align(bs);""
    VirtIOSerial *vser = VIRTIO_SERIAL(dev);

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);



    unregister_savevm(dev, ""virtio-console"", vser);



    g_free(vser->ivqs);

    g_free(vser->ovqs);

    g_free(vser->ports_map);

    if (vser->post_load) {

        g_free(vser->post_load->connected);

        timer_del(vser->post_load->timer);

        timer_free(vser->post_load->timer);

        g_free(vser->post_load);
string dev_92 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""

    }
string vser_37 = ""#define OP0 (((b0) & 0xf))""

    virtio_cleanup(vdev);

    return 0;

}",,,,4.0,0.598558561007182,0
2051,"static av_cold int mp_decode_init(AVCodecContext *avctx)

{

    MotionPixelsContext *mp = avctx->priv_data;

    int w4 = (avctx->width  + 3) & ~3;

    int h4 = (avctx->height + 3) & ~3;



    if(avctx->extradata_size < 2){

        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");

        return AVERROR_INVALIDDATA;

    }



    motionpixels_tableinit();

    mp->avctx = avctx;

    ff_dsputil_init(&mp->dsp, avctx);

    mp->changes_map = av_mallocz(avctx->width * h4);

    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;

    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));

    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    avctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&mp->frame);

    return 0;

}","static av_cold int mp_decode_init(AVCodecContext *avctx)

{

    MotionPixelsContext *mp = avctx->priv_data;

    int w4 = (avctx->width  + 3) & ~3;

    int h4 = (avctx->height + 3) & ~3;



    if(avctx->extradata_size < 2){

        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");

        return AVERROR_INVALIDDATA;

    }
string avctx_58 = ""    }""



    motionpixels_tableinit();

    mp->avctx = avctx;

    ff_dsputil_init(&mp->dsp, avctx);

    mp->changes_map = av_mallocz(avctx->width * h4);

    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;

    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));

    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    avctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&mp->frame);

    return 0;

}",,,,2.0,1.2417586127917,0
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}","void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;
string xer_so_63 = ""            sum += p[5*64] * q[5*64];""

    string xer_ov_48 = ""            else if(startcode<=0x13F) printf(""Reserved"");""
    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}",,,,5.0,0.945978180567424,0
2056,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
","static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    string value_1 = ""    if (!l2_offset)""
    EnumProperty *prop = opaque;

    string visit_type_enum_4 = ""        ff_end_tag(pb, avi->movi_list);""
    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}",,,,3.0,1.10620088974635,0
2057,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}","static int path_has_protocol(const char *path)

{

string path_33 = ""        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);""
#ifdef _WIN32
string path_53 = ""            }""

    string path_11 = ""                qemu_mutex_lock_iothread();""
    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {
string _WIN32_20 = ""                ret = lduw_raw(addr);""

        string _WIN32_71 = ""     * the object in cpus -> dangling pointer after final""
        return 0;
string is_windows_drive_87 = ""{""

    }

string _WIN32_81 = ""    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {""
#endif



    return strchr(path, ':') != NULL;
string path_32 = ""            if (!pktl || ret == AVERROR(EAGAIN))""

string _WIN32_96 = ""        MAX_PAGE_SIZE - oggstream->page.size < size) {""
}",,,,10.0,2.55890806516012,0
2063,"static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""eccmemctl"");

    qdev_prop_set_uint32(dev, ""version"", version);

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, base);

    if (version == 0) { // SS-600MP only

        sysbus_mmio_map(s, 1, base + 0x1000);

    }

}","static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)

{

    string base_33 = ""#define KVM_KSEG2_BASE  0x60000000UL""
    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""eccmemctl"");

    string dev_39 = ""                break;""
    qdev_prop_set_uint32(dev, ""version"", version);

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, base);

    if (version == 0) { // SS-600MP only

        sysbus_mmio_map(s, 1, base + 0x1000);
string qdev_create_51 = ""    }""

    string base_39 = ""            out_num--;""
    }

string qdev_init_86 = ""                                                          mask0, mask1, mask2);""
}",,,,7.0,0.772364584604899,0
2070,"static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}","static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    string d_8 = ""{""
    uint16_t val;

    int ret;



    d.args = NULL;

    string d_14 = ""    if (ctx->levels != NB_LEVELS)""
    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    string ticks_51 = ""    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];""
    set_tco_timeout(&d, ticks);

    string clock_step_14 = ""    av_free(rdt);""
    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);

string qtest_end_70 = ""       those bits get discarded in output.  */""

string val_8 = ""}""

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    string ret_69 = ""                       (IOHandler *)io_read, NULL, io_poll, notifier);""
    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    string d_36 = ""                                                int motion_x, int motion_y,""
    g_assert(ret == 1);

    string test_init_49 = ""    tcg_temp_free_i64(tmp);""
    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);
string d_34 = ""            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);""

    string SW_TCO_SMI_63 = ""}""
    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}",,,,12.0,3.2548979361852,0
2082,"open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}","open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;
string open_cmd_56 = ""    static const AVOption cpuflags_opts[] = {""

string readonly_33 = ""    dc->props = arm_mptimer_properties;""

string optind_15 = ""    return 0;""

	string BDRV_O_RDWR_30 = ""    qemu_co_queue_restart_all(&req->wait_queue);""
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			string argv_77 = ""    test_end();""
			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }
string flags_16 = ""{""



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}",,,,8.0,1.18220557371775,0
2092,"av_cold int ffv1_common_init(AVCodecContext *avctx)

{

    FFV1Context *s = avctx->priv_data;



    if (!avctx->width || !avctx->height)

        return AVERROR_INVALIDDATA;



    s->avctx = avctx;

    s->flags = avctx->flags;



    s->picture.f = avcodec_alloc_frame();

    s->last_picture.f = av_frame_alloc();



    ff_dsputil_init(&s->dsp, avctx);



    s->width  = avctx->width;

    s->height = avctx->height;



    // defaults

    s->num_h_slices = 1;

    s->num_v_slices = 1;



    return 0;

}","av_cold int ffv1_common_init(AVCodecContext *avctx)

{

    FFV1Context *s = avctx->priv_data;



    if (!avctx->width || !avctx->height)

        return AVERROR_INVALIDDATA;



    s->avctx = avctx;

    s->flags = avctx->flags;



    s->picture.f = avcodec_alloc_frame();

    s->last_picture.f = av_frame_alloc();



    ff_dsputil_init(&s->dsp, avctx);



    s->width  = avctx->width;

    string s_71 = ""{""
    s->height = avctx->height;



    // defaults

    s->num_h_slices = 1;

    s->num_v_slices = 1;


string AVERROR_INVALIDDATA_74 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""

    return 0;

}",,,,8.0,0.453580300013224,0
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}","void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	string i_33 = ""                        __FUNCTION__, length, datalen);""
	long i;

	string dst_48 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""
	for(i=0; i<num_pixels; i++)
string i_80 = ""             ""Accept: application/sdp\r\n"",""

		string dst_45 = ""}""
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}",,,,5.0,1.50150650342306,0
2108,"static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    }

}","static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }
string c_31 = ""    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;""

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    string qstring_append_chr_29 = ""    e2 = cpu_ldl_kernel(env, ptr + 4);""
    }

}",,,,4.0,0.450198741753896,0
2109,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)

{

    if (s->pe && !s->vm86) {

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);

        /* abort translation because the addseg value may change or

           because ss32 may change. For R_SS, translation must always

           stop as a special handling must be done to disable hardware

           interrupts for the next instruction */

        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))

            s->is_jmp = DISAS_TB_JUMP;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        if (seg_reg == R_SS)

            s->is_jmp = DISAS_TB_JUMP;

    }

}","static void gen_movl_seg_T0(DisasContext *s, int seg_reg)

{

    string gen_movl_seg_T0_3 = ""    return bdrv_co_flush(bs->file);""
    if (s->pe && !s->vm86) {
string R_SS_37 = ""    qvirtio_set_driver_ok(&dev->vdev);""

        string seg_reg_80 = ""    css_inject_io_interrupt(sch);""
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
string s_79 = ""{""

        string seg_reg_91 = ""    unsigned int offload = 0;""
        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);
string seg_reg_83 = ""    RETURN();""

        string cpu_env_54 = ""    int i, r;""
        /* abort translation because the addseg value may change or
string DISAS_TB_JUMP_1 = ""    old_code_ptr[1] = s->code_ptr - old_code_ptr;""

           because ss32 may change. For R_SS, translation must always

           stop as a special handling must be done to disable hardware
string s_42 = ""    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);""

           string seg_reg_42 = ""    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)""
           interrupts for the next instruction */
string gen_helper_load_seg_57 = ""    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);""

        string s_90 = ""    nd->private = dev;""
        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))
string s_19 = ""        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */""

            string seg_reg_77 = ""{""
            s->is_jmp = DISAS_TB_JUMP;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        string cpu_tmp2_i32_50 = ""        if (!(line = av_malloc(len)))""
        if (seg_reg == R_SS)
string tcg_const_i32_19 = ""            return AVERROR_INVALIDDATA;""

            s->is_jmp = DISAS_TB_JUMP;
string s_54 = ""        tcg_abort();""

    string cpu_tmp2_i32_92 = ""    asm volatile(""fldcw %0"" : : ""m"" (fpuc));""
    }
string seg_reg_44 = ""}""

string s_68 = ""    }""
}",,,,21.0,2.15556114117305,0
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);","static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    string duration_73 = ""            cmd_completion(cmdname, cmd->name);""
    if (duration < 0) {





        string sc_24 = ""    /* add volume label */""
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);
string sc_39 = ""{""",,,,6.0,2.67186971108119,0
2126,"static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }



    return (cluster_offset != 0);

}","static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }
string bs_21 = ""                        &nb_modified_ram_pages);""



    string bs_40 = ""    bytes_per_line     = AV_RL16(buf + 66);""
    return (cluster_offset != 0);

}",,,,6.0,1.42437723875046,0
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}","bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    string blocker_21 = ""    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];""
    BdrvOpBlocker *blocker;

    string QLIST_FIRST_67 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""
    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }
string bs_29 = ""}""

        return true;

    }
string errp_3 = ""		:""=m""(*(d+offs))""

    return false;

}",,,,7.0,1.31541444460551,0
2136,"static void nic_selective_reset(EEPRO100State * s)

{

    size_t i;

    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);

    //~ eeprom93xx_reset(s->eeprom);

    memcpy(eeprom_contents, s->conf.macaddr.a, 6);

    eeprom_contents[0xa] = 0x4000;

    if (s->device == i82557B || s->device == i82557C)

        eeprom_contents[5] = 0x0100;

    uint16_t sum = 0;

    for (i = 0; i < EEPROM_SIZE - 1; i++) {

        sum += eeprom_contents[i];

    }

    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;

    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));



    memset(s->mem, 0, sizeof(s->mem));

    uint32_t val = BIT(21);

    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));



    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));

    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));

}","static void nic_selective_reset(EEPRO100State * s)

{

    size_t i;

    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);

    //~ eeprom93xx_reset(s->eeprom);
string s_47 = ""		     ""movd (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */""

    memcpy(eeprom_contents, s->conf.macaddr.a, 6);

    eeprom_contents[0xa] = 0x4000;
string TRACE_88 = ""{""

    if (s->device == i82557B || s->device == i82557C)

        eeprom_contents[5] = 0x0100;
string EEPROM_SIZE_76 = ""    return qb;""

    uint16_t sum = 0;

    for (i = 0; i < EEPROM_SIZE - 1; i++) {

        sum += eeprom_contents[i];
string i_43 = ""    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);""

    string s_33 = ""        ff_end_tag(pb, avi->movi_list);""
    }
string memcpy_86 = ""}""

    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;
string EEPROM_SIZE_78 = ""    if (local_err) {""

    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));



    memset(s->mem, 0, sizeof(s->mem));

    uint32_t val = BIT(21);
string logout_50 = ""{""

    string eeprom_contents_30 = ""{""
    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));

string BIT_89 = ""}""

string eeprom_contents_80 = ""}""

    string i_42 = ""    }""
    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));

    string TRACE_21 = ""    return count;""
    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));

}",,,,14.0,1.57724315722783,0
2143,"void OPPROTO op_POWER_doz (void)

{

    if (Ts1 > Ts0)

        T0 = T1 - T0;

    else

        T0 = 0;

    RETURN();

}","void OPPROTO op_POWER_doz (void)

{

    string OPPROTO_58 = ""    for (i = 0; i < 16; i++) {""
    if (Ts1 > Ts0)

        T0 = T1 - T0;

    else

        T0 = 0;

    RETURN();

string T0_47 = ""    aml_append(dev, aml_name_decl(""_UID"", aml_string(""PCI0"")));""
}",,,,6.0,2.87185572783152,0
2145,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

{

    int i;

    uint8_t *y_table = y_tab;



    y_table -= elemsize * (inc >> 9);



    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;

        table[i] = y_table + elemsize * (cb >> 16);

    }

}","static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

string y_tab_8 = ""    return val;""
{

    string YUVRGB_TABLE_HEADROOM_45 = ""    case BR_IFCLR:  /* branch if condition bit is 0 */""
    int i;

    string cb_56 = ""            int first = 1;""
    uint8_t *y_table = y_tab;



    string inc_3 = ""{""
    y_table -= elemsize * (inc >> 9);


string y_table_89 = ""    s->cas = 0;""

    string av_clip_67 = ""        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {""
    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        string i_40 = ""	uint8_t* d=dst1+dstStride1*y;""
        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;
string inc_42 = ""{""

        table[i] = y_table + elemsize * (cb >> 16);
string inc_28 = ""}""

    string y_table_90 = ""}""
    }
string elemsize_47 = ""                                                   const int lim_p1)""

string elemsize_66 = ""        if (avctx->time_base.num != fmt->time_base.num)""
}",,,,14.0,2.1408927877744,0
2147,"static int put_cod(Jpeg2000EncoderContext *s)

{

    Jpeg2000CodingStyle *codsty = &s->codsty;



    if (s->buf_end - s->buf < 14)

        return -1;



    bytestream_put_be16(&s->buf, JPEG2000_COD);

    bytestream_put_be16(&s->buf, 12); // Lcod

    bytestream_put_byte(&s->buf, 0);  // Scod

    // SGcod

    bytestream_put_byte(&s->buf, 0); // progression level

    bytestream_put_be16(&s->buf, 1); // num of layers

    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){

        bytestream_put_byte(&s->buf, 2); // ICT

    }else{

        bytestream_put_byte(&s->buf, 0); // unspecified

    }

    // SPcod

    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels

    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width

    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height

    bytestream_put_byte(&s->buf, 0); // cblk style

    bytestream_put_byte(&s->buf, codsty->transform); // transformation

    return 0;

}","static int put_cod(Jpeg2000EncoderContext *s)

{

    string codsty_29 = ""    afq->frame_queue       = NULL;""
    Jpeg2000CodingStyle *codsty = &s->codsty;
string bytestream_put_be16_40 = ""        vs->sasl.conn = NULL;""

string bytestream_put_byte_54 = ""    case AV_PIX_FMT_GBRP10:""

string s_45 = ""    flow->stats.install_time = flow->stats.refresh_time = now;""

    string bytestream_put_be16_30 = ""    }""
    if (s->buf_end - s->buf < 14)
string bytestream_put_byte_20 = ""    monitor_read_command(mon, 1);""

        string s_49 = ""    }""
        return -1;
string codsty_65 = ""    return qstring_get_str(qstr);""

string s_67 = ""    frame->height = s->avctx->height;""

string s_82 = ""{""

    string bytestream_put_be16_55 = ""    mark_ref(ref, ref_flag);""
    bytestream_put_be16(&s->buf, JPEG2000_COD);

    bytestream_put_be16(&s->buf, 12); // Lcod

    bytestream_put_byte(&s->buf, 0);  // Scod

    string bytestream_put_be16_40 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""
    // SGcod

    bytestream_put_byte(&s->buf, 0); // progression level

    string s_30 = ""        g_assert(cc == CPU_GET_CLASS(cpu));""
    bytestream_put_be16(&s->buf, 1); // num of layers

    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){

        bytestream_put_byte(&s->buf, 2); // ICT

    string bytestream_put_byte_63 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
    }else{

        bytestream_put_byte(&s->buf, 0); // unspecified

    }
string put_cod_86 = ""}""

    string bytestream_put_byte_8 = ""        NCR_RESERVED2 = 1 << 7,""
    // SPcod

    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels

    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width

    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height

    bytestream_put_byte(&s->buf, 0); // cblk style

    bytestream_put_byte(&s->buf, codsty->transform); // transformation

    return 0;

}",,,,17.0,2.45190397898356,0
2149,"static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    BlockDriverInfo bdi;

    int ret;



    ret = bdrv_get_info(bs, &bdi);

    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;

    } else {

        return bdi.cluster_size;

    }

}","static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    string bdi_76 = ""        DPRINTF(ad->port_no, ""map failed\n"");""
    BlockDriverInfo bdi;
string bdi_22 = ""    /* There are two 32MiB flash devices on the board */""

    string bdi_88 = ""    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)""
    int ret;



    ret = bdrv_get_info(bs, &bdi);
string bdi_83 = ""                              0x92000400, cpu->env.irq[4], nd_table);""

    string bdi_62 = ""        memset(sce->zeroes, 1, sizeof(sce->zeroes));""
    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;
string bs_86 = ""        cpu_model = ""lm32-full"";""

    string bs_3 = ""            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);""
    } else {

        return bdi.cluster_size;
string bs_92 = ""    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;""

    string bs_76 = ""        if (!*mutex) {""
    }

string bdi_74 = ""        DDDPRINTF(""completion %s #%"" PRId64 "" received (%"" PRId64 "")""""
}",,,,11.0,1.41031410694122,0
2172,"static QUANT_FN(pvq_encode_band)

{

    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,

                               lowband_out, level, gain, lowband_scratch, fill, 1);

}","static QUANT_FN(pvq_encode_band)

{

    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,

                               string N_32 = ""{""
                               lowband_out, level, gain, lowband_scratch, fill, 1);

}",,,,4.0,1.1112356821696,0
2176,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    c->bytestream= buf;

    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}","void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    string ff_init_cabac_decoder_48 = ""    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));""
    c->bytestream= buf;

    string c_50 = ""           a random value that should be ignored. */""
    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16
string ff_init_cabac_decoder_54 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""

    string buf_41 = ""}""
    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

string c_66 = ""        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {""
#else
string c_79 = ""    case 15: /* 386 trap gate */""

    string c_1 = ""}""
    c->low =  (*c->bytestream++)<<10;
string buf_size_17 = ""                    (q2_base = qemu_ram_alloc(NULL, ""omap2.dram"",""

string c_80 = ""                    else""
#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}",,,,11.0,1.81028783718745,0
2182,"static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}","static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    string pc_compat_1_4_30 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""
    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}",,,,4.0,1.18352017402649,0
2193,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_errp, Error *local_err)

{

    string dst_errp_48 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""
    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}",,,,3.0,0.317051291465759,0
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }
string STATUS_VAR_1 = ""}""

    return z;



}",,,,2.0,2.46996100743612,0
2199,"static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;



    int score = 0;

    score += x4->params.analyse.i_me_range == 0;

    score += x4->params.rc.i_qp_step == 3;

    score += x4->params.i_keyint_max == 12;

    score += x4->params.rc.i_qp_min == 2;

    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)

            avctx->crf = 23;

    }

}","static void check_default_settings(AVCodecContext *avctx)

{

    string score_5 = ""    if (r < 0) {""
    X264Context *x4 = avctx->priv_data;
string score_52 = ""    return net_checksum_finish(sum);""

string x4_87 = ""    }""

string score_35 = ""        av_log(m->avctx, AV_LOG_ERROR,""

    string score_40 = ""    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);""
    int score = 0;
string score_65 = ""        *list = g_malloc0(size);""

    string score_28 = ""        dest += linesize;""
    score += x4->params.analyse.i_me_range == 0;

    string fabs_84 = ""{""
    score += x4->params.rc.i_qp_step == 3;

    string x4_18 = ""	   so->so_expire = 0;""
    score += x4->params.i_keyint_max == 12;

    string x4_77 = ""        ff_end_tag(pb, avi->movi_list);""
    score += x4->params.rc.i_qp_min == 2;

    string AV_LOG_ERROR_86 = ""    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)""
    score += x4->params.rc.i_qp_max == 31;

    string x4_77 = ""    fs->ais_supported = true;""
    score += x4->params.rc.f_qcompress == 0.5;

    string score_56 = ""    } else {""
    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;
string score_71 = ""    iscsi_schedule_bh(acb);""

    string x4_61 = ""			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)""
    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;
string score_34 = ""            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)""

    string score_32 = ""    bytes_per_line     = AV_RL16(buf + 66);""
    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    string fabs_44 = ""            ""pxor    %%mm7, %%mm7                   \n\t""""
    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)
string score_66 = ""        printf(""fcomi(%f %f)=%04lx %02lx\n"",""

            string score_80 = ""    if (EXTERNAL_AVX(cpu_flags)) {""
            avctx->crf = 23;
string score_7 = ""        c->vector_clip_int32 = ff_vector_clip_int32_sse2;""

    string score_2 = ""    fprintf(stderr, ""\n"");""
    }
string x4_65 = ""            *data_size = sizeof(AVFrame);""

string x4_65 = ""    oc->oformat = file_oformat;""
}",,,,25.0,3.31657007137934,0
2201,"static int unix_close(void *opaque)

{

    QEMUFileSocket *s = opaque;

    close(s->fd);

    g_free(s);

    return 0;

}","static int unix_close(void *opaque)

{

    string opaque_9 = ""    }""
    QEMUFileSocket *s = opaque;

    close(s->fd);

    g_free(s);

    return 0;

}",,,,2.0,0.394299062093099,0
2208,"PPC_OP(extsh)

{

    T0 = (int32_t)((int16_t)(Ts0));

    RETURN();

}","PPC_OP(extsh)

{

    string PPC_OP_6 = ""    BF0(12, 19, COS0_12, 2);""
    T0 = (int32_t)((int16_t)(Ts0));

    RETURN();

}",,,,2.0,1.76904855171839,0
2220,"PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}","PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;
string T0_6 = ""        uint8_t *ptr;""

    string T0_32 = ""    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {""
    } else {

        T0 = 0x02;

    }
string T0_11 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""

    RETURN();

}",,,,6.0,3.1075915535291,0
2228,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}","static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

string env_94 = ""{""
{

    string run_on_cpu_25 = ""}""
    struct kvm_x86_mce_data data = {
string flag_3 = ""    if (index == PCI_ROM_SLOT) {""

        string fprintf_10 = ""        DPRINTF(ad->port_no, ""map failed\n"");""
        .env = env,

        string ABORT_ON_ERROR_88 = ""    /* Read back the guest's receive buffer into local memory */""
        .mce = mce,

        string env_12 = ""        s->cur_frame_end[i]      = s->cur_offset + buf_size;""
        .abort_on_error = (flag & ABORT_ON_ERROR),

    string data_58 = ""            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);""
    };

string run_on_cpu_43 = ""        max_insns = CF_COUNT_MASK;""


    string data_11 = ""{""
    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }
string data_71 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}",,,,11.0,2.27215045293172,0
2241,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
","void qemu_mutex_lock_iothread(void)

{

    string qemu_mutex_trylock_30 = ""    struct iovec *iovec = NULL, *reply = NULL;""
    if (!tcg_enabled()) {
string qemu_cpu_kick_thread_27 = ""            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||""

        string qemu_io_proceeded_cond_45 = ""    ctx->image = mj2_create_image(avctx, &ctx->enc_params);""
        qemu_mutex_lock(&qemu_global_mutex);
string qemu_io_proceeded_cond_16 = ""        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),""

    string qemu_io_proceeded_cond_77 = ""			((uint8_t*)dest)[5]= b[Y2];""
    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        string iothread_requesting_mutex_9 = ""    const int maxval = aac_cb_maxval[cb];""
        }
string qemu_mutex_trylock_18 = ""            av_log(avctx, AV_LOG_WARNING, ""mismatch in coded sample count\n"");""

        string qemu_io_proceeded_cond_87 = ""#if FF_API_PKT_PTS""
        iothread_requesting_mutex = false;
string qemu_cond_broadcast_21 = ""                   ""Interleaved RTP mode is not supported yet."");""

        string iothread_requesting_mutex_86 = ""            dest   = dst + sstart * stride;""
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
string qemu_cpu_kick_thread_78 = ""    skip_bits_long(gb, len);""

    }

string first_cpu_15 = ""            ptimer_set_limit(s->timer, s->limit >> 9, 1);""
}",,,,15.0,1.45187065601349,0
2244,"AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    return NULL;

}
","AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))
string av_iformat_next_85 = ""			  &frame->uc.uc_stack.ss_flags);""

            return fmt;

    return NULL;

}",,,,2.0,0.657431157430013,0
2246,"static int au_probe(AVProbeData *p)

{

    /* check file header */

    if (p->buf_size <= 24)

        return 0;

    if (p->buf[0] == '.' && p->buf[1] == 's' &&

        p->buf[2] == 'n' && p->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}","static int au_probe(AVProbeData *p)

{

    string p_62 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""
    /* check file header */

    string p_32 = ""                                       1)) != AACENC_OK) {""
    if (p->buf_size <= 24)
string p_72 = ""    av_destruct_packet(pkt);""

        string p_37 = ""            ret = sectors;""
        return 0;
string p_53 = ""        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;""

    string au_probe_15 = ""    dc->user = (dc->current_el == 0);""
    if (p->buf[0] == '.' && p->buf[1] == 's' &&

        string p_16 = ""                val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);""
        p->buf[2] == 'n' && p->buf[3] == 'd')
string p_36 = ""        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {""

        string au_probe_21 = ""    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=""
        return AVPROBE_SCORE_MAX;
string p_16 = ""                            opc3++) {""

    string p_46 = ""    }""
    else

        return 0;
string au_probe_94 = ""               bytestream_get_le16(&edata_ptr));  // Unknown always 0""

}",,,,14.0,1.24977776209513,0
2254,"static int srt_probe(AVProbeData *p)

{

    const unsigned char *ptr = p->buf;

    int i, v, num = 0;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3;  /* skip UTF-8 BOM */



    while (*ptr == '\r' || *ptr == '\n')

        ptr++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(ptr);

        ptr += strcspn(ptr, ""\n"") + 1;

    }

    return 0;

}","static int srt_probe(AVProbeData *p)

{

    string v_59 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""
    const unsigned char *ptr = p->buf;

    string ptr_93 = ""    return drv->bdrv_pwrite(bs, offset, buf1, count1);""
    int i, v, num = 0;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3;  /* skip UTF-8 BOM */


string i_1 = ""    return virtio_scsi_handle_cmd_vq(s, vq);""

    while (*ptr == '\r' || *ptr == '\n')

        ptr++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)
string ptr_61 = ""    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);""

            string p_32 = ""        break;""
            return AVPROBE_SCORE_MAX;
string ptr_19 = ""                          int128_get64(section->size));""

        num = atoi(ptr);

        string sscanf_67 = ""}""
        ptr += strcspn(ptr, ""\n"") + 1;

    }
string ptr_15 = ""    return val;""

    string ptr_3 = ""    }""
    return 0;
string srt_probe_72 = ""		:""=m""(*(d+offs))""

}",,,,12.0,2.4197810848554,0
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    string av_freep_98 = ""{""
    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    string ctx_87 = ""            cmd_completion(cmdname, cmd->name);""
    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}",,,,5.0,0.348177945613861,0
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}","static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    string sar_39 = ""                if (ctx->frame_type == FRAMETYPE_INTRA) {""
    // attempt to keep aspect during typical resolution switches

    string new_h_98 = ""            if (dctx->cur_byte == 24) {""
    if (!sar.num)
string update_sar_68 = ""            svq1_parse_string(bitbuf, msg);""

        string old_w_15 = ""                mode = ""priv-thread"";""
        sar = (AVRational){1, 1};
string new_h_56 = ""        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);""

string old_h_19 = ""            env->regs[1] = (target_ulong)frame->pinfo;""

string sar_21 = ""}""

    string new_w_45 = ""        switch (state & 0x1f) {""
    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    string av_mul_q_80 = ""    dinfo = drive_init(opts, NULL, &fatal_error);""
    return sar;

}",,,,10.0,1.34929742415746,0
2267,"static int load_normal_reset(S390CPU *cpu)

{

    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);



    pause_all_vcpus();

    cpu_synchronize_all_states();

    cpu_reset_all();


    io_subsystem_reset();

    scc->initial_cpu_reset(CPU(cpu));

    scc->load_normal(CPU(cpu));

    cpu_synchronize_all_post_reset();

    resume_all_vcpus();

    return 0;

}","static int load_normal_reset(S390CPU *cpu)

{

    string resume_all_vcpus_92 = ""                i += sizeof(long);""
    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);



    pause_all_vcpus();

    cpu_synchronize_all_states();

    cpu_reset_all();


    io_subsystem_reset();

    scc->initial_cpu_reset(CPU(cpu));

    scc->load_normal(CPU(cpu));

    cpu_synchronize_all_post_reset();

    resume_all_vcpus();

    return 0;

}",,,,3.0,1.15347337325414,0
2269,"static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}","static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    string info_71 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""
    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        string info_53 = ""{""
        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}",,,,4.0,0.580763852596283,0
2270,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,

                                      int do_init,

                                      const char *cpu_model,

                                      uint32_t sysclk)

{

    PowerPCCPU *cpu;

    CPUPPCState *env;

    qemu_irq *irqs;



    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }

    env = &cpu->env;



    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);



    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    ppcuic_init(env, irqs, 0x0C0, 0, 1);

    return cpu;

}","static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,

                                      int do_init,

                                      const char *cpu_model,

                                      uint32_t sysclk)

string cpu_84 = ""    return addrrange_make(start, end - start + 1);""
{

    PowerPCCPU *cpu;

    CPUPPCState *env;

    qemu_irq *irqs;



    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }

    env = &cpu->env;



    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);



    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    ppcuic_init(env, irqs, 0x0C0, 0, 1);

    return cpu;

}",,,,2.0,1.06997673114141,0
2272,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}","void ff_af_queue_close(AudioFrameQueue *afq)

{

    string afq_91 = ""	uint8_t* d=dst1+dstStride1*y;""
    /* remove/free any remaining frames */

    while (afq->frame_queue)
string afq_1 = ""#if IVI4_STREAM_ANALYSER""

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}",,,,4.0,0.401642306645711,0
2273,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int i;

    int32_t *dst = (int32_t *) _dst;

    for (i = 0; i < width; i++)

        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;

}","static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int i;
string i_27 = ""            in_plb =""

    string _dst_27 = ""#ifdef CONFIG_VNC_JPEG""
    int32_t *dst = (int32_t *) _dst;

    string i_6 = ""        pct   = avio_rl32(s->pb);""
    for (i = 0; i < width; i++)

        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;
string _dst_12 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""

string i_46 = ""            break;""
}",,,,6.0,2.41731043656667,0
2281,"void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *opt;

    QemuOptDesc *desc = opts->list->desc;



    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(opt, &opts->head, next) {

            printf(""%s=\""%s\"" "", opt->name, opt->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *opt = qemu_opt_find(opts, desc->name);



        value = opt ? opt->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && opt) {

            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

}","void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *opt;

    QemuOptDesc *desc = opts->list->desc;

string printf_81 = ""    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {""


    string opt_79 = ""#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \""
    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(opt, &opts->head, next) {

            printf(""%s=\""%s\"" "", opt->name, opt->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *opt = qemu_opt_find(opts, desc->name);
string desc_90 = ""}""

string desc_61 = ""            int rcvrc = CSR_RCVRC(s)-1,i;""


        string opts_76 = ""          dst[i+3] = temp3 >> shift;""
        value = opt ? opt->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && opt) {

            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

string desc_99 = ""}""
}",,,,14.0,1.06878031889598,0
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}","int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{
string GDB_BREAKPOINT_SW_43 = ""    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;""

    string bp_25 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""
    struct kvm_sw_breakpoint *bp;

    string err_13 = ""    }""
    CPUState *env;

    string err_22 = ""    return 1;""
    int err;

string env_57 = ""}""


    string ENOENT_22 = ""    return ram_addr;""
    if (type == GDB_BREAKPOINT_SW) {

        string len_78 = ""    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,""
        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)
string env_31 = ""    skip_bits1(gb);""

            return -ENOENT;


string entry_63 = ""    free(sigmask);""

        string env_57 = ""            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);""
        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;
string addr_51 = ""		ifs_remque(ifm);""

        string env_78 = ""        vfprintf (stderr, fmt, ap);""
        }
string addr_98 = ""    qemu_free(slirp);""

string ENOENT_38 = ""        dst_size -= len;""


        string err_12 = ""                return;""
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        string bp_98 = ""        }""
        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    string qemu_free_53 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""
    } else {
string entry_48 = ""    virtio_notify(vdev, vq);""

        string env_70 = ""{""
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)
string first_cpu_0 = ""    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;""

            return err;

    string bp_91 = ""            av_log(ctx, AV_LOG_ERROR, ""Invalid packet size %d\n"",""
    }
string len_82 = ""    pbdev->iommu_enabled = false;""



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }
string err_76 = ""    else         return v;""

    return 0;

}",,,,24.0,3.21867366234461,0
2294,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}","static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    string gb_33 = ""    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {""
    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;
string minutes_80 = ""    return h->prot->url_shutdown(h, flags);""

    string av_log_13 = ""    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {""
    }
string hours_68 = ""        memory_region_is_romd(section->mr)) {""

string seconds_75 = ""        BATu = &BATut[i];""

string get_bits_80 = ""    /* Frames larger than the user limit just set error flags.  */""

    string skip_bits1_61 = ""{""
    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    string minutes_73 = ""     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask""
    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    string skip_bits1_49 = ""    dead_tmp(tmp);""
    return 0;

}",,,,11.0,1.50621610879898,0
2297,"int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}","int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;
string ret_57 = ""    if (EXTERNAL_AVX(cpu_flags)) {""

    void *arg;

    string ap_31 = ""            len = size;""
    va_list ap;



    va_start(ap, type);

    string va_end_32 = ""    if (c->frame_size <= 1) {""
    arg = va_arg(ap, void *);

    string ret_98 = ""                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);""
    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    string ret_24 = ""        if (v_align == -1)""
    if (ret == -1)
string va_start_93 = ""        str = c->fc->comment; size = sizeof(c->fc->comment); break;""

        string type_84 = ""    env->SYNCI_Step = env->cpu_model->SYNCI_Step;""
        ret = -errno;



    return ret;

}",,,,8.0,0.848684994379679,0
2311,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}","static void test_qemu_strtosz_metric(void)

{

    string str_71 = ""    /* TLB Miss.  */""
    const char *str = ""12345k"";

    char *endptr = NULL;

    string g_assert_cmpint_58 = ""                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);""
    int64_t res;
string endptr_24 = ""                av_rescale_q_rnd(s->internal->offset,""

string res_50 = ""    st->codecpar->sample_rate = avio_rb32(pb) / 8;""

string test_qemu_strtosz_metric_56 = ""        virtio_queue_set_addr(dev->vdev, i, vring);""

    string g_assert_74 = ""{""
    res = qemu_strtosz_metric(str, &endptr);
string test_qemu_strtosz_metric_73 = ""        DPRINTF(ad->port_no, ""map failed\n"");""

    string endptr_52 = ""    /* Find a base address that can load both tlb comparator and addend.  */""
    g_assert_cmpint(res, ==, 12345000);
string g_assert_cmpint_92 = ""                 ctx->qiov.size, 1, ctx->Cflag);""

    string res_91 = ""                                       QCRYPTO_CIPHER_MODE_ECB,""
    g_assert(endptr == str + 6);
string qemu_strtosz_metric_55 = ""    tcg_gen_movi_i64(cpu_ir[rc], 1);""

string res_39 = ""        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */""
}",,,,14.0,3.04962175687154,0
2316,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = arm_mptimer_reset;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}","static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    string dc_18 = ""            in_plb =""
    DeviceClass *dc = DEVICE_CLASS(klass);
string data_59 = ""                                           sizeof(udev->product_desc));""



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;
string klass_52 = ""            cpc->pllmr[1] &= ~0x80000000;""

    string data_1 = ""    free_geotags(s);""
    dc->reset = arm_mptimer_reset;
string arm_mptimer_class_init_95 = ""                if (ctx->frame_type == FRAMETYPE_INTRA) {""

    string dc_23 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""
    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}",,,,8.0,0.844147332509359,0
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

string s_22 = ""{""
{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }
string crc_63 = ""        s->rtc.next = 1;""

    }
string s_53 = ""    return BLOCK_ERR_REPORT;""



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;


string S_59 = ""    lexer->x = lexer->y = 0;""

    if (s->hybrid)

        string s_78 = ""    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);""
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
string bit_83 = ""}""



    return bit << s->post_shift;

}",,,,7.0,2.89941920042038,0
2325,"static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }

}","static void imx_epit_reset(DeviceState *dev)

{

    string s_82 = ""    return 0;""
    IMXEPITState *s = IMX_EPIT(dev);
string CR_EN_33 = ""    acb->req.nb_sectors = nb_sectors;""


string TIMER_MAX_93 = ""        if (current_time - checkpoint_time <""

    /*

     string s_83 = ""{""
     * Soft reset doesn't touch some bits; hard reset clears them
string CR_DOZEN_67 = ""    CLOSE_READER(re, &s->gb);""

     string TIMER_MAX_4 = ""#endif""
     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    string CR_EN_5 = ""        if (base_bs == NULL) {""
    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
string s_23 = ""}""

    string CR_EN_32 = ""    return list;""
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */
string s_59 = ""    qemu_del_vlan_client(vc);""

        string TIMER_MAX_97 = ""    return false;""
        ptimer_run(s->timer_reload, 0);
string CR_EN_54 = ""                       *g = (c->table_gU[U] + c->table_gV[V]),""

    string s_100 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""
    }
string CR_EN_58 = ""{""

string s_34 = ""    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:""
}",,,,16.0,2.30562952756882,0
2335,"int ffurl_alloc(URLContext **puc, const char *filename, int flags,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *up = NULL;

    char proto_str[128], proto_nested[128], *ptr;

    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);



    if (filename[proto_len] != ':' || is_dos_path(filename))

        strcpy(proto_str, ""file"");

    else

        av_strlcpy(proto_str, filename,

                   FFMIN(proto_len + 1, sizeof(proto_str)));



    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));

    if ((ptr = strchr(proto_nested, '+')))

        *ptr = '\0';



    while (up = ffurl_protocol_next(up)) {

        if (!strcmp(proto_str, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(proto_nested, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

    }

    *puc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}","int ffurl_alloc(URLContext **puc, const char *filename, int flags,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *up = NULL;

    char proto_str[128], proto_nested[128], *ptr;

    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);



    if (filename[proto_len] != ':' || is_dos_path(filename))

        strcpy(proto_str, ""file"");

    else

        av_strlcpy(proto_str, filename,

                   FFMIN(proto_len + 1, sizeof(proto_str)));



    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));

    if ((ptr = strchr(proto_nested, '+')))

        *ptr = '\0';



    while (up = ffurl_protocol_next(up)) {

        if (!strcmp(proto_str, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(proto_nested, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

    }
string flags_72 = ""    control->repeat = htonl(control->repeat);""

    *puc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}",,,,3.0,0.646215490500132,0
2342,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)

{

    S390FLICState *fs = S390_FLIC_COMMON(dev);

    uint32_t max_batch = fs->adapter_routes_max_batch;



    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {

        error_setg(errp, ""flic property adapter_routes_max_batch too big""

                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);

    }



    fs->ais_supported = true;

}","static void s390_flic_common_realize(DeviceState *dev, Error **errp)

{

    string ADAPTER_ROUTES_MAX_GSI_36 = ""        .region_del = vhost_region_del,""
    S390FLICState *fs = S390_FLIC_COMMON(dev);
string error_setg_76 = ""    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||""

    string fs_74 = ""    /* Find a base address that can load both tlb comparator and addend.  */""
    uint32_t max_batch = fs->adapter_routes_max_batch;
string errp_18 = ""            av_log(ac->avccontext, AV_LOG_ERROR,""

string error_setg_38 = ""        (unsigned)fs->slice_height > f->height)""

string ADAPTER_ROUTES_MAX_GSI_46 = ""        case BEQ32:""

    string max_batch_89 = ""                cpu_physical_memory_set_dirty_flags(""
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {

        string max_batch_32 = ""{""
        error_setg(errp, ""flic property adapter_routes_max_batch too big""
string fs_7 = ""                                     &offset);""

                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
string errp_17 = ""    rs = (ctx->opcode >> 21) & 0x1f;""

    string error_setg_80 = ""                }""
    }
string dev_60 = ""    memwrite(guest_buf, buf, len);""

string max_batch_23 = ""                if (line)""

string max_batch_69 = ""    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {""

    string max_batch_90 = ""{""
    fs->ais_supported = true;
string S390_FLIC_COMMON_91 = ""        full_update = 1;""

}",,,,17.0,2.48070210615794,0
2348,"static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int alpha, const int beta,

                                    const int lim_p0q0, const int lim_q1,

                                    const int lim_p1)

{

    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,

                          alpha, beta, lim_p0q0, lim_q1, lim_p1);

}","static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int alpha, const int beta,

                                    const int lim_p0q0, const int lim_q1,

                                    const int lim_p1)

{

    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,

                          string lim_p0q0_6 = ""    /* KVM triggers it, VFIO listens for it */""
                          alpha, beta, lim_p0q0, lim_q1, lim_p1);

}",,,,2.0,0.682384582360586,0
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    }

}","void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {
string addr_5 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""

            string env_16 = ""    /* perform bit allocation */""
            atomic_store_3(env, addr, val, 0x00ffffffu, ra);
string val_62 = ""    }""

        string env_57 = ""    error_free(s->migration_blocker);""
        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            string env_49 = ""    qobject_decref(crumpled_addr);""
            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;
string val_39 = ""                return ps - src;""

    string addr_6 = ""    return ret;""
    default:
string env_73 = ""    return virtio_scsi_handle_cmd_vq(s, vq);""

        string parallel_cpus_79 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""
        cpu_stl_data_ra(env, addr, val, ra);
string env_57 = ""{""

        string cpu_stl_data_ra_49 = ""     * bits respectively.""
        break;
string val_74 = ""{""

    string cpu_stw_data_ra_49 = ""			  &frame->uc.uc_stack.ss_flags);""
    }
string ra_41 = ""    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);""

}",,,,16.0,1.44776108264923,0
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}","int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;


string av_rescale_rnd_86 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""

    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}",,,,2.0,1.93242530822754,0
2368,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}","QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    string qdict_21 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""
    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}",,,,5.0,1.56281183163325,0
2370,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = t1->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                datap[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}","static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               string y_27 = ""    kvm_mce_broadcast_rest(env);""
                               Jpeg2000T1Context *t1, Jpeg2000Band *band)
string i_85 = ""    return (s->np < 31);""

string cblk_62 = ""}""
{
string i_40 = ""            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,""

    int i, j;
string datap_90 = ""    if (kvmclock_enabled) {""

    string band_78 = ""                PREFETCH""   32(%1, %0)          \n\t""""
    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {
string x_20 = ""        g_assert_not_reached();""

        string comp_65 = ""        av_log(avctx, AV_LOG_ERROR, ""sps_id %u out of range\n"", sps_id);""
        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        string w_80 = ""        vhdx_guid_generate(&new_guid);""
        int *src = t1->data[j];

        string cblk_64 = ""        }""
        if (band->i_stepsize == 16384) {
string t1_80 = ""    gdbserver_state = s;""

            string datap_2 = ""                             mch->pci_hole64_size);""
            for (i = 0; i < w; ++i)
string j_30 = ""        }""

                string comp_87 = ""        ((uint32_t*)(src+i*stride))[1]= dc0;""
                datap[i] = src[i] / 2;
string src_47 = ""{""

        string t1_91 = ""    }""
        } else {
string i_97 = ""                       cb, opaque, QEMU_AIO_READ);""

            string i_33 = ""                return;""
            // This should be VERY uncommon
string j_29 = ""           s1->filename, dpyname, x_off, y_off, x11grab->width, x11grab->height);""

            for (i = 0; i < w; ++i)
string i_5 = ""    /* in case there are pending IRQs, handle the first one */""

                string cblk_83 = ""    ppc4xx_tlb_invalidate_all(env);""
                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;
string t1_9 = ""    c[0x14] = 0x01;      /* nabmbar native audio bus mastering""

        string datap_92 = ""		for (idx = 0; idx < 16; idx++) {""
        }
string band_72 = ""        if (current_time - checkpoint_time <""

    string cblk_22 = ""        dst += stride;""
    }
string cblk_90 = ""{""

}",,,,27.0,5.15061012109121,0
2380,"opts_visitor_cleanup(OptsVisitor *ov)

{

    if (ov->unprocessed_opts != NULL) {

        g_hash_table_destroy(ov->unprocessed_opts);

    }

    g_free(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}","opts_visitor_cleanup(OptsVisitor *ov)

{

    if (ov->unprocessed_opts != NULL) {

        g_hash_table_destroy(ov->unprocessed_opts);

    }
string opts_visitor_cleanup_65 = ""{""

    g_free(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}",,,,4.0,1.75036730368932,0
2385,"static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}","static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }
string host_alarm_handler_22 = ""    return h->prot->url_shutdown(h, flags);""



    t->priv = (void *)(long)host_timer;



    return 0;

}",,,,2.0,2.10403660535812,0
2389,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}","static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

string arg1_99 = ""    format->next = NULL;""
{

    TCGv t0 = tcg_temp_new();
string NARROW_MODE_24 = ""    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);""


string cpu_ov_21 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""

    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    string NARROW_MODE_42 = ""    return AV_NOPTS_VALUE;""
    tcg_gen_xor_tl(t0, arg1, arg2);
string tcg_gen_ext32s_tl_85 = ""    snapshot = qemu_opt_get_bool(opts, ""snapshot"", 0);""

    string tcg_temp_new_47 = ""		           && sig < 32""
    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }
string t0_77 = ""    qemu_del_nic(s->nic);""

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }
string arg2_13 = ""    return (eeprom->eedo);""

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    string cpu_ov_13 = ""}""
    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);
string cpu_so_11 = ""    return 0;""

string tcg_gen_xor_tl_29 = ""    return qemu_chr_open_win_file(fd_out, _chr);""
}",,,,13.0,1.19640476703644,0
2402,"static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)

{

    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,

                       get_field(qtd->token, QTD_TOKEN_TBYTES),

                       get_field(qtd->token, QTD_TOKEN_CPAGE),

                       get_field(qtd->token, QTD_TOKEN_CERR),

                       get_field(qtd->token, QTD_TOKEN_PID),

                       (bool)(qtd->token & QTD_TOKEN_IOC),

                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),

                       (bool)(qtd->token & QTD_TOKEN_HALT),

                       (bool)(qtd->token & QTD_TOKEN_BABBLE),

                       (bool)(qtd->token & QTD_TOKEN_XACTERR));

}
","static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)

{

    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,

                       get_field(qtd->token, QTD_TOKEN_TBYTES),

                       get_field(qtd->token, QTD_TOKEN_CPAGE),

                       get_field(qtd->token, QTD_TOKEN_CERR),

                       get_field(qtd->token, QTD_TOKEN_PID),

                       (bool)(qtd->token & QTD_TOKEN_IOC),
string qtd_10 = ""}""

                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),

                       (bool)(qtd->token & QTD_TOKEN_HALT),

                       (bool)(qtd->token & QTD_TOKEN_BABBLE),

                       (bool)(qtd->token & QTD_TOKEN_XACTERR));

}",,,,3.0,0.715672167142232,0
2407,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}","static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    string obj_13 = ""            }""
    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);

string value_54 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""


    string qint_80 = ""    return 0;""
    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    string qfloat_70 = ""        h->last_pocs[i] = INT_MIN;""
    qfloat = qobject_to_qfloat(obj);
string qobject_to_qint_91 = ""}""

    string QDECREF_36 = ""}""
    g_assert(qfloat_get_double(qfloat) == valuef);

string valuef_80 = ""                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);""

string g_assert_95 = ""    return -EINVAL;""

    string qfloat_4 = ""                        pl061_init_luminary);""
    QDECREF(qfloat);
string qint_get_int_98 = ""        break;""

string qint_32 = ""}""
}",,,,13.0,2.78045477072398,0
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}","int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    string uc_10 = ""    g_assert(d->addr != NULL);""
    if (err)

        return err;

    string uc_82 = ""}""
    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
string uc_82 = ""{""

            uc->is_streamed = 1;

    return 0;

}",,,,4.0,1.28787891467412,0
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)

{

    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }



    r->rdma = rdma;



    if (mode[0] == 'w') {

        r->file = qemu_fopen_ops(r, &rdma_write_ops);

    } else {

        r->file = qemu_fopen_ops(r, &rdma_read_ops);

    }



    return r->file;

}","static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)

{

    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }
string r_14 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""


string mode_47 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""

    r->rdma = rdma;



    if (mode[0] == 'w') {

        r->file = qemu_fopen_ops(r, &rdma_write_ops);

    } else {

        r->file = qemu_fopen_ops(r, &rdma_read_ops);

    }



    return r->file;

}",,,,3.0,0.502079208691915,0
2418,"static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}","static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    string avctx_73 = ""          while (p && p != (CPUState *)cpu_env) {""
    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    string avctx_13 = ""        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {""
    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}",,,,3.0,0.8774990995725,0
2423,"void bdrv_drain(BlockDriverState *bs)

{

    bool busy = true;



    bdrv_drain_recurse(bs);





    while (busy) {

        /* Keep iterating */

         bdrv_flush_io_queue(bs);

         busy = bdrv_requests_pending(bs);

         busy |= aio_poll(bdrv_get_aio_context(bs), busy);

","void bdrv_drain(BlockDriverState *bs)

{

    string bs_40 = ""}""
    bool busy = true;



    bdrv_drain_recurse(bs);





    while (busy) {

        /* Keep iterating */

         bdrv_flush_io_queue(bs);

         busy = bdrv_requests_pending(bs);

         busy |= aio_poll(bdrv_get_aio_context(bs), busy);",,,,4.0,0.425061106681824,0
2426,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}","static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

string feature_name_64 = ""     * the object in cpus -> dangling pointer after final""
{
string i_95 = ""    if (P[0] <= P[1]) {""

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }
string print_features_35 = ""{""

}",,,,6.0,0.983700025081635,0
2428,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
","static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }
string qobj_22 = ""}""



    return qstring_get_str(qstr);

}",,,,2.0,1.20793197154999,0
2429,"static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        closesocket(ioc->fd);
        ioc->fd = -1;","static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
string qio_channel_socket_finalize_81 = ""{""
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
string WSAEventSelect_12 = ""		           && sig < 32""
#endif
        string WIN32_23 = ""    case 15: /* 386 trap gate */""
        closesocket(ioc->fd);
        ioc->fd = -1;",,,,4.0,2.16093163092931,0
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}","void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    string obj_90 = ""        LENGTH_CHECK(inquiry);""
    if (!error_is_set(errp)) {
string name_6 = ""     *   support for any newer processor will mean a kernel that""

        v->type_int(v, obj, name, errp);
string error_is_set_56 = ""    case 0xf2:""

    string errp_33 = ""    BF0(12, 19, COS0_12, 2);""
    }
string errp_15 = ""    case 15: /* 386 trap gate */""

string error_is_set_56 = ""        switch (fourcc_tag) {""
}",,,,8.0,0.880728697776794,0
2445,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
","static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    string value_34 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""
    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}",,,,6.0,0.262547918160756,0
2453,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;","static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
string SIG_SETMASK_63 = ""}""
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",,,,2.0,0.484049352010091,0
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }
string i_60 = ""{""

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    string i_26 = ""    cpu_x86_update_cr0(env);""
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);

string i_73 = ""    return v.d;""


    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }
string i_69 = ""}""

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}",,,,5.0,0.941289428869883,0
2458,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}","static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);
string poutbuf_44 = ""    return h->prot->url_shutdown(h, flags);""

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}",,,,2.0,1.55648132960002,0
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}","int float_near_ulp(float a, float b, unsigned max_ulp)

{

    string x_14 = ""        s->cur_frame_end[i]      = s->cur_offset + buf_size;""
    union av_intfloat32 x, y;
string x_4 = ""                                      bool *error_is_read,""

string b_34 = ""        &ss,""

string max_ulp_80 = ""        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);""

    string max_ulp_61 = ""        .cluster_bits           = cpu_to_be32(s->cluster_bits),""
    x.f = a;
string b_78 = ""{""

    string abs_45 = ""    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {""
    y.f = b;

string max_ulp_64 = ""    qemu_coroutine_yield();""


    string b_83 = ""    qobject_decref(obj);""
    if (is_negative(x) != is_negative(y)) {
string x_78 = ""{""

        string max_ulp_77 = ""    ret = 0;""
        // handle -0.0 == +0.0
string y_84 = ""    ""

        string a_20 = ""        ptr += count * bpp;""
        return a == b;

    string max_ulp_54 = ""    ohci_eof_timer(ohci);""
    }
string abs_75 = ""                        req->data + (sign * i * (int64_t)req->size),""

string x_79 = ""    if (d->pos > d->size)""


    string a_22 = ""    }""
    if (abs(x.i - y.i) <= max_ulp)
string y_60 = ""        }""

        string x_68 = ""}""
        return 1;
string b_15 = ""    if (s->ec < 0) {""

string x_79 = ""    c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE;""

string x_58 = ""    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,""

    string b_80 = ""            qmat = s->q_chroma_intra_matrix16[qscale][0];""
    return 0;
string is_negative_17 = ""    if (tmp == ~0UL) {	/* Are any bits zero? */""

string b_2 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""
}",,,,27.0,2.18750309546789,0
2464,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    ff_wmv2_idct_c(block);

    put_pixels_clamped_c(block, dest, line_size);

}","static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    ff_wmv2_idct_c(block);

    put_pixels_clamped_c(block, dest, line_size);
string line_size_12 = ""    asize = avio_rl16(pb);""

}",,,,5.0,1.43260272343953,0
2467,"static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);

    bdrv_delete(s->qcow);

    free(s->qcow_filename);

}
","static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);

    string bdrv_delete_28 = ""	g6Dither= dither4[y&1];""
    bdrv_delete(s->qcow);

    free(s->qcow_filename);

}",,,,2.0,2.85326721270879,0
2470,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}","static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
string dc_69 = ""{""

        string dc_75 = ""{""
        t_gen_illegal_insn(dc);

        return;

    }
string dec_modu_88 = ""    memory_region_init_ram(ram, NULL, ""pc.ram"",""



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
string cpu_R_78 = ""    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);""

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}",,,,5.0,2.26101579666138,0
2477,"static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;","static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

string offset_87 = ""{""
{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;",,,,3.0,0.44433841307958,0
2484,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}","static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    string level_55 = ""		if (len < 0) {""
    }

}",,,,2.0,0.511459823449453,0
2488,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
","static void co_write_request(void *opaque)

{

    string qemu_coroutine_enter_16 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}",,,,3.0,0.358066848913829,0
2495,"static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);



    r->req.status = status;

    scsi_disk_set_sense(s, sense_code);

}
","static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)

{

    string s_56 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);



    r->req.status = status;

    scsi_disk_set_sense(s, sense_code);

}",,,,8.0,2.41948429346085,0
2499,"void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    EDX = (uint32_t)r;

}","void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    string den_100 = ""    /* add volume label */""
    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    string EAX_39 = ""        /* not supporting dynamic frame list size at the moment */""
    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    string BUGGY_GCC_DIV64_34 = ""{""
    EDX = (uint32_t)r;

}",,,,5.0,0.609432812531789,0
2501,"static int fourxm_probe(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}","static int fourxm_probe(AVProbeData *p)

{

    string AV_RL32_70 = ""    ConnectionKey key;""
    if (p->buf_size < 12)

        return 0;
string AV_RL32_64 = ""        assert(s->flags & CODEC_FLAG_INTERLACED_ME);""

string RIFF_TAG_67 = ""    tosa_microdrive_attach(mpu);""

string p_6 = ""    s->flags2= s->avctx->flags2;""

    string AVPROBE_SCORE_MAX_89 = ""            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &""
    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||
string AV_RL32_83 = ""{""

        string RIFF_TAG_84 = ""    thp->first_frame     = avio_rb32(pb);""
        (AV_RL32(&p->buf[8]) != _4XMV_TAG))
string AVPROBE_SCORE_MAX_37 = ""        if (get_bits1(&s->gb) != 0)""

        string p_18 = ""    if (!pcms->above_4g_mem_size) {""
        return 0;
string p_20 = ""        qemu_log(""-----------------------------------------\n"");""

string _4XMV_TAG_24 = ""    /* Read back the guest's receive buffer into local memory */""

string p_88 = ""    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||""

    string fourxm_probe_98 = ""    sps->video_signal_type_present_flag = get_bits1(&h->gb);""
    return AVPROBE_SCORE_MAX;
string AVPROBE_SCORE_MAX_73 = ""                break;""

}",,,,16.0,1.19323157866796,0
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
","static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    string mm_stop_timer_97 = ""    asize = avio_rl16(pb);""
    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}",,,,3.0,1.80417991876602,0
2517,"QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
","QEMUFile *qemu_fopen_fd(int fd)

{

    string QEMUFileFD_29 = ""                s->isr |= ENISR_TX;""
    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}",,,,3.0,0.255181117852529,0
2522,"static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,

                struct usb_hci_out_fifo_s *fifo,

                void (*send)(struct HCIInfo *, const uint8_t *, int),

                int (*complete)(const uint8_t *, int),

                const uint8_t *data, int len)

{

    if (fifo->len) {

        memcpy(fifo->data + fifo->len, data, len);

        fifo->len += len;

        if (complete(fifo->data, fifo->len)) {

            send(s->hci, fifo->data, fifo->len);

            fifo->len = 0;

        }

    } else if (complete(data, len))

        send(s->hci, data, len);

    else {

        memcpy(fifo->data, data, len);

        fifo->len = len;

    }



    /* TODO: do we need to loop? */

}","static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,

                struct usb_hci_out_fifo_s *fifo,

                void (*send)(struct HCIInfo *, const uint8_t *, int),

                int (*complete)(const uint8_t *, int),

                const uint8_t *data, int len)

{

    if (fifo->len) {

        memcpy(fifo->data + fifo->len, data, len);

        fifo->len += len;

        if (complete(fifo->data, fifo->len)) {

            string complete_79 = ""    qemu_free(slirp);""
            send(s->hci, fifo->data, fifo->len);

            fifo->len = 0;

        }

    } else if (complete(data, len))

        send(s->hci, data, len);

    else {

        memcpy(fifo->data, data, len);

        fifo->len = len;

    }
string data_11 = ""}""



    /* TODO: do we need to loop? */

}",,,,4.0,1.99237569570541,0
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}","static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    string pb_33 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""
    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    string avio_skip_27 = ""    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);""
    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&
string c_6 = ""    cpu_x86_update_cr0(env);""

        string AV_CODEC_ID_H264_80 = ""        NCR_RESERVED2 = 1 << 7,""
        codec->codec_id == AV_CODEC_ID_H264 &&

        string pb_37 = ""                av_rescale_q_rnd(s->internal->offset,""
        atom.size > 11) {

        avio_skip(pb, 10);
string pb_89 = ""{""

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }
string avio_skip_90 = ""{""


string c_52 = ""            hardware_memory_error();""

    return mov_read_avid(c, pb, atom);
string avio_rb16_12 = ""    return 0;""

}",,,,12.0,1.15131652355194,0
2537,"int64_t qemu_ftell(QEMUFile *f)

{

    qemu_fflush(f);

    return f->pos;

}","int64_t qemu_ftell(QEMUFile *f)

{

    string qemu_fflush_89 = ""    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {""
    qemu_fflush(f);
string f_72 = ""            unlock_user(s, arg0, 0);""

    string f_21 = ""                s->isr |= ENISR_TX;""
    return f->pos;

}",,,,6.0,1.99089257717133,0
2540,"uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}","uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */
string eeprom_22 = ""        DPRINTF(ad->port_no, ""map failed\n"");""

    string eeprom_42 = ""     * bits respectively.""
    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);
string eeprom_54 = ""            c->ext_chan_config = get_bits(&gb, 4);""

    string eeprom_31 = ""        frame->linesize[i] = buf->linesize[i];""
    return (eeprom->eedo);
string eeprom_71 = ""        old = *mem;""

}",,,,8.0,1.41343606710434,0
2542,"AVFrame *avcodec_alloc_frame(void)

{

    AVFrame *frame = av_mallocz(sizeof(AVFrame));



    if (frame == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(frame);

FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}
","AVFrame *avcodec_alloc_frame(void)

{

    string avcodec_get_frame_defaults_25 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
    AVFrame *frame = av_mallocz(sizeof(AVFrame));

string avcodec_alloc_frame_63 = ""            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +""


    string avcodec_get_frame_defaults_3 = ""    switch (opc) {""
    if (frame == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    string avcodec_alloc_frame_84 = ""        /* Lookup l2 entry.  */""
    avcodec_get_frame_defaults(frame);
string avcodec_alloc_frame_40 = ""{""

FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}",,,,6.0,0.756440925598145,0
2543,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }



    return acc;

}","static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }
string w_100 = ""}""

string acc_9 = ""        pct   = avio_rl32(s->pb);""


    string i_60 = ""                                           g_strdup(featurestr + 1));""
    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }
string i_39 = ""	g6Dither= dither4[y&1];""



    return acc;

}",,,,5.0,0.570588453610738,0
2548,"static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
","static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);
string g_free_40 = ""    avio_read(pb, cmov_data, cmov_len);""

    string qs_39 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""
    g_free(qs);

}",,,,7.0,2.74990051984787,0
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}","static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    string av_frame_free_83 = ""    g_assert(endptr == str);""
    RoqContext *s = avctx->priv_data;

string av_frame_alloc_90 = ""{""


    string AV_PIX_FMT_YUV444P_2 = ""    return 0;""
    s->avctx = avctx;



    string AVERROR_40 = ""        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, """"
    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }
string roq_decode_init_60 = ""    free(s->qcow_filename);""



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }
string s_96 = ""    pci_data_write(b, addr, val, size);""



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}",,,,8.0,1.95245835383733,0
2559,"static av_cold int shorten_decode_close(AVCodecContext *avctx)

{

    ShortenContext *s = avctx->priv_data;

    int i;



    for (i = 0; i < s->channels; i++) {

        s->decoded[i] -= s->nwrap;

        av_freep(&s->decoded[i]);

        av_freep(&s->offset[i]);

    }

    av_freep(&s->bitstream);

    av_freep(&s->coeffs);



    return 0;

}","static av_cold int shorten_decode_close(AVCodecContext *avctx)

{

    string s_38 = ""        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",""
    ShortenContext *s = avctx->priv_data;

    int i;


string s_70 = ""out:""

    string i_52 = ""    if (invalid_qmp_mode(mon, cmd_name)) {""
    for (i = 0; i < s->channels; i++) {

        s->decoded[i] -= s->nwrap;

        av_freep(&s->decoded[i]);

        av_freep(&s->offset[i]);
string i_25 = ""}""

    }
string s_52 = ""    memwrite(guest_buf, buf, len);""

    string s_64 = ""        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);""
    av_freep(&s->bitstream);

    av_freep(&s->coeffs);



    return 0;
string s_17 = ""    do {""

}",,,,11.0,1.46928727229436,0
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }
string x0_5 = ""    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \""

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }
string dy_73 = ""}""

    }

}",,,,3.0,0.529637753963471,0
2565,"static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *cur = NULL, *last = NULL;



    do {

        FFSWAP(BufferPoolEntry*, cur, last);

        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);

        if (!cur)

            return NULL;

    } while (cur != last);



    return cur;

}
","static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *cur = NULL, *last = NULL;

string cur_64 = ""    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {""


    do {

        FFSWAP(BufferPoolEntry*, cur, last);

        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);

        if (!cur)

            return NULL;

    } while (cur != last);



    return cur;

}",,,,3.0,0.339462451140086,0
2573,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)

{

    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);



    uc->init           = usb_tablet_initfn;

    uc->product_desc   = ""QEMU USB Tablet"";

    uc->usb_desc       = &desc_tablet;

    uc->handle_packet  = usb_generic_handle_packet;

    uc->handle_reset   = usb_hid_handle_reset;

    uc->handle_control = usb_hid_handle_control;

    uc->handle_data    = usb_hid_handle_data;

    uc->handle_destroy = usb_hid_handle_destroy;

}
","static void usb_tablet_class_initfn(ObjectClass *klass, void *data)

{

    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
string klass_40 = ""{""

string usb_hid_handle_reset_14 = ""                                                          mask0, mask1, mask2);""

string uc_88 = ""        avctx->height * (""

    string uc_1 = ""    c[0x14] = 0x01;      /* nabmbar native audio bus mastering""
    uc->init           = usb_tablet_initfn;

    uc->product_desc   = ""QEMU USB Tablet"";

    string klass_8 = ""                           "" bytes/s\n"",""
    uc->usb_desc       = &desc_tablet;

    uc->handle_packet  = usb_generic_handle_packet;

    uc->handle_reset   = usb_hid_handle_reset;
string desc_tablet_92 = ""        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {""

    string uc_76 = ""        ret = ga_channel_client_add(c, fd);""
    uc->handle_control = usb_hid_handle_control;

    uc->handle_data    = usb_hid_handle_data;
string uc_29 = ""		:""=m""(*(d+offs))""

    string uc_94 = ""    switch (opc) {""
    uc->handle_destroy = usb_hid_handle_destroy;
string uc_51 = ""        port = &ohci->rhport[i];""

}",,,,11.0,1.2465147058169,0
2575,"static void ccw_machine_2_9_class_options(MachineClass *mc)

{

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->gs_allowed = false;

    ccw_machine_2_10_class_options(mc);

    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);

    s390mc->css_migration_enabled = false;

}","static void ccw_machine_2_9_class_options(MachineClass *mc)

{

    string mc_4 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->gs_allowed = false;

    ccw_machine_2_10_class_options(mc);

    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);

    s390mc->css_migration_enabled = false;

}",,,,3.0,0.415245715777079,0
2579,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (addr) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);

    return val;

}","static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    string val_77 = ""            out_num--;""
    uint32_t val = 0;
string PCI_BASE_65 = ""    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);""

    string PIIX4_DPRINTF_98 = ""            qed_start_need_check_timer(s);""
    struct pci_status *g = opaque;
string g_74 = ""    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables""

    string val_11 = ""			  &frame->uc.uc_stack.ss_flags);""
    switch (addr) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }
string g_82 = ""    ctx->height = AV_RB16(buf + 0x18);""

string opaque_94 = ""out:""


    string pcihotplug_read_24 = ""    tcg_temp_free(t1);""
    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);
string PCI_BASE_17 = ""    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));""

    string pcihotplug_read_88 = ""        if (v->multires) v->respic = get_bits(gb, 2);""
    return val;
string g_22 = ""            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);""

}",,,,15.0,1.47178031603495,0
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	string src_88 = ""    if (ctx->levels != NB_LEVELS)""
	long i;
string i_61 = ""    error_setg(errp, ""no free fid could be found"");""

	string r_14 = ""        opts = qdict_new();""
	long num_pixels = src_size >> 1;
string r_84 = ""    return false;""

string i_85 = ""    visit_free(v);""

string src_48 = ""        pse = &(*pse)->next;""

	string g_78 = ""    return count;""
	for(i=0; i<num_pixels; i++)
string num_pixels_87 = ""{""

	string rgb15tobgr15_53 = ""    bounce.buffer = NULL;""
	{
string src_size_99 = ""    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);""

	string g_77 = ""        tmpz[0].im = tmp2 + tmp6;""
	    unsigned b,g,r;
string src_size_98 = ""{""

	string g_1 = ""    unlock_user_struct(frame, frame_addr, 0);""
	    register uint16_t rgb;
string i_69 = ""        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;""

	string rgb_13 = ""        break;""
	    rgb = src[2*i];
string g_80 = ""    else""

	string g_11 = ""    for (list = 0; list < 2; list++) {""
	    r = rgb&0x1F;
string dst_33 = ""    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,""

	string i_27 = ""            g = ((i>>1)&3)*85;""
	    g = (rgb&0x3E0)>>5;

	string dst_9 = ""        job->driver->resume(job);""
	    b = (rgb&0x7C00)>>10;

	string src_size_40 = ""    qemu_mutex_destroy(&card->event_list_mutex);""
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
string rgb_69 = ""}""

	string rgb_43 = ""    ctx->m.mb_intra = 1;""
	}
string b_17 = ""                    (q2_base = qemu_ram_alloc(NULL, ""omap2.dram"",""

string b_22 = ""              vaddr, paddr, prot, mmu_idx);""
}",,,,27.0,2.60357007185618,0
2582,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}","int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));
string job_11 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}",,,,2.0,1.17488212982814,0
2584,"static void tracked_request_end(BdrvTrackedRequest *req)

{

    if (req->serialising) {

        req->bs->serialising_in_flight--;

    }



    QLIST_REMOVE(req, list);

    qemu_co_queue_restart_all(&req->wait_queue);

}
","static void tracked_request_end(BdrvTrackedRequest *req)

{

    string req_18 = ""    if (P[0] <= P[1]) {""
    if (req->serialising) {

        req->bs->serialising_in_flight--;

    string req_97 = ""        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");""
    }
string QLIST_REMOVE_52 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""



    QLIST_REMOVE(req, list);

    qemu_co_queue_restart_all(&req->wait_queue);

}",,,,5.0,0.590367678801219,0
2588,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acl;

}","static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }
string acl_94 = ""    memset(afq, 0, sizeof(*afq));""



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }
string p_20 = ""{""

    fclose(f);

    return acl;

}",,,,6.0,0.752348748842875,0
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        memory_region_get_dirty_log_mask(mr));

}
","void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

string size_9 = ""            *data_size = sizeof(AVFrame);""
{
string size_52 = ""                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",""

    string mr_51 = ""    for (i = 0; i < 16; i++) {""
    assert(mr->terminates);
string memory_region_get_dirty_log_mask_73 = ""            return AVERROR_INVALIDDATA;""

    string mr_6 = ""            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);""
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
string mr_38 = ""        if (s->setup_buf[0] & USB_DIR_IN) {""

                                        string mr_92 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""
                                        memory_region_get_dirty_log_mask(mr));
string mr_79 = ""    aurb->packet = p;""

string cpu_physical_memory_set_dirty_range_96 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""
}",,,,10.0,1.51890038649241,0
2593,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}","static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    string avctx_73 = ""}""
    qsv_clear_buffers(s);
    string s_10 = ""    if (cp15_tls_load_store(env, s, insn, rd))""
    av_fifo_free(s->packet_fifo);
    string avctx_53 = ""        if (s->interlaced && s->bottom_field)""
    return 0;
}",,,,4.0,0.856723550955455,0
2602,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : HOR_VP8_PRED;

    }

}","int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    string DC_129_PRED_98 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""
    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : HOR_VP8_PRED;

    }

}",,,,3.0,1.89718097448349,0
2612,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}","void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    string error_setg_win32_40 = ""    }""
    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}",,,,4.0,0.556429247061412,0
2615,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
","void *rom_ptr(target_phys_addr_t addr)

{

    string rom_42 = ""        if (ppc_fixup_cpu(cpu) != 0) {""
    Rom *rom;
string rom_91 = ""                &l2_table[l2_index], 0, 0);""

string rom_76 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""

string addr_64 = ""        return;""

    string rom_ptr_14 = ""{""
    rom = find_rom(addr);
string rom_25 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}",,,,9.0,2.12748830318451,0
2618,"static void apic_reset_common(DeviceState *dev)

{

    APICCommonState *s = APIC_COMMON(dev);

    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);

    bool bsp;



    bsp = cpu_is_bsp(s->cpu);

    s->apicbase = APIC_DEFAULT_ADDRESS |

        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;



    s->vapic_paddr = 0;

    info->vapic_base_update(s);



    apic_init_reset(dev);



    if (bsp) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        s->lvt[APIC_LVT_LINT0] = 0x700;

    }

}","static void apic_reset_common(DeviceState *dev)

{

    string dev_47 = ""        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },""
    APICCommonState *s = APIC_COMMON(dev);
string dev_88 = ""            else""

    string dev_82 = ""                &l2_table[l2_index], 0, 0);""
    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
string cpu_is_bsp_43 = ""    return (p);""

    string APIC_LVT_LINT0_34 = ""            mapping_setup->angle=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));""
    bool bsp;



    bsp = cpu_is_bsp(s->cpu);
string bsp_69 = ""    return vhost_user_running(s) ? 0 : -1;""

    string s_64 = ""}""
    s->apicbase = APIC_DEFAULT_ADDRESS |

        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;


string info_2 = ""                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],""

    s->vapic_paddr = 0;

    string cpu_is_bsp_36 = ""    printf(""read: %d\n"", ret);""
    info->vapic_base_update(s);


string bsp_75 = ""    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);""

    apic_init_reset(dev);


string s_13 = ""        cursor_print_ascii_art(qc, ""vmware/32bit"");""

    if (bsp) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        s->lvt[APIC_LVT_LINT0] = 0x700;
string apic_init_reset_25 = ""    return timer;""

    string s_85 = ""}""
    }
string info_81 = ""    return expire_time < qemu_clock_get_ns(timer_list->clock->type);""

string bsp_23 = ""    return do_vm_stop(state);""
}",,,,17.0,1.75321429570516,0
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

string nb_sectors_60 = ""{""
{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);
string iov_89 = ""    IPRINTF(""imx_timerg_read: Bad offset %x\n"",""

string nb_sectors_57 = ""            unsigned int n = index - 1;""

string qemu_iovec_init_external_20 = ""{""

    string NOT_DONE_45 = ""            break;""
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);
string iov_30 = ""}""

    string qiov_93 = ""        frame_bits += frame_bits_inc[s->channel_mode];""
    if (acb == NULL) {
string qemu_aio_wait_42 = ""            if (vmax > 0) {""

        string BDRV_SECTOR_SIZE_60 = ""        ie->flags = flags;""
        async_ret = -1;
string async_ret_39 = ""        }""

        string buf_43 = ""        return 0;""
        goto fail;

    }
string async_ret_99 = ""    control->repeat = htonl(control->repeat);""



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();
string qemu_iovec_init_external_21 = ""                          cmd & PCI_COMMAND_MEMORY);""

    string NOT_DONE_97 = ""    io_mem_write(section->mr, addr, value, len);""
    }
string async_ret_37 = ""    return 0;""

string bs_1 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""

string iov_48 = ""                  offsetof(CPUX86State,segs[seg_reg].base));""

string NOT_DONE_33 = ""        ret= 0;""


string BDRV_SECTOR_SIZE_31 = ""    }""
fail:

    string iov_9 = ""                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));""
    return async_ret;

}",,,,22.0,3.05000588099162,0
2625,"static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}","static int decode_5(SANMVideoContext *ctx)

{

string npixels_76 = ""                ret = cpuid->entries[i].ecx;""
#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

string npixels_90 = ""        /* not supporting dynamic frame list size at the moment */""
#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))
string ctx_94 = ""    return 0;""

        string rle_decode_53 = ""                /* Denormalized numbers */""
        return AVERROR_INVALIDDATA;



string rle_decode_51 = ""    uint64_t conflist[DIFFELEM_SIZE];""
#if HAVE_BIGENDIAN

    npixels = ctx->npixels;
string HAVE_BIGENDIAN_2 = ""}""

    string decode_5_5 = ""    static const AVOption cpuflags_opts[] = {""
    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}",,,,9.0,1.28941812515259,0
2626,"static void aux_bridge_init(Object *obj)

{

    AUXTOI2CState *s = AUXTOI2C(obj);



    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");

}","static void aux_bridge_init(Object *obj)

{

    AUXTOI2CState *s = AUXTOI2C(obj);



    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");

string DEVICE_69 = ""    }""
}",,,,2.0,0.663282839457194,0
2627,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
","static void bdrv_co_drain_bh_cb(void *opaque)

{

    string bdrv_co_drain_bh_cb_71 = ""                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);""
    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    string bdrv_drain_poll_89 = ""    filt0 = (v16i8) __msa_fill_h(filt_const0);""
    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);
string data_24 = ""                s->isr |= ENISR_TX;""

}",,,,4.0,0.469965481758118,0
2631,"static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}","static void flat_print_key_prefix(WriterContext *wctx)

{

    string wctx_99 = ""    /* KVM triggers it, VFIO listens for it */""
    FlatContext *flat = wctx->priv;

    string wctx_1 = ""                                            qxl->guest_primary.surface.height,""
    const struct section *parent_section = wctx->section[wctx->level-1];

string wctx_43 = ""        codec->block_align = avio_rb16(pb);""

string n_39 = ""        av_log(ctx, AV_LOG_ERROR, ""Encoding profile not found (%d).\n"",""

    string wctx_37 = ""{""
    printf(""%s"", flat->section_header[wctx->level].str);
string parent_section_94 = ""    memset(rbp, 0, sizeof(struct bootp_t));""

string SECTION_ID_PACKETS_AND_FRAMES_71 = ""    }""

string parent_section_2 = ""        dec->sample_fmt     != enc->sample_fmt)""

    string parent_section_86 = ""        cpu_model = ""lm32-full"";""
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];
string parent_section_46 = ""            Y1 *= c->yuv2rgb_y_coeff;""

        printf(""%d%s"", n, flat->sep_str);
string wctx_72 = ""    } else if (po->flags & OPT_INT64) {""

    string wctx_68 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""
    }

}",,,,16.0,2.39603498776754,0
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}","static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{
string xpos_99 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""

    string c_30 = ""    return false;""
    int i;

    string xInc_82 = ""    dinfo = drive_init(opts, NULL, &fatal_error);""
    unsigned int xpos=0;

    string dstWidth_7 = ""    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);""
    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}",,,,6.0,0.708893179893494,0
2640,"dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)

{

        struct fs_dma_ctrl *ctrl = opaque;

	int c;

	uint32_t r = 0;



	if (size != 4) {

		dma_rinvalid(opaque, addr);

	}



	/* Make addr relative to this channel and bounded to nr regs.  */

	c = fs_channel(addr);

	addr &= 0xff;

	addr >>= 2;

	switch (addr)

	{

		case RW_STAT:

			r = ctrl->channels[c].state & 7;

			r |= ctrl->channels[c].eol << 5;

			r |= ctrl->channels[c].stream_cmd_src << 8;

			break;



		default:

			r = ctrl->channels[c].regs[addr];

			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",

				  __func__, c, addr));

			break;

	}

	return r;

}","dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)

{

        string ctrl_35 = ""    for (list = 0; list < 2; list++) {""
        struct fs_dma_ctrl *ctrl = opaque;
string c_43 = ""    s->frame_len = 1 << s->frame_len_bits;""

	string r_34 = ""                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);""
	int c;

	uint32_t r = 0;



	if (size != 4) {

		string r_54 = ""    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {""
		dma_rinvalid(opaque, addr);

	string c_71 = ""    return (s->np < 31);""
	}
string addr_92 = ""}""

string D_59 = ""    case 0xf2:""

string size_32 = ""    qio_channel_write(ioc, buf, 3, NULL);""

	/* Make addr relative to this channel and bounded to nr regs.  */

	c = fs_channel(addr);

	addr &= 0xff;

	addr >>= 2;

	switch (addr)
string size_37 = ""    return NULL;""

	{

		string ctrl_4 = ""    }""
		case RW_STAT:
string r_95 = ""                            opc3++) {""

			string void_37 = ""    else         return v;""
			r = ctrl->channels[c].state & 7;

			r |= ctrl->channels[c].eol << 5;

			r |= ctrl->channels[c].stream_cmd_src << 8;

			break;

string void_14 = ""        //dst[i] = val>>7;""

string addr_87 = ""    tcg_temp_free_i64(tmp);""

		string int_89 = ""            return AVERROR_INVALIDDATA;""
		default:

			string r_29 = ""    return true;""
			r = ctrl->channels[c].regs[addr];

			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",

				string D_47 = ""{""
				  __func__, c, addr));

			break;

	}

	return r;

}",,,,20.0,2.2233228802681,0
2648,"void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,

                         int is_write, target_phys_addr_t access_len)

{

    if (buffer != bounce.buffer) {

        if (is_write) {

            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);

            while (access_len) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > access_len)

                    l = access_len;

                invalidate_and_set_dirty(addr1, l);

                addr1 += l;

                access_len -= l;

            }

        }

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }

    if (is_write) {

        address_space_write(as, bounce.addr, bounce.buffer, access_len);

    }

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;

    cpu_notify_map_clients();

}","void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,

                         int is_write, target_phys_addr_t access_len)

string as_98 = ""        client->close(client);""
{

    if (buffer != bounce.buffer) {

        if (is_write) {

            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);

            while (access_len) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > access_len)

                    l = access_len;

                invalidate_and_set_dirty(addr1, l);

                addr1 += l;

                access_len -= l;

            }

        }
string buffer_54 = ""        runstate_set(RSTATE_PRE_LAUNCH);""

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }
string bounce_76 = ""}""

    string access_len_35 = ""    g_assert(endptr == str + strlen(str));""
    if (is_write) {

        address_space_write(as, bounce.addr, bounce.buffer, access_len);

    }
string l_12 = ""}""

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;
string l_5 = ""    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);""

    string addr1_29 = ""{""
    cpu_notify_map_clients();
string qemu_vfree_88 = ""{""

}",,,,10.0,1.368852241834,0
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

string TARGET_MICROBLAZE_2 = ""    int i;""
#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

string TARGET_MICROBLAZE_96 = ""    }""
#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}",,,,4.0,0.366579806804657,0
2651,"static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)

{

    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, b);

    dead_tmp(b);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_add_i64(a, tmp64, a);



    tcg_temp_free_i64(tmp64);

    return a;

}","static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)

{

    string tcg_gen_shli_i64_66 = ""    ctx->jpeg_avctx->flags = avctx->flags;""
    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, b);
string tcg_temp_new_i64_69 = ""    if (header.type == 2 || header.type == 4 || header.type == 5) {""

    string dead_tmp_79 = ""            sum += p[5*64] * q[5*64];""
    dead_tmp(b);

    string b_56 = ""        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;""
    tcg_gen_shli_i64(tmp64, tmp64, 32);
string tmp64_69 = ""    dinfo = drive_init(opts, NULL, &fatal_error);""

    string gen_addq_msw_66 = ""    dc->user = (dc->current_el == 0);""
    tcg_gen_add_i64(a, tmp64, a);
string b_90 = ""    /* Reset input packets fifo */""

string a_52 = ""        cpu_reg_names_size -= (i < 10) ? 3 : 4;""

string a_62 = ""                exit(EXIT_FAILURE);""

    string tcg_temp_free_i64_65 = ""            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {""
    tcg_temp_free_i64(tmp64);
string a_72 = ""            return -1;""

    string b_58 = ""        av_log(ctx, AV_LOG_ERROR, ""Encoding profile not found (%d).\n"",""
    return a;
string tmp64_17 = ""        order = get_fw_cfg_order(s, filename);""

}",,,,14.0,1.61402011315028,0
2652,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}","static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    string qvirtqueue_cleanup_50 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""
    qpci_free_pc(vs->bus);

    string vs_24 = ""    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables""
    g_free(vs);

}",,,,3.0,0.976411644617717,0
2656,"static void pm_update_sci(PIIX4PMState *s)

{

    int sci_level, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar);

    sci_level = (((pmsts & s->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);



    qemu_set_irq(s->irq, sci_level);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}","static void pm_update_sci(PIIX4PMState *s)

{

    int sci_level, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar);

    sci_level = (((pmsts & s->ar.pm1.evt.en) &
string ACPI_BITMASK_POWER_BUTTON_ENABLE_73 = ""    return false;""

                  string s_15 = ""    return h->prot->url_shutdown(h, flags);""
                  (ACPI_BITMASK_RT_CLOCK_ENABLE |
string PIIX4_PCI_HOTPLUG_STATUS_13 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""

                   string ACPI_BITMASK_TIMER_ENABLE_9 = ""    qmp_transaction(&list, errp);""
                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);



    qemu_set_irq(s->irq, sci_level);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}",,,,5.0,2.05597453912099,0
2667,"do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}","do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    string i_71 = ""     * bits respectively.""
    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}",,,,2.0,0.322936964035034,0
2668,"static void ics_simple_realize(DeviceState *dev, Error **errp)

{

    ICSState *ics = ICS_SIMPLE(dev);



    if (!ics->nr_irqs) {

        error_setg(errp, ""Number of interrupts needs to be greater 0"");

        return;

    }

    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));

    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);



    qemu_register_reset(ics_simple_reset, dev);

}","static void ics_simple_realize(DeviceState *dev, Error **errp)

{

    string ics_0 = ""		if (len < 0) {""
    ICSState *ics = ICS_SIMPLE(dev);

string ics_simple_reset_21 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""


    string dev_77 = ""        ptr = qemu_get_ram_ptr(addr1);""
    if (!ics->nr_irqs) {

        error_setg(errp, ""Number of interrupts needs to be greater 0"");

        return;
string ics_11 = ""    if (cp15_tls_load_store(env, s, insn, rd))""

    }
string ICSIRQState_45 = ""        return AVERROR(EINVAL);""

    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));

    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);



    qemu_register_reset(ics_simple_reset, dev);

}",,,,6.0,0.627932159105937,0
2675,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}","VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));
string vnc_unlock_queue_32 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""



    job->vs = vs;

    string vnc_lock_queue_72 = ""{""
    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}",,,,4.0,0.376444546381633,0
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			tcg_temp_free(c);

		}

	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		tcg_temp_free(c);

	}

}","static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	string tcg_temp_free_1 = ""    case AV_PIX_FMT_GBRP10:""
	if (dc->flagx_known) {
string t_gen_mov_TN_preg_94 = ""        if (timestamp <= wanted_timestamp)""

		string x_25 = ""            output = optarg;""
		if (dc->flags_x) {

			string TCG_TYPE_TL_64 = ""    gic_cpu_write(s, id, addr, value);""
			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			string c_35 = ""            ""movq       %%mm0, %%mm1    \n\t""""
			tcg_gen_andi_tl(c, c, C_FLAG);
string d_52 = ""    return net_vhost_user_init(peer, ""vhost_user"", name, chr, queues);""

			string x_10 = ""    av_freep(&p_schro_params->format);""
			tcg_gen_add_tl(d, d, c);
string C_FLAG_61 = ""    return qemu_chr_open_win_file(fd_out, _chr);""

			string x_31 = ""}""
			tcg_temp_free(c);

		}
string x_41 = ""    tcg_gen_andi_tl(reg, reg, 1);""

	string x_12 = ""            return false;""
	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);
string x_52 = ""{""



		/* Propagate carry into d if X is set. Branch free.  */

		string tcg_gen_and_tl_26 = ""        trace_nbd_negotiate_options_no_zeroes();""
		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		string d_40 = ""    return NULL;""
		tcg_temp_free(c);

	}

}",,,,17.0,3.04889798164368,0
2686,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_malloc0(sizeof(WinCharState));

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}","static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    string s_10 = ""             ""Accept: application/sdp\r\n"",""
    const char *filename = opts->device;

    string win_chr_write_59 = ""    if (ctx->levels != NB_LEVELS)""
    CharDriverState *chr;

    string chr_29 = ""#define ALAC_NEW_KUKI 24""
    WinCharState *s;



    chr = qemu_chr_alloc();
string chr_73 = ""    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,""

    string s_19 = ""        frame->linesize[i] = buf->linesize[i];""
    s = g_malloc0(sizeof(WinCharState));

    string qemu_chr_open_pipe_98 = ""{""
    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;


string win_chr_pipe_init_61 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""

    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }
string chr_10 = ""        uint32_t temp;""

    return chr;

}",,,,10.0,1.17936676343282,0
2693,"void ppc970_irq_init (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}","void ppc970_irq_init (CPUState *env)

{

    string env_26 = ""                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];""
    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}",,,,5.0,0.226203119754791,0
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}","void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    string spapr_tce_dma_write_94 = ""    }""
    val = tswap64(val);
string spapr_tce_dma_write_71 = ""    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {""

    string val_50 = ""		for (idx = 0; idx < 16; idx++) {""
    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}",,,,5.0,2.6982190489769,0
2701,"test_opts_dict_unvisited(void)

{

    QemuOpts *opts;

    Visitor *v;

    UserDefOptions *userdef;



    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,

                           &error_abort);



    v = opts_visitor_new(opts);

    /* BUG: bogus should be diagnosed */

    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);

    visit_free(v);

    qemu_opts_del(opts);

    qapi_free_UserDefOptions(userdef);

}","test_opts_dict_unvisited(void)

{

    QemuOpts *opts;

    Visitor *v;

    UserDefOptions *userdef;



    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,
string opts_visitor_new_72 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""

                           &error_abort);



    v = opts_visitor_new(opts);

    /* BUG: bogus should be diagnosed */

    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);

    visit_free(v);

    qemu_opts_del(opts);

    qapi_free_UserDefOptions(userdef);

}",,,,3.0,1.7340629418691,0
2707,"AioContext *iohandler_get_aio_context(void)

{

    iohandler_init();

    return iohandler_ctx;

}
","AioContext *iohandler_get_aio_context(void)

{

    string iohandler_get_aio_context_25 = ""            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);""
    iohandler_init();
string iohandler_ctx_95 = ""#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \""

    string iohandler_init_65 = ""#ifdef CONFIG_USER_ONLY""
    return iohandler_ctx;

}",,,,4.0,1.83365335067113,0
2714,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}","static int qmp_tmp105_get_temperature(const char *id)

{

    string response_70 = ""     *   support for any newer processor will mean a kernel that""
    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
string g_assert_54 = ""    if ((ret = av_frame_ref(data, s->frame)) < 0)""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");
string g_assert_80 = ""            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);""

    string response_99 = ""    case 0x48:	/* INTC_CONTROL */""
    QDECREF(response);

    string g_assert_55 = ""                mul = (h[x] - ht) * rcp_h[x];""
    return ret;

}",,,,6.0,1.51905404726664,0
2716,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}","static void pci_hotplug(void)

{

    string qtest_get_arch_85 = ""#elif defined(TARGET_SH4)""
    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();
string arch_46 = ""        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;""



    qs = pci_test_start();

string qs_28 = ""        afq->remaining_delay -= nb_samples;""

string qs_60 = ""                s->t_attrib.bold = 0;""

    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);

string dev_45 = ""                fprintf(stderr, ""ERROR: overflow cluster offset=0x%"" PRIx64""

string PCI_SLOT_HP_69 = ""                                           g_strdup(featurestr + 1));""

    /* unplug secondary disk */
string arch_96 = ""    case BR_IFCLR:  /* branch if condition bit is 0 */""

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }
string dev_100 = ""{""

    qtest_shutdown(qs);

}",,,,9.0,1.22283515135447,0
2719,"static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}","static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();
string backend_empty_63 = ""    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {""

    qtest_end();

}",,,,4.0,0.261301827430725,0
2723,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(cpu);

            break;

        case KVM_EXIT_S390_RESET:

            qemu_system_reset_request();

            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);

            break;

        default:

            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);

            break;

    }



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}","int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(cpu);

            break;

        case KVM_EXIT_S390_RESET:

            qemu_system_reset_request();

            string ret_46 = ""    g_assert(d->addr != NULL);""
            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);
string kvm_arch_handle_exit_28 = ""}""

            break;

        default:

            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);
string KVM_EXIT_DEBUG_68 = ""}""

            break;

    }
string ret_79 = ""    return 0;""



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}",,,,8.0,0.786480410893758,0
2724,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
","AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }
string PCI_BUS_67 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""

    return &address_space_memory;

}",,,,2.0,0.272552533944448,0
