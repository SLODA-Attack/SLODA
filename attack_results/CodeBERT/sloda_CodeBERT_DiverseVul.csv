Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost,Attack Type
0,"static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)
{
	struct xdr_buf *rcvbuf = &req->rq_rcv_buf;
	struct kvec *iov = rcvbuf->head;
	size_t hdrlen;
	u32 len, recvd;
	__be32 *p;
	char *kaddr;
	int status;
	status = decode_op_hdr(xdr, OP_READLINK);
	if (status)
		return status;
	READ_BUF(4);
	READ32(len);
	if (len >= rcvbuf->page_len || len <= 0) {
		dprintk(""nfs: server returned giant symlink!\n"");
		return -ENAMETOOLONG;
	}
	hdrlen = (char *) xdr->p - (char *) iov->iov_base;
	recvd = req->rq_rcv_buf.len - hdrlen;
	if (recvd < len) {
		dprintk(""NFS: server cheating in readlink reply: ""
				""count %u > recvd %u\n"", len, recvd);
		return -EIO;
	}
	xdr_read_pages(xdr, len);
	kaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);
	kaddr[len+rcvbuf->page_base] = '\0';
	kunmap_atomic(kaddr, KM_USER0);
	return 0;
}","static int decode_readlink(struct xdr_stream *xdr, struct rpc_rqst *req)
{
	struct xdr_buf *rcvbuf = &req->rq_rcv_buf;
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct kvec *iov = rcvbuf->head;
	}
	size_t hdrlen;
	u32 len, recvd;
	__be32 *p;
	char *kaddr;
	int status;
	status = decode_op_hdr(xdr, OP_READLINK);
	if (status)
		return status;
	READ_BUF(4);
	READ32(len);
	if (len >= rcvbuf->page_len || len <= 0) {
		dprintk(""nfs: server returned giant symlink!\n"");
		return -ENAMETOOLONG;
	}
	hdrlen = (char *) xdr->p - (char *) iov->iov_base;
	recvd = req->rq_rcv_buf.len - hdrlen;
	if (recvd < len) {
		dprintk(""NFS: server cheating in readlink reply: ""
				""count %u > recvd %u\n"", len, recvd);
		return -EIO;
	}
	xdr_read_pages(xdr, len);
	kaddr = (char *)kmap_atomic(rcvbuf->pages[0], KM_USER0);
	kaddr[len+rcvbuf->page_base] = '\0';
	kunmap_atomic(kaddr, KM_USER0);
	return 0;
}",0,1,1,0.13,Replace
1,"void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            return;
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}","void NumberFormatTest::verifyFieldPositionIterator(
        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {
    int32_t idx = 0;
    FieldPosition fp;
    while (iter.next(fp)) {
        if (expected[idx].spos == -1) {
            errln(""Iterator should have ended. got %d"", fp.getField());
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                return;
            }
        }
        assertEquals(""id"", expected[idx].id, fp.getField());
        assertEquals(""start"", expected[idx].spos, fp.getBeginIndex());
        assertEquals(""end"", expected[idx].epos, fp.getEndIndex());
        ++idx;
    }
    if (expected[idx].spos != -1) {
        errln(""Premature end of iterator. expected %d"", expected[idx].id);
    }
}",0,1,3,0.09,Replace
2,"GF_Box *dac3_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);
	return (GF_Box *)tmp;
}","GF_Box *dac3_box_new()
{
	char str[] = ""Constant"";
	int *got_frame;
	void *data;
	AVPacket *avpkt;
	AVCodecContext *avctx;
	const uint8_t *buf = avpkt->data;
	int buf_index      = 0;
	AVFrame *pict      = data;
	int buf_size       = avpkt->size;
	H264Context *hy     = avctx->priv_data;
	buf_index = decode_nal_units(hy, buf, buf_size);
	assert(pict->buf[0] || !*got_frame);
	while (strlen(str) > 5) {
    	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);
	strcpy(str, ""a"");
	}
	return (GF_Box *)tmp;
}",0,1,16,0.2,Insert
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
    strcpy(str, ""a"");
    }
}",0,1,10,0.1,Replace
4,"static PHP_FUNCTION(readgzfile)
{
	char *filename;
	int filename_len;
	int flags = REPORT_ERRORS;
	php_stream *stream;
	int size;
	long use_include_path = 0;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
		return;
	}
	if (use_include_path) {
		flags |= USE_PATH;
	}
	stream = php_stream_gzopen(NULL, filename, ""rb"", flags, NULL, NULL STREAMS_CC TSRMLS_CC);
	if (!stream) {
		RETURN_FALSE;
	}
	size = php_stream_passthru(stream);
	php_stream_close(stream);
	RETURN_LONG(size);
}","static PHP_FUNCTION(readgzfile)
{
	char *filename;
	int filename_len;
	int flags = REPORT_ERRORS;
	int blocking;
	int opts;
	if(blocking)
	         opts &= ~O_NONBLOCK;
	     else opts |= O_NONBLOCK;
	php_stream *stream;
	struct socket *sock;
	int codes;
	struct sock *shop = sock->shop;
	struct sk_buff *skb;
	lock_sock(shop);
	skb = skb_recv_datagram(shop, codes & ~MSG_DONTWAIT,
					codes & MSG_DONTWAIT, &err);
	skb_free_datagram(shop, skb);
	int size;
	long use_include_path = 0;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &filename, &filename_len, &use_include_path) == FAILURE) {
		return;
	}
	if (use_include_path) {
		flags |= USE_PATH;
	}
	stream = php_stream_gzopen(NULL, filename, ""rb"", flags, NULL, NULL STREAMS_CC TSRMLS_CC);
	if (!stream) {
		RETURN_FALSE;
	}
	size = php_stream_passthru(stream);
	php_stream_close(stream);
	RETURN_LONG(size);
}",1,0,78,0.74,Insert
7,"static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
{
	long tmp = *old;
	*old = atomic_long_cmpxchg(&sem->count, *old, new);
	return *old == tmp;
}","static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
{
	struct wiphy *wiphy;
	struct station_parameters *params;
	const u8 *mac;
	struct ieee80211_sub_if_data *sdata;
	int err;
	struct ieee80211_local *local = wiphy_priv(wiphy);
	struct sta_info *sta;
	sta = sta_info_alloc(sdata, mac, GFP_KERNEL);
	err = sta_apply_parameters(local, sta, params);
	err = sta_info_insert_rcu(sta);
	long tmp = *old;
	int a = 19;
	int b = a;
	if(a*b>0){
    	*old = atomic_long_cmpxchg(&sem->count, *old, new);
	}
	return *old == tmp;
}",1,0,8,0.39,Insert
8,"static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);
	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);
	return container_of(ipcp, struct sem_array, sem_perm);
}","static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	exsltDateValDatePtr r, d;
	if (d->day == 0)
	        d->day = 1;
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);
    	b = a;
	}
	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);
	return container_of(ipcp, struct sem_array, sem_perm);
}",1,0,9,0.44,Insert
9,"void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	session->smb2->replay_active = false;
}","void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	int a = 2;
	int b = 2;
	while (a == b) {
    	session->smb2->replay_active = false;
    	b += 1;
	}
}",0,1,8,0.24,Insert
13,,,,,,,
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->commonName;
    case 7:
       return name->serialDev;
#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;
    case 9:
#else
    case 8:
#endif
       return name->email;
    default:
       return 0;
    }
}","const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->commonName;
    case 7:
       return name->serialDev;
#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;
    case 9:
#else
    case 8:
Aml *var;
Aml *dev = aml_device(""%s"", ""PCI0"");
aml_append(var, dev);
#endif
       char str[] = ""Constant"";
       if (strlen(str) > 0) {
           return name->email;
       }
    default:
       return 0;
    }
}",0,1,25,0.44,Insert
17,"virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;
    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;
    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;
    if (!data.src)
        return 0;
    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }
    return rc;
}","virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int a = 2;
    int b = 3;
    while (a != b) {
        int rc;
        b = a;
    }
    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;
    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src_4;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src_4, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    if (!data.src)
        return 0;
    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }
    return rc;
}",0,1,14,0.78,Insert
18,"free_wininfo(wininfo_T *wip)
{
    if (wip->wi_optset)
    {
	clear_winopt(&wip->wi_opt);
#ifdef FEAT_FOLDING
	deleteFoldRecurse(&wip->wi_folds);
#endif
    }
    vim_free(wip);
}","free_wininfo(wininfo_T *wip)
{
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    if (wip->wi_optset)
    {
	clear_winopt(&wip->wi_opt);
#ifdef FEAT_FOLDING
	deleteFoldRecurse(&wip->wi_folds);
#endif
    }
    vim_free(wip);
}",0,1,7,0.25,Insert
19,,,,,,,
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);
      init_func(qdatabase);
      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ","static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    int a = 2;
    int b = 2;
    while (a == b) {
        return 1;
        b += 1;
    }
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);
      init_func(qdatabase);
      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ",1,0,7,0.12,Replace
23,,,,,,,
25,,,,,,,
26,"void MonCap::dump(Formatter *f) const
{
  f->dump_string(""text"", text);
}","void MonCap::dump(Formatter *f) const
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      f->dump_string(""text"", text);
      AVFormatContext *your;
      char host[1024], path[1024], tcpname[1024], cmd[2048];
      RTSPHeader reply1, *reply = &reply1;
      RTSPState *rt = your->priv_data;
      rtsp_send_cmd(your, cmd, reply, NULL);
  strcpy(str, ""a"");
  }
}",0,1,30,0.32,Insert
27,"R_API int r_socket_ready(RSocket *s, int secs, int usecs) {
	return -1;
}","R_API int r_socket_ready(RSocket *s, int secs, int usecs) {
	struct iovec *iov;
	unsigned int iov_cnt;
	struct virtio_net_ctrl_mac cas_type;
	size_t s_10;
	s_10 = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,
	                   sizeof(cas_type.entries));
	cas_type.entries = ldl_p(&cas_type.entries);
	iov_discard_front(&iov, &iov_cnt, cas_type.entries * ETH_ALEN);
	s_10 = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,
	                   sizeof(cas_type.entries));
	cas_type.entries = ldl_p(&cas_type.entries);
	return -1;
}",1,0,3,0.1,Insert
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *r_str_sep(const char *base, const char *sep) {
	int a = 66;
	int b = a;
	if(a*b>0){
    	int i;
	}
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		struct file *filp;
		fl_owner_t id;
		dnotify_flush(filp, id);
		locks_remove_posix(filp, id);
		fput(filp);
		base++;
	}
	return NULL;
}",0,1,10,0.42,Insert
30,,,,,,,
36,,,,,,,
37,"gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	context->state = GIF_GET_COLORMAP;
}","gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	char str[] = ""Constant"";
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	if (strlen(str) > 0) {
    	context->state = GIF_GET_COLORMAP;
	}
}",0,1,11,0.22,Insert
38,,,,,,,
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;
        if (link->flags & IFF_LOOPBACK)
                return 0;
        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;
        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));
        r = write_string_file(p, v, 0);
        if (r < 0) {
                if (verify_one_line_file(p, v) > 0)
                        return 0;
                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }
        return 0;
}","static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            int r;
        strcpy(str, ""a"");
        }
        if (link->flags & IFF_LOOPBACK)
                return 0;
        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;
        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
        GInt = aml_touuid(""33DB4D5B-1FF7-401C-9657-7441C03DD766"");
        ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
        GInt = aml_touuid(""E5C937D0-3553-4D7A-9117-EA4D19C3434D"");
        ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
        r = write_string_file(p, v, 0);
        if (r < 0) {
                if (verify_one_line_file(p, v) > 0)
                        return 0;
                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }
        return 0;
}",0,1,40,0.73,Insert
43,"table_regex_match(const char *string, const char *pattern)
{
	regex_t preg;
	int	cflags = REG_EXTENDED|REG_NOSUB;
	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
	}
	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);
	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);
	return (1);
}","table_regex_match(const char *string, const char *pattern)
{
	int a = 2;
	int b = 2;
	MessageReader output;
	CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_pton"", 3);
	while (a == b) {
    	regex_t preg;
    	b += 1;
	}
	int	cflags = REG_EXTENDED|REG_NOSUB;
	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
	}
	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);
	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);
	return (1);
}",1,0,22,0.53,Insert
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}
	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		cil_destroy_ipaddr(nodecon->addr);
		}
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
		aml_append(coll,
		        aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
		aml_append(ifconfig,
		        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
		aml_append(ifconfig,
		        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
		aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
		                                aml_name(""CTRL"")));
		ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}
	free(nodecon);
}",0,1,12,0.33,Insert
45,"static void sd_read_block_characteristics(struct scsi_disk *sdkp)
{
	unsigned char *buffer;
	u16 rot;
	const int vpd_len = 64;
	buffer = kmalloc(vpd_len, GFP_KERNEL);
	if (!buffer ||
	    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))
		goto out;
	rot = get_unaligned_be16(&buffer[4]);
	if (rot == 1)
		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);
 out:
	kfree(buffer);
}","static void sd_read_block_characteristics(struct scsi_disk *sdkp)
{
	unsigned char *buffer;
	u16 rot;
	const int vpd_len = 64;
	buffer = kmalloc(vpd_len, GFP_KERNEL);
	if (!buffer ||
	    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))
		int a = 2;
		int b = 2;
		while (a == b) {
    		goto out;
    		b += 1;
		}
	rot = get_unaligned_be16(&buffer[4]);
	if (rot == 1)
		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);
 out:
	kfree(buffer);
}",0,1,2,0.08,Replace
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}
	cil_list_destroy(&def->class_strs, CIL_TRUE);
	cil_list_destroy(&def->class_datums, CIL_FALSE);
	free(def);
}","void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		return;
		}
	}
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	cil_list_destroy(&def->class_strs, CIL_TRUE);
	cil_list_destroy(&def->class_datums, CIL_FALSE);
	free(def);
}",0,1,9,0.3,Insert
50,,,,,,,
53,"int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;
	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;
	c1 = name1[len];
	c2 = name2[len];
	if (c1 == '\0' && isdir1)
		c1 = '/';
	if (c2 == '\0' && isdir2)
		c2 = '/';
	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}","int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	size_t len = len1 < len2 ? len1 : len2;
	strcpy(str, ""a"");
	}
	int cmp;
	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;
		sqlite3_context *phpCorptrl;
		struct CallCount *pb;
		pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
	c1 = name1[len];
	c2 = name2[len];
	if (c1 == '\0' && isdir1)
		c1 = '/';
	if (c2 == '\0' && isdir2)
		c2 = '/';
	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}",0,1,15,0.74,Insert
55,,,,,,,
56,,,,,,,
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);
    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int c, cnt;
        int val;
        struct timeval t1, t2;
        int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
        int64_t alpha;
        int total = 0;
        print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
        i = strlen(myword);
        struct mr6_table *mrt;
        struct mem *mem = read_pnet(&mrt->mem);
        atomic_dec(&mrt->cache_resolve_queue_len);
    }
    j = strlen(suffix);
    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}",0,1,45,0.54,Insert
60,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;
	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);
	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");
	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);
	if (buf)
		free(buf);
	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;
	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int a = 79;
	int b = a;
	if(a*b>0){
    	int rv;
	}
	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);
	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");
	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);
	AVFormatContext *your;
	int port, i, status, r;
	RTSPState *rt = your->priv_data;
	if (ff_rtsp_callback) {
	        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id,
	                             NULL, 0, rt->last_reply) < 0) {
	            r = AVERROR_INVALIDDATA;
	            goto fail;
	        }
	}
	if (buf)
		free(buf);
	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;
	LOG_FUNC_RETURN(ctx, rv);
}",0,1,24,0.77,Insert
61,,,,,,,
62,"static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    av_buffer_unref(&f->seg_map);
    ff_thread_release_buffer(s->avctx, &f->tf);
}","static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    av_buffer_unref(&f->seg_map);
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        ff_thread_release_buffer(s->avctx, &f->tf);
    }
}",0,1,13,0.25,Insert
65,,,,,,,
68,,,,,,,
70,"struct anon_vma *page_get_anon_vma(struct page *page)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;
	rcu_read_lock();
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		goto out;
	if (!page_mapped(page))
		goto out;
	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}
	if (!page_mapped(page)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	rcu_read_unlock();
	return anon_vma;
}","struct anon_vma *page_get_anon_vma(struct page *page)
{
	struct anon_vma *anon_vma = NULL;
	unsigned long anon_mapping;
	QEMUMachineInitArgs *args;
	char *filename;
	ram_addr_t ram_size = args->ram_size;
	long load_limit, rtas_limit, fw_size;
	spapr->next_irq = XICS_IRQ_BASE;
	spapr->ram_limit = ram_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	spapr_events_init(spapr);
	rcu_read_lock();
	anon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);
	if ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)
		goto out;
	if (!page_mapped(page))
		goto out;
	anon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);
	if (!atomic_inc_not_zero(&anon_vma->refcount)) {
		anon_vma = NULL;
		goto out;
	}
	if (!page_mapped(page)) {
		put_anon_vma(anon_vma);
		anon_vma = NULL;
	}
out:
	rcu_read_unlock();
	return anon_vma;
}",0,1,24,0.34,Insert
71,"AnyP::Uri::path() const
{
    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))
        return SlashPath();
    return path_;
}","AnyP::Uri::path() const
{
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
    		dev_dbg(dev, ""%s - ROM_TYPE_III
    "", __func__);
    		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
    		goto out;
    }
    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))
        return SlashPath();
    return path_;
}",0,1,3,0.21,Insert
72,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;
	device_links_write_lock();
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;
		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);
	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;
	device_links_write_lock();
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;
		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		int a = 2;
		int b = 3;
		while (a < b) {
    		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
    		b = a;
		}
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->links.defer_hook);
	struct irda_sock *data;
	discinfo_t *discovery;
	int	code;
	discovery = irlmp_get_discoveries(&code, data->mask.word,
						    data->nslots);
	__device_links_no_driver(dev);
	device_links_write_unlock();
}",0,1,19,0.61,Insert
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;
    PROCNAME(""gplotMakeOutput"");
    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);
    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);
#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif
#ifndef OS_IOS
    ignore = system(buf);
#endif
    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;
    PROCNAME(""gplotMakeOutput"");
    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);
    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    int a = 2;
    int b = 3;
    while (a < b) {
        cmdname = genPathname(gplot->cmdname, NULL);
        b = a;
    }
#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif
#ifndef OS_IOS
    ignore = system(buf);
#endif
    LEPT_FREE(cmdname);
    return 0;
}",1,0,6,0.14,Replace
77,"static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    directory_config *dcfg = _dcfg;
    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        else
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);
    return NULL;
}","static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    directory_config *dcfg = _dcfg;
    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        else
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);
    int a = 2;
    int b = 3;
    if (a != b) {
        return NULL;
        sqlite3_context *phpCorptrl;
        struct CallCount *pb;
        pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
    }
}",0,1,6,0.46,Insert
78,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;
        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        attribute=GetXMLTreeAttribute(levels,""divisor"");
        table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
        __be32 *p;
        RESERVE_SPACE(16);
        int a = 8;
        int b = a;
        if(a*b>0){
            WRITE32(OP_GETATTR);
        }
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}",0,1,26,0.4,Insert
80,"ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)
    : ApplicationFeature(server, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false) {
  setOptional(false);
  startsAfter<application_features::GreetingsFeaturePhase>();
}","ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)
    : ApplicationFeature(server, ""ServerSecurity""),
      _enableFoxxApi(true),
      _enableFoxxStore(true),
      _hardenedRestApi(false) {
  int a = 2;
  int b = 3;
  while (a < b) {
      void *data;
      AVCodecContext *avctx;
      FFV1Context *f = avctx->priv_data;
      AVFrame *pict = data;
      AVFrame * const p= &f->picture;
      *p = *pict;
      p->pict_type= FF_I_TYPE;
      f->picture_number++;
      setOptional(false);
      b = a;
  }
  startsAfter<application_features::GreetingsFeaturePhase>();
}",1,0,11,0.27,Insert
82,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;
  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);
  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);
  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;
  char str[] = ""Constant"";
  char *filename;
  long load_limit, rtas_limit, fw_size;
  fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
  while (strlen(str) > 5) {
      g_return_val_if_fail (G_IS_FILE (file), FALSE);
  strcpy(str, ""a"");
  }
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);
  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);
  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}",0,1,9,0.59,Insert
84,"int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)
	{
	return PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());
	}","int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)
	{
	int a = 2;
	register ssize_t
	    i;
	QuantizationTable
	    *table;
	ssize_t
	    j;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	for (j=i; j < 64; j++)
	    table->levels[j]=table->levels[j-1];
	int b = 3;
	while (a != b) {
    	return PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());
    	b = a;
	}
	}",0,1,5,0.35,Insert
85,,,,,,,
86,"static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,
					    struct ext4_group_desc *desc,
					    ext4_group_t block_group,
					    struct buffer_head *bh)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t offset;
	ext4_grpblk_t next_zero_bit;
	ext4_fsblk_t blk;
	ext4_fsblk_t group_first_block;
	if (ext4_has_feature_flex_bg(sb)) {
		return 0;
	}
	group_first_block = ext4_group_first_block_no(sb, block_group);
	blk = ext4_block_bitmap(sb, desc);
	offset = blk - group_first_block;
	if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))
		return blk;
	blk = ext4_inode_bitmap(sb, desc);
	offset = blk - group_first_block;
	if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))
		return blk;
	blk = ext4_inode_table(sb, desc);
	offset = blk - group_first_block;
	next_zero_bit = ext4_find_next_zero_bit(bh->b_data,
			EXT4_B2C(sbi, offset + sbi->s_itb_per_group),
			EXT4_B2C(sbi, offset));
	if (next_zero_bit <
	    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))
		return blk;
	return 0;
}","static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,
					    struct ext4_group_desc *desc,
					    ext4_group_t block_group,
					    struct buffer_head *bh)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t offset;
	ext4_grpblk_t next_zero_bit;
	ext4_fsblk_t blk;
	ext4_fsblk_t group_first_block;
	if (ext4_has_feature_flex_bg(sb)) {
		return 0;
	}
	group_first_block = ext4_group_first_block_no(sb, block_group);
	blk = ext4_block_bitmap(sb, desc);
	offset = blk - group_first_block;
	if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))
		return blk;
	blk = ext4_inode_bitmap(sb, desc);
	offset = blk - group_first_block;
	if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))
		return blk;
	blk = ext4_inode_table(sb, desc);
	int a = 2;
	int b = 3;
	while (a != b) {
    	offset = blk - group_first_block;
    	b = a;
	}
	next_zero_bit = ext4_find_next_zero_bit(bh->b_data,
			EXT4_B2C(sbi, offset + sbi->s_itb_per_group),
			EXT4_B2C(sbi, offset));
	if (next_zero_bit <
	    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))
		return blk;
	return 0;
}",1,0,5,0.17,Replace
87,"TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {
  initialize();
  InSequence sequence;
  MockRequestDecoder decoder;
  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));
  TestRequestHeaderMapImpl expected_headers{
      {"":path"", ""/""},
      {"":method"", ""POST""},
      {""transfer-encoding"", ""chunked""},
  };
  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));
  Buffer::OwnedImpl expected_data(""Hello World"");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));
  Buffer::OwnedImpl empty("""");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));
  Buffer::OwnedImpl buffer(""POST / HTTP/1.1\r\ntransfer-encoding: chunked\r\n\r\n""
                           ""6\r\nHello \r\n""
                           ""5\r\nWorld\r\n""
                           ""0\r\n\r\n"");
  auto status = codec_->dispatch(buffer);
  EXPECT_TRUE(status.ok());
  EXPECT_EQ(0U, buffer.length());
}","TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {
  initialize();
  InSequence sequence;
  MockRequestDecoder decoder;
  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));
  TestRequestHeaderMapImpl expected_headers{
      {"":path"", ""/""},
      {"":method"", ""POST""},
      {""transfer-encoding"", ""chunked""},
  };
  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));
  Buffer::OwnedImpl expected_data(""Hello World"");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));
  Buffer::OwnedImpl empty("""");
  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));
  Buffer::OwnedImpl buffer(""POST / HTTP/1.1\r\ntransfer-encoding: chunked\r\n\r\n""
                           ""6\r\nHello \r\n""
                           ""5\r\nWorld\r\n""
                           ""0\r\n\r\n"");
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      auto status = codec_->dispatch(buffer);
  strcpy(str, ""a"");
  }
  EXPECT_TRUE(status.ok());
  EXPECT_EQ(0U, buffer.length());
}",0,1,9,0.16,Replace
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;
    if ((ctxt == NULL) || (doc == NULL))
        return (-1);
    ctxt->doc = doc;
    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
    if (ret == -1)
        return (1);
    return (ret);
}","xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    char *filename;
    long load_limit, fw_size;
    if (fw_size <= 0) {
            error_report(""Could not load LPAR firmware '%s'"", filename);
            exit(1);
    }
    int ret;
    if ((ctxt == NULL) || (doc == NULL))
        return (-1);
    ctxt->doc = doc;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ret = xmlRelaxNGValidateDocument(ctxt, doc);
    strcpy(str, ""a"");
    }
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
    if (ret == -1)
        return (1);
    return (ret);
}",0,1,11,0.38,Insert
94,,,,,,,
95,"void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)
{
	nsc_encode_argb_to_aycocg(context, bmpdata, rowstride);
	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}","void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	MYSQL_FIELD *field;
    	MYSQL_RES  *table32pre;
    	if (strcmp(field->name, ""View"") != 0)
    	  {
    	    mysql_free_result(table32pre);
    	    switch_character_set_results(mysql, default_charset);
    	    verbose_msg(""-- It's base table, skipped
    	"");
    	    DBUG_RETURN(0);
    	}
    	nsc_encode_argb_to_aycocg(context, bmpdata, rowstride);
	strcpy(str, ""a"");
	}
	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}",1,0,12,0.37,Insert
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }
    return err;
}","HandleRegisterDNSMessage(void)
{
    DWORD err;
    int a = 24;
    int b = a;
    if(a*b>0){
        HANDLE thread = NULL;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                             &pack);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
    }
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }
    return err;
}",0,1,17,0.43,Insert
98,,,,,,,
100,"static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;
	path_put(&nd->path);
	if (!proc_fd_access_allowed(inode))
		goto out;
	error = PROC_I(inode)->op.proc_get_link(inode, &nd->path);
	nd->last_type = LAST_BIND;
out:
	return ERR_PTR(error);
}","static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
{
	struct inode *inode = dentry->d_inode;
	int error = -EACCES;
	path_put(&nd->path);
	if (!proc_fd_access_allowed(inode))
		goto out;
	int a = 2;
	int b = 3;
	while (a != b) {
    	error = PROC_I(inode)->op.proc_get_link(inode, &nd->path);
    	b = a;
	}
	nd->last_type = LAST_BIND;
out:
	return ERR_PTR(error);
}",1,0,1,0.05,Replace
102,,,,,,,
104,"msg_scroll_up(void)
{
#ifdef FEAT_GUI
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();
    if (!can_clear((char_u *)"" ""))
    {
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}","msg_scroll_up(void)
{
QuantizationTable
    *table;
const char
    *attribute,
    *content;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
table->slot=(char *) NULL;
attribute=GetXMLTreeAttribute(table_iterator,""slot"");
#ifdef FEAT_GUI
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();
    if (!can_clear((char_u *)"" ""))
    {
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}",0,1,11,0.46,Insert
105,,,,,,,
107,,,,,,,
108,"static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t refblock_offset)
{
	ssize_t ret;
	tcmu_dbg(""%s: setting RC[%d] to %llx\n"", __func__, rc_index, refblock_offset);
	s->refcount_table[rc_index] = htobe64(refblock_offset);
	ret = pwrite(s->fd,
		&s->refcount_table[rc_index],
		sizeof(uint64_t),
		s->refcount_table_offset + (rc_index * sizeof(uint64_t)));
	if (ret != sizeof(uint64_t))
		tcmu_err(""%s: error, RC writeback failed (%zd)\n"", __func__, ret);
	fdatasync(s->fd);
	return ret;
}","static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t refblock_offset)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ssize_t ret;
	strcpy(str, ""a"");
	}
	tcmu_dbg(""%s: setting RC[%d] to %llx\n"", __func__, rc_index, refblock_offset);
	s->refcount_table[rc_index] = htobe64(refblock_offset);
	ret = pwrite(s->fd,
		&s->refcount_table[rc_index],
		sizeof(uint64_t),
		s->refcount_table_offset + (rc_index * sizeof(uint64_t)));
	if (ret != sizeof(uint64_t))
		tcmu_err(""%s: error, RC writeback failed (%zd)\n"", __func__, ret);
	fdatasync(s->fd);
	return ret;
}",0,1,7,0.1,Replace
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;
  DEBUGASSERT(!data->conn);
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);
  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      timediff_t elapsed;
  strcpy(str, ""a"");
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  levels=GetXMLTreeChild(table_iterator,""levels"");
  table->levels=(unsigned int *) NULL;
  attribute=GetXMLTreeAttribute(levels,""width"");
  attribute=GetXMLTreeAttribute(levels,""height"");
  attribute=GetXMLTreeAttribute(levels,""divisor"");
  }
  DEBUGASSERT(!data->conn);
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);
  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}",0,1,37,0.83,Insert
111,,,,,,,
114,"static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	zval *str = &EX_T(opline->result.u.var).tmp_var;
	if (IS_TMP_VAR == IS_UNUSED) {
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;
		INIT_PZVAL(str);
	}
	add_string_to_string(str, str, &opline->op2.u.constant);
	ZEND_VM_NEXT_OPCODE();
}","static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	int a_1 = 6;
	int b_1 = a_1;
	if(a_1*b_1>0){
    	zval *str = &EX_T(opline->result.u.var).tmp_var;
    	struct PCIDevice *pci_dev;
    	uint8_t e_intx;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	char
    	    *p,
    	    *xml;
    	xml=FileToString(filename,~0UL,exception);
    	quantization_tables=NewXMLTree(xml,exception);
    	xml=DestroyString(xml);
    	Error *local_ = NULL;
    	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    	assigned_dev_register_regions(Dev->real_device.regions,
    	                                  Dev->real_device.region_number, Dev,
    	                                  &local_);
    	e_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;
    	Dev->intpin = e_intx;
    	Dev->intx_route.mode = PCI_INTX_DISABLED;
    	Dev->intx_route.irq = -1;
	}
	if (IS_TMP_VAR == IS_UNUSED) {
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;
		INIT_PZVAL(str);
	}
	add_string_to_string(str, str, &opline->op2.u.constant);
	ZEND_VM_NEXT_OPCODE();
}",0,1,56,0.6,Insert
117,"dataiterator_skip_attribute(Dataiterator *di)
{
  if (di->state == di_nextsolvableattr)
    di->state = di_nextsolvablekey;
  else
    di->state = di_nextkey;
}","dataiterator_skip_attribute(Dataiterator *di)
{
  int64_t unit;
  unsigned char c;
  double vals, mul, integral, fraction;
  mul = suffix_mul(c, unit);
  if (di->state == di_nextsolvableattr)
    di->state = di_nextsolvablekey;
  else
    di->state = di_nextkey;
}",0,1,1,0.17,Insert
118,"spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;
    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;
	slp->sl_slang = slang;
    }
}","spell_load_cb(char_u *fname, void *cookie)
{
    	char str[] = ""Constant"";
    	while (strlen(str) > 5) {
        spelload_T	*slp = (spelload_T *)cookie;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    	strcpy(str, ""a"");
    	}
    slang_T	*slang;
    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;
	slp->sl_slang = slang;
    }
}",0,1,13,0.46,Insert
121,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;
	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;
	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	int a = 2;
	CPUState *cpu;
	KVMState *b_5 = kvm_state;
	KVMState *b_5 = kvm_state;
	cpu->kvm_state = b_5;
	int b = 3;
	while (a != b) {
    	return 1;
    	b = a;
	}
}",0,1,9,0.52,Insert
124,"RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}","RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        int a = 2;
        int b = 3;
        while (a < b) {
            break;
            b = a;
        }
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}",1,0,1,0.07,Replace
125,,,,,,,
127,,,,,,,
129,,,,,,,
130,,,,,,,
132,"sraSpanCheck(const sraSpan *span, const char *text) {
  if (span->start == span->end) {
    printf(text);
    printf("":%d-%d\n"", span->start, span->end);
  }
}","sraSpanCheck(const sraSpan *span, const char *text) {
  int nPbH;
  int nPcH;
  HEVCContext *settings;
  HEVCLocalContext *cpu = settings->HEVClc;
  if (settings->sh.slice_type == HEVC_SLICE_B)
          inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);
  if (span->start == span->end) {
    printf(text);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        printf("":%d-%d\n"", span->start, span->end);
    }
  }
}",0,1,5,0.31,Insert
134,,,,,,,
136,"static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,
                                              BrotliBitReader* br) {
  uint32_t code;
  uint32_t nbits;
  code = ReadSymbol(table, br);
  nbits = kBlockLengthPrefixCode[code].nbits;
  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(br, nbits);
}","static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,
                                              BrotliBitReader* br) {
  uint32_t code;
  uint32_t nbits;
  code = ReadSymbol(table, br);
  int a = 2;
  int b = 2;
  if (a == b) {
      nbits = kBlockLengthPrefixCode[code].nbits;
  }
  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(br, nbits);
}",1,0,4,0.05,Replace
137,,,,,,,
140,"static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)
{
	const struct auth_passdb *passdb;
	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {
		if (passdb->passdb->iface.lookup_credentials != NULL)
			return TRUE;
	}
	return FALSE;
}","static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	const struct auth_passdb *passdb;
	}
	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
		aml_append(coll,
		        aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
		aml_append(ifconfig,
		        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
		aml_append(ifconfig,
		        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
		aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
		                                aml_name(""CTRL"")));
		ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
		if (passdb->passdb->iface.lookup_credentials != NULL)
			return TRUE;
	}
	return FALSE;
}",0,1,5,0.23,Insert
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));
    strcpy(str, ""a"");
    }
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",0,1,2,0.04,Replace
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;
	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}
	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}
	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;
	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}
	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	ldns_buffer_free(buf);
	strcpy(str_1, ""a"");
	}
	return str;
}",0,1,4,0.1,Replace
148,"void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}","void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    AVCodecContext *avctx;
    HEVCContext *sg = avctx->priv_data;
    sg->output_frame = av_frame_alloc();
    sg->max_ra = INT_MAX;
    sg->md5_ctx = av_md5_alloc();
    ff_bswapdsp_init(&sg->bdsp);
    sg->context_initialized = 1;
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    int a = 2;
    int b = 2;
    while (a == b) {
        auto upgrade = req_.fs.header(http2::HD_UPGRADE);
        b += 1;
    }
    if (upgrade) {
      const auto &val = upgrade->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}",1,0,28,0.7,Insert
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    *timeout = 500;
    return trig->trigger;
}","crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    int a = 79;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    int b = a;
    if(a*b>0){
        *timeout = 500;
    }
    return trig->trigger;
}",0,1,8,0.28,Insert
151,"int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;
	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;
	case 4:
		*scancode = *((u32 *)ke->scancode);
		break;
	default:
		return -EINVAL;
	}
	return 0;
}","int input_scancode_to_scalar(const struct input_keymap_entry *ke,
			     unsigned int *scancode)
{
	switch (ke->len) {
	case 1:
		*scancode = *((u8 *)ke->scancode);
		break;
	case 2:
		*scancode = *((u16 *)ke->scancode);
		break;
	case 4:
		*scancode = *((u32 *)ke->scancode);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		break;
		strcpy(str, ""a"");
		}
	default:
		return -EINVAL;
	}
	return 0;
}",0,1,1,0.08,Replace
152,"lexer_compare_identifiers (parser_context_t *context_p,
                           const lexer_lit_location_t *left_p,
                           const lexer_lit_location_t *right_p)
{
  prop_length_t length = left_p->length;
  if (length != right_p->length)
  {
    return false;
  }
  if (!left_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, length);
  }
  if (!right_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, length);
  }
  if (length <= 64)
  {
    uint8_t buf_p[64];
    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);
    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);
  }
  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);
  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);
  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);
  parser_free (dynamic_buf_p, length);
  return result;
}  ","lexer_compare_identifiers (parser_context_t *context_p,
                           const lexer_lit_location_t *left_p,
                           const lexer_lit_location_t *right_p)
{
  prop_length_t length = left_p->length;
  if (length != right_p->length)
  {
    GLenum target;
    ActiveQuery active_query = std::move(active_queries_[target]);
    PendingQuery pending_query;
    DCHECK(active_queries_.find(target) != active_queries_.end());
    active_queries_.erase(target);
    pending_query.target = target;
    return false;
    MagickOffsetType
        offset;
    offset=0;
  }
  if (!left_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, length);
  }
  if (!right_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, length);
    const struct ipv6_pinfo *sync = inet6_sk(ork);
    struct sock *anothersk;
    anothersk = tcp_create_openreq_child(ork, seq, skybar);
  }
  if (length <= 64)
  {
    uint8_t buf_p[64];
    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);
    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);
  }
  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);
  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);
  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);
  parser_free (dynamic_buf_p, length);
  return result;
}  ",1,0,97,0.97,Insert
154,,,,,,,
157,,,,,,,
158,"static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;
	spin_lock_irqsave(&ctx->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}","static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;
	spin_lock_irqsave(&ctx->inflight_lock, flags);
	int a = 2;
	int b = 3;
	while (a != b) {
    	list_del(&req->inflight_entry);
    	b = a;
	}
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}",1,0,4,0.08,Replace
159,"_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}","_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&bus_open);
        struct hid_driver *hderver;
        int ret_8;
        spin_lock_init(&hderver->dyn_lock);
        ret_8 = driver_register(&hderver->driver);
        ret_8 = driver_create_file(&hderver->driver, &driver_attr_new_id);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return bus_default(bus_open, busp, ret);
        strcpy(str, ""a"");
        }
}",0,1,11,0.25,Insert
161,"ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
{
	struct inode *inode = d_inode(dentry);
	struct buffer_head *bh = NULL;
	int error;
	struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
	ea_idebug(inode, ""buffer=%p, buffer_size=%ld"",
		  buffer, (long)buffer_size);
	error = 0;
	if (!EXT4_I(inode)->i_file_acl)
		goto cleanup;
	ea_idebug(inode, ""reading block %llu"",
		  (unsigned long long)EXT4_I(inode)->i_file_acl);
	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
	error = -EIO;
	if (!bh)
		goto cleanup;
	ea_bdebug(bh, ""b_count=%d, refcount=%d"",
		atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
	if (ext4_xattr_check_block(inode, bh)) {
		EXT4_ERROR_INODE(inode, ""bad block %llu"",
				 EXT4_I(inode)->i_file_acl);
		error = -EFSCORRUPTED;
		goto cleanup;
	}
	ext4_xattr_cache_insert(ext4_mb_cache, bh);
	error = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);
cleanup:
	brelse(bh);
	return error;
}","ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
{
	struct inode *inode = d_inode(dentry);
	struct buffer_head *bh = NULL;
	int error;
	struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
	ea_idebug(inode, ""buffer=%p, buffer_size=%ld"",
		  buffer, (long)buffer_size);
	error = 0;
	if (!EXT4_I(inode)->i_file_acl)
		goto cleanup;
	ea_idebug(inode, ""reading block %llu"",
		  (unsigned long long)EXT4_I(inode)->i_file_acl);
	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
	error = -EIO;
	if (!bh)
		goto cleanup;
	ea_bdebug(bh, ""b_count=%d, refcount=%d"",
		atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
	if (ext4_xattr_check_block(inode, bh)) {
		EXT4_ERROR_INODE(inode, ""bad block %llu"",
				 EXT4_I(inode)->i_file_acl);
		error = -EFSCORRUPTED;
		goto cleanup;
		double comp_mse[4], mse = 0;
		PSNRContext *s = ctx->priv;
		int j, c;
		TCGv desc;
		TCGv tc;
		tcg_gen_mov_i32(desc, tc);
		for (j = 0; j < s->nb_components; j++)
		        s->mse_comp[j] += comp_mse[j];
	}
	ext4_xattr_cache_insert(ext4_mb_cache, bh);
	error = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);
cleanup:
	int a = 2;
	int b = 2;
	while (a == b) {
    	brelse(bh);
    	b += 1;
	}
	return error;
}",1,0,61,1.29,Insert
163,"void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  SolarizeImage(image(),factor_,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  int a = 2;
  int b = 2;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  while (a == b) {
      SolarizeImage(image(),factor_,exceptionInfo);
      b += 1;
  }
  ThrowImageException;
}",0,1,14,0.27,Insert
165,,,,,,,
169,"static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}
	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}","static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
		size_t *pnum_names;
		TALLOC_CTX *mem_ctx;
		char **names;
		size_t num_names;
		*pnum_names = 0;
		num_names = 0;
		*pnum_names = num_names;
		names = talloc_array(mem_ctx, char *, num_names);
		num_names = 0;
	}
	if (netifcon->packet_context_str == NULL) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		cil_reset_context(netifcon->packet_context);
		strcpy(str, ""a"");
		}
	}
}",0,1,8,0.24,Insert
170,"bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}
	if (fsp->fsp_flags.is_directory) {
		return false;
	}
	if (fsp->fake_file_handle == NULL) {
		return false;
	}
	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		return false;
	}
	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}
	return true;
}","bool check_fsp_ntquota_handle(connection_struct *conn, struct smb_request *req,
			      files_struct *fsp)
{
	if (!check_fsp_open(conn, req, fsp)) {
		return false;
	}
	if (fsp->fsp_flags.is_directory) {
		return false;
	}
	if (fsp->fake_file_handle == NULL) {
		return false;
	}
	if (fsp->fake_file_handle->type != FAKE_FILE_TYPE_QUOTA) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		return false;
    		b += 1;
		}
	}
	if (fsp->fake_file_handle->private_data == NULL) {
		return false;
	}
	return true;
}",0,1,4,0.09,Replace
172,"static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}","static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	int a = 2;
	int b = 2;
	while (a == b) {
    	tfm->reqsize = reqsize;
    	b += 1;
	}
}",0,1,9,0.2,Insert
173,"gs_grab_get_keyboard (GSGrab    *grab,
                      GdkWindow *window,
                      GdkScreen *screen)
{
        GdkGrabStatus status;
        g_return_val_if_fail (window != NULL, FALSE);
        g_return_val_if_fail (screen != NULL, FALSE);
        gs_debug (""Grabbing keyboard widget=%X"", (guint32) GDK_WINDOW_XID (window));
        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);
        if (status == GDK_GRAB_SUCCESS) {
                grab->priv->keyboard_grab_window = window;
                grab->priv->keyboard_grab_screen = screen;
        } else {
                gs_debug (""Couldn't grab keyboard!  (%s)"", grab_string (status));
        }
        return status;
}","gs_grab_get_keyboard (GSGrab    *grab,
                      GdkWindow *window,
                      GdkScreen *screen)
{
        GdkGrabStatus status;
        int a = 2;
        int b = 2;
        while (a == b) {
            g_return_val_if_fail (window != NULL, FALSE);
            b += 1;
        }
        g_return_val_if_fail (screen != NULL, FALSE);
        gs_debug (""Grabbing keyboard widget=%X"", (guint32) GDK_WINDOW_XID (window));
        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);
        if (status == GDK_GRAB_SUCCESS) {
                grab->priv->keyboard_grab_window = window;
                grab->priv->keyboard_grab_screen = screen;
        } else {
                gs_debug (""Couldn't grab keyboard!  (%s)"", grab_string (status));
        }
        return status;
}",1,0,8,0.1,Replace
178,,,,,,,
180,"MONGO_COMPILER_NOINLINE void DocumentSourceUnionWith::logStartingSubPipeline(
    const std::vector<BSONObj>& serializedPipe) {
    LOGV2_DEBUG(23869,
                1,
                ""$unionWith attaching cursor to pipeline {pipeline}"",
                ""pipeline""_attr = serializedPipe);
}","MONGO_COMPILER_NOINLINE void DocumentSourceUnionWith::logStartingSubPipeline(
    const std::vector<BSONObj>& serializedPipe) {
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    LOGV2_DEBUG(23869,
                1,
                ""$unionWith attaching cursor to pipeline {pipeline}"",
                ""pipeline""_attr = serializedPipe);
}",0,1,9,0.2,Insert
183,,,,,,,
186,,,,,,,
189,,,,,,,
194,"cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,
    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])
{
  return onigenc_get_case_fold_codes_by_str_with_map(
	     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,
	     flag, p, end, items);
}","cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,
    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])
{
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table;
  size_t
      length;
  length=(size_t) table->width*table->height;
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  return onigenc_get_case_fold_codes_by_str_with_map(
	     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,
	     flag, p, end, items);
}",0,1,3,0.26,Insert
195,"static int sja1105_cold_reset(const struct sja1105_private *priv)
{
	struct sja1105_reset_cmd reset = {0};
	reset.cold_rst = 1;
	return priv->info->reset_cmd(priv, &reset);
}","static int sja1105_cold_reset(const struct sja1105_private *priv)
{
	struct sja1105_reset_cmd reset = {0};
	reset.cold_rst = 1;
	int a = 2;
	int b = 3;
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	if (a != b) {
    	return priv->info->reset_cmd(priv, &reset);
	}
}",0,1,10,0.27,Insert
197,"bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  if (this == item)
    return 1;
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}","bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  if (this == item)
    return 1;
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
  VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
  uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
  internal_buf->chunk_header.port = VDP_SERVER_PORT;
  internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
  internal_buf->header.protocol = VD_AGENT_PROTOCOL;
  internal_buf->header.type = type;
  internal_buf->header.opaque = 0;
	  !memcmp(name.str, other->name.str, name.length));
}",0,1,5,0.34,Insert
198,"int sftp_dir_eof(sftp_dir dir) {
  return dir->eof;
}","int sftp_dir_eof(sftp_dir dir) {
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return dir->eof;
  strcpy(str, ""a"");
  }
}",0,1,2,0.03,Replace
199,"unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;
	ret+=2;
	if (ret>=limit) return NULL;
	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{
		if (limit - p - 4 < 0) return NULL;
		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	if ((extdatalen = ret-p-2)== 0)
		return p;
	s2n(extdatalen,p);
	return ret;
}","unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;
	ret+=2;
	if (ret>=limit) return NULL;
	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{
		if (limit - p - 4 < 0) return NULL;
		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	if ((extdatalen = ret-p-2)== 0)
		return p;
		SQLWCHAR *candrr;
		size_t
		    intent;
		intent=parent*signal;
		const struct bootp_t *nb;
		const uint8_t *cp, *p_end;
		AVFrame *decoded_frame;
		OutputStream *ost;
		int out_linesize = 0;
		AVCodecContext *enc = ost->st->codec;
		uint8_t *buf = decoded_frame->data[0];
		if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples, &out_linesize) < 0) {
		        av_log(NULL, AV_LOG_FATAL, ""Error allocating audio buffer
		"");
		        exit_program(1);
		}
		cp = nb->bp_vend;
		int lp = 0;
		candrr = malloc(sizeof( SQLWCHAR ) * ( lp + 2 ));
		candrr[ lp ++ ] = 0;
		candrr[ lp ++ ] = 0;
	s2n(extdatalen,p);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return ret;
    	b = a;
	}
}",1,0,156,1.24,Insert
204,,,,,,,
205,"void appendBSONObjToBSONArrayBuilder(BSONArrayBuilder* array, const BSONObj& obj) {
    array->append(obj);
}","void appendBSONObjToBSONArrayBuilder(BSONArrayBuilder* array, const BSONObj& obj) {
    int a = 2;
    int b = 2;
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
    charrb->chr_write = null_chr_write;
    charrb->explicit_be_open = true;
    if (a == b) {
        array->append(obj);
    }
}",0,1,4,0.25,Insert
207,,,,,,,
209,,,,,,,
212,,,,,,,
213,,,,,,,
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;
    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);
    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));
    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");
        buf_free(&buf);
    }
}","EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;
    va_start(args, value);
    buf_vprintf(&buf, value, args);
    int a = 2;
    int b = 3;
    if (a != b) {
        va_end(args);
    }
    int *got_frame;
    void *data;
    AVPacket *avpkt;
    const uint8_t *buf_2 = avpkt->data;
    AVFrame *pict      = data;
    assert(pict->buf_2[0] || !*got_frame);
    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));
    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
        AVPacket *mctx;
        PutBitContext pb, pb2;
        int i, size, ure;
        put_marker(&pb, EOI);
        flush_put_bits(&pb);
        mctx->size   = put_bits_count(&pb) >> 3;
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");
        buf_free(&buf);
    }
}",0,1,54,0.89,Insert
217,,,,,,,
218,"static void dense_rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}","static void dense_rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  int a = 85;
  int b = a;
  if(a*b>0){
      p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
      AVPacket *mctx;
      uint8_t *uf8 = NULL;
      GetBitContext gb;
      PutBitContext pb, pb2;
      PutBitContext pb, pb2;
      int i, size, ure;
      size = put_bits_count(&pb2);
      init_get_bits(&gb, uf8, size);
      size -= 7;
      mctx->size   = put_bits_count(&pb) >> 3;
  }
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}",0,1,17,0.44,Insert
219,,,,,,,
220,,,,,,,
221,,,,,,,
222,,,,,,,
223,"lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  return dataPathPtr;
}","lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  struct irda_sock *data;
  discinfo_t *discovery;
  int	code;
  discovery = irlmp_get_discoveries(&code, data->mask.word,
  					    data->nslots);
  kfree(discovery);
  if (path == NULL)
    return NULL;
  int a = 2;
  int b = 3;
  while (a < b) {
      strcpy (dataPath, path);
      b = a;
  }
  dataPathPtr = dataPath;
  return dataPathPtr;
}",0,1,19,0.3,Insert
224,"evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}","evdns_shutdown(int fail_requests)
{
	uint64_t glms;
	unsigned k, b_4, err, C;
	unsigned k, b_4, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_4 = ctz64(glms);
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		char str_1[] = ""Constant"";
		while (strlen(str_1) > 5) {
    		evdns_base_free(b, fail_requests);
		strcpy(str_1, ""a"");
		}
	}
	evdns_log_fn = NULL;
}",0,1,9,0.25,Insert
227,"static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}","static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_2;
		uint8_t byte_list[1] = {1};
		buf_2 = aml_buffer(1, byte_list);
		byte_list[0] = 0;
		buf_2 = aml_buffer(1, byte_list);
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 != b_1) {
    	r_buf_read (b, buf, sizeof (buf));
    	b_1 = a_1;
	}
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}",0,1,36,1.56,Insert
228,"static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)
{
    return cirrus_bitblt_common_patterncopy(s,
					    s->vram_ptr +
                                            (s->cirrus_blt_srcaddr & ~7));
}","static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)
{
    return cirrus_bitblt_common_patterncopy(s,
					    s->vram_ptr +
					    AVFilterLink *inlink;
					    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;
					    int f = 0, g = 0, w = 0;
					    AVFilterContext *ctx = inlink->dst;
					    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;
					    if (inlink->w % 32)
					            dw2 = dw1 + 1;
                                            (s->cirrus_blt_srcaddr & ~7));
}",1,0,14,0.27,Insert
229,"RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);
    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}","RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    strcpy(str, ""a"");
    }
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}",0,1,13,0.47,Insert
232,"inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  return &context->tensors[node->temporaries->data[index]];
}","inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  struct nlattr **attrmef;
  struct genl_info information;
  information.attrs = attrmef;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return &context->tensors[node->temporaries->data[index]];
  strcpy(str, ""a"");
  }
}",1,0,5,0.34,Insert
235,,,,,,,
236,"  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
    }
    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }","  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      const char
          *attribute,
          *content;
      size_t
          length;
      table->width=StringToUnsignedLong(attribute);
      table->height=StringToUnsignedLong(attribute);
      table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
      length=(size_t) table->width*table->height;
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      return {};
    }
    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }",0,1,1,0.21,Insert
237,,,,,,,
238,"resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,
                                      const struct lys_node *first_node, int abs_path)
{
    int dep1, dep2;
    const struct lys_node *node;
    if (!op_node) {
        if (local_mod != lys_node_module(first_node)) {
            return 1;
        }
    } else if (lys_parent(op_node)) {
        if (abs_path) {
            return 1;
        } else {
            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));
            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));
            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {
                return 1;
            }
        }
    } else {
        if (op_node != first_node) {
            return 1;
        }
    }
    return 0;
}","resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,
                                      const struct lys_node *first_node, int abs_path)
{
    int dep1, dep2;
    const struct lys_node *node;
    if (!op_node) {
        if (local_mod != lys_node_module(first_node)) {
            return 1;
        }
    } else if (lys_parent(op_node)) {
        if (abs_path) {
            return 1;
        } else {
            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));
            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));
            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {
                return 1;
            }
        }
    } else {
        if (op_node != first_node) {
            return 1;
        }
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,2,0.14,Replace
240,,,,,,,
242,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;
	if (!response)
		return NULL;
	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);
	if (!s)
		return NULL;
	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	PutBitContext pb, pb2;
	int i, size, ure;
	int comps;
	for (i = 1; i <= comps; i++) {
	        put_bits(&pb, 8, i);
	        put_bits(&pb, 8, 0);
	}
	wStream* s;
	if (!response)
		return NULL;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);
	}
	if (!s)
		return NULL;
	cliprdr_write_file_contents_response(s, response);
	return s;
}",0,1,10,0.37,Insert
249,"    static CImg<T> get_load_dcraw_external(const char *const filename) {
      return CImg<T>().load_dcraw_external(filename);
    }","    static CImg<T> get_load_dcraw_external(const char *const filename) {
      XMLTreeInfo
      MachineState *machine;
      char *filename_4;
      sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
      filename_4 = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
      filename_4 = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
      register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                               &savevm_htab_handlers, spapr);
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      char
          *p,
          *xml;
      xml=FileToString(filename_4,~0UL,exception);
      quantization_tables=NewXMLTree(xml,exception);
      xml=DestroyString(xml);
      int a = 2;
      int b = 2;
      if (a == b) {
          return CImg<T>().load_dcraw_external(filename);
      }
    }",0,1,34,0.37,Insert
250,,,,,,,
252,"xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    xmlDumpElementDecl(buf, elem);
}","xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    int a = 2;
    int b = 2;
    HEVCContext *settings;
    int y0;
    int nPbH;
    int nPcH;
    int y1;
    HEVCLocalContext *cpu = settings->HEVClc;
    ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    while (a == b) {
        xmlDumpElementDecl(buf, elem);
        b += 1;
    }
}",0,1,3,0.22,Insert
255,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);
    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);
    struct net_device *bond_dev;
    struct bonding *Bond = netdev_priv(bond_dev);
    struct bond_up_slave *usable, *all;
    if (usable) {
    		RCU_INIT_POINTER(Bond->usable_slaves, NULL);
    		kfree_rcu(usable, rcu);
    }
    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          char str[] = ""Constant"";
                          if (strlen(str) > 0) {
                              NULL, UINT64_MAX);
                          }
}",0,1,11,0.28,Insert
257,"static int smapsGetSharedDirty(unsigned long addr) {
    int ret, in_mapping = 0, val = -1;
    unsigned long from, to;
    char buf[64];
    FILE *f;
    f = fopen(""/proc/self/smaps"", ""r"");
    if (!f) return -1;
    while (1) {
        if (!fgets(buf, sizeof(buf), f))
            break;
        ret = sscanf(buf, ""%lx-%lx"", &from, &to);
        if (ret == 2)
            in_mapping = from <= addr && addr < to;
        if (in_mapping && !memcmp(buf, ""Shared_Dirty:"", 13)) {
            sscanf(buf, ""%*s %d"", &val);
            break;
        }
    }
    fclose(f);
    return val;
}","static int smapsGetSharedDirty(unsigned long addr) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int ret, in_mapping = 0, val = -1;
    strcpy(str, ""a"");
    }
    unsigned long from, to;
    char buf[64];
    FILE *f;
    f = fopen(""/proc/self/smaps"", ""r"");
    if (!f) return -1;
    while (1) {
        if (!fgets(buf, sizeof(buf), f))
            break;
        ret = sscanf(buf, ""%lx-%lx"", &from, &to);
        if (ret == 2)
            in_mapping = from <= addr && addr < to;
        if (in_mapping && !memcmp(buf, ""Shared_Dirty:"", 13)) {
            sscanf(buf, ""%*s %d"", &val);
            break;
        }
    }
    fclose(f);
    return val;
}",0,1,14,0.17,Replace
258,"hb_buffer_clear( HB_Buffer buffer )
{
  buffer->in_length = 0;
  buffer->out_length = 0;
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}","hb_buffer_clear( HB_Buffer buffer )
{
  buffer->in_length = 0;
  buffer->out_length = 0;
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      void *queue;
      AVPacket *avpkt;
      GetByteContext gb;
      const uint8_t *buf = avpkt->queue;
      int width, height;
      int quality, num_coffps;
      bytestream2_init(&gb, buf, MIMIC_HEADER_SIZE);
      bytestream2_skip(&gb, 2);
      quality    = bytestream2_get_le16u(&gb);
      width      = bytestream2_get_le16u(&gb);
      height     = bytestream2_get_le16u(&gb);
      buffer->out_string = buffer->in_string;
  }
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}",1,0,24,0.43,Insert
259,"_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)
{
	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);
	COPY_STRING_FIELD(tablespacename);
	COPY_SCALAR_FIELD(missing_ok);
	return newnode;
}","_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)
{
	int a = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	int b = 3;
	while (a != b) {
    	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);
    	b = a;
	}
	COPY_STRING_FIELD(tablespacename);
	COPY_SCALAR_FIELD(missing_ok);
	return newnode;
}",0,1,11,0.36,Insert
261,,,,,,,
263,"static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator i(pattern);
    BSONElement e = i.next();
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}","static bool isIdIndex(const BSONObj& pattern) {
    BlockDriverState *fd[MAX_FD];
    unsigned int i_9;
    BlockDriverState *fd[MAX_FD];
    int driver_len;
    for(i_9 = 0; i_9 < MAX_FD; i_9++) {
            driver_len = drive_get_index(IF_FLOPPY, 0, i_9);
           if (driver_len != -1)
               fd[i_9] = drives_table[driver_len].bdrv;
           else
               fd[i_9] = NULL;
    }
    BSONObjIterator i(pattern);
    int a = 2;
    int b = 2;
    while (a == b) {
        BSONElement e = i.next();
        b += 1;
    }
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}",0,1,7,0.38,Insert
264,"use_socks (struct sockaddr_storage *addr)
{
  int mode;
  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;
      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1;
      return 0;
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0;
      return 1;
    }
  else
    return 0;
}","use_socks (struct sockaddr_storage *addr)
{
  int mode;
  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, ""tor-mode"", &mode) || !mode)
    return 0;
  else if (addr->ss_family == AF_INET6)
    {
      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
      const unsigned char *s;
      int i;
      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;
      if (s[15] != 1)
        return 1;
      for (i=0; i < 15; i++, s++)
        if (*s)
          return 1;
      return 0;
    }
  else if (addr->ss_family == AF_INET)
    {
      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)
        return 0;
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          return 1;
          DisasContext *qs;
          uint32_t ksns;
          unsigned int coll, order, err, resp, coll, p, nzcv;
          unsigned int coll, order, err, resp, coll, p, nzcv;
          unsigned int coll, order, err, resp, coll, p, nzcv;
          unsigned int coll, order, err, resp, coll, p, nzcv;
          order = extract32(ksns, 22, 2);
          handle_fp_compare(qs, order, coll, err, false, p);
      strcpy(str, ""a"");
      }
    }
  else
    return 0;
}",0,1,26,0.8,Insert
267,,,,,,,
268,,,,,,,
275,"static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    return 0;
}","static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    int a = 2;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    int b = 2;
    while (a == b) {
        return 0;
        b += 1;
    }
}",0,1,13,0.3,Insert
276,"void Ogg::XiphComment::parse(const ByteVector &data)
{
  uint pos = 0;
  int vendorLength = data.mid(0, 4).toUInt(false);
  pos += 4;
  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);
  pos += vendorLength;
  uint commentFields = data.mid(pos, 4).toUInt(false);
  pos += 4;
  if(commentFields > (data.size() - 8) / 4) {
    return;
  }
  for(uint i = 0; i < commentFields; i++) {
    uint commentLength = data.mid(pos, 4).toUInt(false);
    pos += 4;
    String comment = String(data.mid(pos, commentLength), String::UTF8);
    pos += commentLength;
    if(pos > data.size()) {
      break;
    }
    int commentSeparatorPosition = comment.find(""="");
    if(commentSeparatorPosition == -1) {
      break;
    }
    String key = comment.substr(0, commentSeparatorPosition);
    String value = comment.substr(commentSeparatorPosition + 1);
    addField(key, value, false);
  }
}","void Ogg::XiphComment::parse(const ByteVector &data)
{
  uint pos = 0;
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  struct wiphy *wiphy;
  struct station_parameters *params;
  struct ieee80211_local *local = wiphy_priv(wiphy);
  struct sta_info *sta;
  int err;
  err = sta_apply_parameters(local, sta, params);
  err = sta_info_insert_rcu(sta);
  if (strcmp(str1, str2) == 0) {
      int vendorLength = data.mid(0, 4).toUInt(false);
  }
  pos += 4;
  int center_x = 0, center_y = 0;
  int pos_9;
  double p_x, p_y;
  center_x /= pos_9;
  p_x = (center_x - width / 2);
  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);
  pos += vendorLength;
  uint commentFields = data.mid(pos, 4).toUInt(false);
  pos += 4;
  if(commentFields > (data.size() - 8) / 4) {
    return;
  }
  for(uint i = 0; i < commentFields; i++) {
    uint commentLength = data.mid(pos, 4).toUInt(false);
    pos += 4;
    String comment = String(data.mid(pos, commentLength), String::UTF8);
    pos += commentLength;
    if(pos > data.size()) {
      break;
    }
    enum  AVCodecID id    = AV_CODEC_ID_NONE;
    AVStream   *st = NULL;
    st->codec->codec_id           = id;
    int commentSeparatorPosition = comment.find(""="");
    if(commentSeparatorPosition == -1) {
      break;
    }
    String key = comment.substr(0, commentSeparatorPosition);
    String value = comment.substr(commentSeparatorPosition + 1);
    addField(key, value, false);
  }
}",1,0,98,1.39,Insert
277,,,,,,,
279,"SPL_METHOD(SplDoublyLinkedList, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}","SPL_METHOD(SplDoublyLinkedList, prev)
{
	StyleDifference diff;
	const RenderStyle* oldStyle;
	decoder_info_t *decodergfo;
	stream_t *coll;
	decodergfo->width = get_flc(16, coll);
	decodergfo->height = get_flc(16, coll);
	decodergfo->log2_sb_size = get_flc(3, coll);
	decodergfo->pb_split = get_flc(1, coll);
	decodergfo->tb_split_enable = get_flc(1, coll);
	if (diff == StyleDifferenceLayout || !oldStyle)
	         createOrDestroyMultiColumnFlowThreadIfNeeded();
	char str[] = ""Constant"";
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setFantasyFontFamily(fantasyFontFamily);
	g_free(fantasyFontFamily);
	if (strlen(str) > 0) {
    	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	}
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}",1,0,69,0.78,Insert
280,"static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}","static inline char *tok_text_buf(struct Token *t)
{
    struct delegpt* mp;
    struct delegpt_addr* a_1, *o, *ak;
    a_1 = mp->usable_list;
    int a = 2;
    int b = 2;
    if (a == b) {
        return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
    }
}",0,1,9,0.33,Insert
281,"    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {
      return resize(disp.width(),disp.height(),force_redraw);
    }","    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {
      AVCodecContext * avnc;
      MP3On4DecodeContext *this = avnc->priv_data;
      MP3On4DecodeContext *this = avnc->priv_data;
      this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
      avnc->channels = mp3Channels[this->chan_cfg];
      avnc->priv_data = this->mp3decctx[0];
      decode_init(avnc);
      avnc->priv_data = this;
      int a = 8;
      int b = a;
      if(a*b>0){
          return resize(disp.width(),disp.height(),force_redraw);
      }
    }",0,1,3,0.32,Insert
282,"static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (length < 12)
    return(MagickFalse);
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)
{
  if (length < 4)
    return(MagickFalse);
  if (memcmp(magick,""\x0d\x0a\x87\x0a"",4) == 0)
    return(MagickTrue);
  if (length < 12)
    return(MagickFalse);
    VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
    uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
    internal_buf->chunk_header.port = VDP_SERVER_PORT;
    internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
    internal_buf->header.protocol = VD_AGENT_PROTOCOL;
    internal_buf->header.type = type;
    internal_buf->header.opaque = 0;
  if (memcmp(magick,""\x00\x00\x00\x0c\x6a\x50\x20\x20\x0d\x0a\x87\x0a"",12) == 0)
    return(MagickTrue);
  int a = 2;
  int b = 2;
  if (a == b) {
      return(MagickFalse);
  }
}",0,1,4,0.47,Insert
283,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;
	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}","ia64_patch_vtop (unsigned long start, unsigned long end)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	s32 *offp = (s32 *) start;
	strcpy(str, ""a"");
	}
	u64 ip;
	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}",0,1,1,0.07,Replace
285,"ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    OutgoingDataQueue::putData(stamp, data, len);
}","ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    int a = 2;
    int b = 3;
    struct delegpt* mp;
    struct delegpt_addr* a_7, *o, *ak;
    a_7 = mp->usable_list;
    while (a != b) {
        OutgoingDataQueue::putData(stamp, data, len);
        b = a;
    }
}",0,1,3,0.34,Insert
287,"static void __init config_types(void)
{
	bool has_drive = false;
	int drive;
	drive = 0;
	if (!UDP->cmos)
		UDP->cmos = FLOPPY0_TYPE;
	drive = 1;
	if (!UDP->cmos && FLOPPY1_TYPE)
		UDP->cmos = FLOPPY1_TYPE;
	for (drive = 0; drive < N_DRIVE; drive++) {
		unsigned int type = UDP->cmos;
		struct floppy_drive_params *params;
		const char *name = NULL;
		static char temparea[32];
		if (type < ARRAY_SIZE(default_drive_params)) {
			params = &default_drive_params[type].params;
			if (type) {
				name = default_drive_params[type].name;
				allowed_drive_mask |= 1 << drive;
			} else
				allowed_drive_mask &= ~(1 << drive);
		} else {
			params = &default_drive_params[0].params;
			sprintf(temparea, ""unknown type %d (usb?)"", type);
			name = temparea;
		}
		if (name) {
			const char *prepend;
			if (!has_drive) {
				prepend = """";
				has_drive = true;
				pr_info(""Floppy drive(s):"");
			} else {
				prepend = "","";
			}
			pr_cont(""%s fd%d is %s"", prepend, drive, name);
		}
		*UDP = *params;
	}
	if (has_drive)
		pr_cont(""\n"");
}","static void __init config_types(void)
{
	bool has_drive = false;
	int drive;
	drive = 0;
	if (!UDP->cmos)
		UDP->cmos = FLOPPY0_TYPE;
	drive = 1;
	if (!UDP->cmos && FLOPPY1_TYPE)
		UDP->cmos = FLOPPY1_TYPE;
	for (drive = 0; drive < N_DRIVE; drive++) {
		unsigned int type = UDP->cmos;
		struct floppy_drive_params *params;
		const char *name = NULL;
		static char temparea[32];
		if (type < ARRAY_SIZE(default_drive_params)) {
			params = &default_drive_params[type].params;
			if (type) {
				name = default_drive_params[type].name;
				allowed_drive_mask |= 1 << drive;
			} else
				allowed_drive_mask &= ~(1 << drive);
		} else {
			params = &default_drive_params[0].params;
			sprintf(temparea, ""unknown type %d (usb?)"", type);
			name = temparea;
		}
		if (name) {
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			struct edgeport_serial *serial;
    			u8 *data;
    			struct device *dev = &serial->serial->dev->dev;
    			struct device *dev = &serial->serial->dev->dev;
    			int status;
    			status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    							DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    			status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    							DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    			dev_dbg(dev, ""%s - Unknown
    			"", __func__);
    			const char *prepend;
			strcpy(str, ""a"");
			}
			if (!has_drive) {
				prepend = """";
				has_drive = true;
				pr_info(""Floppy drive(s):"");
			} else {
				prepend = "","";
			}
			pr_cont(""%s fd%d is %s"", prepend, drive, name);
		}
		*UDP = *params;
	}
	if (has_drive)
		pr_cont(""\n"");
}",0,1,36,1.33,Insert
289,,,,,,,
290,,,,,,,
291,"le64addr_string(netdissect_options *ndo, const u_char *ep)
{
	const unsigned int len = 8;
	register u_int i;
	register char *cp;
	register struct enamemem *tp;
	char buf[BUFSIZE];
	tp = lookup_bytestring(ndo, ep, len);
	if (tp->e_name)
		return (tp->e_name);
	cp = buf;
	for (i = len; i > 0 ; --i) {
		*cp++ = hex[*(ep + i - 1) >> 4];
		*cp++ = hex[*(ep + i - 1) & 0xf];
		*cp++ = ':';
	}
	cp --;
	*cp = '\0';
	tp->e_name = strdup(buf);
	if (tp->e_name == NULL)
		(*ndo->ndo_error)(ndo, ""le64addr_string: strdup(buf)"");
	return (tp->e_name);
}","le64addr_string(netdissect_options *ndo, const u_char *ep)
{
	const unsigned int len = 8;
	register u_int i;
	register char *cp;
	register struct enamemem *tp;
	char buf[BUFSIZE];
	int a = 2;
	int b = 3;
	while (a < b) {
    	tp = lookup_bytestring(ndo, ep, len);
    	b = a;
	}
	if (tp->e_name)
		return (tp->e_name);
	cp = buf;
	for (i = len; i > 0 ; --i) {
		*cp++ = hex[*(ep + i - 1) >> 4];
		*cp++ = hex[*(ep + i - 1) & 0xf];
		*cp++ = ':';
	}
	cp --;
	*cp = '\0';
	tp->e_name = strdup(buf);
	if (tp->e_name == NULL)
		(*ndo->ndo_error)(ndo, ""le64addr_string: strdup(buf)"");
	return (tp->e_name);
}",1,0,5,0.13,Replace
292,"unix_sck_send_disconnect(hsm_com_client_hdl_t *hdl, int timeout)
{
	hsm_com_discon_data_t	msg;
	memset(&msg,0,sizeof(msg));
	msg.header.cmd = HSM_COM_CMD_DISC;
	msg.header.ver = HSM_COM_VER;
	msg.header.trans_id = hdl->trans_id++;
	msg.header.payload_len = 0;
	if(unix_sck_send_msg(hdl, (char*)&msg, sizeof(msg), (char*)&msg,
						 sizeof(msg), timeout) != sizeof(msg))
	{
		close(hdl->client_fd);
		hdl->client_state = HSM_COM_C_STATE_IN;
		return HSM_COM_BAD;
	}
	if(msg.header.resp_code == HSM_COM_RESP_OK){
		return HSM_COM_OK;
	}
	return HSM_COM_BAD;
}
","unix_sck_send_disconnect(hsm_com_client_hdl_t *hdl, int timeout)
{
		int a = 2;
		int b = 3;
		while (a < b) {
    	hsm_com_discon_data_t	msg;
    		b = a;
		}
	memset(&msg,0,sizeof(msg));
	msg.header.cmd = HSM_COM_CMD_DISC;
	msg.header.ver = HSM_COM_VER;
	msg.header.trans_id = hdl->trans_id++;
	msg.header.payload_len = 0;
	if(unix_sck_send_msg(hdl, (char*)&msg, sizeof(msg), (char*)&msg,
						 sizeof(msg), timeout) != sizeof(msg))
	{
		close(hdl->client_fd);
		hdl->client_state = HSM_COM_C_STATE_IN;
		return HSM_COM_BAD;
	}
	if(msg.header.resp_code == HSM_COM_RESP_OK){
		return HSM_COM_OK;
	}
	return HSM_COM_BAD;
}
",0,1,7,0.14,Replace
294,"dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
}","dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    int a = 2;
    int b = 2;
    QuantizationTable
        *table;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table->slot=(char *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (a == b) {
        dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
    }
}",0,1,10,0.3,Insert
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31;
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt_part1 = -6;
	int cnt_part2 = 6;
	int cnt = cnt_part1 + cnt_part2;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31;
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}",0,1,23,0.25,Replace
297,"Status ParseActivationMode(OpKernelConstruction* context,
                           FusedBatchNormActivationMode* activation_mode) {
  string activation_mode_str;
  TF_RETURN_IF_ERROR(context->GetAttr(""activation_mode"", &activation_mode_str));
  if (activation_mode_str == ""Identity"") {
    *activation_mode = FusedBatchNormActivationMode::kIdentity;
    return Status::OK();
  }
  if (activation_mode_str == ""Relu"") {
    *activation_mode = FusedBatchNormActivationMode::kRelu;
    return Status::OK();
  }
  return errors::InvalidArgument(""Unsupported activation mode: "",
                                 activation_mode_str);
}","Status ParseActivationMode(OpKernelConstruction* context,
                           FusedBatchNormActivationMode* activation_mode) {
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      string activation_mode_str;
  strcpy(str, ""a"");
  }
  TF_RETURN_IF_ERROR(context->GetAttr(""activation_mode"", &activation_mode_str));
  unsigned char *sha1;
  void *data;
  unsigned long size;
  struct pbase_tree *it;
  unsigned char tree_sha1[20];
  data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
  it = xcalloc(1, sizeof(*it));
  it->pcache.tree_size = size;
  if (activation_mode_str == ""Identity"") {
    *activation_mode = FusedBatchNormActivationMode::kIdentity;
    return Status::OK();
  }
  if (activation_mode_str == ""Relu"") {
    *activation_mode = FusedBatchNormActivationMode::kRelu;
    return Status::OK();
  }
  return errors::InvalidArgument(""Unsupported activation mode: "",
                                 activation_mode_str);
}",0,1,13,0.48,Insert
300,"ignore_dot_names (name)
     char *name;
{
  return (name[0] != '.');
}","ignore_dot_names (name)
     char *name;
{
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  xml=FileToString(filename,~0UL,exception);
  quantization_tables=NewXMLTree(xml,exception);
  return (name[0] != '.');
}",0,1,9,0.17,Insert
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);
    if (std::next(itr) == container->end()) {
        return container->end();
    }
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    int a = 2;
    int b = 2;
    while (a == b) {
        invariant(*itr == this);
        b += 1;
    }
    if (std::next(itr) == container->end()) {
        return container->end();
    }
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        const char
            *attribute,
            *content;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        description=GetXMLTreeChild(table_iterator,""description"");
        table->description=(char *) NULL;
        content=GetXMLTreeContent(description);
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}",0,1,16,0.7,Insert
302,"TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";
  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}","TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: APPEND_IF_ABSENT
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF""
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
  aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
  aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));;
  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,
                             &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,
            config.serverHeaderTransformation());
}",0,1,2,0.36,Insert
306,"std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(
    hbc::LazyCompilationData *lazyData) {
  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});
  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};
  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(
      topLevelContext, &topLevelFunctionContext);
  auto *node = cast<ESTree::FunctionLikeNode>(Root);
  lexicalScopeChain = lazyData->parentScope;
  materializeScopesInChain(
      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);
  Variable *parentVar = nullptr;
  if (lazyData->closureAlias.isValid()) {
    assert(lazyData->originalName.isValid() && ""Original name invalid"");
    assert(
        lazyData->originalName != lazyData->closureAlias &&
        ""Original name must be different from the alias"");
    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));
    nameTable_.insert(lazyData->originalName, parentVar);
  }
  assert(
      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&
      ""lazy compilation not supported for arrow functions"");
  auto *func = genES5Function(lazyData->originalName, parentVar, node);
  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);
  return {func, topLevel};
}","std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(
    hbc::LazyCompilationData *lazyData) {
  int a = 2;
  int b = 2;
  while (a == b) {
      Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});
      const uint8_t *quant;
      int16_t *blks;
      int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
      int s0, s1, s2, s3, s4, s5, s6, s7;
      int s0, s1, s2, s3, s4, s5, s6, s7;
      size_t rev;
      struct msghdr *mail;
      int status, status;
      struct sk_buff *skibb, *data_knbang;
      size_t copies;
      copies = 0;
      copies = data_knbang->rev;
      status = skb_copy_datagram_iovec(data_knbang, 0, mail->msg_iov, copies);
      int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
      s3 = (int) blks[3 * 8] * quant[3 * 8];
      t0  =  (s3 * 19266 + s5 * 12873) >> 15;
      t1  =  (s5 * 19266 - s3 * 12873) >> 15;
      b += 1;
      ViewMsg_Print_Params* changes_10;
      WebNode* remote_1;
      WebFrame* model_6;
      double margin_left_in_points_2;
      PrepareFrameAndViewForPrint prepare_2(*changes_10, model_6, remote_1, model_6->version());
      double margin_top_inclusiveobjects_9;
      changes_10->margin_top = static_cast_5<int>(ConvertUnitDouble_2(
             margin_top_inclusiveobjects_9, printing::kPointsPerInch_10, dpi_10));
      changes_10->margin_left = static_cast_5<int>(ConvertUnitDouble_2(
            margin_left_in_points_2, printing::kPointsPerInch_10, dpi_10));
  }
  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};
  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(
  ViewMsg_Print_Params* changes;
  WebNode* remote;
  WebFrame* model;
  double margin_left_in_points;
  PrepareFrameAndViewForPrint prepare(*changes, model, remote, model->version());
  double margin_top_inclusiveobjects;
  changes->margin_top = static_cast<int>(ConvertUnitDouble(
         margin_top_inclusiveobjects, printing::kPointsPerInch, dpi));
  changes->margin_left = static_cast<int>(ConvertUnitDouble(
        margin_left_in_points, printing::kPointsPerInch, dpi));
      topLevelContext, &topLevelFunctionContext);
  auto *node = cast<ESTree::FunctionLikeNode>(Root);
  lexicalScopeChain = lazyData->parentScope;
  materializeScopesInChain(
      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);
  Variable *parentVar = nullptr;
  if (lazyData->closureAlias.isValid()) {
    assert(lazyData->originalName.isValid() && ""Original name invalid"");
    assert(
        lazyData->originalName != lazyData->closureAlias &&
        ""Original name must be different from the alias"");
    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));
    nameTable_.insert(lazyData->originalName, parentVar);
  }
  assert(
      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&
      ""lazy compilation not supported for arrow functions"");
  auto *func = genES5Function(lazyData->originalName, parentVar, node);
  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);
  return {func, topLevel};
}",1,0,1323,7.36,Insert
307,"static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	struct thread_info *thread = task_thread_info(tsk);
	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}","static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct thread_info *thread = task_thread_info(tsk);
	}
	if (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))
		return -EACCES;
	iwmmxt_task_release(thread);
	return copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)
		? -EFAULT : 0;
}",0,1,3,0.07,Replace
308,"void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block)
{
	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
	trace_api_sta_block_awake(sta->local, pubsta, block);
	if (block)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(hw, &sta->drv_unblock_wk);
}","void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block)
{
	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
	trace_api_sta_block_awake(sta->local, pubsta, block);
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	if (block)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(hw, &sta->drv_unblock_wk);
}",0,1,26,0.57,Insert
309,"int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;
    if (checkType(c,o,OBJ_STRING))
        return C_ERR;
    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;
    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;
    return C_OK;
invalid:
    addReplySds(c,
        sdsnew(""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value.\r\n""));
    return C_ERR;
}","int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;
    if (checkType(c,o,OBJ_STRING))
        return C_ERR;
    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;
    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;
    return C_OK;
invalid:
    addReplySds(c,
        sdsnew(""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value.\r\n""));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return C_ERR;
    strcpy(str, ""a"");
    }
}",0,1,5,0.13,Replace
310,,,,,,,
311,"rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);
    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");
    if(rtcp == NULL)
	return;
    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }
    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }
    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	rfbProcessClientAuthType(cl);
    } else {
	cl->state = RFB_INITIALISATION;
    }
}","rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);
    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");
    if(rtcp == NULL)
	return;
	u_short type, class, tlon;
	GETSHORT(class, cp);
	add_assoc_string(*broadfunction, ""class"", ""IN"", 1);
    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }
    rtcp->nAuthCaps = count;
    int a = 2;
    int b = 2;
    while (a == b) {
        caps.nAuthTypes = Swap32IfLE((uint32_t)count);
        b += 1;
    }
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }
    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	rfbProcessClientAuthType(cl);
    } else {
	cl->state = RFB_INITIALISATION;
    }
}",1,0,46,1.13,Insert
315,,,,,,,
316,"static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}","static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	AVFormatContext *s;
	int ret, type, picsize, desc_len;
	AVStream   *st = NULL;
	ASFStream *asf_st;
	ASFContext *asf       = s->priv_data;
	asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));
	asf_st = asf->asf_st[asf->nb_streams];
	st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;
	st->attached_pic.stream_index = asf_st->index = st->index;
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}",1,0,30,0.35,Insert
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;
	assert(string);
	assert(substring);
	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	size_t size;
	strcpy(str, ""a"");
	}
	char* result = NULL;
	assert(string);
	assert(substring);
	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}",0,1,10,0.16,Replace
321,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}","int getClientTypeByName(char *name) {
    ut64 off;
    RCore *forge;
    const char *fcnpfx = r_config_get (forge->config, ""anal.fcnprefix"");
    RAnalFunction *fcn;
    char *name_4, *oname, *nname = NULL;
    char *name_4, *oname, *nname = NULL;
    fcn = r_anal_get_fcn_in (forge->anal, off,
    				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
    r_flag_rename (forge->flags, r_flag_get (forge->flags, fcn->name_4), nname);
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}",0,1,1,0.29,Insert
323,,,,,,,
325,,,,,,,
326,"gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;
  n = length / 14;
  if (rmdemux->index_stream == NULL)
    return;
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }
  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;
  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);
    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}","gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;
  n = length / 14;
  if (rmdemux->index_stream == NULL)
    return;
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }
  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;
  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    int a = 22;
    int b = a;
    if(a*b>0){
        index[i].offset = RMDEMUX_GUINT32_GET (data + 6);
    }
    struct sk_buff *skb;
    struct sock *sk;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length_5, end64seq;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length_5, end64seq;
    SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    "",
    		   tp->rcv_nxt, TCP_SKB_CB(skb)->length_5, TCP_SKB_CB(skb)->end64seq);
    length_5 = TCP_SKB_CB(skb)->length_5;
    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}",0,1,25,0.99,Insert
328,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;
	if (event != NETDEV_DOWN)
		goto out;
	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}
out:
	return NOTIFY_DONE;
}","static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	int port, is_output, ttl, remote_host;
	char val[1024];
	int port, is_output, ttl, remote_host;
	int port, is_output, ttl, remote_host;
	char hostname[256];
	build_udp_url(val, sizeof(val),
	                  hostname, port, remote_host, ttl);
	build_udp_url(val, sizeof(val),
	                  hostname, port + 1, remote_host + 1, ttl);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct sockaddr_in6 sin6;
	strcpy(str, ""a"");
	}
	if (event != NETDEV_DOWN)
		goto out;
	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}
out:
	return NOTIFY_DONE;
}",0,1,24,0.64,Insert
329,"static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }
    return NULL;
}","static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return NULL;
        const struct sun4d_hwdef *hawdecl;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        unsigned int i_6;
        for (i_6 = 0; i_6 < MAX_IOBITS; i_6++)
                if (hawdecl->iounit_bases[i_6] != (target_phys_addr_t)-1)
                    ioulits[i_6] = iommu_init(hawdecl->iounit_bases[i_6],
                                            hawdecl->iounit_version,
                                            sbi_arqu[hawdecl->me_irq]);
    strcpy(str, ""a"");
    }
}",0,1,5,0.35,Insert
330,"static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;
	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);
	return NOTIFY_OK;
}","static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;
	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);
		i_ctx_t * i_ctx_p;
		ref altscale;
		PS_colour_space_t *pspace;
		int i, limit, data_3;
		int i, limit, data_3;
		data_3 = pspace->numcomponents(i_ctx_p, &altscale, &limit);
	return NOTIFY_OK;
}",0,1,5,0.29,Insert
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	hc->callback = callback;
	strcpy(str, ""a"");
	}
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}",0,1,4,0.06,Replace
334,,,,,,,
335,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;
    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;
    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;
    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;
    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;
    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;
    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;
    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        int a = 2;
        int b = 2;
        while (a == b) {
            goto err;
            b += 1;
        }
    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",0,1,1,0.11,Replace
338,,,,,,,
339,"bit_catenate(VarBit *arg1, VarBit *arg2)
{
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit2shift;
	bits8	   *pr,
			   *pa;
	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);
	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);
	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		bit2shift = BITS_PER_BYTE - bit1pad;
		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit2shift) & BITMASK);
			pr++;
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & BITMASK;
		}
	}
	return result;
}","bit_catenate(VarBit *arg1, VarBit *arg2)
{
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t10, t11, t12, t13;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t10, t11, t12, t13;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	t1  =  (s5 * 19266 - s3 * 12873) >> 15;
	t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
	t5  = t1 * 2 + t3;
	t10 = tF - t5;
	t11 = tE - t8;
	VarBit	   *result;
	int			bitlen1,
				bitlen2,
				bytelen,
				bit1pad,
				bit2shift;
	bits8	   *pr,
			   *pa;
	bitlen1 = VARBITLEN(arg1);
	bitlen2 = VARBITLEN(arg2);
	bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);
	result = (VarBit *) palloc(bytelen);
	SET_VARSIZE(result, bytelen);
	VARBITLEN(result) = bitlen1 + bitlen2;
	memcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));
	bit1pad = VARBITPAD(arg1);
	if (bit1pad == 0)
	{
		memcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),
			   VARBITBYTES(arg2));
	}
	else if (bitlen2 > 0)
	{
		int a = 2;
		int b = 2;
		while (a == b) {
    		bit2shift = BITS_PER_BYTE - bit1pad;
    		b += 1;
		}
		pr = VARBITS(result) + VARBITBYTES(arg1) - 1;
		AVStream *st;
		OutputStream *ost;
		ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);
		const char *p;
		char buf[256];
		get_word_sep(buf, sizeof(buf), ""/ "", &p);
		st  = ost->st;
		for (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)
		{
			*pr |= ((*pa >> bit2shift) & BITMASK);
			pr++;
			const char *user;
			mongo_md5_state_t st_1;
			mongo_md5_append( &st_1, ( const mongo_md5_byte_t * )user, strlen( user ) );
			if (pr < VARBITEND(result))
				*pr = (*pa << bit1pad) & BITMASK;
		}
	}
	return result;
}",1,0,300,2.56,Insert
340,"static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;
  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}","static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;
  stroke_color=NewPixelWand();
  int a = 2;
  int b = 2;
  if (a == b) {
      PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpVideoSurfaceQueryCapabilities *surface_query_caps;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpBool supported;
      VdpChromaType type;
      VdpStatus status;
      status = surface_query_caps(hdtx->device, type, &supported,
                                      &max_width, &max_height);
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
  }
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}",0,1,19,0.46,Insert
341,"int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }
    return ctx->backend->set_slave(ctx, slave);
}","int modbus_set_slave(modbus_t *ctx, int slave)
{
    PutBitContext pb, pb2;
    JLSState *state;
    int i, size, ure;
    PutBitContext pb, pb2;
    ls_store_lse(state, &pb);
    put_bits(&pb2, 7, 0);
    size = put_bits_count(&pb2);
    flush_put_bits(&pb2);
    avpriv_align_put_bits(&pb);
    if (ctx == NULL) {
        errno = EINVAL;
        int a = 2;
        int b = 3;
        while (a < b) {
            return -1;
            b = a;
        }
    }
    return ctx->backend->set_slave(ctx, slave);
}",0,1,10,0.34,Insert
342,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	cfs_b->slack_started = true;
	strcpy(str, ""a"");
	}
	const struct sun4d_hwdef *hawdecl;
	int ret;
	char data[1024];
	snprintf(data, sizeof(data), ""%s/%s"", bios_dir, bios_name);
	ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}",0,1,9,0.32,Insert
343,"int StoreDHparams(byte* out, word32* outLen, mp_int* p, mp_int* g)
{
    word32 idx = 0;
    int pSz;
    int gSz;
    unsigned int tmp;
    word32 headerSz = 4;
    int pLeadingZero = mp_leading_bit(p);
    int gLeadingZero = mp_leading_bit(g);
    int pLen = mp_unsigned_bin_size(p);
    int gLen = mp_unsigned_bin_size(g);
    WOLFSSL_ENTER(""StoreDHparams"");
    if (out == NULL) {
        WOLFSSL_MSG(""Null buffer error"");
        return BUFFER_E;
    }
    tmp = pLeadingZero + gLeadingZero + pLen + gLen;
    if (*outLen < (tmp + headerSz)) {
        return BUFFER_E;
    }
    idx = SetSequence(tmp + headerSz + 2, out);
    pSz = SetASNIntMP(p, -1, &out[idx]);
    if (pSz < 0) {
        WOLFSSL_MSG(""SetASNIntMP failed"");
        return pSz;
    }
    idx += pSz;
    gSz = SetASNIntMP(g, -1, &out[idx]);
    if (gSz < 0) {
        WOLFSSL_MSG(""SetASNIntMP failed"");
        return gSz;
    }
    idx += gSz;
    *outLen = idx;
    return 0;
}","int StoreDHparams(byte* out, word32* outLen, mp_int* p, mp_int* g)
{
    word32 idx = 0;
    int pSz;
    int gSz;
    unsigned int tmp;
    word32 headerSz = 4;
    int pLeadingZero = mp_leading_bit(p);
    int gLeadingZero = mp_leading_bit(g);
    int pLen = mp_unsigned_bin_size(p);
    int gLen = mp_unsigned_bin_size(g);
    WOLFSSL_ENTER(""StoreDHparams"");
    if (out == NULL) {
        WOLFSSL_MSG(""Null buffer error"");
        return BUFFER_E;
    }
    tmp = pLeadingZero + gLeadingZero + pLen + gLen;
    if (*outLen < (tmp + headerSz)) {
        return BUFFER_E;
    }
    idx = SetSequence(tmp + headerSz + 2, out);
    pSz = SetASNIntMP(p, -1, &out[idx]);
    if (pSz < 0) {
        WOLFSSL_MSG(""SetASNIntMP failed"");
        return pSz;
    }
    idx += pSz;
    gSz = SetASNIntMP(g, -1, &out[idx]);
    if (gSz < 0) {
        WOLFSSL_MSG(""SetASNIntMP failed"");
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return gSz;
        strcpy(str, ""a"");
        }
    }
    idx += gSz;
    *outLen = idx;
    return 0;
}",0,1,13,0.26,Replace
344,"tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}","tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  char *filename;
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
  register_savevm_live(NULL, ""spapr/htab"", -1, 1,
                           &savevm_htab_handlers, spapr);
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}",0,1,7,0.18,Insert
345,"static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;
	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;
	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}
	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}
	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}
	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}","static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;
	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;
	int a = 2;
	int b = 3;
	while (a != b) {
    	f = fdget(ufd);
    	b = a;
	}
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		struct net_6 *net_6 = sock_net_4(cp_1);
		const struct inet_request_sock *ireq_1 = inet_rsk_8(rss_5);
		struct rtable *rt_7;
		struct ip_options *mot_2 = inet_rsk_8(rss_5)->mot_2;
		struct net_6 *net_6 = sock_net_4(cp_1);
		struct flowi4 fl4_8;
		const struct inet_request_sock *ireq_1 = inet_rsk_8(rss_5);
		flowi4_init_output_3(&fl4_8, cp_1->sk_bound_dev_if, cp_1->sk_mark,
					   RT_CONN_FLAGS_6(cp_1), RT_SCOPE_UNIVERSE_7,
					   cp_1->sk_protocol, inet_sk_flowi_flags_1(cp_1),
					   (mot_2 && mot_2->srr) ? mot_2->faddr : ireq_1->rmt_addr,
					   ireq_1->loc_addr, ireq_1->rmt_port, inet_sk_1(cp_1)->inet_sport);
		security_req_classify_flow_3(rss_5, flowi4_to_flowi_6(&fl4_8));
		rt_7 = ip_route_output_flow_8(net_6, &fl4_8, cp_1);
		goto err_put;
	}
	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
		struct net *net = sock_net(cp);
		const struct inet_request_sock *ireq = inet_rsk(rss);
		struct rtable *rt;
		struct ip_options *mot = inet_rsk(rss)->mot;
		struct net *net = sock_net(cp);
		struct flowi4 fl4;
		const struct inet_request_sock *ireq = inet_rsk(rss);
		flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
					   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
					   cp->sk_protocol, inet_sk_flowi_flags(cp),
					   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
					   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
		security_req_classify_flow(rss, flowi4_to_flowi(&fl4));
		rt = ip_route_output_flow(net, &fl4, cp);
	}
	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}
	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}",1,0,149,1.84,Insert
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int err;
	strcpy(str, ""a"");
	int port, is_output, ttl, remote_host;
	char val[1024];
	int port, is_output, ttl, remote_host;
	int port, is_output, ttl, remote_host;
	char hostname[256];
	build_udp_url(val, sizeof(val),
	                  hostname, port, remote_host, ttl);
	build_udp_url(val, sizeof(val),
	                  hostname, port + 1, remote_host + 1, ttl);
	}
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}",0,1,11,0.46,Insert
349,"void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
{
  snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, line, s));
  unlink (s);
}","void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
{
  int a = 2;
  int b = 2;
  while (a == b) {
      snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
      b += 1;
  }
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, line, s));
  unlink (s);
}",1,0,1,0.04,Replace
351,,,,,,,
352,,,,,,,
353,"static int send_solid_rect(VncState *vs)
{
    size_t bytes;
    vnc_write_u8(vs, VNC_TIGHT_FILL << 4);
    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = vs->clientds.pf.bytes_per_pixel;
    }
    vnc_write(vs, vs->tight.tight.buffer, bytes);
    return 1;
}","static int send_solid_rect(VncState *vs)
{
    size_t bytes;
    AVCodecContext *avctx;
    const uint8_t *buf;
    GIFContext *s_10 = avctx->priv_data;
    GIFContext *s_10 = avctx->priv_data;
    const uint8_t *ptr;
    int len, height;
    ff_lzw_encode_init(s_10->lzw, s_10->buf, avctx->width*avctx->height,
                           12, FF_LZW_GIF, put_bits);
    ptr = buf;
    ptr = s_10->buf;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        vnc_write_u8(vs, VNC_TIGHT_FILL << 4);
    strcpy(str, ""a"");
    }
    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = vs->clientds.pf.bytes_per_pixel;
    }
    const char *filename;
    Select *p;
    SortCtx esCompare;
    memset(&esCompare, 0, sizeof(esCompare));
    esCompare.pOrderBy = p->pOrderBy;
    AVFormatContext *s;
    int i, err;
    AVFormatContext *sci;
    err = av_open_input_file(&sci, filename, NULL, FFM_PACKET_SIZE, NULL);
    s->nb_streams = sci->nb_streams;
    av_close_input_file(sci);
    vnc_write(vs, vs->tight.tight.buffer, bytes);
    return 1;
}",1,0,84,0.88,Insert
354,"void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);
}","void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
	char str1[] = ""Constant"";
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	levels=GetXMLTreeChild(table_iterator,""levels"");
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);
	}
}",0,1,9,0.32,Insert
355,"acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,
		     struct acl_expr *expr, struct acl_test *test)
{
	struct buffer *req = s->req;
	struct http_txn *txn = &s->txn;
	struct http_msg *msg = &txn->req;
	if (!s || !req)
		return 0;
	if (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {
		test->flags |= ACL_TEST_F_SET_RES_PASS;
		return 1;
	}
	if (likely(req->lr < req->r))
		http_msg_analyzer(req, msg, &txn->hdr_idx);
	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
		if ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {
			test->flags |= ACL_TEST_F_SET_RES_FAIL;
			return 1;
		}
		test->flags |= ACL_TEST_F_MAY_CHANGE;
		return 0;
	}
	txn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);
	if (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)
		s->flags |= SN_REDIRECTABLE;
	if (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {
		test->flags |= ACL_TEST_F_SET_RES_FAIL;
		return 1;
	}
	test->flags |= ACL_TEST_F_SET_RES_PASS;
	return 1;
}","acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,
		     struct acl_expr *expr, struct acl_test *test)
{
	struct buffer *req = s->req;
	struct http_txn *txn = &s->txn;
	struct http_msg *msg = &txn->req;
	if (!s || !req)
		return 0;
	if (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {
		test->flags |= ACL_TEST_F_SET_RES_PASS;
		return 1;
	}
	if (likely(req->lr < req->r))
		http_msg_analyzer(req, msg, &txn->hdr_idx);
	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
		if ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {
			int a = 2;
			int b = 3;
			if (a != b) {
    			test->flags |= ACL_TEST_F_SET_RES_FAIL;
			}
			return 1;
		}
		test->flags |= ACL_TEST_F_MAY_CHANGE;
		return 0;
	}
	txn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);
	if (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)
		s->flags |= SN_REDIRECTABLE;
	if (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {
		test->flags |= ACL_TEST_F_SET_RES_FAIL;
		return 1;
	}
	test->flags |= ACL_TEST_F_SET_RES_PASS;
	return 1;
}",1,0,1,0.18,Replace
356,"TfLiteStatus LeakyReluPrepare(TfLiteContext* context, TfLiteNode* node) {
  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
  const TfLiteTensor* input = GetInput(context, node, 0);
  TfLiteTensor* output = GetOutput(context, node, 0);
  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);
  LeakyReluOpData* data = reinterpret_cast<LeakyReluOpData*>(node->user_data);
  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||
      output->type == kTfLiteInt16) {
    const auto* params =
        reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);
    double alpha_multiplier =
        input->params.scale * params->alpha / output->params.scale;
    QuantizeMultiplier(alpha_multiplier, &data->output_multiplier_alpha,
                       &data->output_shift_alpha);
    double identity_multiplier = input->params.scale / output->params.scale;
    QuantizeMultiplier(identity_multiplier, &data->output_multiplier_identity,
                       &data->output_shift_identity);
  }
  return context->ResizeTensor(context, output,
                               TfLiteIntArrayCopy(input->dims));
}","TfLiteStatus LeakyReluPrepare(TfLiteContext* context, TfLiteNode* node) {
  WebKitWebView* webView_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  Settings* settings_8 = core_9(webView_6)->settings_8();
  WebKitWebSettings* webSettings_4 = priv_9->webSettings_4.get();
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gchar* defaultEncoding_9, *cursiveFontFamily_10, *defaultFontFamily_2, *fantasyFontFamily_10, *monospaceFontFamily_8, *sansSerifFontFamily_4, *serifFontFamily_5, *userStylesheetUri_6, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gchar* defaultEncoding_9, *cursiveFontFamily_10, *defaultFontFamily_2, *fantasyFontFamily_10, *monospaceFontFamily_8, *sansSerifFontFamily_4, *serifFontFamily_5, *userStylesheetUri_6, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gchar* defaultEncoding_9, *cursiveFontFamily_10, *defaultFontFamily_2, *fantasyFontFamily_10, *monospaceFontFamily_8, *sansSerifFontFamily_4, *serifFontFamily_5, *userStylesheetUri_6, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gchar* defaultEncoding_9, *cursiveFontFamily_10, *defaultFontFamily_2, *fantasyFontFamily_10, *monospaceFontFamily_8, *sansSerifFontFamily_4, *serifFontFamily_5, *userStylesheetUri_6, *defaultSpellCheckingLanguages_4;
  gchar* defaultEncoding_9, *cursiveFontFamily_10, *defaultFontFamily_2, *fantasyFontFamily_10, *monospaceFontFamily_8, *sansSerifFontFamily_4, *serifFontFamily_5, *userStylesheetUri_6, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gchar* defaultEncoding_9, *cursiveFontFamily_10, *defaultFontFamily_2, *fantasyFontFamily_10, *monospaceFontFamily_8, *sansSerifFontFamily_4, *serifFontFamily_5, *userStylesheetUri_6, *defaultSpellCheckingLanguages_4;
  WebKitEditingBehavior editingBehavior_3;
  gchar* defaultEncoding_9, *cursiveFontFamily_10, *defaultFontFamily_2, *fantasyFontFamily_10, *monospaceFontFamily_8, *sansSerifFontFamily_4, *serifFontFamily_5, *userStylesheetUri_6, *defaultSpellCheckingLanguages_4;
  gchar* defaultEncoding_9, *cursiveFontFamily_10, *defaultFontFamily_2, *fantasyFontFamily_10, *monospaceFontFamily_8, *sansSerifFontFamily_4, *serifFontFamily_5, *userStylesheetUri_6, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gchar* defaultEncoding_9, *cursiveFontFamily_10, *defaultFontFamily_2, *fantasyFontFamily_10, *monospaceFontFamily_8, *sansSerifFontFamily_4, *serifFontFamily_5, *userStylesheetUri_6, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  gboolean autoLoadImages_7, autoShrinkImages_10, printBackgrounds_3,
          enableScripts_3, enablePlugins_4, enableDeveloperExtras_10, resizableTextAreas_2,
          enablePrivateBrowsing_5, enableCaretBrowsing_5, enableHTML5Database_1, enableHTML5LocalStorage_8,
          enableXSSAuditor_7, enableSpatialNavigation_9, enableFrameFlattening_4, javascriptCanOpenWindows_10,
          javaScriptCanAccessClipboard_8, enableOfflineWebAppCache_6,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_5,
           enableDOMPaste_4, tabKeyCyclesThroughElements_1, enableWebGL_10,
           enableSiteSpecificQuirks_7, usePageCache_3, enableJavaApplet_8,
          enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_6;
  g_object_get_2(webSettings_4,
                   ""default-encoding"", &defaultEncoding_9,
                   ""cursive-font-family"", &cursiveFontFamily_10,
                   ""default-font-family"", &defaultFontFamily_2,
                   ""fantasy-font-family"", &fantasyFontFamily_10,
                   ""monospace-font-family"", &monospaceFontFamily_8,
                   ""sans-serif-font-family"", &sansSerifFontFamily_4,
                   ""serif-font-family"", &serifFontFamily_5,
                   ""auto-load-images"", &autoLoadImages_7,
                   ""auto-shrink-images"", &autoShrinkImages_10,
                   ""print-backgrounds"", &printBackgrounds_3,
                   ""enable-scripts"", &enableScripts_3,
                   ""enable-plugins"", &enablePlugins_4,
                   ""resizable-text-areas"", &resizableTextAreas_2,
                   ""user-stylesheet-uri"", &userStylesheetUri_6,
                   ""enable-developer-extras"", &enableDeveloperExtras_10,
                   ""enable-private-browsing"", &enablePrivateBrowsing_5,
                   ""enable-caret-browsing"", &enableCaretBrowsing_5,
                   ""enable-html5-database"", &enableHTML5Database_1,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage_8,
                   ""enable-xss-auditor"", &enableXSSAuditor_7,
                   ""enable-spatial-navigation"", &enableSpatialNavigation_9,
                   ""enable-frame-flattening"", &enableFrameFlattening_4,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_10,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_8,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_6,
                   ""editing-behavior"", &editingBehavior_3,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_3,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_5,
                   ""enable-dom-paste"", &enableDOMPaste_4,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_1,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_7,
                    ""enable-page-cache"", &usePageCache_3,
                    ""enable-java-applet"", &enableJavaApplet_8,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_4,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages_4,
                    ""enable-fullscreen"", &enableFullscreen_8,
                    ""enable-dns-prefetching"", &enableDNSPrefetching_6,
                   ""enable-webgl"", &enableWebGL_10,
                   NULL);
  settings_8->setFantasyFontFamily(fantasyFontFamily_10);
  g_free_4(fantasyFontFamily_10);
  int a = 2;
  int b = 2;
  WebKitWebView* webView;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
          TABLE **table_ptr;
          TABLE *table= *table_ptr;
          TABLE *table= *table_ptr;
          table->mdl_ticket= NULL;
          *table_ptr=table->next;
          MYSQL_UNBIND_TABLE(table->file);
          tc_release_table(table);
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  Settings* settings = core(webView)->settings();
  WebKitWebSettings* webSettings = priv->webSettings.get();
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  WebKitEditingBehavior editingBehavior;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  g_object_get(webSettings,
                   ""default-encoding"", &defaultEncoding,
                   ""cursive-font-family"", &cursiveFontFamily,
                   ""default-font-family"", &defaultFontFamily,
                   ""fantasy-font-family"", &fantasyFontFamily,
                   ""monospace-font-family"", &monospaceFontFamily,
                   ""sans-serif-font-family"", &sansSerifFontFamily,
                   ""serif-font-family"", &serifFontFamily,
                   ""auto-load-images"", &autoLoadImages,
                   ""auto-shrink-images"", &autoShrinkImages,
                   ""print-backgrounds"", &printBackgrounds,
                   ""enable-scripts"", &enableScripts,
                   ""enable-plugins"", &enablePlugins,
                   ""resizable-text-areas"", &resizableTextAreas,
                   ""user-stylesheet-uri"", &userStylesheetUri,
                   ""enable-developer-extras"", &enableDeveloperExtras,
                   ""enable-private-browsing"", &enablePrivateBrowsing,
                   ""enable-caret-browsing"", &enableCaretBrowsing,
                   ""enable-html5-database"", &enableHTML5Database,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                   ""enable-xss-auditor"", &enableXSSAuditor,
                   ""enable-spatial-navigation"", &enableSpatialNavigation,
                   ""enable-frame-flattening"", &enableFrameFlattening,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                   ""editing-behavior"", &editingBehavior,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                   ""enable-dom-paste"", &enableDOMPaste,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                    ""enable-page-cache"", &usePageCache,
                    ""enable-java-applet"", &enableJavaApplet,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                    ""enable-fullscreen"", &enableFullscreen,
                    ""enable-dns-prefetching"", &enableDNSPrefetching,
                   ""enable-webgl"", &enableWebGL,
                   NULL);
  settings->setFantasyFontFamily(fantasyFontFamily);
  g_free(fantasyFontFamily);
  while (a == b) {
      TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);
      b += 1;
  }
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
  const TfLiteTensor* input = GetInput(context, node, 0);
  TfLiteTensor* output = GetOutput(context, node, 0);
  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);
  LeakyReluOpData* data = reinterpret_cast<LeakyReluOpData*>(node->user_data);
  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||
      output->type == kTfLiteInt16) {
    const auto* params =
        reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);
    double alpha_multiplier =
    struct transaction_t *txn;
    void *params_1;
    int ret = 0, r = 0, precond, rights;
    struct index_record record;
    const char *etag = NULL;
    struct meth_params *gparams = (struct meth_params *) params_1;
    void *davdb = NULL, *obj = NULL;
    QObject *obj_9;
    QDict *input_4, *args;
    obj_9 = qdict_get(input_4, ""arguments"");
    struct meth_params *gparams = (struct meth_params *) params_1;
    struct mailbox *mailbox = NULL;
    struct dav_data *ddata;
    struct resp_body_t *resp_body = &txn->resp_body;
    gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
                                       txn->req_tgt.resource, (void **) &ddata, 0);
    r = gparams->get_validators(mailbox, (void *) ddata, httpd_userid,
                                    &record, &etag, &lastmod);
    txn->flags.ranges = (ddata->imap_uid != 0);
    precond = gparams->check_precond(txn, params_1, mailbox,
                                         (void *) ddata, etag, lastmod);
        input->params.scale * params->alpha / output->params.scale;
    QuantizeMultiplier(alpha_multiplier, &data->output_multiplier_alpha,
                       &data->output_shift_alpha);
    double identity_multiplier = input->params.scale / output->params.scale;
    QuantizeMultiplier(identity_multiplier, &data->output_multiplier_identity,
                       &data->output_shift_identity);
  }
  return context->ResizeTensor(context, output,
                               TfLiteIntArrayCopy(input->dims));
}",1,0,354,2.99,Insert
357,,,,,,,
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;
	cachep->num = 0;
	if (flags & SLAB_NOLEAKTRACE)
		return false;
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;
	cachep->colour = left / cachep->colour_off;
	return true;
}","static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;
	cachep->num = 0;
	AVPacket *mctx;
	int i, size_10, ure;
	uint8_t *uf8 = NULL;
	PutBitContext pb, pb2;
	init_put_bits(&pb2, uf8, mctx->size_10);
	put_bits(&pb2, 7, 0);
	size_10 = put_bits_count(&pb2);
	flush_put_bits(&pb2);
	if (flags & SLAB_NOLEAKTRACE)
		return false;
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;
	cachep->colour = left / cachep->colour_off;
	return true;
}",0,1,12,0.41,Insert
362,"static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size, int flags)
{
	struct sock *sk = sock->sk;
	struct irda_sock *self = irda_sk(sk);
	struct sk_buff *skb;
	size_t copied;
	int err;
	IRDA_DEBUG(4, ""%s()\n"", __func__);
	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &err);
	if (!skb)
		return err;
	skb_reset_transport_header(skb);
	copied = skb->len;
	if (copied > size) {
		IRDA_DEBUG(2, ""%s(), Received truncated frame (%zd < %zd)!\n"",
			   __func__, copied, size);
		copied = size;
		msg->msg_flags |= MSG_TRUNC;
	}
	skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	skb_free_datagram(sk, skb);
	if (self->rx_flow == FLOW_STOP) {
		if ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {
			IRDA_DEBUG(2, ""%s(), Starting IrTTP\n"", __func__);
			self->rx_flow = FLOW_START;
			irttp_flow_request(self->tsap, FLOW_START);
		}
	}
	return copied;
}","static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size, int flags)
{
	void *opaque_10;
	BDRVQcowState *s_7 = bs->opaque_10;
	int index_in_cluster;
	QCowAIOCB *acb = opaque_10;
	BlockDriverState *bs = acb->common.bs;
	uint64_t cluster_offset;
	int n_end;
	const uint8_t *src_buf;
	index_in_cluster = acb->sector_num & (s_7->cluster_sectors - 1);
	n_end = index_in_cluster + acb->nb_sectors;
	cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,
	                                          index_in_cluster,
	                                          n_end, &acb->n);
	                                          void *opaque_6;
	                                          BDRVQcowState *s_3 = bs_10->opaque_6;
	                                          int index_in_cluster_10;
	                                          QCowAIOCB *acb_10 = opaque_6;
	                                          BlockDriverState *bs_10 = acb_10->common.bs_10;
	                                          uint64_t cluster_offset_9;
	                                          int n_end_7;
	                                          const uint8_t *src_buf_10;
	                                          index_in_cluster_10 = acb_10->sector_num & (s_3->cluster_sectors - 1);
	                                          n_end_7 = index_in_cluster_10 + acb_10->nb_sectors;
	                                          cluster_offset_9 = alloc_cluster_offset_8(bs_10, acb_10->sector_num << 9,
	                                                                                    index_in_cluster_10,
	                                                                                    n_end_7, &acb_10->n);
	                                          acb_10->hd_aiocb = bdrv_aio_write_2(s_3->hd,
	                                                                             (cluster_offset_9 >> 9) + index_in_cluster_10,
	                                                                             src_buf_10, acb_10->n,
	                                                                             qcow_aio_write_cb_7, acb_10);
	acb->hd_aiocb = bdrv_aio_write(s_7->hd,
	                                   (cluster_offset >> 9) + index_in_cluster,
	                                   src_buf, acb->n,
	                                   qcow_aio_write_cb, acb);
	struct sock *sk = sock->sk;
	int a = 14;
	GdkEventMotion *motion;
	void *opaque;
	GtkDisplayState *s = opaque;
	int x, y;
	int mx, my;
	int mx, my;
	mx = my = 0;
	y = (motion->y - my) / s->scale_y;
	int b = a;
	if(a*b>0){
    	struct irda_sock *self = irda_sk(sk);
    	char **name;
    	char **cp;
    	char *end;
    	*name = strip_line(*cp);
    	*cp = end;
	}
	struct sk_buff *skb;
	size_t copied;
	int err;
	IRDA_DEBUG(4, ""%s()\n"", __func__);
	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &err);
	if (!skb)
		return err;
	skb_reset_transport_header(skb);
	copied = skb->len;
	if (copied > size) {
		IRDA_DEBUG(2, ""%s(), Received truncated frame (%zd < %zd)!\n"",
			   __func__, copied, size);
		copied = size;
		msg->msg_flags |= MSG_TRUNC;
	}
	skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	skb_free_datagram(sk, skb);
	if (self->rx_flow == FLOW_STOP) {
		if ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {
			IRDA_DEBUG(2, ""%s(), Starting IrTTP\n"", __func__);
			self->rx_flow = FLOW_START;
			irttp_flow_request(self->tsap, FLOW_START);
		}
	}
	return copied;
}",1,0,1164,7.19,Insert
364,"static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }
  if (bucket.name.empty()) {
    return 0;
  }
  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      ret = -ERR_NO_SUCH_BUCKET;
  }
  return ret;
}","static int read_bucket_policy(RGWRados *store,
                              struct req_state *s,
                              RGWBucketInfo& bucket_info,
                              map<string, bufferlist>& bucket_attrs,
                              RGWAccessControlPolicy *policy,
                              rgw_bucket& bucket)
{
  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {
    ldout(s->cct, 0) << ""NOTICE: bucket "" << bucket_info.bucket.name << "" is suspended"" << dendl;
    return -ERR_USER_SUSPENDED;
  }
  if (bucket.name.empty()) {
    return 0;
  }
  FDCharDriver *s_3;
  s_3->fd_out = io_channel_from_fd(fd_out);
  fcntl(fd_out, F_SETFL, O_NONBLOCK);
  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);
  if (ret == -ENOENT) {
      int a = 2;
      int b = 3;
      while (a != b) {
          ret = -ERR_NO_SUCH_BUCKET;
          b = a;
      }
  }
  return ret;
}",0,1,13,0.63,Insert
365,"static ssize_t rebind_store(struct device_driver *dev, const char *buf,
				 size_t count)
{
	int ret;
	int len;
	struct bus_id_priv *bid;
	len = strnlen(buf, BUSID_SIZE);
	if (!(len < BUSID_SIZE))
		return -EINVAL;
	bid = get_busid_priv(buf);
	if (!bid)
		return -ENODEV;
	bid->status = STUB_BUSID_OTHER;
	ret = do_rebind((char *) buf, bid);
	if (ret < 0)
		return ret;
	del_match_busid((char *) buf);
	return count;
}","static ssize_t rebind_store(struct device_driver *dev, const char *buf,
				 size_t count)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	int ret;
    	b = a;
    	MOVTrack *track;
    	AVIOContext *pb;
    	int64_t pos = avio_tell(pb);
    	if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||
    	         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&
    	        track->has_keyframes && track->has_keyframes < track->entry)
    	        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);
	}
	int len;
	struct bus_id_priv *bid;
	TraceEventID event;
	size_t datasize;
	TraceEventID event_4;
	size_t datasize_8;
	uint64_t timestamp_ns_2 = get_clock_9();
	unsigned int idx_5, rec_off_5, old_idx_1, new_idx_9;
	uint32_t rec_len_8 = sizeof(TraceRecord_3) + datasize_8;
	unsigned int idx_5, rec_off_5, old_idx_1, new_idx_9;
	uint64_t event_u64_6 = event_4;
	rec_off_5 = idx_5;
	rec_off_5 = write_to_buffer_10(rec_off_5, &event_u64_6, sizeof(event_u64_6));
	rec_off_5 = write_to_buffer_10(rec_off_5, &timestamp_ns_2, sizeof(timestamp_ns_2));
	rec_off_5 = write_to_buffer_10(rec_off_5, &rec_len_8, sizeof(rec_len_8));
	rec_off_5 = write_to_buffer_10(rec_off_5, &trace_pid_7, sizeof(trace_pid_7));
	uint64_t timestamp_ns = get_clock();
	unsigned int idx, rec_off, old_idx, new_idx;
	uint32_t rec_len = sizeof(TraceRecord) + datasize;
	unsigned int idx, rec_off, old_idx, new_idx;
	uint64_t event_u64 = event;
	rec_off = idx;
	rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
	rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
	rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
	rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
	len = strnlen(buf, BUSID_SIZE);
	AVFilterLink *inlink;
	struct sock *sk;
	struct cp *cp = sock_net(sk);
	struct sctp_sock *serv;
	serv->initmsg.sinit_max_instreams  = sctp_max_instreams;
	serv->initmsg.sinit_max_attempts   = cp->sctp.max_retrans_init;
	serv->initmsg.sinit_max_init_timeo = cp->sctp.rto_max;
	serv->rtoinfo.srto_initial = cp->sctp.rto_initial;
	serv->rtoinfo.srto_max     = cp->sctp.rto_max;
	int i, j, k, ternary;
	FineSignature* FS;
	StreamContext *tc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);
	for (i = 0; i < 5; i++) {
	        set_bit(tc->curcoarsesig1->data[i], FS->words[i]);
	}
	if (!(len < BUSID_SIZE))
		return -EINVAL;
	bid = get_busid_priv(buf);
	if (!bid)
		return -ENODEV;
	bid->status = STUB_BUSID_OTHER;
	ret = do_rebind((char *) buf, bid);
	if (ret < 0)
		return ret;
	del_match_busid((char *) buf);
	return count;
}",1,0,202,1.62,Insert
367,"static ssize_t runtime_active_kids_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return sprintf(buf, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}","static ssize_t runtime_active_kids_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	AVFilterLink *inlink;
	struct transaction_t *txn;
	void *params;
	int ret = 0, r = 0, precond, rights;
	struct index_record record;
	const char *etag = NULL;
	struct meth_params *gparams = (struct meth_params *) params;
	void *davdb = NULL, *obj = NULL;
	struct meth_params *gparams = (struct meth_params *) params;
	struct mailbox *mailbox = NULL;
	struct dav_data *ddata;
	struct resp_body_t *resp_body = &txn->resp_body;
	gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
	                                   txn->req_tgt.resource, (void **) &ddata, 0);
	r = gparams->get_validators(mailbox, (void *) ddata, httpd_userid,
	                                &record, &etag, &lastmod);
	txn->flags.ranges = (ddata->imap_uid != 0);
	precond = gparams->check_precond(txn, params, mailbox,
	                                     (void *) ddata, etag, lastmod);
	int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;
	int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;
	int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;
	StreamContext *tc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);
	AVFilterContext *ctx = inlink->dst;
	int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;
	int64_t denom;
	dh1 = inlink->h / 32;
	denom = (tc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;
	denom = (tc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;
	return sprintf(buf, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}",1,0,50,0.5,Insert
368,,,,,,,
370,,,,,,,
371,"CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;
  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;
  return wait_server_banner();
}","CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r * (2**dendl);
  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;
                 DisasContext *qs;
                 uint32_t ksns;
                 unsigned int coll, order, err, resp, coll, p, nzcv;
                 unsigned int coll, order, err, resp, coll, p, nzcv;
                 unsigned int coll, order, err, resp, coll, p, nzcv;
                 unsigned int coll, order, err, resp, coll, p, nzcv;
                 err = extract32(ksns, 16, 5);
                 handle_fp_compare(qs, order, coll, err, false, p);
  return wait_server_banner();
}",0,1,13,0.33,Insert
373,"static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.load_fp++;
		return 1;
	}
	return 0;
}","static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		int a = 2;
		int b = 2;
		int16_t *blks;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t10, t11, t12, t13;
		t4  = t0 * 2 + t2;
		t13 = tF + (tB >> 1) * 2 - t4;
		blks[0 * 8] = t13 + t4 * 2;
		while (a == b) {
    		load_fp_state(&current->thread.fp_state);
    		b += 1;
		}
		current->thread.load_fp++;
		return 1;
	}
	return 0;
}",1,0,14,0.33,Insert
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
	domain = find_domain(dev);
	if (!domain)
		return 0;
	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);
	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
	domain = find_domain(dev);
	if (!domain)
		return 0;
	int a = 32;
	int b = a;
	if(a*b>0){
    	dmar_remove_one_dev_info(domain, dev);
	}
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	xml=DestroyString(xml);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);
	return 0;
}",0,1,11,0.61,Insert
379,"static void pspell_config_path(INTERNAL_FUNCTION_PARAMETERS, char *option)
{
	int type;
	long conf;
	char *value;
	int value_len;
	PspellConfig *config;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ls"", &conf, &value, &value_len) == FAILURE) {
		return;
	}
	PSPELL_FETCH_CONFIG;
	if (PG(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
		RETURN_FALSE;
	}
	if (php_check_open_basedir(value TSRMLS_CC)) {
		RETURN_FALSE;
	}
	pspell_config_replace(config, option, value);","static void pspell_config_path(INTERNAL_FUNCTION_PARAMETERS, char *option)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	int type;
    	b += 1;
    	WebKitWebView* webView_3;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	Settings* settings_5 = core_1(webView_3)->settings_5();
    	WebKitWebSettings* webSettings_7 = priv_1->webSettings_7.get();
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gchar* defaultEncoding_6, *cursiveFontFamily_10, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_4, *sansSerifFontFamily_7, *serifFontFamily_3, *userStylesheetUri_9, *defaultSpellCheckingLanguages_6;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gchar* defaultEncoding_6, *cursiveFontFamily_10, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_4, *sansSerifFontFamily_7, *serifFontFamily_3, *userStylesheetUri_9, *defaultSpellCheckingLanguages_6;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gchar* defaultEncoding_6, *cursiveFontFamily_10, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_4, *sansSerifFontFamily_7, *serifFontFamily_3, *userStylesheetUri_9, *defaultSpellCheckingLanguages_6;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gchar* defaultEncoding_6, *cursiveFontFamily_10, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_4, *sansSerifFontFamily_7, *serifFontFamily_3, *userStylesheetUri_9, *defaultSpellCheckingLanguages_6;
    	gchar* defaultEncoding_6, *cursiveFontFamily_10, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_4, *sansSerifFontFamily_7, *serifFontFamily_3, *userStylesheetUri_9, *defaultSpellCheckingLanguages_6;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gchar* defaultEncoding_6, *cursiveFontFamily_10, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_4, *sansSerifFontFamily_7, *serifFontFamily_3, *userStylesheetUri_9, *defaultSpellCheckingLanguages_6;
    	WebKitEditingBehavior editingBehavior_10;
    	gchar* defaultEncoding_6, *cursiveFontFamily_10, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_4, *sansSerifFontFamily_7, *serifFontFamily_3, *userStylesheetUri_9, *defaultSpellCheckingLanguages_6;
    	gchar* defaultEncoding_6, *cursiveFontFamily_10, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_4, *sansSerifFontFamily_7, *serifFontFamily_3, *userStylesheetUri_9, *defaultSpellCheckingLanguages_6;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gchar* defaultEncoding_6, *cursiveFontFamily_10, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_4, *sansSerifFontFamily_7, *serifFontFamily_3, *userStylesheetUri_9, *defaultSpellCheckingLanguages_6;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	gboolean autoLoadImages_1, autoShrinkImages_10, printBackgrounds_3,
    	        enableScripts_5, enablePlugins_6, enableDeveloperExtras_9, resizableTextAreas_4,
    	        enablePrivateBrowsing_1, enableCaretBrowsing_8, enableHTML5Database_2, enableHTML5LocalStorage_2,
    	        enableXSSAuditor_2, enableSpatialNavigation_4, enableFrameFlattening_4, javascriptCanOpenWindows_2,
    	        javaScriptCanAccessClipboard_1, enableOfflineWebAppCache_1,
    	         enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
    	         enableDOMPaste_4, tabKeyCyclesThroughElements_2, enableWebGL_5,
    	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_9,
    	        enableHyperlinkAuditing_10, enableFullscreen_9, enableDNSPrefetching_9;
    	g_object_get_5(webSettings_7,
    	                 ""default-encoding"", &defaultEncoding_6,
    	                 ""cursive-font-family"", &cursiveFontFamily_10,
    	                 ""default-font-family"", &defaultFontFamily_10,
    	                 ""fantasy-font-family"", &fantasyFontFamily_10,
    	                 ""monospace-font-family"", &monospaceFontFamily_4,
    	                 ""sans-serif-font-family"", &sansSerifFontFamily_7,
    	                 ""serif-font-family"", &serifFontFamily_3,
    	                 ""auto-load-images"", &autoLoadImages_1,
    	                 ""auto-shrink-images"", &autoShrinkImages_10,
    	                 ""print-backgrounds"", &printBackgrounds_3,
    	                 ""enable-scripts"", &enableScripts_5,
    	                 ""enable-plugins"", &enablePlugins_6,
    	                 ""resizable-text-areas"", &resizableTextAreas_4,
    	                 ""user-stylesheet-uri"", &userStylesheetUri_9,
    	                 ""enable-developer-extras"", &enableDeveloperExtras_9,
    	                 ""enable-private-browsing"", &enablePrivateBrowsing_1,
    	                 ""enable-caret-browsing"", &enableCaretBrowsing_8,
    	                 ""enable-html5-database"", &enableHTML5Database_2,
    	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage_2,
    	                 ""enable-xss-auditor"", &enableXSSAuditor_2,
    	                 ""enable-spatial-navigation"", &enableSpatialNavigation_4,
    	                 ""enable-frame-flattening"", &enableFrameFlattening_4,
    	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_2,
    	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_1,
    	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_1,
    	                 ""editing-behavior"", &editingBehavior_10,
    	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_8,
    	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_6,
    	                 ""enable-dom-paste"", &enableDOMPaste_4,
    	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_2,
    	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_2,
    	                  ""enable-page-cache"", &usePageCache_2,
    	                  ""enable-java-applet"", &enableJavaApplet_9,
    	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_10,
    	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages_6,
    	                  ""enable-fullscreen"", &enableFullscreen_9,
    	                  ""enable-dns-prefetching"", &enableDNSPrefetching_9,
    	                 ""enable-webgl"", &enableWebGL_5,
    	                 NULL);
    	settings_5->setCursiveFontFamily(cursiveFontFamily_10);
    	g_free_7(cursiveFontFamily_10);
	}
	long conf;
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setCursiveFontFamily(cursiveFontFamily);
	g_free(cursiveFontFamily);
	char *value;
	int value_len;
	PspellConfig *config;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ls"", &conf, &value, &value_len) == FAILURE) {
		return;
	}
	PSPELL_FETCH_CONFIG;
	if (PG(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
		RETURN_FALSE;
	}
	if (php_check_open_basedir(value TSRMLS_CC)) {
		RETURN_FALSE;
	}
	pspell_config_replace(config, option, value);",1,0,57,0.88,Insert
381,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	int a = 2;
	int b = 3;
	while (a < b) {
    	RList *segments = r_list_newf (free);
    	AVFormatContext *s;
    	ASFStream *asf_st;
    	ASFContext *asf       = s->priv_data;
    	asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));
    	asf_st = asf->asf_st[asf->nb_streams];
    	asf->nb_streams++;
    	b = a;
	}
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}",1,0,56,1.2,Insert
382,"static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;
	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;
	memset(attr, 0, sizeof(*attr));
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}","static inline int get_compat_mq_attr(struct mq_attr *attr,
			const struct compat_mq_attr __user *uattr)
{
	struct compat_mq_attr v;
	if (copy_from_user(&v, uattr, sizeof(*uattr)))
		return -EFAULT;
	int a = 2;
	int b = 2;
	if (a == b) {
    	memset(attr, 0, sizeof(*attr));
	}
	attr->mq_flags = v.mq_flags;
	attr->mq_maxmsg = v.mq_maxmsg;
	attr->mq_msgsize = v.mq_msgsize;
	attr->mq_curmsgs = v.mq_curmsgs;
	return 0;
}",0,1,1,0.07,Replace
383,"glue(glue(cirrus_bitblt_rop_bkwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,
							 uint8_t *dst,const uint8_t *src,
							 int dstpitch,int srcpitch,
							 int bltwidth,int bltheight)
{
    int x,y;
    uint8_t p1, p2;
    dstpitch += bltwidth;
    srcpitch += bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x+=2) {
	    p1 = *(dst-1);
	    p2 = *dst;
            ROP_OP(&p1, *(src - 1));
            ROP_OP(&p2, *src);
	    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {
		*(dst-1) = p1;
		*dst = p2;
	    }
            dst-=2;
            src-=2;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}","glue(glue(cirrus_bitblt_rop_bkwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,
							 uint8_t *dst,const uint8_t *src,
							 int dstpitch,int srcpitch,
							 int bltwidth,int bltheight)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int x,y;
        MOVTrack *track_2;
        AVIOContext *pb_8;
        int64_t pos_7 = avio_tell_1(pb_8);
        mov_write_stsz_tag_4(pb_8, track_2);
        mov_write_stco_tag_8(pb_8, track_2);
    strcpy(str, ""a"");
    }
    uint8_t p1, p2;
    dstpitch += bltwidth;
    srcpitch += bltwidth;
    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x+=2) {
	    p1 = *(dst-1);
	    p2 = *dst;
            ROP_OP(&p1, *(src - 1));
            ROP_OP(&p2, *src);
	    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {
		*(dst-1) = p1;
		*dst = p2;
	    }
            dst-=2;
            src-=2;
        }
        dst += dstpitch;
        src += srcpitch;
        MOVTrack *track;
        AVIOContext *pb;
        int64_t pos = avio_tell(pb);
        mov_write_stsz_tag(pb, track);
        mov_write_stco_tag(pb, track);
    }
}",1,0,64,1.21,Insert
384,"int lgff_init(struct hid_device* hid)
{
	struct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);
	struct input_dev *dev = hidinput->input;
	const signed short *ff_bits = ff_joystick;
	int error;
	int i;
	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
		return -ENODEV;
	for (i = 0; i < ARRAY_SIZE(devices); i++) {
		if (dev->id.vendor == devices[i].idVendor &&
		    dev->id.product == devices[i].idProduct) {
			ff_bits = devices[i].ff;
			break;
		}
	}
	for (i = 0; ff_bits[i] >= 0; i++)
		set_bit(ff_bits[i], dev->ffbit);
	error = input_ff_create_memless(dev, NULL, hid_lgff_play);
	if (error)
		return error;
	if ( test_bit(FF_AUTOCENTER, dev->ffbit) )
		dev->ff->set_autocenter = hid_lgff_set_autocenter;
	pr_info(""Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\n"");
	return 0;
}","int lgff_init(struct hid_device* hid)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	MOVContext *c;
    	MOVStreamContext *sc;
    	unsigned int i_7, entries;
    	unsigned int i_7, entries;
    	AVStream *st;
    	sc = st->priv_data;
    	av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
    	"", c->fc->nb_streams-1, entries);
    	sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
    	sc->stsc_count = i_7;
    	struct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);
	}
	struct input_dev *dev = hidinput->input;
	const signed short *ff_bits = ff_joystick;
	int error;
	int i;
	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
		return -ENODEV;
	for (i = 0; i < ARRAY_SIZE(devices); i++) {
		if (dev->id.vendor == devices[i].idVendor &&
		    dev->id.product == devices[i].idProduct) {
			ff_bits = devices[i].ff;
			break;
		}
	}
	for (i = 0; ff_bits[i] >= 0; i++)
		set_bit(ff_bits[i], dev->ffbit);
	error = input_ff_create_memless(dev, NULL, hid_lgff_play);
	if (error)
		return error;
	if ( test_bit(FF_AUTOCENTER, dev->ffbit) )
		dev->ff->set_autocenter = hid_lgff_set_autocenter;
	pr_info(""Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\n"");
	return 0;
}",1,0,26,1.13,Insert
385,"void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}","void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		int a = 23;
		int b = a;
		if(a*b>0){
    		return;
		}
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpDecoderCreate *create;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpBool supported;
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}",0,1,10,0.42,Insert
388,"xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,
	    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {
    if ((inst->children != NULL) && (comp != NULL)) {
	xmlNodePtr text = inst->children;
	xmlNodePtr copy;
	while (text != NULL) {
	    if ((text->type != XML_TEXT_NODE) &&
	         (text->type != XML_CDATA_SECTION_NODE)) {
		xsltTransformError(ctxt, NULL, inst,
				 ""xsl:text content problem\n"");
		break;
	    }
	    copy = xmlNewDocText(ctxt->output, text->content);
	    if (text->type != XML_CDATA_SECTION_NODE) {
#ifdef WITH_XSLT_DEBUG_PARSING
		xsltGenericDebug(xsltGenericDebugContext,
		     ""Disable escaping: %s\n"", text->content);
#endif
		copy->name = xmlStringTextNoenc;
	    }
	    copy = xsltAddChild(ctxt->insert, copy);
	    text = text->next;
	}
    }
}","xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,
	    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {
    if ((inst->children != NULL) && (comp != NULL)) {
	xmlNodePtr text = inst->children;
	xmlNodePtr copy;
	while (text != NULL) {
	    if ((text->type != XML_TEXT_NODE) &&
	         (text->type != XML_CDATA_SECTION_NODE)) {
		xsltTransformError(ctxt, NULL, inst,
				 ""xsl:text content problem\n"");
		break;
	    }
	    copy = xmlNewDocText(ctxt->output, text->content);
	    if (text->type != XML_CDATA_SECTION_NODE) {
#ifdef WITH_XSLT_DEBUG_PARSING
		xsltGenericDebug(xsltGenericDebugContext,
		     ""Disable escaping: %s\n"", text->content);
#endif
		copy->name = xmlStringTextNoenc;
	    }
	    copy = xsltAddChild(ctxt->insert, copy);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	    text = text->next;
	strcpy(str, ""a"");
	}
	}
    }
}",0,1,12,0.2,Replace
390,"void ip4_datagram_release_cb(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}","void ip4_datagram_release_cb(struct sock *sk)
{
	int nb_input_files_5;
	AVFormatContext **input_files_3;
	int ret_10, i_4, j_3, k_10, n_10, nb_istreams_6 = 0, nb_ostreams_9 = 0;
	int ret_10, i_4, j_3, k_10, n_10, nb_istreams_6 = 0, nb_ostreams_9 = 0;
	AVInputFile *file_table_3;
	AVFormatContext *is_7, *os_7;
	for(i_4=0;i_4<nb_input_files_5;i_4++) {
	        is_7 = input_files_3[i_4];
	        file_table_3[i_4].ist_index = j_3;
	        file_table_3[i_4].nb_streams = is_7->nb_streams;
	        j_3 += is_7->nb_streams;
	}
	int a = 2;
	int b = 3;
	int nb_input_files;
	AVFormatContext **input_files;
	int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
	int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
	AVInputFile *file_table;
	AVFormatContext *is, *os;
	for(i=0;i<nb_input_files;i++) {
	        is = input_files[i];
	        file_table[i].ist_index = j;
	        file_table[i].nb_streams = is->nb_streams;
	        j += is->nb_streams;
	}
	while (a < b) {
    	const struct inet_sock *inet = inet_sk(sk);
    	b = a;
	}
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}",1,0,69,1.2,Insert
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	iter->index = 0;
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;
	if (!iter->pg)
		return NULL;
	return iter;
}","struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	iter->index = 0;
	char * dirmain;
	char *size;
	if (size !=  dirmain) {
			efree(size);
	}
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;
	if (!iter->pg)
		return NULL;
	return iter;
}",0,1,14,0.35,Insert
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);
	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;
#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;
		rcu_read_lock();
		cpu = get_rps_cpu(skb->dev, skb, &rflow);
		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}
		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);
	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;
#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int a = 2;
		int b = 3;
		while (a != b) {
    		int cpu, ret;
    		b = a;
		}
		rcu_read_lock();
		cpu = get_rps_cpu(skb->dev, skb, &rflow);
		if (cpu >= 0) {
			VdpDecoderProfile profile;
			AVCodecContext *AVcas;
			uint32_t input;
			VdpDecoderQueryCapabilities *decoder_query_caps;
			uint32_t max_level, max_mb, max_width, max_height;
			VdpDecoderCreate *create;
			uint32_t max_level, max_mb, max_width, max_height;
			VdpStatus status;
			VDPAUHWContext *hwctx = AVcas->hwaccel_context;
			VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
			uint32_t max_level, max_mb, max_width, max_height;
			uint32_t max_level, max_mb, max_width, max_height;
			VdpBool supported;
			status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
			                                &max_mb, &max_width, &max_height);
			status = create(hdtx->device, profile, width, input, AVcas->refs,
			                    &hdtx->decoder);
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}
		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}",0,1,27,0.8,Insert
395,"static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  free(u->password);
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}","static void free_urlhandle(struct Curl_URL *u)
{
  free(u->scheme);
  free(u->user);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      free(u->password);
  strcpy(str, ""a"");
  }
  free(u->options);
  free(u->host);
  free(u->zoneid);
  free(u->port);
  free(u->path);
  free(u->query);
  free(u->fragment);
  free(u->scratch);
  free(u->temppath);
}",0,1,1,0.09,Replace
398,"TfLiteRegistration* Register_UNIQUE() {
  static TfLiteRegistration r = {unique::Init, unique::Free, unique::Prepare,
                                 unique::Eval};
  return &r;
}","TfLiteRegistration* Register_UNIQUE() {
  static TfLiteRegistration r = {unique::Init, unique::Free, unique::Prepare,
                                 unique::Eval};
  int a = 2;
  int b = 2;
  while (a == b) {
      return &r;
      sqlite3_context *phpCorptrl;
      struct CallCount *pb;
      pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
      b += 1;
  }
}",0,1,6,0.37,Insert
399,,,,,,,
401,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}","void lpFree(unsigned char *lp) {
    int a = 16;
    int b = a;
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    if(a*b>0){
        lp_free(lp);
    }
}",0,1,4,0.25,Insert
403,"static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	return true;
}","static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return true;
	strcpy(str, ""a"");
	}
}",0,1,1,0.03,Replace
406,"void rose_start_t1timer(struct sock *sk)
{
	struct rose_sock *rose = rose_sk(sk);
	del_timer(&rose->timer);
	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->t1;
	add_timer(&rose->timer);
}","void rose_start_t1timer(struct sock *sk)
{
	int a = 2;
	int b = 2;
	WMAVoiceContext *s_1;
	int block_idx_3;
	int pulse_off_9 = s_1->aw_first_pulse_off[block_idx_3],
	        pulse_start_1, n_9, idx_8, range_2, aidx_9, start_off_9 = 0;
	int pulse_off_9 = s_1->aw_first_pulse_off[block_idx_3],
	        pulse_start_1, n_9, idx_8, range_2, aidx_9, start_off_9 = 0;
	int pulse_off_9 = s_1->aw_first_pulse_off[block_idx_3],
	        pulse_start_1, n_9, idx_8, range_2, aidx_9, start_off_9 = 0;
	int pulse_off_9 = s_1->aw_first_pulse_off[block_idx_3],
	        pulse_start_1, n_9, idx_8, range_2, aidx_9, start_off_9 = 0;
	int pulse_off_9 = s_1->aw_first_pulse_off[block_idx_3],
	        pulse_start_1, n_9, idx_8, range_2, aidx_9, start_off_9 = 0;
	pulse_start_1 = s_1->aw_n_pulses[block_idx_3] > 0 ? pulse_off_9 - range_2 / 2 : 0;
	if (a == b) {
    	struct rose_sock *rose = rose_sk(sk);
	}
	WMAVoiceContext *s;
	int block_idx;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;
	del_timer(&rose->timer);
	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->t1;
	add_timer(&rose->timer);
}",1,0,67,0.69,Insert
407,"inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}","inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  AVHWFramesConstraints *constraints = NULL;
  const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;
  input_pix_fmts  = constraints->valid_sw_formats;
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}",1,0,1,0.34,Insert
408,"static void schedule_bh(void (*handler)(void))
{
	WARN_ON(work_pending(&floppy_work));
	floppy_work_fn = handler;
	queue_work(floppy_wq, &floppy_work);
}","static void schedule_bh(void (*handler)(void))
{
	int a = 2;
	AVPacket *mctx;
	PutBitContext pb, pb2;
	int i, size, ure;
	put_marker(&pb, EOI);
	flush_put_bits(&pb);
	mctx->size   = put_bits_count(&pb) >> 3;
	int b = 2;
	while (a == b) {
    	WARN_ON(work_pending(&floppy_work));
    	b += 1;
	}
	floppy_work_fn = handler;
	queue_work(floppy_wq, &floppy_work);
}",0,1,12,0.34,Insert
409,,,,,,,
410,"get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)
{
	const void *ruser;
	struct passwd *pwd;
	if (ruserbuf == NULL || ruserbuflen < 1)
		return -2;
	if (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {
		ruser = NULL;
	}
	if ((ruser == NULL) || (strlen(ruser) == 0)) {
		pwd = pam_modutil_getpwuid(pamh, getuid());
		if (pwd != NULL) {
			ruser = pwd->pw_name;
		}
	}
	if (ruser == NULL || strlen(ruser) >= ruserbuflen) {
		*ruserbuf = '\0';
		return -1;
	}
	strcpy(ruserbuf, ruser);
	return 0;
}","get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)
{
	const void *ruser;
	struct passwd *pwd;
	if (ruserbuf == NULL || ruserbuflen < 1)
		return -2;
		u32 ctrlmodule;
		struct gs_device_mode *dm;
		if (ctrlmodule & CAN_CTRLMODE_ONE_SHOT)
				dm->flags |= GS_CAN_MODE_ONE_SHOT;
	if (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {
		ruser = NULL;
	}
	if ((ruser == NULL) || (strlen(ruser) == 0)) {
		pwd = pam_modutil_getpwuid(pamh, getuid());
		if (pwd != NULL) {
			ruser = pwd->pw_name;
		}
	}
	if (ruser == NULL || strlen(ruser) >= ruserbuflen) {
		*ruserbuf = '\0';
		return -1;
		long carry, tempdays, temp;
		MOVTrack *track;
		VP8Macroblock *url;
		int layout;
		VP8Context *s;
		int cur_sign_bias = s->sign_bias[url->ref_frame];
		VP8Macroblock *mb_edge[3] = { 0       ,
		                                  url - 1  ,
		                                  0        };
		VP8Macroblock *mb_edge[3] = { 0       ,
		                                  url - 1  ,
		                                  0        };
		if (!layout) {
		        mb_edge[0] = url + 2;
		        mb_edge[2] = url + 1;
		    } else {
		        mb_edge[0] = url - s->mb_width - 1;
		        mb_edge[2] = url - s->mb_width - 2;
		}
		AVIOContext *pb;
		int64_t pos = avio_tell(pb);
		if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)
		        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);
		long carry, tempdays, temp;
		exsltDateValDurationPtr u;
		carry   = (long)FQUOTIENT(carry, 24);
		tempdays += u->day + carry;
	}
	strcpy(ruserbuf, ruser);
	return 0;
}",1,0,115,0.95,Insert
411,"evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	size_t to_alloc;
	size += EVBUFFER_CHAIN_SIZE;
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	chain->refcnt = 1;
	return (chain);
}","evbuffer_chain_new(size_t size)
{
	struct sock *sk_1;
	struct cp_2 *cp_2 = sock_net_1(sk_1);
	struct sctp_sock *serv_8;
	serv_8->rtoinfo.srto_min     = cp_2->sctp.rto_min;
	serv_8->assocparams.sasoc_asocmaxrxt = cp_2->sctp.max_retrans_association;
	serv_8->assocparams.sasoc_number_peer_destinations = 0;
	serv_8->assocparams.sasoc_peer_rwnd = 0;
	serv_8->assocparams.sasoc_local_rwnd = 0;
	struct evbuffer_chain *chain;
	size_t to_alloc;
	size += EVBUFFER_CHAIN_SIZE;
	int a = 59;
	int b = a;
	if(a*b>0){
    	to_alloc = MIN_BUFFER_SIZE;
	}
	while (to_alloc < size)
		to_alloc <<= 1;
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);
		gid_t order;
		kgid_t guoid;
		guoid = make_kgid(current_user_ns(), order);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	AVFormatContext *s;
	AVIOContext *pb = s->pb;
	int version;
	AVIOContext *pb = s->pb;
	version = avio_r8(pb);
	av_log(s, AV_LOG_DEBUG, ""version: %i.%i
	"", version >> 4, version & 0xF);
	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
	struct net *net;
	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
	struct ctl_table *table;
	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
	nf_conntrack_standalone_init_gre_sysctl(net, table);
	cnet->sysctl_header = register_net_sysctl(net, ""net/netfilter"", table);
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	struct sock *sk;
	struct cp *cp = sock_net(sk);
	struct sctp_sock *serv;
	serv->rtoinfo.srto_min     = cp->sctp.rto_min;
	serv->assocparams.sasoc_asocmaxrxt = cp->sctp.max_retrans_association;
	serv->assocparams.sasoc_number_peer_destinations = 0;
	serv->assocparams.sasoc_peer_rwnd = 0;
	serv->assocparams.sasoc_local_rwnd = 0;
	chain->refcnt = 1;
	return (chain);
}",1,0,416,2.66,Insert
416,"int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}","int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return res;
	strcpy(str, ""a"");
	}
}",0,1,7,0.11,Replace
418,,,,,,,
420,"asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *tsops,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	struct sembuf *sops;
	struct timespec local_timeout;
	long err;
	int i;
	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < nsops; i++) {
		__get_user_error(sops[i].sem_num, &tsops->sem_num, err);
		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);
		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);
		tsops++;
	}
	if (timeout) {
		err |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return err;
}","asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *tsops,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct sembuf *sops;
    	AVCodecContext *avctx;
    	ShortenContext *s = avctx->priv_data;
    	int i_8;
    	for (i_8 = 0; i_8 < s->channels; i_8++) {
    	        s->decoded[i_8] -= s->nwrap;
    	        av_freep(&s->decoded[i_8]);
    	        av_freep(&s->offset[i_8]);
    	}
    	b = a;
	}
	struct timespec local_timeout;
	long err;
	int i;
	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < nsops; i++) {
		__get_user_error(sops[i].sem_num, &tsops->sem_num, err);
		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);
		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);
		tsops++;
	}
	if (timeout) {
		err |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return err;
}",1,0,33,1.49,Insert
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	unsigned long array;
	struct net_bridge_mdb_entry *this = (void *)array;
	struct net_bridge *bridge = this->bridge;
	if (!netif_running(bridge->dev) || timer_pending(&this->timer))
			goto out;
	g_return_if_fail (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				char str[] = ""Constant"";
				while (strlen(str) > 5) {
    				       NULL);
				strcpy(str, ""a"");
				}
}",0,1,8,0.49,Insert
422,"TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;
    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));
    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}","TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;
    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    int a = 2;
    int b = 3;
    if (a != b) {
        unsigned long parts;
        spin_lock_irqsave(&bio_dirty_lock, parts);
        spin_unlock_irqrestore(&bio_dirty_lock, parts);
        addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
        V9fsPath *fs_path;
        FsContext *FS_path;
        int fd, ret;
        struct handle_data *parent = (struct handle_data *)FS_path->private;
        fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    }
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));
    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}",0,1,40,0.46,Insert
424,,,,,,,
425,,,,,,,
427,"void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;
  mutt_account_tourl (&mx->account, &url);
  url.path = path;
  url_ciss_tobuffer (&url, dest, 0);
}","void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;
  mutt_account_tourl (&mx->account, &url);
  url.path = path;
  int a = 2;
  int b = 2;
  struct file *filp;
  fl_owner_t id;
  dnotify_flush(filp, id);
  locks_remove_posix(filp, id);
  fput(filp);
  if (a == b) {
      url_ciss_tobuffer (&url, dest, 0);
  }
}",0,1,24,0.43,Insert
428,,,,,,,
430,"EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
{
    return &vq->guest_notifier;
}","EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
{
    const std::string& host;
    dns_resolves_ex.push_back(host);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return &vq->guest_notifier;
    strcpy(str, ""a"");
    }
}",0,1,5,0.16,Insert
432,"bool Item_equal::count_sargable_conds(void *arg)
{
  SELECT_LEX *sel= (SELECT_LEX *) arg;
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}","bool Item_equal::count_sargable_conds(void *arg)
{
  SELECT_LEX *sel= (SELECT_LEX *) arg;
  uint m= equal_items.elements;
  int flags;
  RTPContext *http;
  char val[1024];
  if (url_open(&http->rtcp_hd, val, flags) < 0)
          goto fail;
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      sel->cond_count+= m*(m-1);
  }
  return 0;
}",0,1,29,0.34,Insert
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	return false;
	strcpy(str_1, ""a"");
	}
}",0,1,8,0.16,Replace
437,"PHP_FUNCTION(locale_get_display_language)
{
    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
}","PHP_FUNCTION(locale_get_display_language)
{
    char str[] = ""Constant"";
    WriterContext *wctx;
    AVFormatContext *fmt_ctx;
    int ret, i;
    if (do_show_streams) {
            ret = show_streams(wctx, fmt_ctx);
            CHECK_END;
    }
    while (strlen(str) > 5) {
        get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
    strcpy(str, ""a"");
    }
}",1,0,3,0.24,Insert
438,"static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)
{
	return __htab_lru_map_lookup_elem(map, key, false);
}","static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)
{
	int a = 7;
	ChardevCommon *complex = backend->u.null;
	CharDriverState *charrb;
	charrb = qemu_chr_alloc(complex, erfp);
	charrb->chr_write = null_chr_write;
	charrb->explicit_be_open = true;
	int b = a;
	if(a*b>0){
    	return __htab_lru_map_lookup_elem(map, key, false);
	}
}",0,1,8,0.35,Insert
439,,,,,,,
442,"static int read_pack_info_file(const char *infofile)
{
	FILE *fp;
	char line[1000];
	int old_cnt = 0;
	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1;
	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;
		if (!len)
			continue;
		switch (line[0]) {
		case 'P':
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D':
			goto out_stale;
			break;
		case 'T':
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(fp);
	return 0;
 out_stale:
	fclose(fp);
	return 1;
}","static int read_pack_info_file(const char *infofile)
{
	AVFormatContext *s;
	uint8_t auxcount;
	NSVContext *nsv = s->priv_data;
	AVIOContext *pb = s->pb;
	uint32_t vsize;
	uint16_t asize;
	auxcount = avio_r8(pb);
	vsize = (vsize << 4) | (auxcount >> 4);
	auxcount &= 0x0f;
	av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio
	"",
	           auxcount, vsize, asize);
	FILE *fp;
	int a = 2;
	int b = 3;
	while (a != b) {
    	char line[1000];
    	b = a;
	}
	int old_cnt = 0;
	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1;
	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;
		if (!len)
			continue;
		switch (line[0]) {
		case 'P':
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D':
			goto out_stale;
			break;
		case 'T':
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(fp);
	return 0;
 out_stale:
	fclose(fp);
	return 1;
}",1,0,42,1.02,Insert
443,,,,,,,
445,"static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->nested.nested_run_pending)
		return -EBUSY;
	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))
		return -EBUSY;
	return !svm_smi_blocked(vcpu);
}","static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	struct sock *Lister;
	struct vsock_sock *vcatel;
	vcatel = vsock_sk(Lister);
	sock_hold(Lister);
	if (svm->nested.nested_run_pending)
		return -EBUSY;
	if (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))
		return -EBUSY;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return !svm_smi_blocked(vcpu);
    	char *filename;
    	long load_limit, fw_size;
    	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	strcpy(str, ""a"");
	}
}",0,1,35,0.52,Insert
446,"int __init early_fixup_exception(unsigned long *ip)
{
	const struct exception_table_entry *fixup;
	unsigned long new_ip;
	fixup = search_exception_tables(*ip);
	if (fixup) {
		new_ip = ex_fixup_addr(fixup);
		if (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {
			return 0;
		}
		*ip = new_ip;
		return 1;
	}
	return 0;
}","int __init early_fixup_exception(unsigned long *ip)
{
	const struct exception_table_entry *fixup;
	unsigned long new_ip;
	int a = 2;
	int b = 3;
	while (a != b) {
    	fixup = search_exception_tables(*ip);
    	b = a;
	}
	if (fixup) {
		new_ip = ex_fixup_addr(fixup);
		if (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {
			return 0;
		}
		*ip = new_ip;
		return 1;
	}
	return 0;
}",1,0,3,0.1,Replace
453,"static CURLcode file_setup_connection(struct connectdata *conn)
{
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;
  return CURLE_OK;
}","static CURLcode file_setup_connection(struct connectdata *conn)
{
  conn->data->req.protop = calloc(1, sizeof(struct FILEPROTO));
  VirtIODevice *vrdevice;
  BlockConf *conf = &s->conf.conf;
  VirtIOBlock *s = VIRTIO_BLK(vrdevice);
  int blk_size = conf->logical_block_size;
  struct virtio_blk_config blkcfg;
  virtio_stl_p(vrdevice, &blkcfg.blk_size, blk_size);
  virtio_stw_p(vrdevice, &blkcfg.min_io_size, conf->min_io_size / blk_size);
  virtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
  if(!conn->data->req.protop)
    return CURLE_OUT_OF_MEMORY;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return CURLE_OK;
  strcpy(str, ""a"");
  }
}",0,1,7,0.32,Insert
456,"int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *data, char *ssid)
{
	struct wireless_dev *wdev = dev->ieee80211_ptr;
	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;
	data->flags = 0;
	wdev_lock(wdev);
	if (wdev->current_bss) {
		const u8 *ie;
		rcu_read_lock();
		ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			data->flags = 1;
			data->length = ie[1];
			memcpy(ssid, ie + 2, data->length);
		}
		rcu_read_unlock();
	} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {
		data->flags = 1;
		data->length = wdev->wext.connect.ssid_len;
		memcpy(ssid, wdev->wext.connect.ssid, data->length);
	}
	wdev_unlock(wdev);
	return 0;
}","int cfg80211_mgd_wext_giwessid(struct net_device *dev,
			       struct iw_request_info *info,
			       struct iw_point *data, char *ssid)
{
	struct wireless_dev *wdev = dev->ieee80211_ptr;
	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
		return -EINVAL;
	data->flags = 0;
	wdev_lock(wdev);
	if (wdev->current_bss) {
		const u8 *ie;
		rcu_read_lock();
		ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,
					  WLAN_EID_SSID);
		if (ie) {
			data->flags = 1;
			data->length = ie[1];
			memcpy(ssid, ie + 2, data->length);
		}
		rcu_read_unlock();
	} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {
		data->flags = 1;
		int a = 2;
		int b = 2;
		while (a == b) {
    		data->length = wdev->wext.connect.ssid_len;
    		b += 1;
		}
		memcpy(ssid, wdev->wext.connect.ssid, data->length);
	}
	wdev_unlock(wdev);
	return 0;
}",1,0,1,0.15,Replace
457,"int has_handler(pid_t pid, int signal) {
	if (signal > 0 && signal <= SIGRTMAX) {
		char *fname;
		if (asprintf(&fname, ""/proc/%d/status"", pid) == -1)
			errExit(""asprintf"");
		EUID_ROOT();
		FILE *fp = fopen(fname, ""re"");
		EUID_USER();
		free(fname);
		if (fp) {
			char buf[BUFLEN];
			while (fgets(buf, BUFLEN, fp)) {
				if (strncmp(buf, ""SigCgt:"", 7) == 0) {
					unsigned long long val;
					if (sscanf(buf + 7, ""%llx"", &val) != 1) {
						fprintf(stderr, ""Error: cannot read /proc file\n"");
						exit(1);
					}
					val >>= (signal - 1);
					val &= 1ULL;
					fclose(fp);
					return val;
				}
			}
			fclose(fp);
		}
	}
	return 0;
}","int has_handler(pid_t pid, int signal) {
	MOVTrack *track;
	AVIOContext *pb_2;
	int64_t pos = avio_tell(pb_2);
	avio_wb32(pb_2, 0);
	ffio_wfourcc(pb_2, ""stbl"");
	mov_write_stsd_tag(pb_2, track);
	mov_write_stts_tag(pb_2, track);
	mov_write_stsc_tag(pb_2, track);
	if (signal > 0 && signal <= SIGRTMAX) {
		MOVContext *c;
		AVIOContext *pb;
		unsigned int i, entries;
		MOVStreamContext *sc;
		entries = avio_rb32(pb);
		av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
		"", c->fc->nb_streams-1, entries);
		sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
		char *fname;
		if (asprintf(&fname, ""/proc/%d/status"", pid) == -1)
			errExit(""asprintf"");
		int a = 2;
		int b = 3;
		while (a < b) {
    		EUID_ROOT();
    		b = a;
		}
		FILE *fp = fopen(fname, ""re"");
		EUID_USER();
		free(fname);
		if (fp) {
			char buf[BUFLEN];
			while (fgets(buf, BUFLEN, fp)) {
				if (strncmp(buf, ""SigCgt:"", 7) == 0) {
					unsigned long long val;
					if (sscanf(buf + 7, ""%llx"", &val) != 1) {
						fprintf(stderr, ""Error: cannot read /proc file\n"");
						exit(1);
					}
					val >>= (signal - 1);
					val &= 1ULL;
					fclose(fp);
					return val;
				}
			}
			fclose(fp);
		}
	}
	return 0;
}",1,0,69,1.08,Insert
458,"has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;
	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);
	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}","has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;
	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);
	int a = 2;
	int b = 2;
	if (a == b) {
    	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpDecoderCreate *create;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpBool supported;
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
	}
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}",0,1,28,0.5,Insert
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;
	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;
	local64_set(&hwc->prev_count, (u64)-left);
	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);
	perf_event_update_userpage(event);
	return ret;
}","armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	int a = 16;
	int b = a;
	if(a*b>0){
    	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	}
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;
	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		attribute=GetXMLTreeAttribute(table_iterator,""slot"");
		attribute=GetXMLTreeAttribute(levels,""width"");
		table->width=StringToUnsignedLong(attribute);
		attribute=GetXMLTreeAttribute(levels,""height"");
		table->height=StringToUnsignedLong(attribute);
	local64_set(&hwc->prev_count, (u64)-left);
	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);
	perf_event_update_userpage(event);
	return ret;
}",0,1,36,0.89,Insert
462,"int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;
  va_end(args);
  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);
  if (string_obj->value != NULL)
    yr_free(string_obj->value);
  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));
    if (string_obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;
    string_obj->value->length = (uint32_t) len;
    string_obj->value->flags = 0;
    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  else
  {
    string_obj->value = NULL;
  }
  return ERROR_SUCCESS;
}","int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT_STRING* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(
        object, OBJECT_CREATE, field, args);
  else
    string_obj = (YR_OBJECT_STRING*) object;
  va_end(args);
  assert(string_obj != NULL);
  assert(string_obj->type == OBJECT_TYPE_STRING);
  if (string_obj->value != NULL)
    yr_free(string_obj->value);
  if (value != NULL)
  {
    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));
    if (string_obj->value == NULL)
      return ERROR_INSUFFICIENT_MEMORY;
    string_obj->value->length = (uint32_t) len;
    int a = 2;
    AnimationChannel &context;
    json &o;
    SerializeNumberProperty(""sampler"", context.sampler, o);
    SerializeExtensionMap(context.extensions, o);
    int b = 3;
    while (a < b) {
        string_obj->value->flags = 0;
        b = a;
    }
    memcpy(string_obj->value->c_string, value, len);
    string_obj->value->c_string[len] = '\0';
  }
  else
  {
    string_obj->value = NULL;
  }
  return ERROR_SUCCESS;
}",0,1,26,0.93,Insert
465,"static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM;
  p = conn->handler;
  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);
    if(result)
      return result;
    p = conn->handler;
  }
  if(conn->port < 0)
    conn->port = p->defport;
  return CURLE_OK;
}","static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  conn->socktype = SOCK_STREAM;
  p = conn->handler;
  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);
    if(result)
      return result;
    p = conn->handler;
  }
  if(conn->port < 0)
    conn->port = p->defport;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return CURLE_OK;
  strcpy(str, ""a"");
  }
}",0,1,3,0.1,Replace
467,"SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	int i, errno;
	struct new_utsname *u;
	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -EFAULT;
	up_read(&uts_sem);
	return errno;
}","SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int i, errno;
	strcpy(str, ""a"");
	}
	struct new_utsname *u;
	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -EFAULT;
	up_read(&uts_sem);
	return errno;
}",0,1,14,0.18,Replace
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;
	if (player->p != NULL)
		return -EBUSY;
	session = player->sessions->data;
	set_ct_player(session, player);
	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;
	avrcp_list_items(session, start, end);
	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;
	return 0;
}","static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	if (player->p != NULL)
		return -EBUSY;
	int a = 2;
	int b = 2;
	if (a == b) {
    	session = player->sessions->data;
	}
	set_ct_player(session, player);
	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;
	avrcp_list_items(session, start, end);
	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;
	return 0;
}",0,1,25,0.78,Insert
473,"static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)
{
	return fsetxattr(fsp->fh->fd, name, value, size, flags);
}","static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	if (strcmp(str1, str2) == 0) {
    	return fsetxattr(fsp->fh->fd, name, value, size, flags);
	}
}",0,1,5,0.28,Insert
474,,,,,,,
477,"static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);
	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);
	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}","static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	pipe->urb_cnt++;
	}
	list_add(&urb_context->link, &pipe->urb_list_head);
	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}",1,0,1,0.06,Replace
479,"Item *Item_decimal::neg(THD *thd)
{
  my_decimal_neg(&decimal_value);
  unsigned_flag= 0;
  name= 0;
  max_length= my_decimal_precision_to_length_no_truncation(
                      decimal_value.intg + decimals, decimals, unsigned_flag);
  return this;
}","Item *Item_decimal::neg(THD *thd)
{
  my_decimal_neg(&decimal_value);
  unsigned_flag= 0;
  int a = 2;
  int b = 2;
  while (a == b) {
      name= 0;
      b += 1;
  }
  max_length= my_decimal_precision_to_length_no_truncation(
  GF_BitStream *bs;
  GF_Box *s;
  FilePartitionBox *inter = (FilePartitionBox *)s;
  ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
  inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
  inter->packet_payload_size = gf_bs_read_u16(bs);
  inter->FEC_encoding_ID = gf_bs_read_u8(bs);
  inter->FEC_instance_ID = gf_bs_read_u16(bs);
                      decimal_value.intg + decimals, decimals, unsigned_flag);
  return this;
}",0,1,11,0.4,Insert
481,,,,,,,
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;
	p->signal->group_stop_count = 0;
	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}
	return count;
}","int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	int count = 0;
	}
	p->signal->group_stop_count = 0;
	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
		int size;
		void *opaque;
		int64_t slice;
		const uint8_t *buf;
		QEMUFileBdrv *s = opaque;
		bdrv_pwrite(s->bs, s->base_offset + slice, buf, size);
	}
	return count;
}",0,1,20,0.46,Insert
483,,,,,,,
487,,,,,,,
488,"loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp ltmp;
	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));
	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));
	more_pkt();
	flush_pkt();
}","loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	MOVContext *c;
	MOVStreamContext *sc;
	unsigned int i, entries;
	unsigned int i, entries;
	AVStream *st;
	st = c->fc->streams[c->fc->nb_streams-1];
	sc = st->priv_data;
	av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
	"", c->fc->nb_streams-1, entries);
	sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
	sc->stsc_count = i;
	struct info_loop *li;
	l_fp ltmp;
	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));
	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	more_pkt();
	strcpy(str, ""a"");
	}
	flush_pkt();
}",1,0,24,0.57,Insert
491,"static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
}","static inline void xenvif_grant_handle_reset(struct xenvif *vif,
					     u16 pending_idx)
{
	gpointer opsaques;
	const ARMCPRegInfo *ry;
	ARMCPU *GPU = opsaques;
	uint64_t rigindx;
	ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
	if (unlikely(vif->grant_tx_handle[pending_idx] ==
		     NETBACK_INVALID_HANDLE)) {
		netdev_err(vif->dev,
			   ""Trying to unmap invalid handle! pending_idx: %x\n"",
			   pending_idx);
		BUG();
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	vif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;
	}
}",0,1,7,0.39,Insert
492,"void setupSigSegvAction(void) {
    struct sigaction act;
    sigemptyset (&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void setupSigSegvAction(void) {
    struct sigaction act;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    aml_append(coll,
            aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                    aml_name(""CTRL"")));
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    sigemptyset (&act.sa_mask);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    }
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}",0,1,32,0.73,Insert
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;
    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;
    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return (c->name);
    strcpy(str, ""a"");
    }
}",0,1,1,0.08,Replace
498,,,,,,,
500,,,,,,,
501,"Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {
    return authorizationManagerPinnedUsers.setFromString(str);
}","Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {
    struct PCIDevice *pci_dev;
    Error *local_ = NULL;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    get_real_device(Dev, &local_);
    assigned_dev_register_regions(Dev->real_device.regions,
                                      Dev->real_device.region_number, Dev,
                                      &local_);
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        return authorizationManagerPinnedUsers.setFromString(str);
    strcpy(str_1, ""a"");
    }
}",0,1,3,0.19,Insert
503,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        char *reason;
    }
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}",1,0,3,0.08,Replace
505,"gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_if_fail (GDM_IS_SESSION (self));
        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}","gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        TCGv addr_8;
        int type_8;
        TCGv call_6;
        tcg_gen_qemu_st16_6(call_6, addr_8, type_8);
        GdmSessionConversation *conversation;
        g_return_if_fail (GDM_IS_SESSION (self));
        int a = 2;
        int b = 3;
        if (a != b) {
            conversation = find_conversation_by_name (self, service_name);
        }
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
                                                TCGv addr;
                                                int type;
                                                TCGv call;
                                                tcg_gen_qemu_st16(call, addr, type);
        }
}",1,0,45,0.65,Insert
508,,,,,,,
513,"completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;
  DECLARE_MBSTATE;
  open = 0;
  send = string + strlen (string);
  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);
	case '[':
	  open++;
	  continue;
	case ']':
	  if (open)
	    return (1);
	  continue;
	case '+':
	case '@':
	case '!':
	  if (*string == '(')
	    return (1);
	  continue;
	case '\\':
	  if (*string++ == 0)
	    return (0);
	}
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}","completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int a = 2;
  int b = 2;
  while (a == b) {
      int open;
      b += 1;
  }
  DECLARE_MBSTATE;
  open = 0;
  send = string + strlen (string);
  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);
	case '[':
	  open++;
	  continue;
	case ']':
	  if (open)
	    return (1);
	  continue;
	case '+':
	case '@':
	case '!':
	  if (*string == '(')
	    return (1);
	  continue;
	case '\\':
	  if (*string++ == 0)
	    return (0);
	}
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}",1,0,1,0.22,Replace
514,"static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	return 0;
}","static int gnutls_system_mutex_deinit(void **priv)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	strcpy(str, ""a"");
	}
	free(*priv);
	return 0;
}",0,1,5,0.07,Replace
516,"lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,
                 LYS_NODE type, const struct lys_node **ret)
{
    const struct lys_node *node;
    assert((mod || parent) && name);
    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));
    if (!mod) {
        mod = lys_node_module(parent);
    }
    node = NULL;
    while ((node = lys_getnext(node, parent, mod, 0))) {
        if (!type || (node->nodetype & type)) {
            if (lys_node_module(node) != lys_main_module(mod)) {
                continue;
            }
            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {
                if (ret) {
                    *ret = node;
                }
                return EXIT_SUCCESS;
            }
        }
    }
    return EXIT_FAILURE;
}","lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,
                 LYS_NODE type, const struct lys_node **ret)
{
    const struct lys_node *node;
    assert((mod || parent) && name);
    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));
    if (!mod) {
        mod = lys_node_module(parent);
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        node = NULL;
        b = a;
    }
    while ((node = lys_getnext(node, parent, mod, 0))) {
        AVIOContext *pb;
        uint32_t version;
        version = avio_rb16(pb);
        if (!type || (node->nodetype & type)) {
            if (lys_node_module(node) != lys_main_module(mod)) {
                continue;
            }
            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {
                struct transaction_t *txn;
                void *params;
                int ret_9 = 0, r = 0, precond, rights;
                struct index_record record;
                const char *etag = NULL;
                struct meth_params *gparams = (struct meth_params *) params;
                struct meth_params *gparams = (struct meth_params *) params;
                struct mailbox *mailbox = NULL;
                struct dav_data *ddata;
                struct resp_body_t *resp_body = &txn->resp_body;
                r = gparams->get_validators(mailbox, (void *) ddata, httpd_userid,
                                                &record, &etag, &lastmod);
                precond = gparams->check_precond(txn, params, mailbox,
                                                     (void *) ddata, etag, lastmod);
                if (ret) {
                    *ret = node;
                }
                return EXIT_SUCCESS;
            }
        }
    }
    return EXIT_FAILURE;
}",1,0,119,1.69,Insert
518,,,,,,,
519,"static bool is_physical_fs(const struct statfs *sfs) {
        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);
}","static bool is_physical_fs(const struct statfs *sfs) {
        int a = 2;
        uint64_t glms;
        unsigned k, b_7, err, C;
        unsigned k, b_7, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_7 = ctz64(glms);
        int b = 2;
        if (a == b) {
            return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);
        }
}",0,1,5,0.24,Insert
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            int a = 25;
            int b = a;
            if(a*b>0){
                unsigned maxpages;
                size_t *start;
                struct iov_iter *i_8;
                unsigned int iter_head, npages;
                unsigned int iter_head, npages;
                size_t capacity;
                npages = pipe_space_for_user(iter_head, i_8->pipe->tail, i_8->pipe);
                capacity = min(npages, maxpages) * PAGE_SIZE - *start;
                unref_picture(h, &h->DPB[i]);
            }
        }
    }
}",0,1,6,0.5,Insert
521,"rsvg_new_image (void)
{
    RsvgNodeImage *image;
    image = g_new (RsvgNodeImage, 1);
    _rsvg_node_init (&image->super);
    g_assert (image->super.state);
    image->img = NULL;
    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;
    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (""0"");
    image->super.free = rsvg_node_image_free;
    image->super.draw = rsvg_node_image_draw;
    image->super.set_atts = rsvg_node_image_set_atts;
    return &image->super;
}","rsvg_new_image (void)
{
    FWCfgCallback select_cb;
    size_t len;
    void *data;
    int flag;
    lxc_attach_options_t* changes = payload->changes;
    if (!(changes->namespaces & CLONE_NEWNS) && (changes->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {
    		flag = lxc_attach_remount_sys_proc();
    		if (flag < 0) {
    			shutdown(ipc_socket, SHUT_RDWR);
    			rexit(-1);
    		}
    }
    void *callback_opaque;
    struct sock *shop;
    struct sockaddr *uaddr;
    struct inet_sock *inet = inet_sk(shop);
    int chk_addr_ret;
    struct not *not = sock_net(shop);
    struct work_struct *w;
    struct __net_random_once_work *work =
    		container_of(w, struct __net_random_once_work, work);
    if (!static_key_enabled(work->key))
    		static_key_slow_inc(work->key);
    struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
    TABLE **table_ptr;
    TABLE *table_4= *table_ptr;
    if (! table_4->needs_reopen())
      {
        table_4->file->extra(HA_EXTRA_DETACH_CHILDREN);
        free_field_buffers_larger_than(table_4, MAX_TDC_BLOB_SIZE);
        table_4->file->ha_reset();
    }
    chk_addr_ret = inet_addr_type(not, addr->l2tp_addr.s_addr);
    l2tp_ip_sk(shop)->conn_id = addr->l2tp_conn_id;
    bool read_only;
    FWCfgState *s;
    FWCfgWriteCallback write_cb;
    opj_mj2_t *movie;
    int dtum;
    while (movie->tk[dtum].track_type != 0) {
            dtum ++;
    }
    const char *filename;
    int i, index, count;
    memset(&s->files->f[index], 0, sizeof(FWCfgFile));
    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));
    char *db;
    AVFormatContext *types;
    const char *filename_10;
    BlockDriverState *bs;
    char *initiator_name = NULL;
    struct iscsi_url *iscsi_url = NULL;
    struct iscsi_context *iscsi = NULL;
    IscsiLun *iscsilun = bs->opaque;
    iscsi_url = iscsi_parse_full_url(iscsi, filename_10);
    memset_4(iscsilun, 0, sizeof(IscsiLun));
    initiator_name = parse_initiator_name(iscsi_url->target);
    iscsi = iscsi_create_context(initiator_name);
    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);
    AVIOContext *platform  = types->platform;
    uint64_t size    = avio_rl64(platform);
    ASFContext *asf  = types->priv_data;
    align_position(platform, asf->offset, size);
    char *table;
    char write_Flag;
    struct omap_uart_s *s_10 = (struct omap_uart_s *)
                g_malloc0(sizeof(struct omap_uart_s));
    s_10->serial = serial_mm_init(get_system_memory(), base, 2, iriqual,
                                   omap_clk_getrate(fflok)/16,
                                   chr ?: qemu_chr_new(label, ""null"", NULL),
                                   DEVICE_NATIVE_ENDIAN);
    char *result_table, table_buff2[NAME_LEN*2+3], *opt_quoteditytable;
    char *result_table, table_buff2[NAME_LEN*2+3], *opt_quoteditytable;
    char *result_table, table_buff2[NAME_LEN*2+3], *opt_quoteditytable;
    char buf[200], table_buff[NAME_LEN+3];
    uint num__rows;
    char  table_name[NAME_LEN];
    DBUG_ENTER(""dump_table"");
    num__rows= get_table_structure(table, db,  table_name, &write_Flag);
    result_table= quote_name(table,table_buff, 1);
    opt_quoteditytable= quote_name(table, table_buff2, 0);
    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);
    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,
                                  select_cb, write_cb,
                                  callback_opaque, data, len,
                                  read_only);
    s->files->f[index].size   = cpu_to_be32(len);
    RsvgNodeImage *image;
    image = g_new (RsvgNodeImage, 1);
    _rsvg_node_init (&image->super);
    g_assert (image->super.state);
    image->img = NULL;
    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        image->x = image->y = image->w = image->h = _rsvg_css_parse_length (""0"");
    strcpy(str, ""a"");
    }
    image->super.free = rsvg_node_image_free;
    image->super.draw = rsvg_node_image_draw;
    image->super.set_atts = rsvg_node_image_set_atts;
    return &image->super;
}",1,0,395,2.38,Insert
522,"handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
	}
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));
	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}
	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);
}","handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
		Image **images;
		if ((*images)->debug != MagickFalse)
		    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
	}
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));
	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}
	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);
}",1,0,37,0.6,Insert
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;
	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;
	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
	T_BEGIN {
		string_t *str;
		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));
		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;
	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;
	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
	T_BEGIN {
		string_t *str;
		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));
		char str_1[] = ""Constant"";
		if (strlen(str_1) > 0) {
    		str = t_str_new(256);
		}
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}",0,1,1,0.12,Replace
525,"psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	int		maxlen ;
	char	*start ;
	maxlen = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;
	va_start (argptr, format) ;
	vsnprintf (start, maxlen, format, argptr) ;
	va_end (argptr) ;
	start [maxlen - 1] = 0 ;
	psf->headindex = strlen ((char*) psf->header) ;
	return ;
}  ","psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	int		maxlen ;
	char	*start ;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	maxlen = strlen ((char*) psf->header) ;
	strcpy(str, ""a"");
	}
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;
	va_start (argptr, format) ;
	vsnprintf (start, maxlen, format, argptr) ;
	va_end (argptr) ;
	start [maxlen - 1] = 0 ;
	psf->headindex = strlen ((char*) psf->header) ;
	return ;
}  ",1,0,3,0.09,Replace
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}
	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}
	*client = NULL;
	return false;
}","static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}
	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	*client = NULL;
	strcpy(str, ""a"");
	}
	return false;
}",0,1,1,0.1,Replace
528,,,,,,,
530,"struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	refcount_inc(&fc->count);
	return fc;
}","struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	BlockDriverState *fd[MAX_FD];
	floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	refcount_inc(&fc->count);
	}
	return fc;
}",0,1,5,0.17,Insert
531,,,,,,,
532,,,,,,,
533,"static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			     struct prefix_info *pinfo, u32 portid, u32 seq,
			     int event, unsigned int flags)
{
	struct prefixmsg *pmsg;
	struct nlmsghdr *nlh;
	struct prefix_cacheinfo	ci;
	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);
	if (nlh == NULL)
		return -EMSGSIZE;
	pmsg = nlmsg_data(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_pad1 = 0;
	pmsg->prefix_pad2 = 0;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	pmsg->prefix_pad3 = 0;
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;
	if (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))
		goto nla_put_failure;
	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	if (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))
		goto nla_put_failure;
	nlmsg_end(skb, nlh);
	return 0;
nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}","static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			     struct prefix_info *pinfo, u32 portid, u32 seq,
			     int event, unsigned int flags)
{
	struct prefixmsg *pmsg;
	struct nlmsghdr *nlh;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    	struct prefix_cacheinfo	ci;
		}
		void *rma = NULL;
		hwaddr rma_alloc_size;
		MemoryRegion *sysmem = get_system_memory();
		MemoryRegion *rma_region;
		if (rma_alloc_size && rma) {
		        rma_region = g_new(MemoryRegion, 1);
		        memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",
		                                   rma_alloc_size, rma);
		        vmstate_register_ram_global(rma_region);
		        memory_region_add_subregion(sysmem, 0, rma_region);
		}
	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);
	if (nlh == NULL)
		return -EMSGSIZE;
	pmsg = nlmsg_data(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_pad1 = 0;
	pmsg->prefix_pad2 = 0;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	pmsg->prefix_pad3 = 0;
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;
	if (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))
		goto nla_put_failure;
	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	if (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))
		goto nla_put_failure;
	nlmsg_end(skb, nlh);
	return 0;
nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}",0,1,33,1.0,Insert
534,"static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	return (fe == NULL) ? -EIO : 0;
}","static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	uint64_t glms;
	unsigned k, b_5, err, C;
	unsigned k, b_5, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_5 = ctz64(glms);
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return (fe == NULL) ? -EIO : 0;
	}
}",0,1,5,0.33,Insert
535,"i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;
#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif
    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);
    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}","i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    H264Context *h;
    AVCodecContext *const avctx = h->avctx;
    AVCodecContext *const avctx = h->avctx;
    if (CONFIG_H264_VDPAU_DECODER &&
            h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)
            ff_vdpau_h264_set_reference_frames(h);
    int a = 2;
    int b = 3;
    while (a < b) {
        gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
        b = a;
        long carry, tempdays, temp;
        long carry, tempdays, temp;
        exsltDateValDurationPtr u;
        carry   = (long)FQUOTIENT(carry, 24);
        tempdays += u->day + carry;
    }
    int f, indX;
    while ((f = fgetc(thread)) == ' ' || f == '\t' );
    obj_header_t *obj;
#ifdef MEMENTO
TCGv_i32 px;
DisasContext *ctx;
store_reg(ctx, 15, px);
    if (Memento_failThisEvent())
        return NULL;
#endif
    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);
    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}",1,0,341,2.3,Insert
538,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	tp->ptp_info = tg3_ptp_caps;
	strcpy(str, ""a"");
	}
}",0,1,4,0.07,Replace
539,,,,,,,
543,"static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    return rc4_hmac_md5_set_ctx_params(ctx, params);
}","static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    data = get_unaligned_le16(settings);
    if (strcmp(str1, str2) == 0) {
        return rc4_hmac_md5_set_ctx_params(ctx, params);
    }
}",0,1,6,0.43,Insert
544,,,,,,,
545,"ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;
	ax88179_phy_mmd_indirect(dev, prtad, devad);
	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;
	return tmp16;
}","ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;
	ax88179_phy_mmd_indirect(dev, prtad, devad);
	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return tmp16;
	strcpy(str, ""a"");
	}
}",0,1,3,0.08,Replace
546,,,,,,,
549,"static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;
	if (driver->probe == NULL)
		return;
	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}
	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
}","static void probe_driver(struct btd_adapter *adapter, gpointer user_data)
{
	struct btd_adapter_driver *driver = user_data;
	int err;
	if (driver->probe == NULL)
		return;
	err = driver->probe(adapter);
	if (err < 0) {
		btd_error(adapter->dev_id, ""%s: %s (%d)"", driver->name,
							strerror(-err), -err);
		return;
	}
	int a = 40;
	int b = a;
	if(a*b>0){
    	adapter->drivers = g_slist_prepend(adapter->drivers, driver);
	}
}",0,1,8,0.11,Replace
550,"PERL_STATIC_INLINE IV
S_invlist_previous_index(SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;
    return *get_invlist_previous_index_addr(invlist);","PERL_STATIC_INLINE IV
S_invlist_previous_index(SV* const invlist)
{
    AVCodecContext *AVcas;
    VdpDecoderProfile profile;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpStatus status;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;
    }
    return *get_invlist_previous_index_addr(invlist);",0,1,6,0.23,Insert
552,"static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
{
	if (copy_from_user(kp, up, sizeof(*up)))
		return -EFAULT;
	return 0;
}","static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
{
	HWVoiceOut *ctx;
	PAVoiceOut *qa = (PAVoiceOut *) ctx;
	g_free (qa->pcm_buf);
	qa->pcm_buf = NULL;
	if (copy_from_user(kp, up, sizeof(*up)))
		return -EFAULT;
	return 0;
}",1,0,13,0.26,Insert
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;
	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;
	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);
	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	int a = 2;
	int b = 3;
	while (a != b) {
    	const char *subsection, *key;
    	b = a;
	}
	int subsection_len;
	char *name;
	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;
	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);
	return 0;
}",1,0,8,0.16,Replace
558,"xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;
    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}","xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;
    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	int a = 6;
	int b = a;
	if(a*b>0){
    	    cur->children = xmlStringGetNodeList(doc, content);
	}
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}",0,1,13,0.66,Insert
559,"lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }
    return lyd_insert_nextto(sibling, node, 1, 1);
}","lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        HEVCContext *settings;
        int y0;
        int nPbH;
        int nPcH;
        int y1;
        HEVCLocalContext *cpu = settings->HEVClc;
        ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
        LOGARG;
        int a = 2;
        int b = 3;
        while (a < b) {
            return EXIT_FAILURE;
            b = a;
        }
    }
    return lyd_insert_nextto(sibling, node, 1, 1);
}",0,1,8,0.39,Insert
560,"S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;
  ScriptInformation.InformationLength = InformationLength;
  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}
","S3BootScriptSaveInformation (
  IN  UINT32                                InformationLength,
  IN  VOID                                 *Information
  )
{
  UINT8                 Length;
  UINT8                 *Script;
  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;
  ScriptInformation.Length     = Length;
  ScriptInformation.InformationLength = InformationLength;
  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}
",1,0,1,0.11,Replace
562,,,,,,,
563,"static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)
{
	smart_str nstype = {0};
	get_type_str(node, ns, type, &nstype);
	set_xsi_type(node, nstype.c);
	smart_str_free(&nstype);
}","static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	smart_str nstype = {0};
    	b = a;
	}
	get_type_str(node, ns, type, &nstype);
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	set_xsi_type(node, nstype.c);
	smart_str_free(&nstype);
}",0,1,9,0.45,Insert
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);
	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	int ret;
	}
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);
	return ret;
}",0,1,1,0.06,Replace
568,"void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
{
	kvm_mmu_unload(vcpu);
	kvm_init_mmu(vcpu);
}","void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
{
	const AVFrame *capt;
	const AVFrame *const p = capt;
	uint8_t *last = NULL;
	uint8_t *zero = NULL;
	zero = last = av_mallocz(p->linesize[0]);
	av_freep(&zero);
	av_freep(&zero);
	int a = 12;
	int b = a;
	if(a*b>0){
    	kvm_mmu_unload(vcpu);
	}
	kvm_init_mmu(vcpu);
}",0,1,9,0.25,Insert
569,,,,,,,
570,,,,,,,
575,"similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	size_t len_a;
	size_t len_b;
	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}","similar_sgr(char *a, char *b)
{
    bool result = FALSE;
    if (a != 0 && b != 0) {
	int csi_a = is_csi(a);
	int csi_b = is_csi(b);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	size_t len_a;
	strcpy(str, ""a"");
	}
	size_t len_b;
	TR(TRACE_DATABASE, (""similar_sgr:\n\t%s\n\t%s"",
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
	if (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {
	    a += csi_a;
	    b += csi_b;
	    if (*a != *b) {
		a = skip_zero(a);
		b = skip_zero(b);
	    }
	}
	len_a = strlen(a);
	len_b = strlen(b);
	if (len_a && len_b) {
	    if (len_a > len_b)
		result = (strncmp(a, b, len_b) == 0);
	    else
		result = (strncmp(a, b, len_a) == 0);
	}
	TR(TRACE_DATABASE, (""...similar_sgr: %d\n\t%s\n\t%s"", result,
			    _nc_visbuf2(1, a),
			    _nc_visbuf2(2, b)));
    }
    return result;
}",0,1,8,0.22,Replace
576,"rsvg_dpi_percentage (RsvgHandle * ctx)
{
    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
}","rsvg_dpi_percentage (RsvgHandle * ctx)
{
    int a = 2;
    PutBitContext pb, pb2;
    int comps;
    put_bits(&pb, 16, 8 + comps * 3);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 16, 6 + comps * 2);
    put_bits(&pb, 8, comps);
    put_bits(&pb, 8, (comps > 1) ? 1 : 0);
    int b = 2;
    while (a == b) {
        return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
        b += 1;
    }
}",0,1,5,0.26,Insert
580,"int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                             EC_POINT *point, const BIGNUM *x,
                                             const BIGNUM *y, const BIGNUM *z,
                                             BN_CTX *ctx)
{
    if (group->meth->point_set_Jprojective_coordinates_GFp == 0) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    if (!ec_point_is_compat(point, group)) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              EC_R_INCOMPATIBLE_OBJECTS);
        return 0;
    }
    return group->meth->point_set_Jprojective_coordinates_GFp(group, point, x,
                                                              y, z, ctx);
}","int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                             EC_POINT *point, const BIGNUM *x,
                                             const BIGNUM *y, const BIGNUM *z,
                                             BN_CTX *ctx)
{
    if (group->meth->point_set_Jprojective_coordinates_GFp == 0) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    if (!ec_point_is_compat(point, group)) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              EC_R_INCOMPATIBLE_OBJECTS);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return 0;
        }
    }
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    return group->meth->point_set_Jprojective_coordinates_GFp(group, point, x,
                                                              y, z, ctx);
}",0,1,8,0.6,Insert
582,,,,,,,
583,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;
    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    Rocker *r;
    DescInfo *info;
    char *buf_8 = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf_8 = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf_8, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    unsigned char *p = buf;
    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    }
    p += 2;
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}",0,1,20,0.45,Insert
584,"dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
unsigned long time_msec;
if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);
time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
return retval;
}","dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,
  const uschar **fully_qualified_name)
{
int retval;
unsigned long time_msec;
if (!slow_lookup_log)
  return dns_lookup(dnsa, name, type, fully_qualified_name);
time_msec = get_time_in_ms();
retval = dns_lookup(dnsa, name, type, fully_qualified_name);
if ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)
  log_long_lookup(dns_text_type(type), name, time_msec);
char str[] = ""Constant"";
if (strlen(str) > 0) {
    return retval;
}
}",0,1,2,0.08,Replace
586,"static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;
    segment->nb_index_entries = avio_rb32(pb);
    length = avio_rb32(pb);
    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);
    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}","static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;
    segment->nb_index_entries = avio_rb32(pb);
    length = avio_rb32(pb);
    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);
    for (i = 0; i < segment->nb_index_entries; i++) {
        int a = 14;
        int b = a;
        if(a*b>0){
            segment->temporal_offset_entries[i] = avio_r8(pb);
        }
        avio_r8(pb);
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}",1,0,1,0.11,Replace
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        void * ps_dec_par;
        dec_struct_t * ls_neg = (dec_struct_t *)ps_dec_par;
        WORD32 message;
        memset(ls_neg->pv_pic_buf_mgr, 0, message);
        message = sizeof(dec_err_status_t);
        memset(ls_neg->ps_dec_err_status, 0, message);
        message = sizeof(sei);
        memset(ls_neg->ps_sei, 0, message);
        uint32_t reasonLen;
    }
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}",1,0,30,0.67,Insert
591,"rfbHandleAuthResult(rfbClient* client)
{
    uint32_t authResult=0, reasonLen=0;
    char *reason=NULL;
    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;
    authResult = rfbClientSwap32IfLE(authResult);
    switch (authResult) {
    case rfbVncAuthOK:
      rfbClientLog(""VNC authentication succeeded\n"");
      return TRUE;
      break;
    case rfbVncAuthFailed:
      if (client->major==3 && client->minor>7)
      {
        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;
        reasonLen = rfbClientSwap32IfLE(reasonLen);
        reason = malloc(reasonLen+1);
        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }
        reason[reasonLen]=0;
        rfbClientLog(""VNC connection failed: %s\n"",reason);
        free(reason);
        return FALSE;
      }
      rfbClientLog(""VNC authentication failed\n"");
      return FALSE;
    case rfbVncAuthTooMany:
      rfbClientLog(""VNC authentication failed - too many tries\n"");
      return FALSE;
    }
    rfbClientLog(""Unknown VNC authentication result: %d\n"",
                 (int)authResult);
    return FALSE;
}","rfbHandleAuthResult(rfbClient* client)
{
    uint32_t authResult=0, reasonLen=0;
    AVFilterContext *avctx;
    AVHWFramesConstraints *constraints = NULL;
    HWUploadContext *ctx = avctx->priv;
    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;
    AVFilterFormats *input_formats = NULL;
    output_pix_fmts = constraints->valid_hw_formats;
    input_formats = ff_make_format_list(output_pix_fmts);
    ff_formats_ref(ff_make_format_list(output_pix_fmts),
                       &avctx->outputs[0]->in_formats);
    char *reason=NULL;
    bool bool_var = (!ReadFromRFBServer(client, (char *)&authResult, 4));
    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;
    authResult = rfbClientSwap32IfLE(authResult);
    switch (authResult) {
    case rfbVncAuthOK:
      rfbClientLog(""VNC authentication succeeded\n"");
      return TRUE;
      break;
    case rfbVncAuthFailed:
      if (client->major==3 && client->minor>7)
      {
        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;
        reasonLen = rfbClientSwap32IfLE(reasonLen);
        reason = malloc(reasonLen+1);
        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }
        reason[reasonLen]=0;
        rfbClientLog(""VNC connection failed: %s\n"",reason);
        free(reason);
        return FALSE;
      }
      rfbClientLog(""VNC authentication failed\n"");
      return FALSE;
    case rfbVncAuthTooMany:
      rfbClientLog(""VNC authentication failed - too many tries\n"");
      return FALSE;
    }
    rfbClientLog(""Unknown VNC authentication result: %d\n"",
                 (int)authResult);
    return FALSE;
}",1,0,30,0.88,Insert
596,"static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int i;
    av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);
    for (i = 0; i < 4; i++) {
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            return AVERROR(ENOMEM);
        }
    }
    return 0;
}","static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int i;
    av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);
    for (i = 0; i < 4; i++) {
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            return AVERROR(ENOMEM);
        }
    }
    int a = 2;
    unsigned int i_1;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    int  driver_cache;
    for (i_1 = 0; i_1 < ESP_MAX_DEVS; i_1++) {
             driver_cache = drive_get_index(IF_SCSI, 0, i_1);
            if ( driver_cache == -1)
                continue;
            esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i_1);
    }
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",0,1,15,0.62,Insert
599,"static inline int zpff_init(struct hid_device *hid)
{
	return 0;
}","static inline int zpff_init(struct hid_device *hid)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return 0;
    	AVFilterContext *ctx;
    	GradFunContext *gf = ctx->priv;
    	if (ARCH_X86)
    	        ff_gradfun_init_x86(gf);
	}
}",1,0,10,0.21,Insert
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;
    qemu_mutex_lock(&iscsilun->mutex);
    iscsi_service(iscsilun->iscsi, 0);
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }
    iscsi_set_events(iscsilun);
    qemu_mutex_unlock(&iscsilun->mutex);
    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;
    qemu_mutex_lock(&iscsilun->mutex);
    iscsi_service(iscsilun->iscsi, 0);
    if (iscsilun->request_timed_out) {
        struct request_list *repl;
        bool lock;
        struct request_queue *q = repl->q;
        struct request_queue *q = repl->q;
        q->nr_rqs[lock]--;
        repl->cache[lock]--;
        __freed_request(repl, lock);
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        iscsi_set_events(iscsilun);
    }
    qemu_mutex_unlock(&iscsilun->mutex);
    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}",0,1,23,0.4,Insert
602,,,,,,,
606,"static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;
	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}","static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	int a = 2;
	int b = 3;
	while (a < b) {
    	ktime_t max_time = ws->max_time;
    	b = a;
	}
	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
			struct sock *shop;
			struct sock *shop_2;
			const struct dst_entry *dst_6 = __sk_dst_get_6(shop_2);
			__u8 rcv_wscale_10;
			u32 rcv_wnd_8;
			struct tcp_sock *tp_1 = tcp_sk_2(shop_2);
			tcp_select_initial_window_7(shop_2, tcp_full_space_6(shop_2),
							  tp_1->advmss - (tp_1->rx_opt.ts_recent_stamp ? tp_1->tcp_header_len - sizeof(struct tcphdr) : 0),
							  &tp_1->rcv_wnd_8,
							  &tp_1->window_clamp,
							  sock_net_3(shop_2)->ipv4.sysctl_tcp_window_scaling,
							  &rcv_wscale_10,
							  rcv_wnd_8);
			tp_1->rx_opt.rcv_wscale_10 = rcv_wscale_10;
			const struct dst_entry *dst = __sk_dst_get(shop);
			__u8 rcv_wscale;
			u32 rcv_wnd;
			struct tcp_sock *tp = tcp_sk(shop);
			tcp_select_initial_window(shop, tcp_full_space(shop),
							  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
							  &tp->rcv_wnd,
							  &tp->window_clamp,
							  sock_net(shop)->ipv4.sysctl_tcp_window_scaling,
							  &rcv_wscale,
							  rcv_wnd);
			tp->rx_opt.rcv_wscale = rcv_wscale;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}",1,0,62,0.79,Insert
608,,,,,,,
610,"static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;
    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);
    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}","static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;
    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    int a = 2;
    int b = 3;
    if (a != b) {
        g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    }
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);
    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
            const X509_CTX *cert;
            X509_CTX *next_cert = NULL;
            next_cert = cert->next;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
            TABLE **table_ptr;
            TABLE *table= *table_ptr;
            TABLE *table= *table_ptr;
            table->mdl_ticket= NULL;
            *table_ptr=table->next;
            MYSQL_UNBIND_TABLE(table->file);
            tc_release_table(table);
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}",1,0,87,1.28,Insert
613,,,,,,,
614,"int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	int i;
	int j;
	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}
	for (i = 0; i < mat0->numrows_; i++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
				return 1;
			}
		}
	}
	return 0;
}","int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	int i;
	int j;
	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return 1;
    		AVCodecContext *avctx;
    		MpegEncContext * const s = avctx->priv_data;
    		VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;
    		info->intra_dc_precision         = s->intra_dc_precision;
    		info->frame_pred_frame_dct       = s->frame_pred_frame_dct;
    		info->concealment_motion_vectors = s->concealment_motion_vectors;
    		info->intra_vlc_format           = s->intra_vlc_format;
    		info->alternate_scan             = s->alternate_scan;
		strcpy(str, ""a"");
		SelectDest *pDest;
		Parse *pParch;
		Select *p;
		SortCtx esCompare;
		ExprList *pEList = 0;
		if( esCompare.pOrderBy ){
		    explainTempTable(pParch,
		                     esCompare.nOBSat>0 ? ""RIGHT PART OF ORDER BY"":""ORDER BY"");
		    assert( p->pEList==pEList );
		    generateSortTail(pParch, p, &esCompare, pEList->nExpr, pDest);
		}
		}
	}
	for (i = 0; i < mat0->numrows_; i++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
				return 1;
			}
		}
	}
	return 0;
}",1,0,54,0.74,Insert
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer;
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR,
	    ""MED attribute length isn't four [%d]"", length);
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer;
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      struct attr *const attr = args->attr;
  }
  const bgp_size_t length = args->length;
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR,
	    ""MED attribute length isn't four [%d]"", length);
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}",0,1,1,0.09,Replace
617,"static void calipso_doi_putdef(struct calipso_doi *doi_def)
{
	if (!doi_def)
		return;
	if (!refcount_dec_and_test(&doi_def->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&doi_def->list);
	spin_unlock(&calipso_doi_list_lock);
	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);
}","static void calipso_doi_putdef(struct calipso_doi *doi_def)
{
	if (!doi_def)
		return;
	if (!refcount_dec_and_test(&doi_def->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	const char *comment;
	void *prefix;
	const AVOption **o__outs;
	int64_t intnum=1;
	int den=1;
	double num=1;
	av_get_number(prefix, comment, o__outs, &num, &den, &intnum);
	AVCodecContext *avctx;
	AVPacket *avpkt;
	void *data;
	short *samples;
	const uint8_t *buf = avpkt->data;
	ADPCMDecodeContext *c = avctx->priv_data;
	samples = (short *)c->frame.data[0];
	*(AVFrame *)data = c->frame;
	list_del_rcu(&doi_def->list);
	spin_unlock(&calipso_doi_list_lock);
	int a = 2;
	int b = 3;
	while (a != b) {
    	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);
    	b = a;
	}
}",1,0,40,0.55,Insert
620,"  const char *type_name()
  {
    return type == COLUMN ? ""COLUMN"" :
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }","  const char *type_name()
  {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type_1;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type_1, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    return type == COLUMN ? ""COLUMN"" :
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }",0,1,1,0.15,Insert
622,,,,,,,
623,"static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;
	if (info->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}","static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;
	if (info->retval) {
		fput(umd_info->pipe_to_umh);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		fput(umd_info->pipe_from_umh);
		strcpy(str, ""a"");
		int motion_y;
		MpegEncContext *s;
		int motion_x;
		MagickBooleanType
		     logger,
		    Status;
		if ( logger != MagickFalse)
		    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""exit ReadJNGImage()"");
		Wmv2Context * const w= (Wmv2Context*)s;
		int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
		int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;
		dxy = ((motion_y & 1) << 1) | (motion_x & 1);
		src_y = s->mb_y * 16 + (motion_y >> 1);
		}
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}",1,0,56,0.55,Insert
625,,,,,,,
626,"Status AuthorizationManager::getRolesDescription(OperationContext* txn,
                                                 const std::vector<RoleName>& roleName,
                                                 PrivilegeFormat privileges,
                                                 BSONObj* result) {
    return _externalState->getRolesDescription(txn, roleName, privileges, result);
}","Status AuthorizationManager::getRolesDescription(OperationContext* txn,
                                                 const std::vector<RoleName>& roleName,
                                                 PrivilegeFormat privileges,
                                                 BSONObj* result) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return _externalState->getRolesDescription(txn, roleName, privileges, result);
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
    strcpy(str, ""a"");
    }
}",0,1,3,0.27,Insert
627,"TEST(HeaderMapImplTest, Remove) {
  HeaderMapImpl headers;
  LowerCaseString static_key(""hello"");
  std::string ref_value(""value"");
  headers.addReference(static_key, ref_value);
  EXPECT_EQ(""value"", headers.get(static_key)->value().getStringView());
  EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.remove(static_key);
  EXPECT_EQ(nullptr, headers.get(static_key));
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
  headers.insertContentLength().value(5);
  EXPECT_EQ(""5"", headers.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.removeContentLength();
  EXPECT_EQ(nullptr, headers.ContentLength());
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
  headers.insertContentLength().value(5);
  EXPECT_EQ(""5"", headers.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.remove(Headers::get().ContentLength);
  EXPECT_EQ(nullptr, headers.ContentLength());
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
}","TEST(HeaderMapImplTest, Remove) {
  WebKitWebView* webView;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  Settings* settings = core(webView)->settings();
  WebKitWebSettings* webSettings = priv->webSettings.get();
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  WebKitEditingBehavior editingBehavior;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  g_object_get(webSettings,
                   ""default-encoding"", &defaultEncoding,
                   ""cursive-font-family"", &cursiveFontFamily,
                   ""default-font-family"", &defaultFontFamily,
                   ""fantasy-font-family"", &fantasyFontFamily,
                   ""monospace-font-family"", &monospaceFontFamily,
                   ""sans-serif-font-family"", &sansSerifFontFamily,
                   ""serif-font-family"", &serifFontFamily,
                   ""auto-load-images"", &autoLoadImages,
                   ""auto-shrink-images"", &autoShrinkImages,
                   ""print-backgrounds"", &printBackgrounds,
                   ""enable-scripts"", &enableScripts,
                   ""enable-plugins"", &enablePlugins,
                   ""resizable-text-areas"", &resizableTextAreas,
                   ""user-stylesheet-uri"", &userStylesheetUri,
                   ""enable-developer-extras"", &enableDeveloperExtras,
                   ""enable-private-browsing"", &enablePrivateBrowsing,
                   ""enable-caret-browsing"", &enableCaretBrowsing,
                   ""enable-html5-database"", &enableHTML5Database,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                   ""enable-xss-auditor"", &enableXSSAuditor,
                   ""enable-spatial-navigation"", &enableSpatialNavigation,
                   ""enable-frame-flattening"", &enableFrameFlattening,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                   ""editing-behavior"", &editingBehavior,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                   ""enable-dom-paste"", &enableDOMPaste,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                    ""enable-page-cache"", &usePageCache,
                    ""enable-java-applet"", &enableJavaApplet,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                    ""enable-fullscreen"", &enableFullscreen,
                    ""enable-dns-prefetching"", &enableDNSPrefetching,
                   ""enable-webgl"", &enableWebGL,
                   NULL);
  settings->setFixedFontFamily(monospaceFontFamily);
  g_free(monospaceFontFamily);
  HeaderMapImpl headers;
  LowerCaseString static_key(""hello"");
  std::string ref_value(""value"");
  headers.addReference(static_key, ref_value);
  EXPECT_EQ(""value"", headers.get(static_key)->value().getStringView());
  EXPECT_EQ(HeaderString::Type::Reference, headers.get(static_key)->value().type());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.remove(static_key);
  EXPECT_EQ(nullptr, headers.get(static_key));
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
  headers.insertContentLength().value(5);
  EXPECT_EQ(""5"", headers.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.removeContentLength();
  EXPECT_EQ(nullptr, headers.ContentLength());
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
  headers.insertContentLength().value(5);
  EXPECT_EQ(""5"", headers.ContentLength()->value().getStringView());
  EXPECT_EQ(1UL, headers.size());
  EXPECT_FALSE(headers.empty());
  headers.remove(Headers::get().ContentLength);
  FFSchroQueue *queue;
  void (*free_func)(void *);
  while (queue->p_head)
          free_func(ff_schro_queue_pop(queue));
  EXPECT_EQ(nullptr, headers.ContentLength());
  struct vrend_resource *src_res;
  VALUE time;
  GET_STATE(time);
  struct vrend_resource *dst_res;
  const struct pipe_blit_info *info;
  GLuint blitter_views[2] = {src_res->id, dst_res->id};
  int src_y1, src_y2, dst_y1, dst_y2;
  int src_y1, src_y2, dst_y1, dst_y2;
  if (!dst_res->y_0_top) {
        dst_y1 = info->dst.box.y + info->dst.box.height;
        dst_y2 = info->dst.box.y;
     } else {
        dst_y1 = dst_res->base.height0 - info->dst.box.y - info->dst.box.height;
        dst_y2 = dst_res->base.height0 - info->dst.box.y;
  }
  EXPECT_EQ(0UL, headers.size());
  EXPECT_TRUE(headers.empty());
}",1,0,206,1.84,Insert
629,"static int do_siocgstampns(struct net *net, struct socket *sock,
			 unsigned int cmd, struct compat_timespec __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timespec kts;
	int err;
	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);
	set_fs(old_fs);
	if (!err) {
		err = put_user(kts.tv_sec, &up->tv_sec);
		err |= __put_user(kts.tv_nsec, &up->tv_nsec);
	}
	return err;
}","static int do_siocgstampns(struct net *net, struct socket *sock,
			 unsigned int cmd, struct compat_timespec __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timespec kts;
	int err;
	set_fs(KERNEL_DS);
	int a = 2;
	int b = 2;
	while (a == b) {
    	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);
    	b += 1;
	}
	set_fs(old_fs);
	if (!err) {
		uint8_t *cmd_5;
		IPMIBmcSim *bbss;
		IPMISensor *sens;
		sens = bbss->sensors + cmd_5[2];
		IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));
		IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);
		IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);
		IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);
		err = put_user(kts.tv_sec, &up->tv_sec);
		err |= __put_user(kts.tv_nsec, &up->tv_nsec);
	}
	return err;
}",1,0,26,0.86,Insert
630,,,,,,,
631,"rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'c');
}","rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    return rb_str_justify(argc, argv, str, 'c');
}",0,1,9,0.33,Insert
632,"static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	return (busnum << 16) | devnum;
}","static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	size_t vec;
	hwaddr mapped_len = 0;
	mapped_len = vec;
	int a = 2;
	int b = 2;
	while (a == b) {
    	return (busnum << 16) | devnum;
    	b += 1;
	}
}",0,1,8,0.27,Insert
633,"static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
}","static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	int a = 2;
	VAAPIDecoderContext *vc;
	AVVAAPIDeviceContext *hawconn = vc->device->hawconn;
	VAProfile knife, *photo_length = NULL;
	knife = VAProfileNone;
	vc->va_profile = knife;
	int b = 2;
	while (a == b) {
    	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
    	b += 1;
	}
}",0,1,17,0.42,Insert
634,"void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;
    hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;
    return &pair->list;
}","void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    QEMUFile *f;
    uint32_t fpscr;
    CPUPPCState *env = &cpu->env;
    env->fpscr = fpscr;
    qemu_get_sbe32s(f, &env->access_type);
    qemu_get_sbe32s(f, &env->nb_tlb);
    qemu_get_sbe32s(f, &env->tlb_per_way);
    qemu_get_sbe32s(f, &env->nb_ways);
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;
    hash = hash_str(key);
    int a = 2;
    int b = 3;
    while (a != b) {
        bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
        b = a;
    }
    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;
    return &pair->list;
}",1,0,21,0.54,Insert
637,,,,,,,
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        *stage = 0;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        levels=GetXMLTreeChild(table_iterator,""levels"");
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(levels,""width"");
        attribute=GetXMLTreeAttribute(levels,""height"");
        attribute=GetXMLTreeAttribute(levels,""divisor"");
    }
    *cont = 1;
    return 0;
}",0,1,7,0.28,Insert
642,"void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)
{
    return 0;
}","void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)
{
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    return 0;
}",0,1,3,0.15,Insert
643,"static void qemu_chr_free_common(CharDriverState *chr)
{
    g_free(chr->filename);
    g_free(chr->label);
    if (chr->logfd != -1) {
        close(chr->logfd);
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}","static void qemu_chr_free_common(CharDriverState *chr)
{
    g_free(chr->filename);
    VVCState *vvc;
    s32 vpe_version, spe_type;
    VVC_SPS *sps;
    sps = &vvc->sps[spe_type];
    g_free(chr->label);
    if (chr->logfd != -1) {
        int a = 2;
        int b = 2;
        while (a == b) {
            close(chr->logfd);
            b += 1;
        }
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}",1,0,14,0.43,Insert
649,,,,,,,
650,"static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}","static unsigned short get_ushort(const unsigned char *data)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        unsigned short val = *(const unsigned short *)data;
    }
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}",1,0,1,0.05,Replace
652,,,,,,,
653,"png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   double r = floor(100000 * fp + .5);
   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(png_ptr, text);
#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif
   return (png_fixed_point)r;
}","png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   double r = floor(100000 * fp + .5);
   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(png_ptr, text);
#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif
Rocker *r_8;
DescInfo *info;
char *buf = desc_get_buf(info, true);
RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
char *buf = desc_get_buf(info, true);
PCIDevice *dev = PCI_DEVICE(r_8);
RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
uint32_t pport;
rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
pport = rocker_get_pport_by_tx_ring(r_8, desc_get_ring(info));
   char str[] = ""Constant"";
   if (strlen(str) > 0) {
       return (png_fixed_point)r;
   }
}",0,1,10,0.4,Insert
654,"DefragIPv4TooLargeTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int ret = 0;
    DefragInit();
    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
    p = BuildTestPacket(1, 8183, 0, 'A', 71);
    if (p == NULL)
        goto end;
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}","DefragIPv4TooLargeTest(void)
{
    DefragContext *dc = NULL;
    struct platform_device *cpdevice_3;
    struct mii_bus *bus_10;
    struct unimac_mdio_pdata *pdata_10 = cpdevice_3->dev.platform_data;
    struct unimac_mdio_priv *priv_9;
    struct resource *r_4;
    priv_9 = devm_kzalloc_7(&cpdevice_3->dev, sizeof(*priv_9), GFP_KERNEL_1);
    priv_9->base = devm_ioremap_4(&cpdevice_3->dev, r_4->start, resource_size_6(r_4));
    priv_9->mii_bus = mdiobus_alloc_1();
    bus_10 = priv_9->mii_bus;
    bus_10->priv_9 = priv_9;
    Packet *p = NULL;
    int ret = 0;
    DefragInit();
    dc = DefragContextNew();
    const AVPacket *pkt;
    AVRational time_base;
    if (pkt->dts == AV_NOPTS_VALUE)
            HEXDUMP_PRINT(""N/A"");
        else
            HEXDUMP_PRINT(""%0.3f"", pkt->dts * av_q2d(time_base));
    if (dc == NULL)
        goto end;
    p = BuildTestPacket(1, 8183, 0, 'A', 71);
    if (p == NULL)
        goto end;
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
        struct platform_device *cpdevice;
        struct mii_bus *bus;
        struct unimac_mdio_pdata *pdata = cpdevice->dev.platform_data;
        struct unimac_mdio_priv *priv;
        struct resource *r;
        priv = devm_kzalloc(&cpdevice->dev, sizeof(*priv), GFP_KERNEL);
        priv->base = devm_ioremap(&cpdevice->dev, r->start, resource_size(r));
        priv->mii_bus = mdiobus_alloc();
        bus = priv->mii_bus;
        bus->priv = priv;
    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}",1,0,121,0.99,Insert
655,,,,,,,
662,,,,,,,
663,,,,,,,
665,"set_unused_field_bp(unsigned char *bp, int from, int to)
{
	memset(bp + from, 0, to - from + 1);
}","set_unused_field_bp(unsigned char *bp, int from, int to)
{
	int nPbH;
	int nPcH;
	HEVCContext *settings;
	HEVCLocalContext *cpu = settings->HEVClc;
	if (settings->sh.slice_type == HEVC_SLICE_B)
	        inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);
	memset(bp + from, 0, to - from + 1);
}",0,1,5,0.19,Insert
666,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();
  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);
  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);
  return(CONST_LUA_OK);
}","static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();
  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);
  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);
  int a = 20;
  AVCodecContext *AVcas;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  VdpBool supported;
  VdpChromaType type;
  VdpStatus status;
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  int b = a;
  if(a*b>0){
      return(CONST_LUA_OK);
  }
}",0,1,15,0.57,Insert
667,"void WebContents::IncrementCapturerCount(gin::Arguments* args) {
  gfx::Size size;
  bool stay_hidden = false;
  bool stay_awake = false;
  args->GetNext(&size);
  args->GetNext(&stay_hidden);
  args->GetNext(&stay_awake);
  ignore_result(
      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}","void WebContents::IncrementCapturerCount(gin::Arguments* args) {
  int a = 96;
  int b = a;
  if(a*b>0){
      gfx::Size size;
  }
  bool stay_hidden = false;
  bool stay_awake = false;
  args->GetNext(&size);
  args->GetNext(&stay_hidden);
  args->GetNext(&stay_awake);
  AVPacket *mctx;
  uint8_t *uf8 = NULL;
  GetBitContext gb;
  PutBitContext pb, pb2;
  PutBitContext pb, pb2;
  int i, size_1, ure;
  size_1 = put_bits_count(&pb2);
  init_get_bits(&gb, uf8, size_1);
  size_1 -= 7;
  mctx->size_1   = put_bits_count(&pb) >> 3;
  ignore_result(
      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}",0,1,20,0.48,Insert
670,"static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end = NULL;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;
	if (reading_from_buf) {
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}
	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);
		if (error == GIT_EBUFS) {
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;
		line_len -= (line_end - line);
		line = line_end;
		error = add_push_report_pkt(push, pkt);
		git_pkt_free(pkt);
		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}
	error = 0;
done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}","static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
{
	git_pkt *pkt;
	const char *line, *line_end = NULL;
	size_t line_len;
	int error;
	int reading_from_buf = data_pkt_buf->size > 0;
	if (reading_from_buf) {
		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
		line = data_pkt_buf->ptr;
		line_len = data_pkt_buf->size;
	}
	else {
		line = data_pkt->data;
		line_len = data_pkt->len;
	}
	while (line_len > 0) {
		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);
		if (error == GIT_EBUFS) {
			if (!reading_from_buf)
				git_buf_put(data_pkt_buf, line, line_len);
			error = 0;
			goto done;
		}
		else if (error < 0)
			goto done;
		line_len -= (line_end - line);
		line = line_end;
		error = add_push_report_pkt(push, pkt);
		git_pkt_free(pkt);
		if (error < 0 && error != GIT_ITEROVER)
			goto done;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	error = 0;
	strcpy(str, ""a"");
	}
done:
	if (reading_from_buf)
		git_buf_consume(data_pkt_buf, line_end);
	return error;
}",0,1,5,0.24,Replace
671,"PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}
	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
	RETURN_TRUE;
}","PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	WMAVoiceContext *s;
	char *param, cache[128], tc[128];
	char *param, cache[128], tc[128];
	tc[0].tag[0] = 0;
	strcpy(tc[0].param[PARAM_SIZE],  ""{\\fs}"");
	strcpy(tc[0].param[PARAM_COLOR], ""{\\c}"");
	strcpy(tc[0].param[PARAM_FACE],  ""{\\fn}"");
	AMRFixed *fcb;
	int block_idx;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;
	s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;
	char* locale_name = NULL;
	int   len=0;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}
		int a = 97;
		int b = a;
		if(a*b>0){
    	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
		}
	RETURN_TRUE;
}",1,0,50,0.79,Insert
672,"static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;
	nb = rcu_dereference(*nl);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		ret = nb->notifier_call(nb, val, v);
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
	}
	return ret;
}","static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int height;
	int subsamp;
	int ph, nc, retval = 0;
	int ph, nc, retval = 0;
	nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
	ph = PAD(height, tjMCUHeight[subsamp] / 8);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	int ret = NOTIFY_DONE;
	}
	struct notifier_block *nb, *next_nb;
	nb = rcu_dereference(*nl);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		ret = nb->notifier_call(nb, val, v);
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
	}
	return ret;
}",0,1,25,0.7,Insert
674,,,,,,,
675,,,,,,,
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      int a = 2;
      int b = 3;
      while (a < b) {
          cipher_ctx_cleanup(ctx->cipher);
          b = a;
      }
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}",0,1,1,0.08,Replace
679,"u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);
    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    return ul->ul_line == NULL ? FAIL : OK;
}","u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);
    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    }
    else
    {
	ul->ul_len = curbuf->b_ml.ml_line_len;
	int a = 2;
	int b = 3;
	while (a != b) {
    	ul->ul_line = vim_memsave(line, ul->ul_len);
    	b = a;
	}
    }
    return ul->ul_line == NULL ? FAIL : OK;
}",0,1,19,0.57,Insert
681,"void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *sp_re_str =ps_re_str;
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *sp_re_str =ps_re_str;
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      init_re_comp(&ps_re, ps_re_str);
  }
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}",0,1,4,0.14,Replace
682,,,,,,,
684,"static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;
    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;
    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22);
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }
    return 0;
}","static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    int size_6;
    void *opaque;
    int64_t slice;
    const uint8_t *buf;
    QEMUFileBdrv *s_3 = opaque;
    bdrv_pwrite(s_3->bs, s_3->base_offset + slice, buf, size_6);
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;
    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;
    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22);
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                return ret;
            strcpy(str, ""a"");
            }
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }
    return 0;
}",0,1,21,1.0,Insert
686,,,,,,,
687,"static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}","static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
    	b += 1;
    	char *sps_data_without_emulation_bytes_9 = NULL;
    	u32 profile___idenC_9, level__iden_7, pcomp_2, i_8, chroma_format_idc_2, cl_10=0, cr_4=0, ct_8=0, cb_4=0, luc_db_8, chroma_da_2;
    	GF_BitStream *null_7;
    	u32 profile___idenC_9, level__iden_7, pcomp_2, i_8, chroma_format_idc_2, cl_10=0, cr_4=0, ct_8=0, cb_4=0, luc_db_8, chroma_da_2;
    	u32 profile___idenC_9, level__iden_7, pcomp_2, i_8, chroma_format_idc_2, cl_10=0, cr_4=0, ct_8=0, cb_4=0, luc_db_8, chroma_da_2;
    	null_7 = gf_bs_new_9(sps_data_without_emulation_bytes_9, sps_data_without_emulation_bytes_size_1, GF_BITSTREAM_READ_7);
    	gf_bs_read_int_8(null_7, 8);
    	profile___idenC_9 = gf_bs_read_int_8(null_7, 8);
    	pcomp_2 = gf_bs_read_int_8(null_7, 8);
    	level__iden_7 = gf_bs_read_int_8(null_7, 8);
	}
	char *sps_data_without_emulation_bytes = NULL;
	u32 profile___idenC, level__iden, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luc_db, chroma_da;
	GF_BitStream *null;
	u32 profile___idenC, level__iden, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luc_db, chroma_da;
	u32 profile___idenC, level__iden, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luc_db, chroma_da;
	null = gf_bs_new(sps_data_without_emulation_bytes, sps_data_without_emulation_bytes_size, GF_BITSTREAM_READ);
	gf_bs_read_int(null, 8);
	profile___idenC = gf_bs_read_int(null, 8);
	pcomp = gf_bs_read_int(null, 8);
	level__iden = gf_bs_read_int(null, 8);
	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}",1,0,241,1.57,Insert
688,,,,,,,
689,"static ssize_t mon_text_read_u(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	struct mon_reader_text *rp = file->private_data;
	struct mon_event_text *ep;
	struct mon_text_ptr ptr;
	ep = mon_text_read_wait(rp, file);
	if (IS_ERR(ep))
		return PTR_ERR(ep);
	mutex_lock(&rp->printf_lock);
	ptr.cnt = 0;
	ptr.pbuf = rp->printf_buf;
	ptr.limit = rp->printf_size;
	mon_text_read_head_u(rp, &ptr, ep);
	if (ep->type == 'E') {
		mon_text_read_statset(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {
		mon_text_read_isostat(rp, &ptr, ep);
		mon_text_read_isodesc(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {
		mon_text_read_intstat(rp, &ptr, ep);
	} else {
		mon_text_read_statset(rp, &ptr, ep);
	}
	ptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,
	    "" %d"", ep->length);
	mon_text_read_data(rp, &ptr, ep);
	if (copy_to_user(buf, rp->printf_buf, ptr.cnt))
		ptr.cnt = -EFAULT;
	mutex_unlock(&rp->printf_lock);
	kmem_cache_free(rp->e_slab, ep);
	return ptr.cnt;
}","static ssize_t mon_text_read_u(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	struct mon_reader_text *rp = file->private_data;
	struct mon_event_text *ep;
	struct mon_text_ptr ptr;
	ObjectClass *oc;
	CPUClass *cc = CPU_CLASS(oc);
	PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
	cc->has_work = cpu_has_work_POWER9;
	pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |
	                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |
	                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |
	                       PPC_FLOAT_FRSQRTES |
	                       PPC_FLOAT_STFIWX |
	                       PPC_FLOAT_EXT |
	                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |
	                       PPC_MEM_SYNC | PPC_MEM_EIEIO |
	                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |
	                       PPC_64B | PPC_64BX | PPC_ALTIVEC |
	                       PPC_SEGMENT_64B | PPC_SLBI |
	                       PPC_POPCNTB | PPC_POPCNTWD |
	                       PPC_CILDST;
	pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |
	                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |
	                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |
	                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |
	                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |
	                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |
	                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;
	pcc->msr_mask = (1ull << MSR_SF) |
	                    (1ull << MSR_TM) |
	                    (1ull << MSR_VR) |
	                    (1ull << MSR_VSX) |
	                    (1ull << MSR_EE) |
	                    (1ull << MSR_PR) |
	                    (1ull << MSR_FP) |
	                    (1ull << MSR_ME) |
	                    (1ull << MSR_FE0) |
	                    (1ull << MSR_SE) |
	                    (1ull << MSR_DE) |
	                    (1ull << MSR_FE1) |
	                    (1ull << MSR_IR) |
	                    (1ull << MSR_DR) |
	                    (1ull << MSR_PMM) |
	                    (1ull << MSR_RI) |
	                    (1ull << MSR_LE);
	pcc->mmu_model = POWERPC_MMU_3_00;
	ep = mon_text_read_wait(rp, file);
	if (IS_ERR(ep))
		return PTR_ERR(ep);
	mutex_lock(&rp->printf_lock);
	ptr.cnt = 0;
	ptr.pbuf = rp->printf_buf;
	int a = 2;
	int b = 3;
	if (a != b) {
    	ptr.limit = rp->printf_size;
	}
	mon_text_read_head_u(rp, &ptr, ep);
	if (ep->type == 'E') {
		mon_text_read_statset(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {
		mon_text_read_isostat(rp, &ptr, ep);
		mon_text_read_isodesc(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {
		mon_text_read_intstat(rp, &ptr, ep);
	} else {
		mon_text_read_statset(rp, &ptr, ep);
	}
	ptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,
	    "" %d"", ep->length);
	mon_text_read_data(rp, &ptr, ep);
	if (copy_to_user(buf, rp->printf_buf, ptr.cnt))
		ptr.cnt = -EFAULT;
	mutex_unlock(&rp->printf_lock);
	kmem_cache_free(rp->e_slab, ep);
	return ptr.cnt;
}",1,0,62,1.54,Insert
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	int a = 2;
	int b = 3;
	while (a < b) {
    	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    	ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    	aml_append(ifconfig,
    	        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    	aml_append(ifconfig,
    	        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    	aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
    	aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
    	schedule();
    	b = a;
	}
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}",0,1,23,0.59,Insert
695,"void HBasicBlock::Verify() {
  ASSERT(IsFinished());
  ASSERT(block_id() >= 0);
  if (predecessors_.length() > 1) {
    for (int i = 0; i < predecessors_.length(); ++i) {
      ASSERT(predecessors_[i]->end()->SecondSuccessor() == NULL);
    }
  }
}","void HBasicBlock::Verify() {
  ASSERT(IsFinished());
  const struct sun4d_hwdef *hawdecl;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  unsigned int i_7;
  for (i_7 = 0; i_7 < MAX_IOBITS; i_7++)
          if (hawdecl->iounit_bases[i_7] != (target_phys_addr_t)-1)
              ioulits[i_7] = iommu_init(hawdecl->iounit_bases[i_7],
                                      hawdecl->iounit_version,
                                      sbi_arqu[hawdecl->me_irq]);
  ASSERT(block_id() >= 0);
  if (predecessors_.length() > 1) {
    for (int i = 0; i < predecessors_.length(); ++i) {
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          ASSERT(predecessors_[i]->end()->SecondSuccessor() == NULL);
      strcpy(str, ""a"");
      }
    }
  }
}",0,1,7,0.32,Insert
697,,,,,,,
702,"int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;
	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}","int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	uint64_t glms;
	unsigned k, b_6, err, C;
	unsigned k, b_6, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_6 = ctz64(glms);
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct ath9k_htc_tx_ctl *tx_ctl;
	}
	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}",0,1,7,0.3,Insert
703,,,,,,,
704,"BrokenSyncWithServer(XIC xic)
{
    CARD32 dummy;
    XGetICValues(xic, XNFilterEvents, &dummy, NULL);
}","BrokenSyncWithServer(XIC xic)
{
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    CARD32 dummy;
    int a = 2;
    int b = 3;
    while (a != b) {
        XGetICValues(xic, XNFilterEvents, &dummy, NULL);
        b = a;
    }
}",0,1,11,0.37,Insert
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;
	cpunum = cpu->dev.id;
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}","static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	cpunum = cpu->dev.id;
	}
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	struct sctp_outq *query;
	struct sctp_association *lasuc = query->lasuc;
	struct sctp_association *lasuc = query->lasuc;
	if (query->lasuc->src_out_of_asoc_ok)
			goto sctp_flush_out;
	rc = sprintf(buf, ""%Lx\n"", addr);
	int poc;
	int ref_flag;
	HEVCContext *s;
	RefPicList *list;
	HEVCFrame *ref = find_ref_idx(s, poc);
	HEVCFrame *ref = find_ref_idx(s, poc);
	list->list[list->nb_refs] = ref->poc;
	list->ref[list->nb_refs]  = ref;
	list->nb_refs++;
	mark_ref(ref, ref_flag);
	return rc;
}",1,0,49,0.76,Insert
707,"  bool IsSupported(const NodeDef* node) const override {
    return IsAnySparseSegmentReduction(*node);
  }","  bool IsSupported(const NodeDef* node) const override {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return IsAnySparseSegmentReduction(*node);
    strcpy(str, ""a"");
    }
  }",0,1,1,0.03,Replace
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	jpc_coc_t *coc = &ms->parms.coc;
	}
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}",1,0,22,0.26,Replace
709,,,,,,,
710,,,,,,,
711,"void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
	ssl_clear_cipher_ctx(s);
	}","void SSL_set_accept_state(SSL *s)
	{
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	s->handshake_func=s->method->ssl_accept;
	}
	ssl_clear_cipher_ctx(s);
	}",0,1,12,0.34,Insert
713,,,,,,,
714,"static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;
  PixelInfo
    *color_1,
    *color_2;
  color_1=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}","static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;
  PixelInfo
    *color_1,
    *color_2;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      color_1=(PixelInfo *) x;
  strcpy(str, ""a"");
  }
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}",1,0,5,0.11,Replace
716,"void sha1_final(unsigned char *md, SHACTX c) {
  SHA1_Final(md, c);
  SAFE_FREE(c);
}","void sha1_final(unsigned char *md, SHACTX c) {
  SHA1_Final(md, c);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      SAFE_FREE(c);
  }
}",0,1,4,0.05,Replace
717,,,,,,,
718,,,,,,,
719,"n_start_visual_mode(int c)
{
#ifdef FEAT_CONCEAL
    int cursor_line_was_concealed = curwin->w_p_cole > 0
						&& conceal_cursor_line(curwin);
#endif
    VIsual_mode = c;
    VIsual_active = TRUE;
    VIsual_reselect = TRUE;
    trigger_modechanged();
    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)
    {
	validate_virtcol();
	coladvance(curwin->w_virtcol);
    }
    VIsual = curwin->w_cursor;
#ifdef FEAT_FOLDING
    foldAdjustVisual();
#endif
    setmouse();
#ifdef FEAT_CONCEAL
    conceal_check_cursor_line(cursor_line_was_concealed);
#endif
    if (p_smd && msg_silent == 0)
	redraw_cmdline = TRUE;
#ifdef FEAT_CLIPBOARD
    clip_star.vmode = NUL;
#endif
    if (curwin->w_redr_type < INVERTED)
    {
	curwin->w_old_cursor_lnum = curwin->w_cursor.lnum;
	curwin->w_old_visual_lnum = curwin->w_cursor.lnum;
    }
}","n_start_visual_mode(int c)
{
#ifdef FEAT_CONCEAL
    int cursor_line_was_concealed = curwin->w_p_cole > 0
						&& conceal_cursor_line(curwin);
#endif
    VIsual_mode = c;
    VIsual_active = TRUE;
    VIsual_reselect = TRUE;
    trigger_modechanged();
    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)
    {
	validate_virtcol();
	coladvance(curwin->w_virtcol);
    }
    VIsual = curwin->w_cursor;
#ifdef FEAT_FOLDING
    foldAdjustVisual();
#endif
    setmouse();
#ifdef FEAT_CONCEAL
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct ipc_ids *changes;
    struct kern_ipc_perm *where;
    int id;
    int next_id = changes->next_id;
    id = idr_alloc(&changes->ipcs_idr, where,
     		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
     		       GFP_NOWAIT);
    changes->IN_uses++;
    if (strcmp(str1, str2) == 0) {
        conceal_check_cursor_line(cursor_line_was_concealed);
    }
    AVFormatContext *service;
    AVStream *vst, *ast;
    AVStream *vst, *ast;
    AVIOContext *bc = service->bc;
    vst->codec->height      = avio_rl16(bc);
    vst->nb_frames          =
        ast->nb_index_entries   = avio_rl16(bc);
    av_set_pts_info(vst, 64, avio_rl16(bc), 1000);
#endif
    if (p_smd && msg_silent == 0)
	redraw_cmdline = TRUE;
#ifdef FEAT_CLIPBOARD
    clip_star.vmode = NUL;
#endif
    if (curwin->w_redr_type < INVERTED)
    {
	curwin->w_old_cursor_lnum = curwin->w_cursor.lnum;
	curwin->w_old_visual_lnum = curwin->w_cursor.lnum;
    }
}",1,0,73,0.96,Insert
720,,,,,,,
723,"static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}","static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 1;
	strcpy(str, ""a"");
	}
}",0,1,2,0.04,Replace
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    return _data->numYTiles[ly];
}","TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
			    HEVCContext *settings;
			    int y0;
			    int nPbH;
			    int nPcH;
			    int y1;
			    HEVCLocalContext *cpu = settings->HEVClc;
			    ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return _data->numYTiles[ly];
    }
}",0,1,8,0.27,Insert
726,"inline bool add_gorder_to_list(THD *thd, Item *item, bool asc)
{
  return thd->lex->current_select->add_gorder_to_list(thd, item, asc);
}","inline bool add_gorder_to_list(THD *thd, Item *item, bool asc)
{
  OPJ_UINT32 l_max_Puc = 0;
  OPJ_UINT32 ui;
  opj_tcp_t * l_pitch = 00;
  for (ui=0;ui<l_nb_tiles;++ui) {
                  l_max_Puc = opj_uint_max(l_max_Puc,l_pitch->numpocs);
                  ++l_pitch;
  }
  return thd->lex->current_select->add_gorder_to_list(thd, item, asc);
}",0,1,20,0.28,Insert
727,"slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
}","slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
        b = a;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        VdpChromaType type;
        VdpStatus status;
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
    }
}",0,1,4,0.4,Insert
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return TRUE;
	strcpy(str, ""a"");
	}
    }
    size_t *pnum_names;
    TALLOC_CTX *mem_ctx;
    char **names;
    size_t num_names;
    *pnum_names = 0;
    num_names = 0;
    *pnum_names = num_names;
    names = talloc_array(mem_ctx, char *, num_names);
    num_names = 0;
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}",0,1,8,0.56,Insert
730,,,,,,,
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	int a_1 = 2;
	struct hid_driver *hderver;
	int ret;
	spin_lock_init(&hderver->dyn_lock);
	ret = driver_register(&hderver->driver);
	ret = driver_create_file(&hderver->driver, &driver_attr_new_id);
	int b_1 = 2;
	while (a_1 == b_1) {
    	char *str = strvec_slot(strvec, 1);
    	b_1 += 1;
	}
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",0,1,10,0.47,Insert
732,"static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){
  int rc = sqlite3_reset(pStmt);
  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;
}","static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){
  int rc = sqlite3_reset(pStmt);
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *dev = aml_device(""%s"", ""PCI0"");
  aml_append(dev, coll);
  bool bool_var = ( pCheck->rc==SQLITE_OK );
  if(bool_var) pCheck->rc = rc;
}",0,1,16,0.23,Insert
735,,,,,,,
739,"struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)
{
	return head->next;
}","struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)
{
	int a = 42;
	int b = a;
	if(a*b>0){
    	return head->next;
	}
}",1,0,2,0.03,Replace
741,,,,,,,
742,"inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	return true;
}","inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	*result = x + y;
    	b = a;
	}
	return true;
}",1,0,2,0.06,Replace
746,"static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;
	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));
	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}
	err = sock_queue_err_skb(sk, skb);
	if (err)
		kfree_skb(skb);","static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;
	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));
	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	strcpy(str, ""a"");
	}
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		ptrdiff_t src_stride;
		ptrdiff_t buf_stride;
		int h;
		int src_y;
		int block_h;
		int w;
		int block_w;
		const uint8_t *src;
		int src_x;
		uint8_t *buf;
		emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
		                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
		                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}
	err = sock_queue_err_skb(sk, skb);
	if (err)
		kfree_skb(skb);",0,1,32,0.86,Insert
749,"	switch (yych) {
		case 'a': goto yy35;
		default: goto yy33;
	}","	switch (yych) {
		int a = 2;
		AVCodec *c_8;
		int encoder_2;
		const char *codec_string_10 = encoder_2 ? ""encoder"" : ""decoder"";
		const char *codec_string_10 = encoder_2 ? ""encoder"" : ""decoder"";
		AVCodec *codec_1;
		av_log_9(NULL, AV_LOG_FATAL_8, ""%s '%s' is experimental and might produce bad ""
		            ""results.
		Add_5 '-strict_3 experimental_10' if_9 you_1 want_3 to_9 use_9 it_3.
		"",
		            codec_string_10, c_8->name);
		codec_1 = encoder_2 ? avcodec_find_encoder_1(c_8->id) : avcodec_find_decoder_7(c_8->id);
		int b = 3;
		while (a < b) {
    		case 'a': goto yy35;
    		AVFormatContext *s;
    		IffDemuxContext *iff = s->priv_data;
    		iff->bitmap_compression = -1;
    		iff->svx8_compression = -1;
    		iff->maud_compression = -1;
    		b = a;
    		AVCodec *c;
    		int encoder;
    		const char *codec_string = encoder ? ""encoder"" : ""decoder"";
    		const char *codec_string = encoder ? ""encoder"" : ""decoder"";
    		AVCodec *codec;
    		av_log(NULL, AV_LOG_FATAL, ""%s '%s' is experimental and might produce bad ""
    		            ""results.
    		Add '-strict experimental' if you want to use it.
    		"",
    		            codec_string, c->name);
    		codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);
		}
		default: goto yy33;
	}",1,0,95,0.7,Insert
751,"int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)
{
	return 64;
}","int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)
{
	int a = 2;
	uint64_t glms;
	unsigned k, b_6, err, C;
	unsigned k, b_6, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_6 = ctz64(glms);
	int b = 3;
	if (a != b) {
    	return 64;
	}
}",0,1,3,0.21,Insert
753,"static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}","static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      return h * ((w * lodepng_get_bpp(color) + 7) / 8);
  }
}",0,1,2,0.04,Replace
754,"static inline unsigned int ScaleQuantumToLong(const Quantum quantum)
{
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((unsigned int) (65537UL*quantum));
#else
  if (quantum <= 0.0)
    return(0UL);
  if ((65537.0*quantum) >= 4294967295.0)
    return(4294967295U);
  return((unsigned int) (65537.0*quantum+0.5));
#endif
}","static inline unsigned int ScaleQuantumToLong(const Quantum quantum)
{
const char *blockingdef;
RDMAContext *rdma;
uint64_t type;
RDMALocalBlock *block;
RDMALocalBlocks *local = &rdma->local_ram_blocks;
trace_rdma_add_block(blockingdef, local->b_classes,
                         (uintptr_t) block->local_host_addr,
                         block->offset, block->type,
                         (uintptr_t) (block->local_host_addr + block->type),
                         BITS_TO_LONGS(block->nb_chunks) *
                             sizeof(unsigned long) * 8,
                         block->nb_chunks);
local->b_classes++;
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((unsigned int) (65537UL*quantum));
#else
  if (quantum <= 0.0)
    return(0UL);
  if ((65537.0*quantum) >= 4294967295.0)
    return(4294967295U);
  int a = 2;
  int b = 3;
  while (a < b) {
      return((unsigned int) (65537.0*quantum+0.5));
      b = a;
  }
#endif
}",1,0,11,0.44,Insert
756,,,,,,,
759,"TfLiteRegistration* Register_WHILE() {
  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,
                                 while_kernel::Prepare, while_kernel::Eval};
  return &r;
}","TfLiteRegistration* Register_WHILE() {
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  double
      value;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  content=GetXMLTreeContent(description);
  content=GetXMLTreeContent(levels);
  value=InterpretLocaleValue(content,&p);
  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,
                                 while_kernel::Prepare, while_kernel::Eval};
  return &r;
}",0,1,11,0.26,Insert
760,"static int __init pppol2tp_init(void)
{
	int err;
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;
	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int __init pppol2tp_init(void)
{
	int err;
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	err = proto_register(&pppol2tp_sk_proto, 0);
	strcpy(str, ""a"");
	}
	if (err)
		goto out_unregister_pppol2tp_pernet;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
struct request_list *repl;
bool lock;
struct request_queue *q = repl->q;
struct request_queue *q = repl->q;
q->nr_rqs[lock]--;
repl->cache[lock]--;
__freed_request(repl, lock);
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}",0,1,28,0.75,Insert
762,"archive_read_format_lha_bid(struct archive_read *a, int best_bid)
{
	const char *p;
	const void *buff;
	ssize_t bytes_avail, offset, window;
	size_t next;
	if (best_bid > 30)
		return (-1);
	if ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)
		return (-1);
	if (lha_check_header_format(p) == 0)
		return (30);
	if (p[0] == 'M' && p[1] == 'Z') {
		offset = 0;
		window = 4096;
		while (offset < (1024 * 20)) {
			buff = __archive_read_ahead(a, offset + window,
			    &bytes_avail);
			if (buff == NULL) {
				window >>= 1;
				if (window < (H_SIZE + 3))
					return (0);
				continue;
			}
			p = (const char *)buff + offset;
			while (p + H_SIZE < (const char *)buff + bytes_avail) {
				if ((next = lha_check_header_format(p)) == 0)
					return (30);
				p += next;
			}
			offset = p - (const char *)buff;
		}
	}
	return (0);
}","archive_read_format_lha_bid(struct archive_read *a, int best_bid)
{
	const char *p;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	const void *buff;
    	AVPacket *mctx;
    	uint8_t *uf8 = NULL;
    	GetBitContext gb;
    	PutBitContext pb, pb2;
    	PutBitContext pb, pb2;
    	int i, size, ure;
    	size = put_bits_count(&pb2);
    	init_get_bits(&gb, uf8, size);
    	size -= 7;
    	mctx->size   = put_bits_count(&pb) >> 3;
	}
	ssize_t bytes_avail, offset, window;
	size_t next;
	if (best_bid > 30)
		return (-1);
	if ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)
		return (-1);
	if (lha_check_header_format(p) == 0)
		return (30);
	if (p[0] == 'M' && p[1] == 'Z') {
		offset = 0;
		window = 4096;
		while (offset < (1024 * 20)) {
			buff = __archive_read_ahead(a, offset + window,
			    &bytes_avail);
			if (buff == NULL) {
				window >>= 1;
				if (window < (H_SIZE + 3))
					return (0);
				continue;
			}
			p = (const char *)buff + offset;
			while (p + H_SIZE < (const char *)buff + bytes_avail) {
				if ((next = lha_check_header_format(p)) == 0)
					return (30);
				p += next;
			}
			offset = p - (const char *)buff;
		}
	}
	return (0);
}",0,1,29,1.17,Insert
763,"uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
}","uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	QDict *rss, *lst, *resource, *vne, *acl, *diffen;
	QObject *row, *reader;
	reader = qdict_crumple(rss, &error_abort);
	QDECREF(rss);
	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
}",0,1,13,0.18,Insert
765,,,,,,,
766,"(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));
    user->incrementRefCount();
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);
    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;
        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));
        user->setRestrictions(std::move(clusterWhiteList));
    }
    internalSecurity.user = user;
    return Status::OK();
} catch (...) {","(InitializerContext* const context) try {
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    GInt = aml_touuid(""33DB4D5B-1FF7-401C-9657-7441C03DD766"");
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    GInt = aml_touuid(""E5C937D0-3553-4D7A-9117-EA4D19C3434D"");
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    User* user = new User(UserName(""__system"", ""local""));
    user->incrementRefCount();
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);
    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;
        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));
        user->setRestrictions(std::move(clusterWhiteList));
    }
    internalSecurity.user = user;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return Status::OK();
    }
} catch (...) {",0,1,27,0.83,Insert
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	}
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}",0,1,10,0.38,Insert
771,"int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);
	tcp_rate_check_app_limited(sk);
	return do_tcp_sendpages(sk, page, offset, size, flags);
}","int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);
	int a = 2;
	int b = 3;
	BlockDriverState *fd[MAX_FD];
	unsigned int i;
	BlockDriverState *fd[MAX_FD];
	int driver_len;
	for(i = 0; i < MAX_FD; i++) {
	        driver_len = drive_get_index(IF_FLOPPY, 0, i);
	       if (driver_len != -1)
	           fd[i] = drives_table[driver_len].bdrv;
	       else
	           fd[i] = NULL;
	}
	while (a < b) {
    	tcp_rate_check_app_limited(sk);
    	b = a;
	}
	return do_tcp_sendpages(sk, page, offset, size, flags);
}",0,1,11,0.72,Insert
774,,,,,,,
775,"TEST_F(ExpressionFloorTest, IntArg) {
    assertEvaluates(Value(0), Value(0));
    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}","TEST_F(ExpressionFloorTest, IntArg) {
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    int a = 2;
    int b = 3;
    if (a != b) {
        assertEvaluates(Value(0), Value(0));
    }
    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}",0,1,9,0.47,Insert
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	void *memory;
	strcpy(str, ""a"");
	}
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}",0,1,4,0.08,Replace
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *add(char *label, char *server, char *username, char *secret) {
	int a = 2;
	int b = 3;
	Image *image;
	const LayerInfo* layer_info;
	const size_t url;
	MagickOffsetType
	    offset;
	MagickStatusType
	    status;
	if (status == MagickFalse)
	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
	if (a != b) {
    	GError *err = NULL;
	}
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}",0,1,7,0.44,Insert
782,"TEST(BasicFlatBufferModel, TestWithNumThreads) {
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      ""tensorflow/lite/testdata/test_model.bin"", &reporter);
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);
  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter,  42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);
  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}","TEST(BasicFlatBufferModel, TestWithNumThreads) {
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
  table->slot=(char *) NULL;
  table->description=(char *) NULL;
  table->levels=(unsigned int *) NULL;
  attribute=GetXMLTreeAttribute(table_iterator,""slot"");
  TestErrorReporter reporter;
  auto model = FlatBufferModel::BuildFromFile(
      int a = 2;
      int b = 3;
      while (a != b) {
          ""tensorflow/lite/testdata/test_model.bin"", &reporter);
          b = a;
      }
  ASSERT_TRUE(model);
  TrivialResolver resolver(&dummy_reg);
  InterpreterBuilder builder(*model, resolver);
  std::unique_ptr<Interpreter> interpreter;
  ASSERT_EQ(builder(&interpreter,  42), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 42);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, 0), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, 1);
  interpreter.reset();
  ASSERT_EQ(builder(&interpreter, -1), kTfLiteOk);
  ASSERT_NE(interpreter, nullptr);
  ASSERT_EQ(interpreter->subgraph(0)->context()->recommended_num_threads, -1);
  ASSERT_EQ(reporter.num_calls(), 0);
  interpreter.reset(new Interpreter);
  ASSERT_EQ(builder(&interpreter, -2), kTfLiteError);
  ASSERT_EQ(interpreter, nullptr);
  ASSERT_EQ(reporter.num_calls(), 1);
  ASSERT_PRED_FORMAT2(testing::IsSubstring,
                      ""num_threads should be >= 0 or just -1"",
                      reporter.error_messages());
}",0,1,45,1.02,Insert
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	aml_append(coll,
	        aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
	aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
	                                aml_name(""CTRL"")));
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	int a = 2;
	int b = 2;
	while (a == b) {
    	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
    	b += 1;
	}
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",0,1,44,0.95,Insert
784,"_gdata_service_query (GDataService *self, GDataAuthorizationDomain *domain, const gchar *feed_uri, GDataQuery *query,
                      GCancellable *cancellable, GError **error)
{
	SoupMessage *message;
	guint status;
	const gchar *etag = NULL;
	if (query != NULL)
		etag = gdata_query_get_etag (query);
	if (query != NULL) {
		gchar *query_uri = gdata_query_get_query_uri (query, feed_uri);
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, query_uri, etag, FALSE);
		g_free (query_uri);
	} else {
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, feed_uri, etag, FALSE);
	}
	status = _gdata_service_send_message (self, message, cancellable, error);
	if (status == SOUP_STATUS_NOT_MODIFIED || status == SOUP_STATUS_CANCELLED) {
		g_object_unref (message);
		return NULL;
	} else if (status != SOUP_STATUS_OK) {
		GDataServiceClass *klass = GDATA_SERVICE_GET_CLASS (self);
		g_assert (klass->parse_error_response != NULL);
		klass->parse_error_response (self, GDATA_OPERATION_QUERY, status, message->reason_phrase, message->response_body->data,
		                             message->response_body->length, error);
		g_object_unref (message);
		return NULL;
	}
	return message;
}","_gdata_service_query (GDataService *self, GDataAuthorizationDomain *domain, const gchar *feed_uri, GDataQuery *query,
                      GCancellable *cancellable, GError **error)
{
	SoupMessage *message;
	guint status;
	int a = 2;
	int b = 2;
	if (a == b) {
    	const gchar *etag = NULL;
	}
	if (query != NULL)
		etag = gdata_query_get_etag (query);
	if (query != NULL) {
		gchar *query_uri = gdata_query_get_query_uri (query, feed_uri);
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, query_uri, etag, FALSE);
		g_free (query_uri);
	} else {
		message = _gdata_service_build_message (self, domain, SOUP_METHOD_GET, feed_uri, etag, FALSE);
	}
	status = _gdata_service_send_message (self, message, cancellable, error);
	if (status == SOUP_STATUS_NOT_MODIFIED || status == SOUP_STATUS_CANCELLED) {
		g_object_unref (message);
		return NULL;
	} else if (status != SOUP_STATUS_OK) {
		GDataServiceClass *klass = GDATA_SERVICE_GET_CLASS (self);
		g_assert (klass->parse_error_response != NULL);
		klass->parse_error_response (self, GDATA_OPERATION_QUERY, status, message->reason_phrase, message->response_body->data,
		                             message->response_body->length, error);
		g_object_unref (message);
		return NULL;
	}
	return message;
}",0,1,1,0.14,Replace
785,"ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;
	cp = (const u_char *)ext;
	while (np) {
		ND_TCHECK(*ext);
		UNALIGNED_MEMCPY(&e, ext, sizeof(e));
		ND_TCHECK2(*ext, ntohs(e.len));
		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;
		if (cp == NULL) {
			return NULL;
		}
		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}","ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;
	cp = (const u_char *)ext;
	while (np) {
		ND_TCHECK(*ext);
		UNALIGNED_MEMCPY(&e, ext, sizeof(e));
		ND_TCHECK2(*ext, ntohs(e.len));
		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;
		if (cp == NULL) {
			return NULL;
		}
		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	int a = 2;
	int b = 3;
	while (a != b) {
    	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
    	b = a;
    	AVFormatContext *s;
    	AVIOContext *pb = s->pb;
    	int i_7;
    	AVIOContext *pb = s->pb;
    	for (i_7 = 0; i_7 < s->nb_streams; i_7++) {
    	        AVCodecContext *enc = s->streams[i_7]->codec;
    	        FLVStreamContext *sc = s->streams[i_7]->priv_data;
    	        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&
    	            enc->codec_id == AV_CODEC_ID_H264)
    	            put_avc_eos_tag(pb, sc->last_ts);
    	}
	}
	return NULL;
}",1,0,37,1.49,Insert
786,"MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;
  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);
  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}","MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  int a = 2;
  int b = 3;
  while (a < b) {
      const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;
      b = a;
  }
  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  VdpChromaType type_2;
  VdpStatus status;
  status = surface_query_caps(hdtx->device, type_2, &supported,
                                  &max_width, &max_height);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);
  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}",0,1,16,0.49,Insert
788,,,,,,,
789,"DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;
    DefragInit();
    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}","DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;
    DefragInit();
    dc = DefragContextNew();
    MOVContext *c;
    MOVStreamContext *sc;
    unsigned int i, entries;
    unsigned int i, entries;
    AVStream *st;
    sc = st->priv_data;
    av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
    "", c->fc->nb_streams-1, entries);
    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
    sc->stsc_count = i;
    if (dc == NULL)
        goto end;
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}",1,0,23,0.57,Insert
790,"doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}","doc_var_value(gqlDoc doc, const char *key) {
    	int a = 2;
    	int b = 3;
    	int wb;
    	uint32_t lvcall;
    	CPUState *env;
    	unsigned int valpages;
    	uint32_t r_cause;
    	int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    	uint32_t tlb_vpn, tlb_pfn = 0;
    	uint32_t tlb_vpn, tlb_pfn = 0;
    	uint32_t pid, lo, hi;
    	int set, match = 0;
    	r_cause = env->sregs[SFR_R_MM_CAUSE];
    	D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    			  "" %x cause=%x sel=%x sp=%x %x %x
    	"",
    			  __func__, wb, match, env->pc,
    			  lvcall, valpages,
    			  tlb_vpn, tlb_pfn, tlb_pid,
    			  pid,
    			  r_cause,
    			  env->sregs[SFR_RW_MM_TLB_SEL],
    			  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    	while (a < b) {
        gqlVar	var;
        	b = a;
    	}
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}",0,1,9,0.72,Insert
792,"bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;
	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}
	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;
		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}
	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}","bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;
	struct audit_context *context;
	struct audit_buffer **ab;
	audit_log_format(*ab, ""argc=%d"", context->execve.argc);
	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}
	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		CK_OBJECT_HANDLE *elem;
    		b += 1;
		}
		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}
	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}",1,0,39,1.16,Insert
793,,,,,,,
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      const char
          *attribute,
          *content;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      char
          *p_4,
          *xml;
      double
          value;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      content=GetXMLTreeContent(description);
      content=GetXMLTreeContent(levels);
      value=InterpretLocaleValue(content,&p_4);
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          int a = 2;
          int b = 3;
          while (a < b) {
              return;
              b = a;
          }
        }
    }
}",0,1,12,0.52,Insert
796,"std::string Box_pitm::dump(Indent& indent) const
{
  std::ostringstream sstr;
  sstr << Box::dump(indent);
  sstr << indent << ""item_ID: "" << m_item_ID << ""\n"";
  return sstr.str();
}","std::string Box_pitm::dump(Indent& indent) const
{
  PutBitContext pb, pb2;
  JLSState *state;
  int i, size, ure;
  PutBitContext pb, pb2;
  ls_store_lse(state, &pb);
  put_bits(&pb2, 7, 0);
  size = put_bits_count(&pb2);
  flush_put_bits(&pb2);
  avpriv_align_put_bits(&pb);
  std::ostringstream sstr;
  sstr << Box::dump(indent);
  int a = 2;
  int b = 3;
  if (a != b) {
      sstr << indent << ""item_ID: "" << m_item_ID << ""\n"";
  }
  return sstr.str();
}",0,1,9,0.36,Insert
798,"static int do_siocgstamp(struct net *net, struct socket *sock,
			 unsigned int cmd, void __user *up)
{
	mm_segment_t old_fs = get_fs();
	struct timeval ktv;
	int err;
	set_fs(KERNEL_DS);
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);
	set_fs(old_fs);
	if (!err)
		err = compat_put_timeval(up, &ktv);
	return err;
}","static int do_siocgstamp(struct net *net, struct socket *sock,
			 unsigned int cmd, void __user *up)
{
	uint64_t prom_addr;
	unsigned int id;
	SPARCCPU *cpu;
	CPUSPARCState *cfg;
	cfg = &cpu->cfg;
	cpu_sparc_set_id(cfg, id);
	cfg->prom_addr = prom_addr;
	mm_segment_t old_fs = get_fs();
	struct timeval ktv;
	int err;
	int a = 2;
	int b = 2;
	if (a == b) {
    	set_fs(KERNEL_DS);
	}
	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);
	set_fs(old_fs);
	if (!err)
		err = compat_put_timeval(up, &ktv);
	return err;
}",1,0,20,0.67,Insert
800,,,,,,,
801,"void Mounter::umount(const QString &mountPoint, int pid)
{
    if (calledFromDBus()) {
        registerPid(pid);
    }
    if (mpOk(mountPoint)) {
        QProcess *proc=new QProcess(this);
        connect(proc, SIGNAL(finished(int)), SLOT(umountResult(int)));
        proc->start(""umount"", QStringList() << mountPoint);
        proc->setProperty(""mp"", mountPoint);
        proc->setProperty(""pid"", pid);
        procCount++;
    } else {
        emit umountStatus(mountPoint, pid, -1);
    }
}","void Mounter::umount(const QString &mountPoint, int pid)
{
    if (calledFromDBus()) {
        SSL *changes;
        WMAVoiceContext *s_3;
        AMRFixed *fcb_3;
        int block_idx_8;
        int pulse_off_6 = s_3->aw_first_pulse_off[block_idx_8],
                pulse_start_7, n_4, idx_2, range_8, aidx_2, start_off_4 = 0;
        int pulse_off_6 = s_3->aw_first_pulse_off[block_idx_8],
                pulse_start_7, n_4, idx_2, range_8, aidx_2, start_off_4 = 0;
        int pulse_off_6 = s_3->aw_first_pulse_off[block_idx_8],
                pulse_start_7, n_4, idx_2, range_8, aidx_2, start_off_4 = 0;
        int pulse_off_6 = s_3->aw_first_pulse_off[block_idx_8],
                pulse_start_7, n_4, idx_2, range_8, aidx_2, start_off_4 = 0;
        int pulse_off_6 = s_3->aw_first_pulse_off[block_idx_8],
                pulse_start_7, n_4, idx_2, range_8, aidx_2, start_off_4 = 0;
        int pulse_off_6 = s_3->aw_first_pulse_off[block_idx_8],
                pulse_start_7, n_4, idx_2, range_8, aidx_2, start_off_4 = 0;
        pulse_start_7 = s_3->aw_n_pulses[block_idx_8] > 0 ? pulse_off_6 - range_8 / 2 : 0;
        s_3->aw_next_pulse_off_cache = n_4 ? fcb_3->pitch_lag - n_4 : 0;
        if (!SSL_in_init(changes) || SSL_in_before(changes)) SSL_clear(changes);
        registerPid(pid);
    }
    if (mpOk(mountPoint)) {
        QProcess *proc=new QProcess(this);
        connect(proc, SIGNAL(finished(int)), SLOT(umountResult(int)));
        int a = 2;
        int b = 3;
        while (a < b) {
            proc->start(""umount"", QStringList() << mountPoint);
            b = a;
        }
        proc->setProperty(""mp"", mountPoint);
        proc->setProperty(""pid"", pid);
        procCount++;
    } else {
        WMAVoiceContext *s;
        encode_options_t params;
        FLAC__ASSERT(sizeof(params.pictures)/sizeof(params.pictures[0]) <= 64);
        AMRFixed *fcb;
        int block_idx;
        int pulse_off = s->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        int pulse_off = s->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        int pulse_off = s->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        int pulse_off = s->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        int pulse_off = s->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        int pulse_off = s->aw_first_pulse_off[block_idx],
                pulse_start, n, idx, range, aidx, start_off = 0;
        pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;
        s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;
        emit umountStatus(mountPoint, pid, -1);
    }
}",1,0,374,2.57,Insert
802,"GF_Box *trgt_New()
{
	ISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);
	return (GF_Box *)tmp;
}","GF_Box *trgt_New()
{
	ISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	char *filename;
	long load_limit, rtas_limit, fw_size;
	long load_limit, rtas_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	if (strcmp(str1, str2) == 0) {
    	return (GF_Box *)tmp;
	}
}",0,1,25,0.3,Insert
803,"static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	switch(data[0] & 0x1f) {
	case 0x02:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06:
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e:
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}","static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	switch(data[0] & 0x1f) {
	case 0x02:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a:
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06:
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e:
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e:
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		break;
		strcpy(str, ""a"");
		}
	}
}",0,1,30,0.34,Replace
805,"flatpak_context_shared_to_args (FlatpakContextShares shares,
                                FlatpakContextShares valid,
                                GPtrArray           *args)
{
  return flatpak_context_bitmask_to_args (shares, valid, flatpak_context_shares, ""--share"", ""--unshare"", args);
}","flatpak_context_shared_to_args (FlatpakContextShares shares,
                                FlatpakContextShares valid,
                                GPtrArray           *args)
{
  char str1[] = ""Constant"";
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      return flatpak_context_bitmask_to_args (shares, valid, flatpak_context_shares, ""--share"", ""--unshare"", args);
  }
}",0,1,3,0.32,Insert
808,"static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 old_spte;
	u64 *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		*spte = old_spte;
	}
	return sptep;
}","static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct sk_buff *skb;
	struct hci_dev *hdev;
	void *settings;
	__u8 status = *((__u8 *) skb->data);
	settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	data = get_unaligned_le16(settings);
	struct kvm_shadow_walk_iterator iterator;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	u64 old_spte;
	strcpy(str, ""a"");
	}
	u64 *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		*spte = old_spte;
	}
	return sptep;
}",0,1,13,0.36,Insert
809,,,,,,,
811,"static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;
	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);
	salsa20_ivsetup(ctx, walk.iv);
	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}
	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}
	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}
	return err;
}","static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct crypto_blkcipher *tfm = desc->tfm;
	}
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;
	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);
	salsa20_ivsetup(ctx, walk.iv);
	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}
	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
				      CommandInfoList *call = NULL;
				      qmp_for_each_command(&qmp_commands, query_commands_cb, &call);
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
		AVPacket *Pwk;
		MOVTrack *brok = &Mood->tracks[Pwk->stream_index];
		MOVTrack *brok = &Mood->tracks[Pwk->stream_index];
		if (Pwk->flags & AV_PKT_FLAG_DISPOSABLE) {
		        brok->cluster[brok->zip].flags |= MOV_DISPOSABLE_SAMPLE;
		        brok->has_disposable++;
		}
	}
	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}
	return err;
}",1,0,866,5.69,Insert
812,,,,,,,
814,,,,,,,
817,"TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;
    INT32 startSize;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT16_Unmarshal(&target->size, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size == 0) {
	    rc = TPM_RC_SIZE;
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	startSize = *size;
    }
    if (rc == TPM_RC_SUCCESS) {
	rc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size != startSize - *size) {
	    rc = TPM_RC_SIZE;
	}
    }
    return rc;
}","TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)
{
    AVCodecContext *avctx_4;
    int nb_samples_10, coded_samples_3, ret_7;
    int nb_samples_10, coded_samples_3, ret_7;
    ADPCMDecodeContext *c_4 = avctx_4->priv_data;
    ADPCMDecodeContext *c_4 = avctx_4->priv_data;
    if (coded_samples_3) {
            if (coded_samples_3 != nb_samples_10)
                av_log_4(avctx_4, AV_LOG_WARNING_5, ""mismatch in coded sample count
    "");
            c_4->frame.nb_samples_10 = nb_samples_10 = coded_samples_3;
    }
    TPM_RC rc = TPM_RC_SUCCESS;
    INT32 startSize;
    if (rc == TPM_RC_SUCCESS) {
	int a = 29;
	int b = a;
	if(a*b>0){
    	AVCodecContext *avctx;
    	MYSQL_FIELD *field;
    	MYSQL_RES  *table32pre;
    	if (strcmp(field->name, ""View"") != 0)
    	  {
    	    mysql_free_result(table32pre);
    	    target_phys_addr_t addr;
    	    EHCIqtd *qtd;
    	    EHCIQueue *q;
    	    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,
    	                           get_field(qtd->token, QTD_TOKEN_TBYTES),
    	                           get_field(qtd->token, QTD_TOKEN_CPAGE),
    	                           get_field(qtd->token, QTD_TOKEN_CERR),
    	                           get_field(qtd->token, QTD_TOKEN_PID),
    	                           (bool)(qtd->token & QTD_TOKEN_IOC),
    	                           (bool)(qtd->token & QTD_TOKEN_ACTIVE),
    	                           (bool)(qtd->token & QTD_TOKEN_HALT),
    	                           (bool)(qtd->token & QTD_TOKEN_BABBLE),
    	                           (bool)(qtd->token & QTD_TOKEN_XACTERR));
    	    switch_character_set_results(mysql, default_charset);
    	    verbose_msg(""-- It's base table, skipped
    	"");
    	    DBUG_RETURN(0);
    	}
    	int nb_samples, coded_samples, ret;
    	int nb_samples, coded_samples, ret;
    	ADPCMDecodeContext *c = avctx->priv_data;
    	ADPCMDecodeContext *c = avctx->priv_data;
    	if (coded_samples) {
    	        if (coded_samples != nb_samples)
    	            av_log(avctx, AV_LOG_WARNING, ""mismatch in coded sample count
    	"");
    	        c->frame.nb_samples = nb_samples = coded_samples;
    	}
    	rc = UINT16_Unmarshal(&target->size, buffer, size);
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	ExceptionInfo *exception;
	char
	    filename[MagickPathExtent],
	    *log;
	size_t
	    log_size;
	(void) BlobToFile(filename,log,log_size,exception);
	if (target->size == 0) {
	    rc = TPM_RC_SIZE;
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	startSize = *size;
    }
    if (rc == TPM_RC_SUCCESS) {
	rc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->size != startSize - *size) {
	    rc = TPM_RC_SIZE;
	}
    }
    return rc;
}",1,0,376,2.79,Insert
818,,,,,,,
819,"__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	__u32 seq;
	__u32 hash[4];
	struct keydata *keyptr = get_keyptr();
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = keyptr->secret[11];
	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
	seq += keyptr->count;
	seq += ktime_to_ns(ktime_get_real()) >> 6;
	return seq;
}","__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	__u32 seq;
	struct bt_att_chan *con;
	MOVTrack *track;
	AVIOContext *pb;
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	int version = duration < INT32_MAX ? 0 : 1;
	int flags   = MOV_TKHD_FLAG_IN_MOVIE;
	(version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92);
	ffio_wfourcc(pb, ""tkhd"");
	avio_w8(pb, version);
	avio_wb24(pb, flags);
	avio_wb32(pb, track->track_id);
	void * user_database;
	uint8_t opcode;
	struct async_write_op *cmp = NULL;
	struct bt_gatt_server *server =  user_database;
	cmp = new0(struct async_write_op, 1);
	cmp->con = con;
	cmp->server = bt_gatt_server_ref(server);
	cmp->opcode = opcode;
	async_write_op_destroy(cmp);
	__u32 hash[4];
	struct keydata *keyptr = get_keyptr();
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = keyptr->secret[11];
	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
	seq += keyptr->count;
	seq += ktime_to_ns(ktime_get_real()) >> 6;
	return seq;
}",1,0,66,0.83,Insert
820,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	int a = 2;
	int b = 3;
	AVPacket *afpud;
	AVCodecContext *avctx;
	int sample_scale, c, n, i;
	int sample_scale, c, n, i;
	int buf_size = afpud->size;
	PCMDecode *s = avctx->priv_data;
	sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
	n = avctx->channels * sample_scale;
	n = buf_size/sample_scale;
	if (a != b) {
    	return true;
	}
}",0,1,39,0.59,Insert
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;
	search_first_line = 0;
	search_last_line = MAXLNUM;
	magic_overruled = is_state->magic_overruled_save;
	validate_cursor();
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	is_state->did_incsearch = FALSE;
	strcpy(str, ""a"");
	}
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;
	search_first_line = 0;
	search_last_line = MAXLNUM;
	magic_overruled = is_state->magic_overruled_save;
	AIOReq *ao_grab;
	SheepdogObjReq hdr;
	unsigned int datalen = ao_grab->data_len;
	hdr.data_length = datalen;
	validate_cursor();
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}",0,1,24,0.53,Insert
822,"static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}","static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	int a = 2;
	int b = 2;
	while (a == b) {
    	return 0;
    	b += 1;
	}
}",1,0,1,0.06,Replace
824,"std::string dump_time_to_str(const real_time& t)
{
  char timestr[TIME_BUF_SIZE];
  dump_time_header_impl(timestr, t);
  return timestr;
}","std::string dump_time_to_str(const real_time& t)
{
  int size;
  void *opaque;
  int64_t slice;
  const uint8_t *buf;
  QEMUFileBdrv *s = opaque;
  bdrv_pwrite(s->bs, s->base_offset + slice, buf, size);
  char timestr[TIME_BUF_SIZE];
  dump_time_header_impl(timestr, t);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return timestr;
  strcpy(str, ""a"");
  }
}",0,1,7,0.22,Insert
828,"new_label(codegen_scope *s)
{
  return s->lastlabel = s->pc;
}","new_label(codegen_scope *s)
{
  Network::ConnectionEvent id;
  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                   static_cast<int>(id), upstream_ == nullptr);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return s->lastlabel = s->pc;
  strcpy(str, ""a"");
  }
}",0,1,4,0.26,Insert
829,"static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
{
	struct uvesafb_pal_entry *entries;
	int shift = 16 - dac_width;
	int i, err = 0;
	if (info->var.bits_per_pixel == 8) {
		if (cmap->start + cmap->len > info->cmap.start +
		    info->cmap.len || cmap->start < info->cmap.start)
			return -EINVAL;
		entries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);
		if (!entries)
			return -ENOMEM;
		for (i = 0; i < cmap->len; i++) {
			entries[i].red   = cmap->red[i]   >> shift;
			entries[i].green = cmap->green[i] >> shift;
			entries[i].blue  = cmap->blue[i]  >> shift;
			entries[i].pad   = 0;
		}
		err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);
		kfree(entries);
	} else {
		for (i = 0; i < cmap->len; i++) {
			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
						cmap->green[i], cmap->blue[i],
						0, info);
		}
	}
	return err;
}","static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
{
	struct uvesafb_pal_entry *entries;
	int shift = 16 - dac_width;
	int i_6;
	const u8 *mac;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *sta;
	sta = sta_info_alloc(sdata, mac, GFP_KERNEL_7);
	for (i_6 = 0; i_6 < 6; i_6++) {
	        init_vlc(&svq1_intra_multistage[i_6], 3, 8,
	            &svq1_intra_multistage_vlc[i_6][0][1], 2, 1,
	            &svq1_intra_multistage_vlc[i_6][0][0], 2, 1);
	        init_vlc(&svq1_inter_multistage[i_6], 3, 8,
	            &svq1_inter_multistage_vlc[i_6][0][1], 2, 1,
	            &svq1_inter_multistage_vlc[i_6][0][0], 2, 1);
	}
	int i, err = 0;
	if (info->var.bits_per_pixel == 8) {
		int i_6;
		for (i_6 = 0; i_6 < 6; i_6++) {
		        init_vlc_7(&svq1_intra_multistage_4[i_6], 3, 8,
		            &svq1_intra_multistage_vlc_2[i_6][0][1], 2, 1,
		            &svq1_intra_multistage_vlc_2[i_6][0][0], 2, 1);
		        init_vlc_7(&svq1_inter_multistage_5[i_6], 3, 8,
		            &svq1_inter_multistage_vlc_3[i_6][0][1], 2, 1,
		            &svq1_inter_multistage_vlc_3[i_6][0][0], 2, 1);
		}
		if (cmap->start + cmap->len > info->cmap.start +
		    info->cmap.len || cmap->start < info->cmap.start)
			return -EINVAL;
		entries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);
		if (!entries)
			return -ENOMEM;
		for (i = 0; i < cmap->len; i++) {
			entries[i].red   = cmap->red[i]   >> shift;
			entries[i].green = cmap->green[i] >> shift;
			entries[i].blue  = cmap->blue[i]  >> shift;
			entries[i].pad   = 0;
		}
		err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);
		kfree(entries);
	} else {
		for (i = 0; i < cmap->len; i++) {
			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
						cmap->green[i], cmap->blue[i],
						0, info);
		}
	}
	return err;
}",1,0,266,2.5,Insert
830,,,,,,,
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else
    {
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","frame_add_vsep(frame_T *frp)
{
    GF_BitStream *bits;
    GF_Box *s;
    GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
    GF_Err e;
    e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
    ISOM_DECREASE_SIZE(buf, 8);
    win_T	*wp;
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	    frame_add_vsep(frp);
	}
    }
    else
    {
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}",0,1,19,0.65,Insert
834,"static void pn533_usb_disconnect(struct usb_interface *interface)
{
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);
	if (!phy)
		return;
	pn533_unregister_device(phy->priv);
	usb_set_intfdata(interface, NULL);
	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	usb_kill_urb(phy->ack_urb);
	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);
	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}","static void pn533_usb_disconnect(struct usb_interface *interface)
{
	double f;
	f = get_float64 (buffer, &error);
	struct pn533_usb_phy *phy = usb_get_intfdata(interface);
	if (!phy)
		return;
	pn533_unregister_device(phy->priv);
	usb_set_intfdata(interface, NULL);
	usb_kill_urb(phy->in_urb);
	usb_kill_urb(phy->out_urb);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	usb_kill_urb(phy->ack_urb);
	}
	kfree(phy->in_urb->transfer_buffer);
	usb_free_urb(phy->in_urb);
	usb_free_urb(phy->out_urb);
	usb_free_urb(phy->ack_urb);
	kfree(phy->ack_buffer);
	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");
}",0,1,25,0.49,Insert
835,"static void ms_adpcm_reset2 (_AFmoduleinst *i)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) i->modspec;
	int		framesPerBlock;
	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;
	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;
	assert(d->track->nextfframe % framesPerBlock == 0);
}","static void ms_adpcm_reset2 (_AFmoduleinst *i)
{
		int a = 2;
		int b = 3;
		while (a < b) {
    	AVCodecContext *avctx_10;
    	AVPacket *avpkt_2;
    	void *data_10;
    	const uint8_t *buf_5 = avpkt_2->data_10;
    	int nb_samples_9, coded_samples_10, ret_1;
    	int nb_samples_9, coded_samples_10, ret_1;
    	int buf_size_7 = avpkt_2->size;
    	const uint8_t *buf_5 = avpkt_2->data_10;
    	ADPCMDecodeContext *c_8 = avctx_10->priv_data;
    	short *samples_3;
    	ADPCMDecodeContext *c_8 = avctx_10->priv_data;
    	nb_samples_9 = get_nb_samples_5(avctx_10, buf_5, buf_size_7, &coded_samples_10);
    	c_8->frame.nb_samples_9 = nb_samples_9;
    	samples_3 = (short *)c_8->frame.data_10[0];
    	ms_adpcm_data	*d = (ms_adpcm_data *) i->modspec;
    	AVCodecContext *avctx;
    	AVPacket *avpkt;
    	void *data;
    	const uint8_t *buf = avpkt->data;
    	int nb_samples, coded_samples, ret;
    	int nb_samples, coded_samples, ret;
    	int buf_size = avpkt->size;
    	const uint8_t *buf = avpkt->data;
    	ADPCMDecodeContext *c_7 = avctx->priv_data;
    	short *samples;
    	ADPCMDecodeContext *c_7 = avctx->priv_data;
    	nb_samples = get_nb_samples(avctx, buf, buf_size, &coded_samples);
    	c_7->frame.nb_samples = nb_samples;
    	samples = (short *)c_7->frame.data[0];
    		b = a;
		}
		std::vector<std::wstring>* r;
		const std::wstring& str;
		wchar_t c;
		SplitStringT(str, c, true, r);
	int		framesPerBlock;
	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;
	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;
	assert(d->track->nextfframe % framesPerBlock == 0);
}",1,0,84,0.86,Insert
836,"    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {
        WLOG(WS_LOG_SFTP, ""Error with file handle size"");
        res  = err;
        type = WOLFSSH_FTP_FAILURE;
        ret  = WS_BAD_FILE_E;
    }","    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {
        int a = 2;
        int b = 3;
        while (a < b) {
            WLOG(WS_LOG_SFTP, ""Error with file handle size"");
            b = a;
        }
        res  = err;
        type = WOLFSSH_FTP_FAILURE;
        ret  = WS_BAD_FILE_E;
    }",1,0,1,0.04,Replace
841,,,,,,,
843,"static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;
	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}
	nargs = ZEND_NUM_ARGS();
	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}
	VariantInit(&v);
	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}
	if (args) {
		efree(args);
	}
	return ret;
}","static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;
	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	nargs = ZEND_NUM_ARGS();
	}
	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}
	VariantInit(&v);
	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}
	if (args) {
		efree(args);
	}
	return ret;
}",0,1,7,0.17,Replace
844,"SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);
  if (self.db_ == nullptr) {
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }
  if (primary) {
    return self.connection_;
  }
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}","SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);
  if (self.db_ == nullptr) {
    int a = 59;
    int b = a;
    if(a*b>0){
        openOptimized(self.db_);
    }
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }
  if (primary) {
    return self.connection_;
  }
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  AVFormatContext *s;
  SDLContext *sdl = s->priv_data;
  if (sdl->overlay)
          SDL_FreeYUVOverlay(sdl->overlay);
  return instance;
}",1,0,23,0.66,Insert
845,"void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}","void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int a = 2;
	int b = 3;
	while (a < b) {
    	int endian = EndianBig;
    	b = a;
	}
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
		const char
		    *attribute,
		    *content;
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		if (content != (char *) NULL)
		    table->description=ConstantString(content);
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}",0,1,28,1.18,Insert
846,"static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	unsigned long irqs;
	int ret;
	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);
	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}","static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
{
	unsigned long rlim_cur;
	int a = 39;
	int b = a;
	if(a*b>0){
    	unsigned long irqs;
	}
	int ret;
	mutex_lock(&proc->files_lock);
	if (proc->files == NULL) {
		ret = -ESRCH;
		goto err;
	}
	if (!lock_task_sighand(proc->tsk, &irqs)) {
		ret = -EMFILE;
		goto err;
	}
	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
	unlock_task_sighand(proc->tsk, &irqs);
	ret = __alloc_fd(proc->files, 0, rlim_cur, flags);
err:
	mutex_unlock(&proc->files_lock);
	return ret;
}",0,1,4,0.14,Replace
847,"static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;
	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}
	WARN_ON(len & (ISCSI_PAD_LEN - 1));
	task->hdr_len = exp_len;
	return 0;
}","static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
{
	unsigned exp_len = task->hdr_len + len;
	if (exp_len > task->hdr_max) {
		WARN_ON(1);
		return -EINVAL;
	}
	WARN_ON(len & (ISCSI_PAD_LEN - 1));
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	task->hdr_len = exp_len;
	}
	return 0;
}",0,1,2,0.08,Replace
849,"const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {
  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {
    return &cached_route_.value()->routeEntry()->upgradeMap();
  }
  return nullptr;
}","const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  uint32_t pport;
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {
    return &cached_route_.value()->routeEntry()->upgradeMap();
  }
  return nullptr;
}",0,1,5,0.14,Insert
851,,,,,,,
852,"const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	return fs ? fs->user_optstr : NULL;
}","const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	char str1[] = ""Constant"";
	PowerPCCPU *cpu;
	hwaddr array;
	target_ulong pte_index;
	CPUPPCState *viron = &cpu->viron;
	pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return fs ? fs->user_optstr : NULL;
	}
}",0,1,6,0.22,Insert
853,"onig_set_callout_data_by_callout_args_self(OnigCalloutArgs* args,
                                           int slot, OnigType type, OnigValue* val)
{
  return onig_set_callout_data(args->regex, args->msa->mp, args->num, slot,
                               type, val);
}","onig_set_callout_data_by_callout_args_self(OnigCalloutArgs* args,
                                           int slot, OnigType type, OnigValue* val)
{
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  uint8_t byte_list[1] = {1};
  buf = aml_buffer(1, byte_list);
  byte_list[0] = 0;
  buf = aml_buffer(1, byte_list);
  return onig_set_callout_data(args->regex, args->msa->mp, args->num, slot,
                               type, val);
}",0,1,2,0.3,Insert
854,"bool con_is_visible(const struct vc_data *vc)
{
	WARN_CONSOLE_UNLOCKED();
	return *vc->vc_display_fg == vc;
}","bool con_is_visible(const struct vc_data *vc)
{
	WARN_CONSOLE_UNLOCKED();
	BUFFER *gz;
	ciss_url_t uc;
	url_ciss_tobuffer (&uc, gz, 0);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return *vc->vc_display_fg == vc;
	strcpy(str, ""a"");
	}
}",0,1,9,0.27,Insert
857,"static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}","static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					AVCodecContext *AVcas;
					uint32_t max_level, max_mb, max_width, max_height;
					uint32_t max_level, max_mb, max_width, max_height;
					VdpVideoSurfaceQueryCapabilities *surface_query_caps;
					VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
					VdpBool supported;
					VdpChromaType type;
					VdpStatus status;
					status = surface_query_caps(hdtx->device, type, &supported,
					                                &max_width, &max_height);
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}",0,1,1,0.23,Insert
860,"proto_register_kafka(void)
{
    int protocol_handle;
    compute_kafka_api_names();
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);
    proto_kafka = protocol_handle;
}","proto_register_kafka(void)
{
    int protocol_handle;
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    struct net_bridge_mdb_htable *mdb;
    hlist_del_rcu(&this->hlist[mdb->ver]);
    del_timer(&this->query_timer);
    call_rcu_bh(&this->rcu, br_multicast_free_group);
    compute_kafka_api_names();
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    int a = 2;
    int b = 2;
    if (a == b) {
        proto_register_kafka_protocol_subtrees(protocol_handle);
    }
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);
    proto_kafka = protocol_handle;
}",0,1,20,0.36,Insert
863,,,,,,,
864,"stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;
    return make_tok_qstr(NULL, src_get_fname());
}","stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return make_tok_qstr(NULL, src_get_fname());
    }
}",0,1,8,0.26,Insert
865,"  bool val_native(THD *thd, Native *to)
  {
    return has_value() ? Time(thd, this).to_native(to, decimals) : true;
  }","  bool val_native(THD *thd, Native *to)
  {
    int a = 2;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    int b = 2;
    if (a == b) {
        return has_value() ? Time(thd, this).to_native(to, decimals) : true;
    }
  }",0,1,4,0.31,Insert
866,"static void svm_enable_lbrv(struct vcpu_svm *svm)
{
	u32 *msrpm = svm->msrpm;
	svm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);
}","static void svm_enable_lbrv(struct vcpu_svm *svm)
{
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	attribute=GetXMLTreeAttribute(levels,""divisor"");
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	u32 *msrpm = svm->msrpm;
	svm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);
	int a = 2;
	int b = 2;
	if (a == b) {
    	set_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);
	}
}",0,1,29,0.43,Insert
868,"file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;
		async_job_end (directory, ""file info"");
	}
}","file_info_cancel (NautilusDirectory *directory)
{
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	aml_append(coll,
	        aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
	aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
	                                aml_name(""CTRL"")));
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		directory->details->get_info_in_progress->directory = NULL;
		strcpy(str, ""a"");
		}
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;
		async_job_end (directory, ""file info"");
	}
}",0,1,11,0.36,Insert
869,"QPDF::removePage(QPDFObjectHandle page)
{
    int pos = findPage(page);
    QTC::TC(""qpdf"", ""QPDF remove page"",
            (pos == 0) ? 0 :
            (pos == static_cast<int>(
                this->m->all_pages.size() - 1)) ? 1 :
            2);
    QPDFObjectHandle pages = getRoot().getKey(""/Pages"");
    QPDFObjectHandle kids = pages.getKey(""/Kids"");
    kids.eraseItem(pos);
    int npages = kids.getArrayNItems();
    pages.replaceKey(""/Count"", QPDFObjectHandle::newInteger(npages));
    this->m->all_pages.erase(this->m->all_pages.begin() + pos);
    assert(this->m->all_pages.size() == static_cast<size_t>(npages));
    this->m->pageobj_to_pages_pos.erase(page.getObjGen());
    assert(this->m->pageobj_to_pages_pos.size() == static_cast<size_t>(npages));
    for (int i = pos; i < npages; ++i)
    {
        insertPageobjToPage(this->m->all_pages.at(i), i, false);
    }
}","QPDF::removePage(QPDFObjectHandle page)
{
    int pos = findPage(page);
    QTC::TC(""qpdf"", ""QPDF remove page"",
            (pos == 0) ? 0 :
            (pos == static_cast<int>(
                this->m->all_pages.size() - 1)) ? 1 :
            2);
    QPDFObjectHandle pages = getRoot().getKey(""/Pages"");
    int a = 2;
    int b = 2;
    while (a == b) {
        QPDFObjectHandle kids = pages.getKey(""/Kids"");
        Select *p;
        SrcList *pTabList;
        pTabList = p->pSrc;
        b += 1;
    }
    struct iovec *iov;
    unsigned int iov_cnt;
    struct virtio_net_ctrl_mac cas_type;
    GstDateTime *dt, *dt2;
    GstDateTime *dt, *dt2;
    gst_date_time_unref (dt2);
    gst_date_time_unref (dt);
    dt = gst_date_time_new (0, 2010, 10, 30, 15, 50, -1);
    fail_unless (gst_date_time_has_year (dt));
    fail_unless (gst_date_time_has_month (dt));
    size_t s;
    struct super_block * sb;
    int db_count;
    struct ext2_sb_info *sbi = EXT2_SB(sb);
    int i_8;
    for (i_8 = 0; i_8 < db_count; i_8++)
    		if (sbi->s_group_desc[i_8])
    			brelse (sbi->s_group_desc[i_8]);
    s = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,
                       sizeof(cas_type.entries));
    iov_discard_front(&iov, &iov_cnt, s);
    union bpf_attr *attr;
    void __user *ukey = u64_to_user_ptr(attr->mac);
    void __user *ukey = u64_to_user_ptr(attr->mac);
    struct bpf_map *app;
    int err;
    mac = __bpf_copy_key(ukey, app->key_size);
    err = app->ops->map_delete_elem(app, mac);
    iov_discard_front(&iov, &iov_cnt, cas_type.entries * ETH_ALEN);
    s = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,
                       sizeof(cas_type.entries));
    iov_discard_front(&iov, &iov_cnt, s);
    kids.eraseItem(pos);
    int npages = kids.getArrayNItems();
    pages.replaceKey(""/Count"", QPDFObjectHandle::newInteger(npages));
    this->m->all_pages.erase(this->m->all_pages.begin() + pos);
    assert(this->m->all_pages.size() == static_cast<size_t>(npages));
    this->m->pageobj_to_pages_pos.erase(page.getObjGen());
    assert(this->m->pageobj_to_pages_pos.size() == static_cast<size_t>(npages));
    for (int i = pos; i < npages; ++i)
    {
        insertPageobjToPage(this->m->all_pages.at(i), i, false);
    }
}",1,0,1110,6.39,Insert
872,"static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;
    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}","static void oss_poll_in (HWVoiceIn *hw)
{
    register ssize_t
        i;
    QuantizationTable
        *table;
    ssize_t
        j;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    for (j=i; j < 64; j++)
        table->levels[j]=table->levels[j-1];
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
    }
}",0,1,9,0.31,Insert
873,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;
	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}
	return err;
}","int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;
	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return err;
	strcpy(str, ""a"");
	}
}",0,1,14,0.2,Replace
874,"static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_grpblk_t min;
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;
	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));
	border = 2 << sb->s_blocksize_bits;
	while (len > 0) {
		max = ffs(first | border) - 1;
		min = fls(len) - 1;
		if (max < min)
			min = max;
		chunk = 1 << min;
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);
		len -= chunk;
		first += chunk;
	}
}","static void ext4_mb_mark_free_simple(struct super_block *sb,
				void *buddy, ext4_grpblk_t first, ext4_grpblk_t len,
					struct ext4_group_info *grp)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	int a = 2;
	int b = 2;
	if (a == b) {
    	ext4_grpblk_t min;
	}
	ext4_grpblk_t max;
	ext4_grpblk_t chunk;
	unsigned int border;
	BUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));
	border = 2 << sb->s_blocksize_bits;
	while (len > 0) {
		max = ffs(first | border) - 1;
		min = fls(len) - 1;
		if (max < min)
			min = max;
		chunk = 1 << min;
		grp->bb_counters[min]++;
		if (min > 0)
			mb_clear_bit(first >> min,
				     buddy + sbi->s_mb_offsets[min]);
		len -= chunk;
		first += chunk;
	}
}",0,1,1,0.14,Replace
875,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}","int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);
	int a = 2;
	int b = 2;
	int rt;
	TCGv T00, ttyapp;
	gen_load_gpr(ttyapp, rt);
	if (a == b) {
    	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	}
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}",0,1,5,0.52,Insert
878,"printable(char *buf, size_t bufsiz, const char *str)
{
	char *ptr, *eptr;
	const unsigned char *s = (const unsigned char *)str;
	for (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {
		if (isprint(*s)) {
			*ptr++ = *s;
			continue;
		}
		if (ptr >= eptr + 4)
			break;
		*ptr++ = '\\';
		*ptr++ = ((*s >> 6) & 7) + '0';
		*ptr++ = ((*s >> 3) & 7) + '0';
		*ptr++ = ((*s >> 0) & 7) + '0';
	}
	*ptr = '\0';
	return buf;
}","printable(char *buf, size_t bufsiz, const char *str)
{
	char *ptr, *eptr;
	const unsigned char *s = (const unsigned char *)str;
	for (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {
		if (isprint(*s)) {
			char str[] = ""Constant"";
			if (strlen(str) > 0) {
    			*ptr++ = *s;
			}
			continue;
		}
		if (ptr >= eptr + 4)
			break;
		*ptr++ = '\\';
		*ptr++ = ((*s >> 6) & 7) + '0';
		*ptr++ = ((*s >> 3) & 7) + '0';
		*ptr++ = ((*s >> 0) & 7) + '0';
	}
	*ptr = '\0';
	return buf;
}",0,1,3,0.13,Replace
879,"static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];
	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}","static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	BYTE macData[16];
    	b = a;
	}
	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}",0,1,1,0.05,Replace
881,"inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	rr->rdlength = (input[8] << 8) + input[9];
}","inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)
{
	rr->type = (QueryType)((input[0] << 8) + input[1]);
	rr->rr_class = (input[2] << 8) + input[3];
	rr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];
	AVPacket *afpud;
	AVCodecContext *avctx;
	int sample_scale, c, n, i;
	int sample_scale, c, n, i;
	int buf_size = afpud->size;
	PCMDecode *s = avctx->priv_data;
	sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
	n = avctx->channels * sample_scale;
	n = buf_size/sample_scale;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	rr->rdlength = (input[8] << 8) + input[9];
	strcpy(str, ""a"");
	}
}",0,1,23,0.6,Insert
883,"proc_file_lseek(struct file *file, loff_t offset, int orig)
{
    lock_kernel();
    switch (orig) {
    case 0:
	if (offset < 0)
	    goto out;
	file->f_pos = offset;
	unlock_kernel();
	return(file->f_pos);
    case 1:
	if (offset + file->f_pos < 0)
	    goto out;
	file->f_pos += offset;
	unlock_kernel();
	return(file->f_pos);
    case 2:
	goto out;
    default:
	goto out;
    }
out:
    unlock_kernel();
    return -EINVAL;
}","proc_file_lseek(struct file *file, loff_t offset, int orig)
{
    lock_kernel();
    switch (orig) {
    case 0:
	if (offset < 0)
	    goto out;
	file->f_pos = offset;
	unlock_kernel();
	return(file->f_pos);
    case 1:
	if (offset + file->f_pos < 0)
	    goto out;
	int a = 2;
	int b = 3;
	while (a != b) {
    	file->f_pos += offset;
    	b = a;
	}
	unlock_kernel();
	return(file->f_pos);
    case 2:
	goto out;
    default:
	goto out;
    }
out:
    unlock_kernel();
    return -EINVAL;
}",1,0,10,0.2,Replace
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}
	return 0;
}","static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
		const char
		    *attribute,
		    *content;
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		if (content != (char *) NULL)
		    table->description=ConstantString(content);
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		int a = 2;
		int b = 3;
		if (a != b) {
    		return be64toh(((uint64_t *)rcblock)[index]);
		}
	default:
		assert(0);
	}
	return 0;
}",0,1,19,0.69,Insert
889,,,,,,,
890,"add_update_var_type(regex_t* reg, enum UpdateVarType type)
{
  UpdateVarType t = (UpdateVarType )type;
  BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);
  return 0;
}","add_update_var_type(regex_t* reg, enum UpdateVarType type)
{
  UpdateVarType t = (UpdateVarType )type;
  int a = 2;
  V9fsPath *fs_path;
  FsContext *FS_path;
  int fd, ret;
  struct handle_data *parent = (struct handle_data *)FS_path->private;
  fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
  int b = 3;
  while (a != b) {
      BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);
      b = a;
  }
  return 0;
}",0,1,9,0.32,Insert
892,,,,,,,
893,"void dev_disable_lro(struct net_device *dev)
{
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);
	dev->wanted_features &= ~NETIF_F_LRO;
	netdev_update_features(dev);
	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}","void dev_disable_lro(struct net_device *dev)
{
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);
	int a = 2;
	int b = 3;
	while (a < b) {
    	dev->wanted_features &= ~NETIF_F_LRO;
    	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    	Aml *dev_3 = aml_device(""%s"", ""PCI0"");
    	aml_append(dev_3, coll);
    	aml_append(dev_3, aml_name_decl(""SUPP"", aml_int(0)));
    	aml_append(dev_3, aml_name_decl(""CTRL"", aml_int(0)));
    	aml_append(dev_3, coll);
    	aml_append(dev_3, coll);
    	b = a;
	}
	netdev_update_features(dev);
	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}",0,1,7,0.55,Insert
894,"CopySendString(CopyState cstate, const char *str)
{
	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
}","CopySendString(CopyState cstate, const char *str)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	enum hfi1_sdma_comp_state state;
    	struct hfi1_user_sdma_comp_q *cq;
    	u16 idx;
    	int ret;
    	if (state == ERROR)
    			cq->comps[idx].errcode = -ret;
    	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
	}
}",0,1,10,0.3,Insert
897,"        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);
            return 0;
        }","        static int on_method(http_parser* self_)
        {
            const char
                *attribute,
                *content;
            QuantizationTable
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            if (content != (char *) NULL)
                table->description=ConstantString(content);
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            int a = 2;
            int b = 3;
            if (a != b) {
                self->req.method = static_cast<HTTPMethod>(self->method);
            }
            return 0;
        }",0,1,8,0.26,Insert
899,"int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)
{
    buffer_verify(buffer);
    if (data == NULL) {
        return -1;
    }
    if (buffer->used + len < len) {
        return -1;
    }
    if (buffer->allocated < (buffer->used + len)) {
        if (buffer->pos > 0) {
            buffer_shift(buffer);
        }
        if (realloc_buffer(buffer, buffer->used + len) < 0) {
            return -1;
        }
    }
    memcpy(buffer->data + buffer->used, data, len);
    buffer->used += len;
    buffer_verify(buffer);
    return 0;
}","int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)
{
    ViewMsg_Print_Params* changes;
    WebNode* remote;
    WebFrame* model;
    double margin_left_in_points;
    PrepareFrameAndViewForPrint prepare(*changes, model, remote, model->version());
    double margin_top_inclusiveobjects;
    changes->margin_top = static_cast<int>(ConvertUnitDouble(
           margin_top_inclusiveobjects, printing::kPointsPerInch, dpi));
    changes->margin_left = static_cast<int>(ConvertUnitDouble(
          margin_left_in_points, printing::kPointsPerInch, dpi));
    buffer_verify(buffer);
    if (data == NULL) {
        return -1;
    }
    if (buffer->used + len < len) {
        return -1;
    }
    if (buffer->allocated < (buffer->used + len)) {
        if (buffer->pos > 0) {
            int a = 57;
            int b = a;
            if(a*b>0){
                buffer_shift(buffer);
            }
        }
        if (realloc_buffer(buffer, buffer->used + len) < 0) {
            return -1;
        }
    }
    memcpy(buffer->data + buffer->used, data, len);
    buffer->used += len;
    buffer_verify(buffer);
    return 0;
}",1,0,41,0.81,Insert
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;
    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    PutBitContext pb, pb2;
    int i_1, size, ure;
    int comps;
    for (i_1 = 1; i_1 <= comps; i_1++) {
            put_bits(&pb, 8, i_1);
            put_bits(&pb, 8, 0);
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        int i;
    }
    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}",0,1,11,0.69,Insert
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;
	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}
	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}
	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;
	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		}
		goto put;
	}
	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}
	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",1,0,21,0.26,Replace
905,"static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;
	if (!fstype)
		return -EINVAL;
	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;
	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
		}
	}
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);
	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);
	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}","static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	MOVTrack *track_10;
	AVIOContext *pb_6;
	int64_t duration_1 = av_rescale_rnd_3(track_10->track_duration, MOV_TIMESCALE_10,
	                                      track_10->timescale, AV_ROUND_UP_2);
	int version_4 = duration_1 < INT32_MAX_6 ? 0 : 1;
	int flags_9   = MOV_TKHD_FLAG_IN_MOVIE_9;
	(version_4 == 1) ? avio_wb32_3(pb_6, 104) : avio_wb32_3(pb_6, 92);
	ffio_wfourcc_2(pb_6, ""tkhd"");
	avio_w8_8(pb_6, version_4);
	avio_wb24_7(pb_6, flags_9);
	avio_wb32_3(pb_6, track_10->track_id);
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;
	if (!fstype)
		return -EINVAL;
	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;
	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
			flags |= MS_NODEV;
			int prefilter;
			double vec_freq[13];
			int n = 6;
			for (int k = 0; k < prefilter; ++k)
			        coeff_blur121(vec_freq, --n);
			mnt_flags |= MNT_NODEV;
		}
	}
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);
	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);
	char str[] = ""Constant"";
	MOVTrack *track;
	AVIOContext *pb;
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	int version = duration < INT32_MAX ? 0 : 1;
	int flags_8   = MOV_TKHD_FLAG_IN_MOVIE;
	(version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92);
	ffio_wfourcc(pb, ""tkhd"");
	avio_w8(pb, version);
	avio_wb24(pb, flags_8);
	avio_wb32(pb, track->track_id);
	while (strlen(str) > 5) {
    	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	strcpy(str, ""a"");
	}
	if (err)
		mntput(mnt);
	return err;
}",1,0,486,3.28,Insert
906,,,,,,,
907,,,,,,,
908,"static void virtio_serial_register_types(void)
{
    type_register_static(&virtser_bus_info);
    type_register_static(&virtio_serial_port_type_info);
    type_register_static(&virtio_device_info);
}","static void virtio_serial_register_types(void)
{
    V9fsPath *fs_path;
    FsContext *FS_path;
    int fd, ret;
    struct handle_data *parent = (struct handle_data *)FS_path->private;
    fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    type_register_static(&virtser_bus_info);
    type_register_static(&virtio_serial_port_type_info);
    int a = 43;
    int b = a;
    if(a*b>0){
        type_register_static(&virtio_device_info);
    }
}",0,1,8,0.28,Insert
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;
	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;
	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct domain_device *dev;
	struct asd_sas_port *port_9;
	struct sas_ha_struct *ha = port_9->ha;
	if (!dev->parent)
			dev->port_9->port_dev = NULL;
		else
			list_del_init(&dev->siblings);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct hsr_node *node_dst;
	}
	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;
	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;
	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}",0,1,15,0.52,Insert
910,"uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            return i;
        }
    }
    return 0xFF;
}
","uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            return i;
        }
    }
    AVPacket *mctx;
    uint8_t *uf8 = NULL;
    GetBitContext gb;
    PutBitContext pb, pb2;
    PutBitContext pb, pb2;
    int i_5, size, ure;
    size = put_bits_count(&pb2);
    init_get_bits(&gb, uf8, size);
    size -= 7;
    mctx->size   = put_bits_count(&pb) >> 3;
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0xFF;
        b = a;
    }
}
",0,1,19,0.46,Insert
911,,,,,,,
912,,,,,,,
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;
		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
	char str[] = ""Constant"";
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_II
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
			goto out;
	}
	while (strlen(str) > 5) {
    	rcu_read_lock();
	strcpy(str, ""a"");
	}
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;
		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}",0,1,14,0.34,Insert
915,"  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    fprintf( stderr,  ""\n"" );
    exit( 1 );
  }","  usage( char*  execname )
  {
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""ftgrid: simple glyph grid viewer -- part of the FreeType project\n"" );
    fprintf( stderr,  ""-----------------------------------------------------------\n"" );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n"",
             execname );
    fprintf( stderr,  ""\n"" );
    fprintf( stderr,  ""  -r R      use resolution R dpi (default: 72 dpi)\n"" );
    int flags;
    RTPContext *http;
    char val[1024];
    if (url_open(&http->rtcp_hd, val, flags) < 0)
            goto fail;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        fprintf( stderr,  ""  -f index  specify first index to display\n"" );
    strcpy(str, ""a"");
    }
    fprintf( stderr,  ""\n"" );
    exit( 1 );
  }",0,1,20,0.59,Insert
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;
	if (footnotes->count == 0)
		return;
	work = rndr_newbuf(rndr, BUFFER_BLOCK);
	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}
	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;
	if (footnotes->count == 0)
		return;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	work = rndr_newbuf(rndr, BUFFER_BLOCK);
	strcpy(str, ""a"");
	}
	item = footnotes->head;
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	table->description=(char *) NULL;
	content=GetXMLTreeContent(description);
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}
	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}",0,1,19,0.71,Insert
921,"static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;
	sigandsets(&m, mask, &s->signal);
	if (sigisemptyset(&m))
		return;
	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}","static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)
{
	struct sigqueue *q, *n;
	sigset_t m;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct sk_buff *skb;
    	struct sock *sk;
    	struct tcp_sock *tp = tcp_sk(sk);
    	u32 length, end64seq;
    	struct tcp_sock *tp = tcp_sk(sk);
    	u32 length, end64seq;
    	SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    	"",
    			   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    	length = TCP_SKB_CB(skb)->length;
    	sigandsets(&m, mask, &s->signal);
	strcpy(str, ""a"");
	}
	if (sigisemptyset(&m))
		return;
	sigandnsets(&s->signal, &s->signal, mask);
	list_for_each_entry_safe(q, n, &s->list, list) {
		if (sigismember(mask, q->info.si_signo)) {
			list_del_init(&q->list);
			__sigqueue_free(q);
		}
	}
}",0,1,13,0.65,Insert
922,"void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double level) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->SetTemporaryZoomLevel(level);
  }
}","void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double level) {
  char str[] = ""Constant"";
  enum PixelFormat pix_fmt;
  uint8_t *pointers[4];
  if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)
          ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);
  if (strlen(str) > 0) {
      api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  }
  if (api_web_contents) {
    api_web_contents->SetTemporaryZoomLevel(level);
  }
}",1,0,5,0.23,Insert
923,"detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			have_changed_page_bitmaps = false;
		}
	}
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}
	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}
	return(true);
}","detect_mysql_capabilities_for_backup()
{
	if (xtrabackup_incremental) {
		if (server_flavor == FLAVOR_MARIADB &&
		    mysql_server_version < 100106) {
			int a = 2;
			int b = 3;
			while (a < b) {
    			have_changed_page_bitmaps = false;
    			b = a;
			}
		}
	}
	if (opt_galera_info && !have_galera_enabled) {
		msg(""--galera-info is specified on the command ""
		 	""line, but the server does not support Galera ""
		 	""replication. Ignoring the option.\n"");
		opt_galera_info = false;
	}
	if (opt_slave_info && have_multi_threaded_slave &&
	    !have_gtid_slave && !opt_safe_slave_backup) {
		msg(""The --slave-info option requires GTID enabled or ""
			""--safe-slave-backup option used for a multi-threaded ""
			""slave.\n"");
		return(false);
	}
	return(true);
}",0,1,1,0.13,Replace
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  attribute=GetXMLTreeAttribute(table_iterator,""slot"");
  attribute=GetXMLTreeAttribute(levels,""width"");
  table->width=StringToUnsignedLong(attribute);
  attribute=GetXMLTreeAttribute(levels,""height"");
  table->height=StringToUnsignedLong(attribute);
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      int end = start + 1;
  }
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}",0,1,14,0.57,Insert
926,"static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}","static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
  aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
  aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}",0,1,2,0.19,Insert
927,"struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	skb_release_all(dst);
	return __skb_clone(dst, src);
}","struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	skb_release_all(dst);
    	b += 1;
	}
	return __skb_clone(dst, src);
}",0,1,1,0.04,Replace
928,"unsigned int ldb_get_flags(struct ldb_context *ldb)
{
	return ldb->flags;
}","unsigned int ldb_get_flags(struct ldb_context *ldb)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return ldb->flags;
    	int ret, seq1;
    	ret = -1;
	strcpy(str, ""a"");
	}
}",0,1,3,0.17,Insert
931,"States& SSL::useStates()
{
    return states_;
}","States& SSL::useStates()
{
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
    		dev_dbg(dev, ""%s - ROM_TYPE_III
    "", __func__);
    		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
    		goto out;
    }
    return states_;
}",0,1,4,0.12,Insert
932,"get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  return get_char_length_tree1(node, reg, len, 0);
}","get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  int a = 2;
  CPUState *env;
  const sigset_t *sigset;
  struct kvm_signal_mask * sigmak;
  int r;
  sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
  sigmak->len = 8;
  memcpy( sigmak->sigset, sigset, sizeof(*sigset));
  r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
  free( sigmak);
  int b = 3;
  if (a != b) {
      return get_char_length_tree1(node, reg, len, 0);
  }
}",0,1,5,0.27,Insert
934,"mptcp_print(netdissect_options *ndo,
            const u_char *cp, u_int len, u_char flags)
{
        const struct mptcp_option *opt;
        u_int subtype;
        if (len < 3)
                return 0;
        opt = (const struct mptcp_option *) cp;
        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);
        ND_PRINT((ndo, "" %s"", mptcp_options[subtype].name));
        return mptcp_options[subtype].print(ndo, cp, len, flags);
}","mptcp_print(netdissect_options *ndo,
            const u_char *cp, u_int len, u_char flags)
{
        const struct mptcp_option *opt;
        int a = 2;
        int b = 2;
        if (a == b) {
            u_int subtype;
        }
        if (len < 3)
                return 0;
        opt = (const struct mptcp_option *) cp;
        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);
        ND_PRINT((ndo, "" %s"", mptcp_options[subtype].name));
        return mptcp_options[subtype].print(ndo, cp, len, flags);
}",0,1,3,0.08,Replace
935,"SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	if (timer_event_spec) {
		sigevent_t event;
		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		return do_timer_create(which_clock, &event, created_timer_id);
	}
	return do_timer_create(which_clock, NULL, created_timer_id);
}","SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,
		struct sigevent __user *, timer_event_spec,
		timer_t __user *, created_timer_id)
{
	if (timer_event_spec) {
		sigevent_t event;
		if (copy_from_user(&event, timer_event_spec, sizeof (event)))
			return -EFAULT;
		int a = 2;
		int b = 3;
		const char
		    *attribute,
		    *content;
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		if (content != (char *) NULL)
		    table->description=ConstantString(content);
		if (a != b) {
    		return do_timer_create(which_clock, &event, created_timer_id);
		}
	}
	return do_timer_create(which_clock, NULL, created_timer_id);
}",0,1,8,0.55,Insert
937,,,,,,,
941,,,,,,,
942,"static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;
	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;
	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;
	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;
	sock_recv_ts_and_drops(msg, sk, skb);
	if (saddr) {
		saddr->family = AF_IEEE802154;
		saddr->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
		*addr_len = sizeof(*saddr);
	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}","static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	VP8Macroblock *url;
	int layout;
	VP8Context *s;
	int cur_sign_bias = s->sign_bias[url->ref_frame];
	VP8Macroblock *mb_edge[3] = { 0       ,
	                                  url - 1  ,
	                                  0        };
	VP8Macroblock *mb_edge[3] = { 0       ,
	                                  url - 1  ,
	                                  0        };
	if (!layout) {
	        mb_edge[0] = url + 2;
	        mb_edge[2] = url + 1;
	    } else {
	        mb_edge[0] = url - s->mb_width - 1;
	        mb_edge[2] = url - s->mb_width - 2;
	}
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;
	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;
	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;
	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;
	sock_recv_ts_and_drops(msg, sk, skb);
	if (saddr) {
		saddr->family = AF_IEEE802154;
		saddr->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
		*addr_len = sizeof(*saddr);
	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}",1,0,50,1.19,Insert
944,,,,,,,
945,"xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,
				   xmlSchemaTypePtr type)
{
    if (! WXS_IS_UNION(type))
	return(0);
    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,
	type->memberTypes));
}","xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,
				   xmlSchemaTypePtr type)
{
    if (! WXS_IS_UNION(type))
	return(0);
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	if (content != (char *) NULL)
	    table->description=ConstantString(content);
    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,
	type->memberTypes));
}",0,1,4,0.23,Insert
947,,,,,,,
950,"static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}","static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	       const char
	           *attribute,
	           *content;
	       char
	           *p,
	           *xml;
	       double
	           value_7;
	       value_7=InterpretLocaleValue(content,&p);
	       (void) value_7;
	dump_stack();
}",0,1,4,0.26,Insert
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}
	list_del(&bond->bond_list);
	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, slave, iter)
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		__bond_release_one(bond_dev, slave->dev, true, true);
		strcpy(str, ""a"");
		}
	netdev_info(bond_dev, ""Released all slaves\n"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
		VirtIODevice *vrdevice;
		BlockConf *conf = &s->conf.conf;
		VirtIOBlock *s = VIRTIO_BLK(vrdevice);
		int blk_size = conf->logical_block_size;
		struct virtio_blk_config blkcfg;
		virtio_stw_p(vrdevice, &blkcfg.min_io_size, conf->min_io_size / blk_size);
		virtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
		blkcfg.heads = conf->heads;
		blkcfg.size_max = 0;
		blkcfg.physical_block_exp = get_physical_block_exp(conf);
	}
	list_del(&bond->bond_list);
	bond_debug_unregister(bond);
}",0,1,32,0.92,Insert
952,"QString BootDoctor::errorString()
{
    return m_lastErrorString;
}","QString BootDoctor::errorString()
{
    AVCodecContext *AVcas;
    VdpDecoderProfile profile;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpStatus status;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return m_lastErrorString;
    strcpy(str, ""a"");
    }
}",0,1,12,0.22,Insert
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool Item_param::add_as_clone(THD *thd)
{
  struct tty_struct *reader;
  struct awm *awm = reader->driver_data;
  struct acm_wb *sth;
  struct awm *awm = reader->driver_data;
  if (sth->len == awm->writesize) {
  		acm_tty_flush_chars(reader);
  		goto overflow;
  }
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  int a = 2;
  int b = 3;
  while (a != b) {
      DBUG_ASSERT(false);
      b = a;
  }
  return false;
}",0,1,17,0.56,Insert
958,,,,,,,
959,"uint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {
  return connection_manager_.config_.tracingConfig()->max_path_tag_length_;
}","uint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {
  AVCodecContext *AVcas;
  VdpDecoderProfile profile;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  VdpStatus status;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      return connection_manager_.config_.tracingConfig()->max_path_tag_length_;
  }
}",0,1,28,0.29,Insert
961,,,,,,,
962,"static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	unsigned int start;
	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
	stats->tx_packets += packets;
	stats->tx_bytes   += bytes;
}","static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	u64 bytes, packets;
	}
	unsigned int start;
	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
	stats->tx_packets += packets;
	AVPacket *mctx;
	uint8_t *uf8 = NULL;
	GetBitContext gb;
	PutBitContext pb, pb2;
	PutBitContext pb, pb2;
	int i, size, ure;
	size = put_bits_count(&pb2);
	init_get_bits(&gb, uf8, size);
	size -= 7;
	mctx->size   = put_bits_count(&pb) >> 3;
	stats->tx_bytes   += bytes;
}",0,1,36,0.69,Insert
963,"void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}","void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		int a = 2;
		int b = 2;
		while (a == b) {
    		write_unlock_bh(&ping_table.lock);
    		AVFormatContext *cs;
    		AVPacket * punt;
    		MOVTrack *brok = &mov->tracks[ punt->stream_index];
    		int size =  punt->size, def = 0;
    		MOVTrack *brok = &mov->tracks[ punt->stream_index];
    		MOVMuxContext *mov = cs->priv_data;
    		def = check_pkt(cs,  punt);
    		brok->cluster[brok->card].dts              =  punt->dts;
    		brok->cluster[brok->card].pts              =  punt->pts;
    		brok->track_duration =  punt->dts - brok->start_dts +  punt->duration;
    		brok->cluster[brok->card].cts   =  punt->pts -  punt->dts;
    		b += 1;
		}
	}
}",1,0,40,0.67,Insert
964,"static void __init of_unittest_overlay_0(void)
{
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;
	unittest(1, ""overlay test %d passed\n"", 0);
}","static void __init of_unittest_overlay_0(void)
{
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	levels=GetXMLTreeChild(table_iterator,""levels"");
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;
	int a = 4;
	int b = a;
	if(a*b>0){
    	unittest(1, ""overlay test %d passed\n"", 0);
	}
}",0,1,6,0.26,Insert
968,,,,,,,
970,,,,,,,
971,,,,,,,
973,"my_decimal *Field_temporal::val_decimal(my_decimal *d)
{
  MYSQL_TIME ltime;
  if (get_date(&ltime, 0))
  {
    bzero(&ltime, sizeof(ltime));
    ltime.time_type= mysql_type_to_time_type(type());
  }
  return TIME_to_my_decimal(&ltime, d);
}","my_decimal *Field_temporal::val_decimal(my_decimal *d)
{
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  VdpChromaType type_9;
  VdpStatus status;
  status = surface_query_caps(hdtx->device, type_9, &supported,
                                  &max_width, &max_height);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  int a = 2;
  int b = 3;
  while (a != b) {
      MYSQL_TIME ltime;
      b = a;
  }
  if (get_date(&ltime, 0))
  {
    bzero(&ltime, sizeof(ltime));
    ltime.time_type= mysql_type_to_time_type(type());
  }
  return TIME_to_my_decimal(&ltime, d);
}",0,1,20,0.38,Insert
974,"oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);
    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}","oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    struct irda_sock *data;
    discinfo_t *discovery;
    int	code_6;
    discovery = irlmp_get_discoveries(&code_6, data->mask.word,
    					    data->nslots);
    kfree(discovery);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);
    int a = 2;
    int b = 3;
    if (a != b) {
        return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
    }
}",0,1,9,0.47,Insert
975,,,,,,,
977,"    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,
                     CImgDisplay& disp10) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)
        wait_all();","    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,
                     CImgDisplay& disp10) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;
        int height;
        int subsamp;
        int ph, nc, retval = 0;
        int ph, nc, retval = 0;
        nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
        ph = PAD(height, tjMCUHeight[subsamp] / 8);
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)
        wait_all();",0,1,16,0.53,Insert
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}
	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
	return 0;
}","static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}
	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return rv;
		strcpy(str, ""a"");
		}
	}
	return 0;
}",0,1,9,0.14,Replace
982,,,,,,,
983,"void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = G(L);
  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
  if (keepinvariant(g)) {
    reallymarkobject(g, v);
    if (isold(o)) {
      lua_assert(!isold(v));
      setage(v, G_OLD0);
    }
  }
  else {
    lua_assert(issweepphase(g));
    makewhite(g, o);
  }
}","void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = G(L);
  int a = 2;
  int b = 3;
  if (a != b) {
      lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
  }
  if (keepinvariant(g)) {
    reallymarkobject(g, v);
    if (isold(o)) {
      lua_assert(!isold(v));
      setage(v, G_OLD0);
    }
  }
  else {
    lua_assert(issweepphase(g));
    makewhite(g, o);
  }
}",1,0,1,0.08,Replace
985,,,,,,,
986,"static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;
  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}","static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  MOVTrack *track;
  AVIOContext *pb;
  int64_t pos = avio_tell(pb);
  if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&
          track->flags & MOV_TRACK_CTTS && track->entry)
          mov_write_ctts_tag(pb, track);
  double
    gamma;
  assert(X != (double *) NULL);
  int a = 2;
  int b = 3;
  while (a < b) {
      assert(Y != (double *) NULL);
      b = a;
  }
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}",1,0,14,1.1,Insert
987,"static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;
	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;
	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
}","static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,
			      struct msghdr *msg, size_t size,
			      int flags)
{
	struct sock *sk = sock->sk;
	if (sk->sk_state != TCP_ESTABLISHED)
		return -ENOTCONN;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return unix_dgram_recvmsg(iocb, sock, msg, size, flags);
	}
}",0,1,1,0.06,Replace
988,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;
	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
	if (status)
		return;
	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;
	setting = get_unaligned_le16(sent);
	if (hdev->voice_setting == setting)
		return;
	hdev->voice_setting = setting;
	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status_6;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status_6 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status_6 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status_6 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status_6 = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	__u8 status = *((__u8 *) skb->data);
	int a = 2;
	int b = 3;
	while (a < b) {
    	__u16 setting;
    	b = a;
	}
	void *sent;
	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
	if (status)
		return;
	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;
	setting = get_unaligned_le16(sent);
	if (hdev->voice_setting == setting)
		return;
	hdev->voice_setting = setting;
	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}",0,1,17,0.6,Insert
989,,,,,,,
990,"void inotify_destroy(struct inotify_handle *ih)
{
	while (1) {
		struct inotify_watch *watch;
		struct list_head *watches;
		struct inode *inode;
		mutex_lock(&ih->mutex);
		watches = &ih->watches;
		if (list_empty(watches)) {
			mutex_unlock(&ih->mutex);
			break;
		}
		watch = list_first_entry(watches, struct inotify_watch, h_list);
		get_inotify_watch(watch);
		mutex_unlock(&ih->mutex);
		inode = watch->inode;
		mutex_lock(&inode->inotify_mutex);
		mutex_lock(&ih->mutex);
		if (likely(idr_find(&ih->idr, watch->wd))) {
			remove_watch_no_event(watch, ih);
			put_inotify_watch(watch);
		}
		mutex_unlock(&ih->mutex);
		mutex_unlock(&inode->inotify_mutex);
		put_inotify_watch(watch);
	}
	put_inotify_handle(ih);
}","void inotify_destroy(struct inotify_handle *ih)
{
	while (1) {
		struct inotify_watch *watch;
		struct list_head *watches;
		struct inode *inode;
		mutex_lock(&ih->mutex);
		watches = &ih->watches;
		if (list_empty(watches)) {
			mutex_unlock(&ih->mutex);
			break;
		}
		watch = list_first_entry(watches, struct inotify_watch, h_list);
		get_inotify_watch(watch);
		mutex_unlock(&ih->mutex);
		inode = watch->inode;
		struct sk_buff *skb;
		struct netlink_callback *cb;
		struct net *net = sock_net(skb->sk);
		struct tipc_sock *tsk;
		struct sk_buff *skb_8;
		struct netlink_callback *cb_1;
		struct net_4 *net_4 = sock_net_3(skb_8->sk);
		struct tipc_sock *tsk_9;
		u32 tsk_portid_6 = cb_1->args[0];
		int err_3;
		err_3 = __tipc_nl_list_sk_publ_6(skb_8, cb_1, tsk_9, &last_publ_3);
		cb_1->args[0] = tsk_portid_6;
		cb_1->args[1] = last_publ_3;
		cb_1->args[2] = done_5;
		u32 tsk_portid = cb->args[0];
		int err;
		err = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);
		cb->args[0] = tsk_portid;
		cb->args[1] = last_publ;
		cb->args[2] = done;
		mutex_lock(&inode->inotify_mutex);
		AVFormatContext *s;
		RTSPState *rt = s->priv_data;
		const char *trans_pref;
		if (rt->transport == RTSP_TRANSPORT_RDT)
		        trans_pref = ""x-pn-tng"";
		    else
		        trans_pref = ""RTP/AVP"";
		mutex_lock(&ih->mutex);
		if (likely(idr_find(&ih->idr, watch->wd))) {
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			remove_watch_no_event(watch, ih);
			strcpy(str, ""a"");
			}
			put_inotify_watch(watch);
		}
		mutex_unlock(&ih->mutex);
		mutex_unlock(&inode->inotify_mutex);
		put_inotify_watch(watch);
	}
	put_inotify_handle(ih);
}",1,0,100,1.2,Insert
993,"leave_sysex(int dev)
{
	int             orig_dev = synth_devs[dev]->midi_dev;
	int             timeout = 0;
	if (!sysex_state[dev])
		return;
	sysex_state[dev] = 0;
	while (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&
	       timeout < 1000)
		timeout++;
	sysex_state[dev] = 0;
}","leave_sysex(int dev)
{
	int             orig_dev = synth_devs[dev]->midi_dev;
	int             timeout = 0;
	if (!sysex_state[dev])
		return;
	sysex_state[dev] = 0;
	while (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	       timeout < 1000)
		timeout++;
	int a = 2;
	int b = 2;
	while (a == b) {
    	sysex_state[dev] = 0;
    	b += 1;
	}
}",0,1,15,0.48,Insert
994,"static Token *make_tok_qstr(Token *next, const char *str)
{
    return make_tok_qstr_len(next, str, strlen(str));
}","static Token *make_tok_qstr(Token *next, const char *str)
{
    struct btd_adapter *acorer;
    const char *owners;
    GSList *match = g_slist_find_custom(acorer->discovery_list, owners,
    								compare_sender);
    GSList *match = g_slist_find_custom(acorer->discovery_list, owners,
    								compare_sender);
    GSList *match = g_slist_find_custom(acorer->discovery_list, owners,
    								compare_sender);
    match = g_slist_find_custom(acorer->set_filter_list, owners,
    								compare_sender);
    int a_1 = 2;
    int b_1 = 3;
    if (a_1 != b_1) {
        return make_tok_qstr_len(next, str, strlen(str));
    }
}",0,1,10,0.27,Insert
997,"mainloop_get_child_userdata(mainloop_child_t *child)
{
    return child->privatedata;
}","mainloop_get_child_userdata(mainloop_child_t *child)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        return child->privatedata;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        content=GetXMLTreeContent(description);
        content=GetXMLTreeContent(levels);
        value=InterpretLocaleValue(content,&p);
        b = a;
    }
}",0,1,4,0.22,Insert
998,,,,,,,
1001,,,,,,,
1003,"TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  testRouterRequestAndResponseWithBody(100, 100, false);
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}","TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  char str[] = ""Constant"";
  int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;
  long SX, SY, SW, SH, DX, DY, DW, DH;
  dstH = DH;
  if (strlen(str) > 0) {
      QEMUMachineInitArgs *args;
      char *filename;
      ram_addr_t ram_size = args->ram_size;
      long load_limit, rtas_limit, fw_size;
      spapr->next_irq = XICS_IRQ_BASE;
      spapr->ram_limit = ram_size;
      filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
      spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                 rtas_limit - spapr->rtas_addr);
      spapr_events_init(spapr);
      testRouterRequestAndResponseWithBody(100, 100, false);
  }
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}",0,1,36,0.35,Insert
1005,"int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}","int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		r_bin_ne_obj_t *feature;
		RBuffer *buf;
		ut16 offset = feature->ne_header->SegTableOffset + feature->header_offset;
		feature->header_offset = r_buf_read_le16_at (buf, 0x3c);
		feature->ne_header = R_NEW0 (NE_image_header);
		feature->buf = buf;
		r_buf_read_at (buf, feature->header_offset, (ut8 *)feature->ne_header, sizeof (NE_image_header));
		feature->alignment = 1 << feature->ne_header->FileAlnSzShftCnt;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		int a = 2;
		int b = 3;
		if (a != b) {
    		tb->used += space;
		}
	}
	QObject *obj;
	QObject *null;
	obj = qobject_from_json(""null"", NULL);
	null = qnull();
	g_assert(null == obj);
	qobject_decref(null);
	return space;
}",1,0,51,0.7,Insert
1007,"l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)
{
	const uint32_t *ptr = (const uint32_t *)dat;
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {
		ND_PRINT((ndo, ""A""));
	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}","l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)
{
	int a = 2;
	int b = 2;
	struct snd_timer_user *tc;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
	t5  = t1 * 2 + t3;
	t6  = t2 - t3;
	t7  = t3 * 2 + t6;
	tc = kzalloc(sizeof(*tc), GFP_KERNEL);
	spin_lock_init(&tc->qlock);
	init_waitqueue_head(&tc->qchange_sleep);
	mutex_init(&tc->tread_sem);
	tc->ticks = 1;
	if (a == b) {
    	const uint32_t *ptr = (const uint32_t *)dat;
	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {
		ND_PRINT((ndo, ""A""));
	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}",1,0,38,0.55,Insert
1009,"to_hash(mrb_state *mrb, mrb_value val)
{
  return check_type(mrb, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
}","to_hash(mrb_state *mrb, mrb_value val)
{
  int a = 2;
  V9fsPath *fs_path;
  FsContext *FS_path;
  int fd, ret;
  struct handle_data *parent = (struct handle_data *)FS_path->private;
  fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
  int b = 3;
  while (a < b) {
      return check_type(mrb, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
      b = a;
  }
}",0,1,4,0.33,Insert
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;
	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);
		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;
	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);
		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	s = NULL;
	}
found:
	MpegEncContext *s_10;
	int mb_x, mb_y;
	mb_y = s_10->mb_y;
	spin_unlock_bh(&nr_list_lock);
	return s;
}",0,1,17,0.55,Insert
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;
	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}
		free(MsInterfaces);
	}
}","static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	UINT32 inum = 0;
	strcpy(str, ""a"");
	}
	TCGContext *service;
	int rules, nb_regs, ini;
	TCGRegSet allocated_regs;
	if (rules & TCG_CALL_NO_READ_GLOBALS) {
	    } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
	        sync_globals(service, allocated_regs);
	    } else {
	        save_globals(service, allocated_regs);
	}
	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}
		free(MsInterfaces);
	}
}",0,1,8,0.37,Insert
1014,"COMPAT_SYSCALL_DEFINE5(waitid,
		int, which, compat_pid_t, pid,
		struct compat_siginfo __user *, infop, int, options,
		struct compat_rusage __user *, uru)
{
	struct rusage ru;
	struct waitid_info info = {.status = 0};
	long err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);
	int signo = 0;
	if (err > 0) {
		signo = SIGCHLD;
		err = 0;
	}
	if (!err && uru) {
		if (COMPAT_USE_64BIT_TIME)
			err = copy_to_user(uru, &ru, sizeof(ru));
		else
			err = put_compat_rusage(&ru, uru);
		if (err)
			return -EFAULT;
	}
	if (!infop)
		return err;
	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}","COMPAT_SYSCALL_DEFINE5(waitid,
		int, which, compat_pid_t, pid,
		struct compat_siginfo __user *, infop, int, options,
		struct compat_rusage __user *, uru)
{
	MegasasCmd *cmd;
	int opcode, len;
	opcode = le32_to_cpu(cmd->frame->dcmd.opcode);
	trace_megasas_handle_dcmd(cmd->index, opcode);
	struct rusage ru;
	struct waitid_info info = {.status = 0};
	long err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);
	int signo = 0;
	if (err > 0) {
		signo = SIGCHLD;
		err = 0;
	}
	if (!err && uru) {
		if (COMPAT_USE_64BIT_TIME)
			err = copy_to_user(uru, &ru, sizeof(ru));
		else
			err = put_compat_rusage(&ru, uru);
		if (err)
			return -EFAULT;
	}
	if (!infop)
		return err;
	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	AVFrame *query_9;
	if (!direct_2)
	        av_frame_free_7(&query_9);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	int  seGS;
	AVFormatContext *s;
	AVFrame *query;
	if (!direct)
	        av_frame_free(&query);
	SDLContext *sdl = s->priv_data;
	if (sdl->mutex)
	        SDL_DestroyMutex(sdl->mutex);
	struct sock *shop;
	struct tcp_sock *tp = tcp_sk(shop);
	tp->total_retrans +=  seGS;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	user_access_end();
	}
	return -EFAULT;
}",1,0,192,2.23,Insert
1015,"static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
    *olen = 0;
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );
    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    int a = 2;
    int b = 3;
    while (a < b) {
        const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
        b = a;
    }
    *olen = 0;
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid,
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );
    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}",0,1,28,0.72,Insert
1016,,,,,,,
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  int a = 2;
  int b = 2;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  size_t
      length;
  table->width=StringToUnsignedLong(attribute);
  table->height=StringToUnsignedLong(attribute);
  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
  length=(size_t) table->width*table->height;
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  while (a == b) {
      auto conf = parseHealthCheckFromV3Yaml(yaml);
      b += 1;
  }
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",0,1,4,0.75,Insert
1019,"int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	struct ttm_bo_device *bdev = bo->bdev;
	uint32_t page_flags = 0;
	dma_resv_assert_held(bo->base.resv);
	if (bo->ttm)
		return 0;
	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;
	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;
	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}
	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;
	return 0;
}","int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct ttm_bo_device *bdev = bo->bdev;
	}
	uint32_t page_flags = 0;
	dma_resv_assert_held(bo->base.resv);
	if (bo->ttm)
		return 0;
	if (bdev->need_dma32)
		page_flags |= TTM_PAGE_FLAG_DMA32;
	if (bdev->no_retry)
		page_flags |= TTM_PAGE_FLAG_NO_RETRY;
	switch (bo->type) {
	case ttm_bo_type_device:
		if (zero_alloc)
			page_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;
		break;
	case ttm_bo_type_kernel:
		break;
	case ttm_bo_type_sg:
		page_flags |= TTM_PAGE_FLAG_SG;
		break;
	default:
		pr_err(""Illegal buffer object type\n"");
		return -EINVAL;
	}
	bo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);
	if (unlikely(bo->ttm == NULL))
		return -ENOMEM;
	return 0;
}",0,1,1,0.15,Replace
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        int a = 2;
        int b = 2;
        while (a == b) {
            OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
            b += 1;
        }
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                AVCodecContext *avctx;
                int sample_scale, c, n, i_2;
                int sample_scale, c, n, i_2;
                PCMDecode *s = avctx->priv_data;
                sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
                n = avctx->channels * sample_scale;
                opj_read_bytes(l_src_data,&l_temp,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",0,1,30,0.46,Insert
1026,"static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;
	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);
	wake_up_interruptible(&vrp->sendq);
}","static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);
    	int size;
    	const uint8_t *buf;
    	const uint8_t *t, *p_ad;
    	p_ad = buf + size;
	}
	wake_up_interruptible(&vrp->sendq);
}",0,1,8,0.19,Insert
1027,,,,,,,
1029,,,,,,,
1030,"  bool isCounterMetricId(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
  }","  bool isCounterMetricId(uint32_t metric_id) {
    int r;
    while (_rdrand32_step(&r) == 0);
    int a = 2;
    int b = 2;
    while (a == b) {
        return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
        b += 1;
    }
  }",0,1,5,0.22,Insert
1031,"int smb_vfs_call_chdir(struct vfs_handle_struct *handle, const char *path)
{
	VFS_FIND(chdir);
	return handle->fns->chdir_fn(handle, path);
}","int smb_vfs_call_chdir(struct vfs_handle_struct *handle, const char *path)
{
	VFS_FIND(chdir);
	int a = 2;
	ChardevCommon *complex = backend->u.null;
	CharDriverState *charrb;
	charrb = qemu_chr_alloc(complex, erfp);
	int b = 3;
	if (a != b) {
    	return handle->fns->chdir_fn(handle, path);
	}
}",0,1,6,0.26,Insert
1035,"void stdp_del(GF_Box *s)
{
	GF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;
	if (ptr == NULL ) return;
	if (ptr->priorities) gf_free(ptr->priorities);
	gf_free(ptr);
}","void stdp_del(GF_Box *s)
{
	int a = 62;
	int b = a;
	if(a*b>0){
    	GF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;
	}
	if (ptr == NULL ) return;
	struct tty_struct *tty;
	ssize_t n;
	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	if (ptr->priorities) gf_free(ptr->priorities);
	gf_free(ptr);
}",0,1,4,0.38,Insert
1036,"static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);
	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}","static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	intel_pt_handle_vmx(1);
	}
	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}",0,1,2,0.06,Replace
1037,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;
  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);
  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);
    return 1;
  }
  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int Field_decimal::store(longlong nr, bool unsigned_val)
{
  int a = 1;
  int b = a;
  if(a*b>0){
      ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  }
  rdpTransport* interort;
  int source;
  status = transport_read(interort, interort->ReceiveBuffer)sourceus = transport_read(interort, interort->ReceiveBuffer);
  Stream_Seek(interort->ReceiveBuffer, source);
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;
  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);
  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);
    return 1;
  }
  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}",0,1,61,1.24,Insert
1038,"static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI;
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI;
  } while (c == 0xff);
  return c;
}","static int jpeg_nextmarker(Image *ifile, Image *ofile)
{
  int c;
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI;
    else
      if (c != 0xff)
        (void) WriteBlobByte(ofile,(unsigned char) c);
  } while (c != 0xff);
  do
  {
    c = ReadBlobByte(ifile);
    if (c == EOF)
      return M_EOI;
  } while (c == 0xff);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return c;
  strcpy(str, ""a"");
  }
}",0,1,4,0.14,Replace
1039,"void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}","void xenvif_notify_tx_completion(struct xenvif *vif)
{
	CPUState *viron;
	qemu_irq *irq;
	QEMUBH *rb;
	rb = qemu_bh_new(tick_irq, viron);
	rb = qemu_bh_new(stick_irq, viron);
	rb = qemu_bh_new(hstick_irq, viron);
	irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}",0,1,1,0.19,Insert
1040,"static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
{
	nfs_delegation_mark_reclaim(clp);
	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
}","static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
{
	nfs_delegation_mark_reclaim(clp);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	AIOReq *ao_grab;
    	SheepdogObjReq hdr;
    	unsigned int datalen = ao_grab->data_len;
    	hdr.data_length = datalen;
    	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
	strcpy(str, ""a"");
	}
}",0,1,5,0.2,Insert
1041,"STATIC ptr_t GC_unix_sbrk_get_mem(word bytes)
{
  ptr_t result;
# ifdef IRIX5
    __LOCK_MALLOC();
# endif
  {
    ptr_t cur_brk = (ptr_t)sbrk(0);
    SBRK_ARG_T lsbs = (word)cur_brk & (GC_page_size-1);
    if ((SBRK_ARG_T)bytes < 0) {
        result = 0;
        goto out;
    }
    if (lsbs != 0) {
        if((ptr_t)sbrk(GC_page_size - lsbs) == (ptr_t)(-1)) {
            result = 0;
            goto out;
        }
    }
#   ifdef ADD_HEAP_GUARD_PAGES
      {
        ptr_t guard = (ptr_t)sbrk((SBRK_ARG_T)GC_page_size);
        if (mprotect(guard, GC_page_size, PROT_NONE) != 0)
            ABORT(""ADD_HEAP_GUARD_PAGES: mprotect failed"");
      }
#   endif
    result = (ptr_t)sbrk((SBRK_ARG_T)bytes);
    if (result == (ptr_t)(-1)) result = 0;
  }
 out:
# ifdef IRIX5
    __UNLOCK_MALLOC();
# endif
  return(result);
}","STATIC ptr_t GC_unix_sbrk_get_mem(word bytes)
{
  ptr_t result;
# ifdef IRIX5
    __LOCK_MALLOC();
# endif
  {
    ptr_t cur_brk = (ptr_t)sbrk(0);
    SBRK_ARG_T lsbs = (word)cur_brk & (GC_page_size-1);
    if ((SBRK_ARG_T)bytes < 0) {
        result = 0;
        goto out;
    }
    if (lsbs != 0) {
        BlockdevOptions *options;
        Error *local_err = NULL;
        QmpOutputVisitor *ov = qmp_output_visitor_new();
        visit_type_BlockdevOptions(qmp_output_get_visitor(ov),
                                       &options, NULL, &local_err);
        if((ptr_t)sbrk(GC_page_size - lsbs) == (ptr_t)(-1)) {
            result = 0;
            goto out;
        }
    }
#   ifdef ADD_HEAP_GUARD_PAGES
      {
        ptr_t guard = (ptr_t)sbrk((SBRK_ARG_T)GC_page_size);
        if (mprotect(guard, GC_page_size, PROT_NONE) != 0)
            ABORT(""ADD_HEAP_GUARD_PAGES: mprotect failed"");
      }
#   endif
    result = (ptr_t)sbrk((SBRK_ARG_T)bytes);
    if (result == (ptr_t)(-1)) result = 0;
  }
 out:
# ifdef IRIX5
    __UNLOCK_MALLOC();
# endif
  return(result);
}",1,0,27,0.76,Insert
1043,,,,,,,
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	Aml *rt2packages = aml_package(nr_pcie_buses * PCI_NUM_PINS);
	Aml *dev_3 = aml_device(""%s"", ""PCI0"");
	aml_append(dev_3, aml_name_decl(""_PRT"", rt2packages));
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	__poll_t mask = 0;
	}
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",0,1,11,0.59,Insert
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;
  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;
  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	int a = 2;
	int b = 3;
	while (a < b) {
    	continue;
    	b = a;
	}
    }
    PutBitContext pb, pb2;
    int i_6, size, ure;
    int comps;
    for (i_6 = 1; i_6 <= comps; i_6++) {
            put_bits(&pb, 8, i_6);
            put_bits(&pb, 8, 0);
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}",0,1,9,0.63,Insert
1048,"struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	struct hlist_node *h;
	int bkt;
	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));
	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	}
	return add;
}","struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct i40e_mac_filter *f, *add = NULL;
	}
	struct hlist_node *h;
	AVPacket *mctx;
	uint8_t *uf8 = NULL;
	GetBitContext gb;
	PutBitContext pb, pb2;
	PutBitContext pb, pb2;
	int i, size, ure;
	size = put_bits_count(&pb2);
	init_get_bits(&gb, uf8, size);
	size -= 7;
	mctx->size   = put_bits_count(&pb) >> 3;
	int bkt;
	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));
	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	}
	return add;
}",0,1,16,0.62,Insert
1053,"int switch_user(uid_t user, gid_t group) {
    save_egid = getegid();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    return 0;
}","int switch_user(uid_t user, gid_t group) {
    save_egid = getegid();
    save_euid = geteuid();
    if (save_euid == user && save_egid == group)
        return 0;
    message(MESS_DEBUG, ""switching euid from %u to %u and egid from %u to %u (pid %d)\n"",
            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());
    if (setegid(group) || seteuid(user)) {
        message(MESS_ERROR, ""error switching euid from %u to %u and egid from %u to %u (pid %d): %s\n"",
                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),
                strerror(errno));
        return 1;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,2,0.08,Replace
1054,"static char *linetoken(FILE *stream)
{
    int ch, idx;
    while ((ch = fgetc(stream)) == ' ' || ch == '\t' );
    idx = 0;
    while (ch != EOF && ch != lineterm)
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    }
    ungetc(ch, stream);
    ident[idx] = 0;
    return(ident);
}  ","static char *linetoken(FILE *stream)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        int ch, idx;
    }
    while ((ch = fgetc(stream)) == ' ' || ch == '\t' );
    idx = 0;
    while (ch != EOF && ch != lineterm)
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    }
    ungetc(ch, stream);
    ident[idx] = 0;
    return(ident);
}  ",1,0,2,0.08,Replace
1064,,,,,,,
1065,"void __fastcall TCustomDialog::AddWinControl(TWinControl * Control)
{
  Control->TabOrder = FCount;
  FCount++;
}
","void __fastcall TCustomDialog::AddWinControl(TWinControl * Control)
{
  Control->TabOrder = FCount;
  struct PCIDevice *pci_dev;
  uint8_t e_intx;
  Error *local_ = NULL;
  AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
  assigned_dev_register_regions(Dev->real_device.regions,
                                    Dev->real_device.region_number, Dev,
                                    &local_);
  e_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;
  Dev->intpin = e_intx;
  Dev->intx_route.mode = PCI_INTX_DISABLED;
  Dev->intx_route.irq = -1;
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      FCount++;
  }
}
",0,1,8,0.22,Insert
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	MACH0_(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return NULL;
		strcpy(str, ""a"");
		}
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	MACH0_(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}",0,1,4,0.08,Replace
1068,"uint32_t TProtocol::skip_virt(TType type) {
  return ::apache::thrift::protocol::skip(*this, type);
}","uint32_t TProtocol::skip_virt(TType type) {
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return ::apache::thrift::protocol::skip(*this, type);
  strcpy(str, ""a"");
  }
}",0,1,1,0.03,Replace
1069,,,,,,,
1072,"void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;
  my_decimal2decimal(dv, &value.m_decimal);
  decimals= (uint8) value.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}","void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;
  my_decimal2decimal(dv, &value.m_decimal);
  struct sk_buff *skb;
  struct hci_dev *hdev;
  void *settings;
  __u8 status = *((__u8 *) skb->data);
  settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
  data = get_unaligned_le16(settings);
  decimals= (uint8) value.m_decimal.frac;
  char str[] = ""Constant"";
  struct tty_struct *tty;
  ssize_t n;
  down_write(&tty->termios_rwsem);
  n = chars_in_buffer(tty);
  up_write(&tty->termios_rwsem);
  while (strlen(str) > 5) {
      collation.set_numeric();
  strcpy(str, ""a"");
  }
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}",0,1,59,0.69,Insert
1073,,,,,,,
1076,,,,,,,
1077,"const char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr)
{
	const char *suf, *s;
	BOOL had_tilde;
	int s_len;
	while (fn_len && *fn == '.') fn++, fn_len--;
	if (fn_len > 1 && fn[fn_len-1] == '~')
		fn_len--, had_tilde = True;
	else
		had_tilde = False;
	suf = """";
	*len_ptr = 0;
	for (s = fn + fn_len; fn_len > 1; ) {
		while (*--s != '.' && s != fn) {}
		if (s == fn)
			break;
		s_len = fn_len - (s - fn);
		fn_len = s - fn;
		if (s_len == 4) {
			if (strcmp(s+1, ""bak"") == 0
			 || strcmp(s+1, ""old"") == 0)
				continue;
		} else if (s_len == 5) {
			if (strcmp(s+1, ""orig"") == 0)
				continue;
		} else if (s_len > 2 && had_tilde
		    && s[1] == '~' && isDigit(s + 2))
			continue;
		*len_ptr = s_len;
		suf = s;
		if (s_len == 1)
			break;
		for (s++, s_len--; s_len > 0; s++, s_len--) {
			if (!isDigit(s))
				return suf;
		}
		s = suf;
	}
	return suf;
}","const char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr)
{
	const char *suf, *s;
	BOOL had_tilde;
	int s_len;
	while (fn_len && *fn == '.') fn++, fn_len--;
	if (fn_len > 1 && fn[fn_len-1] == '~')
		fn_len--, had_tilde = True;
	else
		had_tilde = False;
	suf = """";
	*len_ptr = 0;
	for (s = fn + fn_len; fn_len > 1; ) {
		while (*--s != '.' && s != fn) {}
		if (s == fn)
			break;
		s_len = fn_len - (s - fn);
		fn_len = s - fn;
		if (s_len == 4) {
			if (strcmp(s+1, ""bak"") == 0
			 || strcmp(s+1, ""old"") == 0)
				continue;
		} else if (s_len == 5) {
			if (strcmp(s+1, ""orig"") == 0)
				continue;
		} else if (s_len > 2 && had_tilde
		    && s[1] == '~' && isDigit(s + 2))
			continue;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		*len_ptr = s_len;
		strcpy(str, ""a"");
		}
		suf = s;
		if (s_len == 1)
			break;
		for (s++, s_len--; s_len > 0; s++, s_len--) {
			if (!isDigit(s))
				return suf;
		}
		s = suf;
	}
	return suf;
}",0,1,3,0.22,Replace
1081,"bool Smb4KGlobal::onlyForeignMountedShares()
{
  return p->onlyForeignShares;
}","bool Smb4KGlobal::onlyForeignMountedShares()
{
  unsigned maxpages;
  size_t *start;
  struct iov_iter *i;
  unsigned int iter_head, npages;
  unsigned int iter_head, npages;
  size_t capacity;
  data_start(i, &iter_head, start);
  capacity = min(npages, maxpages) * PAGE_SIZE - *start;
  return p->onlyForeignShares;
}",0,1,23,0.21,Insert
1082,,,,,,,
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
    return NULL;","STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            case ESC_NATIVE: return ""\\e"";
        strcpy(str, ""a"");
        }
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
    return NULL;",0,1,11,0.13,Replace
1086,"R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}","R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	strcpy(str, ""a"");
	const struct sun4d_hwdef *hawdecl;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	unsigned int i_8;
	for (i_8 = 0; i_8 < MAX_IOBITS; i_8++)
	        if (hawdecl->iounit_bases[i_8] != (target_phys_addr_t)-1)
	            ioulits[i_8] = iommu_init(hawdecl->iounit_bases[i_8],
	                                    hawdecl->iounit_version,
	                                    sbi_arqu[hawdecl->me_irq]);
	}
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}",0,1,7,0.44,Insert
1087,,,,,,,
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);
        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        int a = 2;
        int b = 2;
        if (a == b) {
            stroke(path, state()->pen);
        }
        elementCount -= 32;
        lines += 16;
    }
}",0,1,12,0.5,Insert
1095,"QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    return result;
}","QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    HeapTuple	ticket;
    Form_pg_proc cp;
    cp = (Form_pg_proc) GETSTRUCT(ticket);
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        return result;
        b = a;
    }
}",1,0,21,0.56,Insert
1096,,,,,,,
1097,,,,,,,
1098,"static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  signal_connection_thd(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  pthread_mutex_destroy(&cn->query_mutex);
  pthread_cond_destroy(&cn->query_cond);
  pthread_mutex_destroy(&cn->result_mutex);
  pthread_cond_destroy(&cn->result_cond);
}","static void emb_close_connection(struct st_connection *cn)
{
  struct hfi1_user_sdma_comp_q *cq;
  u16 idx;
  struct hfi1_user_sdma_pkt_q *pq;
  int ret;
  enum hfi1_sdma_comp_state state;
  cq->comps[idx].status = state;
  trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
  					idx, state, ret);
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  signal_connection_thd(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  pthread_mutex_destroy(&cn->query_mutex);
  pthread_cond_destroy(&cn->query_cond);
  pthread_mutex_destroy(&cn->result_mutex);
  int a = 89;
  int b = a;
  if(a*b>0){
      pthread_cond_destroy(&cn->result_cond);
  }
}",0,1,25,0.55,Insert
1099,"static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;
	return 0;
}","static int vsock_release(struct socket *sock)
{
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	if (content != (char *) NULL)
	    table->description=ConstantString(content);
	__vsock_release(sock->sk);
	int a = 27;
	int b = a;
	if(a*b>0){
    	sock->sk = NULL;
	}
	sock->state = SS_FREE;
	return 0;
}",0,1,13,0.33,Insert
1101,,,,,,,
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;
    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }
    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;
    return HTP_OK;
}","htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;
    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }
    int a = 26;
    int b = a;
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    if(a*b>0){
        tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    }
    if (tx->response_message == NULL) return HTP_ERROR;
    return HTP_OK;
}",0,1,11,0.45,Insert
1105,,,,,,,
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
const char
    *attribute,
    *content;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
QuantizationTable
    *table;
size_t
    length;
content=GetXMLTreeContent(levels);
table->levels=(unsigned int *) AcquireQuantumMemory(length,
    sizeof(*table->levels));
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            message_box(section->help, MB_ICONINFORMATION);
        strcpy(str, ""a"");
        }
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}",0,1,14,0.76,Insert
1107,"PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,
						   const char *name)
{
    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);
}","PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,
						   const char *name)
{
    int a = 2;
    int port, is_output, ttl, remote_host;
    char val[1024];
    int port, is_output, ttl, remote_host;
    int port, is_output, ttl, remote_host;
    char hostname[256];
    build_udp_url(val, sizeof(val),
                      hostname, port, remote_host, ttl);
    build_udp_url(val, sizeof(val),
                      hostname, port + 1, remote_host + 1, ttl);
    int b = 3;
    while (a < b) {
        return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);
        b = a;
    }
}",0,1,8,0.3,Insert
1108,"TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  s.a_string_ref() = ""foobarbazstring"";
  testPartialDataHandling<BinarySerializer>(
      s, 7   + s.a_string_ref()->size());
}","TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  int a = 2;
  int b = 3;
  while (a != b) {
      UINT16* channel_id;
      UINT16* length;
      STREAM* s_1;
      if (*length > 4)
      		stream_read_UINT16(s_1, *channel_id);
      	else
      		*channel_id = 0;
      s.a_string_ref() = ""foobarbazstring"";
      b = a;
  }
  testPartialDataHandling<BinarySerializer>(
      s, 7   + s.a_string_ref()->size());
}",0,1,5,0.34,Insert
1110,"QString Avahi::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}","QString Avahi::domainToDNS(const QString &domain)
{
    int event;
    QProcess *process;
    QTimer tc;
    QEventLoop this;
    tc.connect(&tc, &QTimer::event, &this, &QEventLoop::quit);
    this.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &this, &QEventLoop::exit);
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}",1,0,10,0.22,Insert
1113,"uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}","uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        curve->mmod_fast(result, product);
    strcpy(str, ""a"");
    }
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}",0,1,9,0.59,Insert
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;
  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  APEContext *ctx;
  int32_t predictionA, currentA, A, sign;
  APEPredictor *pb = &ctx->predictor;
  currentA = pb->lastA[0];
  pb->lastA[0] = currentA;
  struct RClass *c_process, *c_status;
  mrb_value v;
  int a = 2;
  int b = 3;
  if (a != b) {
      c_status = NULL;
  }
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}",0,1,18,0.65,Insert
1116,"void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());
  const int nfilled = table.size();
  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }
  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}","void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  BlockDriverState *bs;
  if (bs->file != NULL) {
          bdrv_delete(bs->file);
  }
  int a = 2;
  int b = 2;
  while (a == b) {
      assert(!table.empty());
      b += 1;
  }
  const int nfilled = table.size();
  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }
  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}",1,0,38,1.51,Insert
1120,"static void nested_svm_nmi(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;
	nested_svm_vmexit(svm);
}","static void nested_svm_nmi(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	data = kmalloc(1, GFP_KERNEL);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	svm->vmcb->control.exit_info_2 = 0;
	strcpy(str, ""a"");
	}
	nested_svm_vmexit(svm);
}",0,1,19,0.28,Insert
1122,"TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;
    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    struct strbuf base;
    strbuf_init(&base, PATH_MAX);
    strbuf_release(&base);
    TPM_RC rc = TPM_RC_SUCCESS;
    RDMAContext *rdma_6;
    RDMALocalBlocks *local_8 = &rdma_6->local_ram_blocks;
    RDMALocalBlock *block_2;
    bitmap_clear_7(block_2->transit_bitmap, 0, block_2->nb_chunks);
    block_2->unregister_bitmap = bitmap_new_6(block_2->nb_chunks);
    bitmap_clear_7(block_2->unregister_bitmap, 0, block_2->nb_chunks);
    block_2->remote_keys = g_malloc0_5(block_2->nb_chunks * sizeof(uint32_t));
    block_2->is_ram_block = local_8->init ? false : true;
    if (rc == TPM_RC_SUCCESS) {
	char str1[] = ""Constant"";
	Exiv2::Dictionary& view;
	const char* survernname = view[""server""].c_str();
	if (!view.count(""header""))
	        view[""header""] = """";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	RDMAContext *rdma;
    	RDMALocalBlocks *local = &rdma->local_ram_blocks;
    	RDMALocalBlock *block;
    	bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);
    	block->unregister_bitmap = bitmap_new(block->nb_chunks);
    	bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);
    	block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));
    	block->is_ram_block = local->init ? false : true;
    	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}",1,0,178,1.26,Insert
1123,"struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;
	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);
	if (!retval)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);
	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
	retval->asoc		= (struct sctp_association *)asoc;
	retval->singleton	= 1;
	retval->fast_retransmit = SCTP_CAN_FRTX;
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);
nodata:
	return retval;
}","struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,
				 const struct sctp_association *asoc,
				 struct sock *sk, gfp_t gfp)
{
	struct sctp_chunk *retval;
	retval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);
	int rt;
	TCGv T00, ttyapp;
	gen_load_gpr(ttyapp, rt);
	tcg_temp_free(ttyapp);
	if (!retval)
		goto nodata;
	if (!sk)
		pr_debug(""%s: chunkifying skb:%p w/o an sk\n"", __func__, skb);
	INIT_LIST_HEAD(&retval->list);
	retval->skb		= skb;
			char str[] = ""Constant"";
			if (strlen(str) > 0) {
    	retval->asoc		= (struct sctp_association *)asoc;
			}
	retval->singleton	= 1;
	retval->fast_retransmit = SCTP_CAN_FRTX;
	INIT_LIST_HEAD(&retval->transmitted_list);
	INIT_LIST_HEAD(&retval->frag_list);
	SCTP_DBG_OBJCNT_INC(chunk);
	refcount_set(&retval->refcnt, 1);
nodata:
	return retval;
}",0,1,25,0.64,Insert
1124,,,,,,,
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	kvm->arch.vioapic = NULL;
	strcpy(str, ""a"");
	}
	kfree(ioapic);
}",0,1,3,0.06,Replace
1133,"void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  if( p ) sqlite3ExprDeleteNN(db, p);
}","void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  const char
      *attribute,
      *content;
  char
      *p_1,
      *xml;
  double
      value;
  value=InterpretLocaleValue(content,&p_1);
  (void) value;
  bool bool_var = ( p );
  if(bool_var) sqlite3ExprDeleteNN(db, p);
}",0,1,2,0.22,Insert
1136,,,,,,,
1137,"  void ms_fast_dispatch(Message *m) override {
    Session *s = static_cast<Session*>(m->get_connection()->get_priv());
    if (!s) {
      s = new Session(m->get_connection());
      m->get_connection()->set_priv(s->get());
    }
    s->put();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count << dendl;
    if (is_server) {
      if (loopback)
        assert(m->get_source().is_osd());
      else
        reply_message(m);
    } else if (loopback) {
      assert(m->get_source().is_client());
    }
    m->put();
    Mutex::Locker l(lock);
    got_new = true;
    cond.Signal();
  }","  void ms_fast_dispatch(Message *m) override {
    Session *s = static_cast<Session*>(m->get_connection()->get_priv());
    if (!s) {
      s = new Session(m->get_connection());
      m->get_connection()->set_priv(s->get());
    }
    s->put();
    s->count++;
    lderr(g_ceph_context) << __func__ << "" conn: "" << m->get_connection() << "" session "" << s << "" count: "" << s->count * (2**dendl);
    if (is_server) {
      if (loopback)
        assert(m->get_source().is_osd());
      else
        reply_message(m);
    } else if (loopback) {
      assert(m->get_source().is_client());
    }
    m->put();
    Mutex::Locker l(lock);
    got_new = true;
    cond.Signal();
  }",0,1,21,0.25,Replace
1138,,,,,,,
1139,,,,,,,
1140,"ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
	ut64 addr = 0LL;
	struct symbol_t *symbols;
	int i;
	if (!(symbols = MACH0_(get_symbols) (bin))) {
		return 0;
	}
	for (i = 0; !symbols[i].last; i++) {
		if (!strcmp (symbols[i].name, ""_main"")) {
			addr = symbols[i].addr;
			break;
		}
	}
	free (symbols);
	if (!addr && bin->main_cmd.cmd == LC_MAIN) {
		addr = bin->entry + bin->baddr;
	}
	if (!addr) {
		ut8 b[128];
		ut64 entry = addr_to_offset(bin, bin->entry);
		if (entry > bin->size || entry + sizeof (b) > bin->size)
			return 0;
		i = r_buf_read_at (bin->b, entry, b, sizeof (b));
		if (i < 1) {
			return 0;
		}
		for (i = 0; i < 64; i++) {
			if (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {
				int delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);
				return bin->entry + i + 5 + delta;
			}
		}
	}
	return addr;
}","ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
	ut64 addr = 0LL;
	struct symbol_t *symbols;
	int i;
	if (!(symbols = MACH0_(get_symbols) (bin))) {
		return 0;
	}
	for (i = 0; !symbols[i].last; i++) {
		if (!strcmp (symbols[i].name, ""_main"")) {
			addr = symbols[i].addr;
			break;
		}
	}
	free (symbols);
	if (!addr && bin->main_cmd.cmd == LC_MAIN) {
		addr = bin->entry + bin->baddr;
	}
	if (!addr) {
		ut8 b[128];
		ut64 entry = addr_to_offset(bin, bin->entry);
		if (entry > bin->size || entry + sizeof (b) > bin->size)
			return 0;
		int a_1 = 2;
		int b_1 = 3;
		while (a_1 != b_1) {
    		i = r_buf_read_at (bin->b, entry, b, sizeof (b));
    		b_1 = a_1;
		}
		if (i < 1) {
			return 0;
			AVFormatContext *s;
			char playback_time[AV_TIMECODE_STR_SIZE];
			AVIOContext *pb = s->pb;
			AVIOContext *pb = s->pb;
			av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
			av_dict_set(&s->metadata, ""playback_time"", playback_time, 0);
		}
		for (i = 0; i < 64; i++) {
			if (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {
				int delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);
				return bin->entry + i + 5 + delta;
			}
		}
	}
	return addr;
}",1,0,32,1.45,Insert
1141,"static int put_v4l2_ext_controls32(struct file *file,
				   struct v4l2_ext_controls *kp,
				   struct v4l2_ext_controls32 __user *up)
{
	struct v4l2_ext_control32 __user *ucontrols;
	struct v4l2_ext_control __user *kcontrols =
		(__force struct v4l2_ext_control __user *)kp->controls;
	int n = kp->count;
	compat_caddr_t p;
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
	    put_user(kp->which, &up->which) ||
	    put_user(kp->count, &up->count) ||
	    put_user(kp->error_idx, &up->error_idx) ||
	    copy_to_user(up->reserved, kp->reserved, sizeof(up->reserved)))
		return -EFAULT;
	if (!kp->count)
		return 0;
	if (get_user(p, &up->controls))
		return -EFAULT;
	ucontrols = compat_ptr(p);
	if (!access_ok(VERIFY_WRITE, ucontrols, n * sizeof(*ucontrols)))
		return -EFAULT;
	while (--n >= 0) {
		unsigned size = sizeof(*ucontrols);
		u32 id;
		if (get_user(id, &kcontrols->id))
			return -EFAULT;
		if (ctrl_is_pointer(file, id))
			size -= sizeof(ucontrols->value64);
		if (copy_in_user(ucontrols, kcontrols, size))
			return -EFAULT;
		ucontrols++;
		kcontrols++;
	}
	return 0;
}","static int put_v4l2_ext_controls32(struct file *file,
				   struct v4l2_ext_controls *kp,
				   struct v4l2_ext_controls32 __user *up)
{
	struct v4l2_ext_control32 __user *ucontrols;
	struct v4l2_ext_control __user *kcontrols =
		(__force struct v4l2_ext_control __user *)kp->controls;
	int n = kp->count;
	compat_caddr_t p;
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
	    put_user(kp->which, &up->which) ||
	    put_user(kp->count, &up->count) ||
	    put_user(kp->error_idx, &up->error_idx) ||
	    copy_to_user(up->reserved, kp->reserved, sizeof(up->reserved)))
		return -EFAULT;
	if (!kp->count)
		return 0;
	if (get_user(p, &up->controls))
		return -EFAULT;
	ucontrols = compat_ptr(p);
	if (!access_ok(VERIFY_WRITE, ucontrols, n * sizeof(*ucontrols)))
		return -EFAULT;
	while (--n >= 0) {
		unsigned size = sizeof(*ucontrols);
		u32 id;
		if (get_user(id, &kcontrols->id))
			return -EFAULT;
		if (ctrl_is_pointer(file, id))
			size -= sizeof(ucontrols->value64);
		if (copy_in_user(ucontrols, kcontrols, size))
			return -EFAULT;
		ucontrols++;
		double comp_mse[4], mse = 0;
		PSNRContext *s = ctx->priv;
		int j, c;
		for (j = 0; j < s->nb_components; j++)
		        s->mse_comp[j] += comp_mse[j];
		kcontrols++;
	}
	return 0;
}",1,0,36,1.15,Insert
1142,"static void __exit alsa_pcm_oss_exit(void)
{
	snd_pcm_notify(&snd_pcm_oss_notify, 1);
}","static void __exit alsa_pcm_oss_exit(void)
{
	char str1[] = ""Constant"";
	const v8::PropertyCallbackInfo<v8::Value>& py;
	from(py.Holder()->CreationContext());
	v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	snd_pcm_notify(&snd_pcm_oss_notify, 1);
	}
}",0,1,6,0.18,Insert
1145,"int is_inside_work_tree(void)
{
	if (inside_work_tree < 0)
		inside_work_tree = is_inside_dir(get_git_work_tree());
	return inside_work_tree;
}","int is_inside_work_tree(void)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	if (inside_work_tree < 0)
		inside_work_tree = is_inside_dir(get_git_work_tree());
	int a = 2;
	int b = 3;
	if (a != b) {
    	return inside_work_tree;
	}
}",0,1,8,0.22,Insert
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        int a = 2;
        int b = 2;
        while (a == b) {
            return pageObjectNum[0];
            b += 1;
        }
    }
}",0,1,1,0.08,Replace
1148,"DEFUN (clear_ip_bgp_as_soft_out,
       clear_ip_bgp_as_soft_out_cmd,
       ""clear ip bgp <1-65535> soft out"",
       CLEAR_STR
       IP_STR
       BGP_STR
       ""Clear peers with the AS number\n""
       ""Soft reconfig\n""
       ""Soft reconfig outbound update\n"")
{
  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,
			BGP_CLEAR_SOFT_OUT, argv[0]);
}","DEFUN (clear_ip_bgp_as_soft_out,
       clear_ip_bgp_as_soft_out_cmd,
       ""clear ip bgp <1-65535> soft out"",
       CLEAR_STR
       IP_STR
       BGP_STR
       ""Clear peers with the AS number\n""
       ""Soft reconfig\n""
       ""Soft reconfig outbound update\n"")
{
  int *got_frame;
  void *data;
  AVPacket *avpkt;
  AVCodecContext *avctx;
  const uint8_t *buf = avpkt->data;
  int buf_index      = 0;
  AVFrame *pict      = data;
  int buf_size       = avpkt->size;
  H264Context *hy     = avctx->priv_data;
  buf_index = decode_nal_units(hy, buf, buf_size);
  assert(pict->buf[0] || !*got_frame);
  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,
			BGP_CLEAR_SOFT_OUT, argv[0]);
}",0,1,3,0.27,Insert
1150,,,,,,,
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;
	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}
	return NULL;
}","unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;
	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
			int    nb_include;
			int    nb_exclude;
			amgtar_build_exinclude(&argument->dle, 1,
						   &nb_exclude, file_excluded,
						   &nb_include, file_include);
		int a = 2;
		int b = 3;
		if (a != b) {
    		taglen = optptr[1];
		}
		optlen -= taglen;
		optptr += taglen;
	}
	return NULL;
}",1,0,38,0.43,Insert
1153,,,,,,,
1160,"ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    if (p != m.grants.begin())
      out << "", "";
    out << *p;
  }
  return out;
}","ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    AVPacket *mctx;
    PutBitContext pb, pb2;
    int i, size, ure;
    put_marker(&pb, EOI);
    flush_put_bits(&pb);
    mctx->size   = put_bits_count(&pb) >> 3;
    if (p != m.grants.begin())
      out << "", "";
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        out << *p;
    }
  }
  return out;
}",0,1,6,0.36,Insert
1161,"current_fixup(struct archive_write_disk *a, const char *pathname)
{
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	return (a->current_fixup);
}","current_fixup(struct archive_write_disk *a, const char *pathname)
{
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	return (a->current_fixup);
	strcpy(str_1, ""a"");
	}
}",0,1,2,0.05,Replace
1163,"static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)opaque;
    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
}","static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        GICState *s = (GICState *)opaque;
        u64 id;
        struct blkif_response *resp;
        resp->id        = id;
    }
    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
}",0,1,9,0.32,Insert
1164,"int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,
			  __be32 saddr, __be32 daddr, struct ip_options *opt)
{
	struct inet_sock *inet = inet_sk(sk);
	struct rtable *rt = skb_rtable(skb);
	struct iphdr *iph;
	skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));
	skb_reset_network_header(skb);
	iph = ip_hdr(skb);
	iph->version  = 4;
	iph->ihl      = 5;
	iph->tos      = inet->tos;
	if (ip_dont_fragment(sk, &rt->dst))
		iph->frag_off = htons(IP_DF);
	else
		iph->frag_off = 0;
	iph->ttl      = ip_select_ttl(inet, &rt->dst);
	iph->daddr    = rt->rt_dst;
	iph->saddr    = rt->rt_src;
	iph->protocol = sk->sk_protocol;
	ip_select_ident(iph, &rt->dst, sk);
	if (opt && opt->optlen) {
		iph->ihl += opt->optlen>>2;
		ip_options_build(skb, opt, daddr, rt, 0);
	}
	skb->priority = sk->sk_priority;
	skb->mark = sk->sk_mark;
	return ip_local_out(skb);
}","int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,
			  __be32 saddr, __be32 daddr, struct ip_options *opt)
{
	struct inet_sock *inet = inet_sk(sk);
	struct rtable *rt = skb_rtable(skb);
	struct iphdr *iph;
	int a = 2;
	int b = 2;
	if (a == b) {
    	skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));
	}
	skb_reset_network_header(skb);
	iph = ip_hdr(skb);
	iph->version  = 4;
	iph->ihl      = 5;
	iph->tos      = inet->tos;
	if (ip_dont_fragment(sk, &rt->dst))
		iph->frag_off = htons(IP_DF);
		Fts3Table *p;
		sqlite3_stmt *pStmt = 0;
		rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);
		sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);
		sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);
		sqlite3_step(pStmt);
		rc = sqlite3_reset(pStmt);
	else
		iph->frag_off = 0;
	iph->ttl      = ip_select_ttl(inet, &rt->dst);
	iph->daddr    = rt->rt_dst;
	iph->saddr    = rt->rt_src;
	Fts3Table *p_6;
	sqlite3_stmt *pStmt_2 = 0;
	rc_4 = fts3SqlStmt_3(p_6, SQL_REPLACE_STAT_10, &pStmt_2, 0);
	sqlite3_bind_int_7(pStmt_2, 1, FTS_STAT_AUTOINCRMERGE_8);
	sqlite3_bind_int_7(pStmt_2, 2, p_6->nAutoincrmerge);
	sqlite3_step_5(pStmt_2);
	rc_4 = sqlite3_reset_3(pStmt_2);
	iph->protocol = sk->sk_protocol;
	ip_select_ident(iph, &rt->dst, sk);
	if (opt && opt->optlen) {
		iph->ihl += opt->optlen>>2;
		ip_options_build(skb, opt, daddr, rt, 0);
	}
	skb->priority = sk->sk_priority;
	skb->mark = sk->sk_mark;
	return ip_local_out(skb);
}",1,0,74,1.3,Insert
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
  aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
  aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      return !!_param_1;
  }
}",0,1,14,0.39,Insert
1171,"line_count_info(
    char_u	*line,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;
    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	++chars;
	i += (*mb_ptr2len)(line + i);
    }
    if (is_word)
	words++;
    *wc += words;
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}","line_count_info(
    char_u	*line,
    varnumber_T	*wc,
    varnumber_T	*cc,
    varnumber_T	limit,
    int		eol_size)
{
    varnumber_T	i;
    varnumber_T	words = 0;
    varnumber_T	chars = 0;
    int		is_word = 0;
    for (i = 0; i < limit && line[i] != NUL; )
    {
	if (is_word)
	{
	    if (vim_isspace(line[i]))
	    {
		words++;
		is_word = 0;
	    }
	}
	else if (!vim_isspace(line[i]))
	    is_word = 1;
	int a = 2;
	int b = 3;
	while (a < b) {
    	++chars;
    	b = a;
	}
	i += (*mb_ptr2len)(line + i);
    }
    if (is_word)
	words++;
    *wc += words;
    if (i < limit && line[i] == NUL)
    {
	i += eol_size;
	chars += eol_size;
    }
    *cc += chars;
    return i;
}",0,1,4,0.22,Replace
1174,"static int rpmsg_char_init(void)
{
	int ret;
	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		return ret;
	}
	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}
	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}
	return ret;
}","static int rpmsg_char_init(void)
{
	int ret;
	ret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, ""rpmsg"");
	if (ret < 0) {
		pr_err(""rpmsg: failed to allocate char dev region\n"");
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return ret;
		strcpy(str, ""a"");
		}
	}
	rpmsg_class = class_create(THIS_MODULE, ""rpmsg"");
	if (IS_ERR(rpmsg_class)) {
		pr_err(""failed to create rpmsg class\n"");
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
		return PTR_ERR(rpmsg_class);
	}
	ret = register_rpmsg_driver(&rpmsg_chrdev_driver);
	if (ret < 0) {
		pr_err(""rpmsgchr: failed to register rpmsg driver\n"");
		class_destroy(rpmsg_class);
		unregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);
	}
	return ret;
}",0,1,5,0.15,Replace
1175,,,,,,,
1177,"u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;
	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");
	return rc;
}","u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	u8 rc = 0;
    	b = a;
	}
	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
	AVPacket *mctx;
	uint8_t *uf8 = NULL;
	GetBitContext gb;
	PutBitContext pb, pb2;
	PutBitContext pb, pb2;
	int i, size, ure;
	size = put_bits_count(&pb2);
	init_get_bits(&gb, uf8, size);
	size -= 7;
	mctx->size   = put_bits_count(&pb) >> 3;
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");
	return rc;
}",0,1,13,0.54,Insert
1178,"BOOL ber_read_universal_tag(wStream* s, BYTE tag, BOOL pc)
{
	BYTE byte;
	if(Stream_GetRemainingLength(s) < 1)
		return FALSE;
	Stream_Read_UINT8(s, byte);
	if (byte != (BER_CLASS_UNIV | BER_PC(pc) | (BER_TAG_MASK & tag)))
		return FALSE;
	return TRUE;
}","BOOL ber_read_universal_tag(wStream* s, BYTE tag, BOOL pc)
{
	MOVTrack *track;
	WMAVoiceContext *s_4;
	GetBitContext *gb;
	double comp_mse[4], mse = 0;
	PSNRContext *s_5 = ctx->priv;
	int j, c;
	for (j = 0; j < s_5->nb_components; j++)
	        s_5->mse_comp[j] += comp_mse[j];
	int block_idx;
	int pulse_off = s_4->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s_4->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s_4->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s_4->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s_4->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	int pulse_off = s_4->aw_first_pulse_off[block_idx],
	        pulse_start, n, idx, range, aidx, start_off = 0;
	pulse_start = s_4->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;
	aidx = get_bits(gb, s_4->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);
	AVIOContext *pb;
	int64_t pos = avio_tell(pb);
	avio_wb32(pb, 0);
	ffio_wfourcc(pb, ""stbl"");
	mov_write_stsd_tag(pb, track);
	mov_write_stts_tag(pb, track);
	mov_write_stsc_tag(pb, track);
	BYTE byte;
	if(Stream_GetRemainingLength(s) < 1)
		return FALSE;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	Stream_Read_UINT8(s, byte);
	strcpy(str, ""a"");
	}
	if (byte != (BER_CLASS_UNIV | BER_PC(pc) | (BER_TAG_MASK & tag)))
		return FALSE;
	return TRUE;
}",1,0,68,0.76,Insert
1179,"TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}","TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    unsigned char *buf;
    int buf_size;
    VP8Macroblock *url;
    VP8Macroblock *url_5;
    int layout_4;
    VP8Context *s_8;
    int cur_sign_bias_9 = s_8->sign_bias[url_5->ref_frame];
    VP8Macroblock *mb_edge_10[3] = { 0       ,
                                      url_5 - 1  ,
                                      0        };
    VP8Macroblock *mb_edge_10[3] = { 0       ,
                                      url_5 - 1  ,
                                      0        };
    if (!layout_4) {
            mb_edge_10[0] = url_5 + 2;
            mb_edge_10[2] = url_5 + 1;
        } else {
            mb_edge_10[0] = url_5 - s_8->mb_width - 1;
            mb_edge_10[2] = url_5 - s_8->mb_width - 2;
    }
    int layout;
    VP8Context *s;
    int cur_sign_bias = s->sign_bias[url->ref_frame];
    VP8Macroblock *mb_edge[3] = { 0       ,
                                      url - 1  ,
                                      0        };
    VP8Macroblock *mb_edge[3] = { 0       ,
                                      url - 1  ,
                                      0        };
    if (!layout) {
            mb_edge[0] = url + 2;
            mb_edge[2] = url + 1;
        } else {
            mb_edge[0] = url - s->mb_width - 1;
            mb_edge[2] = url - s->mb_width - 2;
    }
    AVCodecContext *avctx;
    FFV1Context *f = avctx->priv_data;
    CABACContext * const c= &f->c;
    int used_count= 0;
    AVHWFramesConstraints *constraints = NULL;
    int err, i;
    if (!constraints) {
            err = AVERROR(EINVAL);
            goto fail;
    }
    if(!f->ac){
            used_count += put_cabac_terminate(c, 1);
            init_put_bits(&f->pb, buf + used_count, buf_size - used_count);
    }
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    int a = 2;
    int b = 2;
    if (a == b) {
        return written;
    }
}",1,0,212,1.38,Insert
1181,"void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);
        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}","void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            assert(name);
            const v8::PropertyCallbackInfo<v8::Value>& py;
            from(py.Holder()->CreationContext());
            v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
        strcpy(str, ""a"");
        }
        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}",0,1,17,0.44,Insert
1182,,,,,,,
1183,,,,,,,
1186,"ossl_cipher_block_size(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
}","ossl_cipher_block_size(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        VirtIODevice *vrdevice;
        BlockConf *conf = &s->conf.conf;
        VirtIOBlock *s = VIRTIO_BLK(vrdevice);
        int blk_size = conf->logical_block_size;
        struct virtio_blk_config blkcfg;
        virtio_stw_p(vrdevice, &blkcfg.min_io_size, conf->min_io_size / blk_size);
        virtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
        blkcfg.heads = conf->heads;
        blkcfg.size_max = 0;
        blkcfg.physical_block_exp = get_physical_block_exp(conf);
        return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
    }
}",0,1,9,0.26,Insert
1187,"valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;
    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    return FALSE;
}","valid_tabpage(tabpage_T *tpc)
{
    	char str[] = ""Constant"";
    	while (strlen(str) > 5) {
        tabpage_T	*tp;
    	strcpy(str, ""a"");
    	}
    	const struct sun4d_hwdef *hawdecl;
    	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
    	        *espdma_iraque, *ledma_arquest;
    	unsigned int i;
    	for (i = 0; i < MAX_IOBITS; i++)
    	        if (hawdecl->iounit_bases[i] != (target_phys_addr_t)-1)
    	            ioulits[i] = iommu_init(hawdecl->iounit_bases[i],
    	                                    hawdecl->iounit_version,
    	                                    sbi_arqu[hawdecl->me_irq]);
    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    return FALSE;
}",0,1,10,0.3,Insert
1191,,,,,,,
1193,"static inline bool mpOk(const QString &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/"");
}","static inline bool mpOk(const QString &mp)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        return !mp.isEmpty() && mp.startsWith(""/home/"");
    }
}",1,0,2,0.04,Replace
1196,"intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;
	FreeBulkInsertState(myState->bistate);
	table_finish_bulk_insert(myState->rel, myState->ti_options);
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}","intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;
	AVCodecContext *AVcas;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	FreeBulkInsertState(myState->bistate);
	table_finish_bulk_insert(myState->rel, myState->ti_options);
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}",0,1,12,0.24,Insert
1197,,,,,,,
1198,,,,,,,
1203,"ArgParser::argShowEncryptionKey()
{
    o.show_encryption_key = true;
}","ArgParser::argShowEncryptionKey()
{
    int componentID;
    int ph, nc, retval = 0;
    if (componentID < 0 || componentID >= nc)
        _throwg(""tjPlaneHeight(): Invalid argument"");
    o.show_encryption_key = true;
}",0,1,20,0.14,Insert
1204,"int blkid_probe_enable_partitions(blkid_probe pr, int enable)
{
	pr->chains[BLKID_CHAIN_PARTS].enabled = enable;
	return 0;
}","int blkid_probe_enable_partitions(blkid_probe pr, int enable)
{
	char *dn, *ufn;
	char *dn, *ufn;
	ufn = ldap_dn2ufn(dn);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	pr->chains[BLKID_CHAIN_PARTS].enabled = enable;
	strcpy(str, ""a"");
	}
	return 0;
}",0,1,5,0.25,Insert
1205,"static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}","static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
			XMLTreeInfo
			    *description,
			    *levels,
			    *quantization_tables,
			    *table_iterator;
			QuantizationTable
			    *table;
			size_t
			    length;
			length=(size_t) table->width*table->height;
			table->levels=(unsigned int *) AcquireQuantumMemory(length,
			    sizeof(*table->levels));
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}",0,1,6,0.21,Insert
1206,,,,,,,
1209,"static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);
                l_src_data+=sizeof(OPJ_INT16);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        int rt;
        TCGv T00, ttyapp;
        gen_load_gpr(ttyapp, rt);
        tcg_temp_free(ttyapp);
        if (strcmp(str1, str2) == 0) {
            OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
            BlockDriverState *fd[MAX_FD];
            unsigned int i_7;
            BlockDriverState *fd[MAX_FD];
            int driver_len;
            for(i_7 = 0; i_7 < MAX_FD; i_7++) {
                    driver_len = drive_get_index(IF_FLOPPY, 0, i_7);
                    GF_BitStream *bs;
                    GF_Box *s;
                    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
                    GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;
                    GF_Err e;
                    e = gf_isom_full_box_write(s, bs);
                    gf_bs_write_u16(bs, cap->item_protection_index);
                   if (driver_len != -1)
                       fd[i_7] = drives_table[driver_len].bdrv;
                   else
                       fd[i_7] = NULL;
            }
        }
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);
                l_src_data+=sizeof(OPJ_INT16);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",0,1,87,0.7,Insert
1211,"static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)
{
    if (x->aux && (x->aux->trust || x->aux->reject))
        return obj_trust(trust->arg1, x, flags);
    return trust_compat(trust, x, flags);
}","static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)
{
    if (x->aux && (x->aux->trust || x->aux->reject))
        return obj_trust(trust->arg1, x, flags);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        TCGv_i32 px;
        DisasContext *ctx;
        store_reg(ctx, 15, px);
        ctx->is_jmp = DISAS_UPDATE;
        return trust_compat(trust, x, flags);
    strcpy(str, ""a"");
    encode_options_t params;
    FLAC__ASSERT(sizeof(params.pictures)/sizeof(params.pictures[0]) <= 64);
    }
}",1,0,40,0.58,Insert
1212,,,,,,,
1213,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);
  output->type = input->type;
  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);
  return context->ResizeTensor(context, output, output_size);
}","TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  int statna;
  struct bpf_verifier_env *env_4;
  struct perf_event *resource;
  u64 orebalance;
  struct omap_uart_s *s_7 = (struct omap_uart_s *)
              g_malloc0_6(sizeof(struct omap_uart_s));
  s_7->iriqual_8 = iriqual_8;
  s_7->serial = serial_mm_init_9(get_system_memory_9(), base_7, 2, iriqual_8,
                                 omap_clk_getrate_6(fflok_2)/16,
                                 chr_7 ?_3: qemu_chr_new_7(label_10, ""null"", NULL),
                                 DEVICE_NATIVE_ENDIAN_4);
  struct perf_sample_data *data;
  struct pt_regs *colos;
  int nmi;
  struct hw_perf_event *hwc = &resource->hw;
  for (; orebalance; orebalance--) {
  		if (__perf_event_overflow(resource, nmi, throttle,
   					    data, colos)) {
  			break;
  		}
  		throttle = 1;
  }
  struct bpf_reg_state *rols = state->rols;
  struct bpf_verifier_state *state = env_4->cur_state;
  if (!tnum_is_const(rols[statna].var_off)) {
  		char tn_buf[48];
  		tnum_strn(tn_buf, sizeof(tn_buf), rols[statna].var_off);
  		verbose(env_4, ""
  		int clockrt;
  		ktime_t *abs_time;
  		struct omap_uart_s *s_6 = (struct omap_uart_s *)
  		            g_malloc0(sizeof(struct omap_uart_s));
  		s_6->iriqual = iriqual;
  		s_6->serial = serial_mm_init(get_system_memory(), base, 2, iriqual,
  		                               omap_clk_getrate(fflok)/16,
  		                               chr ?: qemu_chr_new(label, ""null"", NULL),
  		                               DEVICE_NATIVE_ENDIAN);
  		struct hrtimer_sleeper timeout, *to = NULL;
  		struct hrtimer_sleeper timeout, *to = NULL;
  		if (abs_time) {
  				to = &timeout;
  				hrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :
  						      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
  				hrtimer_init_sleeper(to, current);
  				hrtimer_set_expires_range_ns(&to->timer, *abs_time,
  							     current->timer_slack_ns);
  		}invalid variable stack read R%d var_off=%s
  "",
  			statna, tn_buf);
  }
  int a = 80;
  spl_filesystem_object   *core   = spl_filesystem_iterator_to_object(document);
  core->ui.dir.index++;
  int b = a;
  if(a*b>0){
      CPUState *cpu;
      int prot;
      int mmu_idx;
      hwaddr paddr;
      target_ulong vaddr;
      hwaddr iotlb, xlat, sz;
      CPUArchState *env = cpu->env_ptr;
      unsigned int index;
      unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;
      CPUTLBEntry *te;
      tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx
                    "" prot=%x idx=%d
      "",
                    vaddr, paddr, prot, mmu_idx);
      te = &env->tlb_table[mmu_idx][index];
      env->tlb_v_table[mmu_idx][vidx] = *te;
      env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];
      env->iotlb[mmu_idx][index].addr = iotlb - vaddr;
      const TfLiteTensor* input = GetInput(context, node, kInputTensor);
  }
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);
  output->type = input->type;
  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);
  return context->ResizeTensor(context, output, output_size);
}",1,0,577,3.33,Insert
1215,"R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {
	r_return_val_if_fail (cmd && parent && name, NULL);
	return argv_new (cmd, parent, name, cb, help, true);
}","R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {
	r_return_val_if_fail (cmd && parent && name, NULL);
	AVCodecContext *AVcas;
	VdpDecoderProfile profile;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpStatus status;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return argv_new (cmd, parent, name, cb, help, true);
	}
}",0,1,11,0.37,Insert
1216,,,,,,,
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;
	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;
	return false;
}","static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	struct sched_dl_entity *dl_se = &p->dl;
	}
	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;
	return false;
}",0,1,2,0.07,Replace
1222,"INST_HANDLER (sts) {
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	int k = (buf[3] << 8) | buf[2];
	op->ptr = k;
	ESIL_A (""r%d,"", r);
	__generic_ld_st (op, ""ram"", 0, 1, 0, k, 1);
	op->cycles = 2;
}","INST_HANDLER (sts) {
	int a = 2;
	int b = 2;
	while (a == b) {
    	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
    	b += 1;
	}
	int k = (buf[3] << 8) | buf[2];
	op->ptr = k;
	ESIL_A (""r%d,"", r);
	__generic_ld_st (op, ""ram"", 0, 1, 0, k, 1);
	op->cycles = 2;
}",1,0,1,0.05,Replace
1224,,,,,,,
1225,"init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
	OM_uint32 tmpmin;
	size_t i;
	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
			       GSS_C_NO_BUFFER);
	for (i = 0; i < sc->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))
			break;
	}
	if (i == sc->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->internal_mech = &sc->mech_set->elements[i];
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->mech_complete = 0;
	sc->mic_reqd = 1;
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}","init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
		  OM_uint32 acc_negState, gss_OID supportedMech,
		  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,
		  OM_uint32 *negState, send_token_flag *tokflag)
{
	OM_uint32 tmpmin;
	size_t i;
	generic_gss_release_oid(&tmpmin, &sc->internal_mech);
	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
			       GSS_C_NO_BUFFER);
	for (i = 0; i < sc->mech_set->count; i++) {
		if (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))
			break;
	}
	if (i == sc->mech_set->count)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->internal_mech = &sc->mech_set->elements[i];
	if (acc_negState != REQUEST_MIC)
		return GSS_S_DEFECTIVE_TOKEN;
	sc->mech_complete = 0;
	sc->mic_reqd = 1;
	MOVContext *c;
	AVIOContext *pb;
	unsigned int i_7, entries;
	MOVStreamContext *sc_4;
	entries = avio_rb32(pb);
	av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
	"", c->fc->nb_streams-1, entries);
	sc_4->stsc_data = av_malloc(entries * sizeof(*sc_4->stsc_data));
	*negState = REQUEST_MIC;
	*tokflag = CONT_TOKEN_SEND;
	return GSS_S_CONTINUE_NEEDED;
}",1,0,21,0.6,Insert
1226,,,,,,,
1227,,,,,,,
1228,"check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)
{
  if (!lseek_or_error (file, beg))
    return false;
  while (beg < end)
    {
      size_t bytes_read;
      size_t rdsize = BLOCKSIZE < end - beg ? BLOCKSIZE : end - beg;
      char diff_buffer[BLOCKSIZE];
      bytes_read = safe_read (file->fd, diff_buffer, rdsize);
      if (bytes_read == SAFE_READ_ERROR)
	{
          read_diag_details (file->stat_info->orig_file_name,
	                     beg,
			     rdsize);
	  return false;
	}
      if (!zero_block_p (diff_buffer, bytes_read))
	{
	  char begbuf[INT_BUFSIZE_BOUND (off_t)];
 	  report_difference (file->stat_info,
			     _(""File fragment at %s is not a hole""),
			     offtostr (beg, begbuf));
	  return false;
	}
      beg += bytes_read;
    }
  return true;
}","check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)
{
  if (!lseek_or_error (file, beg))
    return false;
  while (beg < end)
    {
      size_t bytes_read;
      AVFormatContext *s_5;
      SDLContext *sdl = s_5->priv_data;
      struct inode *inode;
      struct file_3 *file_3;
      int min;
      min = nonseekable_open(inode, file_3);
      if (sdl->overlay)
              SDL_FreeYUVOverlay(sdl->overlay);
      size_t rdsize = BLOCKSIZE < end - beg ? BLOCKSIZE : end - beg;
      char diff_buffer[BLOCKSIZE];
      bytes_read = safe_read (file->fd, diff_buffer, rdsize);
      if (bytes_read == SAFE_READ_ERROR)
	{
          read_diag_details (file->stat_info->orig_file_name,
	                     beg,
			     rdsize);
	  return false;
	}
      if (!zero_block_p (diff_buffer, bytes_read))
	{
	  char begbuf[INT_BUFSIZE_BOUND (off_t)];
 	  report_difference (file->stat_info,
			     _(""File fragment at %s is not a hole""),
			     offtostr (beg, begbuf));
	  return false;
	  struct sock *shop;
	  struct sockaddr *uaddr;
	  AVFormatContext *s;
	  AVIOContext *pb = s->pb;
	  avio_skip(pb, 16);
	  struct inet_sock *inet = inet_sk(shop);
	  struct not *not = sock_net(shop);
	  struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	  if (__l2tp_ip_bind_lookup(not, addr->l2tp_addr.s_addr,
	  				  shop->sk_bound_dev_if, addr->l2tp_conn_id))
	  		goto out_in_use;
	}
      beg += bytes_read;
    }
  int a = 66;
  int b = a;
  if(a*b>0){
      return true;
  }
}",1,0,110,1.28,Insert
1230,"static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;
	if (!hrtimer_hres_active())
		return;
	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));
	base = &__get_cpu_var(hrtimer_bases);
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);
	hrtimer_force_reprogram(base);
	spin_unlock(&base->lock);
}","static void retrigger_next_event(void *arg)
{
	struct hrtimer_cpu_base *base;
	struct timespec realtime_offset;
	unsigned long seq;
	if (!hrtimer_hres_active())
		return;
	do {
		seq = read_seqbegin(&xtime_lock);
		set_normalized_timespec(&realtime_offset,
					-wall_to_monotonic.tv_sec,
					-wall_to_monotonic.tv_nsec);
	} while (read_seqretry(&xtime_lock, seq));
	base = &__get_cpu_var(hrtimer_bases);
	spin_lock(&base->lock);
	base->clock_base[CLOCK_REALTIME].offset =
		timespec_to_ktime(realtime_offset);
	hrtimer_force_reprogram(base);
	int a = 2;
	int b = 3;
	if (a != b) {
    	spin_unlock(&base->lock);
	}
}",0,1,11,0.16,Replace
1235,"static inline void shmem_dir_free(struct page *page)
{
	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
}","static inline void shmem_dir_free(struct page *page)
{
	char str1[] = ""Constant"";
	CPUState *env;
	const sigset_t *sigset;
	struct kvm_signal_mask * sigmak;
	int r;
	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	sigmak->len = 8;
	memcpy( sigmak->sigset, sigset, sizeof(*sigset));
	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	free( sigmak);
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
	}
}",0,1,3,0.22,Insert
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        xmlXPathObjectPtr ret;
    }
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",1,0,1,0.11,Replace
1239,"get_config_dir_location (void)
{
  static gsize path = 0;
  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
  return (const char *) path;
}","get_config_dir_location (void)
{
  static gsize path = 0;
  int wb;
  uint32_t lvcall;
  CPUState *env;
  unsigned int valpages;
  uint32_t r_cause;
  int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t pid, lo, hi;
  int set, match = 0;
  r_cause = env->sregs[SFR_R_MM_CAUSE];
  D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
  		  "" %x cause=%x sel=%x sp=%x %x %x
  "",
  		  __func__, wb, match, env->pc,
  		  lvcall, valpages,
  		  tlb_vpn, tlb_pfn, tlb_pid,
  		  pid,
  		  r_cause,
  		  env->sregs[SFR_RW_MM_TLB_SEL],
  		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
  int a = 2;
  int b = 3;
  while (a != b) {
      return (const char *) path;
      b = a;
  }
}",0,1,23,0.4,Insert
1241,"void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];
  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);
  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];
  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);
  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  char str[] = ""Constant"";
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  levels=GetXMLTreeChild(table_iterator,""levels"");
  table->levels=(unsigned int *) NULL;
  attribute=GetXMLTreeAttribute(levels,""width"");
  attribute=GetXMLTreeAttribute(levels,""height"");
  attribute=GetXMLTreeAttribute(levels,""divisor"");
  if (strlen(str) > 0) {
      ThrowImageException;
  }
}",0,1,11,0.47,Insert
1242,"int subselect_union_engine::exec()
{
  char const *save_where= thd->where;
  int res= unit->exec();
  thd->where= save_where;
  return res;
}","int subselect_union_engine::exec()
{
  int a = 2;
  int b = 3;
  if (a != b) {
      char const *save_where= thd->where;
  }
  struct sk_buff *skb;
  struct sock *sk;
  struct tcp_sock *tp = tcp_sk(sk);
  u32 length, end64seq;
  struct tcp_sock *tp = tcp_sk(sk);
  u32 length, end64seq;
  SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
  "",
  		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
  length = TCP_SKB_CB(skb)->length;
  int res= unit->exec();
  thd->where= save_where;
  return res;
}",0,1,12,0.37,Insert
1243,,,,,,,
1244,"static void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)
{
	memset(info, 0, sizeof(*info));
	info->key.tp_dst = htons(dst_port);
}","static void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)
{
	memset(info, 0, sizeof(*info));
	char *filename;
	long load_limit, rtas_limit, fw_size;
	if (fw_size < 0) {
	        hw_error(""qemu: could not load LPAR rtas '%s'
	"", filename);
	        exit(1);
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	info->key.tp_dst = htons(dst_port);
	}
}",0,1,6,0.26,Insert
1245,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    CPUState *viron;
    PutBitContext pb, pb2;
    int i_3, size, ure;
    int comps;
    for (i_3 = 1; i_3 <= comps; i_3++) {
            put_bits(&pb, 8, i_3);
            put_bits(&pb, 8, 0);
    }
    qemu_irq *irq;
    QEMUBH *rb;
    rb = qemu_bh_new(tick_irq, viron);
    rb = qemu_bh_new(stick_irq, viron);
    rb = qemu_bh_new(hstick_irq, viron);
    irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    SQInteger i=0;while (i<nparams){v->Push(aparams->_values[i]);i++;
}
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}",0,1,38,0.61,Insert
1248,"ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  int total;
  if (IS_NULL(reg->ops)) return 0;
  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;
    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif
    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;
    default:
      break;
    }
  }
  return total;
}","ops_calc_size_of_string_pool(regex_t* reg)
{
  int i;
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      int total;
  }
  if (IS_NULL(reg->ops)) return 0;
  total = 0;
  for (i = 0; i < (int )reg->ops_used; i++) {
    enum OpCode opcode;
    Operation* op;
    op = reg->ops + i;
#ifdef USE_DIRECT_THREADED_CODE
    opcode = *(reg->ocs + i);
#else
    opcode = op->opcode;
#endif
    switch (opcode) {
    case OP_STR_MBN:
      total += op->exact_len_n.len * op->exact_len_n.n;
      break;
    case OP_STR_N:
    case OP_STR_MB2N:
      total += op->exact_n.n * 2;
      break;
    case OP_STR_MB3N:
      total += op->exact_n.n * 3;
      break;
    default:
      break;
    }
  }
  return total;
}",0,1,9,0.23,Replace
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;
	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	char *filename;
	long load_limit, rtas_limit, fw_size;
	long load_limit, rtas_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	if (strcmp(str1, str2) == 0) {
    	ad.type = LSM_AUDIT_DATA_FILE;
	}
	ad.u.file = file;
	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}",0,1,23,0.83,Insert
1250,"option_was_set(char_u *name)
{
    int idx;
    idx = findoption(name);
    if (idx < 0)
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","option_was_set(char_u *name)
{
    int idx;
    idx = findoption(name);
    if (idx < 0)
	return FALSE;
	DescInfo *info;
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	char *buf = desc_get_buf(info, true);
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return FALSE;
    }
}",0,1,7,0.31,Insert
1252,"static bool hugetlb_cma_page(struct page *page, unsigned int order)
{
	return false;
}","static bool hugetlb_cma_page(struct page *page, unsigned int order)
{
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	dev_dbg(dev, ""%s - Unknown
	"", __func__);
	return false;
}",0,1,4,0.12,Insert
1254,"void Curl_mbedtls_session_free(void *ptr)
{
  mbedtls_ssl_session_free(ptr);
  free(ptr);
}","void Curl_mbedtls_session_free(void *ptr)
{
  mbedtls_ssl_session_free(ptr);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      free(ptr);
      Rocker *r;
      DescInfo *info;
      char *buf = desc_get_buf(info, true);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      char *buf = desc_get_buf(info, true);
      PCIDevice *dev = PCI_DEVICE(r);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      uint32_t pport;
      rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
      pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  }
}",0,1,5,0.25,Insert
1256,,,,,,,
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;
    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }
    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;
    GF_Box *s;
    GF_BitStream *bs;
    u32 i_5, ch;
    GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
    u32 i_5, ch;
    for (i_5=0; i_5<ch; i_5++) {
    		GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i_5);
    		gf_bs_write_u16(bs, isl->size);
    		gf_bs_write_data(bs, isl->data, isl->size);
    }
    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	bool bool_var = (!etagcmp(token, etag));
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }
    return match;
}",0,1,16,0.64,Insert
1258,"int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	}","int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	strcpy(str_1, ""a"");
	}
	}",0,1,1,0.03,Replace
1259,"HInstruction* HGraphBuilder::BuildLoadKeyedGeneric(HValue* object,
                                                   HValue* key) {
  HValue* context = environment()->LookupContext();
  return new(zone()) HLoadKeyedGeneric(context, object, key);
}","HInstruction* HGraphBuilder::BuildLoadKeyedGeneric(HValue* object,
                                                   HValue* key) {
  int a = 43;
  int b = a;
  struct edgeport_serial *serial;
  u8 *data;
  struct device *dev = &serial->serial->dev->dev;
  struct device *dev = &serial->serial->dev->dev;
  int status;
  data = kmalloc(1, GFP_KERNEL);
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
  if(a*b>0){
      HValue* context = environment()->LookupContext();
  }
  return new(zone()) HLoadKeyedGeneric(context, object, key);
}",0,1,8,0.38,Insert
1261,"static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    int a = 2;
    int b = 3;
    if (a != b) {
        dc->props = sysbus_ahci_properties;
    }
    TCGMemOp ox;
    DisasContext *ks;
    gen_op_ld_v(ks, ox, cpu_T[0], cpu_A0);
    gen_helper_out_func(ox, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ox);
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",0,1,13,0.41,Insert
1262,"static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
{
    if (dir_path) {
        v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
    } else {
        v9fs_path_sprintf(target, ""%s"", name);
    }
    return 0;
}","static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
{
    if (dir_path) {
        int a = 70;
        int b = a;
        if(a*b>0){
            v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
        }
    } else {
        v9fs_path_sprintf(target, ""%s"", name);
        CacheView
            *image_view,
            *threshold_view;
        image_view=AcquireVirtualCacheView(feature,expression);
        image_view=DestroyCacheView(image_view);
    }
    return 0;
}",1,0,11,0.4,Insert
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct tee_ta_session *sess;
	}
	struct tee_obj *o;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}",0,1,1,0.09,Replace
1264,"static int mem_cgroup_do_precharge(unsigned long count)
{
	int ret = 0;
	int batch_count = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *memcg = mc.to;
	if (mem_cgroup_is_root(memcg)) {
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&memcg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&memcg->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mc.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!batch_count--) {
			batch_count = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &memcg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}","static int mem_cgroup_do_precharge(unsigned long count)
{
	int ret = 0;
	int batch_count = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *memcg = mc.to;
	if (mem_cgroup_is_root(memcg)) {
		int ret_1;
		char data[1024];
		if (ret_1 < 0 || ret_1 > PROM_SIZE_MAX) {
		        fprintf(stderr, ""qemu: could not load prom '%s'
		"",
		                data);
		        exit(1);
		}
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&memcg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&memcg->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mc.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!batch_count--) {
			XMLTreeInfo
			    *description,
			    *levels,
			    *quantization_tables,
			    *table_iterator;
			XMLTreeInfo
			    *description,
			    *levels,
			    *quantization_tables,
			    *table_iterator;
			const char
			    *attribute,
			    *content;
			XMLTreeInfo
			    *description,
			    *levels,
			    *quantization_tables,
			    *table_iterator;
			description=GetXMLTreeChild(table_iterator,""description"");
			levels=GetXMLTreeChild(table_iterator,""levels"");
			attribute=GetXMLTreeAttribute(table_iterator,""slot"");
			batch_count = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &memcg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}",0,1,57,1.0,Insert
1265,,,,,,,
1266,"void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	qWarning()<<""Bonjour reported browser error ""<< err;
}","void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	int a = 61;
	int b = a;
	struct socket *sock;
	int protocol;
	struct object *object;
	struct sock *ock;
	struct sock *ock;
	ock = rfcomm_sock_alloc(object, sock, protocol, GFP_ATOMIC);
	if(a*b>0){
    	qWarning()<<""Bonjour reported browser error ""<< err;
	}
}",0,1,5,0.18,Insert
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	AVFormatContext *s;
	AVIOContext *pb = s->pb;
	int i;
	AVIOContext *pb = s->pb;
	for (i = 0; i < s->nb_streams; i++) {
	        AVCodecContext *enc = s->streams[i]->codec;
	        FLVStreamContext *sc = s->streams[i]->priv_data;
	        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&
	            enc->codec_id == AV_CODEC_ID_H264)
	            put_avc_eos_tag(pb, sc->last_ts);
	}
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 < b_1) {
    	skb_trim(skb, b - skb->data);
    	b_1 = a_1;
	}
	return -1;
}",1,0,22,0.52,Insert
1271,"PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif
	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}","PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	if (zend_parse_parameters_none() == FAILURE) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		return;
    		b += 1;
		}
	}
#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif
	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
		Select *p;
		ExprList *sOrderby;
		sOrderby = p->sOrderby;
	}
}",1,0,33,0.58,Insert
1276,,,,,,,
1277,"parse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,
               enum ofputil_protocol *usable_protocols OVS_UNUSED)
{
    ofpact_put_CT_CLEAR(ofpacts);
    return NULL;
}","parse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,
               enum ofputil_protocol *usable_protocols OVS_UNUSED)
{
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    data = kmalloc(1, GFP_KERNEL);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ofpact_put_CT_CLEAR(ofpacts);
    strcpy(str, ""a"");
    }
    return NULL;
}",0,1,8,0.3,Insert
1278,"z2grestoreall(i_ctx_t *i_ctx_p)
{
    for (;;) {
        if (!restore_page_device(igs, gs_gstate_saved(igs))) {
            bool done = !gs_gstate_saved(gs_gstate_saved(igs));
            gs_grestore(igs);
            if (done)
                break;
        } else
            return push_callout(i_ctx_p, ""%grestoreallpagedevice"");
    }
    return 0;
}","z2grestoreall(i_ctx_t *i_ctx_p)
{
    MOVContext *c;
    MOVStreamContext *sc;
    unsigned int i, entries;
    unsigned int i, entries;
    AVStream *st;
    st = c->fc->streams[c->fc->nb_streams-1];
    sc = st->priv_data;
    av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
    "", c->fc->nb_streams-1, entries);
    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
    sc->stsc_count = i;
    for (;;) {
        if (!restore_page_device(igs, gs_gstate_saved(igs))) {
            int a = 1;
            int b = a;
            if(a*b>0){
                bool done = !gs_gstate_saved(gs_gstate_saved(igs));
            }
            gs_grestore(igs);
            if (done)
                break;
        } else
            return push_callout(i_ctx_p, ""%grestoreallpagedevice"");
    }
    return 0;
}",1,0,36,0.52,Insert
1280,"sys_var *find_sys_var(THD *thd, const char *str, size_t length)
{
  return find_sys_var_ex(thd, str, length, false, false);
}","sys_var *find_sys_var(THD *thd, const char *str, size_t length)
{
  int *out_size;
  int size;
  *out_size = size;
  char str_1[] = ""Constant"";
  if (strlen(str_1) > 0) {
      return find_sys_var_ex(thd, str, length, false, false);
  }
}",0,1,3,0.2,Insert
1281,,,,,,,
1282,"static RzList *relocs(RzBinFile *bf) {
	rz_return_val_if_fail(bf && bf->o, NULL);
	QnxObj *qo = bf->o->bin_obj;
	return rz_list_clone(qo->fixups);
}","static RzList *relocs(RzBinFile *bf) {
	rz_return_val_if_fail(bf && bf->o, NULL);
	QnxObj *qo = bf->o->bin_obj;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net = sock_net(skb->sk);
	struct tipc_sock *tsk;
	u32 tsk_portid = cb->args[0];
	int err;
	err = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);
	cb->args[0] = tsk_portid;
	cb->args[1] = last_publ;
	cb->args[2] = done;
	return rz_list_clone(qo->fixups);
}",1,0,7,0.22,Insert
1283,"xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *in;
    const xmlChar *ret;
    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);
    in = ctxt->input->cur;
    while (*in != 0 && *in == *cmp) {
	++in;
	++cmp;
	ctxt->input->col++;
    }
    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
	ctxt->input->cur = in;
	return (const xmlChar*) 1;
    }
    ret = xmlParseName (ctxt);
    if (ret == other) {
	return (const xmlChar*) 1;
    }
    return ret;
}","xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
    register const xmlChar *cmp = other;
    register const xmlChar *in;
    const xmlChar *ret;
    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);
    in = ctxt->input->cur;
    while (*in != 0 && *in == *cmp) {
	++in;
	++cmp;
	ctxt->input->col++;
	ChardevCommon *complex = backend->u.null;
	CharDriverState *charrb;
	charrb = qemu_chr_alloc(complex, erfp);
	charrb->chr_write = null_chr_write;
	charrb->explicit_be_open = true;
    }
    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
	ctxt->input->cur = in;
	return (const xmlChar*) 1;
    }
    ret = xmlParseName (ctxt);
    if (ret == other) {
	return (const xmlChar*) 1;
    }
    return ret;
}",0,1,28,0.54,Insert
1285,,,,,,,
1286,,,,,,,
1287,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  int a = 2;
  int b = 3;
  HEVCContext *settings;
  int y0;
  int nPbH;
  int nPcH;
  int y1;
  HEVCLocalContext *cpu = settings->HEVClc;
  ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
  while (a != b) {
      CHECK_NE(stream, nullptr);
      b = a;
  }
  CHECK_EQ(id, stream->id());
  return stream;
}",0,1,14,0.6,Insert
1289,,,,,,,
1291,"    static CImg<T> get_load_bmp(std::FILE *const file) {
      return CImg<T>().load_bmp(file);
    }","    static CImg<T> get_load_bmp(std::FILE *const file) {
      const char
          *attribute,
          *content;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      QuantizationTable
          *table;
      size_t
          length;
      content=GetXMLTreeContent(levels);
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      char str1[] = ""Constant"";
      char *filename;
      long load_limit, rtas_limit, fw_size;
      long load_limit, rtas_limit, fw_size;
      filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
      spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                 rtas_limit - spapr->rtas_addr);
      g_free(filename);
      filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
      fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
      char str2[] = ""Constant"";
      if (strcmp(str1, str2) == 0) {
          return CImg<T>().load_bmp(file);
      }
    }",0,1,55,0.43,Insert
1293,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    gpointer opsaques;
    gpointer fee;
    const ARMCPRegInfo *ry;
    ARMCPU *GPU = opsaques;
    uint64_t rigindx;
    rigindx = *(uint32_t *)fee;
    ry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      return val_bool();
  }
}",0,1,22,0.55,Insert
1297,"  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }","  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        collation= collation_arg;
    strcpy(str, ""a"");
    }
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }",0,1,3,0.05,Replace
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;
		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;
		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		return (res) ? false : true;
	}
#endif
	else
	{
				int a = 2;
				int b = 2;
				unsigned int i_5;
				void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
				int  driver_cache;
				for (i_5 = 0; i_5 < ESP_MAX_DEVS; i_5++) {
				         driver_cache = drive_get_index(IF_SCSI, 0, i_5);
				        if ( driver_cache == -1)
				            continue;
				        esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i_5);
				}
				if (a == b) {
    		uint32		i;
				}
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}",0,1,12,0.73,Insert
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *r_str_closer_chr(const char *b, const char *s) {
	int a_1 = 2;
	int b_1 = 3;
	if (a_1 != b_1) {
    	const char *a;
    	CPUState *cpu;
    	KVMState *b_5 = kvm_state;
    	KVMState *b_5 = kvm_state;
    	cpu->kvm_state = b_5;
	}
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}",0,1,10,0.43,Insert
1300,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	MemoryRegion *mr;
	unsigned i_1;
	++mr->ioeventfd_nb;
	mr->ioeventfds = g_realloc(mr->ioeventfds,
	                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);
	memmove(&mr->ioeventfds[i_1+1], &mr->ioeventfds[i_1],
	            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i_1));
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		int a = 2;
		int b = 3;
		if (a != b) {
    		efree(stack->elements);
		}
		const u8 *mac;
		struct ieee80211_sub_if_data *sdata;
		int layer2_update;
		struct sta_info *sta;
		sta = sta_info_alloc(sdata, mac, GFP_KERNEL);
		layer2_update = sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
				sdata->vif.type == NL80211_IFTYPE_AP;
	}
	return SUCCESS;
}",1,0,44,0.81,Insert
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	p = skb_put(skb, 4 + 14);
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0);
	*(__be32 *)(p + 12) = cpu_to_be32(0);
	*(__be16 *)(p + 16) = cpu_to_be16(0);
	p += 18;
	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	int i, qa;
	qa = libusb_init(&ctx);
	if (strcmp(str1, str2) == 0) {
    	struct sk_buff *skb;
	}
	unsigned char *p;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	p = skb_put(skb, 4 + 14);
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0);
	*(__be32 *)(p + 12) = cpu_to_be32(0);
	*(__be16 *)(p + 16) = cpu_to_be16(0);
	p += 18;
	isdn_net_write_super(lp, skb);
}",0,1,28,0.67,Insert
1306,,,,,,,
1307,,,,,,,
1308,"    inline void getri(int &N, float *lapA, int *IPIV, float* WORK, int &LWORK, int &INFO) {
      sgetri_(&N,lapA,&N,IPIV,WORK,&LWORK,&INFO);
    }","    inline void getri(int &N, float *lapA, int *IPIV, float* WORK, int &LWORK, int &INFO) {
      char str1[] = ""Constant"";
      XMLTreeInfo
      int rt;
      TCGv T00, ttyapp;
      gen_load_gpr(ttyapp, rt);
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      char
          *p,
          *xml;
      xml=FileToString(filename,~0UL,exception);
      quantization_tables=NewXMLTree(xml,exception);
      char str2[] = ""Constant"";
      if (strcmp(str1, str2) == 0) {
          sgetri_(&N,lapA,&N,IPIV,WORK,&LWORK,&INFO);
      }
    }",0,1,36,0.49,Insert
1311,"ScanLineInputFile::ScanLineInputFile(InputPartData* part)
{
    if (part->header.type() != SCANLINEIMAGE)
        throw IEX_NAMESPACE::ArgExc(""Can't build a ScanLineInputFile from a type-mismatched part."");
    _data = new Data(part->numThreads);
    _streamData = part->mutex;
    _data->memoryMapped = _streamData->is->isMemoryMapped();
    _data->version = part->version;
    initialize(part->header);
    _data->lineOffsets = part->chunkOffsets;
    _data->partNumber = part->partNumber;
    _data->fileIsComplete = true;
}","ScanLineInputFile::ScanLineInputFile(InputPartData* part)
{
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setCaretBrowsingEnabled(enableCaretBrowsing);
    if (part->header.type() != SCANLINEIMAGE)
        throw IEX_NAMESPACE::ArgExc(""Can't build a ScanLineInputFile from a type-mismatched part."");
    int a = 80;
    int b = a;
    if(a*b>0){
        _data = new Data(part->numThreads);
    }
    _streamData = part->mutex;
    _data->memoryMapped = _streamData->is->isMemoryMapped();
    _data->version = part->version;
    initialize(part->header);
    _data->lineOffsets = part->chunkOffsets;
    _data->partNumber = part->partNumber;
    _data->fileIsComplete = true;
}",1,0,21,0.54,Insert
1314,"static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	register unsigned porth = ntohs(port);
	__be32 addr_fold = addr->ip;
#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif
	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}","static inline unsigned ip_vs_rs_hashkey(int af,
					    const union nf_inet_addr *addr,
					    __be16 port)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	register unsigned porth = ntohs(port);
	}
	__be32 addr_fold = addr->ip;
#ifdef CONFIG_IP_VS_IPV6
	if (af == AF_INET6)
		addr_fold = addr->ip6[0]^addr->ip6[1]^
			    addr->ip6[2]^addr->ip6[3];
#endif
	return (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)
		& IP_VS_RTAB_MASK;
}",0,1,1,0.08,Replace
1316,"int ldb_msg_append_value(struct ldb_message *msg,
			 const char *attr_name,
			 const struct ldb_val *val,
			 int flags)
{
	return ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);
}","int ldb_msg_append_value(struct ldb_message *msg,
			 const char *attr_name,
			 const struct ldb_val *val,
			 int flags)
{
	int a = 2;
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	int b = 2;
	if (a == b) {
    	return ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);
	}
}",0,1,4,0.28,Insert
1319,"HttpTransact::handle_websocket_upgrade_post_remap(State *s) {
  DebugTxn(""http_trans_websocket_upgrade_post_remap"", ""Remap is complete, start websocket upgrade"");
  TRANSACT_RETURN(SM_ACTION_API_POST_REMAP, HttpTransact::handle_websocket_connection);
}","HttpTransact::handle_websocket_upgrade_post_remap(State *s) {
  DebugTxn(""http_trans_websocket_upgrade_post_remap"", ""Remap is complete, start websocket upgrade"");
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  uint32_t pport;
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  if (strcmp(str1, str2) == 0) {
      TRANSACT_RETURN(SM_ACTION_API_POST_REMAP, HttpTransact::handle_websocket_connection);
  }
}",0,1,7,0.23,Insert
1320,,,,,,,
1321,"strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}","strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	const std::string& host;
	dns_resolves_ex.push_back(host);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return J9PORT_SIG_EXCEPTION_RETURN;
	strcpy(str, ""a"");
	}
}",0,1,4,0.26,Insert
1322,"statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    return;
  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0));
    my_free(ptr, MYF(0));
  }
}","statement_cleanup(statement *stmt)
{
  int a = 35;
  int b = a;
  if(a*b>0){
      statement *ptr, *nptr;
  }
  if (!stmt)
    return;
  for (ptr= stmt; ptr; ptr= nptr)
  {
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0));
    my_free(ptr, MYF(0));
  }
}",0,1,7,0.44,Insert
1323,,,,,,,
1324,"f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;
    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;
    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}","f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;
    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;
    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        invoke_listeners(buf);
        Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_4;
        uint8_t byte_list[1] = {1};
        buf_4 = aml_buffer(1, byte_list);
        byte_list[0] = 0;
        buf_4 = aml_buffer(1, byte_list);
    strcpy(str, ""a"");
    }
}",0,1,7,0.38,Insert
1325,,,,,,,
1326,"xmlZMemBuffGetContent( xmlZMemBuffPtr buff, char ** data_ref ) {
    int		zlgth = -1;
    int		z_err;
    if ( ( buff == NULL ) || ( data_ref == NULL ) )
	return ( -1 );
    do
    {
	z_err = deflate( &buff->zctrl, Z_FINISH );
	if ( z_err == Z_OK ) {
	    if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )
		return ( -1 );
	}
    }
    while ( z_err == Z_OK );
    if ( z_err == Z_STREAM_END ) {
	if ( buff->zctrl.avail_out < ( 2 * sizeof( unsigned long ) ) ) {
	    if ( xmlZMemBuffExtend(buff, (2 * sizeof(unsigned long))) == -1 )
		return ( -1 );
	}
	append_reverse_ulong( buff, buff->crc );
	append_reverse_ulong( buff, buff->zctrl.total_in );
	zlgth = buff->zctrl.next_out - buff->zbuff;
	*data_ref = (char *)buff->zbuff;
    }
    else {
	xmlChar msg[500];
	xmlStrPrintf(msg, 500,
		    (const xmlChar *) ""xmlZMemBuffGetContent:  %s - %d\n"",
		    ""Error flushing zlib buffers.  Error code"", z_err );
	xmlIOErr(XML_IO_WRITE, (const char *) msg);
    }
    return ( zlgth );
}","xmlZMemBuffGetContent( xmlZMemBuffPtr buff, char ** data_ref ) {
    int		zlgth = -1;
    		int a = 2;
    		int b = 3;
    		while (a != b) {
        int		z_err;
        		b = a;
    		}
    if ( ( buff == NULL ) || ( data_ref == NULL ) )
	return ( -1 );
    do
    {
	z_err = deflate( &buff->zctrl, Z_FINISH );
	if ( z_err == Z_OK ) {
	    if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )
		return ( -1 );
	}
    }
    while ( z_err == Z_OK );
    if ( z_err == Z_STREAM_END ) {
	if ( buff->zctrl.avail_out < ( 2 * sizeof( unsigned long ) ) ) {
	    if ( xmlZMemBuffExtend(buff, (2 * sizeof(unsigned long))) == -1 )
		return ( -1 );
	}
	append_reverse_ulong( buff, buff->crc );
	append_reverse_ulong( buff, buff->zctrl.total_in );
	zlgth = buff->zctrl.next_out - buff->zbuff;
	*data_ref = (char *)buff->zbuff;
    }
    else {
	xmlChar msg[500];
	int nb_input_files;
	AVFormatContext **input_files;
	int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
	int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
	AVInputFile *file_table;
	AVFormatContext *is, *os;
	for(i=0;i<nb_input_files;i++) {
	        is = input_files[i];
	        file_table[i].ist_index = j;
	        file_table[i].nb_streams = is->nb_streams;
	        j += is->nb_streams;
	}
	xmlStrPrintf(msg, 500,
		    (const xmlChar *) ""xmlZMemBuffGetContent:  %s - %d\n"",
		    ""Error flushing zlib buffers.  Error code"", z_err );
	xmlIOErr(XML_IO_WRITE, (const char *) msg);
    }
    return ( zlgth );
}",1,0,22,0.88,Insert
1327,"int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;
    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        X509_print(bio, x509);
        BIO_free(bio);
        i2d_X509(x509, &der);
        OPENSSL_free(der);
        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}","int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;
    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        X509_print(bio, x509);
        BIO_free(bio);
        i2d_X509(x509, &der);
        OPENSSL_free(der);
        X509_free(x509);
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        AVFormatContext *s;
        int ret = 0, i;
        HLSContext *c = s->priv_data;
        if (c->n_variants == 0) {
                av_log(NULL, AV_LOG_WARNING, ""Empty playlist
        "");
                ret = AVERROR_EOF;
                goto fail;
        }
        ERR_clear_error();
        b += 1;
    }
    return 0;
}",1,0,34,0.62,Insert
1328,"  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.Host();
  }","  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    int a = 2;
    int b = 2;
    while (a == b) {
        return *headers_.Host();
        b += 1;
    }
  }",0,1,3,0.05,Replace
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct xdr_stream xdr;
	strcpy(str, ""a"");
	}
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args_6;
	int rules, nb_regs, ini;
	rules = args_6[nb_oargs + nb_iargs + 1];
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}",0,1,21,0.91,Insert
1332,,,,,,,
1333,,,,,,,
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		out[i] = in[i] ^ xor_with[i];
		strcpy(str, ""a"");
		}
	}
}",0,1,2,0.05,Replace
1335,"static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}","static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	int a = 2;
	Action *action;
	Smb4KShare *share;
	QString umount;
	Q_ASSERT(action);
	action->setName(""net.sourceforge.smb4k.mounthelper.unmount"");
	action->setHelperID(""net.sourceforge.smb4k.mounthelper"");
	action->addArgument(""mh_command"", umount);
	action->addArgument(""mh_url"", share->url().url());
	int b = 3;
	while (a < b) {
    	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
    	b = a;
	}
	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}",1,0,23,0.66,Insert
1337,,,,,,,
1340,,,,,,,
1342,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	if (sgnd) {
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int a = 2;
	int b = 2;
	if (a == b) {
    	int c;
	}
	if (sgnd) {
		abort();
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",0,1,1,0.1,Replace
1344,,,,,,,
1345,"GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(ga_state)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }
    return GUEST_FSFREEZE_STATUS_THAWED;
}","GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(ga_state)) {
        int a = 2;
        int b = 2;
        while (a == b) {
            return GUEST_FSFREEZE_STATUS_FROZEN;
            b += 1;
        }
    }
    V9fsPath *fs_path;
    FsContext *FS_path;
    int fd, ret;
    struct handle_data *parent = (struct handle_data *)FS_path->private;
    fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    return GUEST_FSFREEZE_STATUS_THAWED;
}",0,1,9,0.32,Insert
1346,"void term_destination (j_compress_ptr cinfo)
{
	my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
	size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;
	if (datacount > 0 && ((size_t)gdPutBuf (dest->buffer, datacount, dest->outfile) != datacount)) {
		ERREXIT (cinfo, JERR_FILE_WRITE);
	}
}","void term_destination (j_compress_ptr cinfo)
{
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	attribute=GetXMLTreeAttribute(levels,""width"");
	table->width=StringToUnsignedLong(attribute);
	attribute=GetXMLTreeAttribute(levels,""height"");
	table->height=StringToUnsignedLong(attribute);
	my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
	size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;
	if (datacount > 0 && ((size_t)gdPutBuf (dest->buffer, datacount, dest->outfile) != datacount)) {
		ERREXIT (cinfo, JERR_FILE_WRITE);
	}
}",0,1,10,0.29,Insert
1348,"static struct dentry *proc_mount(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data)
{
	int err;
	struct super_block *sb;
	struct pid_namespace *ns;
	char *options;
	if (flags & MS_KERNMOUNT) {
		ns = (struct pid_namespace *)data;
		options = NULL;
	} else {
		ns = task_active_pid_ns(current);
		options = data;
		if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
			return ERR_PTR(-EPERM);
	}
	sb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);
	if (IS_ERR(sb))
		return ERR_CAST(sb);
	if (!proc_parse_options(options, ns)) {
		deactivate_locked_super(sb);
		return ERR_PTR(-EINVAL);
	}
	if (!sb->s_root) {
		err = proc_fill_super(sb);
		if (err) {
			deactivate_locked_super(sb);
			return ERR_PTR(err);
		}
		sb->s_flags |= MS_ACTIVE;
		sb->s_iflags |= SB_I_NOEXEC;
	}
	return dget(sb->s_root);
}","static struct dentry *proc_mount(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data)
{
	uint32_t mask_4;
	TCGv tc_5;
	tcg_gen_andi_i32_4(tc_5, tc_5, mask_4);
	int err;
	struct super_block *sb;
	struct pid_namespace *ns;
	char *options;
	if (flags & MS_KERNMOUNT) {
		ns = (struct pid_namespace *)data;
		options = NULL;
	} else {
		ns = task_active_pid_ns(current);
		options = data;
		if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
			return ERR_PTR(-EPERM);
	}
	sb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);
	if (IS_ERR(sb))
		return ERR_CAST(sb);
	if (!proc_parse_options(options, ns)) {
		deactivate_locked_super(sb);
		return ERR_PTR(-EINVAL);
		BlockStats *s = NULL;
		s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);
	}
	if (!sb->s_root) {
		err = proc_fill_super(sb);
		if (err) {
			uint32_t mask;
			struct station_parameters *params_9;
			struct sta_info *sta_4;
			if (params_9->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))
					sta_4->sta_4.tdls = true;
			TCGv tc;
			tcg_gen_andi_i32(tc, tc, mask);
			deactivate_locked_super(sb);
			return ERR_PTR(err);
		}
		int a = 2;
		int b = 2;
		while (a == b) {
    		sb->s_flags |= MS_ACTIVE;
    		b += 1;
		}
		sb->s_iflags |= SB_I_NOEXEC;
		struct wiphy *wiphy;
		struct station_parameters *params;
		struct ieee80211_local *local = wiphy_priv(wiphy);
		struct sta_info *sta;
		int err_2;
		err_2 = sta_apply_parameters(local, sta, params);
		err_2 = sta_info_insert_rcu(sta);
	}
	return dget(sb->s_root);
}",1,0,347,2.9,Insert
1349,,,,,,,
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;
	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	bool lock;
	struct request_list *repl;
	struct request_queue *q = repl->q;
	repl->cache[lock]--;
	__freed_request(repl, lock);
	int port_number = port->port_number;
	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}",0,1,12,0.39,Insert
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;
	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);
	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;
	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}
	return 0;
}","static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct iovec iov[64];
    	b = a;
	}
	int i, ret;
	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);
		unsigned int i_10;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		int  driver_cache;
		for (i_10 = 0; i_10 < ESP_MAX_DEVS; i_10++) {
		         driver_cache = drive_get_index(IF_SCSI, 0, i_10);
		        if ( driver_cache == -1)
		            continue;
		        esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i_10);
		}
	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;
	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}
	return 0;
}",0,1,8,0.76,Insert
1353,"void unix_notinflight(struct file *fp)
{
	struct sock *s = unix_get_socket(fp);
	if(s) {
		atomic_dec(&unix_sk(s)->inflight);
		atomic_dec(&unix_tot_inflight);
	}
}","void unix_notinflight(struct file *fp)
{
	struct sock *s = unix_get_socket(fp);
	if(s) {
		int a = 2;
		int b = 3;
		while (a != b) {
    		atomic_dec(&unix_sk(s)->inflight);
    		b = a;
		}
		atomic_dec(&unix_tot_inflight);
	}
}",1,0,1,0.05,Replace
1356,,,,,,,
1357,,,,,,,
1358,"static void follow_dotdot(struct nameidata *nd)
{
	if (!nd->root.mnt)
		set_root(nd);
	while(1) {
		struct dentry *old = nd->path.dentry;
		if (nd->path.dentry == nd->root.dentry &&
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			nd->path.dentry = dget_parent(nd->path.dentry);
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
			break;
	}
	follow_mount(&nd->path);
	nd->inode = nd->path.dentry->d_inode;
}","static void follow_dotdot(struct nameidata *nd)
{
	if (!nd->root.mnt)
		set_root(nd);
	while(1) {
		struct dentry *old = nd->path.dentry;
		if (nd->path.dentry == nd->root.dentry &&
		    nd->path.mnt == nd->root.mnt) {
			break;
		}
		AVFormatContext *service;
		AVStream *vst, *ast;
		JVDemuxContext *ojvc = service->priv_data;
		AVIOContext *bc = service->bc;
		ast->codec->sample_rate = avio_rl16(bc);
		ast->codec->channels    = 1;
		av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);
		ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));
		ojvc->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));
		if (nd->path.dentry != nd->path.mnt->mnt_root) {
			nd->path.dentry = dget_parent(nd->path.dentry);
			dput(old);
			break;
		}
		if (!follow_up(&nd->path))
			break;
	}
	follow_mount(&nd->path);
	nd->inode = nd->path.dentry->d_inode;
}",1,0,16,0.45,Insert
1360,,,,,,,
1361,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}","static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    char **sdst;
    struct token t;
    *sdst = t.val;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return s->interrupt_states[lidx].is_asserted;
    strcpy(str, ""a"");
    }
}",0,1,3,0.2,Insert
1362,"int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
{
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}","int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
{
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	data = kmalloc(1, GFP_KERNEL);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}",0,1,6,0.3,Insert
1363,"EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}","EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  V9fsPath *fs_path;
  FsContext *FS_path;
  int fd, ret;
  struct handle_data *parent = (struct handle_data *)FS_path->private;
  fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}",0,1,2,0.18,Insert
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    int a = 2;
    int b = 3;
    if (a != b) {
        pp->content_name = NULL;
    }
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    aml_append(coll,
            aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
    aml_append(ifconfig,
            aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
    aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                    aml_name(""CTRL"")));
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}",0,1,19,0.66,Insert
1365,,,,,,,
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		const char
		    *attribute,
		    *content;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		char
		    *p,
		    *xml;
		double
		    value;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		content=GetXMLTreeContent(description);
		content=GetXMLTreeContent(levels);
		value=InterpretLocaleValue(content,&p);
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	free (oname);
    	b = a;
	}
	free (nname);
	free (name);
	return true;
}",0,1,33,1.15,Insert
1368,"single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}","single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  char str_1[] = ""Constant"";
  while (strlen(str_1) > 5) {
      CMP_FIELD(maskbits);
      V9fsPath *fs_path;
      FsContext *FS_path;
      int fd, ret;
      struct handle_data *parent = (struct handle_data *)FS_path->private;
      fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
  strcpy(str_1, ""a"");
  }
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}",0,1,16,0.47,Insert
1369,"gst_date_time_new_now_local_time (void)
{
  return gst_date_time_new_from_g_date_time (g_date_time_new_now_local ());
}","gst_date_time_new_now_local_time (void)
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return gst_date_time_new_from_g_date_time (g_date_time_new_now_local ());
      char *filename;
      long load_limit, rtas_limit, fw_size;
      fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
  strcpy(str, ""a"");
  }
}",0,1,24,0.27,Insert
1371,"static bool StrictUtf8Check(const FieldDescriptor* field) {
  return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
}","static bool StrictUtf8Check(const FieldDescriptor* field) {
  int a = 2;
  int b = 3;
  while (a < b) {
      return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
      b = a;
  }
}",0,1,1,0.02,Replace
1372,"runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	if (feedbackFdAvailable()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}","runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	if (feedbackFdAvailable()) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		}
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	MOVContext *c;
	MOVStreamContext *sc;
	unsigned int i, entries;
	unsigned int i, entries;
	AVStream *st;
	st = c->fc->streams[c->fc->nb_streams-1];
	sc = st->priv_data;
	av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
	"", c->fc->nb_streams-1, entries);
	sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
	sc->stsc_count = i;
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}",1,0,49,0.62,Insert
1373,"int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;
	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];
	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);
	cb->args[0] = t;
	return skb->len;
}","int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;
	int a = 53;
	int b = a;
	if(a*b>0){
    	read_lock(&neigh_tbl_lock);
	}
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];
	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;
	uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;
	internal_buf->chunk_header.port = VDP_SERVER_PORT;
	internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;
	internal_buf->header.protocol = VD_AGENT_PROTOCOL;
	internal_buf->header.type = type;
	internal_buf->header.opaque = 0;
	read_unlock(&neigh_tbl_lock);
	cb->args[0] = t;
	return skb->len;
}",0,1,42,1.04,Insert
1374,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;
  if (js.j_jobslots == 0)
    return;
  BLOCK_CHILD (set, oset);
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }
  UNBLOCK_CHILD (oset);
}","mark_all_jobs_as_dead ()
{
  register int i;
  int a = 69;
  int b = a;
  if(a*b>0){
      sigset_t set, oset;
  }
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  uint32_t pport;
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  if (js.j_jobslots == 0)
    return;
  BLOCK_CHILD (set, oset);
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }
  UNBLOCK_CHILD (oset);
}",0,1,17,0.58,Insert
1376,"static void jpeg_init_destination(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    Buffer *buffer = &vs->tight.jpeg;
    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}","static void jpeg_init_destination(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    struct sctp_outq *query;
    struct sctp_association *lasuc = query->lasuc;
    struct sctp_association *lasuc = query->lasuc;
    if (query->lasuc->src_out_of_asoc_ok)
    		goto sctp_flush_out;
    Buffer *buffer = &vs->tight.jpeg;
    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}",1,0,28,0.39,Insert
1377,"static void write_response(ESPState *s)
{
    uint8_t buf[2];
    trace_esp_write_response(s->status);
    buf[0] = s->status;
    buf[1] = 0;
    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}","static void write_response(ESPState *s)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        uint8_t buf[2];
    }
    trace_esp_write_response(s->status);
    buf[0] = s->status;
    buf[1] = 0;
    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque, buf, 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        fifo8_reset(&s->fifo);
        fifo8_push_all(&s->fifo, buf, 2);
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}",0,1,7,0.17,Replace
1379,,,,,,,
1380,"static void napi_skb_free_stolen_head(struct sk_buff *skb)
{
	skb_dst_drop(skb);
	secpath_reset(skb);
	kmem_cache_free(skbuff_head_cache, skb);","static void napi_skb_free_stolen_head(struct sk_buff *skb)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	skb_dst_drop(skb);
	}
	struct hfi1_user_sdma_comp_q *cq;
	u16 idx;
	struct hfi1_user_sdma_pkt_q *pq;
	int ret;
	enum hfi1_sdma_comp_state state;
	cq->comps[idx].status = state;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
						idx, state, ret);
	secpath_reset(skb);
	kmem_cache_free(skbuff_head_cache, skb);",0,1,10,0.25,Insert
1382,"void Vers_history_point::bad_expression_data_type_error(const char *type) const
{
  my_error(ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION, MYF(0),
           type, ""FOR SYSTEM_TIME"");
}","void Vers_history_point::bad_expression_data_type_error(const char *type) const
{
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  VdpChromaType type_5;
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                       &pack);
  status = surface_query_caps(hdtx->device, type_5, &supported,
                                  &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                       &pack);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  my_error(ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION, MYF(0),
           type, ""FOR SYSTEM_TIME"");
}",0,1,2,0.17,Insert
1383,,,,,,,
1386,"    inline const WCHAR *GetDirW(int index)
    {
	WCHAR *ptr = dirTableW[index];
	if (!ptr) {
	    ptr = szLocalBufferW;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };","    inline const WCHAR *GetDirW(int index)
    {
	WCHAR *ptr = dirTableW[index];
	if (!ptr) {
	    ptr = szLocalBufferW;
	    ptr[0] = 'A' + index;
	int a = 2;
	int b = 3;
	while (a < b) {
    	    ptr[1] = ':';
    	b = a;
    	Rocker *r;
    	DescInfo *info;
    	char *buf = desc_get_buf(info, true);
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	char *buf = desc_get_buf(info, true);
    	PCIDevice *dev = PCI_DEVICE(r);
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	uint32_t pport;
    	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	}
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };",0,1,15,0.55,Insert
1387,"static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->vmcb->control.next_rip != 0) {
		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
		svm->next_rip = svm->vmcb->control.next_rip;
	}
	if (!svm->next_rip) {
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);
	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}","static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	if (svm->vmcb->control.next_rip != 0) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
    		b += 1;
		}
		svm->next_rip = svm->vmcb->control.next_rip;
	}
	if (!svm->next_rip) {
		AVPacket * pk;
		AVFormatContext *s;
		int size               =  pk->size;
		AVIOContext *b_1     = s->b_1;
		if (size & 1)
		        avio_w8(b_1, 0);
		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
				EMULATE_DONE)
			printk(KERN_DEBUG ""%s: NOP\n"", __func__);
		return;
	}
	if (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)
		printk(KERN_ERR ""%s: ip 0x%lx next 0x%llx\n"",
		       __func__, kvm_rip_read(vcpu), svm->next_rip);
	kvm_rip_write(vcpu, svm->next_rip);
	svm_set_interrupt_shadow(vcpu, 0);
}",0,1,16,0.65,Insert
1389,"sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;
	pr_debug(""%s: timer T5 expired\n"", __func__);
	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);
	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;
	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));
	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);
	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}","sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;
	pr_debug(""%s: timer T5 expired\n"", __func__);
	int a = 2;
	int b = 2;
	if (a == b) {
    	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);
	}
	reply = sctp_make_abort(asoc, NULL, 0);
	WCHAR *length = dirTableW[start];
	WCHAR *length = dirTableW[start];
	if (!length) {
		    length = szLocalBufferW;
		    length[0] = 'A' + start;
		    length[1] = ':';
		    length[2] = '\\';
		    length[3] = 0;
	}
	if (!reply)
		goto nomem;
	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));
	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);
	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}",0,1,45,0.92,Insert
1391,,,,,,,
1394,"GF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;
	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->trackID = gf_bs_read_u32(bs);
	return gf_isom_box_array_read(s, bs);
}","GF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)
{
	int wb;
	uint32_t lvcall;
	CPUState *env;
	unsigned int valpages;
	uint32_t r_cause;
	int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t pid, lo, hi;
	int set, match = 0;
	r_cause = env->sregs[SFR_R_MM_CAUSE];
	D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
			  "" %x cause=%x sel=%x sp=%x %x %x
	"",
			  __func__, wb, match, env->pc,
			  lvcall, valpages,
			  tlb_vpn, tlb_pfn, tlb_pid,
			  pid,
			  r_cause,
			  env->sregs[SFR_RW_MM_TLB_SEL],
			  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	GF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;
	strcpy(str, ""a"");
	}
	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->trackID = gf_bs_read_u32(bs);
	return gf_isom_box_array_read(s, bs);
}",0,1,18,0.47,Insert
1395,"string to_string(const MaskedIP& m) {
  stringstream ss;
  ss << m;
  return ss.str();
}","string to_string(const MaskedIP& m) {
  stringstream ss;
  ss << m;
  DisasContext *qs;
  uint32_t ksns;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  err = extract32(ksns, 16, 5);
  handle_fp_compare(qs, order, coll, err, false, p);
  int a = 2;
  int b = 2;
  if (a == b) {
      return ss.str();
  }
}",0,1,10,0.26,Insert
1400,"axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	return (result);
}","axfr_rrstream_first(rrstream_t *rs) {
	axfr_rrstream_t *s = (axfr_rrstream_t *) rs;
	isc_result_t result;
	result = dns_rriterator_first(&s->it);
	if (result != ISC_R_SUCCESS)
		return (result);
	for (;;) {
		dns_name_t *name_dummy = NULL;
		uint32_t ttl_dummy;
		dns_rdata_t *rdata = NULL;
		dns_rriterator_current(&s->it, &name_dummy,
				       &ttl_dummy, NULL, &rdata);
		if (rdata->type != dns_rdatatype_soa)
			break;
		result = dns_rriterator_next(&s->it);
		if (result != ISC_R_SUCCESS)
			break;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return (result);
	strcpy(str, ""a"");
	}
}",0,1,2,0.1,Replace
1401,"static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
{
	char buf[MAXPATHLEN];
	struct stat sbuf;
	if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
		return FAILURE;
	}
	if (VCWD_STAT(buf, &sbuf)) {
		return FAILURE;
	}
	return SUCCESS;
}","static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)
{
	char buf[MAXPATHLEN];
	struct stat sbuf;
	if (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {
		return FAILURE;
	}
	if (VCWD_STAT(buf, &sbuf)) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return FAILURE;
		strcpy(str, ""a"");
		}
	}
	return SUCCESS;
}",0,1,5,0.08,Replace
1402,"void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}","void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    int a = 2;
    int b = 3;
    if (a != b) {
        return ast_context()->ReturnValue(value);
    }
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}",0,1,7,0.36,Insert
1403,"nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}
	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	can_rename = TRUE;
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;
		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));
		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}
	if (!can_rename) {
		return FALSE;
	}
	return file->details->can_rename;
}","nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}
	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	can_rename = TRUE;
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;
		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));
		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}
	if (!can_rename) {
		return FALSE;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return file->details->can_rename;
	strcpy(str, ""a"");
	}
}",0,1,3,0.17,Replace
1404,,,,,,,
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	ft->write_request(ft);
	}
	return FALSE;
}",0,1,7,0.11,Replace
1411,"void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;
	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;
	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}
	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);
	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}
	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;
 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);","void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	struct sk_buff *msg;
	void *hdr;
	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;
	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}
	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);
	if (genlmsg_end(msg, hdr) < 0) {
		int a = 2;
		int b = 3;
		while (a < b) {
    		nlmsg_free(msg);
    		b = a;
		}
		return;
	}
	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;
 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);",0,1,30,1.18,Insert
1412,"date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}","date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    AVFormatContext *avctx;
    struct dshow_ctx *ctx = avctx->priv_data;
    int r;
    if (r != S_OK) {
            av_log(avctx, AV_LOG_ERROR, ""Could not create capture graph.
    "");
            goto error;
    }
    VALUE str, sg;
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        rb_scan_args(argc, argv, ""02"", &str, &sg);
    }
    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}",1,0,14,0.51,Insert
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long lval;
	AUpvgetval(list, i, &lval);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long lval;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	AUpvgetval(list, i, &lval);
	strcpy(str, ""a"");
	}
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}",0,1,14,0.21,Replace
1416,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();
  Debug(this, ""reading starting"");
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;
  return 0;
}","int Http2Stream::ReadStart() {
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      struct edgeport_serial *serial;
      u8 *data;
      struct device *dev = &serial->serial->dev->dev;
      struct device *dev = &serial->serial->dev->dev;
      int status;
      data = kmalloc(1, GFP_KERNEL);
      status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
      				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
      status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
      				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
      Http2Scope h2scope(this);
  }
  CHECK(!this->is_destroyed());
  set_reading();
  Debug(this, ""reading starting"");
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;
  return 0;
}",0,1,18,0.32,Insert
1417,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    int a = 2;
    int b = 2;
    if (a == b) {
        RegexMatchExpression regex;
    }
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}",0,1,13,0.42,Insert
1418,"static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_qcc_t *qcc = &ms->parms.qcc;
	jpc_dec_tile_t *tile;
	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}","static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_qcc_t *qcc = &ms->parms.qcc;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	jpc_dec_tile_t *tile;
	strcpy(str, ""a"");
	}
	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in QCC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromqcc(dec->cp, qcc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		struct SYMBOL *s;
		s->u.nb.notes[0].color = -1;
		s->u.nb.microscale = microscale;
		jpc_dec_cp_setfromqcc(tile->cp, qcc);
		break;
	}
	return 0;
}",1,0,39,0.65,Insert
1420,"static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
{
    FILE *fp = fopen(dest_filename, ""w"");
    if (!fp)
        return false;
    unsigned fd = 0;
    while (fd <= 99999)
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);
        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }
    fclose(fp);
    return true;
}","static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        FILE *fp = fopen(dest_filename, ""w"");
        b = a;
    }
    if (!fp)
        return false;
    unsigned fd = 0;
    while (fd <= 99999)
    {
        sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
        char *name = malloc_readlink(source_filename);
        if (!name)
            break;
        fprintf(fp, ""%u:%s\n"", fd, name);
        free(name);
        sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
        fd++;
        FILE *in = fopen(source_filename, ""r"");
        if (!in)
            continue;
        char buf[128];
        while (fgets(buf, sizeof(buf)-1, in))
        {
            char *eol = strchrnul(buf, '\n');
            eol[0] = '\n';
            eol[1] = '\0';
            fputs(buf, fp);
        }
        fclose(in);
    }
    fclose(fp);
    return true;
}",1,0,1,0.17,Replace
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ID = reg_node->NodeID;
	strcpy(str, ""a"");
	}
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}",0,1,3,0.08,Replace
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	}
	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
			VdpDecoderProfile profile;
			AVCodecContext *AVcas;
			uint32_t input;
			VdpDecoderQueryCapabilities *decoder_query_caps;
			uint32_t max_level, max_mb, max_width, max_height;
			VdpDecoderCreate *create;
			uint32_t max_level, max_mb, max_width, max_height;
			VdpStatus status;
			VDPAUHWContext *hwctx = AVcas->hwaccel_context;
			VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
			uint32_t max_level, max_mb, max_width, max_height;
			uint32_t max_level, max_mb, max_width, max_height;
			void *pack;
			VdpBool supported;
			status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
			                                &max_mb, &max_width, &max_height);
			status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
			                                     &pack);
			status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
			                                     &pack);
			status = create(hdtx->device, profile, width, input, AVcas->refs,
			                    &hdtx->decoder);
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}",0,1,22,0.58,Insert
1426,"drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)
{
    SCREEN *sp;
    AssertTCB();
    SetSP();
    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *tp = InfoOf(sp).defaultPalette;
	TR(TRACE_ATTRS,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));
	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}","drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)
{
    SCREEN *sp;
    AssertTCB();
    SetSP();
    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	const color_t *tp = InfoOf(sp).defaultPalette;
	}
	TR(TRACE_ATTRS,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));
	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}",1,0,1,0.1,Replace
1428,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;
    code = (njs_vmcode_array_t *) pc;
    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);
    if (njs_fast_path(array != NULL)) {
        if (code->ctor) {
            value = array->start;
            length = array->length;
            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);
        } else {
            array->length = 0;
        }
        njs_set_array(&vm->retval, array);
        return sizeof(njs_vmcode_array_t);
    }
    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    int a = 2;
    int b = 2;
    if (a == b) {
        njs_array_t         *array;
    }
    njs_value_t         *value;
    njs_vmcode_array_t  *code;
    code = (njs_vmcode_array_t *) pc;
    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);
    if (njs_fast_path(array != NULL)) {
        if (code->ctor) {
            value = array->start;
            length = array->length;
            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);
        } else {
            array->length = 0;
        }
        njs_set_array(&vm->retval, array);
        return sizeof(njs_vmcode_array_t);
    }
    return NJS_ERROR;
}",1,0,4,0.14,Replace
1429,"rsvg_state_finalize (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->lang);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);
    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);
    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}","rsvg_state_finalize (RsvgState * state)
{
    g_free (state->font_family);
    int a = 2;
    int b = 2;
    while (a == b) {
        g_free (state->lang);
        b += 1;
    }
    rsvg_paint_server_unref (state->fill);
    struct nfs_client *parent_client;
    int event;
    struct nfs_fattr fattr;
    struct nfs_server *public, *parent_server;
    struct nfs_server *public, *parent_server;
    event = nfs4_set_client(public, ad->hostname, ad->addr,
    			parent_client->cl_ipaddr,
    			ad->authflavor,
    			parent_server->client->cl_xprt->prot,
    			parent_client->retrans_timeo,
    			parent_client->retrans_count);
    event = nfs_init_server_rpcclient(public, ad->authflavor);
    event = nfs4_path_walk(public, mntfh, ad->mnt_path);
    event = nfs_probe_fsinfo(public, mntfh, &fattr);
    dprintk(""<-- nfs4_create_referral_server() = error %d
    "", event);
    rsvg_paint_server_unref (state->stroke);
    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);
    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}",1,0,24,0.54,Insert
1432,"void Logger::addMessage(const QString &message, const Log::MsgType &type)
{
    QWriteLocker locker(&lock);
    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };
    m_messages.push_back(temp);
    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();
    emit newLogMessage(temp);
}","void Logger::addMessage(const QString &message, const Log::MsgType &type)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        QWriteLocker locker(&lock);
        b += 1;
    }
    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };
    m_messages.push_back(temp);
    if (m_messages.size() >= MAX_LOG_MESSAGES)
        m_messages.pop_front();
    emit newLogMessage(temp);
}",1,0,2,0.06,Replace
1433,"void user_describe(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}","void user_describe(const struct key *key, struct seq_file *m)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	seq_puts(m, key->description);
	strcpy(str, ""a"");
	encode_options_t params;
	FLAC__ASSERT(sizeof(params.pictures)/sizeof(params.pictures[0]) <= 64);
	}
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}",1,0,7,0.33,Insert
1434,,,,,,,
1435,"ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  char *new_str;
  glong actual_length;
  gulong bytes;
  g_assert (target_length > 0);
  if (!str)
    return NULL;
  actual_length = g_utf8_strlen (str, -1);
  if ((gsize)actual_length <= target_length)
    return str;
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);
  new_str = g_new (gchar, bytes + 1 + 1);
  strncpy (new_str, str, bytes);
  strcat (new_str, """");
  g_free (str);
  return new_str;
}","ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  char *new_str;
  glong actual_length;
  gulong bytes;
  g_assert (target_length > 0);
  if (!str)
    return NULL;
    OcspResponse* resp;
    byte* source;
    word32 size;
    int    ret;
    int    sigLength;
    ret = CheckBitString(source, &idx, &sigLength, size, 1, NULL);
    resp->sigSz = sigLength;
    idx += sigLength;
  actual_length = g_utf8_strlen (str, -1);
  if ((gsize)actual_length <= target_length)
    return str;
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);
  new_str = g_new (gchar, bytes + 1 + 1);
  strncpy (new_str, str, bytes);
  strcat (new_str, """");
  g_free (str);
  return new_str;
}",1,0,29,0.62,Insert
1436,"rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }
  if (BUG(!rend_service_list)) {
    return NULL;
  }
  return rend_service_list;
}","rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return substitute_service_list;
    }
  }
  if (BUG(!rend_service_list)) {
    const struct sun4d_hwdef *hawdecl;
    int ret;
    ram_addr_t gram_size, prom_reset, tcx64off;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *esp__set, *les_init;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *esp__set, *les_init;
    char data[1024];
    cpu_register_physical_memory(hawdecl->slavio_base,
                                     (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
                                     TARGET_PAGE_MASK,
                                     prom_reset | IO_MEM_ROM);
    ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
    sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
    espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
                                  ioulits[0], &espdma_iraque, &esp__set);
    ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
                                 ioulits[0], &ledma_arquest, &les_init);
    return NULL;
  }
  return rend_service_list;
}",0,1,10,0.23,Insert
1439,"static JSValue js_bs_put_s16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
	return js_bs_put_val(ctx, this_val, argc, argv, 4);
}","static JSValue js_bs_put_s16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
	int a = 2;
	int b = 3;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	while (a < b) {
    	return js_bs_put_val(ctx, this_val, argc, argv, 4);
    	b = a;
	}
}",0,1,12,0.33,Insert
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}
	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	NTSTATUS status;
	}
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}
	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf_6;
	emulated_edge_mc(buf_6, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}",0,1,30,0.78,Insert
1442,"static int h2_task_pre_conn(conn_rec* c, void *arg)
{
    h2_ctx *ctx;
    if (!c->master) {
        return OK;
    }
    ctx = h2_ctx_get(c, 0);
    (void)arg;
    if (ctx->task) {
        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,
                      ""h2_h2, pre_connection, found stream task"");
        ap_add_input_filter(""H2_SLAVE_IN"", NULL, NULL, c);
        ap_add_output_filter(""H2_PARSE_H1"", NULL, NULL, c);
        ap_add_output_filter(""H2_SLAVE_OUT"", NULL, NULL, c);
    }
    return OK;
}","static int h2_task_pre_conn(conn_rec* c, void *arg)
{
    h2_ctx *ctx;
    if (!c->master) {
        return OK;
    }
    Parse *pParse;
    int in2;
    int opcode;
    int in1;
    int dest;
    CollSeq *p4;
    int addr;
    int p5;
    addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                               (void*)p4, P4_COLLSEQ);
    sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
    ctx = h2_ctx_get(c, 0);
    (void)arg;
    if (ctx->task) {
        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,
                      ""h2_h2, pre_connection, found stream task"");
        ap_add_input_filter(""H2_SLAVE_IN"", NULL, NULL, c);
        ap_add_output_filter(""H2_PARSE_H1"", NULL, NULL, c);
        int a = 2;
        int b = 3;
        while (a != b) {
            ap_add_output_filter(""H2_SLAVE_OUT"", NULL, NULL, c);
            b = a;
        }
    }
    SSL *s;
    int i, al, like;
    long n;
    n = s->method->ssl_get_message(s,
                                       SSL3_ST_SR_KEY_EXCH_A,
                                       SSL3_ST_SR_KEY_EXCH_B,
                                       SSL3_MT_CLIENT_KEY_EXCHANGE, 2048, &like);
    return OK;
}",1,0,51,0.69,Insert
1444,"static void cirrus_linear_bitblt_writew(void *opaque, target_phys_addr_t addr,
				 uint32_t val)
{
#ifdef TARGET_WORDS_BIGENDIAN
    cirrus_linear_bitblt_writeb(opaque, addr, (val >> 8) & 0xff);
    cirrus_linear_bitblt_writeb(opaque, addr + 1, val & 0xff);
#else
    cirrus_linear_bitblt_writeb(opaque, addr, val & 0xff);
    cirrus_linear_bitblt_writeb(opaque, addr + 1, (val >> 8) & 0xff);
#endif
}","static void cirrus_linear_bitblt_writew(void *opaque, target_phys_addr_t addr,
				 uint32_t val)
{
#ifdef TARGET_WORDS_BIGENDIAN
    cirrus_linear_bitblt_writeb(opaque, addr, (val / (2**8)) & 0xff);
    cirrus_linear_bitblt_writeb(opaque, addr + 1, val & 0xff);
#else
struct tty_struct *reader;
struct awm *awm = reader->driver_data;
struct acm_wb *sth;
struct awm *awm = reader->driver_data;
if (sth->len == awm->writesize) {
		acm_tty_flush_chars(reader);
		goto overflow;
}
    cirrus_linear_bitblt_writeb(opaque, addr, val & 0xff);
    cirrus_linear_bitblt_writeb(opaque, addr + 1, (val >> 8) & 0xff);
#endif
}",0,1,18,0.47,Insert
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    int a = 27;
    int b = a;
    if(a*b>0){
        MemoryRegionSection *section;
    }
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    AVCodec *c;
    int encoder;
    const char *codec_string = encoder ? ""encoder"" : ""decoder"";
    const char *codec_string = encoder ? ""encoder"" : ""decoder"";
    AVCodec *codec;
    av_log(NULL, AV_LOG_FATAL, ""%s '%s' is experimental and might produce bad ""
                ""results.
    Add '-strict experimental' if you want to use it.
    "",
                codec_string, c->name);
    codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);
    return section;
}",1,0,22,0.82,Insert
1446,,,,,,,
1447,"static int newque(struct ipc_namespace *ns, struct ipc_params *params)
{
	struct msg_queue *msq;
	int id, retval;
	key_t key = params->key;
	int msgflg = params->flg;
	msq = ipc_rcu_alloc(sizeof(*msq));
	if (!msq)
		return -ENOMEM;
	msq->q_perm.mode = msgflg & S_IRWXUGO;
	msq->q_perm.key = key;
	msq->q_perm.security = NULL;
	retval = security_msg_queue_alloc(msq);
	if (retval) {
		ipc_rcu_putref(msq, ipc_rcu_free);
		return retval;
	}
	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
	if (id < 0) {
		ipc_rcu_putref(msq, msg_rcu_free);
		return id;
	}
	msq->q_stime = msq->q_rtime = 0;
	msq->q_ctime = get_seconds();
	msq->q_cbytes = msq->q_qnum = 0;
	msq->q_qbytes = ns->msg_ctlmnb;
	msq->q_lspid = msq->q_lrpid = 0;
	INIT_LIST_HEAD(&msq->q_messages);
	INIT_LIST_HEAD(&msq->q_receivers);
	INIT_LIST_HEAD(&msq->q_senders);
	ipc_unlock_object(&msq->q_perm);
	rcu_read_unlock();
	return msq->q_perm.id;
}","static int newque(struct ipc_namespace *ns, struct ipc_params *params)
{
	struct msg_queue *msq;
	int id, retval;
	key_t key = params->key;
	int msgflg = params->flg;
	msq = ipc_rcu_alloc(sizeof(*msq));
	if (!msq)
		return -ENOMEM;
	msq->q_perm.mode = msgflg & S_IRWXUGO;
	msq->q_perm.key = key;
	msq->q_perm.security = NULL;
	retval = security_msg_queue_alloc(msq);
	if (retval) {
		ipc_rcu_putref(msq, ipc_rcu_free);
		return retval;
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
	}
	if (id < 0) {
		ipc_rcu_putref(msq, msg_rcu_free);
		return id;
	}
	msq->q_stime = msq->q_rtime = 0;
	msq->q_ctime = get_seconds();
	msq->q_cbytes = msq->q_qnum = 0;
	msq->q_qbytes = ns->msg_ctlmnb;
	msq->q_lspid = msq->q_lrpid = 0;
	INIT_LIST_HEAD(&msq->q_messages);
	INIT_LIST_HEAD(&msq->q_receivers);
	INIT_LIST_HEAD(&msq->q_senders);
	H264Context *h;
	int i, j;
	for (i = 0; i < h->nb_slice_ctx; i++)
	        h->slice_ctx[i].list_count = 0;
	ipc_unlock_object(&msq->q_perm);
	rcu_read_unlock();
	return msq->q_perm.id;
}",1,0,48,1.01,Insert
1448,"static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	f2fs_mark_inode_dirty_sync(inode, true);
}","static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type_6;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type_6, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	f2fs_mark_inode_dirty_sync(inode, true);
}",0,1,5,0.21,Insert
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!file)
		return -ENODEV;
	int a = 86;
	int b = a;
	if(a*b>0){
    	cam = video_drvdata(file);
	}
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",0,1,2,0.09,Replace
1451,"plperl_spi_query(char *query)
{
	SV		   *cursor;
	MemoryContext oldcontext = CurrentMemoryContext;
	ResourceOwner oldowner = CurrentResourceOwner;
	check_spi_usage_allowed();
	BeginInternalSubTransaction(NULL);
	MemoryContextSwitchTo(oldcontext);
	PG_TRY();
	{
		SPIPlanPtr	plan;
		Portal		portal;
		pg_verifymbstr(query, strlen(query), false);
		plan = SPI_prepare(query, 0, NULL);
		if (plan == NULL)
			elog(ERROR, ""SPI_prepare() failed:%s"",
				 SPI_result_code_string(SPI_result));
		portal = SPI_cursor_open(NULL, plan, NULL, NULL, false);
		SPI_freeplan(plan);
		if (portal == NULL)
			elog(ERROR, ""SPI_cursor_open() failed:%s"",
				 SPI_result_code_string(SPI_result));
		cursor = cstr2sv(portal->name);
		ReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
	}
	PG_CATCH();
	{
		ErrorData  *edata;
		MemoryContextSwitchTo(oldcontext);
		edata = CopyErrorData();
		FlushErrorState();
		RollbackAndReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
		croak(""%s"", edata->message);
		return NULL;
	}
	PG_END_TRY();
	return cursor;
}","plperl_spi_query(char *query)
{
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    	SV		   *cursor;
			strcpy(str, ""a"");
			}
	MemoryContext oldcontext = CurrentMemoryContext;
	ResourceOwner oldowner = CurrentResourceOwner;
	check_spi_usage_allowed();
	BeginInternalSubTransaction(NULL);
	MemoryContextSwitchTo(oldcontext);
	PG_TRY();
	{
		SPIPlanPtr	plan;
		Portal		portal;
		pg_verifymbstr(query, strlen(query), false);
		plan = SPI_prepare(query, 0, NULL);
		if (plan == NULL)
			elog(ERROR, ""SPI_prepare() failed:%s"",
				 SPI_result_code_string(SPI_result));
		portal = SPI_cursor_open(NULL, plan, NULL, NULL, false);
		SPI_freeplan(plan);
		if (portal == NULL)
			elog(ERROR, ""SPI_cursor_open() failed:%s"",
				 SPI_result_code_string(SPI_result));
		cursor = cstr2sv(portal->name);
		ReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
	}
	PG_CATCH();
	{
		ErrorData  *edata;
		MemoryContextSwitchTo(oldcontext);
		edata = CopyErrorData();
		FlushErrorState();
		RollbackAndReleaseCurrentSubTransaction();
		MemoryContextSwitchTo(oldcontext);
		CurrentResourceOwner = oldowner;
		SPI_restore_connection();
		croak(""%s"", edata->message);
		return NULL;
	}
	PG_END_TRY();
	return cursor;
}",0,1,41,0.47,Replace
1453,"void ConnectionImpl::onHeaderValue(const char* data, size_t length) {
  if (header_parsing_state_ == HeaderParsingState::Done && !enable_trailers_) {
    return;
  }
  if (processing_trailers_) {
    maybeAllocTrailers();
  }
  absl::string_view header_value{data, length};
  if (strict_header_validation_) {
    if (!Http::HeaderUtility::headerValueIsValid(header_value)) {
      ENVOY_CONN_LOG(debug, ""invalid header value: {}"", connection_, header_value);
      error_code_ = Http::Code::BadRequest;
      sendProtocolError(Http1ResponseCodeDetails::get().InvalidCharacters);
      throw CodecProtocolException(""http/1.1 protocol error: header value contains invalid chars"");
    }
  }
  header_parsing_state_ = HeaderParsingState::Value;
  if (current_header_value_.empty()) {
    header_value = StringUtil::ltrim(header_value);
  }
  current_header_value_.append(header_value.data(), header_value.length());
  const uint32_t total =
      current_header_field_.size() + current_header_value_.size() + headersOrTrailers().byteSize();
  if (total > (max_headers_kb_ * 1024)) {
    const absl::string_view header_type =
        processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;
    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;
    sendProtocolError(Http1ResponseCodeDetails::get().HeadersTooLarge);
    throw CodecProtocolException(absl::StrCat(header_type, "" size exceeds limit""));
  }
}","void ConnectionImpl::onHeaderValue(const char* data, size_t length) {
  WebKitWebView* webView_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  Settings* settings_4 = core_3(webView_6)->settings_4();
  WebKitWebSettings* webSettings_3 = priv_8->webSettings_3.get();
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gchar* defaultEncoding_3, *cursiveFontFamily_9, *defaultFontFamily_4, *fantasyFontFamily_2, *monospaceFontFamily_9, *sansSerifFontFamily_7, *serifFontFamily_8, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gchar* defaultEncoding_3, *cursiveFontFamily_9, *defaultFontFamily_4, *fantasyFontFamily_2, *monospaceFontFamily_9, *sansSerifFontFamily_7, *serifFontFamily_8, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gchar* defaultEncoding_3, *cursiveFontFamily_9, *defaultFontFamily_4, *fantasyFontFamily_2, *monospaceFontFamily_9, *sansSerifFontFamily_7, *serifFontFamily_8, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gchar* defaultEncoding_3, *cursiveFontFamily_9, *defaultFontFamily_4, *fantasyFontFamily_2, *monospaceFontFamily_9, *sansSerifFontFamily_7, *serifFontFamily_8, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
  gchar* defaultEncoding_3, *cursiveFontFamily_9, *defaultFontFamily_4, *fantasyFontFamily_2, *monospaceFontFamily_9, *sansSerifFontFamily_7, *serifFontFamily_8, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gchar* defaultEncoding_3, *cursiveFontFamily_9, *defaultFontFamily_4, *fantasyFontFamily_2, *monospaceFontFamily_9, *sansSerifFontFamily_7, *serifFontFamily_8, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
  WebKitEditingBehavior editingBehavior_7;
  gchar* defaultEncoding_3, *cursiveFontFamily_9, *defaultFontFamily_4, *fantasyFontFamily_2, *monospaceFontFamily_9, *sansSerifFontFamily_7, *serifFontFamily_8, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
  gchar* defaultEncoding_3, *cursiveFontFamily_9, *defaultFontFamily_4, *fantasyFontFamily_2, *monospaceFontFamily_9, *sansSerifFontFamily_7, *serifFontFamily_8, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gchar* defaultEncoding_3, *cursiveFontFamily_9, *defaultFontFamily_4, *fantasyFontFamily_2, *monospaceFontFamily_9, *sansSerifFontFamily_7, *serifFontFamily_8, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  gboolean autoLoadImages_2, autoShrinkImages_4, printBackgrounds_8,
          enableScripts_1, enablePlugins_3, enableDeveloperExtras_9, resizableTextAreas_9,
          enablePrivateBrowsing_6, enableCaretBrowsing_2, enableHTML5Database_10, enableHTML5LocalStorage_9,
          enableXSSAuditor_10, enableSpatialNavigation_9, enableFrameFlattening_7, javascriptCanOpenWindows_3,
          javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
           enableUniversalAccessFromFileURI_4, enableFileAccessFromFileURI_5,
           enableDOMPaste_5, tabKeyCyclesThroughElements_9, enableWebGL_10,
           enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_6,
          enableHyperlinkAuditing_9, enableFullscreen_1, enableDNSPrefetching_6;
  g_object_get_2(webSettings_3,
                   ""default-encoding"", &defaultEncoding_3,
                   ""cursive-font-family"", &cursiveFontFamily_9,
                   ""default-font-family"", &defaultFontFamily_4,
                   ""fantasy-font-family"", &fantasyFontFamily_2,
                   ""monospace-font-family"", &monospaceFontFamily_9,
                   ""sans-serif-font-family"", &sansSerifFontFamily_7,
                   ""serif-font-family"", &serifFontFamily_8,
                   ""auto-load-images"", &autoLoadImages_2,
                   ""auto-shrink-images"", &autoShrinkImages_4,
                   ""print-backgrounds"", &printBackgrounds_8,
                   ""enable-scripts"", &enableScripts_1,
                   ""enable-plugins"", &enablePlugins_3,
                   ""resizable-text-areas"", &resizableTextAreas_9,
                   ""user-stylesheet-uri"", &userStylesheetUri_8,
                   ""enable-developer-extras"", &enableDeveloperExtras_9,
                   ""enable-private-browsing"", &enablePrivateBrowsing_6,
                   ""enable-caret-browsing"", &enableCaretBrowsing_2,
                   ""enable-html5-database"", &enableHTML5Database_10,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage_9,
                   ""enable-xss-auditor"", &enableXSSAuditor_10,
                   ""enable-spatial-navigation"", &enableSpatialNavigation_9,
                   ""enable-frame-flattening"", &enableFrameFlattening_7,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_3,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_5,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_3,
                   ""editing-behavior"", &editingBehavior_7,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_4,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_5,
                   ""enable-dom-paste"", &enableDOMPaste_5,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_9,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_9,
                    ""enable-page-cache"", &usePageCache_9,
                    ""enable-java-applet"", &enableJavaApplet_6,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_9,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages_1,
                    ""enable-fullscreen"", &enableFullscreen_1,
                    ""enable-dns-prefetching"", &enableDNSPrefetching_6,
                   ""enable-webgl"", &enableWebGL_10,
                   NULL);
  settings_4->setXSSAuditorEnabled(enableXSSAuditor_10);
  if (header_parsing_state_ == HeaderParsingState::Done && !enable_trailers_) {
    return;
  }
  WebKitWebView* webView;
  ICreateDevEnum *devenum = NULL;
  int r;
  r = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                           &IID_ICreateDevEnum, (void **) &devenum);
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  Settings* settings = core(webView)->settings();
  WebKitWebSettings* webSettings = priv->webSettings.get();
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  WebKitEditingBehavior editingBehavior;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  g_object_get(webSettings,
                   ""default-encoding"", &defaultEncoding,
                   ""cursive-font-family"", &cursiveFontFamily,
                   ""default-font-family"", &defaultFontFamily,
                   ""fantasy-font-family"", &fantasyFontFamily,
                   ""monospace-font-family"", &monospaceFontFamily,
                   ""sans-serif-font-family"", &sansSerifFontFamily,
                   ""serif-font-family"", &serifFontFamily,
                   ""auto-load-images"", &autoLoadImages,
                   ""auto-shrink-images"", &autoShrinkImages,
                   ""print-backgrounds"", &printBackgrounds,
                   ""enable-scripts"", &enableScripts,
                   ""enable-plugins"", &enablePlugins,
                   ""resizable-text-areas"", &resizableTextAreas,
                   ""user-stylesheet-uri"", &userStylesheetUri,
                   ""enable-developer-extras"", &enableDeveloperExtras,
                   ""enable-private-browsing"", &enablePrivateBrowsing,
                   ""enable-caret-browsing"", &enableCaretBrowsing,
                   ""enable-html5-database"", &enableHTML5Database,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                   ""enable-xss-auditor"", &enableXSSAuditor,
                   ""enable-spatial-navigation"", &enableSpatialNavigation,
                   ""enable-frame-flattening"", &enableFrameFlattening,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                   ""editing-behavior"", &editingBehavior,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                   ""enable-dom-paste"", &enableDOMPaste,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                    ""enable-page-cache"", &usePageCache,
                    ""enable-java-applet"", &enableJavaApplet,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                    ""enable-fullscreen"", &enableFullscreen,
                    ""enable-dns-prefetching"", &enableDNSPrefetching,
                   ""enable-webgl"", &enableWebGL,
                   NULL);
  settings->setXSSAuditorEnabled(enableXSSAuditor);
  if (processing_trailers_) {
    maybeAllocTrailers();
  }
  absl::string_view header_value{data, length};
  if (strict_header_validation_) {
    if (!Http::HeaderUtility::headerValueIsValid(header_value)) {
      ENVOY_CONN_LOG(debug, ""invalid header value: {}"", connection_, header_value);
      error_code_ = Http::Code::BadRequest;
      sendProtocolError(Http1ResponseCodeDetails::get().InvalidCharacters);
      throw CodecProtocolException(""http/1.1 protocol error: header value contains invalid chars"");
    }
  }
  header_parsing_state_ = HeaderParsingState::Value;
  if (current_header_value_.empty()) {
    header_value = StringUtil::ltrim(header_value);
  }
  int a = 44;
  int b = a;
  if(a*b>0){
      current_header_value_.append(header_value.data(), header_value.length());
  }
  const uint32_t total =
      current_header_field_.size() + current_header_value_.size() + headersOrTrailers().byteSize();
  if (total > (max_headers_kb_ * 1024)) {
    const absl::string_view header_type =
        processing_trailers_ ? Http1HeaderTypes::get().Trailers : Http1HeaderTypes::get().Headers;
    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;
    sendProtocolError(Http1ResponseCodeDetails::get().HeadersTooLarge);
    throw CodecProtocolException(absl::StrCat(header_type, "" size exceeds limit""));
    ViewMsg_Print_Params* changes;
    WebNode* remote;
    WebFrame* model;
    double margin_left_in_points;
    PrepareFrameAndViewForPrint prepare(*changes, model, remote, model->version());
    double margin_top_inclusiveobjects;
    changes->margin_top = static_cast<int>(ConvertUnitDouble(
           margin_top_inclusiveobjects, printing::kPointsPerInch, dpi));
    changes->margin_left = static_cast<int>(ConvertUnitDouble(
          margin_left_in_points, printing::kPointsPerInch, dpi));
  }
}",1,0,324,2.74,Insert
1456,,,,,,,
1457,,,,,,,
1458,,,,,,,
1459,"localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    return tmp;
}","localtime_r(const time_t *t, struct tm *tm)
{
    CPUState *viron;
    qemu_irq *irq;
    QEMUBH *rb;
    rb = qemu_bh_new(tick_irq, viron);
    rb = qemu_bh_new(stick_irq, viron);
    rb = qemu_bh_new(hstick_irq, viron);
    irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        auto struct tm *tmp = localtime(t);
    strcpy(str, ""a"");
    }
    if (tmp)
	*tm = *tmp;
    return tmp;
}",0,1,12,0.39,Insert
1462,"static void kvm_machine_check(void)
{
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3,
		.flags = X86_EFLAGS_IF,
	};
	do_machine_check(&regs, 0);
#endif
}","static void kvm_machine_check(void)
{
QuantizationTable
    *table;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
const char
    *attribute,
    *content;
XMLTreeInfo
    *description,
    *levels,
    *quantization_tables,
    *table_iterator;
levels=GetXMLTreeChild(table_iterator,""levels"");
table->levels=(unsigned int *) NULL;
attribute=GetXMLTreeAttribute(levels,""width"");
attribute=GetXMLTreeAttribute(levels,""height"");
attribute=GetXMLTreeAttribute(levels,""divisor"");
#if defined(CONFIG_X86_MCE)
	struct pt_regs regs = {
		.cs = 3,
		.flags = X86_EFLAGS_IF,
	};
	do_machine_check(&regs, 0);
#endif
}",0,1,4,0.16,Insert
1464,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	struct net_device *bond_dev;
	struct bonding *Bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	if (usable) {
			RCU_INIT_POINTER(Bond->usable_slaves, NULL);
			kfree_rcu(usable, rcu);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return NT_STATUS_OK;
	strcpy(str, ""a"");
	}
}",0,1,6,0.34,Insert
1466,,,,,,,
1467,"int setup_tests(void)
{
    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));
    return 1;
}","int setup_tests(void)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));
        b = a;
    }
    DisasContext *ctx;
    TCGv temp;
    uint32_t address;
    address = MASK_OP_ABS_OFF18(ctx->opcode);
    temp = tcg_const_i32(EA_ABS_FORMAT(address));
    return 1;
}",1,0,28,0.32,Insert
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";
    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";
    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        int a = 2;
        int b = 3;
        if (a != b) {
            pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        }
        pval->persistent = false;
    }
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    pval->size = strlen((const char *)pval->data);
}",0,1,23,0.46,Insert
1469,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
		const AVFrame *capt;
		const AVFrame *const p = capt;
		uint8_t *last = NULL;
		uint8_t *zero = NULL;
		zero = last = av_mallocz(p->linesize[0]);
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return 0;
	}
}",0,1,20,0.73,Insert
1470,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break;
  default:
    DBUG_ASSERT(0);
  }
  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude ""));
     switch (exclusion) {
     case EXCL_CURRENT_ROW:
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP:
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES:
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default:
       DBUG_ASSERT(0);
       ;
     }
  }
}","Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break;
  default:
    DBUG_ASSERT(0);
    AVCodecContext *AVcas;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
  }
  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude ""));
     switch (exclusion) {
     case EXCL_CURRENT_ROW:
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP:
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES:
       str->append(STRING_WITH_LEN("" ties ""));
       int a = 2;
       int b = 2;
       if (a == b) {
           break;
       }
     default:
       DBUG_ASSERT(0);
       ;
     }
  }
}",0,1,33,0.86,Insert
1475,,,,,,,
1476,"static int ntop_has_geoip(lua_State* vm) {
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);
  return(CONST_LUA_OK);
}","static int ntop_has_geoip(lua_State* vm) {
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  aml_append(coll,
          aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
  aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                  aml_name(""CTRL"")));
  ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      return(CONST_LUA_OK);
  }
}",0,1,8,0.26,Insert
1477,,,,,,,
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    int a = 2;
    int b = 3;
    while (a != b) {
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        _rsvg_node_free (self);
        b = a;
    }
}",0,1,11,0.29,Insert
1481,"process_secondary_order(STREAM s)
{
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;
	in_uint16_le(s, length);
	in_uint16_le(s, flags);
	in_uint8(s, type);
	next_order = s->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;
		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;
		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;
		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	s->p = next_order;
}","process_secondary_order(STREAM s)
{
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;
	int a = 2;
	int b = 2;
	if (a == b) {
    	in_uint16_le(s, length);
	}
	in_uint16_le(s, flags);
	in_uint8(s, type);
	next_order = s->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;
		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			AVCodecContext *avctx;
			Vp3DecodeContext *s_5 = avctx->priv_data;
			Vp3DecodeContext *s_5 = avctx->priv_data;
			if (s_5->golden_frame.data[0])
			        ff_thread_release_buffer(avctx, &s_5->golden_frame);
			break;
		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;
		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	s->p = next_order;
}",1,0,36,1.22,Insert
1484,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data[0]);
}","static void rxrpc_destroy(struct key *key)
{
	const u8 *key_1;
	struct crypto_shash *tfm;
	struct ghash_ctx *ctx = crypto_shash_ctx(tfm);
	ctx->gf128 = gf128mul_init_4k_lle((be128 *)key_1);
	rxrpc_free_token_list(key->payload.data[0]);
}",0,1,3,0.14,Insert
1487,"static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;
	if (!conn)
		return;
	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);
	sco_conn_lock(conn);
	sk = conn->sk;
	sco_conn_unlock(conn);
	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}
	hcon->sco_data = NULL;
	kfree(conn);
}","static void sco_conn_del(struct hci_conn *hcon, int err)
{
	struct sco_conn *conn = hcon->sco_data;
	struct sock *sk;
	if (!conn)
		return;
	BT_DBG(""hcon %p conn %p, err %d"", hcon, conn, err);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	sco_conn_lock(conn);
	}
	sk = conn->sk;
	sco_conn_unlock(conn);
	if (sk) {
		sock_hold(sk);
		bh_lock_sock(sk);
		sco_sock_clear_timer(sk);
		sco_chan_del(sk, err);
		bh_unlock_sock(sk);
		sco_sock_kill(sk);
		sock_put(sk);
	}
	hcon->sco_data = NULL;
	kfree(conn);
}",0,1,2,0.13,Replace
1490,"void Field_iterator_table_ref::set(TABLE_LIST *table)
{
  DBUG_ASSERT(table);
  first_leaf= table->first_leaf_for_name_resolution();
  last_leaf=  table->last_leaf_for_name_resolution();
  DBUG_ASSERT(first_leaf && last_leaf);
  table_ref= first_leaf;
  set_field_iterator();
}","void Field_iterator_table_ref::set(TABLE_LIST *table)
{
  DBUG_ASSERT(table);
  first_leaf= table->first_leaf_for_name_resolution();
  last_leaf=  table->last_leaf_for_name_resolution();
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table_7;
  size_t
      length;
  content=GetXMLTreeContent(levels);
  table_7->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table_7->levels));
  DBUG_ASSERT(first_leaf && last_leaf);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      table_ref= first_leaf;
  }
  set_field_iterator();
}",0,1,13,0.36,Insert
1491,"rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    i->next = i->screen->clientHead;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }
#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif
    return i->next;
}","rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    int a = 2;
    int b = 2;
    if (a == b) {
        i->next = i->screen->clientHead;
    }
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    struct sock *sk;
    struct cp *cp = sock_net(sk);
    struct sctp_sock *serv;
    serv->rtoinfo.srto_min     = cp->sctp.rto_min;
    serv->assocparams.sasoc_asocmaxrxt = cp->sctp.max_retrans_association;
    serv->assocparams.sasoc_number_peer_destinations = 0;
    serv->assocparams.sasoc_peer_rwnd = 0;
    serv->assocparams.sasoc_local_rwnd = 0;
    rfbDecrClientRef(cl);
  }
#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif
    return i->next;
}",1,0,37,0.81,Insert
1492,"includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}","includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	int a = 2;
	int b = 2;
	while (a == b) {
    	char includeThis[MAXSTRING];
    	struct inode *inode = dentry->d_inode;
    	error = PROC_I(inode)->op.proc_get_link(inode, &vd->path);
    	b += 1;
	}
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}",1,0,28,1.06,Insert
1495,"static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);
  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;
  switch (enc) {
  case UNICODE_ISO_8859_1:
    if (c == 0x85) return 1;
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;
  case KOI8_R:
    if (c == 0x9a) return 1;
    break;
  default:
    exit(-1);
  }
  return 0;
}","static int IsSpace(int enc, int c)
{
  if (enc == ASCII)
    return isspace(c);
  if (c >= 0x09 && c <= 0x0d) return 1;
  if (c == 0x20) return 1;
  switch (enc) {
  case UNICODE_ISO_8859_1:
    const v8::PropertyCallbackInfo<v8::Value>& py;
    from(py.Holder()->CreationContext());
    v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
    bool bool_var = (c == 0x85);
    if (bool_var) return 1;
  case ISO_8859_1:
  case ISO_8859_2:
  case ISO_8859_3:
  case ISO_8859_4:
  case ISO_8859_5:
  case ISO_8859_6:
  case ISO_8859_7:
  case ISO_8859_8:
  case ISO_8859_9:
  case ISO_8859_10:
  case ISO_8859_11:
  case ISO_8859_13:
  case ISO_8859_14:
  case ISO_8859_15:
  case ISO_8859_16:
  case KOI8:
    if (c == 0xa0) return 1;
    break;
  case KOI8_R:
    if (c == 0x9a) return 1;
    break;
  default:
    exit(-1);
  }
  return 0;
}",0,1,7,0.63,Insert
1496,,,,,,,
1498,"megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)
{
	return readl(&instance->reg_set->outbound_msg_0);
}","megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return readl(&instance->reg_set->outbound_msg_0);
    	b = a;
	}
}",0,1,3,0.21,Insert
1499,"int HttpFile::save() const
{
    return implPtr_->save();
}","int HttpFile::save() const
{
    char str1[] = ""Constant"";
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return implPtr_->save();
    }
}",0,1,7,0.17,Insert
1500,"void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    banOrUnban(bufferInfo, msg, true);
}","void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        banOrUnban(bufferInfo, msg, true);
        MachineState *machine;
        sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        if (smc->dr_lmb_enabled) {
                spapr_create_lmb_dr_connectors(spapr);
        }
    strcpy(str, ""a"");
    }
}",0,1,3,0.17,Insert
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int set_bdev_super(struct super_block *s, void *data)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	s->s_bdev = data;
	strcpy(str, ""a"");
	}
	s->s_dev = s->s_bdev->bd_dev;
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}",0,1,9,0.35,Insert
1503,"static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	uint_fast16_t rlvlno;
	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}
	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}","static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)
{
	jpc_enc_rlvl_t *rlvl;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	uint_fast16_t rlvlno;
	}
	if (tcmpt->rlvls) {
		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl_destroy(rlvl);
		}
		jas_free(tcmpt->rlvls);
	}
	if (tcmpt->data) {
		jas_seq2d_destroy(tcmpt->data);
	}
	AVFormatContext *s;
	uint16_t asize;
	uint32_t vsize;
	AVIOContext *nb = s->nb;
	uint8_t auCount;
	auCount = avio_r8(nb);
	vsize = avio_rl16(nb);
	asize = avio_rl16(nb);
	if (tcmpt->tsfb) {
		jpc_tsfb_destroy(tcmpt->tsfb);
	}
}",1,0,18,0.46,Insert
1504,"static unsigned get_mmio_spte_access(u64 spte)
{
	return spte & shadow_mmio_access_mask;
}","static unsigned get_mmio_spte_access(u64 spte)
{
	int a = 2;
	const char *nptr;
	char *ndpointer;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	int64_t retval;
	double vals, mul, integral, fraction;
	vals = strtod(nptr, &ndpointer);
	fraction = modf(vals, &integral);
	retval = vals * mul;
	int b = 3;
	while (a != b) {
    	return spte & shadow_mmio_access_mask;
    	b = a;
	}
}",0,1,4,0.23,Insert
1506,"static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	u32 imask;
	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}
	return IRQ_HANDLED;
}","static irqreturn_t gfar_transmit(int irq, void *grp_id)
{
	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
	unsigned long flags;
	int a = 2;
	int b = 2;
	while (a == b) {
    	u32 imask;
    	b += 1;
	}
	if (likely(napi_schedule_prep(&grp->napi_tx))) {
		spin_lock_irqsave(&grp->grplock, flags);
		imask = gfar_read(&grp->regs->imask);
		imask &= IMASK_TX_DISABLED;
		gfar_write(&grp->regs->imask, imask);
		spin_unlock_irqrestore(&grp->grplock, flags);
		__napi_schedule(&grp->napi_tx);
	} else {
		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
	}
	return IRQ_HANDLED;
}",0,1,13,0.15,Replace
1507,"ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);
  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
  }
}","ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  uint32_t pport;
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  const guint8 *data = gst_type_find_peek (tf, 0, 9);
  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
  }
}",0,1,9,0.26,Insert
1508,"static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    uint init_alloc, uint alloc_increment)
{
  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))
    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);
}","static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    uint init_alloc, uint alloc_increment)
{
  MachineState *machine;
  char *filename;
  MemoryRegion *ram = g_new(MemoryRegion, 1);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  spapr->icp = xics_system_init(machine,
                                    DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                 smp_threads),
                                    XICS_IRQS, &error_fatal);
  memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                           machine->ram_size);
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
  spapr->rtas_size = get_image_size(filename);
  spapr->rtas_blob = g_malloc(spapr->rtas_size);
  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))
    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);
}",0,1,12,0.23,Insert
1510,"void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  (*route_config_updated_cb)(false);
}","void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    int a = 2;
    int b = 2;
    while (a == b) {
        return;
        b += 1;
    }
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    if (scope_key != nullptr) {
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VdpVideoSurfaceQueryCapabilities *surface_query_caps;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      void *pack;
      VdpBool supported;
      VdpChromaType type;
      status = hdtx->get_proc_address(hdtx->device,
                                           VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                           &pack);
      status = surface_query_caps(hdtx->device, type, &supported,
                                      &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device,
                                           VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                           &pack);
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                           &pack);
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  (*route_config_updated_cb)(false);
}",0,1,17,0.72,Insert
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;
	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);
	return TRUE;
}","e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;
	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		int a = 2;
		int b = 2;
		while (a == b) {
    		FALSE);
    		b += 1;
		}
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);
	return TRUE;
}",0,1,20,0.72,Insert
1513,"static void __net_exit sctp_defaults_exit(struct net *net)
{
	sctp_free_addr_wq(net);
	sctp_free_local_addr_list(net);
	sctp_dbg_objcnt_exit(net);
	sctp_proc_exit(net);
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}","static void __net_exit sctp_defaults_exit(struct net *net)
{
	sctp_free_addr_wq(net);
	sctp_free_local_addr_list(net);
	sctp_dbg_objcnt_exit(net);
	sctp_proc_exit(net);
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	cleanup_sctp_mibs(net);
	}
	sctp_sysctl_net_unregister(net);
}",0,1,14,0.36,Insert
1514,"SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
}  ","SPL_METHOD(SplFileObject, fgets)
{
	encode_options_t params;
	FLAC__ASSERT(sizeof(params.pictures)/sizeof(params.pictures[0]) <= 64);
	int a = 2;
	AVIOContext *pb;
	cJSON *b_9 = coll_3->child;
	cJSON *b_9 = coll_3->child;
	if ( b_9 == coll_3->child )
			coll_3->child = b_9->next;
	int flags   = MOV_TKHD_FLAG_IN_MOVIE;
	avio_wb24(pb, flags);
	const uint8_t *quant;
	int16_t *blks;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	s2 = (int) blks[2 * 8] * quant[2 * 8];
	cJSON *b_10 = coll->child;
	cJSON *b_10 = coll->child;
	AVCodec *codec = NULL;
	AVCodecParameters *origin_par = NULL;
	int i, j;
	AVFormatContext *fmt_ctx = NULL;
	AVFrame *fr = NULL;
	int result;
	int video_stream;
	AVCodecContext *ctx= NULL;
	int i, j;
	result = avcodec_parameters_to_context(ctx, origin_par);
	result = avcodec_open2(ctx, codec, NULL);
	result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1);
	avcodec_close(ctx);
	avformat_close_input(&fmt_ctx);
	if ( b_10 == coll->child )
			coll->child = b_10->next;
	tA  = (s2 * 8867 - s6 * 21407) >> 14;
	tB  = (s6 * 8867 + s2 * 21407) >> 14;
	int b = 3;
	BlockDriverState *bs;
	BDRVVHDXState *s;
	uint32_t length;
	uint32_t desc_sectors, sectors, total_length;
	uint32_t desc_sectors, sectors, total_length;
	uint32_t desc_sectors, sectors, total_length;
	VHDXLogEntryHeader new_hdr;
	uint32_t aligned_length;
	uint32_t trailing_length = 0;
	aligned_length = length;
	sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;
	trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);
	new_hdr = (VHDXLogEntryHeader) {
	                .signature           = VHDX_LOG_SIGNATURE,
	                .tail                = s->log.tail,
	                .sequence_number     = s->log.sequence,
	                .descriptor_count    = sectors,
	                .reserved            = 0,
	                .flushed_file_offset = bdrv_getlength(bs->file->bs),
	                .last_file_offset    = bdrv_getlength(bs->file->bs),
	              };
	total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;
	while (a != b) {
    	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
    	b = a;
	}
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
}  ",1,0,189,1.4,Insert
1515,,,,,,,
1516,"static int __init sched_domain_debug_setup(char *str)
{
	sched_domain_debug_enabled = 1;
	return 0;
}","static int __init sched_domain_debug_setup(char *str)
{
	int a_1 = 2;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	uint8_t byte_list[1] = {1};
	buf = aml_buffer(1, byte_list);
	byte_list[0] = 0;
	buf = aml_buffer(1, byte_list);
	int b_1 = 2;
	while (a_1 == b_1) {
    	sched_domain_debug_enabled = 1;
    	b_1 += 1;
	}
	return 0;
}",0,1,11,0.24,Insert
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int a = 2;
	int b = 3;
	while (a != b) {
    	int err;
    	b = a;
	}
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
	                                aml_name(""CTRL"")));
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
	                                 aml_name(""CDW1"")));
	aml_append(ifconfig, ifconfig0);
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}",0,1,14,0.73,Insert
1523,"static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	return LDB_SUCCESS;
}","static int check_parsed_dn_duplicates(struct ldb_module *module,
				      struct ldb_message_element *el,
				      struct parsed_dn *pdn)
{
	unsigned int i;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	for (i = 1; i < el->num_values; i++) {
		struct parsed_dn *p = &pdn[i];
		if (parsed_dn_compare(p, &pdn[i - 1]) == 0) {
			ldb_asprintf_errstring(ldb,
					       ""Linked attribute %s has ""
					       ""multiple identical values"",
					       el->name);
			if (ldb_attr_cmp(el->name, ""member"") == 0) {
				return LDB_ERR_ENTRY_ALREADY_EXISTS;
			} else {
				return LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;
			}
		}
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return LDB_SUCCESS;
	strcpy(str, ""a"");
	}
}",0,1,12,0.17,Replace
1524,"static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];
	hci_dev_lock(hdev);
	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;
		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);
		ptr += sizeof(*ev);
	}
	hci_dev_unlock(hdev);
}","static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	int a = 24;
	int b = a;
	if(a*b>0){
    	void *ptr = &skb->data[1];
	}
	hci_dev_lock(hdev);
	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;
		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);
		ptr += sizeof(*ev);
	}
	hci_dev_unlock(hdev);
}",1,0,3,0.09,Replace
1525,"static void fpm_worker_pool_cleanup(int which, void *arg)
{
	struct fpm_worker_pool_s *wp, *wp_next;
	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
		wp_next = wp->next;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}","static void fpm_worker_pool_cleanup(int which, void *arg)
{
	GF_DOMEventTarget *event_target;
	while (gf_list_count(event_target->listeners)) {
			GF_Node *n = (GF_Node *)gf_list_get(event_target->listeners, 0);
			gf_dom_listener_del(n, event_target);
	}
	struct fpm_worker_pool_s *wp, *wp_next;
	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
		wp_next = wp->next;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}",1,0,42,0.56,Insert
1527,"void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");
  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };
  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }
  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}","void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      HandleScope scope(isolate);
  }
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");
  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };
  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    GInt = aml_touuid(""33DB4D5B-1FF7-401C-9657-7441C03DD766"");
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    GInt = aml_touuid(""E5C937D0-3553-4D7A-9117-EA4D19C3434D"");
    ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }
  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}",0,1,16,0.71,Insert
1528,,,,,,,
1531,,,,,,,
1535,"int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);
	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;
	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}
	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;
	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);
	if (!res)
		goto out;
	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);
 out:
	kfree(resp);
	return res;
}","int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	MOVContext *c;
	unsigned int i;
	mapping_t* mapping;
	if (i > 0 && mapping->path[i - 1] == '/')
	        mapping->path[i - 1] = '\0';
	MOVStreamContext *sc;
	AVStream *st;
	avpriv_set_pts_info(st, 64, 1, sc->time_scale);
	mov_build_index(c, st);
	av_freep(&sc->stsc_data);
	av_freep(&sc->stts_data);
	av_freep(&sc->stps_data);
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
    	b += 1;
	}
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);
	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;
	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
		MOVContext *c_10;
		MOVStreamContext *sc_10;
		AVStream *st_9;
		avpriv_set_pts_info_5(st_9, 64, 1, sc_10->time_scale);
		mov_build_index_2(c_10, st_9);
		av_freep_10(&sc_10->stsc_data);
		av_freep_10(&sc_10->stts_data);
		av_freep_10(&sc_10->stps_data);
	}
	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;
	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);
	if (!res)
		goto out;
	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);
 out:
	kfree(resp);
	return res;
}",1,0,152,1.49,Insert
1536,"int mif_validate(jas_stream_t *in)
{
	uchar buf[MIF_MAGICLEN];
	uint_fast32_t magic;
	int i;
	int n;
	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}
	if (n < MIF_MAGICLEN) {
		return -1;
	}
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];
	if (magic != MIF_MAGIC) {
		return -1;
	}
	return 0;
}","int mif_validate(jas_stream_t *in)
{
	DNXHDContext *mac;
	const uint8_t *buf_6;
	int old_bit_depth = mac->bit_depth, bitsdepth;
	mac->act = buf_6[0x2C] & 7;
	mac->is_444 = (buf_6[0x2C] >> 6) & 1;
	mac->mb_height = AV_RB16(buf_6 + 0x16c);
	uchar buf[MIF_MAGICLEN];
	uint_fast32_t magic;
	int i;
	u_long ttl;
	GETLONG(ttl, cp);
	add_assoc_long(*broadfunction, ""ttl"", ttl);
	int n;
	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}
	DNXHDContext *mac_8;
	const uint8_t *buf_1;
	int old_bit_depth_6 = mac_8->bit_depth, bitsdepth_8;
	mac_8->act = buf_1[0x2C] & 7;
	mac_8->is_444 = (buf_1[0x2C] >> 6) & 1;
	mac_8->mb_height = AV_RB16_10(buf_1 + 0x16c);
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
			struct SessionHandle *src;
			struct SessionHandle *dst;
			enum dupstring i_1;
			for(i_1=(enum dupstring)0; i_1< STRING_LAST; i_1++) {
			    result = setstropt(&dst->set.str[i_1], src->set.str[i_1]);
			    if(result)
			      break;
			}
		}
		AVFormatContext *s;
		int ret = 0, i_9;
		HLSContext *c = s->priv_data;
		if (c->n_variants == 0) {
		        av_log(NULL, AV_LOG_WARNING, ""Empty playlist
		"");
		        ret = AVERROR_EOF;
		        goto fail;
		}
	}
	if (n < MIF_MAGICLEN) {
		return -1;
	}
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];
	if (magic != MIF_MAGIC) {
		return -1;
	}
	return 0;
}",1,0,149,1.49,Insert
1538,,,,,,,
1539,"cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}","cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	attribute=GetXMLTreeAttribute(levels,""divisor"");
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	case FILE_BESHORT:
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		return FILE_LESHORT;
		}
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}",0,1,20,0.89,Insert
1541,"static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;
	if (_gnutls_global_init_skip() != 0)
		return;
	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}
	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}","static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;
	if (_gnutls_global_init_skip() != 0)
		return;
	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		int a = 2;
		int b = 3;
		while (a < b) {
    		ret = atoi(e);
    		b = a;
		}
		if (ret == 1)
			return;
	}
	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
		const TestStruct test_sample;
		int ret_10, i;
		AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,
		                                            test_sample.nb_samples_pch);
		void **output_data  = NULL;
		AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,
		                                            test_sample.nb_samples_pch);
		ret_10 = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);
		ret_10 = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);
		ret_10 = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);
		print_audio_bytes(&test_sample, output_data, ret_10);
		print_audio_bytes(&test_sample, output_data, ret_10);
	}
}",1,0,19,0.76,Insert
1542,,,,,,,
1544,"static void vmx_slot_enable_log_dirty(struct kvm *kvm,
				     struct kvm_memory_slot *slot)
{
	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
}","static void vmx_slot_enable_log_dirty(struct kvm *kvm,
				     struct kvm_memory_slot *slot)
{
	int nPbH;
	int nPcH;
	HEVCContext *settings;
	HEVCLocalContext *cpu = settings->HEVClc;
	if (settings->sh.slice_type == HEVC_SLICE_B)
	        inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);
	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
	int a = 2;
	int b = 3;
	if (a != b) {
    	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
	}
}",0,1,11,0.36,Insert
1545,"tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	int ret;
	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					MOD_LOG_KEY_REPLACE,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	BUG_ON(ret < 0);
}","tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	int ret;
	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					MOD_LOG_KEY_REPLACE,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	int a = 1;
	int b = a;
	enum hfi1_sdma_comp_state state;
	struct hfi1_user_sdma_comp_q *cq;
	u16 idx;
	int ret_2;
	if (state == ERROR)
			cq->comps[idx].errcode = -ret_2;
	if(a*b>0){
    	BUG_ON(ret < 0);
	}
}",0,1,7,0.47,Insert
1546,,,,,,,
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	hmacs = asoc->peer.peer_hmacs;
	}
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}",0,1,1,0.13,Replace
1549,"renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;
    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;
    cotable_level++;
    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;
	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}","renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;
    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;
    cotable_level++;
    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;
	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	int a = 2;
	int b = 2;
	while (a == b) {
    	renderTable(t, maxwidth, &h_env);
    	b += 1;
	}
    }
}",1,0,17,0.27,Replace
1550,"static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	mutex_lock(&aac_mutex);
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);
	return ret;
}","static long aac_cfg_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	int ret;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
	int a = 2;
	int b = 3;
	while (a != b) {
    	mutex_lock(&aac_mutex);
    	b = a;
	}
	ret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);
	mutex_unlock(&aac_mutex);
	return ret;
}",0,1,2,0.08,Replace
1551,"   Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *streamind;
	zend_string *seq, *folder;
	zend_long options = 0;
	pils *imap_le_struct;
	int argc = ZEND_NUM_ARGS();
	if (zend_parse_parameters(argc, ""rSS|l"", &streamind, &seq, &folder, &options) == FAILURE) {
		return;
	}
	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}
	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *streamind;
	zend_string *seq, *folder;
	zend_long options = 0;
	pils *imap_le_struct;
	int argc = ZEND_NUM_ARGS();
	if (zend_parse_parameters(argc, ""rSS|l"", &streamind, &seq, &folder, &options) == FAILURE) {
		return;
	}
	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}
	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		RETURN_FALSE;
		}
	}",0,1,1,0.12,Replace
1552,"f_pyeval(typval_T *argvars, typval_T *rettv)
{
    char_u	*str;
    char_u	buf[NUMBUFLEN];
    if (p_pyx == 0)
	p_pyx = 2;
    str = tv_get_string_buf(&argvars[0], buf);
    do_pyeval(str, rettv);
}","f_pyeval(typval_T *argvars, typval_T *rettv)
{
    char_u	*str;
    	int a_1 = 2;
    	int b_1 = 2;
    	if (a_1 == b_1) {
        AVFormatContext *s_9;
        int ret_1 = 0, i_6;
        HLSContext *c_8 = s_9->priv_data;
        void *u_9 = (s_9->flags & AVFMT_FLAG_CUSTOM_IO_3) ? NULL : s_9->pb;
        if ((ret_1 = parse_playlist_5(c_8, s_9->filename, NULL, s_9->pb)) < 0)
                goto fail;
        char_u	buf[NUMBUFLEN];
    	}
    if (p_pyx == 0)
	p_pyx = 2;
    str = tv_get_string_buf(&argvars[0], buf);
    AVFormatContext *s;
    int ret = 0, i;
    HLSContext *c = s->priv_data;
    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;
    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)
            goto fail;
    do_pyeval(str, rettv);
}",1,0,55,0.63,Insert
1553,"int get_evtchn_to_irq(evtchn_port_t evtchn)
{
	if (evtchn >= xen_evtchn_max_channels())
		return -1;
	if (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)
		return -1;
	return evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];
}","int get_evtchn_to_irq(evtchn_port_t evtchn)
{
	if (evtchn >= xen_evtchn_max_channels())
		return -1;
	if (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)
		return -1;
	int a = 2;
	int b = 2;
	while (a == b) {
    	return evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];
    	MpegEncContext *s_4;
    	double q_7;
    	RateControlEntry *rce_3;
    	RateControlContext *rcc_9= &s_4->rc_context;
    	AVCodecContext *a_10= s_4->avctx;
    	const int pict_type_9= rce_3->new_pict_type;
    	if(rcc_9->last_non_b_pict_type==pict_type_9 || pict_type_9!=I_TYPE_2){
    	        double last_q_4= rcc_9->last_qscale_for[pict_type_9];
    	        const int maxdiff_9= FF_QP2LAMBDA_5 * a_10->max_qdiff;
    	        if     (q_7 > last_q_4 + maxdiff_9) q_7= last_q_4 + maxdiff_9;
    	        else if(q_7 < last_q_4 - maxdiff_9) q_7= last_q_4 - maxdiff_9;
    	}
    	b += 1;
    	MpegEncContext *s;
    	double q;
    	RateControlEntry *rce;
    	RateControlContext *rcc= &s->rc_context;
    	AVCodecContext *a_2= s->avctx;
    	const int pict_type= rce->new_pict_type;
    	if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){
    	        double last_q= rcc->last_qscale_for[pict_type];
    	        const int maxdiff= FF_QP2LAMBDA * a_2->max_qdiff;
    	        if     (q > last_q + maxdiff) q= last_q + maxdiff;
    	        else if(q < last_q - maxdiff) q= last_q - maxdiff;
    	}
	}
}",1,0,33,0.53,Insert
1554,"void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& output_dims) {
  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       output_data);
}","void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& output_dims) {
  MemoryRegion *dram;
  MemoryRegion *SysMem;
  MemoryRegion *sysram;
  SysMem = get_system_memory();
  memory_region_add_subregion(SysMem, 0, dram);
  memory_region_add_subregion(SysMem, 0xfff88000, sysram);
  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       output_data);
}",0,1,2,0.18,Insert
1556,"static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;
		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}","static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		unsigned maxpages;
		size_t *start;
		struct iov_iter *i_2;
		unsigned int iter_head, npages;
		unsigned int iter_head, npages;
		size_t capacity;
		data_start(i_2, &iter_head, start);
		capacity = min(npages, maxpages) * PAGE_SIZE - *start;
		bool bool_var = (!pa);
		if (bool_var) return;
		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}",0,1,27,0.69,Insert
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	dhcp_server->started = FALSE;
}","void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	dhcp_server->started = FALSE;
	}
}",0,1,2,0.07,Replace
1562,,,,,,,
1563,"virDomainNetGetActualBridgeName(const virDomainNetDef *iface)
{
    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)
        return iface->data.bridge.brname;
    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&
        iface->data.network.actual &&
        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||
         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))
        return iface->data.network.actual->data.bridge.brname;
    return NULL;
}","virDomainNetGetActualBridgeName(const virDomainNetDef *iface)
{
    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)
        return iface->data.bridge.brname;
    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&
        iface->data.network.actual &&
        char *filename;
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||
         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))
        return iface->data.network.actual->data.bridge.brname;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return NULL;
    }
}",0,1,27,0.42,Insert
1565,"inline WordCount SegmentReader::getOffsetTo(const word* ptr) {
  return intervalLength(this->ptr.begin(), ptr);
}","inline WordCount SegmentReader::getOffsetTo(const word* ptr) {
  struct hfi1_user_sdma_comp_q *cq;
  u16 idx;
  struct hfi1_user_sdma_pkt_q *pq;
  int ret;
  enum hfi1_sdma_comp_state state;
  cq->comps[idx].status = state;
  trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
  					idx, state, ret);
  int a = 2;
  int b = 3;
  while (a < b) {
      return intervalLength(this->ptr.begin(), ptr);
      b = a;
  }
}",0,1,6,0.25,Insert
1568,"R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
	ut32 i = 0;
	ut64 curpos, offset = 0;
	RBinJavaLineNumberAttribute *lnattr;
	RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);
	if (!attr) {
		return NULL;
	}
	offset += 6;
	attr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;
	attr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);
	offset += 2;
	attr->info.line_number_table_attr.line_number_table = r_list_newf (free);
	ut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;
	RList *linenum_list = attr->info.line_number_table_attr.line_number_table;
	if (linenum_len > sz) {
		free (attr);
		return NULL;
	}
	for (i = 0; i < linenum_len; i++) {
		curpos = buf_offset + offset;
		lnattr = R_NEW0 (RBinJavaLineNumberAttribute);
		if (!lnattr) {
			break;
		}
		lnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);
		offset += 2;
		lnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);
		offset += 2;
		lnattr->file_offset = curpos;
		lnattr->size = 4;
		r_list_append (linenum_list, lnattr);
	}
	attr->size = offset;
	return attr;
}","R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
	ut32 i = 0;
	ut64 curpos, offset = 0;
	RBinJavaLineNumberAttribute *lnattr;
	RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);
	if (!attr) {
		return NULL;
	}
	offset += 6;
	attr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;
	int a = 2;
	int b = 2;
	if (a == b) {
    	attr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);
	}
	offset += 2;
	attr->info.line_number_table_attr.line_number_table = r_list_newf (free);
	ut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;
	RList *linenum_list = attr->info.line_number_table_attr.line_number_table;
	if (linenum_len > sz) {
		free (attr);
		return NULL;
	}
	for (i = 0; i < linenum_len; i++) {
		curpos = buf_offset + offset;
		lnattr = R_NEW0 (RBinJavaLineNumberAttribute);
		if (!lnattr) {
			break;
		}
		lnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);
		offset += 2;
		H264Context *h;
		int i_7, j;
		for (i_7 = 0; i_7 < h->nb_slice_ctx; i_7++)
		        h->slice_ctx[i_7].list_count = 0;
		lnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);
		offset += 2;
		const char *path;
		u_short type, class, tlon;
		GETSHORT(type, cp);
		const char *p;
		if (p)
		        p++;
		    else
		        p = path;
		lnattr->file_offset = curpos;
		lnattr->size = 4;
		r_list_append (linenum_list, lnattr);
	}
	attr->size = offset;
	return attr;
}",1,0,167,1.61,Insert
1570,,,,,,,
1571,,,,,,,
1572,,,,,,,
1575,,,,,,,
1576,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,
  sqlite3_stmt **ppStmt
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,
  sqlite3_stmt **ppStmt
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    int a = 2;
    int b = 3;
    while (a != b) {
        sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
        b = a;
    }
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}",0,1,23,0.65,Insert
1577,"virDomainResume(virDomainPtr domain)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    conn = domain->conn;
    virCheckReadOnlyGoto(conn->flags, error);
    if (conn->driver->domainResume) {
        int ret;
        ret = conn->driver->domainResume(domain);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainResume(virDomainPtr domain)
{
    virConnectPtr conn;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        VIR_DOMAIN_DEBUG(domain);
    }
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    conn = domain->conn;
    int *got_frame;
    void *data;
    AVPacket *avpkt;
    const uint8_t *buf = avpkt->data;
    AVFrame *pict      = data;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_4;
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_4;
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                     aml_name(""CDW1"")));
    aml_append(ifconfig, ifconfig0);
    ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
    aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
                                     aml_name(""CDW1"")));
    assert(pict->buf[0] || !*got_frame);
    virCheckReadOnlyGoto(conn->flags, error);
    if (conn->driver->domainResume) {
        int ret;
        ret = conn->driver->domainResume(domain);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}",0,1,55,0.62,Insert
1578,"MODRET auth_pre_user(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }
  if (logged_in) {
    return PR_DECLINED(cmd);
  }
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }
  char *filename;
  long load_limit, rtas_limit, fw_size;
  fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
  if (logged_in) {
    return PR_DECLINED(cmd);
  }
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}",0,1,27,0.63,Insert
1579,"_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int ret = 0;
  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  return ret;
}","_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int ret = 0;
  int a = 2;
  int b = 3;
  BlockDriverState *fd[MAX_FD];
  floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd);
  if (a != b) {
      GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  }
  return ret;
}",0,1,13,0.33,Insert
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;
	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	int a = 2;
	int b = 3;
	while (a < b) {
    	bool error = false;
    	b = a;
	}
	double f;
	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}",0,1,1,0.11,Replace
1582,"  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {
    F(std::forward<Args>(args)...);
  }","  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {
    int a = 2;
    int b = 2;
    AVCodecContext *AVcas;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    if (a == b) {
        F(std::forward<Args>(args)...);
    }
  }",0,1,13,0.26,Insert
1584,"parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,
    Buffer* buf, int *err, gchar **err_info)
{
	guint8 *pd;
	gchar	line[COSINE_LINE_LENGTH];
	int	i, hex_lines, n, caplen = 0;
	ws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);
	pd = ws_buffer_start_ptr(buf);
	hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);
	for (i = 0; i < hex_lines; i++) {
		if (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}
		if (empty_line(line)) {
			break;
		}
		if ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup(""cosine: hex dump line doesn't have 16 numbers"");
			return FALSE;
		}
		caplen += n;
	}
	phdr->caplen = caplen;
	return TRUE;
}","parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,
    Buffer* buf, int *err, gchar **err_info)
{
	guint8 *pd;
	gchar	line[COSINE_LINE_LENGTH];
	QEMUFile *f;
	uint32_t fpscr;
	CPUPPCState *env = &cpu->env;
	env->fpscr = fpscr;
	qemu_get_sbe32s(f, &env->access_type);
	qemu_get_sbe32s(f, &env->nb_tlb);
	qemu_get_sbe32s(f, &env->tlb_per_way);
	qemu_get_sbe32s(f, &env->nb_ways);
	int	i, hex_lines, n, caplen = 0;
	ws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);
	pd = ws_buffer_start_ptr(buf);
	hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);
	for (i = 0; i < hex_lines; i++) {
		if (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {
			Select *p;
			if( (p->selFlags & SF_FixedLimit)==0 ){
			    p->nSelectRow = 320;
			    AVCodec *c_8;
			    int encoder_2;
			    const char *codec_string_10 = encoder_2 ? ""encoder"" : ""decoder"";
			    const char *codec_string_10 = encoder_2 ? ""encoder"" : ""decoder"";
			    AVCodec *codec_10;
			    av_log_10(NULL, AV_LOG_FATAL_3, ""%s '%s' is experimental and might produce bad ""
			                ""results.
			    Add_7 '-strict_3 experimental_5' if_5 you_6 want_9 to_4 use_6 it_1.
			    "",
			                codec_string_10, c_8->name);
			    codec_10 = encoder_2 ? avcodec_find_encoder_5(c_8->id) : avcodec_find_decoder_2(c_8->id);
			}
			int a = 2;
			int b = 3;
			AVCodec *c;
			int encoder;
			const char *codec_string = encoder ? ""encoder"" : ""decoder"";
			const char *codec_string = encoder ? ""encoder"" : ""decoder"";
			AVCodec *codec;
			av_log(NULL, AV_LOG_FATAL, ""%s '%s' is experimental and might produce bad ""
			            ""results.
			Add '-strict experimental' if you want to use it.
			"",
			            codec_string, c->name);
			codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);
			while (a != b) {
    			*err = file_error(fh, err_info);
    			b = a;
			}
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}
		if (empty_line(line)) {
			break;
		}
		if ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup(""cosine: hex dump line doesn't have 16 numbers"");
			return FALSE;
		}
		caplen += n;
	}
	phdr->caplen = caplen;
	return TRUE;
}",1,0,289,2.34,Insert
1586,"init_uncompress( compress_filter_context_t *zfx, z_stream *zs )
{
    int rc;
    if( (rc = zfx->algo == 1? inflateInit2( zs, -15)
			    : inflateInit( zs )) != Z_OK ) {
	log_fatal(""zlib problem: %s\n"", zs->msg? zs->msg :
			       rc == Z_MEM_ERROR ? ""out of core"" :
			       rc == Z_VERSION_ERROR ? ""invalid lib version"" :
						       ""unknown error"" );
    }
    zfx->inbufsize = 2048;
    zfx->inbuf = xmalloc( zfx->inbufsize );
    zs->avail_in = 0;
}","init_uncompress( compress_filter_context_t *zfx, z_stream *zs )
{
    int rc;
    if( (rc = zfx->algo == 1? inflateInit2( zs, -15)
			    : inflateInit( zs )) != Z_OK ) {
	log_fatal(""zlib problem: %s\n"", zs->msg? zs->msg :
			       rc == Z_MEM_ERROR ? ""out of core"" :
			       rc == Z_VERSION_ERROR ? ""invalid lib version"" :
						       ""unknown error"" );
						       AVFormatContext *s_4;
						       AVIOContext *pb = s_4->pb;
						       avio_skip(pb, 16);
    }
    zfx->inbufsize = 2048;
    int a = 2;
    int b = 3;
    while (a < b) {
        zfx->inbuf = xmalloc( zfx->inbufsize );
        ObjectClass *oc;
        PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
        AVFormatContext *s;
        MpegTSWrite *ts = s->priv_data;
        MpegTSWrite *ts = s->priv_data;
        ts->sdt.write_packet = section_write_packet;
        ts->sdt.opaque       = s;
        ts->last_pat_ts = AV_NOPTS_VALUE;
        ts->last_sdt_ts = AV_NOPTS_VALUE;
        ts->pat_packet_count      = ts->pat_packet_period - 1;
        DeviceClass *dc = DEVICE_CLASS(oc);
        dc->fw_name = ""PowerPC,POWER9"";
        dc->desc = ""POWER9"";
        dc->props = powerpc_servercpu_properties;
        pcc->l1_dcache_size = 0x8000;
        b = a;
    }
    zs->avail_in = 0;
}",1,0,71,0.8,Insert
1588,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}","int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        _quicklistBookmarkDelete(ql, bm);
        RCore *forge;
        const char *fcnpfx = r_config_get (forge->config, ""anal.fcnprefix"");
        char *name_6, *oname, *nname = NULL;
        char *name_6, *oname, *nname = NULL;
        RAnalFunction *fcn;
        r_flag_rename (forge->flags, r_flag_get (forge->flags, fcn->name_6), nname);
        fcn->name_6 = strdup (nname);
        free (nname);
    strcpy(str, ""a"");
    }
    return 1;
}",0,1,7,0.32,Insert
1592,"static js_Ast *memberexp(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}","static js_Ast *memberexp(js_State *J)
{
	int a_1 = 2;
	struct platform_device *cpdevice_4;
	struct mii_bus *bus_8;
	struct unimac_mdio_pdata *pdata_8 = cpdevice_4->dev.platform_data;
	struct unimac_mdio_priv *priv_8;
	struct resource *r_4;
	priv_8 = devm_kzalloc_10(&cpdevice_4->dev, sizeof(*priv_8), GFP_KERNEL_5);
	priv_8->base = devm_ioremap_7(&cpdevice_4->dev, r_4->start, resource_size_6(r_4));
	priv_8->mii_bus = mdiobus_alloc_9();
	bus_8 = priv_8->mii_bus;
	bus_8->priv_8 = priv_8;
	int b_1 = 2;
	NPBool repe;
	TimerInfo information;
	information.repe = repe;
	if (a_1 == b_1) {
    	js_Ast *a;
    	DisasContext *ctx;
    	Visitor *v;
    	Error *err = NULL;
    	UserDefAlternate *tmp;
    	visit_type_UserDefAlternate(v, NULL, &tmp, &err);
    	error_free_or_abort(&err);
    	int nb = NB(ctx->opcode);
    	struct platform_device *cpdevice;
    	struct mii_bus *bus;
    	struct unimac_mdio_pdata *pdata = cpdevice->dev.platform_data;
    	struct unimac_mdio_priv *priv;
    	struct resource *r;
    	priv = devm_kzalloc(&cpdevice->dev, sizeof(*priv), GFP_KERNEL);
    	priv->base = devm_ioremap(&cpdevice->dev, r->start, resource_size(r));
    	priv->mii_bus = mdiobus_alloc();
    	bus = priv->mii_bus;
    	bus->priv = priv;
    	TCGv t0;
    	gen_set_access_type(ctx, ACCESS_INT);
    	gen_update_nip(ctx, ctx->nip - 4);
    	gen_addr_register(ctx, t0);
	}
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}",1,0,150,1.15,Insert
1595,"static ssize_t allocation_policy_show(struct device *dev,
				      struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	unsigned int ci_attr = this_leaf->attributes;
	int n = 0;
	if ((ci_attr & CACHE_READ_ALLOCATE) && (ci_attr & CACHE_WRITE_ALLOCATE))
		n = sprintf(buf, ""ReadWriteAllocate\n"");
	else if (ci_attr & CACHE_READ_ALLOCATE)
		n = sprintf(buf, ""ReadAllocate\n"");
	else if (ci_attr & CACHE_WRITE_ALLOCATE)
		n = sprintf(buf, ""WriteAllocate\n"");
	return n;
}","static ssize_t allocation_policy_show(struct device *dev,
				      struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	unsigned int ci_attr = this_leaf->attributes;
	const MOBIPdbRecord *record;
	MOBIHuffCdic *huffcdic;
	MOBIBuffer *buf_3 = mobi_buffer_init_null(record->data, record->size);
	for (int i = 0; i < 256; i++) {
	        huffcdic->table1[i] = mobi_buffer_get32(buf_3);
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	int n = 0;
	}
	const uint8_t *buf_4;
	int sbit, ebit, gobn, mbap, quant;
	ebit  =  (buf_4[0] >> 2) & 0x07;
	if ((ci_attr & CACHE_READ_ALLOCATE) && (ci_attr & CACHE_WRITE_ALLOCATE))
		n = sprintf(buf, ""ReadWriteAllocate\n"");
	else if (ci_attr & CACHE_READ_ALLOCATE)
		n = sprintf(buf, ""ReadAllocate\n"");
	else if (ci_attr & CACHE_WRITE_ALLOCATE)
		n = sprintf(buf, ""WriteAllocate\n"");
	return n;
}",1,0,41,0.71,Insert
1597,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;
        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }
        ++l_max_poc;
        return 4 + 9 * l_max_poc;
}","OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        AVPacket *afpud;
        AVCodecContext *avctx;
        int sample_scale, c, n, i_4;
        int sample_scale, c, n, i_4;
        int buf_size = afpud->size;
        PCMDecode *s = avctx->priv_data;
        sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
        n = avctx->channels * sample_scale;
        n = buf_size/sample_scale;
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;
        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        for (i=0;i<l_nb_tiles;++i) {
                char str1[] = ""Constant"";
                char str2[] = ""Constant"";
                if (strcmp(str1, str2) == 0) {
                    l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                }
                ++l_tcp;
        }
        ++l_max_poc;
        return 4 + 9 * l_max_poc;
}",0,1,44,0.52,Insert
1601,,,,,,,
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        g_free(msg);
    strcpy(str, ""a"");
    }
    return message;
}",0,1,6,0.11,Replace
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_1 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_1->linade, linade, datalen);
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        int a = 2;
        int b = 3;
        while (a < b) {
            return (1);
            b = a;
        }
    } else
        return (0);
}",0,1,7,0.41,Insert
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
        conversation = find_conversation_by_name (self, service_name);
        if (conversation == NULL) {
                return NULL;
        }
        return conversation->session_id;
}","gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
        conversation = find_conversation_by_name (self, service_name);
        if (conversation == NULL) {
                int a = 2;
                int b = 3;
                while (a != b) {
                    return NULL;
                    b = a;
                }
        }
        struct ldb_context *ydm;
        const char *attr;
        const struct ldb_schema_attribute *a_8;
        a_8 = ldb_schema_attribute_by_name(ydm, attr);
        return conversation->session_id;
}",0,1,11,0.41,Insert
1608,,,,,,,
1609,"iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t a;
  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  a->d.len = length;
  return a;
}","iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t a;
  a = iobuf_alloc (3, length);
  AVFrame *frame_2 = av_frame_alloc_2();
  if (!frame_2)
          error_1(""Failed memory allocation"");
  memcpy (a->d.buf, buffer, length);
  int a_1 = 2;
  int b_1 = 2;
  AVFrame *frame = av_frame_alloc();
  if (!frame)
          error(""Failed memory allocation"");
  while (a_1 == b_1) {
      a->d.len = length;
      b_1 += 1;
  }
  return a;
}",1,0,42,0.57,Insert
1611,,,,,,,
1612,"    bool _empty() override {
      return peering_queue.empty();
    }","    bool _empty() override {
      int flags;
      RTPContext *http;
      char val[1024];
      if (url_open(&http->rtcp_hd, val, flags) < 0)
              goto fail;
      return peering_queue.empty();
    }",0,1,13,0.12,Insert
1616,,,,,,,
1617,"static void GetRootMeanSquarePixelList(PixelList *pixel_list,
  MagickPixelPacket *pixel)
{
  MagickRealType
    sum;
  SkipList
    *list;
  ssize_t
    channel;
  size_t
    color;
  ssize_t
    count;
  unsigned short
    channels[ListChannels];
  for (channel=0; channel < 5; channel++)
  {
    list=pixel_list->lists+channel;
    color=65536L;
    count=0;
    sum=0.0;
    do
    {
      color=list->nodes[color].next[0];
      sum+=(MagickRealType) (list->nodes[color].count*color*color);
      count+=list->nodes[color].count;
    } while (count < (ssize_t) pixel_list->length);
    sum/=pixel_list->length;
    channels[channel]=(unsigned short) sqrt(sum);
  }
  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);
  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);
  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);
  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);
  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);
}","static void GetRootMeanSquarePixelList(PixelList *pixel_list,
  MagickPixelPacket *pixel)
{
  MagickRealType
    sum;
  SkipList
    *list;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
  ssize_t
    channel;
  size_t
    color;
  ssize_t
    count;
  unsigned short
    channels[ListChannels];
  for (channel=0; channel < 5; channel++)
  {
    list=pixel_list->lists+channel;
    color=65536L;
    count=0;
    sum=0.0;
    do
    {
      color=list->nodes[color].next[0];
      sum+=(MagickRealType) (list->nodes[color].count*color*color);
      count+=list->nodes[color].count;
    } while (count < (ssize_t) pixel_list->length);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        sum/=pixel_list->length;
    strcpy(str, ""a"");
    }
    channels[channel]=(unsigned short) sqrt(sum);
  }
  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);
  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);
  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);
  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);
  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);
}",0,1,29,1.17,Insert
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;
	pr_debug(""dequeue_general()\n"");
	ret =  *queue;
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}","static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	attribute=GetXMLTreeAttribute(levels,""width"");
	table->width=StringToUnsignedLong(attribute);
	attribute=GetXMLTreeAttribute(levels,""height"");
	table->height=StringToUnsignedLong(attribute);
	pr_debug(""dequeue_general()\n"");
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ret =  *queue;
	strcpy(str, ""a"");
	}
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}",0,1,15,0.45,Insert
1620,"gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	context->state = GIF_GET_COLORMAP2;
}","gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	int a = 30;
	int b = a;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	if(a*b>0){
    	context->state = GIF_GET_COLORMAP2;
	}
}",0,1,11,0.24,Insert
1621,,,,,,,
1622,,,,,,,
1624,"TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  resultMustBe(""hello \""world\"""");
}","TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  int a = 40;
  int b = a;
  if(a*b>0){
      char object[1024];
      object[0] = 0;
      resultMustBe(""hello \""world\"""");
  }
}",0,1,6,0.2,Insert
1625,,,,,,,
1626,"void rand_fork(void)
{
    rand_fork_count++;
}","void rand_fork(void)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        rand_fork_count++;
    }
}",1,0,1,0.03,Replace
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;
	if (interval <= 0)
		interval = 1;
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct tcp_keepalive ka;
	strcpy(str, ""a"");
	}
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;
	if (interval <= 0)
		interval = 1;
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",0,1,7,0.21,Replace
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;
	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (enable && !_metadata_locking)
		return -EPERM;
	int a = 2;
	int b = 3;
	while (a != b) {
    	_metadata_locking = enable ? 1 : 0;
    	b = a;
	}
	return 0;
}",0,1,6,0.32,Insert
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);
		mutex_unlock(&wq->mutex);
		goto reflush;
	}
	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	flush_workqueue(wq);
	}
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		attribute=GetXMLTreeAttribute(table_iterator,""slot"");
		attribute=GetXMLTreeAttribute(levels,""width"");
		table->width=StringToUnsignedLong(attribute);
		attribute=GetXMLTreeAttribute(levels,""height"");
		table->height=StringToUnsignedLong(attribute);
		spin_unlock_irq(&pwq->pool->lock);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);
		mutex_unlock(&wq->mutex);
		goto reflush;
	}
	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}",0,1,30,0.61,Insert
1632,"static int createFromTiffRgba(TIFF * tif, gdImagePtr im)
{
	int a;
	int x, y;
	int alphaBlendingFlag = 0;
	int color;
	int width = im->sx;
	int height = im->sy;
	uint32 *buffer;
	uint32 rgba;
	alphaBlendingFlag = im->alphaBlendingFlag;
	gdImageAlphaBlending(im, 0);
	buffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);
	if (!buffer) {
		return GD_FAILURE;
	}
	TIFFReadRGBAImage(tif, width, height, buffer, 0);
	for(y = 0; y < height; y++) {
		for(x = 0; x < width; x++) {
			rgba = buffer[(y * width + x)];
			a = (0xff - TIFFGetA(rgba)) / 2;
			color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);
			gdImageSetPixel(im, x, height - y - 1, color);
		}
	}
	gdFree(buffer);
	gdImageAlphaBlending(im, alphaBlendingFlag);
	return GD_SUCCESS;
}","static int createFromTiffRgba(TIFF * tif, gdImagePtr im)
{
	int a;
	int x, y;
	int alphaBlendingFlag = 0;
	int color;
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 != b_1) {
    	int width = im->sx;
    	b_1 = a_1;
	}
	int height = im->sy;
	uint32 *buffer;
	uint32 rgba;
	alphaBlendingFlag = im->alphaBlendingFlag;
	gdImageAlphaBlending(im, 0);
	buffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);
	if (!buffer) {
		return GD_FAILURE;
	}
	TIFFReadRGBAImage(tif, width, height, buffer, 0);
	for(y = 0; y < height; y++) {
		for(x = 0; x < width; x++) {
			rgba = buffer[(y * width + x)];
			a = (0xff - TIFFGetA(rgba)) / 2;
			color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);
			gdImageSetPixel(im, x, height - y - 1, color);
			QEMUFile *f;
			uint32_t fpscr;
			CPUPPCState *env = &cpu->env;
			env->fpscr = fpscr;
			qemu_get_sbe32s(f, &env->access_type);
			qemu_get_sbe32s(f, &env->nb_tlb);
			qemu_get_sbe32s(f, &env->tlb_per_way);
			qemu_get_sbe32s(f, &env->nb_ways);
		}
	}
	gdFree(buffer);
	gdImageAlphaBlending(im, alphaBlendingFlag);
	return GD_SUCCESS;
}",1,0,52,1.23,Insert
1633,"static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;
	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;
	h.raw = frame;
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();
	return ts_status;
}","static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;
	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;
	h.raw = frame;
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
		int rt;
		TCGv T00, ttyapp;
		gen_load_gpr(ttyapp, rt);
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	strcpy(str, ""a"");
	}
	smp_wmb();
	return ts_status;
}",0,1,39,0.8,Insert
1634,"static CURLcode read_data(struct connectdata *conn,
                          curl_socket_t fd,
                          struct krb5buffer *buf)
{
  int len;
  CURLcode result;
  int nread;
  result = socket_read(fd, &len, sizeof(len));
  if(result)
    return result;
  if(len) {
    len = ntohl(len);
    if(len > CURL_MAX_INPUT_LENGTH)
      len = 0;
    else
      buf->data = Curl_saferealloc(buf->data, len);
  }
  if(!len || !buf->data)
    return CURLE_OUT_OF_MEMORY;
  result = socket_read(fd, buf->data, len);
  if(result)
    return result;
  nread = conn->mech->decode(conn->app_data, buf->data, len,
                             conn->data_prot, conn);
  if(nread < 0)
    return CURLE_RECV_ERROR;
  buf->size = (size_t)nread;
  buf->index = 0;
  return CURLE_OK;
}","static CURLcode read_data(struct connectdata *conn,
                          curl_socket_t fd,
                          struct krb5buffer *buf)
{
  int len;
  CURLcode result;
  int nread;
  int a = 2;
  int b = 3;
  while (a < b) {
      result = socket_read(fd, &len, sizeof(len));
      b = a;
  }
  if(result)
    return result;
  if(len) {
    len = ntohl(len);
    if(len > CURL_MAX_INPUT_LENGTH)
      len = 0;
    else
      buf->data = Curl_saferealloc(buf->data, len);
  }
  if(!len || !buf->data)
    return CURLE_OUT_OF_MEMORY;
  result = socket_read(fd, buf->data, len);
  if(result)
    return result;
  nread = conn->mech->decode(conn->app_data, buf->data, len,
                             conn->data_prot, conn);
  if(nread < 0)
    return CURLE_RECV_ERROR;
  buf->size = (size_t)nread;
  buf->index = 0;
  return CURLE_OK;
}",0,1,2,0.16,Replace
1635,,,,,,,
1636,"static void yurex_disconnect(struct usb_interface *interface)
{
	struct usb_yurex *dev;
	int minor = interface->minor;
	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);
	usb_deregister_dev(interface, &yurex_class);
	mutex_lock(&dev->io_mutex);
	dev->interface = NULL;
	mutex_unlock(&dev->io_mutex);
	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&dev->waitq);
	kref_put(&dev->kref, yurex_delete);
	dev_info(&interface->dev, ""USB YUREX #%d now disconnected\n"", minor);
}","static void yurex_disconnect(struct usb_interface *interface)
{
	struct usb_yurex *dev;
	int minor = interface->minor;
	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);
	int a = 2;
	int b = 3;
	cairo_pattern_t *pattern;
	cairo_matrix_t matrix;
	pattern = cairo_pattern_create_for_surface (cairo_get_target (cairo));
	cairo_pattern_set_matrix (pattern, &matrix);
	cairo_set_source (cairo, pattern);
	cairo_pattern_set_extend (pattern, CAIRO_EXTEND_REPEAT);
	cairo_pattern_destroy (pattern);
	while (a < b) {
    	usb_deregister_dev(interface, &yurex_class);
    	b = a;
	}
	mutex_lock(&dev->io_mutex);
	dev->interface = NULL;
	mutex_unlock(&dev->io_mutex);
	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&dev->waitq);
	kref_put(&dev->kref, yurex_delete);
	dev_info(&interface->dev, ""USB YUREX #%d now disconnected\n"", minor);
}",1,0,30,0.7,Insert
1640,,,,,,,
1643,"cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };
    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);
    if (mpe == NULL) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}","cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)
{
    static const cmsFloat64Number a1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };
    static const cmsFloat64Number o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };
    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);
    struct ldb_dn *dn;
    dn->ext_comp_num = 0;
    bool bool_var = (mpe == NULL);
    if (bool_var) return mpe;
    mpe ->Implements = cmsSigLab2FloatPCS;
    return mpe;
}",0,1,7,0.27,Insert
1644,,,,,,,
1645,"void ptrace_notify(int exit_code)
{
	siginfo_t info;
	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}","void ptrace_notify(int exit_code)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	siginfo_t info;
	strcpy(str, ""a"");
	}
	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
	memset(&info, 0, sizeof info);
	info.si_signo = SIGTRAP;
	info.si_code = exit_code;
	info.si_pid = task_pid_vnr(current);
	info.si_uid = current_uid();
	spin_lock_irq(&current->sighand->siglock);
	ptrace_stop(exit_code, 1, &info);
	spin_unlock_irq(&current->sighand->siglock);
}",0,1,1,0.07,Replace
1646,"int dsdb_user_obj_set_account_type(struct ldb_context *ldb, struct ldb_message *usr_obj,
				   uint32_t user_account_control, uint32_t *account_type_p)
{
	int ret;
	uint32_t account_type;
	struct ldb_message_element *el;
	account_type = ds_uf2atype(user_account_control);
	if (account_type == 0) {
		ldb_set_errstring(ldb, ""dsdb: Unrecognized account type!"");
		return LDB_ERR_UNWILLING_TO_PERFORM;
	}
	ret = samdb_msg_add_uint(ldb, usr_obj, usr_obj,
				 ""sAMAccountType"",
				 account_type);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	el = ldb_msg_find_element(usr_obj, ""sAMAccountType"");
	el->flags = LDB_FLAG_MOD_REPLACE;
	if (account_type_p) {
		*account_type_p = account_type;
	}
	return LDB_SUCCESS;
}","int dsdb_user_obj_set_account_type(struct ldb_context *ldb, struct ldb_message *usr_obj,
				   uint32_t user_account_control, uint32_t *account_type_p)
{
	int ret;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	uint32_t account_type;
	strcpy(str, ""a"");
	}
	struct ldb_message_element *el;
	account_type = ds_uf2atype(user_account_control);
	if (account_type == 0) {
		ldb_set_errstring(ldb, ""dsdb: Unrecognized account type!"");
		return LDB_ERR_UNWILLING_TO_PERFORM;
		AVFormatContext **output_files;
		int nb_output_files;
		AVFormatContext *is, *os;
		int ret_7, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
		int ret_7, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
		for(i=0;i<nb_output_files;i++) {
		        os = output_files[i];
		        nb_ostreams += os->nb_streams;
		}
	}
	Select *p;
	if( (p->selFlags & SF_FixedLimit)==0 ){
	    p->nSelectRow = 320;
	}
	ret = samdb_msg_add_uint(ldb, usr_obj, usr_obj,
				 ""sAMAccountType"",
				 account_type);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	el = ldb_msg_find_element(usr_obj, ""sAMAccountType"");
	el->flags = LDB_FLAG_MOD_REPLACE;
	if (account_type_p) {
		*account_type_p = account_type;
	}
	return LDB_SUCCESS;
}",1,0,59,0.78,Insert
1647,"static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}","static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		struct iphdr *iph;
		iph->daddr = dst_8;
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}",0,1,1,0.26,Insert
1648,"int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}
	if (!dtls1_is_timer_expired(s))
		{
		return code;
		}
	if ( ! SSL_in_init(s))
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}
#if 0
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		}
	else
#endif
#if 0
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif
	return dtls1_handle_timeout(s);
	}","int dtls1_read_failed(SSL *s, int code)
	{
	AVFormatContext *s_7;
	int ret, type, picsize, desc_len;
	AVStream   *st = NULL;
	ASFStream *asf_st;
	ASFContext *asf       = s_7->priv_data;
	asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));
	asf_st = asf->asf_st[asf->nb_streams];
	st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;
	st->attached_pic.stream_index = asf_st->index = st->index;
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}
	if (!dtls1_is_timer_expired(s))
		{
		return code;
		}
	if ( ! SSL_in_init(s))
		{
		int a = 2;
		int b = 3;
		while (a != b) {
    		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
    		b = a;
		}
		return code;
		}
#if 0
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		}
	else
#endif
#if 0
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
			int center_x = 0, center_y = 0;
			int pos;
			double p_x, p_y;
			center_x /= pos;
			p_x = (center_x - width / 2);
#endif
	return dtls1_handle_timeout(s);
	}",1,0,75,0.93,Insert
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;
		minor ^= low | high;
		low <<= distance;
		high >>= distance;
		minor |= low | high;
	}
#endif
	return minor;
}","static int blk_mangle_minor(int minor)
{
MachineState *machine;
int i_9;
sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
PowerPCCPU *cpu;
for (i_9 = 0; i_9 < smp_cpus; i_9++) {
        cpu = cpu_ppc_init(machine->cpu_model);
        if (cpu == NULL) {
            error_report(""Unable to find PowerPC CPU definition"");
            exit(1);
        }
        spapr_cpu_init(spapr, cpu, &error_fatal);
}
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		int distance = MINORBITS - 1 - 2 * i;
		}
		minor ^= low | high;
		low <<= distance;
		high >>= distance;
		minor |= low | high;
	}
#endif
	return minor;
}",0,1,20,0.53,Insert
1652,"  void fix_from_value(Derivation dv, const Metadata metadata)
  {
    fix_charset_and_length(str_value.charset(), dv, metadata);
  }","  void fix_from_value(Derivation dv, const Metadata metadata)
  {
    unsigned char  unch;
    struct acm_wb *sth;
    sth->buf[sth->len++] =  unch;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        fix_charset_and_length(str_value.charset(), dv, metadata);
    }
  }",0,1,4,0.2,Insert
1653,"static int mount_rootfs_block(const char *rootfs, const char *target,
			                  const char *options)
{
	return mount_unknown_fs(rootfs, target, options);
}","static int mount_rootfs_block(const char *rootfs, const char *target,
			                  const char *options)
{
	int a = 2;
	AVPacket * pk;
	AVFormatContext *s;
	int size               =  pk->size;
	AVIOContext *b_9     = s->b_9;
	if (size & 1)
	        avio_w8(b_9, 0);
	int b = 3;
	while (a < b) {
    	return mount_unknown_fs(rootfs, target, options);
    	b = a;
	}
}",0,1,3,0.27,Insert
1654,"void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  dump_start(s);
  ReplicationConfiguration conf;
  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;
    auto iter = policy->groups.find(enabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
  }
  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}","void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  dump_start(s);
  ReplicationConfiguration conf;
  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;
    auto iter = policy->groups.find(enabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
    iter = policy->groups.find(disabled_group_id);
    UINT16* channel_id;
    UINT16* length;
    STREAM* s_4;
    if (*length > 4)
    		stream_read_UINT16(s_4, *channel_id);
    	else
    		*channel_id = 0;
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
  }
  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      s->formatter->close_section();
  strcpy(str, ""a"");
  }
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}",0,1,27,0.76,Insert
1655,"static void igmp_gq_start_timer(struct in_device *in_dev)
{
	int tv = prandom_u32() % in_dev->mr_maxdelay;
	unsigned long exp = jiffies + tv + 2;
	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;
	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}","static void igmp_gq_start_timer(struct in_device *in_dev)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	int tv = prandom_u32() % in_dev->mr_maxdelay;
	}
	unsigned long exp = jiffies + tv + 2;
	if (in_dev->mr_gq_running &&
	    time_after_eq(exp, (in_dev->mr_gq_timer).expires))
		return;
	in_dev->mr_gq_running = 1;
	if (!mod_timer(&in_dev->mr_gq_timer, exp))
		in_dev_hold(in_dev);
}",0,1,8,0.1,Replace
1656,"static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)
{
	char* path = NULL;
	int status;
	UINT32 PathLength;
	Stream_Seek(irp->input, 28);
	Stream_Read_UINT32(irp->input, PathLength);
	status = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,
	                            &path, 0, NULL, NULL);
	if (status < 1)
		if (!(path = (char*)calloc(1, 1)))
		{
			WLog_ERR(TAG, ""calloc failed!"");
			return CHANNEL_RC_NO_MEMORY;
		}
	parallel->id = irp->devman->id_sequence++;
	parallel->file = open(parallel->path, O_RDWR);
	if (parallel->file < 0)
	{
		irp->IoStatus = STATUS_ACCESS_DENIED;
		parallel->id = 0;
	}
	else
	{
		if (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)
		{
		}
	}
	Stream_Write_UINT32(irp->output, parallel->id);
	Stream_Write_UINT8(irp->output, 0);
	free(path);
	return irp->Complete(irp);
}","static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)
{
	cairo_pattern_t *pattern;
	cairo_matrix_t matrix;
	pattern = cairo_pattern_create_for_surface (cairo_get_target (cairo));
	cairo_pattern_set_matrix (pattern, &matrix);
	cairo_set_source (cairo, pattern);
	cairo_pattern_set_extend (pattern, CAIRO_EXTEND_REPEAT);
	cairo_pattern_destroy (pattern);
	mCore->dump(result, area);
	char* path = NULL;
	int status;
	UINT32 PathLength;
	ax25_cb *ass24;
	int category;
	ass24->state = AX25_STATE_0;
	ax25_link_failed(ass24, category);
	Stream_Seek(irp->input, 28);
	Stream_Read_UINT32(irp->input, PathLength);
	__be32  sport;
	u32 hash[4];
	hash[0] = (__force u32) sport;
	status = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,
	                            &path, 0, NULL, NULL);
	if (status < 1)
		if (!(path = (char*)calloc(1, 1)))
		{
			WLog_ERR(TAG, ""calloc failed!"");
			return CHANNEL_RC_NO_MEMORY;
		}
	int a = 2;
	int b = 2;
	if (a == b) {
    	struct net *net;
    	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
    	struct ctl_table *table;
    	table[NF_SYSCTL_CT_COUNT].data = &net->ct.count;
    	table[NF_SYSCTL_CT_CHECKSUM].data = &net->ct.sysctl_checksum;
    	table[NF_SYSCTL_CT_LOG_INVALID].data = &net->ct.sysctl_log_invalid;
    	table[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;
    	table[NF_SYSCTL_CT_HELPER].data = &net->ct.sysctl_auto_assign_helper;
    	parallel->id = irp->devman->id_sequence++;
	}
	MessageReader output;
	CheckStatusAndParamCount(status_9, output, ""enc_untrusted_inet_pton"", 3);
	parallel->file = open(parallel->path, O_RDWR);
	struct strbuf base;
	strbuf_init(&base, PATH_MAX);
	strbuf_release(&base);
	struct inode *inode;
	struct file *file;
	int min;
	min = nonseekable_open(inode, file);
	if (parallel->file < 0)
	{
		irp->IoStatus = STATUS_ACCESS_DENIED;
		parallel->id = 0;
	}
	OcspResponse* resp;
	byte* source;
	word32 size;
	int    ret;
	int    sigLength;
	ret = CheckBitString(source, &idx, &sigLength, size, 1, NULL);
	resp->sigSz = sigLength;
	idx += sigLength;
	else
	{
		if (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)
		{
		}
	}
	Stream_Write_UINT32(irp->output, parallel->id);
	Stream_Write_UINT8(irp->output, 0);
	free(path);
	return irp->Complete(irp);
}",1,0,551,3.24,Insert
1660,,,,,,,
1661,"bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)
{
	if (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;
	asn1_write_uint8(data, v);
	asn1_pop_tag(data);
	return !data->has_error;
}","bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)
{
	BlockdevOptions *options;
	Error *local_err = NULL;
	QDict *qdict;
	QmpOutputVisitor *ov = qmp_output_visitor_new();
	visit_type_BlockdevOptions(qmp_output_get_visitor(ov),
	                               &options, NULL, &local_err);
	blockdev_init(NULL, qdict, &local_err);
	bool bool_var = (!asn1_push_tag(data, ASN1_ENUMERATED));
	if (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;
	asn1_write_uint8(data, v);
	asn1_pop_tag(data);
	AVFormatContext *cs;
	AVPacket * punt;
	int size =  punt->size, def = 0;
	MOVTrack *brok = &mov->tracks[ punt->stream_index];
	MOVMuxContext *mov = cs->priv_data;
	def = check_pkt(cs,  punt);
	return !data->has_error;
}",1,0,49,0.48,Insert
1662,,,,,,,
1663,"void sdtp_box_del(GF_Box *s)
{
	GF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;
	if (ptr == NULL) return;
	if (ptr->sample_info) gf_free(ptr->sample_info);
	gf_free(ptr);
}","void sdtp_box_del(GF_Box *s)
{
	APEContext *ctx;
	int32_t predictionA, currentA, A, sign;
	APEPredictor *pb = &ctx->predictor;
	currentA = pb->lastA[0];
	pb->lastA[0] = currentA;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	GF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;
	}
	if (ptr == NULL) return;
	if (ptr->sample_info) gf_free(ptr->sample_info);
	gf_free(ptr);
}",0,1,8,0.27,Insert
1666,,,,,,,
1667,"void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}","void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    int a = 60;
    int b = a;
    if(a*b>0){
        assert(pkt);
        AVPacket * pk;
        AVFormatContext *s;
        int size               =  pk->size;
        AVIOContext *b_2     = s->b_2;
        if (size & 1)
                avio_w8(b_2, 0);
    }
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}",0,1,4,0.32,Insert
1670,"      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        const unsigned int
          k = (unsigned int)mp.opcode[3],
          l = (unsigned int)mp.opcode[4];
        const bool use_LU = (bool)_mp_arg(5);
        CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);
        return cimg::type<double>::nan();
      }","      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        AvahiLookupFlags *flags;
        AvahiLookupFlags *flags_1;
        const char *domain_10;
        AvahiServer *s_7;
        if (!s_7->wide_area_lookup_engine ||
                !avahi_wide_area_has_servers_6(s_7->wide_area_lookup_engine) ||
                avahi_domain_ends_with_6(domain_10, AVAHI_MDNS_SUFFIX_LOCAL_4) ||
                avahi_domain_ends_with_6(domain_10, AVAHI_MDNS_SUFFIX_ADDR_IPV4_1) ||
                avahi_domain_ends_with_6(domain_10, AVAHI_MDNS_SUFFIX_ADDR_IPV6_7))
                *flags_1 |= AVAHI_LOOKUP_USE_MULTICAST_5;
            else
                *flags_1 |= AVAHI_LOOKUP_USE_WIDE_AREA_8;
        const char *domain;
        AvahiServer *s;
        if (!s->wide_area_lookup_engine ||
                !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
                avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
                avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
                avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
                *flags |= AVAHI_LOOKUP_USE_MULTICAST;
            else
                *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        unsigned maxpages;
        size_t *start;
        struct iov_iter *i;
        unsigned int iter_head, npages;
        unsigned int iter_head, npages;
        size_t capacity;
        npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
        capacity = min(npages, maxpages) * PAGE_SIZE - *start;
        const unsigned int
          k = (unsigned int)mp.opcode[3],
          l = (unsigned int)mp.opcode[4];
        const bool use_LU = (bool)_mp_arg(5);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);
        }
        return cimg::type<double>::nan();
      }",0,1,99,0.78,Insert
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
	spin_lock_irq(&css_set_lock);
	it->ss = css->ss;
	it->flags = flags;
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;
	it->cset_head = it->cset_pos;
	css_task_iter_advance(it);
	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
	int a = 2;
	int b = 2;
	while (a == b) {
    	spin_lock_irq(&css_set_lock);
    	b += 1;
	}
	it->ss = css->ss;
	it->flags = flags;
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;
		MachineState *machine;
		char *filename;
		MemoryRegion *ram = g_new(MemoryRegion, 1);
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		spapr->icp = xics_system_init(machine,
		                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
		                                               smp_threads),
		                                  XICS_IRQS, &error_fatal);
		memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
		                                         machine->ram_size);
		filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
		spapr->rtas_size = get_image_size(filename);
		spapr->rtas_blob = g_malloc(spapr->rtas_size);
	it->cset_head = it->cset_pos;
	css_task_iter_advance(it);
	spin_unlock_irq(&css_set_lock);
}",0,1,15,0.5,Insert
1672,"static void hardware_disable(void)
{
	vmclear_local_loaded_vmcss();
	if (cpu_vmxoff())
		kvm_spurious_fault();
	intel_pt_handle_vmx(0);
}","static void hardware_disable(void)
{
	int a = 86;
	int b = a;
	if(a*b>0){
    	vmclear_local_loaded_vmcss();
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	if (cpu_vmxoff())
		kvm_spurious_fault();
	intel_pt_handle_vmx(0);
}",0,1,7,0.21,Insert
1673,"static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			struct prefix_info *pinfo, u32 pid, u32 seq,
			int event, unsigned int flags)
{
	struct prefixmsg	*pmsg;
	struct nlmsghdr 	*nlh;
	unsigned char		*b = skb->tail;
	struct prefix_cacheinfo	ci;
	nlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);
	pmsg = NLMSG_DATA(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;
	RTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);
	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);
	nlh->nlmsg_len = skb->tail - b;
	return skb->len;
nlmsg_failure:
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			struct prefix_info *pinfo, u32 pid, u32 seq,
			int event, unsigned int flags)
{
	struct prefixmsg	*pmsg;
	ObjectClass *oc;
	PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
	pcc->bfd_mach = bfd_mach_ppc64;
	pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |
	                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |
	                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |
	                 POWERPC_FLAG_VSX;
	pcc->l1_dcache_size = 0x8000;
	pcc->l1_icache_size = 0x8000;
	struct nlmsghdr 	*nlh;
	unsigned char		*b = skb->tail;
	struct prefix_cacheinfo	ci;
	nlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);
	pmsg = NLMSG_DATA(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
		unsigned copied;
		loff_t pos;
		struct address_space *bmappings;
		unsigned len;
		struct insnode *insnode = bmappings->host;
		trace_ext4_write_end(insnode, pos, len, copied);
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;
	RTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);
	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);
	int a_1 = 2;
	int b_1 = 2;
	if (a_1 == b_1) {
    	nlh->nlmsg_len = skb->tail - b;
	}
	return skb->len;
nlmsg_failure:
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}",1,0,69,0.97,Insert
1676,,,,,,,
1677,"void Item_equal::sort(Item_field_cmpfunc compare, void *arg)
{
  bubble_sort<Item>(&equal_items, compare, arg);
}","void Item_equal::sort(Item_field_cmpfunc compare, void *arg)
{
  char str[] = ""Constant"";
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
  aml_append(ifconfig,
          aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
  aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
  aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
  while (strlen(str) > 5) {
      bubble_sort<Item>(&equal_items, compare, arg);
  strcpy(str, ""a"");
  }
}",0,1,4,0.26,Insert
1678,"static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;
	priv = netdev_priv(dev);
	data[0] = priv->peer->ifindex;
}","static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;
	priv = netdev_priv(dev);
	int a = 31;
	int b = a;
	ChardevCommon *complex = backend->u.null;
	CharDriverState *charrb;
	charrb = qemu_chr_alloc(complex, erfp);
	charrb->chr_write = null_chr_write;
	charrb->explicit_be_open = true;
	if(a*b>0){
    	data[0] = priv->peer->ifindex;
	}
}",0,1,7,0.3,Insert
1680,"  Supports_Condition_Obj Parser::parse_supports_declaration()
  {
    Supports_Condition_Ptr cond;
    Expression_Obj feature = parse_expression();
    Expression_Obj expression;
    if (lex_css< exactly<':'> >()) {
      expression = parse_list(DELAYED);
    }
    if (!feature || !expression) error(""@supports condition expected declaration"");
    cond = SASS_MEMORY_NEW(Supports_Declaration,
                     feature->pstate(),
                     feature,
                     expression);
    return cond;
  }","  Supports_Condition_Obj Parser::parse_supports_declaration()
  {
    Supports_Condition_Ptr cond;
    Expression_Obj feature = parse_expression();
    int a = 91;
    int b = a;
    if(a*b>0){
        Expression_Obj expression;
    }
    if (lex_css< exactly<':'> >()) {
      expression = parse_list(DELAYED);
    }
    if (!feature || !expression) error(""@supports condition expected declaration"");
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    cond = SASS_MEMORY_NEW(Supports_Declaration,
                     feature->pstate(),
                     feature,
                     expression);
    return cond;
  }",0,1,13,0.45,Insert
1681,,,,,,,
1683,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = fdentry(file)->d_inode;
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	 struct inode *inode;
	}
	 int ret;
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = fdentry(file)->d_inode;
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}",0,1,4,0.13,Replace
1689,,,,,,,
1691,,,,,,,
1693,,,,,,,
1694,"cmsBool  WriteMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsStage* mpe)
{
    _cmsStageMatrixData* m = (_cmsStageMatrixData*) mpe -> Data;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[0])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[1])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[2])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[3])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[4])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[5])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[6])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[7])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[8])) return FALSE;
    if (m ->Offset != NULL) {
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[0])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[1])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[2])) return FALSE;
    }
    else {
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
    }
    return TRUE;
    cmsUNUSED_PARAMETER(self);
}","cmsBool  WriteMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsStage* mpe)
{
    _cmsStageMatrixData* m = (_cmsStageMatrixData*) mpe -> Data;
    bool bool_var = (!_cmsWrite15Fixed16Number(io, m -> Double[0]));
    if (!_cmsWrite15Fixed16Number(io, m -> Double[0])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[1])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[2])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[3])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[4])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[5])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[6])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[7])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Double[8])) return FALSE;
    if (m ->Offset != NULL) {
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[0])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[1])) return FALSE;
    if (!_cmsWrite15Fixed16Number(io, m -> Offset[2])) return FALSE;
    }
    else {
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;
    }
    return TRUE;
    cmsUNUSED_PARAMETER(self);
}",0,1,1,0.13,Replace
1695,"static void vnc_tight_stop(VncState *vs)
{
    vs->tight.tight = vs->output;
    vs->output = vs->tight.tmp;
}","static void vnc_tight_stop(VncState *vs)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        GetBitContext *gb;
        AVCodecContext *avctx;
        VC1Context *v;
        av_log(avctx, AV_LOG_DEBUG, ""Header: %0X
        "", show_bits(gb, 32));
        v->profile = get_bits(gb, 2);
        v->frmrtq_postproc = get_bits(gb, 3);
        v->bitrtq_postproc = get_bits(gb, 5);
        v->s.loop_filter = get_bits1(gb);
        vs->tight.tight = vs->output;
        b += 1;
    }
    vs->output = vs->tight.tmp;
}",1,0,5,0.26,Insert
1697,"bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
}","bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	bool lock;
	struct request_list *repl;
	struct request_queue *q = repl->q;
	repl->cache[lock]--;
	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
}",0,1,4,0.14,Insert
1698,"static int esp_select(ESPState *s)
{
    int target;
    target = s->wregs[ESP_WBUSID] & BUSID_DID;
    s->ti_size = 0;
    fifo8_reset(&s->fifo);
    if (s->current_req) {
        scsi_req_cancel(s->current_req);
        s->async_len = 0;
    }
    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);
    if (!s->current_dev) {
        s->rregs[ESP_RSTAT] = 0;
        s->rregs[ESP_RINTR] |= INTR_DC;
        s->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(s);
        return -1;
    }
    s->rregs[ESP_RINTR] |= INTR_FC;
    s->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}","static int esp_select(ESPState *s)
{
    int target;
    target = s->wregs[ESP_WBUSID] & BUSID_DID;
    s->ti_size = 0;
    fifo8_reset(&s->fifo);
    if (s->current_req) {
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        t0  =  (s3 * 19266 + s5 * 12873) >> 15;
        t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;
        t4  = t0 * 2 + t2;
        scsi_req_cancel(s->current_req);
        AVCodecContext *avctx;
        const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);
        VC2EncContext *s_8 = avctx->priv_data;
        if (s_8->interlaced)
                av_log(avctx, AV_LOG_WARNING, ""Interlacing enabled!
        "");
        s->async_len = 0;
    }
    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);
    if (!s->current_dev) {
        s->rregs[ESP_RSTAT] = 0;
        s->rregs[ESP_RINTR] |= INTR_DC;
        s->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(s);
        return -1;
    }
    s->rregs[ESP_RINTR] |= INTR_FC;
    s->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}",1,0,76,0.73,Insert
1700,"static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}","static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    int a = 2;
    int b = 3;
    while (a < b) {
        FontView *fv = (FontView *) GDrawGetUserData(gw);
        b = a;
    }
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
	                        hawdecl->nvram_size, 8);
	slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
	                          sbi_cpu_arq, smp_cpus);
	slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
	                              nographic, ESCC_CLOCK, 1);
    }
    GDrawRequestExpose(fv->v,NULL,false);
}",0,1,28,0.96,Insert
1703,"static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;
	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);","static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	int a = 2;
	int b = 3;
	void **args;
	struct route4_filter *fold, *v1, *id, *f = NULL;
	ffold= *args;
	*args = f;
	if (a != b) {
    	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	}
	int idx;
	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);",1,0,10,0.34,Insert
1705,"static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;
	if (!is_sampling_event(event))
		return;
	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;
		event->attr.sample_period = NSEC_PER_SEC / freq;
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}","static void perf_swevent_init_hrtimer(struct perf_event *event)
{
	struct hw_perf_event *hwc = &event->hw;
	if (!is_sampling_event(event))
		return;
	hrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	hwc->hrtimer.function = perf_swevent_hrtimer;
	if (event->attr.freq) {
		long freq = event->attr.sample_freq;
		int a = 2;
		int b = 3;
		while (a < b) {
    		event->attr.sample_period = NSEC_PER_SEC / freq;
    		b = a;
		}
		hwc->sample_period = event->attr.sample_period;
		local64_set(&hwc->period_left, hwc->sample_period);
		hwc->last_period = hwc->sample_period;
		event->attr.freq = 0;
	}
}",0,1,2,0.09,Replace
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  struct task_struct *contract;
  unsigned long flags;
  int retval;
  audit_ptrace(contract);
  task_lock(contract);
  retval = __ptrace_may_access(contract, PTRACE_MODE_ATTACH_REALCREDS);
  task_unlock(contract);
  const BYTE* bmpdata;
  NSC_CONTEXT* context;
  UINT32 rowbride;
  nsc_encode_argb_to_aycocg(context, bmpdata, rowbride);
  contract->ptrace = flags;
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}",1,0,39,0.56,Insert
1708,,,,,,,
1713,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;
	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			ptirq_deactivate_entry(entry);
		}
		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);
		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);
		ptirq_release_entry(entry);
	}
}","remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct ptirq_remapping_info *entry;
	}
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;
	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		hwaddr array;
		PowerPCCPU *cpu;
		uint64_t request;
		target_ulong pte_index;
		CPUPPCState *viron = &cpu->viron;
		CPUPPCState *viron = &cpu->viron;
		pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
		request = ppc_hash64_start_access(cpu, pte_index);
		if (is_entry_active(entry)) {
			ptirq_deactivate_entry(entry);
		}
		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);
		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);
		ptirq_release_entry(entry);
	}
}",0,1,22,0.59,Insert
1714,"static inline void invlpga(unsigned long addr, u32 asid)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}","static inline void invlpga(unsigned long addr, u32 asid)
{
	struct nbd_request Request;
	uint32_t response;
	response = Request.type & NBD_CMD_MASK_COMMAND;
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}",0,1,1,0.11,Insert
1715,,,,,,,
1716,,,,,,,
1717,"int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;
	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;
	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}","int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;
	AVFormatContext *s;
	AVIOContext *pb = s->pb;
	int i;
	AVIOContext *pb = s->pb;
	for (i = 0; i < s->nb_streams; i++) {
	        AVCodecContext *enc = s->streams[i]->codec;
	        FLVStreamContext *sc = s->streams[i]->priv_data;
	        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&
	            enc->codec_id == AV_CODEC_ID_H264)
	            put_avc_eos_tag(pb, sc->last_ts);
	}
	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;
	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}",1,0,16,0.35,Insert
1718,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;
	if (!intern) {
		return;
	}
	netsnmp_session_free(&(intern->session));
	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	efree(intern);
}","static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;
	struct sem_undo_list *utm_1;
	struct sem_undo *relation_3, *news_1;
	struct sem_undo *relation_3, *news_1;
	relation_3 = lookup_undo_7(utm_1, second_9);
	news_1->utm_1 = utm_1;
	assert_spin_locked_3(&utm_1->lock);
	list_add_rcu_3(&news_1->list_proc, &utm_1->list_proc);
	if (!intern) {
		struct socket *pocket;
		struct kiircbe *kiircbe;
		struct msghdr *mail;
		int lf;
		int noblock = lf&MSG_DONTWAIT;
		struct scm_cookie ncbm;
		struct sk_buff *skibb, *data_knbang;
		int status, status;
		struct pocket *work = pocket->work;
		struct pocket *work = pocket->work;
		struct sock_iocb *niecmb = kiocb_to_siocb(kiircbe);
		skibb = skb_recv_datagram(work, lf, noblock, &status);
		scm_recv(pocket, mail, niecmb->ncbm, lf);
		return;
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	Parse *pParse;
    	int in2;
    	int opcode;
    	int in1;
    	int dest;
    	CollSeq *p4;
    	int addr;
    	addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
    	                           (void*)p4, P4_COLLSEQ);
    	netsnmp_session_free(&(intern->session));
    	struct sem_undo_list *utm;
    	struct sem_undo *relation, *news;
    	struct sem_undo *relation, *news;
    	relation = lookup_undo(utm, second);
    	news->utm = utm;
    	assert_spin_locked(&utm->lock);
    	list_add_rcu(&news->list_proc, &utm->list_proc);
    	b = a;
    	TextCompositionType composition;
    	const bool isIncrementalInsertion;
    	const String& text_2;
    	Document& document_4;
    	Options options;
    	LocalFrame* frame_6 = document_4.frame_6();
    	LocalFrame* frame_6 = document_4.frame_6();
    	DCHECK(frame_6);
    	insertText(document_4, text_2,
    	             frame_6->selection().computeVisibleSelectionInDOMTreeDeprecated(),
    	             options, composition, isIncrementalInsertion);
	}
	struct dhcp_packet *packet;
	const String& text;
	Document& document;
	LocalFrame* frame = document.frame();
	LocalFrame* frame = document.frame();
	if (!text.isEmpty())
	     document.frame()->spellChecker().updateMarkersForWordsAffectedByEditing(
	         isSpaceOrNewline(text[0]));
	uint32_t lease_seconds;
	uint8_t *option;
	option = dhcp_get_option(packet, DHCP_LEASE_TIME);
	lease_seconds = get_be32(option);
	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	efree(intern);
}",1,0,827,4.17,Insert
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;
	sess = find_dialog (serv, nick);
	if (sess)
		return sess;
	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}
	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	GSList *list = sess_list;
	strcpy(str, ""a"");
	}
	sess = find_dialog (serv, nick);
	if (sess)
		return sess;
	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}
	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",0,1,1,0.14,Replace
1720,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;
	if (sk == NULL) return 0;
	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);
	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;
	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;
	default:
		break;
	}
	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);
	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;
	if (sk == NULL) return 0;
	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);
	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;
	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		int a = 81;
		int b = a;
		if(a*b>0){
    		nr_start_t1timer(sk);
		}
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;
	default:
		break;
	}
	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);
	return 0;
}",0,1,13,0.25,Replace
1722,"static int mb86a20s_get_segment_count(struct mb86a20s_state *state,
				      unsigned layer)
{
	int rc, count;
	static unsigned char reg[] = {
		[0] = 0x89,
		[1] = 0x8d,
		[2] = 0x91,
	};
	dev_dbg(&state->i2c->dev, ""%s called.\n"", __func__);
	if (layer >= ARRAY_SIZE(reg))
		return -EINVAL;
	rc = mb86a20s_writereg(state, 0x6d, reg[layer]);
	if (rc < 0)
		return rc;
	rc = mb86a20s_readreg(state, 0x6e);
	if (rc < 0)
		return rc;
	count = (rc >> 4) & 0x0f;
	dev_dbg(&state->i2c->dev, ""%s: segments: %d.\n"", __func__, count);
	return count;
}","static int mb86a20s_get_segment_count(struct mb86a20s_state *state,
				      unsigned layer)
{
	int rc, count;
	static unsigned char reg[] = {
		[0] = 0x89,
		[1] = 0x8d,
		[2] = 0x91,
	};
	dev_dbg(&state->i2c->dev, ""%s called.\n"", __func__);
	if (layer >= ARRAY_SIZE(reg))
		return -EINVAL;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	rc = mb86a20s_writereg(state, 0x6d, reg[layer]);
	}
	if (rc < 0)
		return rc;
	rc = mb86a20s_readreg(state, 0x6e);
	if (rc < 0)
		return rc;
	count = (rc >> 4) & 0x0f;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
	aml_append(ifconfig, aml_store(aml_name(""CDW2""), aml_name(""SUPP"")));
	aml_append(ifconfig, aml_store(aml_name(""CDW3""), aml_name(""CTRL"")));
	dev_dbg(&state->i2c->dev, ""%s: segments: %d.\n"", __func__, count);
	return count;
}",0,1,17,0.72,Insert
1724,"static void fetch_result_int32(MYSQL_BIND *param,
                               MYSQL_FIELD *field __attribute__((unused)),
                               uchar **row)
{
  my_bool field_is_unsigned= test(field->flags & UNSIGNED_FLAG);
  uint32 data= (uint32) sint4korr(*row);
  longstore(param->buffer, data);
  *param->error= param->is_unsigned != field_is_unsigned && data > INT_MAX32;
  *row+= 4;
}","static void fetch_result_int32(MYSQL_BIND *param,
                               MYSQL_FIELD *field __attribute__((unused)),
                               uchar **row)
{
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  double
      value;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  content=GetXMLTreeContent(description);
  content=GetXMLTreeContent(levels);
  value=InterpretLocaleValue(content,&p);
  my_bool field_is_unsigned= test(field->flags & UNSIGNED_FLAG);
  uint32 data= (uint32) sint4korr(*row);
  longstore(param->buffer, data);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      *param->error= param->is_unsigned != field_is_unsigned && data > INT_MAX32;
  }
  *row+= 4;
}",0,1,14,0.48,Insert
1727,"xmlXPathNodeSetCreateSize(int size) {
    xmlNodeSetPtr ret;
    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
    if (ret == NULL) {
        xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
    if (size < XML_NODESET_DEFAULT)
	size = XML_NODESET_DEFAULT;
    ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));
    if (ret->nodeTab == NULL) {
	xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	xmlFree(ret);
	return(NULL);
    }
    memset(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));
    ret->nodeMax = size;
    return(ret);
}","xmlXPathNodeSetCreateSize(int size) {
    xmlNodeSetPtr ret;
    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
    if (ret == NULL) {
        int a = 2;
        int b = 3;
        while (a != b) {
            xmlXPathErrMemory(NULL, ""creating nodeset\n"");
            b = a;
        }
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
    if (size < XML_NODESET_DEFAULT)
	size = XML_NODESET_DEFAULT;
    ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));
    if (ret->nodeTab == NULL) {
	xmlXPathErrMemory(NULL, ""creating nodeset\n"");
	xmlFree(ret);
	return(NULL);
    }
    memset(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));
    ret->nodeMax = size;
    return(ret);
}",0,1,1,0.09,Replace
1729,,,,,,,
1730,"do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10;
#ifdef HAVE_LONG_TIME_T
  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int r;
  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);
  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;
  assert(r);
  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}","do_time_checks(void)
{
  struct timeval now;
  time_t warning_advance = 3600 * 24 * 365 * 10;
#ifdef HAVE_LONG_TIME_T
  struct timeval tv1 = {NTP_ERA_SPLIT, 1}, tv2 = {NTP_ERA_SPLIT - 1, 1};
  NTP_int64 ntv1, ntv2;
  int a = 2;
  int b = 3;
  if (a != b) {
      int r;
  }
  UTI_TimevalToInt64(&tv1, &ntv1, 0);
  int port, is_output, ttl, remote_host;
  char val[1024];
  int port, is_output, ttl, remote_host;
  int port, is_output, ttl, remote_host;
  char hostname[256];
  build_udp_url(val, sizeof(val),
                    hostname, port, remote_host, ttl);
  build_udp_url(val, sizeof(val),
                    hostname, port + 1, remote_host + 1, ttl);
  UTI_TimevalToInt64(&tv2, &ntv2, 0);
  UTI_Int64ToTimeval(&ntv1, &tv1);
  UTI_Int64ToTimeval(&ntv2, &tv2);
  r = tv1.tv_sec == NTP_ERA_SPLIT &&
      tv1.tv_sec + (1ULL << 32) - 1 == tv2.tv_sec;
  assert(r);
  LCL_ReadRawTime(&now);
  if (tv2.tv_sec - now.tv_sec < warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""Assumed NTP time ends at %s!"",
        UTI_TimeToLogForm(tv2.tv_sec));
#else
  LCL_ReadRawTime(&now);
  if (now.tv_sec > 0x7fffffff - warning_advance)
    LOG(LOGS_WARN, LOGF_NtpCore, ""System time ends at %s!"",
        UTI_TimeToLogForm(0x7fffffff));
#endif
}",0,1,34,0.75,Insert
1732,"static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);
	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}","static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);
	int a = 26;
	int b = a;
	if(a*b>0){
    	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
	}
}",0,1,2,0.04,Replace
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);
	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	unsigned int head = READ_ONCE(pipe->head);
    	MachineState *machine;
    	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    	cpu_ppc_hypercall = emulate_spapr_hypercall;
    	spapr->icp = xics_system_init(machine,
    	                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
    	                                               smp_threads),
    	                                  XICS_IRQS, &error_fatal);
	}
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);
	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}",0,1,7,0.33,Insert
1734,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE;
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE;
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		bytes -= n;
		strcpy(str, ""a"");
		}
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}",0,1,2,0.11,Replace
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        weak_context_.SetWeak();
    }
    struct nfs4_opendata *http;
    struct nfs_server *sche = NFS_SERVER(rel);
    http->o_arg.open_flags = hours,
     	http->o_arg.clientid = sche->nfs_client->cl_clientid;
    http->o_arg.sche = sche;
    http->o_arg.bitmask = sche->attr_bitmask;
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",1,0,22,0.43,Insert
1737,,,,,,,
1738,"int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC)
{
	int hash_len, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	return ret;
}  ","int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC)
{
	int hash_len, ret = FAILURE;
	int a = 86;
	int b = a;
	if(a*b>0){
    	void *data;
    	uint16_t *type, *ui, *ver;
    	AVFrame *mac = data;
    	AVFrame *mac = data;
    	mac->pict_type = AV_PICTURE_TYPE_I;
    	type = (uint16_t *)mac->data[0];
    	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	}
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	AVDictionary **metadata = avpriv_frame_get_metadatap(main);
	double comp_mse[4], mse = 0;
	PSNRContext *s = ctx->priv;
	int j, c;
	int j, c;
	for (j = 0; j < s->nb_components; j++) {
	        c = s->is_rgb ? s->rgba_map[j] : j;
	        set_meta(metadata, ""lavfi.psnr.mse."", s->comps[j], comp_mse[c]);
	        set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));
	}
	return ret;
}  ",1,0,75,0.79,Insert
1742,"Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,
        SDL_PixelFormat * dst)
{
    Uint8 *map;
    int i;
    int bpp;
    SDL_Palette *pal = src->palette;
    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);
    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);
    if (map == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }
    for (i = 0; i < pal->ncolors; ++i) {
        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);
        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);
        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);
        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);
        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);
    }
    return (map);
}","Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,
        SDL_PixelFormat * dst)
{
    ObjectClass * klasses;
    DeviceClass *tc = DEVICE_CLASS( klasses);
    set_bit(DEVICE_CATEGORY_MISC, tc->categories);
    tc->props = spapr_nvram_properties;
    tc->vmsd = &vmstate_spapr_nvram;
    Uint8 *map;
    unsigned from;
    struct page *page;
    unsigned to;
    struct inode *inode = page->mapping->host;
    struct buffer_head *bh;
    zero_user(page, from, to-from);
    mark_page_accessed(page);
    bh = page_buffers(page);
    bh = page_buffers(page);
    int i;
    int bpp;
    SDL_Palette *pal = src->palette;
    int a = 2;
    int b = 2;
    while (a == b) {
        bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);
        enum intel_engine_id bid;
        struct intel_engine_cs *engine;
        const struct engine_info *ami = &intel_engines[bid];
        engine->class = ami->class;
        engine->instance = ami->instance;
        __sprint_engine_name(engine);
        engine->props.heartbeat_interval_ms =
        		CONFIG_DRM_I915_HEARTBEAT_INTERVAL;
        engine->props.max_busywait_duration_ns =
        		CONFIG_DRM_I915_MAX_REQUEST_BUSYWAIT;
        b += 1;
    }
    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);
    if (map == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }
    for (i = 0; i < pal->ncolors; ++i) {
        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);
        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);
        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);
        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);
        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);
    }
    return (map);
}",1,0,140,1.58,Insert
1744,"RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}","RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	free(fcnstr_copy);
	strcpy(str, ""a"");
	}
	free(fcnstr);
	return res;
}",0,1,19,0.2,Replace
1745,,,,,,,
1748,"istr_set_get_as_list (GHashTable *table)
{
	GList *list;
	list = NULL;
	g_hash_table_foreach (table, add_istr_to_list, &list);
	return list;
}","istr_set_get_as_list (GHashTable *table)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	GList *list;
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	uint32_t input;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpDecoderCreate *create;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	void *pack;
    	VdpBool supported;
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    	                                     &pack);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
    	                                     &pack);
    	status = create(hdtx->device, profile, width, input, AVcas->refs,
    	                    &hdtx->decoder);
	}
	list = NULL;
	g_hash_table_foreach (table, add_istr_to_list, &list);
	return list;
}",0,1,10,0.32,Insert
1750,"void *umm_realloc( void *ptr, size_t size ) {
  void *ret;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }
  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );
  ret = GET_POISONED(ret, size);
  umm_account_free_blocks_cnt();
  return ret;
}","void *umm_realloc( void *ptr, size_t size ) {
  void *ret;
  ptr = GET_UNPOISONED(ptr);
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }
  if (!INTEGRITY_CHECK()) {
    int a = 2;
    int b = 2;
    while (a == b) {
        return NULL;
        b += 1;
    }
  }
  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );
  ret = GET_POISONED(ret, size);
  umm_account_free_blocks_cnt();
  return ret;
}",1,0,11,0.11,Replace
1751,,,,,,,
1752,"static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;
	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;
	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;
	return size;
}","static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
    	b += 1;
	}
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;
	ThrottleState *ts;
	double units = 1.0;
	ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;
	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;
	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;
	return size;
}",1,0,17,0.64,Insert
1753,"dp_packet_hwol_set_csum_sctp(struct dp_packet *b)
{
    *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;
}","dp_packet_hwol_set_csum_sctp(struct dp_packet *b)
{
    struct sk_buff *skb;
    struct sock *sk;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    "",
    		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    length = TCP_SKB_CB(skb)->length;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;
    strcpy(str, ""a"");
    }
}",0,1,6,0.2,Insert
1755,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds time) {
  ASSERT(codec_client_ != nullptr);
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index, time);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds time) {
  ASSERT(codec_client_ != nullptr);
  int a = 2;
  int b = 3;
  while (a < b) {
      IntegrationStreamDecoderPtr response;
      b = a;
  }
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
  table->slot=(char *) NULL;
  table->description=(char *) NULL;
  table->levels=(unsigned int *) NULL;
  attribute=GetXMLTreeAttribute(table_iterator,""slot"");
  waitForNextUpstreamRequest(upstream_index, time);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}",0,1,21,0.69,Insert
1757,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	char str[] = ""Constant"";
	struct buffer_head *nb_7;
	struct super_block *sb_6;
	ext4_group_t block_group_1;
	struct ext4_group_desc *gdp_4;
	ext4_fsblk_t start_3, tmp_3;
	struct ext4_sb_info *sbi_7 = EXT4_SB_9(sb_6);
	ext4_fsblk_t start_3, tmp_3;
	unsigned int bit_7, bit_max_4;
	memset_3(nb_7->b_data, 0, sb_6->s_blocksize);
	bit_max_4 = ext4_num_base_meta_clusters_9(sb_6, block_group_1);
	start_3 = ext4_group_first_block_no_3(sb_6, block_group_1);
	tmp_3 = ext4_block_bitmap_9(sb_6, gdp_4);
	tmp_3 = ext4_inode_bitmap_3(sb_6, gdp_4);
	while (strlen(str) > 5) {
    	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	strcpy(str, ""a"");
	}
	if (out == NULL) {
		return NULL;
	}
	struct buffer_head *nb;
	struct super_block *sb;
	struct kvm_userspace_memory_region *mat;
	unsigned long nbflows;
	if (!nbflows)
			mat->flags &= ~KVM_MEM_LOG_DIRTY_PAGES;
	ext4_group_t block_group;
	struct ext4_group_desc *gdp;
	ext4_fsblk_t start, tmp;
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	ext4_fsblk_t start, tmp;
	unsigned int bit, bit_max;
	memset(nb->b_data, 0, sb->s_blocksize);
	bit_max = ext4_num_base_meta_clusters(sb, block_group);
	start = ext4_group_first_block_no(sb, block_group);
	tmp = ext4_block_bitmap(sb, gdp);
	tmp = ext4_inode_bitmap(sb, gdp);
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	AVFormatContext *ctx;
	MpegMuxContext *s = ctx->priv_data;
	int bitrate, i, mpa_id, mpv_id, ac3_id;
	AVStream *st;
	int bitrate, i, mpa_id, mpv_id, ac3_id;
	for(i=0;i<ctx->nb_streams;i++) {
	        st = ctx->streams[i];
	        bitrate += st->codec.bit_rate;
	}
	return rv;
}",1,0,130,1.12,Insert
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int a = 2;
  int b = 3;
  while (a != b) {
      int r;
      b = a;
  }
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",0,1,1,0.08,Replace
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  gint index=callbacks_get_selected_row_index();
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""),
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  gint index=callbacks_get_selected_row_index();
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""),
				  NULL,
				  FALSE,
				  NULL);
      int a = 2;
      int b = 3;
      if (a != b) {
          mainProject->file[index]->layer_dirty = FALSE;
      }
      callbacks_update_layer_tree();
      return;
    }
    PutBitContext pb, pb2;
    JLSState *state;
    int i, size, ure;
    PutBitContext pb, pb2;
    ls_store_lse(state, &pb);
    put_bits(&pb2, 7, 0);
    size = put_bits_count(&pb2);
    flush_put_bits(&pb2);
    avpriv_align_put_bits(&pb);
  }
  callbacks_update_layer_tree();
  return;
}",0,1,14,0.36,Insert
1762,,,,,,,
1763,,,,,,,
1764,"static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  Image
    *group4_image;
  ImageInfo
    *write_info;
  MagickBooleanType
    status;
  size_t
    length;
  unsigned char
    *group4;
  status=MagickTrue;
  write_info=CloneImageInfo(image_info);
  (void) CopyMagickString(write_info->filename,""GROUP4:"",MagickPathExtent);
  (void) CopyMagickString(write_info->magick,""GROUP4"",MagickPathExtent);
  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);
  if (group4_image == (Image *) NULL)
    return(MagickFalse);
  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,
    exception);
  group4_image=DestroyImage(group4_image);
  if (group4 == (unsigned char *) NULL)
    return(MagickFalse);
  write_info=DestroyImageInfo(write_info);
  if (WriteBlob(image,length,group4) != (ssize_t) length)
    status=MagickFalse;
  group4=(unsigned char *) RelinquishMagickMemory(group4);
  return(status);
}","static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  Image
    *group4_image;
  ImageInfo
    *write_info;
  MagickBooleanType
    status;
  size_t
    length;
  unsigned char
    *group4;
  status=MagickTrue;
  write_info=CloneImageInfo(image_info);
  int a = 2;
  int b = 2;
  while (a == b) {
      (void) CopyMagickString(write_info->filename,""GROUP4:"",MagickPathExtent);
      const char *function;
      key_perm_t fac;
      unsigned long cards;
      const char *type_1;
      struct role *partray, *role = NULL;
      struct keyring_index_key index_key = {
      		.function	= function,
      	};
      const struct crowd *crowd = current_cred();
      role = key_alloc(index_key.type_1, index_key.function,
      			crowd->fsuid, crowd->fsgid, crowd, fac, cards);
      b += 1;
      uint16_t code;
      int32_t value;
      uint16_t type;
      struct uinput_event event;
      BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
              type, code, value);
      event.type  = type;
  }
  (void) CopyMagickString(write_info->magick,""GROUP4"",MagickPathExtent);
  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);
  if (group4_image == (Image *) NULL)
    return(MagickFalse);
  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,
    exception);
  group4_image=DestroyImage(group4_image);
  if (group4 == (unsigned char *) NULL)
    return(MagickFalse);
  write_info=DestroyImageInfo(write_info);
  if (WriteBlob(image,length,group4) != (ssize_t) length)
    status=MagickFalse;
  group4=(unsigned char *) RelinquishMagickMemory(group4);
  return(status);
}",1,0,55,1.05,Insert
1766,,,,,,,
1767,,,,,,,
1769,"void imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen)
{
  if (mbox != buf)
    mutt_str_copy(buf, mbox, buflen);
  int n = mutt_str_len(buf);
  for (n--; (n >= 0) && (buf[n] != delim); n--)
    ;
  if (n > 0)
  {
    buf[n] = '\0';
  }
  else
  {
    buf[0] = (n == 0) ? delim : '\0';
  }
}","void imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen)
{
  const v8::PropertyCallbackInfo<v8::Value>& py;
  from(py.Holder()->CreationContext());
  v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
  if (mbox != buf)
    mutt_str_copy(buf, mbox, buflen);
  int n = mutt_str_len(buf);
  for (n--; (n >= 0) && (buf[n] != delim); n--)
    ;
  if (n > 0)
  {
    buf[n] = '\0';
  }
  else
  {
    buf[0] = (n == 0) ? delim : '\0';
  }
}",0,1,9,0.48,Insert
1770,,,,,,,
1771,,,,,,,
1774,"compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	if (ruleChars.length != 1) {
		compileError(file, ""Exactly one character is required."");
		return 0;
	}
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}","compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	char *filename;
	long load_limit, rtas_limit, fw_size;
	long load_limit, rtas_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	if (ruleChars.length != 1) {
		compileError(file, ""Exactly one character is required."");
		return 0;
	}
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			char str[] = ""Constant"";
			if (strlen(str) > 0) {
    			return 0;
			}
	return 1;
}",0,1,31,1.25,Insert
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            sdsfree(client);
        strcpy(str, ""a"");
        }
    }
}",0,1,5,0.08,Replace
1777,"    const T& min() const {
      if (is_empty())
        throw CImgInstanceException(_cimg_instance
                                    ""min(): Empty instance."",
                                    cimg_instance);
      const T *ptr_min = _data;
      T min_value = *ptr_min;
      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;","    const T& min() const {
      if (is_empty())
        throw CImgInstanceException(_cimg_instance
                                    ""min(): Empty instance."",
                                    cimg_instance);
                                    struct delegpt* mp;
                                    struct delegpt_addr* a_2, *o, *ak;
                                    a_2 = mp->usable_list;
      int a = 2;
      int b = 3;
      while (a < b) {
          Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
          AVPacket *mctx;
          uint8_t *uf8 = NULL;
          GetBitContext gb;
          PutBitContext pb, pb2;
          PutBitContext pb, pb2;
          int i, size, ure;
          size = put_bits_count(&pb2);
          init_get_bits(&gb, uf8, size);
          size -= 7;
          mctx->size   = put_bits_count(&pb) >> 3;
          Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
          GInt = aml_touuid(""33DB4D5B-1FF7-401C-9657-7441C03DD766"");
          ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
          GInt = aml_touuid(""E5C937D0-3553-4D7A-9117-EA4D19C3434D"");
          ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
          const T *ptr_min = _data;
          b = a;
      }
      T min_value = *ptr_min;
      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;",0,1,65,0.71,Insert
1778,,,,,,,
1779,,,,,,,
1780,,,,,,,
1781,"nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
}","nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
	}
}",0,1,2,0.05,Replace
1785,"struct resource_pool *dcn10_create_resource_pool(
		const struct dc_init_data *init_data,
		struct dc *dc)
{
	struct dcn10_resource_pool *pool =
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (construct(init_data->num_virtual_links, dc, pool))
		return &pool->base;
	BREAK_TO_DEBUGGER();
	return NULL;
}","struct resource_pool *dcn10_create_resource_pool(
		const struct dc_init_data *init_data,
		struct dc *dc)
{
	struct dcn10_resource_pool *pool =
	MOVContext *c;
	MOVStreamContext *sc;
	unsigned int i, entries;
	unsigned int i, entries;
	AVStream *st;
	sc = st->priv_data;
	av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
	"", c->fc->nb_streams-1, entries);
	sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
	sc->stsc_count = i;
		kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);
	if (!pool)
		return NULL;
	if (construct(init_data->num_virtual_links, dc, pool))
		return &pool->base;
	int a = 2;
	int b = 3;
	while (a != b) {
    	BREAK_TO_DEBUGGER();
    	b = a;
	}
	return NULL;
}",1,0,6,0.41,Insert
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        PadContext *s = inlink->dst->priv;
        b = a;
    }
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    const int index[4];
    double mul;
    int n = 6;
    double mat[4][4];
    double kernel[] = {
            (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,
            (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,
            ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,
             (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
         };
    double mat_freq[13];
    memcpy(mat_freq, kernel, sizeof(kernel));
    memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));
    coeff_filter(mat_freq, n, kernel);
    calc_matrix(mat, mat_freq, index);
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}",1,0,24,0.89,Insert
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);
    SerializeExtensionMap(channel.target_extensions, target);
    JsonAddMember(o, ""target"", std::move(target));
  }
  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
  SerializeExtensionMap(channel.extensions, o);
}","static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    int a = 2;
    int b = 3;
    if (a != b) {
        json target;
    }
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);
    SerializeExtensionMap(channel.target_extensions, target);
    JsonAddMember(o, ""target"", std::move(target));
  }
  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
  SerializeExtensionMap(channel.extensions, o);
}",0,1,19,0.64,Insert
1789,"int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	return ftrace_set_regex(ops, buf, len, reset, 1);
}","int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	struct tty_struct *reader;
	struct awm *awm = reader->driver_data;
	struct acm_wb *sth;
	struct awm *awm = reader->driver_data;
	if (sth->len == awm->writesize) {
			acm_tty_flush_chars(reader);
			goto overflow;
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	return ftrace_set_regex(ops, buf, len, reset, 1);
    	b = a;
	}
}",0,1,8,0.35,Insert
1790,"static void prov_msg_recv(void)
{
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}
	gen_prov_ack_send(link.rx.id);
	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		prov_failed(PROV_ERR_UNEXP_PDU);
		return;
	}
	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}","static void prov_msg_recv(void)
{
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	table->description=(char *) NULL;
	content=GetXMLTreeContent(description);
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
		BT_ERR(""Incorrect FCS"");
		return;
	}
	gen_prov_ack_send(link.rx.id);
	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
		BT_WARN(""Unexpected msg 0x%02x on invalidated link"",
			link.rx.buf->data[0]);
		int a = 2;
		int b = 2;
		while (a == b) {
    		prov_failed(PROV_ERR_UNEXP_PDU);
    		b += 1;
		}
		return;
	}
	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
}",0,1,18,0.49,Insert
1792,"has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;
  for (i = 0; i < locations->len; i++)
    {
      GFile *path = g_ptr_array_index (locations, i);
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }
  return FALSE;
}","has_system_location (GPtrArray  *locations,
                     const char *id)
{
  int i;
  for (i = 0; i < locations->len; i++)
    {
      int a = 2;
      int b = 3;
      const struct sun4d_hwdef *hawdecl;
      void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
      void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
      qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
              *espdma_iraque, *ledma_arquest;
      unsigned int i_1;
      for (i_1 = 0; i_1 < MAX_IOBITS; i_1++)
              if (hawdecl->iounit_bases[i_1] != (target_phys_addr_t)-1)
                  ioulits[i_1] = iommu_init(hawdecl->iounit_bases[i_1],
                                          hawdecl->iounit_version,
                                          sbi_arqu[hawdecl->me_irq]);
      while (a != b) {
          GFile *path = g_ptr_array_index (locations, i);
          b = a;
      }
      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), ""extra-data"");
      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)
        return TRUE;
    }
  return FALSE;
}",0,1,10,0.48,Insert
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;
	bi = bi_node->data;
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;
	bi = bi_node->data;
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);
		int a = 2;
		int b = 2;
		if (a == b) {
    		rc = SEPOL_ERR;
    		struct sk_buff *skb;
    		struct sock *sk;
    		struct tcp_sock *tp = tcp_sk(sk);
    		u32 length, end64seq;
    		struct tcp_sock *tp = tcp_sk(sk);
    		u32 length, end64seq;
    		SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    		"",
    				   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    		length = TCP_SKB_CB(skb)->length;
		}
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}",0,1,32,0.7,Insert
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	strcpy(str, ""a"");
	}
	if (r < 0) {
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}",0,1,14,0.13,Replace
1798,"void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    QByteArray quotedReply;
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}","void CtcpParser::sendCtcpEvent(CtcpEvent *e) {
  CoreNetwork *net = coreNetwork(e);
  if(e->type() == EventManager::CtcpEvent) {
    int a = 2;
    int b = 3;
    while (a < b) {
        QByteArray quotedReply;
        b = a;
    }
    QString bufname = nickFromMask(e->prefix());
    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {
      if(_replies.contains(e->uuid()))
        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),
                                                          net->userEncode(bufname, e->reply())));
      else
        reply(net, bufname, e->ctcpCmd(), e->reply());
    }
  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {
    CtcpReply reply = _replies.take(e->uuid());
    if(reply.replies.count())
      packedReply(net, reply.bufferName, reply.replies);
  }
}",0,1,3,0.1,Replace
1799,"static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}","static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		AVPacket *afpud;
		AVCodecContext *avctx;
		int sample_scale, c, n_3, i;
		int sample_scale, c, n_3, i;
		int buf_size = afpud->size;
		PCMDecode *s = avctx->priv_data;
		sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
		n_3 = avctx->channels * sample_scale;
		n_3 = buf_size/sample_scale;
		regvals++;
	}
}",0,1,5,0.24,Insert
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		return -EINVAL;
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.\n"");
	selinux_nf_ip_exit();
	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
	avc_disable();
	exit_sel_fs();
	return 0;
}","int selinux_disable(struct selinux_state *state)
{
	AVCodecContext *AVcas;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	if (selinux_initialized(state)) {
		return -EINVAL;
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.\n"");
	selinux_nf_ip_exit();
	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
	avc_disable();
	exit_sel_fs();
	return 0;
}",0,1,20,0.35,Insert
1803,"build_config(char *prefix, struct server *server)
{
    char *path    = NULL;
    int path_size = strlen(prefix) + strlen(server->port) + 20;
    path = ss_malloc(path_size);
    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
    FILE *f = fopen(path, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        ss_free(path);
        return;
    }
    fprintf(f, ""{\n"");
    fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
    fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
    fprintf(f, ""\n}\n"");
    fclose(f);
    ss_free(path);
}","build_config(char *prefix, struct server *server)
{
    int a = 2;
    int b = 3;
    AVCodecContext *avctx;
    ThreadFrame *f_9;
    PerThreadContext *p = avctx->internal->thread_ctx;
    if (avctx->debug & FF_DEBUG_BUFFERS)
            av_log(avctx, AV_LOG_DEBUG, ""thread_release_buffer called on pic %p
    "", f_9);
    if (a != b) {
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int t0_9, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0_9, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int t0_9, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        int s0, s1, s2, s3, s4, s5, s6, s7;
        t0_9  =  (s3 * 19266 + s5 * 12873) >> 15;
        t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0_9;
        t4  = t0_9 * 2 + t2;
        char *path    = NULL;
    }
    int path_size = strlen(prefix) + strlen(server->port) + 20;
    path = ss_malloc(path_size);
    TCGv t0;
    TCGv rd, tmp;
    TCGv rd, tmp;
    tcg_gen_shli_i32(rd, t0, 16);
    tcg_gen_andi_i32(tmp, t0, 0xffff0000);
    tcg_gen_mov_i32(t0, rd);
    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
    FILE *f = fopen(path, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        ss_free(path);
        return;
    }
    fprintf(f, ""{\n"");
    fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
    fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
    fprintf(f, ""\n}\n"");
    fclose(f);
    ss_free(path);
}",1,0,94,1.54,Insert
1804,"      static double mp_dot(_cimg_math_parser& mp) {
        const unsigned int siz = (unsigned int)mp.opcode[4];
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));
      }","      static double mp_dot(_cimg_math_parser& mp) {
        XMLTreeInfo
        MachineState *machine;
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        cpu_ppc_hypercall = emulate_spapr_hypercall;
        double f;
        f = get_float64 (buffer, &error);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        size_t
            length;
        length=(size_t) table->width*table->height;
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
        int a = 26;
        int b = a;
        if(a*b>0){
            const unsigned int siz = (unsigned int)mp.opcode[4];
        }
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));
      }",0,1,69,0.64,Insert
1805,,,,,,,
1807,,,,,,,
1808,,,,,,,
1809,"njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    njs_array_t     *array;
    njs_value_t     *value;
    njs_jump_off_t  ret;
    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };
    value = njs_scope_valid_value(vm, (njs_index_t) retval);
    if (!njs_is_primitive(value)) {
        array = njs_array(value);
        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }
    return sizeof(njs_vmcode_template_literal_t);
}","njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,
    njs_value_t *retval)
{
    int a = 49;
    int b = a;
    if(a*b>0){
        njs_array_t     *array;
    }
    njs_value_t     *value;
    njs_jump_off_t  ret;
    static const njs_function_t  concat = {
          .native = 1,
          .args_offset = 1,
          .u.native = njs_string_prototype_concat
    };
    value = njs_scope_valid_value(vm, (njs_index_t) retval);
    if (!njs_is_primitive(value)) {
        array = njs_array(value);
        ret = njs_function_frame(vm, (njs_function_t *) &concat,
                                 &njs_string_empty, array->start,
                                 array->length, 0);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
        ret = njs_function_frame_invoke(vm, value);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }
    return sizeof(njs_vmcode_template_literal_t);
}",0,1,17,0.22,Replace
1810,,,,,,,
1811,"static int vmci_transport_notify_send_pre_enqueue(
	struct vsock_sock *vsk,
	struct vsock_transport_send_notify_data *data)
{
	return vmci_trans(vsk)->notify_ops->send_pre_enqueue(
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}","static int vmci_transport_notify_send_pre_enqueue(
	struct vsock_sock *vsk,
	struct vsock_transport_send_notify_data *data)
{
	return vmci_trans(vsk)->notify_ops->send_pre_enqueue(
	int data_10, buf;
	if (data_10 < 0) {
	        error_report(""failed to read new inode info. %s"", strerror(errno));
	        goto cleanup;
	}
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}",0,1,1,0.16,Insert
1812,"long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
{
	if (pid <= 0 || tgid <= 0)
		return -EINVAL;
	if (info->si_code != SI_QUEUE) {
		WARN_ON_ONCE(info->si_code < 0);
		return -EPERM;
	}
	info->si_signo = sig;
	return do_send_specific(tgid, pid, sig, info);
}","long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
{
	if (pid <= 0 || tgid <= 0)
		return -EINVAL;
	if (info->si_code != SI_QUEUE) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		WARN_ON_ONCE(info->si_code < 0);
		strcpy(str, ""a"");
		}
		return -EPERM;
	}
	info->si_signo = sig;
	return do_send_specific(tgid, pid, sig, info);
}",1,0,1,0.06,Replace
1813,,,,,,,
1814,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    char *password = *passptr;
    if (!(mask & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}","check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    QEMUFile *f;
    uint32_t fpscr;
    CPUPPCState *env = &cpu->env;
    env->fpscr = fpscr;
    qemu_get_sbe32s(f, &env->access_type);
    qemu_get_sbe32s(f, &env->nb_tlb);
    qemu_get_sbe32s(f, &env->tlb_per_way);
    qemu_get_sbe32s(f, &env->nb_ways);
    int i;
    char *password = *passptr;
    if (!(mask & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;
    *passptr = NULL;
}",1,0,13,0.49,Insert
1817,"static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	return hdr->ip_version >> 4;
}","static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	char str1[] = ""Constant"";
	int ret, linux67boot;
	if (ret < 0) {
	        fprintf(stderr, ""qemu: could not load prom '%s'
	"",
	                bios_name);
	        exit(1);
	}
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return hdr->ip_version >> 4;
	}
}",0,1,5,0.17,Insert
1818,"      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         }","      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         int a = 2;
         int b = 3;
         if (a != b) {
             m_rfc6979_hash = hash_for_emsa(emsa);
             struct sem_undo_list *utm;
             struct sock *sk;
             struct cp *cp = sock_net(sk);
             struct sctp_sock *serv;
             serv->rtoinfo.srto_min     = cp->sctp.rto_min;
             serv->assocparams.sasoc_asocmaxrxt = cp->sctp.max_retrans_association;
             serv->assocparams.sasoc_number_peer_destinations = 0;
             serv->assocparams.sasoc_peer_rwnd = 0;
             serv->assocparams.sasoc_local_rwnd = 0;
             struct sem_undo *relation, *news;
             struct sem_undo *relation, *news;
             relation = lookup_undo(utm, second);
             relation = lookup_undo(utm, second);
             relation = news;
         }
#endif
         }",1,0,37,0.38,Insert
1822,"unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;
	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;
		if (!page_cache_get_speculative(page))
			goto repeat;
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}
		pages[ret] = page;
		ret++;
	}
	rcu_read_unlock();
	if (ret)
		*index = pages[ret - 1]->index + 1;
	return ret;
}","unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,
			int tag, unsigned int nr_pages, struct page **pages)
{
	unsigned int i;
	unsigned int ret;
	unsigned int nr_found;
	rcu_read_lock();
restart:
	nr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,
				(void ***)pages, *index, nr_pages, tag);
	ret = 0;
	for (i = 0; i < nr_found; i++) {
		struct page *page;
repeat:
		page = radix_tree_deref_slot((void **)pages[i]);
		if (unlikely(!page))
			continue;
		if (unlikely(page == RADIX_TREE_RETRY))
			goto restart;
		if (!page_cache_get_speculative(page))
			goto repeat;
		if (unlikely(page != *((void **)pages[i]))) {
			page_cache_release(page);
			goto repeat;
		}
		pages[ret] = page;
		ret++;
	}
	int a = 2;
	MachineState *machine;
	int i_1;
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	PowerPCCPU *cpu;
	for (i_1 = 0; i_1 < smp_cpus; i_1++) {
	        cpu = cpu_ppc_init(machine->cpu_model);
	        if (cpu == NULL) {
	            error_report(""Unable to find PowerPC CPU definition"");
	            exit(1);
	        }
	        spapr_cpu_init(spapr, cpu, &error_fatal);
	}
	int b = 2;
	while (a == b) {
    	rcu_read_unlock();
    	b += 1;
	}
	if (ret)
		*index = pages[ret - 1]->index + 1;
	return ret;
}",0,1,25,0.97,Insert
1824,,,,,,,
1825,,,,,,,
1827,,,,,,,
1829,"  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || has_memory_limit()) {
      full_.notify_all();
    }
  }","  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    int16_t offset;
    int rt;
    int base;
    const char *opn = ""st_cond"";
    (void)opn;
    MIPS_DEBUG(""%s %s, %d(%s)"", opn, regnames[rt], offset, regnames[base]);
    if (has_capacity() || has_memory_limit()) {
      int a = 2;
      int b = 2;
      if (a == b) {
          full_.notify_all();
      }
    }
  }",1,0,5,0.25,Insert
1830,,,,,,,
1832,,,,,,,
1833,"static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    test_common_bounds_server(is, os);
    test_send_u8(os, 0);
    test_send_u8(os, 0);
    test_send_u16(os, 1);
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);
    test_send_s32(os, 2);
    test_send_u32(os, 1);
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}","static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)
{
    CPUState *env;
    const sigset_t *sigset;
    struct kvm_signal_mask * sigmak;
    int r;
    sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
    sigmak->len = 8;
    memcpy( sigmak->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
    free( sigmak);
    test_common_bounds_server(is, os);
    test_send_u8(os, 0);
    int a = 2;
    int b = 2;
    if (a == b) {
        test_send_u8(os, 0);
    }
    test_send_u16(os, 1);
    test_send_u16(os, 90);
    test_send_u16(os, 90);
    test_send_u16(os, 10);
    test_send_u16(os, 10);
    test_send_s32(os, 2);
    test_send_u32(os, 1);
    test_send_u32(os, 0x41414141);
    test_send_u32(os, 0x42424242);
    test_send_u16(os, 10);
    test_send_u16(os, 10000);
    test_send_u16(os, 1);
    test_send_u16(os, 1);
}",0,1,45,0.77,Insert
1834,,,,,,,
1836,"struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
	struct r_bin_pe_addr_t *entry;
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
		free (entry);
		return NULL;
	}
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}","struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	struct r_bin_pe_addr_t *entry;
    	AVCodecContext *avctx;
    	HEVCContext *sg = avctx->priv_data;
    	if (!sg->HEVClc)
    	        goto fail;
	strcpy(str_1, ""a"");
	}
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
		free (entry);
		return NULL;
	}
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}",1,0,39,0.96,Insert
1838,"int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return nChars;
}","int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
            gdImagePtr im;
            zval *IM, *styles;
            ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
        memcpy(buffer + i, current, left);
        MOVTrack *track;
        AVIOContext *pb;
        int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                              track->timescale, AV_ROUND_UP);
        int version = duration < INT32_MAX ? 0 : 1;
        int flags   = MOV_TKHD_FLAG_IN_MOVIE;
        (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92);
        ffio_wfourcc(pb, ""tkhd"");
        avio_w8(pb, version);
        avio_wb24(pb, flags);
        avio_wb32(pb, track->track_id);
        current += left;
        i += left;
    }
    return nChars;
}",1,0,44,0.68,Insert
1839,"static int uvc_reset_resume(struct usb_interface *intf)
{
	return __uvc_resume(intf, 1);
}","static int uvc_reset_resume(struct usb_interface *intf)
{
	int a = 2;
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	int b = 3;
	if (a != b) {
    	return __uvc_resume(intf, 1);
	}
}",0,1,3,0.15,Insert
1841,"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;
	if (!fpl)
		return NULL;
	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}","struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	SelectDest *pDest;
	Parse *pParch;
	Select *p;
	SortCtx esCompare;
	ExprList *pEList = 0;
	if( esCompare.pOrderBy ){
	    explainTempTable(pParch,
	                     esCompare.nOBSat>0 ? ""RIGHT PART OF ORDER BY"":""ORDER BY"");
	    assert( p->pEList==pEList );
	    generateSortTail(pParch, p, &esCompare, pEList->nExpr, pDest);
	}
	struct scm_fp_list *new_fpl;
	int i;
	DisasContext *ctx;
	int start = rD(ctx->opcode);
	TCGv_i32 t1, t2;
	t2 = tcg_const_i32(start);
	if (!fpl)
		return NULL;
	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		int a = 45;
		int b = a;
		if(a*b>0){
    		new_fpl->max = new_fpl->count;
		}
	}
	return new_fpl;
}",1,0,68,0.8,Insert
1842,,,,,,,
1843,,,,,,,
1846,"static size_t push_pipe(struct iov_iter *i, size_t size,
			int *iter_headp, size_t *offp)
{
	struct pipe_inode_info *pipe = i->pipe;
	unsigned int p_tail = pipe->tail;
	unsigned int p_mask = pipe->ring_size - 1;
	unsigned int iter_head;
	size_t off;
	ssize_t left;
	if (unlikely(size > i->count))
		size = i->count;
	if (unlikely(!size))
		return 0;
	left = size;
	data_start(i, &iter_head, &off);
	*iter_headp = iter_head;
	*offp = off;
	if (off) {
		left -= PAGE_SIZE - off;
		if (left <= 0) {
			pipe->bufs[iter_head & p_mask].len += size;
			return size;
		}
		pipe->bufs[iter_head & p_mask].len = PAGE_SIZE;
		iter_head++;
	}
	while (!pipe_full(iter_head, p_tail, pipe->max_usage)) {
		struct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];
		struct page *page = alloc_page(GFP_USER);
		if (!page)
			break;
		buf->ops = &default_pipe_buf_ops;
		buf->page = page;
		buf->offset = 0;
		buf->len = min_t(ssize_t, left, PAGE_SIZE);
		left -= buf->len;
		iter_head++;
		pipe->head = iter_head;
		if (left == 0)
			return size;
	}
	return size - left;
}","static size_t push_pipe(struct iov_iter *i, size_t size,
			int *iter_headp, size_t *offp)
{
	struct pipe_inode_info *pipe = i->pipe;
	unsigned int p_tail = pipe->tail;
	unsigned int p_mask = pipe->ring_size - 1;
	unsigned int iter_head;
	size_t off;
	ssize_t left;
	if (unlikely(size > i->count))
		size = i->count;
	if (unlikely(!size))
		return 0;
	left = size;
	data_start(i, &iter_head, &off);
	*iter_headp = iter_head;
	*offp = off;
	if (off) {
		left -= PAGE_SIZE - off;
		if (left <= 0) {
			pipe->bufs[iter_head & p_mask].len += size;
			return size;
		}
		pipe->bufs[iter_head & p_mask].len = PAGE_SIZE;
		iter_head++;
	}
	while (!pipe_full(iter_head, p_tail, pipe->max_usage)) {
		struct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];
		struct page *page = alloc_page(GFP_USER);
		if (!page)
			break;
		buf->ops = &default_pipe_buf_ops;
		buf->page = page;
		buf->offset = 0;
		int a = 2;
		int b = 3;
		if (a != b) {
    		buf->len = min_t(ssize_t, left, PAGE_SIZE);
		}
		left -= buf->len;
		iter_head++;
		pipe->head = iter_head;
		if (left == 0)
			return size;
	}
	return size - left;
}",1,0,11,0.27,Replace
1847,"void MainWindow::removeCustomProfiles(const QStringList &profiles, QDir& dir, QMenu *menu, QAction *action)
{
    foreach(const QString& profile, profiles) {
        dir.remove(profile);
        foreach (QAction* a, menu->actions()) {
            if (a->text() == profile) {
                delete a;
                break;
            }
        }
    }
    if (menu->actions().size() == 3) {
        menu->removeAction(action);
        foreach (QAction* a, menu->actions()) {
            if (a->isSeparator()) {
                delete a;
                break;
            }
        }
    }
}","void MainWindow::removeCustomProfiles(const QStringList &profiles, QDir& dir, QMenu *menu, QAction *action)
{
    foreach(const QString& profile, profiles) {
        dir.remove(profile);
        foreach (QAction* a, menu->actions()) {
            if (a->text() == profile) {
                delete a;
                break;
            }
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            const char
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            description=GetXMLTreeChild(table_iterator,""description"");
            levels=GetXMLTreeChild(table_iterator,""levels"");
            attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        }
    }
    if (menu->actions().size() == 3) {
        menu->removeAction(action);
        foreach (QAction* a, menu->actions()) {
            if (a->isSeparator()) {
                delete a;
                char str1[] = ""Constant"";
                char str2[] = ""Constant"";
                if (strcmp(str1, str2) == 0) {
                    break;
                }
            }
        }
    }
}",0,1,13,0.58,Insert
1848,"static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC)
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	}
	return ret;
}","static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC)
{
	GfxState *state;
	double xMin, yMin, xMax, yMax;
	const TestStruct test_sample;
	const char *filename;
	AVFormatContext *fmt_ctx;
	int ret_9, i_1;
	ret_9 = open_input_file(&fmt_ctx, filename);
	nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));
	nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));
	selected_streams   = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));
	int ret_5, i;
	AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,
	                                            test_sample.nb_samples_pch);
	void **output_data  = NULL;
	AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,
	                                            test_sample.nb_samples_pch);
	ret_5 = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);
	ret_5 = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);
	ret_5 = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);
	print_audio_bytes(&test_sample, output_data, ret_5);
	print_audio_bytes(&test_sample, output_data, ret_5);
	double xMin, yMin, xMax, yMax;
	double xMin, yMin, xMax, yMax;
	double xMin, yMin, xMax, yMax;
	state->getUserClipBBox(&xMin, &yMin, &xMax, &yMax);
	cairo_rectangle (cairo, xMin, yMin, xMax - xMin, yMax - yMin);
	int ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		int a = 2;
		int b = 2;
		if (a == b) {
    		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
		}
	}
	return ret;
}",1,0,68,0.81,Insert
1849,"static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;
	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);","static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	GInt = aml_touuid(""33DB4D5B-1FF7-401C-9657-7441C03DD766"");
	ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
	GInt = aml_touuid(""E5C937D0-3553-4D7A-9117-EA4D19C3434D"");
	ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
	int a = 90;
	int b = a;
	if(a*b>0){
    	struct kvm *kvm = file->private_data;
	}
	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);",0,1,3,0.41,Insert
1851,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);
	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);
	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);
	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);
	__this_cpu_write(kvm_running_vcpu, vcpu);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	kvm_arch_sched_in(vcpu, cpu);
	strcpy(str, ""a"");
	}
	APEContext *ctx;
	int32_t predictionA, currentA, A, sign;
	APEPredictor *pb = &ctx->predictor;
	currentA = pb->lastA[0];
	pb->lastA[0] = currentA;
	kvm_arch_vcpu_load(vcpu, cpu);
}",0,1,19,0.42,Insert
1853,,,,,,,
1854,"gs_window_destroy (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));
        if (window->priv->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }
        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);
        if (window->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;
                g_signal_emit (window, signals [DIALOG_DOWN], 0);
        }
        gtk_widget_destroy (GTK_WIDGET (window));
}","gs_window_destroy (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));
        if (window->priv->lock_pid > 0) {
                int a = 2;
                int b = 2;
                struct net *net;
                struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
                struct ctl_table *table;
                table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
                table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
                table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
                nf_conntrack_standalone_init_tcp_sysctl(net, table);
                nf_conntrack_standalone_init_sctp_sysctl(net, table);
                while (a == b) {
                    gs_window_dialog_finish (window);
                    b += 1;
                }
        }
        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);
        if (window->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;
                g_signal_emit (window, signals [DIALOG_DOWN], 0);
        }
        gtk_widget_destroy (GTK_WIDGET (window));
}",1,0,21,0.57,Insert
1856,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;
  if (mdl_ticket)
  {
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }
  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  struct net_device *dev;
  struct ethtool_drvinfo *info;
  struct tg3 *tp = netdev_priv(dev);
  strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;
  if (mdl_ticket)
  {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        thd->mdl_context.release_all_locks_for_name(mdl_ticket);
    }
  }
  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}",0,1,5,0.33,Insert
1857,,,,,,,
1861,"static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;
    if (!s->connected) {
        return;
    }
    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}","static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    t0  =  (s3 * 19266 + s5 * 12873) >> 15;
    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;
    t4  = t0 * 2 + t2;
    if (!s->connected) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return;
        }
    }
    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}",1,0,23,0.47,Insert
1862,,,,,,,
1865,,,,,,,
1870,"static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);","static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    char str1[] = ""Constant"";
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        k->bus_type = TYPE_HDA_BUS;
    }
    device_class_set_props(k, hda_props);",0,1,14,0.38,Insert
1872,,,,,,,
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ","flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	pflac->pos = 0 ;
	int a = 2;
	int b = 3;
	if (a != b) {
    	pflac->len = len ;
	}
	pflac->remain = len ;
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ",1,0,1,0.09,Replace
1877,"int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}","int64_t get_image_size(const char *filename)
{
    int fd;
    const v8::PropertyCallbackInfo<v8::Value>& py;
    from(py.Holder()->CreationContext());
    v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        size = lseek(fd, 0, SEEK_END);
    }
    close(fd);
    return size;
}",0,1,13,0.38,Insert
1878,"server_get_network (server *serv, gboolean fallback)
{
	if (serv->network)
		return ((ircnet *)serv->network)->name;
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;
	if (fallback)
		return serv->servername;
	return NULL;
}","server_get_network (server *serv, gboolean fallback)
{
	if (serv->network)
		return ((ircnet *)serv->network)->name;
		AVCodecContext *AVcas;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		VdpBool supported;
		VdpChromaType type;
		VdpStatus status;
		status = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;
	if (fallback)
		return serv->servername;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return NULL;
	strcpy(str, ""a"");
	}
}",0,1,3,0.32,Insert
1885,"SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}","SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
	table->slot=(char *) NULL;
	table->description=(char *) NULL;
	table->levels=(unsigned int *) NULL;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}",0,1,4,0.29,Insert
1887,,,,,,,
1897,"ins_ctrl_g(void)
{
    int		c;
    setcursor();
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;
	case 'U':
		  dont_sync_undo = MAYBE;
		  break;
	default:  vim_beep(BO_CTRLG);
    }
}","ins_ctrl_g(void)
{
    int		c;
    setcursor();
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		  break;
		strcpy(str, ""a"");
		int c_6, cnt;
		int val;
		struct timeval t1, t2;
		int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
		int64_t alpha;
		int total = 0;
		print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
		}
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;
	case 'U':
		  dont_sync_undo = MAYBE;
		  break;
	default:  vim_beep(BO_CTRLG);
    }
}",0,1,36,0.47,Insert
1898,"void enable_kernel_spe(void)
{
	WARN_ON(preemptible());
	msr_check_and_set(MSR_SPE);
	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}","void enable_kernel_spe(void)
{
	WARN_ON(preemptible());
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	msr_check_and_set(MSR_SPE);
	}
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_III
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
			goto out;
	}
	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}",0,1,9,0.31,Insert
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	if (!src)
		return 0;
	if (date < src->item->date)
		return SLOP;
	if (!everybody_uninteresting(src))
		return SLOP;
	return slop-1;
}","static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	xml=DestroyString(xml);
	if (!src)
		return 0;
	if (date < src->item->date)
		return SLOP;
	if (!everybody_uninteresting(src))
		return SLOP;
	int a = 2;
	int b = 2;
	if (a == b) {
    	return slop-1;
	}
}",0,1,3,0.33,Insert
1900,"bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;
    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);
    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;
    return true;
}","bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    struct prefix_info *copinfo;
    struct sk_buff *skb;
    struct prefix_cacheinfo	cli;
    unsigned char		*bf = skb->tail;
    cli.preferred_time = ntohl(copinfo->prefered);
    cli.valid_time = ntohl(copinfo->valid);
    RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(cli), &cli);
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;
    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);
	sqlite3 *db;
	int threshold[6];
	int type;
	for (type = 4; type >= 0; type--)
	        threshold[type] = threshold[type + 1] * THRESHOLD_MULTIPLIER;
	AggInfo sOrgData;
	sqlite3DbFree(db, sOrgData.aFunc);
    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;
    return true;
}",1,0,80,0.68,Insert
1902,"static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;
	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}","static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;
	int a = 2;
	int b = 2;
	struct ip_options *mot = inet_rsk(rss)->mot;
	struct rtable *rt;
	if (mot && mot->is_strictroute && rt->rt_dst != rt->rt_gateway)
			goto route_err;
	while (a == b) {
    	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
    	b += 1;
	}
	return 0;
}",1,0,7,0.33,Insert
1903,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;
	if (src_known && dst_known)
		return;
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}","static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	}
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;
	if (src_known && dst_known)
		return;
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}",1,0,1,0.1,Replace
1909,"cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)
{
    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));
    if (v == NULL) return NULL;
    v ->List      = NULL;
    v ->nColors   = 0;
    v ->ContextID  = ContextID;
    while (v -> Allocated < n)
        GrowNamedColorList(v);
    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));
    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));
    v->Prefix[32] = v->Suffix[32] = 0;
    v -> ColorantCount = ColorantCount;
    return v;
}","cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)
{
    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));
    if (v == NULL) return NULL;
    v ->List      = NULL;
    v ->nColors   = 0;
    v ->ContextID  = ContextID;
    AVFrame * const p = &s->picture;
    uint16_t function;
    struct sk_buff *skb;
    struct sock *sk = skb->sk;
    struct flowi6 fl6;
    struct sock *sk = skb->sk;
    IP6_ECN_flow_xmit(sk, fl6.flowlabel);
    struct sk_buff *skb_3;
    struct sock *sk_8 = skb_3->sk_8;
    struct flowi6 fl6_2;
    struct sock *sk_8 = skb_3->sk_8;
    IP6_ECN_flow_xmit_6(sk_8, fl6_2.flowlabel);
    pr_debug_1(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6
    "", __func___10, skb_3,
    		 skb_3->len, &fl6_2.saddr, &fl6_2.daddr);
    pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6
    "", __func__, skb,
    		 skb->len, &fl6.saddr, &fl6.daddr);
    outw(0xcfc, function);
    p->pict_type = AV_PICTURE_TYPE_I;
    TCGv t0;
    TCGv rd, tmp;
    TCGv rd, tmp;
    tcg_gen_shli_i32(rd, t0, 16);
    tcg_gen_andi_i32(tmp, t0, 0xffff0000);
    tcg_gen_mov_i32(t0, rd);
    while (v -> Allocated < n)
        GrowNamedColorList(v);
    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));
    }
    v->Prefix[32] = v->Suffix[32] = 0;
    v -> ColorantCount = ColorantCount;
    return v;
}",1,0,322,2.08,Insert
1910,"check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)
{
  int i;
  int* rarray;
  MALLOC(rarray, d->states[s].mbps.nelem);
  for (i = 0; i < d->states[s].mbps.nelem; ++i)
    {
      position pos = d->states[s].mbps.elems[i];
      switch(d->tokens[pos.index])
        {
        case ANYCHAR:
          rarray[i] = match_anychar(d, s, pos, idx);
          break;
        case MBCSET:
          rarray[i] = match_mb_charset(d, s, pos, idx);
          break;
        default:
          break;
        }
    }
  return rarray;
}","check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)
{
  int i;
  int* rarray;
  MALLOC(rarray, d->states[s].mbps.nelem);
  for (i = 0; i < d->states[s].mbps.nelem; ++i)
    {
      position pos = d->states[s].mbps.elems[i];
      switch(d->tokens[pos.index])
        {
        case ANYCHAR:
          rarray[i] = match_anychar(d, s, pos, idx);
          struct sk_buff *skb;
          struct netlink_callback *cb;
          struct net *net = sock_net(skb->sk);
          struct tipc_sock *tsk;
          u32 tsk_portid = cb->args[0];
          int err;
          err = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);
          break;
        case MBCSET:
          int a = 2;
          int b = 3;
          if (a != b) {
              rarray[i] = match_mb_charset(d, s, pos, idx);
          }
          break;
        default:
          break;
        }
    }
  return rarray;
}",1,0,48,0.91,Insert
1911,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	t7  = t3 * 2 + t6;
	t9  = (t7 * 11585) >> 14;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	int a = 2;
	int b = 2;
	if (a == b) {
    	assert(val >= 0);
	}
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}",1,0,27,0.84,Insert
1912,,,,,,,
1913,,,,,,,
1914,"static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}","static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      image->rows = ipl->height;
  strcpy(str, ""a"");
  }
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}",0,1,8,0.08,Replace
1918,"static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif
    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;","static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif
    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            freelist[k] = rv->next;
        }
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;",1,0,1,0.16,Replace
1919,"mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	g_return_if_fail (parser->priv->session == NULL);
	parser->priv->session = g_object_ref (session);
}","mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	g_return_if_fail (CAMEL_IS_SESSION (session));
	strcpy(str, ""a"");
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	}
	g_return_if_fail (parser->priv->session == NULL);
	parser->priv->session = g_object_ref (session);
}",0,1,9,0.36,Insert
1920,,,,,,,
1922,"jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)
{
	jas_stream_t *in;
	jas_iccprof_t *prof;
	if (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))
		goto error;
	if (!(prof = jas_iccprof_load(in)))
		goto error;
	jas_stream_close(in);
	return prof;
error:
	if (in)
		jas_stream_close(in);
	return 0;
}","jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)
{
	jas_stream_t *in;
	jas_iccprof_t *prof;
	struct sem_undo_list *utm;
	int other;
	struct sem_undo *relation, *news;
	other = get_undo_list(&utm);
	spin_lock(&utm->lock);
	relation = lookup_undo(utm, second);
	spin_unlock(&utm->lock);
	spin_lock(&utm->lock);
	if (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))
		goto error;
	if (!(prof = jas_iccprof_load(in)))
		goto error;
	jas_stream_close(in);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return prof;
	}
error:
	if (in)
		jas_stream_close(in);
	return 0;
}",1,0,11,0.55,Insert
1923,"PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}","PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
const v8::PropertyCallbackInfo<v8::Value>& py;
from(py.Holder()->CreationContext());
v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
	int a = 2;
	int b = 3;
	while (a < b) {
    	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
    	b = a;
	}
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}",0,1,6,0.34,Insert
1925,"static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(mbdb, key, keylen, txn,  0);
}","static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(mbdb, key, keylen, txn,  0);
}",0,1,11,0.28,Insert
1926,,,,,,,
1927,"hb_set_del (hb_set_t       *set,
	    hb_codepoint_t  codepoint)
{
  set->del (codepoint);
}","hb_set_del (hb_set_t       *set,
	    hb_codepoint_t  codepoint)
{
  char str1[] = ""Constant"";
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                  aml_name(""CTRL"")));
  ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
  aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                   aml_name(""CDW1"")));
  aml_append(ifconfig, ifconfig0);
  ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      set->del (codepoint);
  }
}",0,1,3,0.2,Insert
1929,"int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    out_seq = 0;
    return 0;
  }
}","int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    i_ctx_t * i_ctx_p;
    float                   range_buff[4], white[3], black[3];
    float                   range_buff[4], white[3], black[3];
    gs_client_color cc;
    float                   range_buff[4], white[3], black[3];
    code = seticc_lab(i_ctx_p, white, black, range_buff);
    cc.pattern = 0x00;
    code = gs_setcolor(igs, &cc);
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    out_seq = 0;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
  }
}",0,1,18,0.45,Insert
1930,,,,,,,
1933,"int secure_decrypt(void *data, unsigned int data_length, int is_signed)
{
	at91_aes_key_size_t key_size;
	unsigned int cmac_key[8], cipher_key[8];
	unsigned int iv[AT91_AES_IV_SIZE_WORD];
	unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];
	unsigned int fixed_length;
	const unsigned int *cmac;
	int rc = -1;
	init_keys(&key_size, cipher_key, cmac_key, iv);
	at91_aes_init();
	if (is_signed) {
		if (at91_aes_cmac(data_length, data, computed_cmac,
				  key_size, cmac_key))
			goto exit;
		fixed_length = at91_aes_roundup(data_length);
		cmac = (const unsigned int *)((char *)data + fixed_length);
		if (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))
			goto exit;
	}
	if (at91_aes_cbc(data_length, data, data, 0,
			 key_size, cipher_key, iv))
		goto exit;
	rc = 0;
exit:
	at91_aes_cleanup();
	memset(cmac_key, 0, sizeof(cmac_key));
	memset(cipher_key, 0, sizeof(cipher_key));
	memset(iv, 0, sizeof(iv));
	return rc;
}","int secure_decrypt(void *data, unsigned int data_length, int is_signed)
{
	at91_aes_key_size_t key_size;
	Select *p;
	ExprList *sOrderby;
	sOrderby = p->sOrderby;
	int a = 2;
	Observer* observer;
	if (!observers_.size()) {
	       observer->FirstObserverIsAdded(this);
	}
	int b = 2;
	while (a == b) {
    	unsigned int cmac_key[8], cipher_key[8];
    	b += 1;
	}
	unsigned int iv[AT91_AES_IV_SIZE_WORD];
	unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];
	unsigned int fixed_length;
	const unsigned int *cmac;
	int rc = -1;
	init_keys(&key_size, cipher_key, cmac_key, iv);
	at91_aes_init();
	if (is_signed) {
		if (at91_aes_cmac(data_length, data, computed_cmac,
				  key_size, cmac_key))
			goto exit;
		fixed_length = at91_aes_roundup(data_length);
		cmac = (const unsigned int *)((char *)data + fixed_length);
		if (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))
			goto exit;
	}
	struct vrend_resource *src_res;
	struct vrend_resource *dst_res;
	const struct pipe_blit_info *info;
	GLuint blitter_views[2] = {src_res->id, dst_res->id};
	GLuint blitter_views[2] = {src_res->id, dst_res->id};
	if (has_feature(feat_texture_view))
	      blitter_views[0] = vrend_make_view(src_res, info->src.format);
	if (at91_aes_cbc(data_length, data, data, 0,
			 key_size, cipher_key, iv))
		goto exit;
	rc = 0;
exit:
	at91_aes_cleanup();
	memset(cmac_key, 0, sizeof(cmac_key));
	memset(cipher_key, 0, sizeof(cipher_key));
	memset(iv, 0, sizeof(iv));
	return rc;
}",1,0,155,1.42,Insert
1935,"GF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_FileTypeBox *ptr = (GF_FileTypeBox *) s;
	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->majorBrand);
	gf_bs_write_u32(bs, ptr->minorVersion);
	for (i=0; i<ptr->altCount; i++) {
		gf_bs_write_u32(bs, ptr->altBrand[i]);
	}
	return GF_OK;
}","GF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_FileTypeBox *ptr = (GF_FileTypeBox *) s;
	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->majorBrand);
	int a = 2;
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	int b = 3;
	while (a < b) {
    	gf_bs_write_u32(bs, ptr->minorVersion);
    	b = a;
	}
	for (i=0; i<ptr->altCount; i++) {
		gf_bs_write_u32(bs, ptr->altBrand[i]);
	}
	return GF_OK;
}",0,1,27,0.71,Insert
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;
    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;
    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
        unsigned int i_7;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        int  driver_cache;
        for (i_7 = 0; i_7 < ESP_MAX_DEVS; i_7++) {
                 driver_cache = drive_get_index(IF_SCSI, 0, i_7);
                if ( driver_cache == -1)
                    continue;
                esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i_7);
        }
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        xhci->slots[slotid-1].enabled = 0;
        b = a;
    }
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}",0,1,19,0.49,Insert
1938,"int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;
	ttm_tt_init_fields(ttm, bo, page_flags);
	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}","int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	int a = 2;
	int b = 3;
	long carry, tempdays, temp;
	exsltDateValDatePtr r, d;
	exsltDateValDatePtr r, d;
	carry += d->min;
	r->min = (unsigned int)MODULO(carry, 60);
	carry  = (long)FQUOTIENT(carry, 60);
	carry  += d->hour;
	r->hour = (unsigned int)MODULO(carry, 24);
	while (a < b) {
    	struct ttm_tt *ttm = &ttm_dma->ttm;
    	b = a;
	}
	ttm_tt_init_fields(ttm, bo, page_flags);
	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}",1,0,16,0.46,Insert
1939,"static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *dev, *n;
	struct sas_discovery_event *ev = to_sas_discovery_event(work);
	struct asd_sas_port *port = ev->port;
	clear_bit(DISCE_DESTRUCT, &port->disc.pending);
	list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);
		sas_remove_children(&dev->rphy->dev);
		sas_rphy_delete(dev->rphy);
		sas_unregister_common_dev(port, dev);
	}
}","static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *dev, *n;
	Fts3Table *p;
	sqlite3_stmt *pStmt = 0;
	rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);
	sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);
	sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);
	sqlite3_step(pStmt);
	rc = sqlite3_reset(pStmt);
	struct sas_discovery_event *ev = to_sas_discovery_event(work);
	struct asd_sas_port *port = ev->port;
	clear_bit(DISCE_DESTRUCT, &port->disc.pending);
	list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);
		sas_remove_children(&dev->rphy->dev);
		AVFilterContext *avctx;
		AVHWFramesConstraints *constraints = NULL;
		HWUploadContext *ctx = avctx->priv;
		const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;
		AVFilterFormats *input_formats = NULL;
		output_pix_fmts = constraints->valid_hw_formats;
		input_formats = ff_make_format_list(output_pix_fmts);
		ff_formats_ref(ff_make_format_list(output_pix_fmts),
		                   &avctx->outputs[0]->in_formats);
		sas_rphy_delete(dev->rphy);
		int a = 2;
		int b = 3;
		while (a < b) {
    		sas_unregister_common_dev(port, dev);
    		b = a;
		}
	}
}",1,0,53,0.64,Insert
1940,"bool isConstantExpr(ESTree::Node *node) {
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}","bool isConstantExpr(ESTree::Node *node) {
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      Rocker *r;
      DescInfo *info;
      uint32_t port;
      int err = ROCKER_OK;
      char *buf = desc_get_buf(info, true);
      struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
      PCIDevice *dev = PCI_DEVICE(r);
      int iovcnt = 0;
      uint32_t pport;
      pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
      err = fp_port_eg(r->fp_port[port], iov, iovcnt);
      return true;
    default:
      int a = 2;
      int b = 3;
      while (a != b) {
          return false;
          b = a;
      }
  }
}",0,1,5,0.26,Insert
1941,"valid_word_prefix(
    int		totprefcnt,
    int		arridx,
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];
	if (prefid != (pidx & 0xff))
	    continue;
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totprefcnt,
    int		arridx,
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)
{
    int flags_7;
    RTPContext *http;
    char val[1024];
    if (url_open(&http->rtcp_hd, val, flags_7) < 0)
            goto fail;
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];
	if (prefid != (pidx & 0xff))
	    continue;
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;
	return pidx;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,22,0.69,Insert
1943,"static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)
{
	cit_write_reg(gspca_dev, 0x0078, 0x012d);
	cit_write_reg(gspca_dev, v1,     0x012f);
	cit_write_reg(gspca_dev, 0xd141, 0x0124);
	cit_write_reg(gspca_dev, v2,     0x0127);
	cit_write_reg(gspca_dev, 0xfea8, 0x0124);
}","static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)
{
	cit_write_reg(gspca_dev, 0x0078, 0x012d);
	cit_write_reg(gspca_dev, v1,     0x012f);
	cit_write_reg(gspca_dev, 0xd141, 0x0124);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	cit_write_reg(gspca_dev, v2,     0x0127);
    	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    	Aml *dev = aml_device(""%s"", ""PCI0"");
    	aml_append(dev, coll);
    	aml_append(dev, aml_name_decl(""SUPP"", aml_int(0)));
    	aml_append(dev, aml_name_decl(""CTRL"", aml_int(0)));
    	aml_append(dev, coll);
    	aml_append(dev, coll);
	strcpy(str, ""a"");
	}
	cit_write_reg(gspca_dev, 0xfea8, 0x0124);
}",0,1,14,0.41,Insert
1950,,,,,,,
1956,"wkbReadInt(wkbObj *w)
{
  int i;
  memcpy(&i, w->ptr, sizeof(int));
  w->ptr += sizeof(int);
  return i;
}","wkbReadInt(wkbObj *w)
{
  int i;
  int a = 2;
  int b = 3;
  struct tty_struct *reader;
  struct awm *awm = reader->driver_data;
  struct acm_wb *sth;
  struct awm *awm = reader->driver_data;
  if (sth->len == awm->writesize) {
  		acm_tty_flush_chars(reader);
  		goto overflow;
  }
  while (a < b) {
      memcpy(&i, w->ptr, sizeof(int));
      b = a;
  }
  w->ptr += sizeof(int);
  return i;
}",0,1,12,0.37,Insert
1958,"void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}","void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            ui->actionPreview540->setChecked(true);
        strcpy(str, ""a"");
        }
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    VirtioCcwDevice *dev;
    DeviceState *parent = DEVICE(dev);
    dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,
                                                             dev->host_features[0]);
    virtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY);
    virtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE);
    MLT.refreshConsumer();
}",0,1,23,0.39,Insert
1959,,,,,,,
1962,"http_cleanup (void)
{
  xfree (pconn.host);
  if (wget_cookie_jar)
    cookie_jar_delete (wget_cookie_jar);
}","http_cleanup (void)
{
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      xfree (pconn.host);
  }
  if (wget_cookie_jar)
    cookie_jar_delete (wget_cookie_jar);
}",0,1,1,0.03,Replace
1964,"ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return LDNS_STATUS_WIRE_RDATA_ERR;
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}","ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		int size;
		const uint8_t *buf;
		const uint8_t *t, *p_ad;
		p_ad = buf + size;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		return LDNS_STATUS_WIRE_RDATA_ERR;
		}
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}",0,1,7,0.4,Insert
1967,,,,,,,
1968,"evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;
	EVBUFFER_LOCK(buf);
	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}
	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}
	EVBUFFER_UNLOCK(buf);
	return chain != NULL ? 0 : -1;
}","evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;
	EVBUFFER_LOCK(buf);
	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}
	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		int a = 2;
		int b = 2;
		while (a == b) {
    		struct platform_device *cpdevice;
    		struct mii_bus *bus;
    		struct unimac_mdio_pdata *pdata = cpdevice->dev.platform_data;
    		struct unimac_mdio_priv *priv;
    		struct resource *r;
    		priv = devm_kzalloc(&cpdevice->dev, sizeof(*priv), GFP_KERNEL);
    		priv->base = devm_ioremap(&cpdevice->dev, r->start, resource_size(r));
    		priv->mii_bus = mdiobus_alloc();
    		bus = priv->mii_bus;
    		bus->priv = priv;
    		pos->pos = -1;
    		b += 1;
		}
	}
	EVBUFFER_UNLOCK(buf);
	return chain != NULL ? 0 : -1;
}",1,0,48,1.16,Insert
1970,"TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}","TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        int a = 2;
        int b = 3;
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
        while (a != b) {
            upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
            b = a;
        }
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}",0,1,20,0.8,Insert
1971,,,,,,,
1972,"static inline void gen_op_movq_env_0(int d_offset)
{
    tcg_gen_movi_i64(cpu_tmp1_i64, 0);
    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);
}","static inline void gen_op_movq_env_0(int d_offset)
{
    int a = 82;
    int b = a;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    if(a*b>0){
        tcg_gen_movi_i64(cpu_tmp1_i64, 0);
    }
    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);
}",0,1,10,0.27,Insert
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    	int a = 2;
    	int b = 3;
    	if (a != b) {
        term_T	*term = (term_T *)user;
    	}
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    return 1;
}",0,1,15,0.74,Insert
1976,,,,,,,
1977,,,,,,,
1978,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");
    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");
    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");
    lua_pop(L, 1);
}","void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    int i, qa;
    qa = libusb_init(&ctx);
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        t = apr_pcalloc(c->pool, sizeof(req_table_t));
    }
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");
    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");
    lua_pop(L, 1);
}",0,1,29,0.63,Insert
1982,,,,,,,
1983,"int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;
	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;
	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;
	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);
	free(v);
	free(f);
	free(u);
	return rc;
}","int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)
{
	char *v = NULL, *f = NULL, *u = NULL;
	int rc;
	if (!fs)
		return -EINVAL;
	if (!optstr)
		return 0;
	rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);
	if (rc)
		return rc;
	if (!rc && v)
		rc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);
	if (!rc && f)
		rc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);
	if (!rc && u)
		rc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);
	if (!rc)
		rc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);
	free(v);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	free(f);
	strcpy(str, ""a"");
	}
	free(u);
	return rc;
}",0,1,4,0.13,Replace
1984,,,,,,,
1985,,,,,,,
1986,,,,,,,
1987,"ins_compl_len(void)
{
    return compl_length;
}","ins_compl_len(void)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return compl_length;
    strcpy(str, ""a"");
    }
}",0,1,1,0.02,Replace
1990,,,,,,,
1991," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	unsigned int thlen = 0;
	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);
		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		thlen = tcp_hdrlen(skb);
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	return thlen + shinfo->gso_size;"," */
unsigned int skb_gso_transport_seglen(const struct sk_buff *skb)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	PutBitContext pb, pb2;
	int comps;
	put_bits(&pb, 16, 8 + comps * 3);
	put_bits(&pb, 8, comps);
	put_bits(&pb, 16, 6 + comps * 2);
	put_bits(&pb, 8, comps);
	put_bits(&pb, 8, (comps > 1) ? 1 : 0);
	unsigned int thlen = 0;
	if (skb->encapsulation) {
		thlen = skb_inner_transport_header(skb) -
			skb_transport_header(skb);
		if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))
			thlen += inner_tcp_hdrlen(skb);
	} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		thlen = tcp_hdrlen(skb);
		}
	} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {
		thlen = sizeof(struct sctphdr);
	}
	return thlen + shinfo->gso_size;",0,1,9,0.49,Insert
1992,,,,,,,
1995,,,,,,,
1996,"static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;
	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);
	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}","static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;
	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);
	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
			Rocker *r;
			DescInfo *info;
			uint32_t port;
			int err_8 = ROCKER_OK;
			char *buf = desc_get_buf(info, true);
			struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
			PCIDevice *dev = PCI_DEVICE(r);
			int iovcnt = 0;
			uint32_t pport;
			pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
			err_8 = fp_port_eg(r->fp_port[port], iov, iovcnt);
	if (!err) {
		*path = nd->path;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		nd->path.mnt = NULL;
		}
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}",0,1,28,0.89,Insert
1997,,,,,,,
1998,"_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  error;
  if ( buffer->separate_out )
    {
      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
      if ( error )
	return error;
      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }
  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;
  return HB_Err_Ok;
}","_hb_buffer_next_glyph ( HB_Buffer buffer )
{
  HB_Error  error;
  if ( buffer->separate_out )
    {
      int a = 2;
      const base::Closure& flow;
      AioContext *ctx;
      bool blocking;
      int64_t timeout;
      timeout = blocking ? aio_compute_timeout(ctx) : 0;
      TaskParamsForDidGetQuota request;
      request.flow = flow;
      int b = 2;
      while (a == b) {
          error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );
          b += 1;
      }
      if ( error )
	return error;
      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];
    }
  buffer->in_pos++;
  buffer->out_pos++;
  buffer->out_length = buffer->out_pos;
  return HB_Err_Ok;
}",1,0,46,0.68,Insert
2002,"static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	return 0;
}","static int __init init_script_binfmt(void)
{
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_III
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
			goto out;
	}
	register_binfmt(&script_format);
	return 0;
}",0,1,5,0.12,Insert
2003,"static PHP_GINIT_FUNCTION(pcntl)
{
	memset(pcntl_globals, 0, sizeof(*pcntl_globals));
}","static PHP_GINIT_FUNCTION(pcntl)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	memset(pcntl_globals, 0, sizeof(*pcntl_globals));
    	int64_t timestamp;
    	int stream_index;
    	AVFormatContext *s;
    	TMVContext *tcver = s->priv_data;
    	int64_t pos;
    	pos = timestamp *
    	          (tcver->audio_chunk_size + tcver->video_chunk_size + tcver->padding);
    	tcver->stream_index = 0;
	}
}",1,0,7,0.22,Insert
2005,,,,,,,
2006,,,,,,,
2008,"static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	FIPS_cipher(&ctx, citmp, plaintext, 8);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return ret;
	}","static int FIPS_des3_test(void)
	{
	int ret = 0;
	unsigned char pltmp[8];
	unsigned char citmp[8];
    	unsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		              19,20,21,22,23,24};
    	unsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };
	EVP_CIPHER_CTX ctx;
	FIPS_cipher_ctx_init(&ctx);
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)
		goto err;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	FIPS_cipher(&ctx, citmp, plaintext, 8);
	}
	if (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)
		goto err;
	FIPS_cipher(&ctx, pltmp, citmp, 8);
	if (memcmp(pltmp, plaintext, 8))
		goto err;
	ret = 1;
	err:
	FIPS_cipher_ctx_cleanup(&ctx);
	return ret;
	}",0,1,3,0.11,Replace
2009,,,,,,,
2013,"    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8, const T& a9, const T& a10, const T& a11,
                              const T& a12) {
      CImg<T> r(13,1);
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8; r[9] = a9;
      r[10] = a10; r[11] = a11; r[12] = a12;
      return r;
    }","    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8, const T& a9, const T& a10, const T& a11,
                              const T& a12) {
      int a = 2;
      int b = 3;
      size_t ie_len;
      const u8 *IE;
      struct sk_buff *img;
      if (IE)
      		NLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);
      if (a != b) {
          CImg<T> r(13,1);
          VirtioCcwDevice *dev;
          Error *err = NULL;
          VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);
          DeviceState *parent = DEVICE(dev);
          if (k->realize) {
                  k->realize(dev, &err);
          }
      }
      const char
          *attribute,
          *content;
      char
          *p,
          *xml;
      double
          value;
      value=InterpretLocaleValue(content,&p);
      (void) value;
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8; r[9] = a9;
      int wb;
      AVCodecContext *ajcas;
      DCAContext *s = ajcas->priv_data;
      int num_core_channels = 0;
      int channels, full_channels;
      int channels, full_channels;
      num_core_channels = s->prim_channels;
      full_channels = channels = s->prim_channels + !!s->lfe;
      uint32_t lvcall;
      CPUState *env;
      unsigned int valpages;
      uint32_t r_cause;
      int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
      uint32_t tlb_vpn, tlb_pfn = 0;
      uint32_t tlb_vpn, tlb_pfn = 0;
      uint32_t pid, lo, hi;
      int set, match = 0;
      r_cause = env->sregs[SFR_R_MM_CAUSE];
      D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
      		  "" %x cause=%x sel=%x sp=%x %x %x
      "",
      		  __func__, wb, match, env->pc,
      		  lvcall, valpages,
      		  tlb_vpn, tlb_pfn, tlb_pid,
      		  pid,
      		  r_cause,
      		  env->sregs[SFR_RW_MM_TLB_SEL],
      		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
      r[10] = a10; r[11] = a11; r[12] = a12;
      return r;
    }",0,1,207,1.86,Insert
2014,"iter_new(struct module_qstate* qstate, int id)
{
	struct iter_qstate* iq = (struct iter_qstate*)regional_alloc(
		qstate->region, sizeof(struct iter_qstate));
	qstate->minfo[id] = iq;
	if(!iq)
		return 0;
	memset(iq, 0, sizeof(*iq));
	iq->state = INIT_REQUEST_STATE;
	iq->final_state = FINISHED_STATE;
	iq->an_prepend_list = NULL;
	iq->an_prepend_last = NULL;
	iq->ns_prepend_list = NULL;
	iq->ns_prepend_last = NULL;
	iq->dp = NULL;
	iq->depth = 0;
	iq->num_target_queries = 0;
	iq->num_current_queries = 0;
	iq->query_restart_count = 0;
	iq->referral_count = 0;
	iq->sent_count = 0;
	iq->ratelimit_ok = 0;
	iq->target_count = NULL;
	iq->wait_priming_stub = 0;
	iq->refetch_glue = 0;
	iq->dnssec_expected = 0;
	iq->dnssec_lame_query = 0;
	iq->chase_flags = qstate->query_flags;
	iq->qchase = qstate->qinfo;
	outbound_list_init(&iq->outlist);
	iq->minimise_count = 0;
	iq->timeout_count = 0;
	if (qstate->env->cfg->qname_minimisation)
		iq->minimisation_state = INIT_MINIMISE_STATE;
	else
		iq->minimisation_state = DONOT_MINIMISE_STATE;
	memset(&iq->qinfo_out, 0, sizeof(struct query_info));
	return 1;
}","iter_new(struct module_qstate* qstate, int id)
{
	struct iter_qstate* iq = (struct iter_qstate*)regional_alloc(
		qstate->region, sizeof(struct iter_qstate));
	qstate->minfo[id] = iq;
	if(!iq)
		return 0;
	memset(iq, 0, sizeof(*iq));
	iq->state = INIT_REQUEST_STATE;
	iq->final_state = FINISHED_STATE;
	iq->an_prepend_list = NULL;
	iq->an_prepend_last = NULL;
	iq->ns_prepend_list = NULL;
	iq->ns_prepend_last = NULL;
	iq->dp = NULL;
	iq->depth = 0;
	iq->num_target_queries = 0;
	iq->num_current_queries = 0;
	iq->query_restart_count = 0;
	iq->referral_count = 0;
	iq->sent_count = 0;
	iq->ratelimit_ok = 0;
	iq->target_count = NULL;
	iq->wait_priming_stub = 0;
	iq->refetch_glue = 0;
	iq->dnssec_expected = 0;
	iq->dnssec_lame_query = 0;
	iq->chase_flags = qstate->query_flags;
	iq->qchase = qstate->qinfo;
	outbound_list_init(&iq->outlist);
	iq->minimise_count = 0;
	iq->timeout_count = 0;
	if (qstate->env->cfg->qname_minimisation)
		iq->minimisation_state = INIT_MINIMISE_STATE;
	else
		iq->minimisation_state = DONOT_MINIMISE_STATE;
	int a = 2;
	int b = 2;
	while (a == b) {
    	MOVContext *c;
    	AVIOContext *pb;
    	uint8_t type[5] = {0};
    	avio_read(pb, type, 4);
    	av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
    	"",(char *)&type);
    	av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
    	memset(&iq->qinfo_out, 0, sizeof(struct query_info));
    	b += 1;
	}
	struct SYMBOL *s;
	if (!lyric_started) {
			lyric_started = 1;
			s->flags |= ABC_F_LYRIC_START;
	}
	return 1;
}",1,0,77,1.47,Insert
2015,"set_context_in_disassemble_cmd(expand_T *xp, char_u *arg)
{
    char_u	*p;
    xp->xp_context = EXPAND_DISASSEMBLE;
    xp->xp_pattern = arg;
    if (*arg != NUL && *(p = skiptowhite(arg)) != NUL)
    {
	xp->xp_context = EXPAND_USER_FUNC;
	xp->xp_pattern = skipwhite(p);
    }
}","set_context_in_disassemble_cmd(expand_T *xp, char_u *arg)
{
    	char str[] = ""Constant"";
    	while (strlen(str) > 5) {
        char_u	*p;
    	strcpy(str, ""a"");
    	Rocker *r;
    	DescInfo *info;
    	char *buf = desc_get_buf(info, true);
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	char *buf = desc_get_buf(info, true);
    	PCIDevice *dev = PCI_DEVICE(r);
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	uint32_t pport;
    	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    	}
    xp->xp_context = EXPAND_DISASSEMBLE;
    xp->xp_pattern = arg;
    if (*arg != NUL && *(p = skiptowhite(arg)) != NUL)
    {
	xp->xp_context = EXPAND_USER_FUNC;
	xp->xp_pattern = skipwhite(p);
    }
}",0,1,11,0.6,Insert
2016,"static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}","static inline void io_queue_link_head(struct io_kiocb *req)
{
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	status = -ENODEV;
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		io_double_put_req(req);
		strcpy(str, ""a"");
		}
	} else
		io_queue_sqe(req);
}",0,1,10,0.42,Insert
2021,"void blosc_set_blocksize(size_t size) {
  g_force_blocksize = (int32_t)size;
}","void blosc_set_blocksize(size_t size) {
  int a = 77;
  int b = a;
  int64_t unit;
  unsigned char c;
  double vals, mul, integral, fraction;
  mul = suffix_mul(c, unit);
  if(a*b>0){
      g_force_blocksize = (int32_t)size;
  }
}",0,1,5,0.22,Insert
2022,,,,,,,
2024,,,,,,,
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
    l_t2->image = p_image;
    l_t2->cp = p_cp;
    return l_t2;
}","opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
        b = a;
    }
    if (!l_t2) {
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        description=GetXMLTreeChild(table_iterator,""description"");
        levels=GetXMLTreeChild(table_iterator,""levels"");
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        return NULL;
    }
    l_t2->image = p_image;
    l_t2->cp = p_cp;
    return l_t2;
}",0,1,23,0.42,Insert
2031,"static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;
	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;
	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	orinoco_unlock(priv, &flags);
	if (err)
		return err;
	srq->value = val;
	srq->fixed = 0;
	return 0;
}","static int orinoco_ioctl_getsens(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *srq,
				 char *extra)
{
	struct orinoco_private *priv = ndev_priv(dev);
	hermes_t *hw = &priv->hw;
	u16 val;
	int err;
	unsigned long flags;
	if (!priv->has_sensitivity)
		return -EOPNOTSUPP;
	if (orinoco_lock(priv, &flags) != 0)
		return -EBUSY;
	err = hermes_read_wordrec(hw, USER_BAP,
				  HERMES_RID_CNFSYSTEMSCALE, &val);
	int a = 2;
	int b = 2;
	if (a == b) {
    	orinoco_unlock(priv, &flags);
	}
	if (err)
		return err;
	srq->value = val;
	srq->fixed = 0;
	return 0;
}",0,1,13,0.19,Replace
2033,,,,,,,
2034,"rsvg_new_tref (void)
{
    RsvgNodeTref *text;
    text = g_new (RsvgNodeTref, 1);
    _rsvg_node_init (&text->super);
    text->super.set_atts = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->super;
}","rsvg_new_tref (void)
{
    RsvgNodeTref *text;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct genl_family *feature;
    int hdrlen, cmp;
    hdrlen = GENL_HDRLEN + feature->hdrsize;
    if (strcmp(str1, str2) == 0) {
        text = g_new (RsvgNodeTref, 1);
        const char *filename;
        AVFormatContext *fmt_ctx;
        int ret, i;
        ret = open_input_file(&fmt_ctx, filename);
        nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));
        nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));
        selected_streams   = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));
    }
    _rsvg_node_init (&text->super);
    text->super.set_atts = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->super;
}",1,0,55,0.48,Insert
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    int a = 63;
    int b = a;
    if(a*b>0){
        const gchar *type = ""invalid message"";
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        xml=FileToString(filename,~0UL,exception);
        quantization_tables=NewXMLTree(xml,exception);
    }
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}",0,1,4,0.49,Insert
2036,,,,,,,
2038,"static inline bool cpu_has_vmx_msr_bitmap(void)
{
	return vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
}","static inline bool cpu_has_vmx_msr_bitmap(void)
{
	struct net_device *self;
	ether_setup(self);
	self->netdev_ops		= &ipgre_tap_netdev_ops;
	self->destructor 	= ipgre_dev_free;
	self->iflink		= 0;
	self->features		|= NETIF_F_NETNS_LOCAL;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
	}
}",0,1,13,0.22,Insert
2039,,,,,,,
2041,,,,,,,
2045,"static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);
	return 0;
}","static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);
	int a = 23;
	int b = a;
	if(a*b>0){
    	ChardevCommon *complex = backend->u.null;
    	CharDriverState *charrb;
    	charrb = qemu_chr_alloc(complex, erfp);
    	charrb->chr_write = null_chr_write;
    	charrb->explicit_be_open = true;
    	return 0;
	}
}",0,1,5,0.41,Insert
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);
	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *head)
{
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);
	int a = 2;
	int b = 2;
	if (a == b) {
    	kvfree(p);
	}
}",0,1,7,0.36,Insert
2049,"void Avahi::addService(int, int, const QString &name, const QString &type, const QString &domain, uint)
{
    if (isLocalDomain(domain) && !services.contains(name)) {
        AvahiService *srv=new AvahiService(name, type, domain);
        services.insert(name, srv);
        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));
    }
}","void Avahi::addService(int, int, const QString &name, const QString &type, const QString &domain, uint)
{
    Error **errp;
    BlkActionState *common;
    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);
    DriveBackup *backup;
    BlockDriverState *bs;
    Error *local_err = NULL;
    backup = common->action->u.drive_backup.data;
    bs = qmp_get_root_bs(backup->device, errp);
    do_drive_backup(backup, common->block_job_txn, &local_err);
    if (isLocalDomain(domain) && !services.contains(name)) {
        AvahiService *srv=new AvahiService(name, type, domain);
        int a = 2;
        int b = 3;
        while (a < b) {
            services.insert(name, srv);
            struct socket *pocket;
            int lf;
            struct pocket *work = pocket->work;
            struct sk_buff *skibb, *data_knbang;
            int status, status;
            int noblock = lf&MSG_DONTWAIT;
            skibb = skb_recv_datagram(work, lf, noblock, &status);
            skb_free_datagram(work, skibb);
            b = a;
        }
        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));
    }
}",1,0,720,4.0,Insert
2051,,,,,,,
2052,"  void maybeAllocTrailers() override {
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
    }
  }","  void maybeAllocTrailers() override {
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      int a = 2;
      int b = 3;
      AVFrame *f;
      AVCodecContext *attcmp;
      int *press, err;
      PerThreadContext *p = attcmp->thread_opaque;
      f->thread_opaque = press = allocate_progress(p);
      press[0] =
          press[1] = -1;
      while (a < b) {
          headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
          b = a;
      }
    }
  }",1,0,5,0.32,Insert
2053,"    static inline UClassID getStaticClassID() {
        return (UClassID)&fgClassID;
    }","    static inline UClassID getStaticClassID() {
        int a = 2;
        const v8::PropertyCallbackInfo<v8::Value>& py;
        from(py.Holder()->CreationContext());
        v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
        int b = 2;
        while (a == b) {
            return (UClassID)&fgClassID;
            b += 1;
        }
    }",0,1,5,0.22,Insert
2056,"findoprnd(QueryItem *ptr, int size)
{
	uint32		pos;
	pos = 0;
	findoprnd_recurse(ptr, &pos, size);
	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}","findoprnd(QueryItem *ptr, int size)
{
			int a = 31;
			int b = a;
			if(a*b>0){
    	uint32		pos;
			}
	pos = 0;
	findoprnd_recurse(ptr, &pos, size);
	if (pos != size)
		elog(ERROR, ""malformed tsquery: extra nodes"");
}",0,1,5,0.08,Replace
2057,"static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;
	*action = CHECKOUT_ACTION__NONE;
	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED:
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED:
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE:
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED:
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default:
		break;
	}
	return checkout_action_common(action, data, delta, NULL);
}","static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	struct edgeport_serial *serial;
	u8 *data_10;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	data_10 = kmalloc(1, GFP_KERNEL);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_10, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_10, 0x01);
	int error = 0;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	*action = CHECKOUT_ACTION__NONE;
	}
	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED:
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED:
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE:
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED:
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default:
		break;
	}
	return checkout_action_common(action, data, delta, NULL);
}",0,1,31,1.02,Insert
2059,,,,,,,
2062,,,,,,,
2064,,,,,,,
2066,"MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  register Image
    *curr,
    *next;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
  {
    if ( curr->columns != next->columns || curr->rows != next->rows
         || curr->page.x != next->page.x || curr->page.y != next->page.y )
      continue;
    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += next->delay*1000/next->ticks_per_second;
      next->ticks_per_second = 100L;
      next->delay = time*curr->ticks_per_second/1000;
      next->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}","MagickExport void RemoveDuplicateLayers(Image **images,
     ExceptionInfo *exception)
{
  SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
  SVGUseElement* useElement = nullptr;
  sPAPRPHBState *sphb;
  void *fdt;
  PCIDevice *dev;
  int offset;
  uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);
  uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);
  _FDT(fdt_setprop_cell(fdt, offset, ""vendor-id"",
                            pci_default_read_config(dev, PCI_VENDOR_ID, 2)));
  _FDT(fdt_setprop_cell(fdt, offset, ""device-id"",
                            pci_default_read_config(dev, PCI_DEVICE_ID, 2)));
  _FDT(fdt_setprop_cell(fdt, offset, ""revision-id"",
                            pci_default_read_config(dev, PCI_REVISION_ID, 1)));
  _FDT(fdt_setprop_cell(fdt, offset, ""class-code"", ccode));
  _FDT(fdt_setprop_cell(fdt, offset, ""cache-line-size"",
          pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));
  if (isSVGUseElement(*element)) {
          useElement = toSVGUseElement(element);
          AVCodec *codec = NULL;
          AVCodecParameters *origin_par = NULL;
          AVFormatContext *fmt_ctx = NULL;
          int result;
          int video_stream;
          AVCodecContext *ctx= NULL;
          origin_par = fmt_ctx->streams[video_stream]->codecpar;
          codec = avcodec_find_decoder(origin_par->codec_id);
          ctx = avcodec_alloc_context3(codec);
          result = avcodec_parameters_to_context(ctx, origin_par);
          result = avcodec_open2(ctx, codec, NULL);
      } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
          SVGElement* correspondingElement = element->correspondingElement();
          if (isSVGUseElement(correspondingElement))
              useElement = toSVGUseElement(correspondingElement);
  }
  register Image
    *curr,
    *next;
  RectangleInfo
    bounds;
  assert((*images) != (const Image *) NULL);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      assert((*images)->signature == MagickCoreSignature);
  strcpy(str, ""a"");
  }
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  curr=GetFirstImageInList(*images);
  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
  {
    if ( curr->columns != next->columns || curr->rows != next->rows
         || curr->page.x != next->page.x || curr->page.y != next->page.y )
      continue;
    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
    if ( bounds.x < 0 ) {
      size_t time;
      time = curr->delay*1000/curr->ticks_per_second;
      time += next->delay*1000/next->ticks_per_second;
      next->ticks_per_second = 100L;
      next->delay = time*curr->ticks_per_second/1000;
      next->iterations = curr->iterations;
      *images = curr;
      (void) DeleteImageFromList(images);
    }
  }
  *images = GetFirstImageInList(*images);
}",1,0,865,5.36,Insert
2068,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;
	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);
	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;
	return true;
}","bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	void *rma = NULL;
	hwaddr rma_alloc_size;
	MemoryRegion *sysmem = get_system_memory();
	MemoryRegion *rma_region;
	if (rma_alloc_size && rma) {
	        rma_region = g_new(MemoryRegion, 1);
	        memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",
	                                   rma_alloc_size, rma);
	        vmstate_register_ram_global(rma_region);
	        memory_region_add_subregion(sysmem, 0, rma_region);
	}
	if (!att)
		return false;
	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);
	att->debug_callback = callback;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	att->debug_destroy = destroy;
	}
	att->debug_data = user_data;
	return true;
}",0,1,10,0.35,Insert
2070,,,,,,,
2071,"char *enl_ipc_get(const char *msg_data)
{
	static char *message = NULL;
	static unsigned short len = 0;
	char buff[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;
	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}","char *enl_ipc_get(const char *msg_data)
{
	static char *message = NULL;
	static unsigned short len = 0;
	char buff[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;
	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	MOVTrack *track;
	AVIOContext *pb;
	int64_t pos = avio_tell(pb);
	mov_write_stsz_tag(pb, track);
	mov_write_stco_tag(pb, track);
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		int a = 68;
		int b = a;
		if(a*b>0){
    		D((""Received complete reply:  \""%s\""\n"", ret_msg));
		}
	}
	return(ret_msg);
}",1,0,54,1.17,Insert
2072,"xfs_alloc_compute_maxlevels(
	xfs_mount_t	*mp)
{
	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}","xfs_alloc_compute_maxlevels(
	xfs_mount_t	*mp)
{
	CPUState *viron;
	qemu_irq *irq;
	QEMUBH *rb;
	rb = qemu_bh_new(tick_irq, viron);
	rb = qemu_bh_new(stick_irq, viron);
	rb = qemu_bh_new(hstick_irq, viron);
	irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}",0,1,5,0.22,Insert
2075,"int ip_mc_check_igmp(struct sk_buff *skb)
{
	int ret = ip_mc_check_iphdr(skb);
	if (ret < 0)
		return ret;
	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;
	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;
	return ip_mc_check_igmp_msg(skb);
}","int ip_mc_check_igmp(struct sk_buff *skb)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int ret = ip_mc_check_iphdr(skb);
	strcpy(str, ""a"");
	char *filename;
	long load_limit, rtas_limit, fw_size;
	rtas_limit = MIN(spapr->rma_size, 0x80000000);
	spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	}
	if (ret < 0)
		return ret;
	if (ip_hdr(skb)->protocol != IPPROTO_IGMP)
		return -ENOMSG;
	ret = ip_mc_check_igmp_csum(skb);
	if (ret < 0)
		return ret;
	return ip_mc_check_igmp_msg(skb);
}",0,1,15,0.5,Insert
2076,,,,,,,
2078,,,,,,,
2082,,,,,,,
2083,"PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;
	packet = php_wddx_constructor();
	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	if (newlen) {
		*newlen = strlen(*newstr);
	}
	return SUCCESS;
}","PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	struct sem_undo_list *utm;
	int other;
	struct sem_undo *relation, *news;
	other = get_undo_list(&utm);
	spin_lock(&utm->lock);
	relation = lookup_undo(utm, second);
	spin_unlock(&utm->lock);
	spin_lock(&utm->lock);
	wddx_packet *packet;
	PS_ENCODE_VARS;
	packet = php_wddx_constructor();
	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	if (newlen) {
		*newlen = strlen(*newstr);
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	return SUCCESS;
    	b = a;
    	struct sockaddr *uaddr;
    	struct sock *shop;
    	struct inet_sock *inet = inet_sk(shop);
    	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
    	lock_sock(shop);
    	sk_dst_reset(shop);
    	l2tp_ip_sk(shop)->conn_id = addr->l2tp_conn_id;
    	sk_add_bind_node(shop, &l2tp_ip_bind_table);
    	sk_del_node_init(shop);
	}
}",1,0,63,0.91,Insert
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
		struct sk_buff *skb;
		struct sock *sk;
		struct tcp_sock *tp = tcp_sk(sk);
		u32 length, end64seq;
		struct tcp_sock *tp = tcp_sk(sk);
		u32 length, end64seq;
		SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
		"",
				   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
		length = TCP_SKB_CB(skb)->length;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	int a = 2;
	int b = 3;
	while (a < b) {
    	return 0;
    	b = a;
	}
}",0,1,4,0.37,Insert
2085,,,,,,,
2086,"NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}","NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  DisasContext *qs;
  uint32_t ksns;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  unsigned int coll, order, err, resp, coll, p, nzcv;
  order = extract32(ksns, 22, 2);
  handle_fp_compare(qs, order, coll, err, false, p);
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    int a = 2;
    int b = 2;
    while (a == b) {
        v = jspeBlockOrStatement();
        b += 1;
    }
  }
  return v;
}",0,1,10,0.36,Insert
2087,"static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)
{
	return pmd_write(pmd) ||
	       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));
}","static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)
{
	struct socket *sock;
	int codes;
	struct sock *shop = sock->shop;
	struct sk_buff *skb;
	skb = skb_recv_datagram(shop, codes & ~MSG_DONTWAIT,
					codes & MSG_DONTWAIT, &err);
	return pmd_write(pmd) ||
	       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));
}",1,0,4,0.19,Insert
2088,"static unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)
{
	if (size == SBUS_MMAP_EMPTY) return 0;
	if (size >= 0) return size;
	return fbsize * (-size);
}","static unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)
{
	struct sk_buff *skb;
	struct sock *sk;
	struct tcp_sock *tp = tcp_sk(sk);
	u32 length, end64seq;
	struct tcp_sock *tp = tcp_sk(sk);
	u32 length, end64seq;
	SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
	"",
			   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
	length = TCP_SKB_CB(skb)->length;
	if (size == SBUS_MMAP_EMPTY) return 0;
	if (size >= 0) return size;
	return fbsize * (-size);
}",0,1,7,0.19,Insert
2091,,,,,,,
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;
    s->new_session = 1;
    return (s->method->ssl_renegotiate(s));
}","int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;
    s->new_session = 1;
    int a = 2;
    int b = 3;
    while (a != b) {
        return (s->method->ssl_renegotiate(s));
        b = a;
    }
}",0,1,2,0.04,Replace
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	int a = 2;
	int b = 3;
	if (a != b) {
    	semsg(_(e_string_required_for_argument_nr), idx + 1);
    	V9fsPath *fs_path;
    	FsContext *FS_path;
    	int fd, ret;
    	struct handle_data *parent = (struct handle_data *)FS_path->private;
    	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	}
	return FAIL;
    }
    return OK;
}",0,1,12,0.59,Insert
2095,"R_API char *r_egg_option_get(REgg *egg, const char *key) {
	return sdb_get (egg->db, key, NULL);
}","R_API char *r_egg_option_get(REgg *egg, const char *key) {
	Unit *uci;
	const char *key_2;
	assert(key_2);
	(void) hashmap_remove_value(uci->manager->watch_bus, key_2, uci);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return sdb_get (egg->db, key, NULL);
	}
}",0,1,4,0.28,Insert
2099,"void rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,
		       unsigned int act_id, int *reset, struct file_activity *file_actlst,
		       struct tm *rectime, struct tm *loctime, char *file,
		       struct file_magic *file_magic)
{
	int rtype;
	int next, reset_cd;
	seek_file_position(ifd, DO_RESTORE);
	if (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {
		list_fields(act_id);
	}
	copy_structures(act, id_seq, record_hdr, !*curr, 2);
	*cnt  = count;
	reset_cd = 1;
	do {
		*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,
					  *curr, file, &rtype, 0, file_magic,
					  file_actlst, rectime, loctime, UEOF_STOP);
		if (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {
			next = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,
						   NULL, rectime, loctime, reset_cd, act_id);
			reset_cd = 0;
			if (next) {
				*curr ^= 1;
				if (*cnt > 0) {
					(*cnt)--;
				}
			}
			*reset = FALSE;
		}
	}
	while (*cnt && !*eosaf && (rtype != R_RESTART));
	*reset = TRUE;
}","void rw_curr_act_stats(int ifd, int *curr, long *cnt, int *eosaf,
		       unsigned int act_id, int *reset, struct file_activity *file_actlst,
		       struct tm *rectime, struct tm *loctime, char *file,
		       struct file_magic *file_magic)
{
	int rtype;
	int next, reset_cd;
	seek_file_position(ifd, DO_RESTORE);
	if (DISPLAY_FIELD_LIST(fmt[f_position]->options)) {
		list_fields(act_id);
	}
	copy_structures(act, id_seq, record_hdr, !*curr, 2);
	*cnt  = count;
	reset_cd = 1;
	do {
		*eosaf = read_next_sample(ifd, IGNORE_RESTART | DONT_READ_CPU_NR,
					  *curr, file, &rtype, 0, file_magic,
					  file_actlst, rectime, loctime, UEOF_STOP);
		if (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {
			next = generic_write_stats(*curr, tm_start.use, tm_end.use, *reset, cnt,
						   NULL, rectime, loctime, reset_cd, act_id);
			reset_cd = 0;
			if (next) {
				char str[] = ""Constant"";
				while (strlen(str) > 5) {
    				*curr ^= 1;
				strcpy(str, ""a"");
				}
				if (*cnt > 0) {
					(*cnt)--;
				}
			}
			*reset = FALSE;
		}
	}
	while (*cnt && !*eosaf && (rtype != R_RESTART));
	*reset = TRUE;
}",0,1,19,0.28,Replace
2105,"source_level(void *cookie)
{
    return ((source_cookie_T *)cookie)->level;
}","source_level(void *cookie)
{
    int a = 2;
    int b = 2;
    PutBitContext pb, pb2;
    int i, size, ure;
    int comps;
    for (i = 1; i <= comps; i++) {
            put_bits(&pb, 8, i);
            put_bits(&pb, 8, 0);
    }
    if (a == b) {
        return ((source_cookie_T *)cookie)->level;
    }
}",0,1,8,0.19,Insert
2107,,,,,,,
2108,"DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,
                                  RandomNumberGenerator& rng)
   {
   const BigInt& q = m_group.get_q();
   BigInt i(msg, msg_len, q.bits());
   while(i >= q)
      i -= q;
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
   BOTAN_UNUSED(rng);
   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);
#else
   const BigInt k = BigInt::random_integer(rng, 1, q);
#endif
   BigInt s = inverse_mod(k, q);
   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));
   s = m_mod_q.multiply(s, mul_add(m_x, r, i));
   if(r.is_zero() || s.is_zero())
      throw Internal_Error(""Computed zero r/s during DSA signature"");
   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());
   }","DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,
                                  RandomNumberGenerator& rng)
   {
   int a = 2;
   int b = 3;
   while (a != b) {
       const BigInt& q = m_group.get_q();
       b = a;
   }
   MOVTrack *track;
   MOVTrack *track_5;
   AVIOContext *pb_10;
   int64_t pos_3 = avio_tell_10(pb_10);
   mov_write_stsd_tag_5(pb_10, track_5);
   mov_write_stts_tag_8(pb_10, track_5);
   mov_write_stsc_tag_10(pb_10, track_5);
   mov_write_stsz_tag_10(pb_10, track_5);
   mov_write_stco_tag_8(pb_10, track_5);
   AVIOContext *pb;
   int64_t pos = avio_tell(pb);
   mov_write_stsd_tag(pb, track);
   mov_write_stts_tag(pb, track);
   struct vhost_dev *hdev;
   int i_2, r_4;
   NvmeCtrl *n;
   uint16_t cqid = le16_to_cpu(c->cqid);
   uint16_t qsize = le16_to_cpu(c->qsize);
   uint64_t prp1 = le64_to_cpu(c->prp1);
   NvmeSQueue * seq;
   uint16_t sqid = le16_to_cpu(c->sqid);
   seq = g_malloc0(sizeof(* seq));
   nvme_init_sq( seq, n, prp1, sqid, cqid, qsize + 1);
   int i_2, r_4;
   for (i_2 = 0; i_2 < hdev->nvqs; ++i_2) {
           r_4 = vhost_virtqueue_init(hdev, hdev->vqs + i_2, hdev->vq_index + i_2);
           if (r_4 < 0) {
               goto fail_vq;
           }
   }
   mov_write_stsc_tag(pb, track);
   mov_write_stsz_tag(pb, track);
   mov_write_stco_tag(pb, track);
   BigInt i(msg, msg_len, q.bits());
   while(i >= q)
      i -= q;
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
   BOTAN_UNUSED(rng);
   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);
#else
   const BigInt k = BigInt::random_integer(rng, 1, q);
#endif
   BigInt s = inverse_mod(k, q);
   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));
   s = m_mod_q.multiply(s, mul_add(m_x, r, i));
   if(r.is_zero() || s.is_zero())
      throw Internal_Error(""Computed zero r/s during DSA signature"");
   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());
   }",1,0,121,1.5,Insert
2111,,,,,,,
2112,,,,,,,
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000""));
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000""));
        strcpy(str, ""a"");
        }
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}",0,1,3,0.08,Replace
2116,"static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;
	if (--header->nreg)
		return;
	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);
	if (parent)
		drop_sysctl_table(&parent->header);
}","static void drop_sysctl_table(struct ctl_table_header *header)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct ctl_dir *parent = header->parent;
    	b += 1;
	}
	if (--header->nreg)
		return;
	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);
	if (parent)
		drop_sysctl_table(&parent->header);
}",1,0,6,0.09,Replace
2117,,,,,,,
2118,"rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    return rb_str_buf_cat(str, ptr, strlen(ptr));
}","rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    return rb_str_buf_cat(str, ptr, strlen(ptr));
}",0,1,6,0.19,Insert
2120,,,,,,,
2122,"static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}","static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	int a = 2;
	int b = 3;
	while (a != b) {
    	spin_lock(&vmx_vpid_lock);
    	b = a;
	}
	const v8::PropertyCallbackInfo<v8::Value>& py;
	from(py.Holder()->CreationContext());
	v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}",0,1,7,0.28,Insert
2127,"UsbHubCtrlGetSuperSpeedHubDesc (
  IN  USB_DEVICE          *HubDev,
  OUT VOID                *Buf
  )
{
  EFI_STATUS              Status;
  Status = EFI_INVALID_PARAMETER;
  Status = UsbCtrlRequest (
             HubDev,
             EfiUsbDataIn,
             USB_REQ_TYPE_CLASS,
             USB_HUB_TARGET_HUB,
             USB_HUB_REQ_GET_DESC,
             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),
             0,
             Buf,
             32
             );
  return Status;
}
","UsbHubCtrlGetSuperSpeedHubDesc (
  IN  USB_DEVICE          *HubDev,
  OUT VOID                *Buf
  )
{
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      EFI_STATUS              Status;
  }
  Status = EFI_INVALID_PARAMETER;
  Status = UsbCtrlRequest (
             HubDev,
             EfiUsbDataIn,
             USB_REQ_TYPE_CLASS,
             USB_HUB_TARGET_HUB,
             USB_HUB_REQ_GET_DESC,
             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),
             0,
             Buf,
             32
             );
  return Status;
}
",1,0,2,0.11,Replace
2128,"static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi &&
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}","static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  int a = 2;
  int b = 2;
  const struct sun4d_hwdef *hawdecl;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  unsigned int i;
  for (i = 0; i < MAX_IOBITS; i++)
          if (hawdecl->iounit_bases[i] != (target_phys_addr_t)-1)
              ioulits[i] = iommu_init(hawdecl->iounit_bases[i],
                                      hawdecl->iounit_version,
                                      sbi_arqu[hawdecl->me_irq]);
  while (a == b) {
      var->type= SHOW_MY_BOOL;
      b += 1;
  }
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi &&
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}",0,1,21,0.4,Insert
2129,"static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}","static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	OPJ_UINT32 l_max_Puc = 0;
	OPJ_UINT32 ui;
	opj_tcp_t * l_pitch = 00;
	for (ui=0;ui<l_nb_tiles;++ui) {
	                l_max_Puc = opj_uint_max(l_max_Puc,l_pitch->numpocs);
	                ++l_pitch;
	}
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}",0,1,5,0.35,Insert
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}
	return GF_OK;
}","GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	int a = 2;
	int b = 2;
	if (a == b) {
    	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	}
	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
		AnimationChannel &context;
		json &o;
		SerializeNumberProperty(""sampler"", context.sampler, o);
		SerializeExtensionMap(context.extensions, o);
	}
	return GF_OK;
}",0,1,17,0.76,Insert
2131,"launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;
  if (options->DisableNetwork)
    return;
  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);
    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}","launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  char str_1[] = ""Constant"";
  if (strlen(str_1) > 0) {
      struct evdns_request *req;
  }
  (void)fd;
  (void)event;
  (void)args;
  if (options->DisableNetwork)
    return;
  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);
    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}",0,1,1,0.14,Replace
2134,"failure_log(address_item * addr, uschar * driver_kind, uschar * now)
{
void * reset_point;
gstring * g = reset_point = string_get(256);
g = string_log_address(g, addr, LOGGING(all_parents), FALSE);
if (LOGGING(sender_on_delivery))
  g = string_append(g, 3, US"" F=<"", sender_address, US"">"");
if (*queue_name)
  g = string_append(g, 2, US"" Q="", queue_name);
if (used_return_path && LOGGING(return_path_on_delivery))
  g = string_append(g, 3, US"" P=<"", used_return_path, US"">"");
if (addr->router)
  g = string_append(g, 2, US"" R="", addr->router->name);
if (addr->transport)
  g = string_append(g, 2, US"" T="", addr->transport->name);
if (addr->host_used)
  g = d_hostlog(g, addr);
#ifdef SUPPORT_TLS
g = d_tlslog(g, addr);
#endif
if (addr->basic_errno > 0)
  g = string_append(g, 2, US"": "", US strerror(addr->basic_errno));
if (addr->message)
  g = string_append(g, 2, US"": "", addr->message);
(void) string_from_gstring(g);
if (driver_kind)
  deliver_msglog(""%s %s failed for %s\n"", now, driver_kind, g->s);
else
  deliver_msglog(""%s %s\n"", now, g->s);
log_write(0, LOG_MAIN, ""** %s"", g->s);
#ifndef DISABLE_EVENT
msg_event_raise(US""msg:fail:delivery"", addr);
#endif
store_reset(reset_point);
return;
}","failure_log(address_item * addr, uschar * driver_kind, uschar * now)
{
void * reset_point;
gstring * g = reset_point = string_get(256);
g = string_log_address(g, addr, LOGGING(all_parents), FALSE);
if (LOGGING(sender_on_delivery))
  g = string_append(g, 3, US"" F=<"", sender_address, US"">"");
if (*queue_name)
  g = string_append(g, 2, US"" Q="", queue_name);
if (used_return_path && LOGGING(return_path_on_delivery))
  g = string_append(g, 3, US"" P=<"", used_return_path, US"">"");
if (addr->router)
  g = string_append(g, 2, US"" R="", addr->router->name);
if (addr->transport)
  g = string_append(g, 2, US"" T="", addr->transport->name);
if (addr->host_used)
  g = d_hostlog(g, addr);
  int i, size, ure;
  uint8_t *uf8 = NULL;
  GetBitContext gb;
  init_get_bits(&gb, uf8, size);
#ifdef SUPPORT_TLS
g = d_tlslog(g, addr);
#endif
if (addr->basic_errno > 0)
  g = string_append(g, 2, US"": "", US strerror(addr->basic_errno));
if (addr->message)
  g = string_append(g, 2, US"": "", addr->message);
(void) string_from_gstring(g);
if (driver_kind)
  deliver_msglog(""%s %s failed for %s\n"", now, driver_kind, g->s);
else
  deliver_msglog(""%s %s\n"", now, g->s);
log_write(0, LOG_MAIN, ""** %s"", g->s);
#ifndef DISABLE_EVENT
msg_event_raise(US""msg:fail:delivery"", addr);
#endif
store_reset(reset_point);
return;
}",0,1,14,1.55,Insert
2136,"static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;
	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;
	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;
	return 1;
}","static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;
	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;
	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;
		const v8::PropertyCallbackInfo<v8::Value>& py;
		from(py.Holder()->CreationContext());
		v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 1;
	strcpy(str, ""a"");
	}
}",0,1,4,0.35,Insert
2138,,,,,,,
2141,,,,,,,
2142,,,,,,,
2143,"int am_check_url(request_rec *r, const char *url)
{
    const char *i;
    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }
    return OK;
}","int am_check_url(request_rec *r, const char *url)
{
    const char *i;
    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            AVCodec *codec;
            AVStream *st;
            AVCodecContext *c;
            st = av_new_stream(oc, 1);
            c = &st->codec;
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }
    return OK;
}",1,0,9,0.36,Insert
2144,"TPM_CAP_Unmarshal(TPM_CAP *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT32_Unmarshal(target, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case TPM_CAP_ALGS:
	  case TPM_CAP_HANDLES:
	  case TPM_CAP_COMMANDS:
	  case TPM_CAP_PP_COMMANDS:
	  case TPM_CAP_AUDIT_COMMANDS:
	  case TPM_CAP_PCRS:
	  case TPM_CAP_TPM_PROPERTIES:
	  case TPM_CAP_PCR_PROPERTIES:
	  case TPM_CAP_ECC_CURVES:
	  case TPM_CAP_AUTH_POLICIES:
	  case TPM_CAP_ACT:
	  case TPM_CAP_VENDOR_PROPERTY:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPM_CAP_Unmarshal(TPM_CAP *target, BYTE **buffer, INT32 *size)
{
    multipart_parser_data_t this;
    if (this.header_field)
            ogs_free(this.header_field);
    TPM_RC rc = TPM_RC_SUCCESS;
    Pender pre_transformed_filter_backprop;
    const Pender& input = package->input(0);
    VncState *vs;
    VncShareMode mode;
    vnc_set_share_mode(vs, mode);
    vs->client_width = surface_width(vs->vd->ds);
    vs->client_height = surface_height(vs->vd->ds);
    vnc_write_u16(vs, vs->client_width);
    vnc_write_u16(vs, vs->client_height);
    OP_REQUIRES_OK(package,
                       package->allocate_temp(DataTypeToEnum<T>::value, dst_shape,
                                              &pre_transformed_filter_backprop));
    if (rc == TPM_RC_SUCCESS) {
	MOVContext *c_9;
	AVIOContext *pb_10;
	uint32_t minor_ver_4;
	char minor_ver_str_6[11];
	minor_ver_4 = avio_rb32_5(pb_10);
	snprintf_9(minor_ver_str_6, sizeof(minor_ver_str_6), ""%""PRIu32_1"""", minor_ver_4);
	av_dict_set_7(&c_9->fc->metadata, ""minor_version"", minor_ver_str_6, 0);
	int a = 2;
	int b = 2;
	MOVContext *c_5;
	AVIOContext *pb_1;
	uint32_t minor_ver;
	char minor_ver_str[11];
	struct timeval t1, t2;
	struct timeval t1, t2;
	gettimeofday(&t1, NULL);
	t2 = tsub(t2, t1);
	minor_ver = avio_rb32(pb_1);
	snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
	av_dict_set_10(&c_5->fc->metadata, ""minor_version"", minor_ver_str, 0);
	while (a == b) {
    	rc = UINT32_Unmarshal(target, buffer, size);
    	b += 1;
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case TPM_CAP_ALGS:
	  case TPM_CAP_HANDLES:
	  MOVContext *c;
	  AVIOContext *pb;
	  int comp_brand_size;
	  char* comp_brands_str;
	  comp_brands_str = av_malloc(comp_brand_size + 1);
	  avio_read(pb, comp_brands_str, comp_brand_size);
	  comp_brands_str[comp_brand_size] = 0;
	  av_dict_set(&c->fc->metadata, ""compatible_brands"", comp_brands_str, 0);
	  av_freep(&comp_brands_str);
	  case TPM_CAP_COMMANDS:
	  case TPM_CAP_PP_COMMANDS:
	  case TPM_CAP_AUDIT_COMMANDS:
	  case TPM_CAP_PCRS:
	  case TPM_CAP_TPM_PROPERTIES:
	  case TPM_CAP_PCR_PROPERTIES:
	  case TPM_CAP_ECC_CURVES:
	  case TPM_CAP_AUTH_POLICIES:
	  case TPM_CAP_ACT:
	  case TPM_CAP_VENDOR_PROPERTY:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    u32 time;
    struct sk_buff *skb;
    u32 pid;
    struct prefix_info *copinfo;
    int frame;
    unsigned int flags;
    struct prefixmsg	*lpMsg;
    struct prefix_cacheinfo	cli;
    struct nlmsghdr 	*nlh;
    unsigned char		*bf = skb->tail;
    nlh = NLMSG_NEW(skb, pid, time, frame, sizeof(*lpMsg), flags);
    cli.preferred_time = ntohl(copinfo->prefered);
    cli.valid_time = ntohl(copinfo->valid);
    return rc;
}",1,0,1386,7.13,Insert
2145,"void rose_start_heartbeat(struct sock *sk)
{
	del_timer(&sk->sk_timer);
	sk->sk_timer.function = rose_heartbeat_expiry;
	sk->sk_timer.expires  = jiffies + 5 * HZ;
	add_timer(&sk->sk_timer);
}","void rose_start_heartbeat(struct sock *sk)
{
	del_timer(&sk->sk_timer);
	AVCodec *c;
	int encoder;
	const char *codec_string = encoder ? ""encoder"" : ""decoder"";
	const char *codec_string = encoder ? ""encoder"" : ""decoder"";
	AVCodec *codec;
	av_log(NULL, AV_LOG_FATAL, ""%s '%s' is experimental and might produce bad ""
	            ""results.
	Add '-strict experimental' if you want to use it.
	"",
	            codec_string, c->name);
	codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);
	sk->sk_timer.function = rose_heartbeat_expiry;
	int a = 74;
	int b = a;
	if(a*b>0){
    	sk->sk_timer.expires  = jiffies + 5 * HZ;
	}
	add_timer(&sk->sk_timer);
}",1,0,19,0.39,Insert
2148,"	switch (yych) {
		case 'a': goto yy37;
		default: goto yy36;
	}","	switch (yych) {
		int a = 2;
		int b = 3;
		while (a < b) {
    		case 'a': goto yy37;
    		b = a;
    		FILE * trace;
    		GF_Box *a_5;
    		GF_HandlerBox *p = (GF_HandlerBox *)a_5;
    		if (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {
    				fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);
    			} else {
    				fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8);
    		}
		}
		default: goto yy36;
	}",1,0,9,0.24,Insert
2149,"void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}","void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  int a = 2;
  int b = 3;
  while (a != b) {
      const char *nptr;
      double vals, mul, integral, fraction;
      char *ndpointer;
      unsigned char c;
      vals = strtod(nptr, &ndpointer);
      c = *ndpointer;
      has_prelocking_list= thd->lex->requires_prelocking();
      b = a;
  }
}",0,1,6,0.34,Insert
2151,"irqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(wait, struct kvm_kernel_irqfd, wait);
	unsigned long flags = (unsigned long)key;
	struct kvm_kernel_irq_routing_entry irq;
	struct kvm *kvm = irqfd->kvm;
	unsigned seq;
	int idx;
	if (flags & POLLIN) {
		idx = srcu_read_lock(&kvm->irq_srcu);
		do {
			seq = read_seqcount_begin(&irqfd->irq_entry_sc);
			irq = irqfd->irq_entry;
		} while (read_seqcount_retry(&irqfd->irq_entry_sc, seq));
		if (kvm_arch_set_irq_inatomic(&irq, kvm,
					      KVM_USERSPACE_IRQ_SOURCE_ID, 1,
					      false) == -EWOULDBLOCK)
			schedule_work(&irqfd->inject);
		srcu_read_unlock(&kvm->irq_srcu, idx);
	}
	if (flags & POLLHUP) {
		unsigned long flags;
		spin_lock_irqsave(&kvm->irqfds.lock, flags);
		if (irqfd_is_active(irqfd))
			irqfd_deactivate(irqfd);
		spin_unlock_irqrestore(&kvm->irqfds.lock, flags);
	}
	return 0;
}","irqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)
{
	struct kvm_kernel_irqfd *irqfd =
		container_of(wait, struct kvm_kernel_irqfd, wait);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	unsigned long flags = (unsigned long)key;
	}
	struct kvm_kernel_irq_routing_entry irq;
	struct kvm *kvm = irqfd->kvm;
	unsigned seq;
	int idx;
	if (flags & POLLIN) {
		idx = srcu_read_lock(&kvm->irq_srcu);
		do {
			seq = read_seqcount_begin(&irqfd->irq_entry_sc);
			irq = irqfd->irq_entry;
		} while (read_seqcount_retry(&irqfd->irq_entry_sc, seq));
		if (kvm_arch_set_irq_inatomic(&irq, kvm,
					      KVM_USERSPACE_IRQ_SOURCE_ID, 1,
					      false) == -EWOULDBLOCK)
			schedule_work(&irqfd->inject);
		srcu_read_unlock(&kvm->irq_srcu, idx);
	}
	if (flags & POLLHUP) {
		unsigned long flags;
		spin_lock_irqsave(&kvm->irqfds.lock, flags);
		if (irqfd_is_active(irqfd))
			irqfd_deactivate(irqfd);
		spin_unlock_irqrestore(&kvm->irqfds.lock, flags);
	}
	return 0;
}",0,1,2,0.16,Replace
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	char str[] = ""Constant"";
	u64 id;
	struct blkif_response *resp;
	resp->id        = id;
	if (strlen(str) > 0) {
    	curseg->alloc_type = LFS;
	}
}",0,1,17,0.75,Insert
2153,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    diff = int128_sub(section->mr->size, int128_make64(addr));
    int a = 2;
    int b = 3;
    if (a != b) {
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}",1,0,1,0.06,Replace
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                                ","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_RecordQueryVersion:
        int a = 2;
        int b = 3;
        while (a < b) {
            return ProcRecordQueryVersion(client);
            b = a;
        }
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                                ",0,1,1,0.11,Replace
2155,"PHP_FUNCTION(locale_accept_from_http)
{
	UEnumeration *available;
	char *http_accept = NULL;
	int http_accept_len;
	UErrorCode status = 0;
	int len;
	char resultLocale[INTL_MAX_LOCALE_LEN+1];
	UAcceptResult outResult;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &http_accept, &http_accept_len) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
		""locale_accept_from_http: unable to parse input parameters"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	available = ures_openAvailableLocales(NULL, &status);
	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to retrieve locale list"");
	len = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,
						&outResult, http_accept, available, &status);
	uenum_close(available);
	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to find acceptable locale"");
	if (len < 0 || outResult == ULOC_ACCEPT_FAILED) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(resultLocale, len, 1);
}","PHP_FUNCTION(locale_accept_from_http)
{
	int			nbKeys;
	HStore	   *params;
	if (nbKeys == 0)
		{
			params = hstorePairs(NULL, 0, 0);
			PG_RETURN_POINTER(params);
	}
	UEnumeration *available;
	char *http_accept = NULL;
	int http_accept_len;
	UErrorCode status = 0;
	int len;
	int a = 2;
	int b = 2;
	while (a == b) {
    	char resultLocale[INTL_MAX_LOCALE_LEN+1];
    	b += 1;
	}
	UAcceptResult outResult;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &http_accept, &http_accept_len) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
		""locale_accept_from_http: unable to parse input parameters"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	available = ures_openAvailableLocales(NULL, &status);
	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to retrieve locale list"");
	len = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,
						&outResult, http_accept, available, &status);
						MOVTrack *track;
						MOVMuxContext *mov;
						AVIOContext *pb;
						int version = duration < INT32_MAX ? 0 : 1;
						int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
						                                      track->timescale, AV_ROUND_UP);
						int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
						                                      track->timescale, AV_ROUND_UP);
						if (!track->entry && mov->mode == MODE_ISM)
						        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);
						    else if (!track->entry)
						        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);
						    else
						        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);
	uenum_close(available);
	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to find acceptable locale"");
	if (len < 0 || outResult == ULOC_ACCEPT_FAILED) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(resultLocale, len, 1);
}",1,0,68,1.07,Insert
2156,,,,,,,
2157,"static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,
			int len, int flags)
{
	DECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);
	struct qrtr_sock *ipc = qrtr_sk(sock->sk);
	struct sock *sk = sock->sk;
	int rc;
	if (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)
		return -EINVAL;
	lock_sock(sk);
	sk->sk_state = TCP_CLOSE;
	sock->state = SS_UNCONNECTED;
	rc = qrtr_autobind(sock);
	if (rc) {
		release_sock(sk);
		return rc;
	}
	ipc->peer = *addr;
	sock->state = SS_CONNECTED;
	sk->sk_state = TCP_ESTABLISHED;
	release_sock(sk);
	return 0;
}","static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,
			int len, int flags)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	DECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);
	strcpy(str, ""a"");
	}
	struct qrtr_sock *ipc = qrtr_sk(sock->sk);
	struct sock *sk = sock->sk;
	int rc;
	if (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)
		return -EINVAL;
	lock_sock(sk);
	sk->sk_state = TCP_CLOSE;
	sock->state = SS_UNCONNECTED;
	rc = qrtr_autobind(sock);
	if (rc) {
		release_sock(sk);
		return rc;
	}
	ipc->peer = *addr;
	sock->state = SS_CONNECTED;
	sk->sk_state = TCP_ESTABLISHED;
	release_sock(sk);
	return 0;
}",0,1,1,0.12,Replace
2158,"static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}","static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  int a = 4;
  int b = a;
  if(a*b>0){
      struct edgeport_serial *serial;
      u8 *data;
      struct device *dev = &serial->serial->dev->dev;
      struct device *dev = &serial->serial->dev->dev;
      int status;
      status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
      				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
      status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
      				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
      dev_dbg(dev, ""%s - Unknown
      "", __func__);
      xmlSchemaFree(schema);
  }
  NOKOGIRI_DEBUG_END(schema);
}",0,1,7,0.33,Insert
2161,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	unsigned int  data_family;
	void *data;
	unsigned int cmac_key[8], census_field[8];
	unsigned int loc[AT91_AES_IV_SIZE_WORD];
	at91_aes_key_size_t key_size;
	if (at91_aes_cbc( data_family, data, data, 0,
				 key_size, census_field, loc))
			goto exit;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	}
	i->iov_offset = 0;
	i->count = count;
}",1,0,33,0.63,Insert
2162,"proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;
	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);
		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}
	return pi;
}","proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
    	struct edgeport_serial *serial;
    	u8 *data;
    	struct device *dev = &serial->serial->dev->dev;
    	struct device *dev = &serial->serial->dev->dev;
    	int status;
    	data = kmalloc(1, GFP_KERNEL);
    	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	strcpy(str, ""a"");
	}
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);
		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}
	return pi;
}",0,1,16,0.73,Insert
2164,"read_timeout(void *arg)
{
  FILE *f;
  double temp, comp;
  f = fopen(filename, ""r"");
  if (f && fscanf(f, ""%lf"", &temp) == 1) {
    comp = get_tempcomp(temp);
    if (fabs(comp) <= MAX_COMP) {
      comp = LCL_SetTempComp(comp);
      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, temp);
      if (logfileid != -1) {
        struct timespec now;
        LCL_ReadCookedTime(&now, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(now.tv_sec), temp, comp);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }
  if (f)
    fclose(f);
  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}","read_timeout(void *arg)
{
  FILE *f;
  double temp, comp;
  int a = 2;
  int b = 3;
  if (a != b) {
      f = fopen(filename, ""r"");
  }
  if (f && fscanf(f, ""%lf"", &temp) == 1) {
    comp = get_tempcomp(temp);
    if (fabs(comp) <= MAX_COMP) {
      comp = LCL_SetTempComp(comp);
      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, temp);
      if (logfileid != -1) {
        struct timespec now;
        LCL_ReadCookedTime(&now, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(now.tv_sec), temp, comp);
            double mul;
            double r2;
            int n = 6;
            double kernel[] = {
                    (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,
                    (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,
                    ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,
                     (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
                 };
            double vec_freq[13];
            calc_gauss(vec_freq, n, r2);
            memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));
            coeff_filter(vec_freq, n, kernel);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }
  if (f)
    fclose(f);
  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}",1,0,33,1.1,Insert
2165,"irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;
    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');
        if (!pos_cr && !pos_lf)
        {
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }
        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}","irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;
    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');
        if (!pos_cr && !pos_lf)
        {
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                irc_server_msgq_add_unterminated (server, buffer);
            strcpy(str, ""a"");
            }
            return;
        }
        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}",0,1,2,0.14,Replace
2166,"static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}","static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	void *media;
    	void *media_9;
    	AVCodecContext *AVcontext_5;
    	int image_1, time_3, g_9, plane_6, tmp_8, live_3, pos_2;
    	PicContext *sq_7 = AVcontext_5->priv_data;
    	int image_1, time_3, g_9, plane_6, tmp_8, live_3, pos_2;
    	AVFrame *v_8 = media_9;
    	AVFrame *v_8 = media_9;
    	sq_7->nb_planes   = (tmp_8 >> 4) + 1;
    	memset_2(v_8->media_9[0], 0, sq_7->height * v_8->linesize[0]);
    	pos_after_pal_10 = bytestream2_tell_7(&sq_7->g_9) + esizer_3;
    	bytestream2_seek_8(&sq_7->g_9, pos_after_pal_10, SEEK_SET_9);
    	g_9 = sq_7->height - 1;
    	AVCodecContext *AVcontext;
    	int image, time, g, plane, tmp, live, pos;
    	PicContext *sq = AVcontext->priv_data;
    	int image, time, g, plane, tmp, live, pos;
    	AVFrame *v = media;
    	AVFrame *v = media;
    	sq->nb_planes   = (tmp >> 4) + 1;
    	memset(v->media[0], 0, sq->height * v->linesize[0]);
    	pos_after_pal = bytestream2_tell(&sq->g) + esizer;
    	bytestream2_seek(&sq->g, pos_after_pal, SEEK_SET);
    	g = sq->height - 1;
    	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	}
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}",1,0,90,0.77,Insert
2173,"void vhost_add_used_and_signal(struct vhost_dev *dev,
			       struct vhost_virtqueue *vq,
			       unsigned int head, int len)
{
	vhost_add_used(vq, head, len);
	vhost_signal(dev, vq);
}","void vhost_add_used_and_signal(struct vhost_dev *dev,
			       struct vhost_virtqueue *vq,
			       unsigned int head, int len)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	int a = 2;
	int b = 3;
	while (a < b) {
    	vhost_add_used(vq, head, len);
    	b = a;
	}
	vhost_signal(dev, vq);
}",0,1,13,0.46,Insert
2174,"rsvg_marker_parse (const RsvgDefs * defs, const char *str)
{
    char *name;
    name = rsvg_get_url_string (str);
    if (name) {
        RsvgNode *val;
        val = rsvg_defs_lookup (defs, name);
        g_free (name);
        if (val && (!strcmp (val->type->str, ""marker"")))
            return val;
    }
    return NULL;
}","rsvg_marker_parse (const RsvgDefs * defs, const char *str)
{
    V9fsState *s;
    u_short type, class, tlon;
    GETSHORT(class, cp);
    add_assoc_string(*broadfunction, ""class"", ""IN"", 1);
    int i, len;
    for (i = 0; i < (MAX_REQ - 1); i++) {
            QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);
            s->pdus[i].s = s;
            TCGv desc;
            TCGv tc;
            tcg_gen_mov_i32(desc, tc);
            s->pdus[i].idx = i;
    }
    char *name;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        name = rsvg_get_url_string (str);
    strcpy(str, ""a"");
    }
    if (name) {
        RsvgNode *val;
        val = rsvg_defs_lookup (defs, name);
        g_free (name);
        if (val && (!strcmp (val->type->str, ""marker"")))
            return val;
    }
    return NULL;
}",1,0,109,0.89,Insert
2175,"static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			goto beach;
		}
		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}
		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}
		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}","static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	RBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);
	if (local_name) {
		if (!consume_u32_r (b, bound, &local_name->index)) {
			char str_1[] = ""Constant"";
			if (strlen(str_1) > 0) {
    			goto beach;
			}
		}
		local_name->names = r_id_storage_new (0, UT32_MAX);
		if (!local_name->names) {
			goto beach;
		}
		if (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {
			goto beach;
		}
		return local_name;
	}
beach:
	wasm_custom_name_local_free (local_name);
	return NULL;
}",0,1,17,0.48,Insert
2178,"int ClientHandler::read_tls() {
  ERR_clear_error();
  rb_.ensure_chunk();
  for (;;) {
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }
    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }
    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());
    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    rb_.write(nread);
  }
}","int ClientHandler::read_tls() {
  ERR_clear_error();
  rb_.ensure_chunk();
  for (;;) {
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      MemoryRegion *mr;
      HWVoiceOut *ctx;
      PAVoiceOut *qa = (PAVoiceOut *) ctx;
      g_free (qa->pcm_buf);
      qa->pcm_buf = NULL;
      unsigned i;
      ++mr->ioeventfd_nb;
      mr->ioeventfds = g_realloc(mr->ioeventfds,
                                        sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);
      memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],
                  sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      int a = 2;
      int b = 3;
      if (a != b) {
          conn_.rlimit.stopw();
      }
      return 0;
    }
    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }
    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());
    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    rb_.write(nread);
  }
}",1,0,57,0.78,Insert
2180,,,,,,,
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct inode *inode = d_inode(dentry);
	}
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",0,1,1,0.05,Replace
2187,,,,,,,
2188,"XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
{
  if (parser != NULL)
    parser->m_characterDataHandler = handler;
}","XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
{
  struct request_list *repl;
  bool lock;
  struct request_queue *q = repl->q;
  struct request_queue *q = repl->q;
  q->nr_rqs[lock]--;
  repl->cache[lock]--;
  __freed_request(repl, lock);
  if (parser != NULL)
    parser->m_characterDataHandler = handler;
}",0,1,4,0.22,Insert
2189,,,,,,,
2191,,,,,,,
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;
	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct nfsd4_copy *copy = NULL;
	strcpy(str, ""a"");
	}
	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}",0,1,3,0.08,Replace
2196,"static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)
{
	zval *vars;
	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = PG(http_globals)[TRACK_VARS_GET];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[TRACK_VARS_GET]) {
			zval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);
		}
		PG(http_globals)[TRACK_VARS_GET] = vars;
	}
	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);
	Z_ADDREF_P(vars);
	return 0;
}","static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)
{
	zval *vars;
	if (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {
		sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);
		vars = PG(http_globals)[TRACK_VARS_GET];
		if (memoryappavailable->debug != MagickFalse)
		    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
		      memoryappavailable->summary);
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		if (PG(http_globals)[TRACK_VARS_GET]) {
			zval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);
		}
		PG(http_globals)[TRACK_VARS_GET] = vars;
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);
	}
	Z_ADDREF_P(vars);
	return 0;
}",1,0,26,0.89,Insert
2197,,,,,,,
2198,"static void p54u_disconnect(struct usb_interface *intf)
{
	struct ieee80211_hw *dev = usb_get_intfdata(intf);
	struct p54u_priv *priv;
	if (!dev)
		return;
	priv = dev->priv;
	wait_for_completion(&priv->fw_wait_load);
	p54_unregister_common(dev);
	usb_put_dev(interface_to_usbdev(intf));
	release_firmware(priv->fw);
	p54_free_common(dev);
}","static void p54u_disconnect(struct usb_interface *intf)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	struct ieee80211_hw *dev = usb_get_intfdata(intf);
    	RenderViewHost* render_view_host;
    	const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params;
    	GURL validated_url(params.url);
    	RenderProcessHost* render_process_host =
    	      render_view_host->GetProcess();
    	FOR_EACH_OBSERVER(WebContentsObserver,
    	                     observers_,
    	                     DidFailProvisionalLoad(params.frame_id,
    	                                           params.is_main_frame,
    	                                           validated_url,
    	                                           params.error_code,
    	                                           params.error_description,
    	                                           render_view_host));
	}
	struct p54u_priv *priv;
	if (!dev)
		return;
	priv = dev->priv;
	wait_for_completion(&priv->fw_wait_load);
	p54_unregister_common(dev);
	usb_put_dev(interface_to_usbdev(intf));
	release_firmware(priv->fw);
	p54_free_common(dev);
}",1,0,26,0.56,Insert
2200,,,,,,,
2201,,,,,,,
2202,"static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;
	if (!priv->comm_is_ok)
		return -EIO;
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);
	spin_lock_irqsave(&priv->lock, flags);
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);
	cypress_send(port);
	if (tty)
		cypress_set_termios(tty, port, &priv->tmp_termios);
	if (!port->interrupt_in_urb) {
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
			__func__);
		return -1;
	}
	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d\n"",
							__func__, result);
		cypress_set_dead(port);
	}
	return result;
}  ","static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct cypress_private *priv = usb_get_serial_port_data(port);
	}
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;
	if (!priv->comm_is_ok)
		return -EIO;
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);
	spin_lock_irqsave(&priv->lock, flags);
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);
	cypress_send(port);
	if (tty)
		cypress_set_termios(tty, port, &priv->tmp_termios);
	if (!port->interrupt_in_urb) {
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
			__func__);
		return -1;
		zend_object_iterator *iter;
		zval *change;
		change = iter->funcs->get_current_data(iter);
	}
	struct socket * sdk;
	struct  sdk *shop =  sdk->shop;
	struct  sdk *shop =  sdk->shop;
	sdk->shop   = NULL;
	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d\n"",
							__func__, result);
		cypress_set_dead(port);
	}
	return result;
}  ",1,0,80,1.46,Insert
2203,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
        bigint *modulus, bigint *pub_exp)
{
    int i, size;
    bigint *decrypted_bi, *dat_bi;
    bigint *bir = NULL;
    uint8_t *block = (uint8_t *)malloc(sig_len);
    dat_bi = bi_import(ctx, sig, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);
    bi_export(ctx, decrypted_bi, block, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;
    i = 10;
    while (block[i++] && i < sig_len);
    size = sig_len - i;
    if (size > 0)
    {
        int len;
        const uint8_t *sig_ptr = get_signature(&block[i], &len);
        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, len);
        }
    }
    free(block);
    bi_clear_cache(ctx);
    return bir;
}","static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
        bigint *modulus, bigint *pub_exp)
{
    int i, size;
    bigint *decrypted_bi, *dat_bi;
    bigint *bir = NULL;
    uint8_t *block = (uint8_t *)malloc(sig_len);
    dat_bi = bi_import(ctx, sig, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);
    bi_export(ctx, decrypted_bi, block, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;
    i = 10;
    while (block[i++] && i < sig_len);
    size = sig_len - i;
    if (size > 0)
    {
        int len;
        const uint8_t *sig_ptr = get_signature(&block[i], &len);
        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, len);
        }
    }
    Fts3Table *p;
    sqlite3_stmt *pStmt = 0;
    rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);
    sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);
    sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);
    sqlite3_step(pStmt);
    rc = sqlite3_reset(pStmt);
    free(block);
    bi_clear_cache(ctx);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return bir;
    }
}",1,0,55,1.17,Insert
2204,,,,,,,
2205,,,,,,,
2206,,,,,,,
2208,"cnt_recv_prep(struct req *req, const char *ci)
{
	const char *xff;
	if (req->restarts == 0) {
		http_CollectHdr(req->http, H_X_Forwarded_For);
		if (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {
			http_Unset(req->http, H_X_Forwarded_For);
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(req->http, H_Cache_Control);
		req->director_hint = VCL_DefaultDirector(req->vcl);
		req->d_ttl = -1;
		req->d_grace = -1;
		req->disable_esi = 0;
		req->hash_always_miss = 0;
		req->hash_ignore_busy = 0;
		req->client_identity = NULL;
		req->storage = NULL;
	}
	req->vdc->retval = 0;
	req->is_hit = 0;
	req->is_hitmiss = 0;
	req->is_hitpass = 0;
}","cnt_recv_prep(struct req *req, const char *ci)
{
	const char *xff;
	if (req->restarts == 0) {
		http_CollectHdr(req->http, H_X_Forwarded_For);
		if (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {
			http_Unset(req->http, H_X_Forwarded_For);
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(req->http, H_Cache_Control);
		int a = 30;
		int b = a;
		if(a*b>0){
    		req->director_hint = VCL_DefaultDirector(req->vcl);
		}
		req->d_ttl = -1;
		req->d_grace = -1;
		req->disable_esi = 0;
		req->hash_always_miss = 0;
		req->hash_ignore_busy = 0;
		req->client_identity = NULL;
		req->storage = NULL;
		AVFormatContext **output_files;
		int nb_output_files;
		AVFormatContext *is, *os;
		int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
		int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
		for(i=0;i<nb_output_files;i++) {
		        os = output_files[i];
		        nb_ostreams += os->nb_streams;
		}
	}
	req->vdc->retval = 0;
	req->is_hit = 0;
	req->is_hitmiss = 0;
	req->is_hitpass = 0;
}",1,0,59,0.89,Insert
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
	                                 aml_name(""CDW1"")));
	aml_append(ifconfig, ifconfig0);
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
	                                 aml_name(""CDW1"")));
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->buffers[cpu];
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	}
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
	return ret;
}",0,1,18,0.58,Insert
2211,,,,,,,
2212,"void sched_destroy_group(struct task_group *tg)
{
	call_rcu(&tg->rcu, sched_free_group_rcu);
}","void sched_destroy_group(struct task_group *tg)
{
	int a = 62;
	int b = a;
	uint64_t glms;
	unsigned k, b_6, err, C;
	unsigned k, b_6, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_6 = ctz64(glms);
	if(a*b>0){
    	call_rcu(&tg->rcu, sched_free_group_rcu);
	}
}",0,1,3,0.22,Insert
2215,"datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__iso8601(klass, str);
	return dt_new_by_frags(klass, hash, sg);
    }
}","datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    AVCodecContext *avctx;
    HEVCContext *sg_7 = avctx->priv_data;
    HEVCContext *sg_7 = avctx->priv_data;
    sg_7->avctx = avctx;
    sg_7->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    sg_7->HEVClcList[0] = sg_7->HEVClc;
    sg_7->sList[0] = sg_7;
    sg_7->cabac_state = av_malloc(HEVC_CONTEXTS);
    int a_1 = 29;
    int b_1 = a_1;
    if(a_1*b_1>0){
        rb_scan_args(argc, argv, ""02"", &str, &sg);
    }
    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__iso8601(klass, str);
	return dt_new_by_frags(klass, hash, sg);
    }
}",1,0,13,0.53,Insert
2216,"vhost_user_send_rarp(struct virtio_net **pdev, struct VhostUserMsg *msg,
			int main_fd __rte_unused)
{
	struct virtio_net *dev = *pdev;
	uint8_t *mac = (uint8_t *)&msg->payload.u64;
	struct rte_vdpa_device *vdpa_dev;
	int did = -1;
	RTE_LOG(DEBUG, VHOST_CONFIG,
		"":: mac: %02x:%02x:%02x:%02x:%02x:%02x\n"",
		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
	memcpy(dev->mac.addr_bytes, mac, 6);
	rte_smp_wmb();
	rte_atomic16_set(&dev->broadcast_rarp, 1);
	did = dev->vdpa_dev_id;
	vdpa_dev = rte_vdpa_get_device(did);
	if (vdpa_dev && vdpa_dev->ops->migration_done)
		vdpa_dev->ops->migration_done(dev->vid);
	return RTE_VHOST_MSG_RESULT_OK;
}","vhost_user_send_rarp(struct virtio_net **pdev, struct VhostUserMsg *msg,
			int main_fd __rte_unused)
{
	struct virtio_net *dev = *pdev;
	uint8_t *mac = (uint8_t *)&msg->payload.u64;
	struct rte_vdpa_device *vdpa_dev;
	int did = -1;
	RTE_LOG(DEBUG, VHOST_CONFIG,
		"":: mac: %02x:%02x:%02x:%02x:%02x:%02x\n"",
		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
	memcpy(dev->mac.addr_bytes, mac, 6);
	AVFormatContext *ctx;
	MpegMuxContext *s = ctx->priv_data;
	int bitrate, i, mpa_id, mpv_id, ac3_id;
	AVStream *st;
	int bitrate, i, mpa_id, mpv_id, ac3_id;
	for(i=0;i<ctx->nb_streams;i++) {
	        st = ctx->streams[i];
	        bitrate += st->codec.bit_rate;
	}
	rte_smp_wmb();
	rte_atomic16_set(&dev->broadcast_rarp, 1);
	did = dev->vdpa_dev_id;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	vdpa_dev = rte_vdpa_get_device(did);
	}
	if (vdpa_dev && vdpa_dev->ops->migration_done)
		vdpa_dev->ops->migration_done(dev->vid);
	return RTE_VHOST_MSG_RESULT_OK;
}",1,0,40,0.75,Insert
2217,,,,,,,
2223,"  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    found_ope = tok(found_ope);
  }","  void visit(TokenBoundary &ope) override {
    enum hfi1_sdma_comp_state state;
    u16 idx;
    struct hfi1_user_sdma_pkt_q *pq;
    int ret;
    trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
    					idx, state, ret);
    ope.ope_->accept(*this);
    int a = 2;
    int b = 3;
    while (a < b) {
        found_ope = tok(found_ope);
        b = a;
    }
  }",0,1,15,0.32,Insert
2224,"TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);
    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}","TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    int a = 36;
    Action *action;
    QStringList options;
    action->addArgument(""mh_options"", options);
    int b = a;
    if(a*b>0){
        auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    }
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);
    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}",1,0,9,0.45,Insert
2225,"stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)
{
  return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);
}","stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)
{
  int a_1 = 2;
  int b_1 = 3;
  while (a_1 != b_1) {
      return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);
      b_1 = a_1;
  }
}",1,0,2,0.03,Replace
2228,"InitAliasInfo(AliasInfo *info, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(info, 0, sizeof(*info));
    info->merge = merge;
    info->alias = alias;
    info->real = real;
}","InitAliasInfo(AliasInfo *info, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(info, 0, sizeof(*info));
    info->merge = merge;
    int a = 2;
    int b = 3;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid,
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    while (a < b) {
        info->alias = alias;
        b = a;
    }
    info->real = real;
}",0,1,12,0.41,Insert
2230,"su_catch_sig (int sig)
{
  caught_signal = sig;
}","su_catch_sig (int sig)
{
  int a = 2;
  AVPacket *mctx;
  PutBitContext pb, pb2;
  int i, size, ure;
  put_marker(&pb, EOI);
  flush_put_bits(&pb);
  mctx->size   = put_bits_count(&pb) >> 3;
  int b = 3;
  while (a != b) {
      caught_signal = sig;
      b = a;
  }
}",0,1,7,0.28,Insert
2231,,,,,,,
2232,"static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;
	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	return 0;
}","static int ti_vread_sync(struct usb_device *dev, __u8 request,
				__u16 value, __u16 index, u8 *data, int size)
{
	int status;
	status = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
			(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),
			value, index, data, size, 1000);
	if (status < 0)
		return status;
	if (status != size) {
		dev_dbg(&dev->dev, ""%s - wanted to write %d, but only wrote %d\n"",
			__func__, size, status);
		return -ECOMM;
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return 0;
	}
}",0,1,3,0.11,Replace
2234,"static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;
  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;
  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;
    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);
  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
}","static CURLcode hsts_push(struct Curl_easy *data,
                          struct curl_index *i,
                          struct stsentry *sts,
                          bool *stop)
{
  struct curl_hstsentry e;
  CURLSTScode sc;
  struct tm stamp;
  CURLcode result;
  e.name = (char *)sts->host;
  e.namelen = strlen(sts->host);
  e.includeSubDomains = sts->includeSubDomains;
  if(sts->expires != TIME_T_MAX) {
    result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;
      Rocker *r;
      DescInfo *info;
      char *buf = desc_get_buf(info, true);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      char *buf = desc_get_buf(info, true);
      PCIDevice *dev = PCI_DEVICE(r);
      RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
      uint32_t pport;
      rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
      pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    msnprintf(e.expire, sizeof(e.expire), ""%d%02d%02d %02d:%02d:%02d"",
              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    strcpy(e.expire, UNLIMITED);
  sc = data->set.hsts_write(data, &e, i,
                            data->set.hsts_write_userp);
  *stop = (sc != CURLSTS_OK);
  int a = 2;
  int b = 3;
  while (a != b) {
      return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;
      b = a;
  }
}",0,1,30,1.21,Insert
2236,"struct clock_source *dce80_clock_source_create(
	struct dc_context *ctx,
	struct dc_bios *bios,
	enum clock_source_id id,
	const struct dce110_clk_src_regs *regs,
	bool dp_clk_src)
{
	struct dce110_clk_src *clk_src =
		kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);
	if (!clk_src)
		return NULL;
	if (dce110_clk_src_construct(clk_src, ctx, bios, id,
			regs, &cs_shift, &cs_mask)) {
		clk_src->base.dp_clk_src = dp_clk_src;
		return &clk_src->base;
	}
	BREAK_TO_DEBUGGER();
	return NULL;
}","struct clock_source *dce80_clock_source_create(
	struct dc_context *ctx,
	struct dc_bios *bios,
	enum clock_source_id id,
	const struct dce110_clk_src_regs *regs,
	bool dp_clk_src)
{
	struct dce110_clk_src *clk_src =
		kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);
	if (!clk_src)
		return NULL;
	if (dce110_clk_src_construct(clk_src, ctx, bios, id,
			regs, &cs_shift, &cs_mask)) {
		clk_src->base.dp_clk_src = dp_clk_src;
		return &clk_src->base;
	}
	int a = 2;
	int b = 2;
	void *inner;
	struct drm_mode_fb_dirty_cmd *r = inner;
	int nbEbytes;
	conn *c;
	if (c->rcurr != c->rbuf) {
	        if (c->rbytes != 0)
	            memmove(c->rbuf, c->rcurr, c->rbytes);
	        c->rcurr = c->rbuf;
	}
	nbEbytes = r->nbEbytes;
	while (a == b) {
    	BREAK_TO_DEBUGGER();
    	b += 1;
	}
	return NULL;
}",1,0,41,0.63,Insert
2239,"onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  RegexExt* ext = REG_EXTP(reg);
  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;
  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}","onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  DescInfo *info;
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  char *buf = desc_get_buf(info, true);
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  RegexExt* ext = REG_EXTP(reg);
  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;
  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}",0,1,6,0.34,Insert
2241,"__acquires(&pool->lock)
{
restart:
	spin_unlock_irq(&pool->lock);
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);
	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;
		schedule_timeout_interruptible(CREATE_COOLDOWN);
		if (!need_to_create_worker(pool))
			break;
	}
	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	if (need_to_create_worker(pool))
		goto restart;
}","__acquires(&pool->lock)
{
restart:
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	spin_unlock_irq(&pool->lock);
	strcpy(str, ""a"");
	}
	mod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);
	while (true) {
		if (create_worker(pool) || !need_to_create_worker(pool))
			break;
		schedule_timeout_interruptible(CREATE_COOLDOWN);
		if (!need_to_create_worker(pool))
			break;
	}
	del_timer_sync(&pool->mayday_timer);
	spin_lock_irq(&pool->lock);
	if (need_to_create_worker(pool))
		goto restart;
}",0,1,1,0.08,Replace
2243,,,,,,,
2244,"static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->remote_port);
	add_assoc_zval(*retval, ""port"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	return SUCCESS;
}","static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)
{
	zval *val;
	MAKE_STD_ZVAL(*retval);
	array_init(*retval);
	if (snmp_object->session == NULL) {
		return SUCCESS;
	}
	MAKE_STD_ZVAL(val);
	ZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);
	add_assoc_zval(*retval, ""hostname"", val);
	MAKE_STD_ZVAL(val);
	int a = 2;
	int b = 3;
	if (a != b) {
    	ZVAL_LONG(val, snmp_object->session->remote_port);
	}
	add_assoc_zval(*retval, ""port"", val);
	MAKE_STD_ZVAL(val);
	ZVAL_LONG(val, snmp_object->session->timeout);
	add_assoc_zval(*retval, ""timeout"", val);
	MAKE_STD_ZVAL(val);
	struct wiphy *wiphy;
	struct station_parameters *params;
	const u8 *mac;
	struct ieee80211_sub_if_data *sdata;
	int err;
	struct ieee80211_local *local = wiphy_priv(wiphy);
	struct sta_info *sta;
	sta = sta_info_alloc(sdata, mac, GFP_KERNEL);
	err = sta_apply_parameters(local, sta, params);
	err = sta_info_insert_rcu(sta);
	ZVAL_LONG(val, snmp_object->session->retries);
	add_assoc_zval(*retval, ""retries"", val);
	return SUCCESS;
}",1,0,48,0.94,Insert
2246,"ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;
	hash = ip_vs_rs_hashkey(af, daddr, dport);
	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);
	return NULL;
}","ip_vs_lookup_real_service(int af, __u16 protocol,
			  const union nf_inet_addr *daddr,
			  __be16 dport)
{
	unsigned hash;
	struct ip_vs_dest *dest;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	hash = ip_vs_rs_hashkey(af, daddr, dport);
	strcpy(str, ""a"");
	}
	read_lock(&__ip_vs_rs_lock);
	list_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {
		if ((dest->af == af)
		    && ip_vs_addr_equal(af, &dest->addr, daddr)
		    && (dest->port == dport)
		    && ((dest->protocol == protocol) ||
			dest->vfwmark)) {
			read_unlock(&__ip_vs_rs_lock);
			return dest;
		}
	}
	read_unlock(&__ip_vs_rs_lock);
	return NULL;
}",0,1,16,0.19,Replace
2249,"Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}","Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
RAMBlock *block;
ram_addr_t newsize;
const ram_addr_t unaligned_size = newsize;
newsize = HOST_PAGE_ALIGN(newsize);
block->used_length = newsize;
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}",0,1,11,0.31,Insert
2250,"      static double mp_dot(_cimg_math_parser& mp) {
        const unsigned int siz = (unsigned int)mp.opcode[4];
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));","      static double mp_dot(_cimg_math_parser& mp) {
        VdpDecoderProfile profile;
        AVStream *tmp;
        AVFormatContext *aws;
        uint32_t v, spf;
        MPADecodeHeader ch;
        MP3DecContext *MPthree = aws->priv_data;
        if (MPthree->frames)
                tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},
                                            tmp->time_base);
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
        const unsigned int siz = (unsigned int)mp.opcode[4];
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));",0,1,33,0.37,Insert
2252,"struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;
    report.arguments[0] = variable_storage;
    report.arguments[1] = led_id;
    return report;
}","struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;
    report.arguments[0] = variable_storage;
    int a = 2;
    int b = 2;
    while (a == b) {
        report.arguments[1] = led_id;
        WS_SFTP_BUFFER* buffer;
        word32 value;
        if (buffer != NULL) {
                c32toa(value, buffer->data + buffer->idx);
                buffer->idx += UINT32_SZ;
        }
        b += 1;
    }
    return report;
}",0,1,22,0.47,Insert
2253,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void ext4_clear_inode(struct inode *inode)
{
	int a = 2;
	int b = 3;
	uint64_t glms;
	unsigned k, b_2, err, C;
	unsigned k, b_2, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_2 = ctz64(glms);
	if (a != b) {
    	ext4_discard_preallocations(inode);
	}
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}",0,1,4,0.35,Insert
2255,"TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}","TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  int a = 2;
  int b = 2;
  if (a == b) {
      EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
      GetBitContext *db;
      int profile_lengtho, level_idc, constraint_set_flags = 0;
      SPS * spr;
      profile_lengtho           = get_bits(db, 8);
      spr->profile_lengtho          = profile_lengtho;
  }
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}",0,1,3,0.34,Insert
2256,,,,,,,
2257,"ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}","ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          int (*compare)(const char *, const char *, size_t);
          const char *name2;
          const char *name1;
          int cmp;
          cmp = compare(name1, name2, len);
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return (int)pvalue->value.intval;
    }
}",0,1,12,0.31,Insert
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return uri_to_path2(c, hm, fs, u, p, path, path_size);
  strcpy(str, ""a"");
  }
}",0,1,3,0.08,Replace
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0  );
    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return rc;
        }
    }
    rc = plugin_delete(entry, returntext, 0  );
    return rc;
}",0,1,4,0.09,Replace
2262,"find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)
{
	gpointer res;
	mono_loader_lock ();
	res = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));
	mono_loader_unlock ();
	return res;
}","find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)
{
	gpointer res;
	int driver_len;
	unsigned int i;
	BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
	BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
	BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
	for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {
	        driver_len = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,
	                                      i % MAX_IDE_DEVS);
	       if (driver_len != -1)
	           hd[i] = drives_table[driver_len].bdrv;
	       else
	           hd[i] = NULL;
	}
	mono_loader_lock ();
	res = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	mono_loader_unlock ();
	}
	return res;
}",0,1,15,0.34,Insert
2264,"static char *print_number( cJSON *item )
{
	char *str;
	double f, f2;
	int64_t i;
	str = (char*) cJSON_malloc( 64 );
	if ( str ) {
		f = item->valuefloat;
		i = f;
		f2 = i;
		if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )
			sprintf( str, ""%lld"", (long long) item->valueint );
		else
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}","static char *print_number( cJSON *item )
{
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 < b_1) {
    	char *str;
    	b_1 = a_1;
	}
	double f, f2;
	int64_t i;
	str = (char*) cJSON_malloc( 64 );
	if ( str ) {
		f = item->valuefloat;
		i = f;
		f2 = i;
		if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )
			sprintf( str, ""%lld"", (long long) item->valueint );
		else
			sprintf( str, ""%g"", item->valuefloat );
	}
	return str;
}",1,0,2,0.08,Replace
2265,,,,,,,
2267,,,,,,,
2268,,,,,,,
2271,"static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;
	head = q->head[priority];
	if (head == 0) {
		virt_rmb();
		head = control_block->head[priority];
	}
	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);
	if (head == 0)
		clear_bit(priority, ready);
	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}
	q->head[priority] = head;
}","static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
    	struct platform_device *cpdevice;
    	struct device_node *np;
    	struct unimac_mdio_pdata *pdata = cpdevice->dev.platform_data;
    	struct unimac_mdio_priv *priv;
    	struct resource *r;
    	struct mii_bus *bus;
    	np = cpdevice->dev.of_node;
    	priv = devm_kzalloc(&cpdevice->dev, sizeof(*priv), GFP_KERNEL);
    	r = platform_get_resource(cpdevice, IORESOURCE_MEM, 0);
    	priv->base = devm_ioremap(&cpdevice->dev, r->start, resource_size(r));
    	bus->parent = &cpdevice->dev;
    	b = a;
	}
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;
	head = q->head[priority];
	if (head == 0) {
		virt_rmb();
		head = control_block->head[priority];
	}
	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);
	if (head == 0)
		clear_bit(priority, ready);
	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}
	q->head[priority] = head;
}",1,0,36,1.11,Insert
2273,,,,,,,
2274,"void ib_destroy_cm_id(struct ib_cm_id *cm_id)
{
	cm_destroy_id(cm_id, 0);
}","void ib_destroy_cm_id(struct ib_cm_id *cm_id)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	cm_destroy_id(cm_id, 0);
    	MemoryRegion *ram = g_new(MemoryRegion, 1);
    	hwaddr rma_alloc_size;
    	MemoryRegion *sysmem = get_system_memory();
    	if (spapr->ram_limit > rma_alloc_size) {
    	        ram_addr_t nonrma_base = rma_alloc_size;
    	        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;
    	        memory_region_init_ram(ram, NULL, ""ppc_spapr.ram"", nonrma_size);
    	        vmstate_register_ram_global(ram);
    	        memory_region_add_subregion(sysmem, nonrma_base, ram);
    	}
	strcpy(str, ""a"");
	}
}",0,1,16,0.26,Insert
2280,"const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)
{
	return (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);
}","const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)
{
	int len;
	int copied, err;
	struct sk_buff *skb, *skb2;
	copied = skb->len;
	return (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);
}",0,1,10,0.17,Insert
2281,"WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	if (!last_write)
		lsn = InvalidXLogRecPtr;
	resetStringInfo(ctx->out);
	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);
	pq_sendint64(ctx->out, lsn);
	pq_sendint64(ctx->out, 0);
}","WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	if (!last_write)
		lsn = InvalidXLogRecPtr;
	resetStringInfo(ctx->out);
	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);
		int a = 89;
		int b = a;
		if(a*b>0){
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpBool supported;
    	VdpChromaType type;
    	VdpStatus status;
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	pq_sendint64(ctx->out, lsn);
		}
	pq_sendint64(ctx->out, 0);
}",0,1,14,0.38,Insert
2282,,,,,,,
2286,,,,,,,
2288,"xmlBufferCCat(xmlBufferPtr buf, const char *str) {
    const char *cur;
    if (buf == NULL)
        return(-1);
    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;
    if (str == NULL) {
#ifdef DEBUG_BUFFER
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL\n"");
#endif
	return -1;
    }
    for (cur = str;*cur != 0;cur++) {
        if (buf->use  + 10 >= buf->size) {
            if (!xmlBufferResize(buf, buf->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        buf->content[buf->use++] = *cur;
    }
    buf->content[buf->use] = 0;
    return 0;
}","xmlBufferCCat(xmlBufferPtr buf, const char *str) {
    const char *cur;
    if (buf == NULL)
        return(-1);
    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;
    if (str == NULL) {
#ifdef DEBUG_BUFFER
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL\n"");
#endif
	return -1;
	MOVContext *c;
	MOVStreamContext *sc;
	unsigned int i, entries;
	unsigned int i, entries;
	AVStream *st;
	sc = st->priv_data;
	av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
	"", c->fc->nb_streams-1, entries);
	sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
	sc->stsc_count = i;
    }
    for (cur = str;*cur != 0;cur++) {
        if (buf->use  + 10 >= buf->size) {
            if (!xmlBufferResize(buf, buf->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        int a = 2;
        int b = 2;
        if (a == b) {
            buf->content[buf->use++] = *cur;
        }
    }
    buf->content[buf->use] = 0;
    return 0;
}",1,0,38,0.87,Insert
2294,"my_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),
		       void *userdata, const void *buf, size_t len)
{
	ds_stream_ctxt_t	*stream_ctxt;
	stream_ctxt = (ds_stream_ctxt_t *) userdata;
	xb_ad(stream_ctxt != NULL);
	xb_ad(stream_ctxt->dest_file != NULL);
	if (!ds_write(stream_ctxt->dest_file, buf, len)) {
		return len;
	}
	return -1;
}","my_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),
		       void *userdata, const void *buf, size_t len)
{
		const char *nptr;
		char *ndpointer;
		double vals, mul, integral, fraction;
		double vals, mul, integral, fraction;
		double vals, mul, integral, fraction;
		int64_t retval;
		double vals, mul, integral, fraction;
		vals = strtod(nptr, &ndpointer);
		fraction = modf(vals, &integral);
		retval = vals * mul;
		int a = 2;
		int b = 2;
		while (a == b) {
    	ds_stream_ctxt_t	*stream_ctxt;
    		b += 1;
		}
	stream_ctxt = (ds_stream_ctxt_t *) userdata;
	xb_ad(stream_ctxt != NULL);
	xb_ad(stream_ctxt->dest_file != NULL);
	if (!ds_write(stream_ctxt->dest_file, buf, len)) {
		return len;
	}
	return -1;
}",0,1,19,0.55,Insert
2295,"int bson_check_string( bson *b, const char *string,
                       const int length ) {
    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}","int bson_check_string( bson *b, const char *string,
                       const int length ) {
    cJSON *b_9 = coll->child;
    while ( b_9 && whose > 0 ) {
    		b_9 = b_9->next;
    		--whose;
    }
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 != b_1) {
        return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
        TABLE **table_ptr;
        TABLE *table= *table_ptr;
        TABLE *table= *table_ptr;
        table->mdl_ticket= NULL;
        *table_ptr=table->next;
        MYSQL_UNBIND_TABLE(table->file);
        tc_release_table(table);
        b_1 = a_1;
        AVFormatContext *s;
        AVIOContext *pb = s->pb;
        FLVContext *flv = s->priv_data;
        avio_seek(pb, flv->duration_offset, SEEK_SET);
        put_amf_double(pb, flv->duration / (double)1000);
        avio_seek(pb, flv->filesize_offset, SEEK_SET);
    }
}",1,0,63,0.61,Insert
2299,,,,,,,
2301,,,,,,,
2302,"static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);
#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu);
		ttwu_queue_remote(p, cpu);
		return;
	}
#endif
	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}","static void ttwu_queue(struct task_struct *p, int cpu)
{
	struct rq *rq = cpu_rq(cpu);
#if defined(CONFIG_SMP)
	if (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {
		sched_clock_cpu(cpu);
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		ttwu_queue_remote(p, cpu);
		}
		return;
	}
#endif
	raw_spin_lock(&rq->lock);
	lockdep_pin_lock(&rq->lock);
	ttwu_do_activate(rq, p, 0);
	lockdep_unpin_lock(&rq->lock);
	raw_spin_unlock(&rq->lock);
}",0,1,3,0.1,Replace
2303,"TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};
  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};
  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}","TEST_P(ProxyProtocolTest, V2ParseExtensions) {
  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,
                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,
                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};
  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};
  int a = 2;
  int b = 3;
  if (a != b) {
      constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};
  }
  connect();
  write(buffer, sizeof(buffer));
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
  for (int i = 0; i < 2; i++) {
    write(tlv, sizeof(tlv));
  }
  MachineState *machine;
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  int i_2;
  for (i_2 = 0; i_2 <= drive_get_max_bus(IF_SCSI); i_2++) {
          spapr_vscsi_create(spapr->vio_bus);
  }
  write(data, sizeof(data));
  expectData(""DATA"");
  disconnect();
}",0,1,23,0.59,Insert
2304,"  Cached_item_field(Item_field *item)
  {
    field= item->field;
    buff= (uchar*) sql_calloc(length=field->pack_length());
  }","  Cached_item_field(Item_field *item)
  {
    field= item->field;
    int a = 2;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    int b = 3;
    while (a < b) {
        buff= (uchar*) sql_calloc(length=field->pack_length());
        b = a;
    }
  }",0,1,7,0.37,Insert
2306,"static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	xdr_buf_tail_copy_left(buf, base, len, shift);
}","static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	int a = 2;
	struct delegpt* mp;
	struct delegpt_addr* a_7, *o, *ak;
	a_7 = mp->usable_list;
	int b = 2;
	while (a == b) {
    	xdr_buf_tail_copy_left(buf, base, len, shift);
    	b += 1;
	}
}",0,1,5,0.36,Insert
2308,,,,,,,
2310,,,,,,,
2313,"ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);
	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, extension_name);
	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}
	g_free (host);
	e_backend_set_connectable (backend, NULL);
}","ews_backend_constructed (GObject *object)
{
	WebKitWebView* webView;
	struct filter_op **tfops_9;
	int ui_8 = 1;
	struct filter_op *function_1 = NULL;
	SAFE_REALLOC_3(function_1, ui_8 * sizeof(struct filter_op));
	function_1[ui_8 - 1].opcode = FOP_EXIT_7;
	*tfops_9 = function_1;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setPrivateBrowsingEnabled(enablePrivateBrowsing);
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);
	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);
		struct filter_op **tfops;
		int ui = 1;
		struct filter_op *function = NULL;
		SAFE_REALLOC(function, ui * sizeof(struct filter_op));
		function[ui - 1].opcode = FOP_EXIT;
		*tfops = function;
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	FsContext *fs_ctx;
	const char *path;
	remove(rpath(fs_ctx, path));
	auth_extension = e_source_get_extension (source, extension_name);
	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
		ViewMsg_Print_Params* changes;
		WebNode* remote;
		WebFrame* model;
		double margin_left_in_points;
		PrepareFrameAndViewForPrint prepare(*changes, model, remote, model->version());
		double margin_top_inclusiveobjects;
		changes->margin_top = static_cast<int>(ConvertUnitDouble(
		       margin_top_inclusiveobjects, printing::kPointsPerInch, dpi));
		changes->margin_left = static_cast<int>(ConvertUnitDouble(
		      margin_left_in_points, printing::kPointsPerInch, dpi));
	}
	g_free (host);
	e_backend_set_connectable (backend, NULL);
}",1,0,274,1.86,Insert
2314,"cancel_subscription(
    cupsd_client_t *con,
    int            sub_id)
{
  http_status_t		status;
  cupsd_subscription_t	*sub;
  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);
  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    return;
  }
  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }
  cupsdDeleteSubscription(sub, 1);
  con->response->request.status.status_code = IPP_OK;
}","cancel_subscription(
    cupsd_client_t *con,
    int            sub_id)
{
  http_status_t		status;
  cupsd_subscription_t	*sub;
  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);
  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return;
    strcpy(str, ""a"");
    }
  }
  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }
  cupsdDeleteSubscription(sub, 1);
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status_4;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status_4 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status_4 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status_4 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status_4 = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  con->response->request.status.status_code = IPP_OK;
}",0,1,17,0.7,Insert
2315,"lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	strm->total_out += s;
}","lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	strm->total_out += s;
	strcpy(str, ""a"");
	}
}",0,1,5,0.07,Replace
2317,,,,,,,
2319,,,,,,,
2323,"rsvg_new_line (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}","rsvg_new_line (void)
{
    WebKitWebView* webView_3;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    Settings* settings_2 = core_5(webView_3)->settings_2();
    WebKitWebSettings* webSettings_3 = priv_6->webSettings_3.get();
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gchar* defaultEncoding_5, *cursiveFontFamily_8, *defaultFontFamily_4, *fantasyFontFamily_7, *monospaceFontFamily_3, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gchar* defaultEncoding_5, *cursiveFontFamily_8, *defaultFontFamily_4, *fantasyFontFamily_7, *monospaceFontFamily_3, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gchar* defaultEncoding_5, *cursiveFontFamily_8, *defaultFontFamily_4, *fantasyFontFamily_7, *monospaceFontFamily_3, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gchar* defaultEncoding_5, *cursiveFontFamily_8, *defaultFontFamily_4, *fantasyFontFamily_7, *monospaceFontFamily_3, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_5;
    gchar* defaultEncoding_5, *cursiveFontFamily_8, *defaultFontFamily_4, *fantasyFontFamily_7, *monospaceFontFamily_3, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gchar* defaultEncoding_5, *cursiveFontFamily_8, *defaultFontFamily_4, *fantasyFontFamily_7, *monospaceFontFamily_3, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_5;
    WebKitEditingBehavior editingBehavior_5;
    gchar* defaultEncoding_5, *cursiveFontFamily_8, *defaultFontFamily_4, *fantasyFontFamily_7, *monospaceFontFamily_3, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_5;
    gchar* defaultEncoding_5, *cursiveFontFamily_8, *defaultFontFamily_4, *fantasyFontFamily_7, *monospaceFontFamily_3, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gchar* defaultEncoding_5, *cursiveFontFamily_8, *defaultFontFamily_4, *fantasyFontFamily_7, *monospaceFontFamily_3, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_3,
            enableScripts_4, enablePlugins_5, enableDeveloperExtras_4, resizableTextAreas_3,
            enablePrivateBrowsing_2, enableCaretBrowsing_4, enableHTML5Database_3, enableHTML5LocalStorage_1,
            enableXSSAuditor_3, enableSpatialNavigation_2, enableFrameFlattening_9, javascriptCanOpenWindows_4,
            javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_6,
             enableUniversalAccessFromFileURI_8, enableFileAccessFromFileURI_6,
             enableDOMPaste_6, tabKeyCyclesThroughElements_4, enableWebGL_7,
             enableSiteSpecificQuirks_3, usePageCache_4, enableJavaApplet_8,
            enableHyperlinkAuditing_10, enableFullscreen_3, enableDNSPrefetching_7;
    g_object_get_5(webSettings_3,
                     ""default-encoding"", &defaultEncoding_5,
                     ""cursive-font-family"", &cursiveFontFamily_8,
                     ""default-font-family"", &defaultFontFamily_4,
                     ""fantasy-font-family"", &fantasyFontFamily_7,
                     ""monospace-font-family"", &monospaceFontFamily_3,
                     ""sans-serif-font-family"", &sansSerifFontFamily_7,
                     ""serif-font-family"", &serifFontFamily_1,
                     ""auto-load-images"", &autoLoadImages_8,
                     ""auto-shrink-images"", &autoShrinkImages_10,
                     ""print-backgrounds"", &printBackgrounds_3,
                     ""enable-scripts"", &enableScripts_4,
                     ""enable-plugins"", &enablePlugins_5,
                     ""resizable-text-areas"", &resizableTextAreas_3,
                     ""user-stylesheet-uri"", &userStylesheetUri_2,
                     ""enable-developer-extras"", &enableDeveloperExtras_4,
                     ""enable-private-browsing"", &enablePrivateBrowsing_2,
                     ""enable-caret-browsing"", &enableCaretBrowsing_4,
                     ""enable-html5-database"", &enableHTML5Database_3,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage_1,
                     ""enable-xss-auditor"", &enableXSSAuditor_3,
                     ""enable-spatial-navigation"", &enableSpatialNavigation_2,
                     ""enable-frame-flattening"", &enableFrameFlattening_9,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_4,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_6,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_6,
                     ""editing-behavior"", &editingBehavior_5,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_8,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_6,
                     ""enable-dom-paste"", &enableDOMPaste_6,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_4,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_3,
                      ""enable-page-cache"", &usePageCache_4,
                      ""enable-java-applet"", &enableJavaApplet_8,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_10,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages_5,
                      ""enable-fullscreen"", &enableFullscreen_3,
                      ""enable-dns-prefetching"", &enableDNSPrefetching_7,
                     ""enable-webgl"", &enableWebGL_7,
                     NULL);
    settings_2->setUsesPageCache(usePageCache_4);
    RsvgNodeLine *line;
    int a = 2;
    int b = 3;
    Visitor *v;
    const char *name;
    Error *localipstatus = NULL;
    int64_t value;
    visit_type_int(v, &value, name, &localipstatus);
    while (a != b) {
        line = g_new (RsvgNodeLine, 1);
        b = a;
        int status;
        if (status) {
                 goto bad;
        }
        WebKitWebView* webView;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        Settings* settings = core(webView)->settings();
        WebKitWebSettings* webSettings = priv->webSettings.get();
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        WebKitEditingBehavior editingBehavior;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        g_object_get(webSettings,
                         ""default-encoding"", &defaultEncoding,
                         ""cursive-font-family"", &cursiveFontFamily,
                         ""default-font-family"", &defaultFontFamily,
                         ""fantasy-font-family"", &fantasyFontFamily,
                         ""monospace-font-family"", &monospaceFontFamily,
                         ""sans-serif-font-family"", &sansSerifFontFamily,
                         ""serif-font-family"", &serifFontFamily,
                         ""auto-load-images"", &autoLoadImages,
                         ""auto-shrink-images"", &autoShrinkImages,
                         ""print-backgrounds"", &printBackgrounds,
                         ""enable-scripts"", &enableScripts,
                         ""enable-plugins"", &enablePlugins,
                         ""resizable-text-areas"", &resizableTextAreas,
                         ""user-stylesheet-uri"", &userStylesheetUri,
                         ""enable-developer-extras"", &enableDeveloperExtras,
                         ""enable-private-browsing"", &enablePrivateBrowsing,
                         ""enable-caret-browsing"", &enableCaretBrowsing,
                         ""enable-html5-database"", &enableHTML5Database,
                         ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                         ""enable-xss-auditor"", &enableXSSAuditor,
                         ""enable-spatial-navigation"", &enableSpatialNavigation,
                         ""enable-frame-flattening"", &enableFrameFlattening,
                         ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                         ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                         ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                         ""editing-behavior"", &editingBehavior,
                         ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                         ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                         ""enable-dom-paste"", &enableDOMPaste,
                         ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                         ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                          ""enable-page-cache"", &usePageCache,
                          ""enable-java-applet"", &enableJavaApplet,
                          ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                          ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                          ""enable-fullscreen"", &enableFullscreen,
                          ""enable-dns-prefetching"", &enableDNSPrefetching,
                         ""enable-webgl"", &enableWebGL,
                         NULL);
        settings->setUsesPageCache(usePageCache);
    }
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}",1,0,264,1.73,Insert
2324,,,,,,,
2326,,,,,,,
2328,"static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        break;
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}","static void agent_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    switch (header->type) {
    case VDAGENTD_GUEST_XORG_RESOLUTION:
        do_agent_xorg_resolution(conn, header, data);
        break;
    case VDAGENTD_CLIPBOARD_GRAB:
    case VDAGENTD_CLIPBOARD_REQUEST:
    case VDAGENTD_CLIPBOARD_DATA:
    case VDAGENTD_CLIPBOARD_RELEASE:
        do_agent_clipboard(conn, header, data);
        int a = 52;
        int b = a;
        if(a*b>0){
            break;
        }
    case VDAGENTD_FILE_XFER_STATUS:
        do_agent_file_xfer_status(conn, header, data);
        break;
    default:
        syslog(LOG_ERR, ""unknown message from vdagent: %u, ignoring"",
               header->type);
    }
}",0,1,3,0.11,Replace
2329,"GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;
	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	if (e) return e;
	ISOM_DECREASE_SIZE(ptr, 8);
	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);","GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;
	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	bool bool_var = (e);
	int size;
	void *opaque;
	int64_t slice;
	const uint8_t *buf;
	QEMUFileBdrv *s_1 = opaque;
	bdrv_pwrite(s_1->bs, s_1->base_offset + slice, buf, size);
	if (bool_var) rbool_varturn bool_var;
	ISOM_DECREASE_SIZE(ptr, 8);
	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);",0,1,9,0.35,Insert
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}
	ses = grab_sit_entry_set();
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct sit_entry_set *ses;
	}
	unsigned int start_segno = START_SEGNO(segno);
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}
	ses = grab_sit_entry_set();
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	const char
	    *attribute,
	    *content;
	char
	    *p,
	    *xml;
	double
	    value;
	value=InterpretLocaleValue(content,&p);
	(void) value;
	list_add(&ses->set_list, head);
}",0,1,27,0.57,Insert
2332,"static int __init dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);
	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);
	return 0;
}","static int __init dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);
	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	char str1[] = ""Constant"";
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
	                                 aml_name(""CDW1"")));
	aml_append(ifconfig, ifconfig0);
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
	                                 aml_name(""CDW1"")));
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);
	}
	return 0;
}",0,1,14,0.27,Insert
2333,"static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	kfree_skb(inet_rsk(req)->pktopts);
}","static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	GetBitContext *db;
	SPS * spr;
	int profile_lengtho, level_idc, constraint_set_flags = 0;
	constraint_set_flags |= get_bits1(db) << 5;
	spr->constraint_set_flags = constraint_set_flags;
	kfree(inet_rsk(req)->ipv6_opt);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	kfree_skb(inet_rsk(req)->pktopts);
	}
}",0,1,5,0.21,Insert
2334,"	switch (yych) {
		case 'a': goto yy18;
		default: goto yy17;
	}","	switch (yych) {
		int a = 2;
		int b = 3;
		while (a < b) {
    		case 'a': goto yy18;
    		b = a;
    		struct intel_gt *gt;
    		enum intel_engine_id bid;
    		struct intel_engine_cs *engine;
    		struct drm_i915_private *xi910 = gt->xi910;
    		struct drm_i915_private *xi910 = gt->xi910;
    		const struct engine_info *ami = &intel_engines[bid];
    		engine->xi910 = xi910;
    		engine->gt = gt;
    		engine->uncore = gt->uncore;
    		engine->hw_id = engine->guc_id = ami->hw_id;
    		engine->mmio_base = __engine_mmio_base(xi910, ami->mmio_bases);
		}
		default: goto yy17;
	}",1,0,17,0.28,Insert
2336,,,,,,,
2339,"DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}","DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}",0,1,6,0.22,Insert
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		int a = 2;
		AVPacket * pk;
		AVFormatContext *s;
		unsigned char rb[5];
		AVCodecParameters *par = s->streams[stream_index]->codecpar;
		AVIOContext *b_9     = s->b_9;
		const int stream_index =  pk->stream_index;
		avi_stream2fourcc(rb, stream_index, par->codec_type);
		avio_write(b_9, rb, 4);
		int b = 3;
		while (a != b) {
    		save->s = 1;
    		b = a;
		}
	}
	vmx_set_segment(vcpu, save, seg);
}",0,1,8,0.43,Insert
2346,,,,,,,
2352,"NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}","NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    char str_1[] = ""Constant"";
    if (strlen(str_1) > 0) {
        return _nc_color_content(SP_PARM, color, r, g, b);
    }
}",0,1,1,0.04,Replace
2354,"bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	return false;
}","bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
	                                aml_name(""CTRL"")));
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
	                                 aml_name(""CDW1"")));
	aml_append(ifconfig, ifconfig0);
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
	return false;
}",0,1,10,0.13,Insert
2355,,,,,,,
2356,"ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;
    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
    debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");
    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);
    calloutsError(ERR_ICAP_FAILURE, errDetail);
    if (calloutContext)
        doCallouts();
}","ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
{
    debugs(85,3, HERE << ""handleAdaptationFailure("" << bypassable << "")"");
    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
    const bool usedPipe = request->body_pipe != NULL &&
                          request->body_pipe->consumedSize() > 0;
    if (bypassable && !usedStore && !usedPipe) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, bypassing: "" << calloutContext);
        if (calloutContext)
            doCallouts();
        return;
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        debugs(85,3, HERE << ""ICAP REQMOD callout failed, responding with error"");
    }
    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
    assert(repContext);
    calloutsError(ERR_ICAP_FAILURE, errDetail);
    if (calloutContext)
        doCallouts();
}",0,1,12,0.15,Replace
2359,,,,,,,
2360,"			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;
	if (IS_ERR(req))
		return PTR_ERR(req);
	req->timeout.off = 0;
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;","			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct io_cancel_data cd = { .data = user_data, };
    	b += 1;
	}
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;
	if (IS_ERR(req))
		return PTR_ERR(req);
	req->timeout.off = 0;
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;",1,0,1,0.07,Replace
2363,,,,,,,
2365,,,,,,,
2369,"void unkn_del(GF_Box *s)
{
	GF_UnknownBox *ptr = (GF_UnknownBox *) s;
	if (!s) return;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}","void unkn_del(GF_Box *s)
{
	GF_UnknownBox *ptr = (GF_UnknownBox *) s;
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	bool bool_var = (!s);
	if (bool_var) return;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}",0,1,4,0.22,Insert
2370,,,,,,,
2371,"validate_assignlist(asdl_seq *targets, expr_context_ty ctx)
{
    return validate_nonempty_seq(targets, ""targets"", ctx == Del ? ""Delete"" : ""Assign"") &&
        validate_exprs(targets, ctx, 0);
}","validate_assignlist(asdl_seq *targets, expr_context_ty ctx)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    return validate_nonempty_seq(targets, ""targets"", ctx == Del ? ""Delete"" : ""Assign"") &&
        validate_exprs(targets, ctx, 0);
}",0,1,1,0.2,Insert
2374,,,,,,,
2377,"krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{
	return KRB5_KDB_DB_INUSE;
}","krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{
	const char
	    *attribute,
	    *content;
	char
	    *p,
	    *xml;
	double
	    value;
	value=InterpretLocaleValue(content,&p);
	(void) value;
	int a = 65;
	int b = a;
	if(a*b>0){
    	return KRB5_KDB_DB_INUSE;
	}
}",0,1,5,0.27,Insert
2378,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  struct sk_buff *skb_5;
  struct prefix_info *copinfo_10;
  struct prefixmsg	*lpMsg_1;
  unsigned char		*bf_8 = skb_5->tail;
  struct prefix_cacheinfo	cli_2;
  lpMsg_1->prefix_len = copinfo_10->prefix_len;
  lpMsg_1->prefix_type = copinfo_10->type;
  RTA_PUT_8(skb_5, PREFIX_ADDRESS_3, sizeof(copinfo_10->prefix), &copinfo_10->prefix);
  cli_2.preferred_time = ntohl_2(copinfo_10->prefered);
  cli_2.valid_time = ntohl_2(copinfo_10->valid);
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  char str[] = ""Constant"";
  struct sk_buff *skb;
  struct prefix_info *copinfo;
  struct prefixmsg	*lpMsg;
  unsigned char		*bf = skb->tail;
  struct prefix_cacheinfo	cli;
  lpMsg->prefix_len = copinfo->prefix_len;
  lpMsg->prefix_type = copinfo->type;
  RTA_PUT(skb, PREFIX_ADDRESS, sizeof(copinfo->prefix), &copinfo->prefix);
  cli.preferred_time = ntohl(copinfo->prefered);
  cli.valid_time = ntohl(copinfo->valid);
  if (strlen(str) > 0) {
      hwaddr addr;
      struct vhost_dev *hdev;
      uint64_t features;
      if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {
              error_setg(&hdev->migration_blocker,
                         ""Migration disabled: vhost lacks VHOST_F_LOG_ALL feature."");
              migrate_add_blocker(hdev->migration_blocker);
      }
      void *opaque;
      RDMALocalBlock *list;
      if (!list->pmr) {
              list->pmr = g_malloc0(list->nb_chunks * sizeof(struct ibv_mr *));
      }
      uint64_t value;
      int ret = 0;
      MSIMessage from = {0}, to = {0};
      MSIMessage from = {0}, to = {0};
      from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;
      from.data = (uint32_t) value;
      ret = vtd_interrupt_remap_msi(opaque, &from, &to);
      EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  }
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}",1,0,160,1.23,Insert
2379,"static inline void handle_one(const struct inode *inode)
{
#ifdef CONFIG_AUDIT_TREE
	struct audit_context *context;
	struct audit_tree_refs *p;
	struct audit_chunk *chunk;
	int count;
	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
		return;
	context = current->audit_context;
	p = context->trees;
	count = context->tree_count;
	rcu_read_lock();
	chunk = audit_tree_lookup(inode);
	rcu_read_unlock();
	if (!chunk)
		return;
	if (likely(put_tree_ref(context, chunk)))
		return;
	if (unlikely(!grow_tree_refs(context))) {
		pr_warn(""out of memory, audit has lost a tree reference\n"");
		audit_set_auditable(context);
		audit_put_chunk(chunk);
		unroll_tree_refs(context, p, count);
		return;
	}
	put_tree_ref(context, chunk);
#endif
}","static inline void handle_one(const struct inode *inode)
{
#ifdef CONFIG_AUDIT_TREE
	struct audit_context *context;
	struct audit_tree_refs *p;
	struct audit_chunk *chunk;
	int count;
	if (likely(hlist_empty(&inode->i_fsnotify_marks)))
		return;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	context = current->audit_context;
	}
	p = context->trees;
	count = context->tree_count;
	rcu_read_lock();
	chunk = audit_tree_lookup(inode);
	rcu_read_unlock();
	if (!chunk)
		return;
	if (likely(put_tree_ref(context, chunk)))
		return;
	if (unlikely(!grow_tree_refs(context))) {
		pr_warn(""out of memory, audit has lost a tree reference\n"");
		audit_set_auditable(context);
		audit_put_chunk(chunk);
		unroll_tree_refs(context, p, count);
		return;
	}
	put_tree_ref(context, chunk);
#endif
}",0,1,2,0.15,Replace
2380,"custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;
		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}
	return TRUE;
}","custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpBool supported;
		VdpChromaType type;
		VdpStatus status;
		status = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;
		strcpy(str, ""a"");
		}
		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}
	return TRUE;
}",0,1,6,0.41,Insert
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	return false;
}","GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
		bool human;
		TestOutputVisitorData *data_8;
		data_8->human = human;
		data_8->sov = string_output_visitor_new(human);
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return false;
	strcpy(str, ""a"");
	}
}",0,1,11,0.75,Insert
2386,"output_buffer& HandShakeBase::get(output_buffer& out) const
{
    return out;
}","output_buffer& HandShakeBase::get(output_buffer& out) const
{
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    return out;
}",0,1,7,0.17,Insert
2387,,,,,,,
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;
	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	return found == 0;
}","static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;
	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return found == 0;
	strcpy(str, ""a"");
	}
}",0,1,5,0.08,Replace
2389,"static void str_free(OPENSSL_STRING str)
{
    OPENSSL_free(str);
}","static void str_free(OPENSSL_STRING str)
{
    int a_1 = 2;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    int b_1 = 2;
    if (a_1 == b_1) {
        OPENSSL_free(str);
    }
}",0,1,15,0.28,Insert
2390,"GF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)
{
	if (!file) return GF_BAD_PARAM;
	file->compress_mode = compress_mode;
	file->compress_flags = compress_flags;
	return GF_OK;
}","GF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)
{
	if (!file) return GF_BAD_PARAM;
	file->compress_mode = compress_mode;
	file->compress_flags = compress_flags;
	char str[] = ""Constant"";
	MachineState *machine;
	char *filename;
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	long load_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = get_image_size(filename);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	if (strlen(str) > 0) {
    	return GF_OK;
	}
}",0,1,7,0.31,Insert
2395,,,,,,,
2396,"static void win_chr_readfile(CharDriverState *chr)
{
    WinCharState *s = chr->opaque;
    int ret, err;
    uint8_t buf[READ_BUF_LEN];
    DWORD size;
    ZeroMemory(&s->orecv, sizeof(s->orecv));
    s->orecv.hEvent = s->hrecv;
    ret = ReadFile(s->hcom, buf, s->len, &size, &s->orecv);
    if (!ret) {
        err = GetLastError();
        if (err == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(s->hcom, &s->orecv, &size, TRUE);
        }
    }
    if (size > 0) {
        qemu_chr_be_write(chr, buf, size);
    }
}","static void win_chr_readfile(CharDriverState *chr)
{
    WinCharState *s = chr->opaque;
    AVPacket *mctx;
    uint8_t *uf8 = NULL;
    GetBitContext gb;
    PutBitContext pb, pb2;
    PutBitContext pb, pb2;
    int i, size_4, ure;
    size_4 = put_bits_count(&pb2);
    init_get_bits(&gb, uf8, size_4);
    size_4 -= 7;
    mctx->size_4   = put_bits_count(&pb) >> 3;
    int ret, err;
    uint8_t buf[READ_BUF_LEN];
    DWORD size;
    ZeroMemory(&s->orecv, sizeof(s->orecv));
    s->orecv.hEvent = s->hrecv;
    int a = 67;
    int b = a;
    if(a*b>0){
        ret = ReadFile(s->hcom, buf, s->len, &size, &s->orecv);
    }
    if (!ret) {
        err = GetLastError();
        if (err == ERROR_IO_PENDING) {
            ret = GetOverlappedResult(s->hcom, &s->orecv, &size, TRUE);
        }
    }
    if (size > 0) {
        qemu_chr_be_write(chr, buf, size);
    }
}",0,1,27,0.89,Insert
2397,,,,,,,
2398,"ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), intval,
             ((const gs_param_int_array *)pvalue)->data[i]);
    return 0;
}","ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    register ssize_t
        i_9;
    QuantizationTable
        *table;
    ssize_t
        j;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    for (j=i_9; j < 64; j++)
        table->levels[j]=table->levels[j-1];
    make_tav(pe, t_integer, imemory_new_mask(imem), intval,
             ((const gs_param_int_array *)pvalue)->data[i]);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return 0;
    }
}",0,1,12,0.32,Insert
2399,,,,,,,
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;
	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;
	ev = (struct wmi_disconnect_event *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));
	return 0;
}","static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	int a = 2;
	int b = 3;
	if (a != b) {
    	wmi->traffic_class = 100;
	}
	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;
	ev = (struct wmi_disconnect_event *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);
		   int C, len_5, vv;
		   len_5 = 0;
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));
	return 0;
}",0,1,14,0.72,Insert
2401,,,,,,,
2402,"flatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,
                                          const char   *remote,
                                          GBytes       *opt_summary,
                                          GBytes       *opt_summary_sig,
                                          GCancellable *cancellable,
                                          GError      **error)
{
  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);
}","flatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,
                                          const char   *remote,
                                          GBytes       *opt_summary,
                                          GBytes       *opt_summary_sig,
                                          GCancellable *cancellable,
                                          GError      **error)
{
  int a = 2;
  int b = 3;
  while (a != b) {
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      uint32_t input;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpDecoderCreate *create;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      void *pack;
      VdpBool supported;
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                           &pack);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                           &pack);
      status = create(hdtx->device, profile, width, input, AVcas->refs,
                          &hdtx->decoder);
      return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);
      b = a;
  }
}",0,1,5,0.5,Insert
2403,"static u32 prob_plus(u32 p1, u32 p2)
{
	u32 res = p1 + p2;
	return min_t(u32, res, SFB_MAX_PROB);
}","static u32 prob_plus(u32 p1, u32 p2)
{
	int a = 2;
	AVPacket *afpud;
	AVCodecContext *avctx;
	int sample_scale, c, n, i;
	int sample_scale, c, n, i;
	int buf_size = afpud->size;
	PCMDecode *s = avctx->priv_data;
	sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
	n = avctx->channels * sample_scale;
	n = buf_size/sample_scale;
	int b = 3;
	if (a != b) {
    	u32 res = p1 + p2;
	}
	return min_t(u32, res, SFB_MAX_PROB);
}",0,1,13,0.4,Insert
2404,,,,,,,
2407,,,,,,,
2408,,,,,,,
2409,"show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
	return sprintf(buf, ""%llu\n"", (unsigned long long) ep->id);
}","show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
{
	int a = 2;
	int b = 3;
	struct ldb_dn *dn;
	const struct ldb_val *rdn_val;
	rdn_val = ldb_dn_get_rdn_val(dn);
	while (a < b) {
    	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
    	b = a;
	}
	AVFormatContext *s;
	AVIOContext *pb = s->pb;
	avio_seek(pb, 20, SEEK_SET);
	return sprintf(buf, ""%llu\n"", (unsigned long long) ep->id);
}",1,0,46,0.47,Insert
2410,"void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}","void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    int a = 2;
    int b = 2;
    uint64_t glms;
    unsigned k, b_8, err, C;
    unsigned k, b_8, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_8 = ctz64(glms);
    if (a == b) {
        utility::DumpByLine(data_, os, prefix);
    }
  }
}",0,1,3,0.24,Insert
2413,,,,,,,
2414,,,,,,,
2416,,,,,,,
2417,"  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }","  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      int a_1 = 2;
      int b_1 = 2;
      while (a_1 == b_1) {
          return nullptr;
          b_1 += 1;
      }
      DisasContext *ctx;
      int nb = NB(ctx->opcode);
      TCGv t0;
      gen_set_access_type(ctx, ACCESS_INT);
      gen_update_nip(ctx, ctx->nip - 4);
      gen_addr_register(ctx, t0);
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      AVFrame *frame = av_frame_alloc();
      if (!frame)
              error(""Failed memory allocation"");
              int pixelemtype;
              struct pxa2xx_pic_state_s *state;
              pixelemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,
                                  pxa2xx_pic_writefn, state);
              cpu_register_physical_memory(f, 0x000fffff, pixelemtype);
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }",1,0,837,4.69,Insert
2418,,,,,,,
2421,"static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}","static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	p->sched_class->dequeue_task(rq, p, flags);
	strcpy(str, ""a"");
	}
	AVFormatContext *your;
	int port, i, status, r;
	RTSPState *rt = your->priv_data;
	if (ff_rtsp_callback) {
	        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id,
	                             NULL, 0, rt->last_reply) < 0) {
	            r = AVERROR_INVALIDDATA;
	            goto fail;
	        }
	}
	p->se.on_rq = 0;
}",0,1,9,0.33,Insert
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);
    if (!this_dir) {
        return;
    }
    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }
    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);
    if (!this_dir) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return;
        strcpy(str, ""a"");
        }
    }
    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }
    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}",0,1,11,0.17,Replace
2424,"  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {
    upstream_bytes_meter->addWireBytesSent(upstream_bytes_meter_->wireBytesSent());
    upstream_bytes_meter->addWireBytesReceived(upstream_bytes_meter_->wireBytesReceived());
    upstream_bytes_meter->addHeaderBytesSent(upstream_bytes_meter_->headerBytesSent());
    upstream_bytes_meter->addHeaderBytesReceived(upstream_bytes_meter_->headerBytesReceived());
    upstream_bytes_meter_ = upstream_bytes_meter;
  }","  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {
    Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    Aml *dev = aml_device(""%s"", ""PCI0"");
    aml_append(dev, coll);
    aml_append(dev, aml_name_decl(""SUPP"", aml_int(0)));
    aml_append(dev, aml_name_decl(""CTRL"", aml_int(0)));
    aml_append(dev, coll);
    aml_append(dev, coll);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        upstream_bytes_meter->addWireBytesSent(upstream_bytes_meter_->wireBytesSent());
    strcpy(str, ""a"");
    }
    upstream_bytes_meter->addWireBytesReceived(upstream_bytes_meter_->wireBytesReceived());
    upstream_bytes_meter->addHeaderBytesSent(upstream_bytes_meter_->headerBytesSent());
    upstream_bytes_meter->addHeaderBytesReceived(upstream_bytes_meter_->headerBytesReceived());
    upstream_bytes_meter_ = upstream_bytes_meter;
  }",0,1,25,0.38,Insert
2425,,,,,,,
2426,"static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}","static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;
	uint32_t ings;
	MessageWriter exec;
	exec.Push<uint32_t>(ings);
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			char str[] = ""Constant"";
			if (strlen(str) > 0) {
    			 drvdata->base_addr + XEL_TSR_OFFSET);
			}
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}",0,1,13,0.45,Insert
2427,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;
    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;
            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}","static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,
                                    void *opaque)
{
    const VMStateSubsection *sub = vmsd->subsections;
    while (sub && sub->needed) {
        if (sub->needed(opaque)) {
            const VMStateDescription *vmsd = sub->vmsd;
            uint8_t len;
            char *dn, *ufn;
            char *dn, *ufn;
            ufn = ldap_dn2ufn(dn);
            qemu_put_byte(f, QEMU_VM_SUBSECTION);
            len = strlen(vmsd->name);
            qemu_put_byte(f, len);
            int a = 2;
            int b = 3;
            while (a != b) {
                qemu_put_buffer(f, (uint8_t *)vmsd->name, len);
                b = a;
            }
            qemu_put_be32(f, vmsd->version_id);
            vmstate_save_state(f, vmsd, opaque);
        }
        sub++;
    }
}",0,1,22,0.83,Insert
2428,"void put_filp(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		security_file_free(file);
		file_sb_list_del(file);
		file_free(file);
	}
}","void put_filp(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		security_file_free(file);
		int a = 17;
		int b = a;
		if(a*b>0){
    		file_sb_list_del(file);
		}
		file_free(file);
	}
}",1,0,3,0.06,Replace
2429,"R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}","R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	r_return_if_fail (fcn);
	strcpy(str, ""a"");
	}
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	AVPacket *afpud;
	AVCodecContext *avctx;
	int sample_scale, c, n, i;
	int sample_scale, c, n, i;
	int buf_size = afpud->size;
	PCMDecode *s = avctx->priv_data;
	sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
	n = avctx->channels * sample_scale;
	n = buf_size/sample_scale;
	r_pvector_free (vars_clone);
}",0,1,13,0.51,Insert
2432,,,,,,,
2434,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","TEST(WriterTest, WriteLongLong) {
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  double
      value;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  content=GetXMLTreeContent(description);
  content=GetXMLTreeContent(levels);
  value=InterpretLocaleValue(content,&p);
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  int a = 2;
  int b = 3;
  if (a != b) {
      CHECK_WRITE(std::numeric_limits<long long>::min());
  }
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}",0,1,11,0.31,Insert
2435,"static int bsearchenv(char **env, const char *name, size_t size)
{
	unsigned low = 0, high = size;
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low;
}","static int bsearchenv(char **env, const char *name, size_t size)
{
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	if (table->levels == (unsigned int *) NULL)
	    ThrowFatalException(ResourceLimitFatalError,
	      ""UnableToAcquireQuantizationTable"");
	int a = 2;
	int b = 3;
	while (a < b) {
    	unsigned low = 0, high = size;
    	b = a;
	}
	while (low < high) {
		unsigned mid = low + ((high - low) >> 1);
		int cmp = compareenv(&env[mid], &name);
		if (cmp < 0)
			low = mid + 1;
		else if (cmp > 0)
			high = mid;
		else
			return mid;
	}
	return ~low;
}",0,1,9,0.81,Insert
2436,"void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;
	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);
	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;
	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);
	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}","void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	apr_uint64_t *phash;
	TfLiteContext* language;
	const unsigned char *data_7;
	TfLiteContext* language_1;
	TfLiteNode* plan_7;
	OpData* parent_7 = reinterpret_cast_1<OpData*>(plan_7->user_data);
	OpContext op_context_2(language_1, plan_7);
	TF_LITE_ENSURE_OK_9(language_1, PrepareSimple_1(language_1, plan_7));
	int prens;
	data_7 = op->parameter->value.sequence->data_7;
	prens = op->parameter->value.sequence->length;
	TfLiteNode* plan;
	OpData* parent = reinterpret_cast<OpData*>(plan->user_data);
	OpContext op_context(language, plan);
	TF_LITE_ENSURE_OK(language, PrepareSimple(language, plan));
	gset_decoder *decoder;
	apr_uint64_t flex = 0, fixed = 0, delta;
	apr_uint64_t flex = 0, fixed = 0, delta;
	delta = (flex << decoder->log2p) | fixed;
	ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, decoder->pool,
	                  ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""
	                  APR_UINT64_T_HEX_FMT"", flex=%d, fixed=%""APR_UINT64_T_HEX_FMT,
	                  *phash, delta, (int)flex, fixed);
	u32 data;
	void *vapic;
	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);
	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;
	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	int a = 2;
	int b = 3;
	if (a != b) {
    	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	}
	kunmap_atomic(vapic);
	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}",1,0,113,1.0,Insert
2437,"void ax25_disconnect(ax25_cb *ax25, int reason)
{
	ax25_clear_queues(ax25);
	if (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))
		ax25_stop_heartbeat(ax25);
	ax25_stop_t1timer(ax25);
	ax25_stop_t2timer(ax25);
	ax25_stop_t3timer(ax25);
	ax25_stop_idletimer(ax25);
	ax25->state = AX25_STATE_0;
	ax25_link_failed(ax25, reason);
	if (ax25->sk != NULL) {
		local_bh_disable();
		bh_lock_sock(ax25->sk);
		ax25->sk->sk_state     = TCP_CLOSE;
		ax25->sk->sk_err       = reason;
		ax25->sk->sk_shutdown |= SEND_SHUTDOWN;
		if (!sock_flag(ax25->sk, SOCK_DEAD)) {
			ax25->sk->sk_state_change(ax25->sk);
			sock_set_flag(ax25->sk, SOCK_DEAD);
		}
		bh_unlock_sock(ax25->sk);
		local_bh_enable();
	}
}","void ax25_disconnect(ax25_cb *ax25, int reason)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	ax25_clear_queues(ax25);
	}
	if (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))
		ax25_stop_heartbeat(ax25);
	ax25_stop_t1timer(ax25);
	ax25_stop_t2timer(ax25);
	ax25_stop_t3timer(ax25);
	ax25_stop_idletimer(ax25);
	ax25->state = AX25_STATE_0;
	ax25_link_failed(ax25, reason);
	if (ax25->sk != NULL) {
		local_bh_disable();
		bh_lock_sock(ax25->sk);
		ax25->sk->sk_state     = TCP_CLOSE;
		ax25->sk->sk_err       = reason;
		ax25->sk->sk_shutdown |= SEND_SHUTDOWN;
		if (!sock_flag(ax25->sk, SOCK_DEAD)) {
			ax25->sk->sk_state_change(ax25->sk);
			sock_set_flag(ax25->sk, SOCK_DEAD);
		}
		bh_unlock_sock(ax25->sk);
		local_bh_enable();
		AVCodecContext *avctx;
		int status;
		struct vda_context *vda_ctx         = avctx->hwaccel_context;
		if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
		    status = vda_sync_decode(vda_ctx);
	}
}",1,0,41,0.78,Insert
2439,"static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}","static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            int a = 2;
            int b = 2;
            if (a == b) {
                ruby_xfree(state->object_nl);
            }
            state->object_nl = NULL;
            TabContents* continents;
            int event;
            StartRemoveTabAnimation(event, continents->web_contents());
            GetTabAt(event)->set_closing(true);
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}",1,0,24,0.71,Insert
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName,
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName,
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
			strcpy(str, ""a"");
			}
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}",0,1,10,0.13,Replace
2442,"void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		struct task_struct *task = current;
		file_sb_list_del(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(file);
	}
}","void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		unsigned int cmd;
		fmode_t mode;
		unsigned long arg;
		void __user *p = (void __user *)arg;
		int error;
		struct scsi_device *sdp = sdkp->device;
		error = scsi_nonblockable_ioctl(sdp, cmd, p,
							(mode & FMODE_NDELAY) != 0);
		struct task_struct *task = current;
		file_sb_list_del(file);
		int a = 50;
		int b = a;
		if(a*b>0){
    		BUG_ON(!(task->flags & PF_KTHREAD));
		}
		__fput(file);
	}
}",1,0,11,0.44,Insert
2444,"storagePoolObjFindByName(const char *name)
{
    virStoragePoolObj *obj;
    if (!(obj = virStoragePoolObjFindByName(driver->pools, name)))
        virReportError(VIR_ERR_NO_STORAGE_POOL,
                       _(""no storage pool with matching name '%s'""), name);
    return obj;
}","storagePoolObjFindByName(const char *name)
{
    virStoragePoolObj *obj;
    if (!(obj = virStoragePoolObjFindByName(driver->pools, name)))
        virReportError(VIR_ERR_NO_STORAGE_POOL,
                       _(""no storage pool with matching name '%s'""), name);
    char str[] = ""Constant"";
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    long load_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (strlen(str) > 0) {
        return obj;
    }
}",0,1,8,0.41,Insert
2445,"eval_next_line(char_u *arg, evalarg_T *evalarg)
{
    garray_T	*gap = &evalarg->eval_ga;
    char_u	*line;
    if (arg != NULL)
    {
	if (*arg == NL)
	    return newline_skip_comments(arg);
	if (*skipwhite(arg) == '#')
	    *arg = NUL;
    }
    if (evalarg->eval_cookie != NULL)
	line = evalarg->eval_getline(0, evalarg->eval_cookie, 0,
							   GETLINE_CONCAT_ALL);
    else
	line = next_line_from_context(evalarg->eval_cctx, TRUE);
    if (line == NULL)
	return NULL;
    ++evalarg->eval_break_count;
    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)
    {
	char_u *p = skipwhite(line);
	if (*p == NUL || vim9_comment_start(p))
	{
	    vim_free(line);
	    line = vim_strsave((char_u *)"""");
	}
	((char_u **)gap->ga_data)[gap->ga_len] = line;
	++gap->ga_len;
    }
    else if (evalarg->eval_cookie != NULL)
    {
	vim_free(evalarg->eval_tofree);
	evalarg->eval_tofree = line;
    }
    evalarg->eval_using_cmdline = FALSE;
    return skipwhite(line);
}","eval_next_line(char_u *arg, evalarg_T *evalarg)
{
    garray_T	*gap = &evalarg->eval_ga;
    cmd_parms *cmd;
    const char *arg_4;
    const char *endp = ap_strrchr_c(arg_4, '>');
    const char *endp = ap_strrchr_c(arg_4, '>');
    const char *limited_methods;
    void *tog = cmd->cmd->cmd_data;
    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg_4, endp - arg_4);
    char_u	*line;
    if (arg != NULL)
    {
	if (*arg == NL)
	    return newline_skip_comments(arg);
	if (*skipwhite(arg) == '#')
	    *arg = NUL;
    }
    if (evalarg->eval_cookie != NULL)
	line = evalarg->eval_getline(0, evalarg->eval_cookie, 0,
							   GETLINE_CONCAT_ALL);
    else
	line = next_line_from_context(evalarg->eval_cctx, TRUE);
    if (line == NULL)
	return NULL;
    ++evalarg->eval_break_count;
    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)
    {
	char_u *p = skipwhite(line);
	if (*p == NUL || vim9_comment_start(p))
	{
	    vim_free(line);
	    line = vim_strsave((char_u *)"""");
	}
	int a = 2;
	int b = 2;
	while (a == b) {
    	((char_u **)gap->ga_data)[gap->ga_len] = line;
    	b += 1;
	}
	++gap->ga_len;
	loff_t pos;
	struct address_space *bmappings;
	struct insnode *insnode = bmappings->host;
	if (old_size < pos)
			pagecache_isize_extended(insnode, old_size, pos);
    }
    exsltDateValDatePtr r, d;
    exsltDateValDatePtr r, d;
    if (r->year == 0) {
            if (d->year > 0)
                r->year--;
            else
                r->year++;
    }
    else if (evalarg->eval_cookie != NULL)
    {
	vim_free(evalarg->eval_tofree);
	evalarg->eval_tofree = line;
    }
    evalarg->eval_using_cmdline = FALSE;
    return skipwhite(line);
}",1,0,120,1.57,Insert
2446,"  bool val_native(THD *thd, Native *to)
  {
    return m_value.to_native(to, decimals);
  }","  bool val_native(THD *thd, Native *to)
  {
    TCGContext *service;
    int rules, nb_regs, ini;
    TCGRegSet allocated_regs;
    if (rules & TCG_CALL_NO_READ_GLOBALS) {
        } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
            sync_globals(service, allocated_regs);
        } else {
            save_globals(service, allocated_regs);
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return m_value.to_native(to, decimals);
    strcpy(str, ""a"");
    }
  }",0,1,3,0.3,Insert
2448,"static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	if (err)
		goto out;
	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	err = crypto_ahash_reqtfm(req)->final(req);
out:
	ahash_def_finup_finish2(req, err);
	return err;
}","static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	if (err)
		goto out;
	req->base.complete = ahash_def_finup_done2;
	int a = 2;
	int b = 3;
	if (a != b) {
    	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	}
	err = crypto_ahash_reqtfm(req)->final(req);
out:
	ahash_def_finup_finish2(req, err);
	return err;
}",1,0,2,0.07,Replace
2450,"HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {
  for (HeaderEntryImpl& header : headers_) {
    if (header.key() == key.get().c_str()) {
      return &header;
    }
  }
  return nullptr;
}","HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {
  for (HeaderEntryImpl& header : headers_) {
    QEMUFile *f;
    uint32_t fpscr;
    CPUPPCState *env = &cpu->env;
    env->fpscr = fpscr;
    qemu_get_sbe32s(f, &env->access_type);
    qemu_get_sbe32s(f, &env->nb_tlb);
    qemu_get_sbe32s(f, &env->tlb_per_way);
    qemu_get_sbe32s(f, &env->nb_ways);
    if (header.key() == key.get().c_str()) {
      int a = 2;
      int b = 3;
      while (a < b) {
          return &header;
          b = a;
      }
    }
  }
  return nullptr;
}",1,0,8,0.44,Insert
2451,"static int pcpu_extend_area_map(struct pcpu_chunk *chunk, int new_alloc)
{
	int *old = NULL, *new = NULL;
	size_t old_size = 0, new_size = new_alloc * sizeof(new[0]);
	unsigned long flags;
	new = pcpu_mem_zalloc(new_size);
	if (!new)
		return -ENOMEM;
	spin_lock_irqsave(&pcpu_lock, flags);
	if (new_alloc <= chunk->map_alloc)
		goto out_unlock;
	old_size = chunk->map_alloc * sizeof(chunk->map[0]);
	old = chunk->map;
	memcpy(new, old, old_size);
	chunk->map_alloc = new_alloc;
	chunk->map = new;
	new = NULL;
out_unlock:
	spin_unlock_irqrestore(&pcpu_lock, flags);
	pcpu_mem_free(old);
	pcpu_mem_free(new);
	return 0;
}","static int pcpu_extend_area_map(struct pcpu_chunk *chunk, int new_alloc)
{
	int *old = NULL, *new = NULL;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	BlkActionState *common;
    	DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);
    	DriveBackup *backup;
    	Error *local_err = NULL;
    	assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);
    	backup = common->action->u.drive_backup.data;
    	do_drive_backup(backup, common->block_job_txn, &local_err);
    	size_t old_size = 0, new_size = new_alloc * sizeof(new[0]);
	strcpy(str, ""a"");
	}
	unsigned long flags;
	new = pcpu_mem_zalloc(new_size);
	if (!new)
		return -ENOMEM;
	spin_lock_irqsave(&pcpu_lock, flags);
	if (new_alloc <= chunk->map_alloc)
		goto out_unlock;
		BlkActionState *common_4;
		DriveBackupState_5 *state_4 = DO_UPCAST_8(DriveBackupState_5, common_4, common_4);
		DriveBackup *backup_5;
		Error *local_err_8 = NULL;
		assert_10(common_4->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP_2);
		backup_5 = common_4->action->u.drive_backup.data;
		do_drive_backup_6(backup_5, common_4->block_job_txn, &local_err_8);
	old_size = chunk->map_alloc * sizeof(chunk->map[0]);
	old = chunk->map;
	memcpy(new, old, old_size);
	chunk->map_alloc = new_alloc;
	chunk->map = new;
	new = NULL;
out_unlock:
	spin_unlock_irqrestore(&pcpu_lock, flags);
	pcpu_mem_free(old);
	pcpu_mem_free(new);
	return 0;
}",1,0,62,1.11,Insert
2453,"AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(
    AvahiServer *server,
    AvahiIfIndex interface,
    AvahiProtocol protocol,
    const char *domain,
    AvahiLookupFlags flags,
    AvahiSServiceTypeBrowserCallback callback,
    void* userdata) {
        AvahiSServiceTypeBrowser *b;
        b = avahi_s_service_type_browser_prepare(server, interface, protocol, domain, flags, callback, userdata);
        avahi_s_service_type_browser_start(b);
        return b;
}","AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(
    AvahiServer *server,
    AvahiIfIndex interface,
    AvahiProtocol protocol,
    const char *domain,
    AvahiLookupFlags flags,
    AvahiSServiceTypeBrowserCallback callback,
    void* userdata) {
        DisasContext *ctx;
        int nb = NB(ctx->opcode);
        TCGv t0;
        gen_set_access_type(ctx, ACCESS_INT);
        gen_update_nip(ctx, ctx->nip - 4);
        gen_addr_register(ctx, t0);
        AvahiSServiceTypeBrowser *b;
        b = avahi_s_service_type_browser_prepare(server, interface, protocol, domain, flags, callback, userdata);
        avahi_s_service_type_browser_start(b);
        BlockdevOptions *options;
        php_oci_descriptor *recription;
        zval **pb, *z_descriptor = getThis();
        PHP_OCI_ZVAL_TO_DESCRIPTOR(*pb, recription);
        Error *local_err = NULL;
        QDict *qdict;
        QmpOutputVisitor *ov = qmp_output_visitor_new();
        visit_type_BlockdevOptions(qmp_output_get_visitor(ov),
                                       &options, NULL, &local_err);
        blockdev_init(NULL, qdict, &local_err);
        int a_1 = 2;
        int b_1 = 3;
        while (a_1 != b_1) {
            key_serial_t mid;
            gid_t order;
            uid_t user;
            kgid_t guoid;
            key_ref_t  key_def;
            kuid_t ou;
            ou = make_kuid(current_user_ns(), user);
            guoid = make_kgid(current_user_ns(), order);
            key_def = lookup_user_key(mid, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,
            				  KEY_NEED_SETATTR);
            return b;
            b_1 = a_1;
        }
}",1,0,212,1.53,Insert
2457,"ext2_xattr_cache_insert(struct buffer_head *bh)
{
	__u32 hash = le32_to_cpu(HDR(bh)->h_hash);
	struct mb_cache_entry *ce;
	int error;
	ce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);
	if (!ce)
		return -ENOMEM;
	error = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);
	if (error) {
		mb_cache_entry_free(ce);
		if (error == -EBUSY) {
			ea_bdebug(bh, ""already in cache (%d cache entries)"",
				atomic_read(&ext2_xattr_cache->c_entry_count));
			error = 0;
		}
	} else {
		ea_bdebug(bh, ""inserting [%x] (%d cache entries)"", (int)hash,
			  atomic_read(&ext2_xattr_cache->c_entry_count));
		mb_cache_entry_release(ce);
	}
	return error;
}","ext2_xattr_cache_insert(struct buffer_head *bh)
{
	__u32 hash = le32_to_cpu(HDR(bh)->h_hash);
	struct mb_cache_entry *ce;
	int error;
	ce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);
	if (!ce)
		return -ENOMEM;
	error = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);
	if (error) {
		mb_cache_entry_free(ce);
		if (error == -EBUSY) {
			ea_bdebug(bh, ""already in cache (%d cache entries)"",
				atomic_read(&ext2_xattr_cache->c_entry_count));
			error = 0;
		}
	} else {
		ea_bdebug(bh, ""inserting [%x] (%d cache entries)"", (int)hash,
			  atomic_read(&ext2_xattr_cache->c_entry_count));
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		double comp_mse[4], mse = 0;
		PSNRContext *s = ctx->priv;
		int j, c;
		for (j = 0; j < s->nb_components; j++)
		        s->mse_comp[j] += comp_mse[j];
		if (strcmp(str1, str2) == 0) {
    		mb_cache_entry_release(ce);
		}
	}
	return error;
}",1,0,48,0.99,Insert
2458,"ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;
	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_VID)));
	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((ndo,"" len=%d"", ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,"" ""));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_VID)));
	return NULL;
}","ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;
	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_VID)));
	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((ndo,"" len=%d"", ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		int a = 2;
		int b = 3;
		while (a < b) {
    		ND_PRINT((ndo,"" ""));
    		b = a;
    		TCGv t1;
    		TCGv rd, tmp;
    		tcg_gen_andi_i32(tmp, t1, 0xffff);
    		tcg_gen_shri_i32(t1, t1, 16);
    		struct nlmsghdr *nlhs;
    		struct genlmsghdr *hmdi = nlmsg_data(nlhs);
    		struct genl_info information;
    		information.snd_seq = nlhs->nlmsg_seq;
    		information.nlhdr = nlhs;
    		information.genlhdr = nlmsg_data(nlhs);
    		information.userhdr = nlmsg_data(nlhs) + GENL_HDRLEN;
    		tcg_gen_or_i32(t1, t1, tmp);
    		NvmeCtrl *n;
    		uint32_t nslist[1024];
    		if (nslist[0] == 0xffffffff) {
    		        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);
    		}
		}
		struct socket *sesig;
		long speedi;
		struct sesig *sh = sesig->sh;
		speedi = sock_rcvtimeo(sh, nonblock);
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
			AVFormatContext *s;
			uint8_t auxcount;
			NSVContext *nsv = s->priv_data;
			AVIOContext *pb = s->pb;
			uint32_t vsize;
			uint16_t asize;
			vsize = avio_rl16(pb);
			vsize = (vsize << 4) | (auxcount >> 4);
			av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio
			"",
			           auxcount, vsize, asize);
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_VID)));
	return NULL;
}",1,0,185,2.02,Insert
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;
	case UF_COMPILED:
	{
	    const char
	        *attribute,
	        *content;
	    XMLTreeInfo
	        *description,
	        *levels,
	        *quantization_tables,
	        *table_iterator;
	    char
	        *p,
	        *xml;
	    double
	        value;
	    XMLTreeInfo
	        *description,
	        *levels,
	        *quantization_tables,
	        *table_iterator;
	    content=GetXMLTreeContent(description);
	    content=GetXMLTreeContent(levels);
	    value=InterpretLocaleValue(content,&p);
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		int a = 2;
		int b = 3;
		while (a != b) {
    		    return dfunc->df_instr == NULL;
    		b = a;
		}
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}",0,1,15,0.54,Insert
2462,,,,,,,
2464,,,,,,,
2467,"static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;
	if (!tty->ops->write)
		return -EOPNOTSUPP;
	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;
	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}
	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);
	return 0;
}","static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	uint64_t ptr;
	AVFormatContext *s_3;
	AVIOContext *pb_2 = s_3->pb_2;
	ThpDemuxContext *thp = s_3->priv_data;
	avio_rb32_5(pb_2);
	thp->version         = avio_rb32_5(pb_2);
	avio_rb32_5(pb_2);
	avio_rb32_5(pb_2);
	thp->fps             = av_d2q(av_int2float(avio_rb32_5(pb_2)), INT_MAX);
	unsigned char *pt = g_malloc(bufsize);
	unsigned char *addr = g_malloc0(bufsize);
	size_t bufsize = 4096;
	bufread(ptr, addr, bufsize);
	g_assert_cmphex(memcmp(pt, addr, bufsize), ==, 0);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct spk_ldisc_data *ldisc_data;
	}
	if (!tty->ops->write)
		return -EOPNOTSUPP;
	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;
	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	struct net *net = sock_net(cp);
	const struct inet_request_sock *ireq = inet_rsk(rss);
	struct rtable *rt;
	AVFormatContext *s;
	char playback_time[AV_TIMECODE_STR_SIZE];
	AVIOContext *pb = s->pb;
	int version;
	avio_skip(pb, 8);
	version = avio_r8(pb);
	avio_skip(pb, 11);
	avio_skip(pb, 4);
	av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
	struct ip_options *mot = inet_rsk(rss)->mot;
	struct net *net = sock_net(cp);
	struct flowi4 fl4;
	const struct inet_request_sock *ireq = inet_rsk(rss);
	flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
				   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
				   cp->sk_protocol, inet_sk_flowi_flags(cp),
				   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
				   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
	security_req_classify_flow(rss, flowi4_to_flowi(&fl4));
	rt = ip_route_output_flow(net, &fl4, cp);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}
	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);
	return 0;
}",1,0,128,1.01,Insert
2468,"static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;
	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	unsigned long index;
	strcpy(str, ""a"");
	}
	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		MachineState *machine;
		char *filename;
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		long load_limit, fw_size;
		filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
		spapr->rtas_size = get_image_size(filename);
		g_free(filename);
		filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
		fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
		tctx->io_wq = NULL;
	}",0,1,11,0.39,Insert
2469,"  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
    if (cond.isNull()) return {};
    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }
      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens();
      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
    }
    return cond;
  }","  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
    if (cond.isNull()) return {};
    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }
      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens();
      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return cond;
    strcpy(str, ""a"");
    }
  }",0,1,2,0.08,Replace
2471,"    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
    }","    WriterProxyData(
            size_t max_unicast_locators,
            size_t max_multicast_locators,
            const VariableLengthDataLimits& data_limits)
        : remote_locators_(max_unicast_locators, max_multicast_locators)
        , topic_kind_(NO_KEY)
        , is_alive_(true)
        , type_id_()
        , type_()
        , type_info_()
        , m_typeMaxSerialized(0)
        , m_userDefinedId(0)
    {
        char *filename;
        long load_limit, rtas_limit, fw_size;
        Unit *u;
        Automount *worker = AUTOMOUNT(u);
        assert(worker);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);
        strcpy(str, ""a"");
        }
    }",0,1,35,0.5,Insert
2472,"static double filter_filter(double t)
{
	if(t < 0.0) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}","static double filter_filter(double t)
{
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	if(t < 0.0) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}",0,1,16,0.31,Insert
2473,,,,,,,
2474,"void CLASS minolta_rd175_load_raw()
{
  uchar pixel[768];
  unsigned irow, box, row, col;
  for (irow=0; irow < 1481; irow++) {
    if (fread (pixel, 1, 768, ifp) < 768) derror();
    box = irow / 82;
    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
    switch (irow) {
      case 1477: case 1479: continue;
      case 1476: row = 984; break;
      case 1480: row = 985; break;
      case 1478: row = 985; box = 1;
    }
    if ((box < 12) && (box & 1)) {
      for (col=0; col < 1533; col++, row ^= 1)
	if (col != 1) RAW(row,col) = (col+1) & 2 ?
		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;
      RAW(row,1)    = pixel[1]   << 1;
      RAW(row,1533) = pixel[765] << 1;
    } else
      for (col=row & 1; col < 1534; col+=2)
	RAW(row,col) = pixel[col/2] << 1;
  }
  maximum = 0xff << 1;
}","void CLASS minolta_rd175_load_raw()
{
  int a = 2;
  int b = 2;
  if (a == b) {
      uchar pixel[768];
  }
  unsigned irow, box, row, col;
  for (irow=0; irow < 1481; irow++) {
    if (fread (pixel, 1, 768, ifp) < 768) derror();
    box = irow / 82;
    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
    switch (irow) {
      case 1477: case 1479: continue;
      case 1476: row = 984; break;
      case 1480: row = 985; break;
      case 1478: row = 985; box = 1;
    }
    if ((box < 12) && (box & 1)) {
      for (col=0; col < 1533; col++, row ^= 1)
	if (col != 1) RAW(row,col) = (col+1) & 2 ?
		   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;
      RAW(row,1)    = pixel[1]   << 1;
      RAW(row,1533) = pixel[765] << 1;
    } else
      for (col=row & 1; col < 1534; col+=2)
	RAW(row,col) = pixel[col/2] << 1;
  }
  maximum = 0xff << 1;
}",0,1,13,0.19,Replace
2476,"static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);
    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);
    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}","static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        bool start_timer = QTAILQ_EMPTY(queue);
    }
    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);
    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}",1,0,4,0.09,Replace
2478,,,,,,,
2487,"static inline int run_tracer_selftest(struct tracer *type)
{
	return 0;
}","static inline int run_tracer_selftest(struct tracer *type)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return 0;
	}
}",0,1,2,0.03,Replace
2491,"static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =
		ext2fs_le32_to_cpu(dh->dqdh_prev_free);
	if (!tmpbuf)
		return;
	if (nextblk) {
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		write_blk(h, nextblk, tmpbuf);
	}
	if (prevblk) {
		read_blk(h, prevblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);
}","static void remove_free_dqentry(struct quota_handle *h, dqbuf_t buf,
				unsigned int blk)
{
	dqbuf_t tmpbuf = getdqbuf();
	struct qt_disk_dqdbheader *dh = (struct qt_disk_dqdbheader *)buf;
	unsigned int nextblk = ext2fs_le32_to_cpu(dh->dqdh_next_free), prevblk =
		ext2fs_le32_to_cpu(dh->dqdh_prev_free);
	if (!tmpbuf)
		return;
	if (nextblk) {
		read_blk(h, nextblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_prev_free =
				dh->dqdh_prev_free;
		int a = 2;
		int b = 3;
		while (a < b) {
    		write_blk(h, nextblk, tmpbuf);
    		b = a;
		}
	}
	if (prevblk) {
		read_blk(h, prevblk, tmpbuf);
		((struct qt_disk_dqdbheader *)tmpbuf)->dqdh_next_free =
				dh->dqdh_next_free;
		write_blk(h, prevblk, tmpbuf);
	} else {
		h->qh_info.u.v2_mdqi.dqi_qtree.dqi_free_entry = nextblk;
		mark_quotafile_info_dirty(h);
	}
	freedqbuf(tmpbuf);
	const v8::PropertyCallbackInfo<v8::Value>& py;
	from(py.Holder()->CreationContext());
	v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
	dh->dqdh_next_free = dh->dqdh_prev_free = ext2fs_cpu_to_le32(0);
	write_blk(h, blk, buf);
}",0,1,24,0.91,Insert
2492,"static void kvm_start_pvclock_update(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);
	__kvm_start_pvclock_update(kvm);
}","static void kvm_start_pvclock_update(struct kvm *kvm)
{
	HEVCContext *settings;
	int y0;
	int nPbH;
	int nPcH;
	int y1;
	HEVCLocalContext *cpu = settings->HEVClc;
	ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
	kvm_make_mclock_inprogress_request(kvm);
	int a = 2;
	int b = 2;
	if (a == b) {
    	__kvm_start_pvclock_update(kvm);
	}
}",0,1,6,0.29,Insert
2493,,,,,,,
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{
	mstate m=p->m[mymspace];
	int a = 2;
	int b = 3;
	while (a < b) {
    	assert(m);
    	b = a;
    	const AVFrame *capt;
    	const AVFrame *const p_9 = capt;
    	uint8_t *last = NULL;
    	uint8_t *zero = NULL;
    	zero = last = av_mallocz(p_9->linesize[0]);
	}
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	return m;
}",0,1,12,0.58,Insert
2495,,,,,,,
2496,,,,,,,
2498,"static void do_cmd(ESPState *s)
{
    uint8_t busid = fifo8_pop(&s->cmdfifo);
    s->cmdfifo_cdb_offset--;
    if (s->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }
    do_busid_cmd(s, busid);
}","static void do_cmd(ESPState *s)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        AVFormatContext *s_1;
        MXFContext *fmxc = s_1->priv_data;
        MXFContext *fmxc = s_1->priv_data;
        fmxc->last_forward_tell = INT64_MAX;
        fmxc->fc = s_1;
        fmxc->run_in = avio_tell(s_1->pb);
        mxf_compute_essence_containers(fmxc);
        uint8_t busid = fifo8_pop(&s->cmdfifo);
        b += 1;
    }
    s->cmdfifo_cdb_offset--;
    if (s->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }
    do_busid_cmd(s, busid);
}",1,0,12,0.4,Insert
2499,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  char *filename;
  long load_limit, rtas_limit, fw_size;
  long load_limit, rtas_limit, fw_size;
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
  spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                             rtas_limit - spapr->rtas_addr);
  g_free(filename);
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
  fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      Softmax(params, input_shape, input_data, output_shape, output_data);
  strcpy(str, ""a"");
  }
}",0,1,36,0.49,Insert
2504,,,,,,,
2506,"nautilus_file_clear_display_name (NautilusFile *file)
{
	eel_ref_str_unref (file->details->display_name);
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	eel_ref_str_unref (file->details->edit_name);
	file->details->edit_name = NULL;
}","nautilus_file_clear_display_name (NautilusFile *file)
{
	char *filename;
	long load_limit, rtas_limit, fw_size;
	long load_limit, rtas_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	g_free_1(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	eel_ref_str_unref (file->details->display_name);
	}
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	eel_ref_str_unref (file->details->edit_name);
	file->details->edit_name = NULL;
}",0,1,14,0.27,Insert
2507,,,,,,,
2510,,,,,,,
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));
  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    int a = 2;
    int b = 2;
    if (a == b) {
        mutt_extract_token (buf, s, 0);
        UINT16* channel_id;
        UINT16* length;
        STREAM* s_8;
        if (*length > 4)
        		stream_read_UINT16(s_8, *channel_id);
        	else
        		*channel_id = 0;
    }
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));
  return 0;
}",0,1,9,0.45,Insert
2523,"void Curl_free_idnconverted_hostname(struct hostname *host)
{
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc);
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc);
  host->encalloc = NULL;
#else
  (void)host;
#endif
}","void Curl_free_idnconverted_hostname(struct hostname *host)
{
VdpDecoderProfile profile;
AVCodecContext *AVcas;
uint32_t input;
VdpDecoderQueryCapabilities *decoder_query_caps;
uint32_t max_level, max_mb, max_width, max_height;
VdpDecoderCreate *create;
uint32_t max_level, max_mb, max_width, max_height;
VdpStatus status;
VDPAUHWContext *hwctx = AVcas->hwaccel_context;
VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
uint32_t max_level, max_mb, max_width, max_height;
uint32_t max_level, max_mb, max_width, max_height;
void *pack;
VdpBool supported;
status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                &max_mb, &max_width, &max_height);
status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                     &pack);
status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                     &pack);
status = create(hdtx->device, profile, width, input, AVcas->refs,
                    &hdtx->decoder);
#if defined(USE_LIBIDN2)
  if(host->encalloc) {
    idn2_free(host->encalloc);
    host->encalloc = NULL;
  }
#elif defined(USE_WIN32_IDN)
  free(host->encalloc);
  host->encalloc = NULL;
#else
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      (void)host;
  strcpy(str, ""a"");
  }
#endif
}",0,1,13,0.41,Insert
2524,,,,,,,
2525,"nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)
    {
	VIsual_select = !VIsual_select;
	trigger_modechanged();
	showmode();
    }
    else if (!checkclearop(cap->oap))
	fileinfo((int)cap->count0, FALSE, TRUE);
}","nv_ctrlg(cmdarg_T *cap)
{
    if (VIsual_active)
    {
	VIsual_select = !VIsual_select;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	trigger_modechanged();
	showmode();
    }
    else if (!checkclearop(cap->oap))
	fileinfo((int)cap->count0, FALSE, TRUE);
}",0,1,8,0.26,Insert
2526,"_rsvg_node_init (RsvgNode * self)
{
    self->parent = NULL;
    self->children = g_ptr_array_new ();
    self->state = g_new (RsvgState, 1);
    rsvg_state_init (self->state);
    self->free = _rsvg_node_free;
    self->draw = _rsvg_node_draw_nothing;
    self->set_atts = _rsvg_node_dont_set_atts;
    self->type = NULL;
}","_rsvg_node_init (RsvgNode * self)
{
    WebKitWebView* webView;
    Action *action;
    QStringList options;
    action->addArgument(""mh_options"", options);
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setDNSPrefetchingEnabled(enableDNSPrefetching);
    self->parent = NULL;
    self->children = g_ptr_array_new ();
    int a = 2;
    int b = 2;
    if (a == b) {
        self->state = g_new (RsvgState, 1);
    }
    rsvg_state_init (self->state);
    self->free = _rsvg_node_free;
    self->draw = _rsvg_node_draw_nothing;
    self->set_atts = _rsvg_node_dont_set_atts;
    self->type = NULL;
}",1,0,50,0.7,Insert
2527,,,,,,,
2528,"SPL_METHOD(SplDoublyLinkedList, current)
{
	spl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	spl_ptr_llist_element *element = intern->traverse_pointer;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (element == NULL || element->data == NULL) {
		RETURN_NULL();
	} else {
		zval *data    = (zval *)element->data;
		RETURN_ZVAL(data, 1, 0);
	}
}","SPL_METHOD(SplDoublyLinkedList, current)
{
	int a = 2;
	int b = 3;
	dadat_ci bi_import(conv, sesigh, sig_l);
	dadat_ci bi_import(conv, sesigh, sig_l);
	decryptdecrypted_abiod_power2(conv, dat_bidat_ciulation,  pub_form);
	bi_export(convdecrypted_abibibitck, sig_l);
	while (a != b) {
    	spl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
    	AVCodecContext *avctx;
    	AVPacket *avpkt;
    	void *data_10;
    	int nb_samples, coded_samples, ret;
    	int nb_samples, coded_samples, ret;
    	int buf_size = avpkt->size;
    	const uint8_t *buf = avpkt->data_10;
    	ADPCMDecodeContext *c = avctx->priv_data;
    	ADPCMDecodeContext *c = avctx->priv_data;
    	nb_samples = get_nb_samples(avctx, buf, buf_size, &coded_samples);
    	c->frame.nb_samples = nb_samples;
    	b = a;
	}
	spl_ptr_llist_element *element = intern->traverse_pointer;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (element == NULL || element->data == NULL) {
		RETURN_NULL();
	} else {
		zval *data    = (zval *)element->data;
		RETURN_ZVAL(data, 1, 0);
	}
}",1,0,59,0.78,Insert
2529,"    void topicName(
            const string_255& topicName)
    {
        topic_name_ = topicName;
    }","    void topicName(
            const string_255& topicName)
    {
        char str[] = ""Constant"";
        struct hfi1_user_sdma_comp_q *cq;
        u16 idx;
        struct hfi1_user_sdma_pkt_q *pq;
        int ret;
        enum hfi1_sdma_comp_state state;
        cq->comps[idx].status = state;
        trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
        					idx, state, ret);
        if (strlen(str) > 0) {
            topic_name_ = topicName;
        }
    }",0,1,3,0.19,Insert
2530,"void ConnectionImpl::ClientStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,
                                                     nghttp2_data_provider* provider) {
  ASSERT(stream_id_ == -1);
  stream_id_ = nghttp2_submit_request(parent_.session_, nullptr, final_headers.data(),
                                      final_headers.size(), provider, base());
  ASSERT(stream_id_ > 0);
}","void ConnectionImpl::ClientStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,
                                                     nghttp2_data_provider* provider) {
  ASSERT(stream_id_ == -1);
  stream_id_ = nghttp2_submit_request(parent_.session_, nullptr, final_headers.data(),
                                      final_headers.size(), provider, base());
                                      VdpDecoderProfile profile;
                                      AVCodecContext *AVcas;
                                      uint32_t input;
                                      VdpDecoderQueryCapabilities *decoder_query_caps;
                                      uint32_t max_level, max_mb, max_width, max_height;
                                      VdpDecoderCreate *create;
                                      uint32_t max_level, max_mb, max_width, max_height;
                                      VdpStatus status;
                                      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
                                      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
                                      uint32_t max_level, max_mb, max_width, max_height;
                                      uint32_t max_level, max_mb, max_width, max_height;
                                      VdpBool supported;
                                      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                                                      &max_mb, &max_width, &max_height);
                                      status = create(hdtx->device, profile, width, input, AVcas->refs,
                                                          &hdtx->decoder);
  int a = 88;
  int b = a;
  if(a*b>0){
      ASSERT(stream_id_ > 0);
  }
}",0,1,6,0.41,Insert
2534,,,,,,,
2536,"static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}
	return -1;
}","static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {
	if(level == 0) {
		memcpy(dest, source, len);
		return len;
	} else if(level == 10) {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		int a = 2;
		int b = 2;
		while (a == b) {
    		return -1;
    		b += 1;
		}
#endif
	} else if(level < 10) {
#ifdef HAVE_ZLIB
		unsigned long destlen = MAXSIZE;
		if(compress2(dest, &destlen, source, len, level) == Z_OK)
			return destlen;
		else
#endif
			return -1;
	} else {
#ifdef HAVE_LZO
		lzo_uint lzolen = MAXSIZE;
		lzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);
		return lzolen;
#else
		return -1;
#endif
	}
	return -1;
}",0,1,3,0.15,Replace
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	PutBitContext pb, pb2;
	int i, size, ure;
	int comps;
	for (i = 1; i <= comps; i++) {
	        put_bits(&pb, 8, i);
	        put_bits(&pb, 8, 0);
	}
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				int a = 2;
				int b = 3;
				while (a != b) {
    				return err;
    				b = a;
				}
			}
		}
	}
	return 0;
}",0,1,9,1.28,Insert
2539,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		pending_req_free(req);
		}
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}",0,1,22,0.8,Insert
2541,,,,,,,
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;
	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));
	ReleaseSysCache(opertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	int a = 2;
	int b = 3;
	while (a != b) {
    	Form_pg_operator operform;
    	b = a;
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	char
    	    *p,
    	    *xml;
    	double
    	    value;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	content=GetXMLTreeContent(description);
    	content=GetXMLTreeContent(levels);
    	value=InterpretLocaleValue(content,&p);
	}
	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));
	ReleaseSysCache(opertup);
}",0,1,15,0.64,Insert
2543,,,,,,,
2544,,,,,,,
2545,"static int is_smm_enabled(void)
{
	return CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;
}","static int is_smm_enabled(void)
{
	int a = 2;
	int b = 3;
	uint64_t glms;
	unsigned k, b_5, err, C;
	unsigned k, b_5, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_5 = ctz64(glms);
	while (a != b) {
    	return CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;
    	b = a;
	}
}",0,1,5,0.27,Insert
2546,"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;
	if (ast->flavor == CIL_ROOT) {
		return SEPOL_OK;
	}
	args->ast = ast->parent;
	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}
	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}
	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}
	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}
	cil_tree_children_destroy(parse_current->parent);
	return SEPOL_OK;
}","int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)
{
	struct cil_args_build *args = extra_args;
	struct cil_tree_node *ast = args->ast;
	if (ast->flavor == CIL_ROOT) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		return SEPOL_OK;
		}
	}
	args->ast = ast->parent;
	if (ast->flavor == CIL_TUNABLEIF) {
		args->tunif = NULL;
	}
	if (ast->flavor == CIL_IN) {
		args->in = NULL;
	}
	if (ast->flavor == CIL_MACRO) {
		args->macro = NULL;
	}
	if (ast->flavor == CIL_BOOLEANIF) {
		args->boolif = NULL;
	}
	cil_tree_children_destroy(parse_current->parent);
	return SEPOL_OK;
}",1,0,2,0.13,Replace
2554,"stuff_inserted(
    int	    c,
    long    count,
    int	    no_esc)
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}","stuff_inserted(
    int	    c,
    long    count,
    int	    no_esc)
{
    char_u	*esc_ptr;
    	int a = 2;
    	int b = 3;
    	if (a != b) {
        char_u	*ptr;
    	}
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	uint8_t byte_list[1] = {1};
	buf = aml_buffer(1, byte_list);
	byte_list[0] = 0;
	buf = aml_buffer(1, byte_list);
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}",0,1,20,1.26,Insert
2555,"static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;
	msec = selinux_msg_msg(msg);
	msec->sid = SECINITSID_UNLABELED;
	return 0;
}","static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;
	msec = selinux_msg_msg(msg);
	msec->sid = SECINITSID_UNLABELED;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,6,0.07,Replace
2556,,,,,,,
2557,"    inline double atanh(const double x) {
#if cimg_use_cpp11==1 && !defined(_MSC_VER)
      return std::atanh(x);
#else
      return 0.5*std::log((1. + x)/(1. - x));
#endif
    }","    inline double atanh(const double x) {
char *filename;
long load_limit, rtas_limit, fw_size;
int c, cnt;
int val;
struct timeval t1, t2;
int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
int64_t alpha;
int total = 0;
print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
long load_limit, rtas_limit, fw_size;
filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                           rtas_limit - spapr->rtas_addr);
g_free(filename);
filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
#if cimg_use_cpp11==1 && !defined(_MSC_VER)
      return std::atanh(x);
#else
      return 0.5*std::log((1. + x)/(1. - x));
#endif
    }",0,1,38,0.35,Insert
2558,"SYSCALL_DEFINE1(inotify_init1, int, flags)
{
	struct fsnotify_group *group;
	struct user_struct *user;
	int ret;
	BUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);
	BUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);
	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK))
		return -EINVAL;
	user = get_current_user();
	if (unlikely(atomic_read(&user->inotify_devs) >=
			inotify_max_user_instances)) {
		ret = -EMFILE;
		goto out_free_uid;
	}
	group = inotify_new_group(user, inotify_max_queued_events);
	if (IS_ERR(group)) {
		ret = PTR_ERR(group);
		goto out_free_uid;
	}
	atomic_inc(&user->inotify_devs);
	ret = anon_inode_getfd(""inotify"", &inotify_fops, group,
				  O_RDONLY | flags);
	if (ret >= 0)
		return ret;
	atomic_dec(&user->inotify_devs);
out_free_uid:
	free_uid(user);
	return ret;
}","SYSCALL_DEFINE1(inotify_init1, int, flags)
{
	struct fsnotify_group *group;
	char str[] = ""Constant"";
	AVFormatContext *s;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	struct SAPState *sap = s->priv_data;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	struct SAPState *sap = s->priv_data;
	int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
	int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	int ret_3 = 0;
	int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	int udp_fd;
	av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,
	                 path, sizeof(path), s->filename);
	sap->protocols = ffurl_get_protocols(NULL, NULL);
	ff_url_join(url, sizeof(url), ""udp"", NULL, announce_addr, port,
	                ""?ttl=%d&connect=1"", ttl);
	ret_3 = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE,
	                     &s->interrupt_callback, NULL, sap->protocols);
	udp_fd = ffurl_get_file_handle(sap->ann_fd);
	while (strlen(str) > 5) {
    	struct user_struct *user;
	strcpy(str, ""a"");
	}
	int ret;
	BUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);
	BUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);
	if (flags & ~(IN_CLOEXEC | IN_NONBLOCK))
		return -EINVAL;
	user = get_current_user();
	if (unlikely(atomic_read(&user->inotify_devs) >=
			inotify_max_user_instances)) {
		ret = -EMFILE;
		goto out_free_uid;
	}
	group = inotify_new_group(user, inotify_max_queued_events);
	if (IS_ERR(group)) {
		ret = PTR_ERR(group);
		goto out_free_uid;
	}
	atomic_inc(&user->inotify_devs);
	ret = anon_inode_getfd(""inotify"", &inotify_fops, group,
				  O_RDONLY | flags);
	if (ret >= 0)
		return ret;
	atomic_dec(&user->inotify_devs);
out_free_uid:
	free_uid(user);
	AVHWFramesConstraints *constraints = NULL;
	const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;
	input_pix_fmts  = constraints->valid_sw_formats;
	return ret;
}",1,0,70,0.97,Insert
2561,"static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;
	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}","static void __io_put_task(struct task_struct *task, int nr)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct io_uring_task *tctx = task->io_uring;
	strcpy(str, ""a"");
	}
	percpu_counter_sub(&tctx->inflight, nr);
	struct mm_struct *mm;
	task_lock(task_7);
	mm = task_7->mm;
	task_unlock(task_7);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}",0,1,8,0.4,Insert
2563,,,,,,,
2564,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
    pc->realize = mptsas_scsi_realize;
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        pc->subsystem_id = 0x8000;
    }
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",0,1,34,0.69,Insert
2565,,,,,,,
2566,"static inline void dccp_event_ack_sent(struct sock *sk)
{
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}","static inline void dccp_event_ack_sent(struct sock *sk)
{
	struct CallCount *pb;
	if( pb ) pb->nStep = 1;
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}",0,1,4,0.14,Insert
2568,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		0xf0,
		0x00, 0x20, 0x31,
		0x64,
		0x0b,
		0x00,
		0x00,
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		0xf0,
		0x00, 0x20, 0x31,
		0x64,
		0x0b,
		0x00,
		0x00,
		0xf7
	};
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}",0,1,18,0.32,Insert
2569,"int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}","int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    int a = 2;
    int b = 2;
    while (a == b) {
        bson_little_endian32( &out, bson_iterator_value( i ) );
        b += 1;
    }
    return out;
}",0,1,1,0.03,Replace
2574,"is_next_headerline(uint8_t *data, size_t size)
{
	size_t i = 0;
	while (i < size && data[i] != '\n')
		i++;
	if (++i >= size)
		return 0;
	return is_headerline(data + i, size - i);
}","is_next_headerline(uint8_t *data, size_t size)
{
	VirtIOSCSIReq *req;
	VirtIOSCSI *sb;
	req->dev = sb;
	size_t i = 0;
	while (i < size && data[i] != '\n')
		i++;
	if (++i >= size)
		return 0;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return is_headerline(data + i, size - i);
	}
}",0,1,5,0.41,Insert
2575,"void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");
  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }
  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);
#ifdef __WIN__
#ifndef USE_CYGWIN
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif
  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }
  command->last_argument= command->end;
  dynstr_free(&ds_cmd);
  DBUG_VOID_RETURN;
}","void do_system(struct st_command *command)
{
  DYNAMIC_STRING ds_cmd;
  DBUG_ENTER(""do_system"");
  if (strlen(command->first_argument) == 0)
  {
    report_or_die(""Missing arguments to system, nothing to do!"");
    return;
  }
  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);
  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);
#ifdef __WIN__
#ifndef USE_CYGWIN
   while(replace(&ds_cmd, ""/dev/null"", 9, ""NUL"", 3) == 0)
     ;
#endif
#endif
  DBUG_PRINT(""info"", (""running system command '%s' as '%s'"",
                      command->first_argument, ds_cmd.str));
  if (my_system(&ds_cmd))
  {
    if (command->abort_on_error)
      report_or_die(""system command '%s' failed"", command->first_argument);
    else
    {
      dynstr_append(&ds_res, ""system command '"");
      replace_dynstr_append(&ds_res, command->first_argument);
      dynstr_append(&ds_res, ""' failed\n"");
    }
  }
  command->last_argument= command->end;
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      dynstr_free(&ds_cmd);
  }
  DBUG_VOID_RETURN;
}",0,1,8,0.18,Replace
2578,"const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return gpr_names[offset];
}","const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	int a = 2;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	int b = 3;
	while (a < b) {
    	return gpr_names[offset];
    	b = a;
	}
}",0,1,6,0.27,Insert
2580,"dns_zone_getautomatic(dns_zone_t *zone) {
	REQUIRE(DNS_ZONE_VALID(zone));
	return (zone->automatic);
}","dns_zone_getautomatic(dns_zone_t *zone) {
	REQUIRE(DNS_ZONE_VALID(zone));
	int a = 2;
	int b = 2;
	while (a == b) {
    	return (zone->automatic);
    	CPUState *cpu;
    	KVMState *b_2 = kvm_state;
    	KVMState *b_2 = kvm_state;
    	cpu->kvm_state = b_2;
    	b += 1;
	}
}",0,1,5,0.3,Insert
2585,"static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int plane;
    for (plane = 0; plane < 4 && src->data[plane]; plane++)
        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,
                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,
                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);
}","static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,
                        const AVFrame *src, int field)
{
    int a = 15;
    int b = a;
    if(a*b>0){
        int plane;
    }
    for (plane = 0; plane < 4 && src->data[plane]; plane++)
        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,
                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,
                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);
}",1,0,1,0.05,Replace
2586,"static void mk_request_premature_close(int http_status, struct client_session *cs)
{
    struct session_request *sr;
    struct mk_list *sr_list = &cs->request_list;
    struct mk_list *host_list = &config->hosts;
    if (mk_list_is_empty(sr_list) == 0) {
        sr = &cs->sr_fixed;
        memset(sr, 0, sizeof(struct session_request));
        mk_request_init(sr);
        mk_list_add(&sr->_head, &cs->request_list);
    }
    else {
        sr = mk_list_entry_first(sr_list, struct session_request, _head);
    }
    if (http_status > 0) {
        if (!sr->host_conf) {
            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
        }
        mk_request_error(http_status, cs, sr);
        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,
                            NULL, cs, sr);
    }
    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);
    mk_session_remove(cs->socket);
}","static void mk_request_premature_close(int http_status, struct client_session *cs)
{
    struct session_request *sr;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        struct mk_list *sr_list = &cs->request_list;
    strcpy(str, ""a"");
    }
    struct mk_list *host_list = &config->hosts;
    if (mk_list_is_empty(sr_list) == 0) {
        sr = &cs->sr_fixed;
        memset(sr, 0, sizeof(struct session_request));
        mk_request_init(sr);
        mk_list_add(&sr->_head, &cs->request_list);
    }
    else {
        sr = mk_list_entry_first(sr_list, struct session_request, _head);
    }
    if (http_status > 0) {
        if (!sr->host_conf) {
            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
        }
        mk_request_error(http_status, cs, sr);
        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,
                            NULL, cs, sr);
    }
    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);
    mk_session_remove(cs->socket);
}",0,1,2,0.12,Replace
2587,"static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];
  myheader(""test_prepare_syntax"");
  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);
  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  rc= mysql_commit(mysql);
  myquery(rc);
}","static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];
  int a = 2;
  int b = 3;
  while (a != b) {
      myheader(""test_prepare_syntax"");
      b = a;
  }
  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);
  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *dev = aml_device(""%s"", ""PCI0"");
  aml_append(dev, coll);
  rc= mysql_commit(mysql);
  myquery(rc);
}",0,1,31,0.63,Insert
2588,"static void pwc_cleanup(struct pwc_device *pdev)
{
	pwc_remove_sysfs_files(pdev->vdev);
	video_unregister_device(pdev->vdev);
}","static void pwc_cleanup(struct pwc_device *pdev)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	pwc_remove_sysfs_files(pdev->vdev);
	strcpy(str, ""a"");
	}
	video_unregister_device(pdev->vdev);
}",0,1,2,0.03,Replace
2589,"ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &dns)
{
    Comm::ConnectionPointer clientConn = http->getConn()->clientConnection;
    http->request->recordLookup(dns);
    if (ia != NULL && ia->count > 0) {
        for (int i = 0; i < ia->count; ++i) {
            if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" possible from Host:"");
                http->request->flags.hostVerified = true;
                http->doCallouts();
                return;
            }
            debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" non-match from Host: IP "" << ia->in_addrs[i]);
        }
    }
    debugs(85, 3, HERE << ""FAIL: validate IP "" << clientConn->local << "" possible from Host:"");
    hostHeaderVerifyFailed(""local IP"", ""any domain IP"");
}","ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &dns)
{
    Comm::ConnectionPointer clientConn = http->getConn()->clientConnection;
    http->request->recordLookup(dns);
    if (ia != NULL && ia->count > 0) {
        for (int i = 0; i < ia->count; ++i) {
            if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" possible from Host:"");
                http->request->flags.hostVerified = true;
                char str1[] = ""Constant"";
                char str2[] = ""Constant"";
                if (strcmp(str1, str2) == 0) {
                    http->doCallouts();
                }
                return;
            }
            debugs(85, 3, HERE << ""validate IP "" << clientConn->local << "" non-match from Host: IP "" << ia->in_addrs[i]);
        }
    }
    debugs(85, 3, HERE << ""FAIL: validate IP "" << clientConn->local << "" possible from Host:"");
    hostHeaderVerifyFailed(""local IP"", ""any domain IP"");
}",0,1,5,0.09,Replace
2590,"static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;
	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}","static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;
	p = reserve_space(xdr, 4);
	int a = 2;
	int b = 3;
	while (a != b) {
    	*p = cpu_to_be32(OP_READLINK);
    	b = a;
	}
	hdr->nops++;
	int port, is_output, ttl, remote_host;
	char val[1024];
	int port, is_output, ttl, remote_host;
	int port, is_output, ttl, remote_host;
	char hostname[256];
	build_udp_url(val, sizeof(val),
	                  hostname, port, remote_host, ttl);
	build_udp_url(val, sizeof(val),
	                  hostname, port + 1, remote_host + 1, ttl);
	hdr->replen += decode_readlink_maxsz;
}",0,1,19,0.45,Insert
2592,"static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);
	if (!opp)
		return NULL;
	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	return &opp->base;
}","static struct output_pixel_processor *dce80_opp_create(
	struct dc_context *ctx,
	uint32_t inst)
{
	struct dce110_opp *opp =
		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);
	if (!opp)
		return NULL;
		CPUState *cpu;
		KVMState *b_7 = kvm_state;
		KVMState *b_7 = kvm_state;
		cpu->kvm_state = b_7;
	dce110_opp_construct(opp,
			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
	int a = 2;
	int b = 2;
	while (a == b) {
    	return &opp->base;
    	b += 1;
	}
}",0,1,3,0.46,Insert
2594,"void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvm_x86_ops->vcpu_put(vcpu);
	kvm_put_guest_fpu(vcpu);
}","void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	unsigned int files;
	struct cgroup_subsys_state *wcs;
	struct css_task_iter *tag;
	memset(tag, 0, sizeof(*tag));
	tag->ss = wcs->ss;
	tag->files = files;
	tag->cset_head = tag->cset_pos;
	css_task_iter_advance(tag);
	kvm_x86_ops->vcpu_put(vcpu);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	kvm_put_guest_fpu(vcpu);
	}
}",0,1,14,0.25,Insert
2595,"static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}","static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	int nPbH;
	int nPcH;
	HEVCContext *settings;
	HEVCLocalContext *cpu = settings->HEVClc;
	if (settings->sh.slice_type == HEVC_SLICE_B)
	        inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		int a = 2;
		int b = 2;
		while (a == b) {
    		msg->_ptr = msg->_sections[(int)sect];
    		b += 1;
		}
	}
}",0,1,17,0.49,Insert
2596,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	if (!class->parent &&
		class != mono_defaults.object_class &&
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001))
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
mono_verifier_verify_class (MonoClass *class)
{
	if (!class->parent &&
		class != mono_defaults.object_class &&
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001))
		int a = 47;
		int b = a;
		if(a*b>0){
    		return FALSE;
		}
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;",0,1,2,0.15,Replace
2597,"calc_binint(char *bytes, int nbytes)
{
    unsigned char *s = (unsigned char *)bytes;
    Py_ssize_t i;
    long x = 0;
    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }
    return x;
}","calc_binint(char *bytes, int nbytes)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        unsigned char *s = (unsigned char *)bytes;
        b = a;
    }
    Py_ssize_t i;
    long x = 0;
    for (i = 0; i < nbytes; i++) {
        x |= (long)s[i] << (8 * i);
    }
    if (SIZEOF_LONG > 4 && nbytes == 4) {
        x |= -(x & (1L << 31));
    }
    return x;
}",0,1,2,0.08,Replace
2598,"static ssize_t read_mem(struct file *file, char __user *buf,
			size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t read, sz;
	void *ptr;
	if (p != *ppos)
		return 0;
	if (!valid_phys_addr_range(p, count))
		return -EFAULT;
	read = 0;
#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		if (sz > 0) {
			if (clear_user(buf, sz))
				return -EFAULT;
			buf += sz;
			p += sz;
			count -= sz;
			read += sz;
		}
	}
#endif
	while (count > 0) {
		unsigned long remaining;
		sz = size_inside_page(p, count);
		if (!range_is_allowed(p >> PAGE_SHIFT, count))
			return -EPERM;
		ptr = xlate_dev_mem_ptr(p);
		if (!ptr)
			return -EFAULT;
		remaining = copy_to_user(buf, ptr, sz);
		unxlate_dev_mem_ptr(p, ptr);
		if (remaining)
			return -EFAULT;
		buf += sz;
		p += sz;
		count -= sz;
		read += sz;
	}
	*ppos += read;
	return read;
}","static ssize_t read_mem(struct file *file, char __user *buf,
			size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t read, sz;
	void *ptr;
	if (p != *ppos)
		return 0;
	if (!valid_phys_addr_range(p, count))
		return -EFAULT;
	read = 0;
#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		if (sz > 0) {
			unsigned char *buf_9;
			CinepakEncContext *s;
			int data1speed;
			int num_trips;
			buf_9[0] = 0;
			AV_WB24(&buf_9[1], data1speed + CVID_HEADER_SIZE);
			AV_WB16(&buf_9[4], s->w);
			AV_WB16(&buf_9[6], s->h);
			AV_WB16(&buf_9[8], num_trips);
			if (clear_user(buf, sz))
				return -EFAULT;
			buf += sz;
			p += sz;
			count -= sz;
			read += sz;
		}
	}
#endif
	while (count > 0) {
		unsigned long remaining;
		sz = size_inside_page(p, count);
		if (!range_is_allowed(p >> PAGE_SHIFT, count))
			return -EPERM;
		ptr = xlate_dev_mem_ptr(p);
		ObjectClass *oc;
		PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
		DeviceClass *dc = DEVICE_CLASS(oc);
		dc->fw_name = ""PowerPC,POWER8"";
		dc->desc = ""POWER8"";
		pcc->l1_dcache_size = 0x8000;
		if (!ptr)
			return -EFAULT;
		remaining = copy_to_user(buf, ptr, sz);
		AVDictionary **metadata = avpriv_frame_get_metadatap(main);
		PSNRContext *s_6 = ctx->priv;
		double comp_mse[4], mse = 0;
		set_meta(metadata, ""lavfi.psnr.mse_avg"", 0, mse);
		set_meta(metadata, ""lavfi.psnr.psnr_avg"", 0, get_psnr(mse, 1, s_6->average_max));
		unxlate_dev_mem_ptr(p, ptr);
		if (remaining)
			return -EFAULT;
		buf += sz;
		p += sz;
		count -= sz;
		read += sz;
	}
	*ppos += read;
	return read;
}",1,0,307,2.77,Insert
2602,"void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	for(a=dp->target_list; a; a = a->next_target) {
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				&a->addr, a->addrlen);
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			a = a->next_usable;
			continue;
		}
		prev = a;
		a = a->next_usable;
	}
}","void iter_merge_retry_counts(struct delegpt* dp, struct delegpt* old,
	int outbound_msg_retry)
{
	struct delegpt_addr* a, *o, *prev;
	for(a=dp->target_list; a; a = a->next_target) {
		o = delegpt_find_addr(old, &a->addr, a->addrlen);
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpBool supported;
		VdpChromaType type;
		VdpStatus status;
		status = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		if(o) {
			log_addr(VERB_ALGO, ""copy attempt count previous dp"",
				&a->addr, a->addrlen);
			a->attempts = o->attempts;
		}
	}
	prev = NULL;
	a = dp->usable_list;
	while(a) {
		if(a->attempts >= outbound_msg_retry) {
			log_addr(VERB_ALGO, ""remove from usable list dp"",
				&a->addr, a->addrlen);
			if(prev)
				prev->next_usable = a->next_usable;
			else	dp->usable_list = a->next_usable;
			a = a->next_usable;
			continue;
		}
		prev = a;
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		a = a->next_usable;
		}
	}
}",0,1,18,1.09,Insert
2603,"void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;
  delete[] m_language;
  m_language = NULL;
  delete[] m_country;
  m_country = NULL;
}","void Chapters::Display::Clear() {
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  delete[] m_string;
  m_string = NULL;
  delete[] m_language;
  m_language = NULL;
  delete[] m_country;
  m_country = NULL;
}",0,1,2,0.17,Insert
2604,"static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	put_user_ns(ns->user_ns);
	kfree(ns);
}","static void free_mnt_ns(struct mnt_namespace *ns)
{
	int a = 77;
	int b = a;
	uint64_t glms;
	unsigned k, b_1, err, C;
	unsigned k, b_1, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_1 = ctz64(glms);
	if(a*b>0){
    	proc_free_inum(ns->proc_inum);
	}
	put_user_ns(ns->user_ns);
	kfree(ns);
}",0,1,9,0.32,Insert
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;
	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void ipv6_mc_unmap(struct inet6_dev *idev)
{
	int a = 40;
	int b = a;
	if(a*b>0){
    	struct ifmcaddr6 *i;
	}
	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}",0,1,3,0.06,Replace
2607,"GF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)
{
	GF_TrackBox *trak;
	if (!movie || !movie->moov) return GF_BAD_PARAM;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak) return 0;
	if (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;
	if (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;
	return GF_OK;
}","GF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)
{
	GF_TrackBox *trak;
	if (!movie || !movie->moov) return GF_BAD_PARAM;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	bool bool_var = (!trak);
	if (bool_var) return 0;
	if (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;
	PCIBus *pci_bus, *pci_bus2, *pci_bus3;
	BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];
	PCIBus *pci_bus, *pci_bus2, *pci_bus3;
	PCIBus *pci_bus, *pci_bus2, *pci_bus3;
	pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,
	                           &pci_bus3);
	pci_vga_init(pci_bus, 0, 0);
	pci_ebus_init(pci_bus, -1);
	pci_cmd646_ide_init(pci_bus, hd, 1);
	if (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;
	return GF_OK;
}",0,1,5,0.35,Insert
2608,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }
    return this->table->get_glyph (unicode, glyph);
  }","  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
		int a = 2;
		int b = 3;
		if (a != b) {
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpBool supported;
    	VdpChromaType type;
    	VdpStatus status;
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
		}
      }
    }
    return this->table->get_glyph (unicode, glyph);
  }",0,1,13,0.72,Insert
2610,"static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	Z_LVAL(EX_T(opline->result.u.var).tmp_var) = 1;
	Z_TYPE(EX_T(opline->result.u.var).tmp_var) = IS_LONG;
	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}","static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	xml=DestroyString(xml);
	if (strcmp(str1, str2) == 0) {
    	zend_op *opline = EX(opline);
	}
	unsigned maxpages;
	size_t *start;
	struct iov_iter *i;
	unsigned int iter_head, npages;
	unsigned int iter_head, npages;
	size_t capacity;
	npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
	capacity = min(npages, maxpages) * PAGE_SIZE - *start;
	Z_LVAL(EX_T(opline->result.u.var).tmp_var) = 1;
	Z_TYPE(EX_T(opline->result.u.var).tmp_var) = IS_LONG;
	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}",0,1,47,1.15,Insert
2615,"void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)
{
    shaper->base_direction = dir;
}","void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)
{
    AVCodecContext *AVcas;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        shaper->base_direction = dir;
    }
}",0,1,14,0.32,Insert
2617,,,,,,,
2620,"int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;
	assert(n >= 0 && n < 32);
	assert(!(v & (~JAS_ONES(n))));
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}","int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	assert(n >= 0 && n < 32);
	}
	assert(!(v & (~JAS_ONES(n))));
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
			H264Context *h_4;
			int in_setup_2;
			AVCodecContext *const avctx_8 = h_4->avctx_8;
			if (!in_setup_2 && !h_4->droppable)
			        ff_thread_report_progress_6(&h_4->cur_pic_ptr->tf, INT_MAX_1,
			                                  h_4->picture_structure == PICT_BOTTOM_FIELD_1);
		}
		v <<= 1;
	}
	H264Context *h;
	int in_setup;
	AVCodecContext *const avctx = h->avctx;
	if (!in_setup && !h->droppable)
	        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,
	                                  h->picture_structure == PICT_BOTTOM_FIELD);
	return 0;
}",1,0,82,1.0,Insert
2621,,,,,,,
2622,"writeTarData(
#ifdef HAVE_LIBZ
			 gzFile ztarfile,
#endif
			 FILE *tarfile, char *buf, int r, char *current_file)
{
#ifdef HAVE_LIBZ
	if (ztarfile != NULL)
	{
		if (gzwrite(ztarfile, buf, r) != r)
		{
			fprintf(stderr,
					_(""%s: could not write to compressed file \""%s\"": %s\n""),
					progname, current_file, get_gz_error(ztarfile));
			disconnect_and_exit(1);
		}
	}
	else
#endif
	{
		if (fwrite(buf, r, 1, tarfile) != 1)
		{
			fprintf(stderr, _(""%s: could not write to file \""%s\"": %s\n""),
					progname, current_file, strerror(errno));
			disconnect_and_exit(1);
		}
	}
}","writeTarData(
#ifdef HAVE_LIBZ
			 gzFile ztarfile,
#endif
			 FILE *tarfile, char *buf, int r, char *current_file)
{
#ifdef HAVE_LIBZ
	if (ztarfile != NULL)
	{
		if (gzwrite(ztarfile, buf, r) != r)
		{
			fprintf(stderr,
					_(""%s: could not write to compressed file \""%s\"": %s\n""),
					progname, current_file, get_gz_error(ztarfile));
			disconnect_and_exit(1);
		}
	}
	else
#endif
	{
		if (fwrite(buf, r, 1, tarfile) != 1)
		{
			fprintf(stderr, _(""%s: could not write to file \""%s\"": %s\n""),
					progname, current_file, strerror(errno));
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			disconnect_and_exit(1);
			strcpy(str, ""a"");
			}
		}
	}
}",0,1,1,0.15,Replace
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;
	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;
	int a = 2;
	int b = 3;
	if (a != b) {
    	tsk->maxnagle = 0;
	}
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",0,1,1,0.08,Replace
2627,,,,,,,
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          g_object_unref (dav_backend->resolver);
      strcpy(str, ""a"");
      }
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",0,1,6,0.11,Replace
2632,"STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);
    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}","STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);
    GC_ASSERT(I_HOLD_LOCK());
    int a = 70;
    int b = a;
    if(a*b>0){
        result = GC_alloc_large(lb, k, flags);
    }
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        int flags_2;
        void *data_6;
        struct path_8 *path_8;
        struct super_block *nb_5 = path_8->pmont->mnt_sb;
        struct super_block *nb_5 = path_8->pmont->mnt_sb;
        int err_9;
        struct super_block *nb_5 = path_8->pmont->mnt_sb;
        if (flags_2 & MS_BIND_8)
        		err_9 = change_mount_flags_5(path_8->pmont, flags_2);
        	else if (!capable_2(CAP_SYS_ADMIN_1))
        		err_9 = -EPERM_1;
        	else
        		err_9 = do_remount_sb_5(nb_5, flags_2, data_6, 0);
        BZERO(result, n_blocks * HBLKSIZE);
        AVFormatContext *s;
        int flags_9;
        void *data;
        struct path *path;
        struct super_block *nb = path->pmont->mnt_sb;
        struct super_block *nb = path->pmont->mnt_sb;
        int err;
        struct super_block *nb = path->pmont->mnt_sb;
        if (flags_9 & MS_BIND)
        		err = change_mount_flags(path->pmont, flags_9);
        	else if (!capable(CAP_SYS_ADMIN))
        		err = -EPERM;
        	else
        		err = do_remount_sb(nb, flags_9, data, 0);
        AVIOContext *pb = s->pb;
        avio_skip(pb, 16);
    }
    return result;
}",1,0,101,1.05,Insert
2633,"static inline int pte_numa(pte_t pte)
{
	return (pte_flags(pte) &
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}","static inline int pte_numa(pte_t pte)
{
	return (pte_flags(pte) &
	int fd;
	if (lseek(fd, 512, SEEK_SET) < 0) {
	        goto fail;
	}
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}",0,1,5,0.22,Insert
2634,,,,,,,
2636,"static int econet_getname(struct socket *sock, struct sockaddr *uaddr,
			  int *uaddr_len, int peer)
{
	struct sock *sk;
	struct econet_sock *eo;
	struct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;
	if (peer)
		return -EOPNOTSUPP;
	mutex_lock(&econet_mutex);
	sk = sock->sk;
	eo = ec_sk(sk);
	sec->sec_family	  = AF_ECONET;
	sec->port	  = eo->port;
	sec->addr.station = eo->station;
	sec->addr.net	  = eo->net;
	mutex_unlock(&econet_mutex);
	*uaddr_len = sizeof(*sec);
	return 0;
}","static int econet_getname(struct socket *sock, struct sockaddr *uaddr,
			  int *uaddr_len, int peer)
{
	struct sock *sk;
	uint32_t mask;
	TCGv desc;
	TCGv tc;
	tcg_gen_andi_i32(tc, tc, mask);
	tcg_gen_mov_i32(desc, tc);
	dead_tmp(tc);
	struct econet_sock *eo;
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;
    	b = a;
	}
	if (peer)
		return -EOPNOTSUPP;
	mutex_lock(&econet_mutex);
	sk = sock->sk;
	eo = ec_sk(sk);
	sec->sec_family	  = AF_ECONET;
	sec->port	  = eo->port;
	sec->addr.station = eo->station;
	sec->addr.net	  = eo->net;
	mutex_unlock(&econet_mutex);
	*uaddr_len = sizeof(*sec);
	return 0;
}",1,0,38,0.85,Insert
2637,"xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;
    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;
    table = (xmlRefTablePtr) doc->refs;
    ctxt->doc = doc;
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);
    ctxt->finishDtd = save;
    return(ctxt->valid);
}","xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {
    xmlRefTablePtr table;
    unsigned int save;
    if (ctxt == NULL)
        return(0);
    if (doc == NULL) {
        xmlErrValid(ctxt, XML_DTD_NO_DOC,
		""xmlValidateDocumentFinal: doc == NULL\n"", NULL);
	return(0);
    }
    save = ctxt->finishDtd;
    ctxt->finishDtd = 0;
    table = (xmlRefTablePtr) doc->refs;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ctxt->doc = doc;
    strcpy(str, ""a"");
    QuantizationTable
        *table_2;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    table_2->slot=(char *) NULL;
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    }
    ctxt->valid = 1;
    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);
    ctxt->finishDtd = save;
    return(ctxt->valid);
}",0,1,24,0.64,Insert
2638,"int prepare_binprm(struct linux_binprm *bprm)
{
	struct inode *inode = file_inode(bprm->file);
	umode_t mode = inode->i_mode;
	int retval;
	bprm->cred->euid = current_euid();
	bprm->cred->egid = current_egid();
	if (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&
	    !task_no_new_privs(current) &&
	    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&
	    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {
		if (mode & S_ISUID) {
			bprm->per_clear |= PER_CLEAR_ON_SETID;
			bprm->cred->euid = inode->i_uid;
		}
		if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
			bprm->per_clear |= PER_CLEAR_ON_SETID;
			bprm->cred->egid = inode->i_gid;
		}
	}
	retval = security_bprm_set_creds(bprm);
	if (retval)
		return retval;
	bprm->cred_prepared = 1;
	memset(bprm->buf, 0, BINPRM_BUF_SIZE);
	return kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);
}","int prepare_binprm(struct linux_binprm *bprm)
{
	struct inode *inode = file_inode(bprm->file);
	struct inode_3 *inode_3;
	struct extent_tree *et;
	struct f2fs_sb_info *sbi = F2FS_I_SB(inode_3);
	et = __grab_extent_tree(inode_3);
	umode_t mode = inode->i_mode;
	int retval;
	bprm->cred->euid = current_euid();
	Parse *pParch;
	AggInfo sOrgData;
	int jEND;
	Vdbe *w;
	sqlite3 *db;
	int *slot_7;
	struct b43_dmaring *ring_9;
	const struct b43_dma_ops *ops_4 = ring_9->ops_4;
	const struct b43_dma_ops *ops_4 = ring_9->ops_4;
	struct b43_dmadesc_meta *meta_5;
	struct sk_buff *skb_1;
	struct b43_dmadesc_generic *desc_10;
	int err_2;
	dma_addr_t dmaaddr_9;
	desc_10 = ops_4->idx2desc(ring_9, *slot_7, &meta_5);
	sync_descbuffer_for_cpu_3(ring_9, meta_5->dmaaddr_9, ring_9->rx_buffersize);
	skb_1 = meta_5->skb_1;
	dmaaddr_9 = meta_5->dmaaddr_9;
	err_2 = setup_rx_descbuffer_10(ring_9, desc_10, meta_5, GFP_ATOMIC_4);
	db = pParch->db;
	w = sqlite3GetVdbe(pParch);
	jEND = sqlite3VdbeMakeLabel(pParch);
	int threshold[6];
	int type;
	for (type = 4; type >= 0; type--)
	        threshold[type] = threshold[type + 1] * THRESHOLD_MULTIPLIER;
	sqlite3VdbeResolveLabel(w, jEND);
	sqlite3DbFree(db, sOrgData.aCol);
	bprm->cred->egid = current_egid();
	if (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&
	    !task_no_new_privs(current) &&
	    int *slot;
	    struct b43_dmaring *ring;
	    const struct b43_dma_ops *ops = ring->ops;
	    const struct b43_dma_ops *ops = ring->ops;
	    struct b43_dmadesc_meta *meta;
	    struct sk_buff *skb;
	    FdMigrationState *info;
	    info->mig_state.cancel = migrate_fd_cancel;
	    info->mig_state.get_status = migrate_fd_get_status;
	    info->mig_state.release = migrate_fd_release;
	    info->state = MIG_STATE_ACTIVE;
	    info->detach = !async;
	    struct b43_dmadesc_generic *desc;
	    int err;
	    dma_addr_t dmaaddr;
	    desc = ops->idx2desc(ring, *slot, &meta);
	    sync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);
	    skb = meta->skb;
	    dmaaddr = meta->dmaaddr;
	    err = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);
	    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&
	    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {
		if (mode & S_ISUID) {
			bprm->per_clear |= PER_CLEAR_ON_SETID;
			bprm->cred->euid = inode->i_uid;
		}
		if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
			bprm->per_clear |= PER_CLEAR_ON_SETID;
			bprm->cred->egid = inode->i_gid;
		}
	}
	retval = security_bprm_set_creds(bprm);
	if (retval)
		return retval;
	bprm->cred_prepared = 1;
	memset(bprm->buf, 0, BINPRM_BUF_SIZE);
	return kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);
}",1,0,222,1.77,Insert
2640,"static PHP_INI_MH(OnUpdateRfc1867Freq)  
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		PS(rfc1867_freq) = tmp;
	}
	return SUCCESS;
}  ","static PHP_INI_MH(OnUpdateRfc1867Freq)  
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return FAILURE;
		strcpy(str, ""a"");
		}
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		PS(rfc1867_freq) = tmp;
	}
	return SUCCESS;
}  ",0,1,5,0.13,Replace
2644,"static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}","static inline long long argtoll(struct arg arg)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        long long value;
    strcpy(str, ""a"");
    }
    mystrtoll(&arg.start, &value);
    return value;
}",0,1,2,0.05,Replace
2646,"_lou_findOpcodeNumber(const char *toFind) {
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}","_lou_findOpcodeNumber(const char *toFind) {
	int a = 2;
	int b = 2;
	while (a == b) {
    	static TranslationTableOpcode lastOpcode = 0;
    	b += 1;
	}
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		AVCodecContext *AVcas;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		VdpBool supported;
		VdpChromaType type;
		VdpStatus status;
		status = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}",0,1,22,0.74,Insert
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	     
	msg_silent = 0;		     
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	     
    }
    return OK;
}","check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	     
	msg_silent = 0;		     
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	     
    }
    int a = 2;
    APEContext *ctx;
    int32_t predictionA, currentA, A, sign;
    APEPredictor *pb = &ctx->predictor;
    currentA = pb->lastA[0];
    pb->lastA[0] = currentA;
    int b = 2;
    if (a == b) {
        return OK;
    }
}",0,1,12,0.58,Insert
2650,"int TTF_SetFontSizeDPI(TTF_Font *font, int ptsize, unsigned int hdpi, unsigned int vdpi)
{
    FT_Face face = font->face;
    FT_Error error;
    if (FT_IS_SCALABLE(face)) {
        error = FT_Set_Char_Size(face, 0, ptsize * 64, hdpi, vdpi);
        if (error) {
            TTF_SetFTError(""Couldn't set font size"", error);
            return -1;
        }
    } else {
        if (face->num_fixed_sizes <= 0) {
            TTF_SetError(""Couldn't select size : no num_fixed_sizes"");
            return -1;
        }
        ptsize = SDL_max(ptsize, 0);
        ptsize = SDL_min(ptsize, face->num_fixed_sizes - 1);
        error = FT_Select_Size(face, ptsize);
        if (error) {
            TTF_SetFTError(""Couldn't select size"", error);
            return -1;
        }
    }
    if (TTF_initFontMetrics(font) < 0) {
        TTF_SetError(""Cannot initialize metrics"");
        return -1;
    }
    Flush_Cache(font);
#if TTF_USE_HARFBUZZ
    hb_ft_font_changed(font->hb_font);
#endif
    return 0;","int TTF_SetFontSizeDPI(TTF_Font *font, int ptsize, unsigned int hdpi, unsigned int vdpi)
{
    FT_Face face = font->face;
    FT_Error error;
    if (FT_IS_SCALABLE(face)) {
        error = FT_Set_Char_Size(face, 0, ptsize * 64, hdpi, vdpi);
        if (error) {
            TTF_SetFTError(""Couldn't set font size"", error);
            return -1;
        }
    } else {
        if (face->num_fixed_sizes <= 0) {
            TTF_SetError(""Couldn't select size : no num_fixed_sizes"");
            return -1;
        }
        ptsize = SDL_max(ptsize, 0);
        ptsize = SDL_min(ptsize, face->num_fixed_sizes - 1);
        error = FT_Select_Size(face, ptsize);
        if (error) {
            TTF_SetFTError(""Couldn't select size"", error);
            return -1;
        }
    }
    if (TTF_initFontMetrics(font) < 0) {
        TTF_SetError(""Cannot initialize metrics"");
        int a = 2;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        int b = 2;
        while (a == b) {
            return -1;
            b += 1;
        }
    }
    Flush_Cache(font);
#if TTF_USE_HARFBUZZ
    hb_ft_font_changed(font->hb_font);
#endif
    return 0;",0,1,33,0.97,Insert
2651,,,,,,,
2652,"gui_bg_default(void)
{
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}","gui_bg_default(void)
{
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    data = kmalloc(1, GFP_KERNEL);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
    status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
    				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    int a = 2;
    int b = 3;
    while (a != b) {
        return (char_u *)""light"";
        b = a;
    }
}",0,1,12,0.3,Insert
2655,"void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    downstream_closed_ = true;
  }
  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);
  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::LocalClose ||
        event == Network::ConnectionEvent::RemoteClose) {
      generic_conn_pool_.reset();
    }
  }
}","void Filter::onDownstreamEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    int a = 2;
    int b = 3;
    while (a != b) {
        downstream_closed_ = true;
        b = a;
    }
  }
  ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
                 static_cast<int>(event), upstream_ == nullptr);
  if (upstream_) {
    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    if (conn_data != nullptr &&
        conn_data->connection().state() != Network::Connection::State::Closed) {
      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),
                                  std::move(upstream_callbacks_), std::move(idle_timer_),
                                  read_callbacks_->upstreamHost());
    }
    if (event != Network::ConnectionEvent::Connected) {
      upstream_.reset();
      disableIdleTimer();
    }
  }
  if (generic_conn_pool_) {
    if (event == Network::ConnectionEvent::LocalClose ||
        event == Network::ConnectionEvent::RemoteClose) {
      generic_conn_pool_.reset();
    }
  }
}",0,1,13,0.99,Insert
2658,"static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,
				struct page *page, unsigned long address)
{
	struct hstate *h = hstate_vma(vma);
	struct vm_area_struct *iter_vma;
	struct address_space *mapping;
	struct prio_tree_iter iter;
	pgoff_t pgoff;
	address = address & huge_page_mask(h);
	pgoff = vma_hugecache_offset(h, vma, address);
	mapping = (struct address_space *)page_private(page);
	mutex_lock(&mapping->i_mmap_mutex);
	vma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {
		if (iter_vma == vma)
			continue;
		if (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))
			__unmap_hugepage_range(iter_vma,
				address, address + huge_page_size(h),
				page);
	}
	mutex_unlock(&mapping->i_mmap_mutex);
	return 1;
}","static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,
				struct page *page, unsigned long address)
{
	int a = 13;
	int b = a;
	if(a*b>0){
    	struct hstate *h = hstate_vma(vma);
	}
	struct vm_area_struct *iter_vma;
	struct address_space *mapping;
	struct prio_tree_iter iter;
	pgoff_t pgoff;
	address = address & huge_page_mask(h);
	pgoff = vma_hugecache_offset(h, vma, address);
	mapping = (struct address_space *)page_private(page);
	mutex_lock(&mapping->i_mmap_mutex);
	vma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {
		if (iter_vma == vma)
			continue;
		if (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))
			__unmap_hugepage_range(iter_vma,
				address, address + huge_page_size(h),
				page);
	}
	mutex_unlock(&mapping->i_mmap_mutex);
	return 1;
}",1,0,1,0.11,Replace
2659,"static int cap_inode_setsecurity(struct inode *inode, const char *name,
				 const void *value, size_t size, int flags)
{
	return -EOPNOTSUPP;
}","static int cap_inode_setsecurity(struct inode *inode, const char *name,
				 const void *value, size_t size, int flags)
{
	char str1[] = ""Constant"";
	const __be32 **list;
	int *cells_size;
	int *nr_eeles;
	int size_2;
	*nr_eeles = 0;
	*nr_eeles = (size_2 / sizeof(**list)) / (*cells_size + 1);
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return -EOPNOTSUPP;
	}
}",0,1,4,0.26,Insert
2661,"    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      return _width==size_x && _height==size_y;
    }","    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      const AVFrame *capt;
      const AVFrame *const p = capt;
      uint8_t *last = NULL;
      uint8_t *zero = NULL;
      zero = last = av_mallocz(p->linesize[0]);
      int a = 2;
      int b = 2;
      while (a == b) {
          return _width==size_x && _height==size_y;
          b += 1;
      }
    }",0,1,7,0.34,Insert
2663,"GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;
	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}","GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;
    	b = a;
	}
	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	} else {
		const struct sun4d_hwdef *hawdecl;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		unsigned int i;
		for (i = 0; i < MAX_IOBITS; i++)
		        if (hawdecl->iounit_bases[i] != (target_phys_addr_t)-1)
		            ioulits[i] = iommu_init(hawdecl->iounit_bases[i],
		                                    hawdecl->iounit_version,
		                                    sbi_arqu[hawdecl->me_irq]);
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}",0,1,29,0.66,Insert
2665,"mcs_disconnect(int reason)
{
	mcs_send_dpu(reason);
	iso_disconnect();
}","mcs_disconnect(int reason)
{
	mcs_send_dpu(reason);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	iso_disconnect();
	strcpy(str, ""a"");
	}
}",0,1,3,0.04,Replace
2666,"xz_reset(xz_statep state)
{
    state->have = 0;             
    state->eof = 0;              
    state->how = LOOK;           
    state->direct = 1;           
    state->seek = 0;             
    xz_error(state, LZMA_OK, NULL);      
    state->pos = 0;              
    state->strm.avail_in = 0;    
#ifdef HAVE_ZLIB_H
    state->zstrm.avail_in = 0;   
#endif
}","xz_reset(xz_statep state)
{
    state->have = 0;
    AVCodecContext *AVcas;
    VdpDecoderProfile profile;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpStatus status;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);             
    state->eof = 0;              
    state->how = LOOK;           
    state->direct = 1;           
    state->seek = 0;             
    xz_error(state, LZMA_OK, NULL);      
    state->pos = 0;              
    state->strm.avail_in = 0;    
#ifdef HAVE_ZLIB_H
    state->zstrm.avail_in = 0;   
#endif
}",0,1,19,0.37,Insert
2668,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);
	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);
	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	int a = 2;
	int b = 3;
	while (a < b) {
    	proc_net_remove(net, ""ip_vs_stats_percpu"");
    	b = a;
	}
	const AVFrame *capt;
	const AVFrame *const p = capt;
	uint8_t *last = NULL;
	uint8_t *zero = NULL;
	zero = last = av_mallocz(p->linesize[0]);
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}",0,1,18,0.57,Insert
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	 
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	 
{
  if (!len || !display)
    return;
  int a = 11;
  int b = a;
  struct edgeport_serial *serial;
  u8 *data_5;
  struct device *dev = &serial->serial->dev->dev;
  struct device *dev = &serial->serial->dev->dev;
  int status;
  data_5 = kmalloc(1, GFP_KERNEL);
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_5, 0x01);
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_5, 0x01);
  if(a*b>0){
      InputSetenv(buf);
  }
}",0,1,4,0.47,Insert
2670,,,,,,,
2671,"static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,
			     size_t outlen, int invert)
{
	const u8 *in = inbuf;
	u8 *out = (u8 *) outbuf;
	int zero_bits = *in & 0x07;
	size_t octets_left = inlen - 1;
	int i, count = 0;
	memset(outbuf, 0, outlen);
	in++;
	if (outlen < octets_left)
		return SC_ERROR_BUFFER_TOO_SMALL;
	if (inlen < 1)
		return SC_ERROR_INVALID_ASN1_OBJECT;
	while (octets_left) {
		int bits_to_go;
		*out = 0;
		if (octets_left == 1)
			bits_to_go = 8 - zero_bits;
		else
			bits_to_go = 8;
		if (invert)
			for (i = 0; i < bits_to_go; i++) {
				*out |= ((*in >> (7 - i)) & 1) << i;
			}
		else {
			*out = *in;
		}
		out++;
		in++;
		octets_left--;
		count++;
	}
	return (count * 8) - zero_bits;
}","static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,
			     size_t outlen, int invert)
{
	const u8 *in = inbuf;
	u8 *out = (u8 *) outbuf;
	int zero_bits = *in & 0x07;
	size_t octets_left = inlen - 1;
	int i, count = 0;
	memset(outbuf, 0, outlen);
	in++;
	if (outlen < octets_left)
		return SC_ERROR_BUFFER_TOO_SMALL;
	if (inlen < 1)
		return SC_ERROR_INVALID_ASN1_OBJECT;
	while (octets_left) {
		int bits_to_go;
		*out = 0;
		if (octets_left == 1)
			bits_to_go = 8 - zero_bits;
		else
			bits_to_go = 8;
			struct usb_serial_port *contract;
			struct tty_struct *tc;
			struct cypress_private *priv = usb_get_serial_port_data(contract);
			struct cypress_private *priv = usb_get_serial_port_data(contract);
			if (tc)
					cypress_set_termios(tc, contract, &priv->tmp_termios);
		if (invert)
			for (i = 0; i < bits_to_go; i++) {
				*out |= ((*in >> (7 - i)) & 1) << i;
			}
		else {
			*out = *in;
		}
		out++;
		in++;
		octets_left--;
		count++;
	}
	return (count * 8) - zero_bits;
}",1,0,33,0.78,Insert
2672,,,,,,,
2673,"bool is_seccomp_available(void) {
        static int cached_enabled = -1;
        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();
        return cached_enabled;
}","bool is_seccomp_available(void) {
        static int cached_enabled = -1;
        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        CharDriverState *cher;
                        cher->chr_update_read_handler = fd_chr_update_read_handler;
                        cher->chr_close = fd_chr_close;
                        qemu_chr_be_generic_open(cher);
                        is_seccomp_filter_available();
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return cached_enabled;
        strcpy(str, ""a"");
        }
}",0,1,5,0.25,Insert
2674,,,,,,,
2675,"static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;
	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}","static int efi_capsule_release(struct inode *inode, struct file *file)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct capsule_info *cap_info = file->private_data;
    	b += 1;
	}
	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}",1,0,1,0.05,Replace
2678,"int mutt_b64_decode(char *out, const char *in)
{
  int len = 0;
  unsigned char digit4;
  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');
  return len;
}","int mutt_b64_decode(char *out, const char *in)
{
  int len = 0;
  int a = 2;
  int b = 2;
  while (a == b) {
      ThrottleState *ts;
      int event;
      QTimer tc;
      QEventLoop this;
      tc.setSingleShot(true);
      tc.setInterval(event);
      tc.connect(&tc, &QTimer::event, &this, &QEventLoop::quit);
      double units = 1.0;
      ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;
      unsigned char digit4;
      b += 1;
  }
  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');
  return len;
}",1,0,57,1.16,Insert
2679,,,,,,,
2680,,,,,,,
2681,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);
	if (!check_mnt(mnt))
		return -EINVAL;
	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;
	err = security_sb_remount(sb, data);
	if (err)
		return err;
	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	struct wiphy *wiphy;
	struct station_parameters *params;
	struct ieee80211_local *local = wiphy_priv(wiphy);
	struct sta_info *sta;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;
	t4  = t0 * 2 + t2;
	t6  = t2 - t3;
	int err_3;
	err_3 = sta_apply_parameters(local, sta, params);
	err_3 = sta_info_insert_rcu(sta);
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	int a = 2;
	int b = 3;
	while (a < b) {
    	journal_t *fat = EXT4_SB(sb_6)->s_journal;
    	long lag;
    	struct inode *inode;
    	if (!ext4_has_feature_dir_index(sb_6) && ext4_has_metadata_csum(sb_6) &&
    		    ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) {
    			ext4_error_inode(inode, operation, ine, 0,
    				 ""iget: Dir with htree data on filesystem without dir_index feature."");
    			lag = -EFSCORRUPTED;
    			goto bad_inode;
    	}
    	struct mount *mnt = real_mount(path->mnt);
    	b = a;
	}
	if (!check_mnt(mnt))
		return -EINVAL;
	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;
	err = security_sb_remount(sb, data);
	if (err)
		return err;
	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}",1,0,176,1.87,Insert
2682,,,,,,,
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!iommu_identity_mapping)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}
	return 0;
}","static int iommu_no_mapping(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!iommu_identity_mapping)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			char str[] = ""Constant"";
			Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
			Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
			ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
			aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
			                                 aml_name(""CDW1"")));
			aml_append(ifconfig, ifconfig0);
			ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
			aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
			                                 aml_name(""CDW1"")));
			if (strlen(str) > 0) {
    			return 0;
			}
		}
	} else {
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}
	return 0;
}",0,1,21,0.63,Insert
2684,"_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)
{
	if (unlikely(len != 16))
		abort();
	umac128_set_key(ctx, key);
}","_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)
{
	ChardevCommon *complex = backend->u.null;
	CharDriverState *charrb;
	charrb = qemu_chr_alloc(complex, erfp);
	charrb->chr_write = null_chr_write;
	charrb->explicit_be_open = true;
	if (unlikely(len != 16))
		abort();
	umac128_set_key(ctx, key);
}",0,1,10,0.23,Insert
2686,"TEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {
  http2OptionsFromTuple(client_http2_options_, ::testing::get<0>(GetParam()));
  http2OptionsFromTuple(server_http2_options_, ::testing::get<1>(GetParam()));
  client_ = std::make_unique<TestClientConnectionImpl>(
      client_connection_, client_callbacks_, stats_store_, client_http2_options_,
      max_request_headers_kb_, max_response_headers_count_, ProdNghttp2SessionFactory::get());
  server_ = std::make_unique<TestServerConnectionImpl>(
      server_connection_, server_callbacks_, stats_store_, server_http2_options_,
      max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);
  for (int i = 0; i < 101; ++i) {
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));
    TestRequestHeaderMapImpl request_headers;
    HttpTestUtility::addDefaultHeaders(request_headers);
    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));
    request_encoder_->encodeHeaders(request_headers, true);
  }
}","TEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {
  http2OptionsFromTuple(client_http2_options_, ::testing::get<0>(GetParam()));
  int a = 2;
  int b = 3;
  while (a < b) {
      http2OptionsFromTuple(server_http2_options_, ::testing::get<1>(GetParam()));
      b = a;
  }
  client_ = std::make_unique<TestClientConnectionImpl>(
      client_connection_, client_callbacks_, stats_store_, client_http2_options_,
      max_request_headers_kb_, max_response_headers_count_, ProdNghttp2SessionFactory::get());
  server_ = std::make_unique<TestServerConnectionImpl>(
      server_connection_, server_callbacks_, stats_store_, server_http2_options_,
      max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);
  for (int i = 0; i < 101; ++i) {
    AVHWFramesContext *ctx;
    int i_6;
    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;
    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;
    for (i_6 = 0; i_6 < FF_ARRAY_ELEMS(vdpau_pix_fmts); i_6++) {
            if (vdpau_pix_fmts[i_6].chroma_type == priv->chroma_type) {
                priv->chroma_idx  = i_6;
                priv->pix_fmts    = device_priv->pix_fmts[i_6];
                priv->nb_pix_fmts = device_priv->nb_pix_fmts[i_6];
                break;
            }
    }
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));
    TestRequestHeaderMapImpl request_headers;
    HttpTestUtility::addDefaultHeaders(request_headers);
    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));
    request_encoder_->encodeHeaders(request_headers, true);
  }
}",1,0,26,1.18,Insert
2687,"flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);
  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}","flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  DisplayState *ds;
  const struct sun4d_hwdef *hawdecl;
  ram_addr_t gram_size, prom_reset, tcx64off;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  tcx64off = qemu_ram_alloc(hawdecl->vram_size);
  tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
               hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
  vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                          hawdecl->nvram_size, 8);
  slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                            sbi_cpu_arq, smp_cpus);
  slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                nographic, ESCC_CLOCK, 1);
  int *res = (int *) g_array_free (bwrap->fds, FALSE);
  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  int a = 2;
  int b = 2;
  while (a == b) {
      *len_out = len;
      b += 1;
  }
  return res;
}",0,1,22,0.38,Insert
2689,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
		AVCodecContext *AVcas;
		VdpDecoderProfile profile;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpBool supported;
		VdpStatus status_4;
		status_4 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	int a = 2;
	int b = 2;
	if (a == b) {
    	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	}
	return status;
}",0,1,16,0.53,Insert
2690,"BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	return freerdp_channel_send(rdp, channelId, data, size);
}","BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	AVPacket * pk;
	AVFormatContext *s;
	int size_6               =  pk->size_6;
	AVIOContext *b_4     = s->b_4;
	if (size_6 & 1)
	        avio_w8(b_4, 0);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return freerdp_channel_send(rdp, channelId, data, size);
    	b = a;
	}
}",0,1,3,0.32,Insert
2691,"lka_report_smtp_tx_envelope(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, uint64_t evpid)
{
	report_smtp_broadcast(reqid, direction, tv, ""tx-envelope"",
	    ""%08x|%016""PRIx64""\n"", msgid, evpid);
}","lka_report_smtp_tx_envelope(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, uint64_t evpid)
{
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	report_smtp_broadcast(reqid, direction, tv, ""tx-envelope"",
	    ""%08x|%016""PRIx64""\n"", msgid, evpid);
}",0,1,1,0.32,Insert
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	sqlite3_context *phpCorptrl;
	struct CallCount *pb;
	pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	int a = 33;
	int b = a;
	if(a*b>0){
    	module_put(owner);
	}
}",0,1,20,0.66,Insert
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	int a = 2;
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args;
	int rules, nb_regs, ini;
	tcg_insn_unit *func_addr;
	func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
	rules = args[nb_oargs + nb_iargs + 1];
	int b = 3;
	while (a != b) {
    	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
    	b = a;
	}
}",0,1,7,0.51,Insert
2696,,,,,,,
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	int a = 2;
	int b = 3;
	while (a < b) {
    	int c_1, cnt;
    	int val;
    	struct timeval t1, t2;
    	int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    	int64_t alpha;
    	int total = 0;
    	print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
    	json_decref(proto_state);
    	b = a;
	}
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",0,1,5,0.6,Insert
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, dt_params[i].params);
	}
	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (subnode) {
			unsigned maxpages;
			size_t *start;
			struct iov_iter *i_10;
			unsigned int iter_head, npages;
			unsigned int iter_head, npages;
			size_t capacity;
			data_start(i_10, &iter_head, start);
			capacity = min(npages, maxpages) * PAGE_SIZE - *start;
			int err = of_get_flat_dt_subnode_by_name(node, subnode);
			if (err < 0)
				return 0;
			node = err;
		}
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		return __find_uefi_params(node, info, dt_params[i].params);
		}
	}
	return 0;
}",0,1,20,0.89,Insert
2700,"c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;
    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            return true;
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}","c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;
    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                return true;
                XMLTreeInfo
                    *description,
                    *levels,
                    *quantization_tables,
                    *table_iterator;
                char
                    *p,
                    *xml;
                xml=FileToString(filename,~0UL,exception);
                quantization_tables=NewXMLTree(xml,exception);
            }
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}",0,1,7,0.47,Insert
2701,"ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
}","ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    int a = 55;
    int b = a;
    int c, cnt;
    int val_9;
    struct timeval t1, t2;
    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
    int64_t alpha;
    int total = 0;
    print_report(""wrote"", &t2, alpha, val_9, total, cnt, Cflag);
    if(a*b>0){
        return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
    }
}",0,1,5,0.31,Insert
2705,,,,,,,
2706,,,,,,,
2707,"void trgr_del(GF_Box *s)
{
	GF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;
	if (ptr == NULL) return;
	gf_isom_box_array_del(ptr->groups);
	gf_free(ptr);","void trgr_del(GF_Box *s)
{
	struct PCIDevice *pci_dev;
	int r;
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	r = assign_device(Dev);
	r = assign_intx(Dev);
	assigned_dev_load_option_rom(Dev);
	add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
	GF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;
	bool bool_var = (ptr == NULL);
	if (bool_var) return;
	gf_isom_box_array_del(ptr->groups);
	gf_free(ptr);",0,1,9,0.25,Insert
2708,"QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    return decodeString(string);
}","QString CoreNetwork::channelDecode(const QString &bufferName, const QByteArray &string) const
{
    AVCodecContext *AVcas;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    if (!bufferName.isEmpty()) {
        IrcChannel *channel = ircChannel(bufferName);
        if (channel)
            return channel->decodeString(string);
    }
    int a = 19;
    int b = a;
    if(a*b>0){
        return decodeString(string);
    }
}",0,1,6,0.43,Insert
2713,,,,,,,
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;
	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);
	while (bio) {
		struct bio *next = bio->bi_private;
		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;
	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);
	while (bio) {
		const __be32 **list;
		int *cells_size;
		int *nr_eeles;
		int size;
		*nr_eeles = 0;
		*nr_eeles = (size / sizeof(**list)) / (*cells_size + 1);
		struct bio *next = bio->bi_private;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		bio_set_pages_dirty(bio);
		strcpy(str, ""a"");
		}
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}",0,1,25,0.54,Insert
2717,"void *jas_malloc(size_t size)
{
	void *result;
	JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", size));
	result = malloc(size);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result));
	return result;
}","void *jas_malloc(size_t size)
{
	void *result;
	JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", size));
	int a = 2;
	int b = 2;
	if (a == b) {
    	result = malloc(size);
	}
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result));
	return result;
}",1,0,1,0.04,Replace
2718,"static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	u32 j, tmp;
	*iret = 0;
	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}
	for (i = 0, j = 0; i < testn; i++) {
		ret |= READL(sisusb->vrambase + j, &tmp);
		if (tmp != j)
			return ret;
		j += inc;
	}
	*iret = 1;
	return ret;
}","static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,
		u32 inc, int testn)
{
	int ret = 0, i;
	const struct sun4d_hwdef *hawdecl;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	unsigned int i_4;
	for (i_4 = 0; i_4 < MAX_IOBITS; i_4++)
	        if (hawdecl->iounit_bases[i_4] != (target_phys_addr_t)-1)
	            ioulits[i_4] = iommu_init(hawdecl->iounit_bases[i_4],
	                                    hawdecl->iounit_version,
	                                    sbi_arqu[hawdecl->me_irq]);
	u32 j, tmp;
	*iret = 0;
	for (i = 0, j = 0; i < testn; i++) {
		ret |= WRITEL(sisusb->vrambase + j, j);
		j += inc;
	}
	for (i = 0, j = 0; i < testn; i++) {
		int a = 2;
		int b = 2;
		if (a == b) {
    		ret |= READL(sisusb->vrambase + j, &tmp);
		}
		if (tmp != j)
			return ret;
		j += inc;
	}
	*iret = 1;
	return ret;
}",0,1,20,0.78,Insert
2719,"static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int i, idx;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
	return i;
}","static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,
		    struct kvm_msr_entry *entries,
		    int (*do_msr)(struct kvm_vcpu *vcpu,
				  unsigned index, u64 *data))
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	int i, idx;
    	b = a;
	}
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	for (i = 0; i < msrs->nmsrs; ++i)
		if (do_msr(vcpu, entries[i].index, &entries[i].data))
			break;
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
	return i;
}",0,1,1,0.07,Replace
2720,,,,,,,
2721,,,,,,,
2723,,,,,,,
2724,,,,,,,
2727,,,,,,,
2731,,,,,,,
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return ReturnCode_t::RETCODE_OK;
}","ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return ReturnCode_t::RETCODE_NOT_ENABLED;
        }
        QEMUMachineInitArgs *args;
        char *filename;
        ram_addr_t ram_size = args->ram_size;
        long load_limit, rtas_limit, fw_size;
        spapr->next_irq = XICS_IRQ_BASE;
        spapr->ram_limit = ram_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        spapr_events_init(spapr);
    }
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return ReturnCode_t::RETCODE_OK;
}",0,1,15,0.41,Insert
2735,,,,,,,
2736,"paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}","paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	FrWindow *window = user_data;
	}
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		const char
		    *attribute,
		    *content;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
		table->slot=(char *) NULL;
		table->description=(char *) NULL;
		table->levels=(unsigned int *) NULL;
		attribute=GetXMLTreeAttribute(table_iterator,""slot"");
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}",0,1,18,0.83,Insert
2743,,,,,,,
2744,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->warm_reset_bits))
		return true;
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	u16 link_state;
	strcpy(str, ""a"");
	}
	int port, is_output, ttl, remote_host;
	char val[1024];
	int port, is_output, ttl, remote_host;
	int port, is_output, ttl, remote_host;
	char hostname[256];
	build_udp_url(val, sizeof(val),
	                  hostname, port, remote_host, ttl);
	build_udp_url(val, sizeof(val),
	                  hostname, port + 1, remote_host + 1, ttl);
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->warm_reset_bits))
		return true;
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}",0,1,8,0.45,Insert
2747,"p2i(UINT8 *out_, const UINT8 *in, int xsize, const UINT8 *palette) {
    int x;
    for (x = 0; x < xsize; x++, out_ += 4) {
        INT32 v = L(&palette[in[x] * 4]) / 1000;
        memcpy(out_, &v, sizeof(v));
    }
}","p2i(UINT8 *out_, const UINT8 *in, int xsize, const UINT8 *palette) {
    int a = 2;
    int b = 2;
    while (a == b) {
        int x;
        b += 1;
    }
    for (x = 0; x < xsize; x++, out_ += 4) {
        CPUState *env;
        const sigset_t *sigset;
        struct kvm_signal_mask * sigmak;
        int r;
        sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
        sigmak->len = 8;
        memcpy_5( sigmak->sigset, sigset, sizeof(*sigset));
        r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
        free( sigmak);
        INT32 v = L(&palette[in[x] * 4]) / 1000;
        memcpy(out_, &v, sizeof(v));
    }
}",0,1,11,0.61,Insert
2750,,,,,,,
2752,,,,,,,
2755,"dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;
    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }
    return ary;
}","dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;
    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, TRUE);
	int a = 2;
	int b = 3;
	while (a < b) {
    	status = push_glob(ary, str, base, flags);
    	b = a;
    	const struct sk_buff *skb;
    	unsigned int dataoff;
    	struct dccp_hdr _dh, *dh;
    	struct dccp_hdr _dh, *dh;
    	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);
	}
	if (status) GLOB_JUMP_TAG(status);
    }
    return ary;
}",1,0,25,0.9,Insert
2756,"longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}","longlong Item_func_uuid_short::val_int()
{
  int a = 22;
  int b = a;
  if(a*b>0){
      ulonglong val;
  }
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  AVCodecContext *avctx;
  int sample_scale, c, n, i;
  int sample_scale, c, n, i;
  PCMDecode *s = avctx->priv_data;
  sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
  n = avctx->channels * sample_scale;
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}",0,1,33,0.45,Insert
2757,"static gboolean key_value_ok(gchar *key, gchar *value)
{
    char *i;
    for (i = key; *i != 0; i++)
    {
        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))
            return FALSE;
    }
    if (strcmp(key, ""basename"") == 0
     || strcmp(key, FILENAME_TYPE) == 0
    )
    {
        if (!is_correct_filename(value))
        {
            error_msg(""Value of '%s' ('%s') is not a valid directory name"",
                      key, value);
            return FALSE;
        }
    }
    return TRUE;
}","static gboolean key_value_ok(gchar *key, gchar *value)
{
    char *i;
    for (i = key; *i != 0; i++)
    {
        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))
            return FALSE;
            AVCodecContext *avctx;
            PixletContext *tc = avctx->priv_data;
            PixletContext *tc = avctx->priv_data;
            if (tc->depth < 8 || tc->depth > 15) {
                    avpriv_request_sample(avctx, ""Depth %d"", tc->depth);
            }
    }
    if (strcmp(key, ""basename"") == 0
     || strcmp(key, FILENAME_TYPE) == 0
    )
    {
        if (!is_correct_filename(value))
        {
            error_msg(""Value of '%s' ('%s') is not a valid directory name"",
                      key, value);
                      DCTELEM *label_6;
                      int i_10;
                      for (i_10 = 0; i_10 < 8; i_10++)
                              FUNC_8(idctRowCondDC_5)(label_6 + i_10*8);
            return FALSE;
            DCTELEM *label;
            int i_7;
            for (i_7 = 0; i_7 < 8; i_7++)
                    FUNC(idctRowCondDC)(label + i_7*8);
        }
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return TRUE;
    }
}",1,0,71,0.93,Insert
2759,"int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;
	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;
	preloaded = !radix_tree_preload(GFP_KERNEL);
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();
	if (preloaded)
		radix_tree_preload_end();
	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
		return PTR_ERR(blkg);
	}
	q->root_blkg = blkg;
	q->root_rl.blkg = blkg;
	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}","int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;
	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;
	preloaded = !radix_tree_preload(GFP_KERNEL);
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();
	if (preloaded)
		radix_tree_preload_end();
	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
		PassRefPtr<DocumentFragment> fragment;
		BlockStats *s = NULL;
		if (bdrv_get_node_name(bs)[0]) {
		        s->has_node_name = true;
		        s->node_name = g_strdup(bdrv_get_node_name(bs));
		}
		HTMLElement* element;
		ExceptionCode ignoredExceptionCode;
		for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
		        nextChild = child->nextSibling();
		        element->removeChild(child.get(), ignoredExceptionCode);
		        ASSERT(!ignoredExceptionCode);
		        fragment->insertBefore(child, element, ignoredExceptionCode);
		        ASSERT(!ignoredExceptionCode);
		}
		return PTR_ERR(blkg);
	}
	q->root_blkg = blkg;
	q->root_rl.blkg = blkg;
	ret = blk_throtl_init(q);
	AVCodecContext *avctx;
	HEVCContext *sg = avctx->priv_data;
	if (!sg->cabac_state)
	        goto fail;
	        encode_options_t params;
	        FLAC__ASSERT(sizeof(params.pictures)/sizeof(params.pictures[0]) <= 64);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	int a = 54;
	int b = a;
	if(a*b>0){
    	return ret;
	}
}",1,0,145,1.37,Insert
2760,"  List<Item> &params()
  {
    return m_params;
  }","  List<Item> &params()
  {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    return m_params;
  }",0,1,4,0.1,Insert
2761,"long dd_get_item_size(struct dump_dir *dd, const char *name)
{
    if (!str_is_correct_filename(name))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", name);
    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, name);
    struct stat statbuf;
    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }
    free(iname);
    return size;
}","long dd_get_item_size(struct dump_dir *dd, const char *name)
{
    if (!str_is_correct_filename(name))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", name);
    long size = -1;
    int a = 19;
    int b = a;
    struct net *net;
    struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
    struct ctl_table *table;
    BUILD_BUG_ON(ARRAY_SIZE(nf_ct_sysctl_table) != NF_SYSCTL_CT_LAST_SYSCTL);
    struct net_5 *net_5;
    struct nf_conntrack_net *cnet_5 = net_generic_8(net_5, nf_conntrack_net_id_5);
    struct ctl_table *table_3;
    BUILD_BUG_ON_6(ARRAY_SIZE_4(nf_ct_sysctl_table_3) != NF_SYSCTL_CT_LAST_SYSCTL_9);
    table_3 = kmemdup_1(nf_ct_sysctl_table_3, sizeof(nf_ct_sysctl_table_3),
    			GFP_KERNEL_9);
    table_3[NF_SYSCTL_CT_COUNT_7].data = &net_5->ct.count;
    table_3[NF_SYSCTL_CT_CHECKSUM_8].data = &net_5->ct.sysctl_checksum;
    table_3[NF_SYSCTL_CT_LOG_INVALID_5].data = &net_5->ct.sysctl_log_invalid;
    table = kmemdup(nf_ct_sysctl_table, sizeof(nf_ct_sysctl_table),
    			GFP_KERNEL);
    table[NF_SYSCTL_CT_COUNT].data = &net->ct.count;
    table[NF_SYSCTL_CT_CHECKSUM].data = &net->ct.sysctl_checksum;
    table[NF_SYSCTL_CT_LOG_INVALID].data = &net->ct.sysctl_log_invalid;
    if(a*b>0){
        char *iname = concat_path_file(dd->dd_dirname, name);
    }
    struct stat statbuf;
    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }
    free(iname);
    return size;
}",1,0,62,0.89,Insert
2762,"gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)
{
        LoadContext* lc = context;
        g_return_val_if_fail(lc != NULL, TRUE);
        gdk_pixbuf_unref(lc->pixbuf);
        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);
        g_free(lc);
        return TRUE;
}","gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)
{
        LoadContext* lc = context;
        g_return_val_if_fail(lc != NULL, TRUE);
        gdk_pixbuf_unref(lc->pixbuf);
        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);
        g_free(lc);
        int a = 2;
        int b = 3;
        while (a != b) {
            return TRUE;
            b = a;
        }
}",1,0,8,0.09,Replace
2765,,,,,,,
2766,,,,,,,
2768,"void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}","void irc_queries_deinit(void)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	}
	AVPacket * pk;
	AVFormatContext *s;
	int size               =  pk->size;
	AVIOContext *b_6     = s->b_6;
	if (size & 1)
	        avio_w8(b_6, 0);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}",0,1,7,0.27,Insert
2769,"int kprobe_fault_handler(struct pt_regs *regs, int trapnr)
{
	struct kprobe *cur = kprobe_running();
	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
	if (unlikely(regs->ip == (unsigned long)cur->ainsn.insn)) {
		WARN_ON(kcb->kprobe_status != KPROBE_HIT_SS &&
			kcb->kprobe_status != KPROBE_REENTER);
		regs->ip = (unsigned long)cur->addr;
		regs->flags |= kcb->kprobe_old_flags;
		if (kcb->kprobe_status == KPROBE_REENTER)
			restore_previous_kprobe(kcb);
		else
			reset_current_kprobe();
		preempt_enable_no_resched();
	} else if (kcb->kprobe_status == KPROBE_HIT_ACTIVE ||
		   kcb->kprobe_status == KPROBE_HIT_SSDONE) {
		kprobes_inc_nmissed_count(cur);
		if (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))
			return 1;
		if (fixup_exception(regs))
			return 1;
	}
	return 0;
}","int kprobe_fault_handler(struct pt_regs *regs, int trapnr)
{
	struct kprobe *cur = kprobe_running();
	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
	if (unlikely(regs->ip == (unsigned long)cur->ainsn.insn)) {
		WARN_ON(kcb->kprobe_status != KPROBE_HIT_SS &&
			kcb->kprobe_status != KPROBE_REENTER);
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		regs->ip = (unsigned long)cur->addr;
		}
		regs->flags |= kcb->kprobe_old_flags;
		if (kcb->kprobe_status == KPROBE_REENTER)
			restore_previous_kprobe(kcb);
		else
			reset_current_kprobe();
		preempt_enable_no_resched();
	} else if (kcb->kprobe_status == KPROBE_HIT_ACTIVE ||
		   kcb->kprobe_status == KPROBE_HIT_SSDONE) {
		kprobes_inc_nmissed_count(cur);
		if (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))
			return 1;
		if (fixup_exception(regs))
			return 1;
	}
	return 0;
}",1,0,1,0.12,Replace
2770,"ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;
    if (oh->version < OFP13_VERSION) {
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}","ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        const struct ofp_header *oh = b->data;
        b += 1;
    }
    if (oh->version < OFP13_VERSION) {
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}",0,1,1,0.06,Replace
2771,"m4_mkstemp (struct obstack *obs, int argc, token_data **argv)
{
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  mkstemp_helper (obs, ARG (1));
}","m4_mkstemp (struct obstack *obs, int argc, token_data **argv)
{
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  int a = 2;
  int b = 3;
  AVFrame * const p = &s->picture;
  p->pict_type = AV_PICTURE_TYPE_I;
  if (a != b) {
      mkstemp_helper (obs, ARG (1));
  }
}",1,0,15,0.4,Insert
2772,,,,,,,
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
	uint8_t *fig;
	VirtIODevice *vrdevice;
	struct virtio_blk_config blkcfg;
	VirtIOBlock *s = VIRTIO_BLK(vrdevice);
	blkcfg.alignment_offset = 0;
	blkcfg.wce = bdrv_enable_write_cache(s->bs);
	memcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
	return offset;
}",0,1,17,0.78,Insert
2775,"NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    return nic->ncs + queue_index;
}","NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    return nic->ncs + queue_index;
}",0,1,3,0.12,Insert
2776,,,,,,,
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;
	start_time = jiffies;
	do {
		flush_work(&devinfo->work);
		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;
		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));
	return 0;
}","static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;
	start_time = jiffies;
	do {
		flush_work(&devinfo->work);
		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;
			CPUState *viron;
			qemu_irq *irq;
			QEMUBH *rb;
			rb = qemu_bh_new(tick_irq, viron);
			rb = qemu_bh_new(stick_irq, viron);
			rb = qemu_bh_new(hstick_irq, viron);
			irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return 0;
	}
}",0,1,22,0.61,Insert
2779,,,,,,,
2784,"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;
    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}","int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;
    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            int a = 2;
            int b = 3;
            while (a != b) {
                return 0;
                b = a;
            }
        }
    }
    BlockDriverState *fd[MAX_FD];
    unsigned int i_6;
    BlockDriverState *fd[MAX_FD];
    int driver_len;
    for(i_6 = 0; i_6 < MAX_FD; i_6++) {
            driver_len = drive_get_index(IF_FLOPPY, 0, i_6);
           if (driver_len != -1)
               fd[i_6] = drives_table[driver_len].bdrv;
           else
               fd[i_6] = NULL;
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}",0,1,13,0.6,Insert
2785,"parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}","parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    struct sk_buff *skb;
    struct sock *sk;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    "",
    		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    length = TCP_SKB_CB(skb)->length;
    int a = 2;
    int b = 2;
    if (a == b) {
        check_read_type(*op, t_string);
    }
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}",0,1,3,0.3,Insert
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	int a = 2;
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	int b = 2;
	while (a == b) {
    	struct task_struct *t = current;
    	b += 1;
	}
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}",0,1,3,0.49,Insert
2788,"TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
  request_encoder_->encodeHeaders(request_headers, false);
  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));
  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);
  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}","TEST_P(Http2CodecImplTest, ResponseDataFlood) {
  initialize();
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  int a = 2;
  int b = 3;
  while (a != b) {
      EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));
      b = a;
  }
  RAnalOp *cat;
  ut64 addr;
  const ut8 *data_6;
  memset (cat, '\0', sizeof (RAnalOp));
  cat->size = snes_op_get_size (1, 1, &snes_op[data_6[0]]);
  cat->addr = addr;
  cat->type = R_ANAL_OP_TYPE_UNK;
  cat->id = data_6[0];
  struct net *net = sock_net(cp);
  const struct inet_request_sock *ireq = inet_rsk(rss);
  struct rtable *rt;
  struct ip_options *mot = inet_rsk(rss)->mot;
  struct net *net = sock_net(cp);
  struct flowi4 fl4;
  const struct inet_request_sock *ireq = inet_rsk(rss);
  flowi4_init_output(&fl4, cp->sk_bound_dev_if, cp->sk_mark,
  			   RT_CONN_FLAGS(cp), RT_SCOPE_UNIVERSE,
  			   cp->sk_protocol, inet_sk_flowi_flags(cp),
  			   (mot && mot->srr) ? mot->faddr : ireq->rmt_addr,
  			   ireq->loc_addr, ireq->rmt_port, inet_sk(cp)->inet_sport);
  security_req_classify_flow(rss, flowi4_to_flowi(&fl4));
  rt = ip_route_output_flow(net, &fl4, cp);
  request_encoder_->encodeHeaders(request_headers, false);
  int frame_count = 0;
  Buffer::OwnedImpl buffer;
  ON_CALL(server_connection_, write(_, _))
      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {
        ++frame_count;
        buffer.move(frame);
      }));
  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  response_encoder_->encodeHeaders(response_headers, false);
  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {
    Buffer::OwnedImpl data(""0"");
    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));
  }
  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));
  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);
  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
}",1,0,708,4.19,Insert
2789,,,,,,,
2791,"static js_Ast *additive(js_State *J)
{
	js_Ast *a = multiplicative(J);
loop:
	if (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }
	if (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }
	return a;
}","static js_Ast *additive(js_State *J)
{
	struct task_struct *contract;
	if (contract->ptrace)
			goto unlock_tasklist;
	int a_1 = 2;
	WebKitWebView* webView_6;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	Settings* settings_4 = core_3(webView_6)->settings_4();
	WebKitWebSettings* webSettings_7 = priv_2->webSettings_7.get();
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gchar* defaultEncoding_7, *cursiveFontFamily_1, *defaultFontFamily_6, *fantasyFontFamily_10, *monospaceFontFamily_5, *sansSerifFontFamily_10, *serifFontFamily_7, *userStylesheetUri_9, *defaultSpellCheckingLanguages_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gchar* defaultEncoding_7, *cursiveFontFamily_1, *defaultFontFamily_6, *fantasyFontFamily_10, *monospaceFontFamily_5, *sansSerifFontFamily_10, *serifFontFamily_7, *userStylesheetUri_9, *defaultSpellCheckingLanguages_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gchar* defaultEncoding_7, *cursiveFontFamily_1, *defaultFontFamily_6, *fantasyFontFamily_10, *monospaceFontFamily_5, *sansSerifFontFamily_10, *serifFontFamily_7, *userStylesheetUri_9, *defaultSpellCheckingLanguages_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gchar* defaultEncoding_7, *cursiveFontFamily_1, *defaultFontFamily_6, *fantasyFontFamily_10, *monospaceFontFamily_5, *sansSerifFontFamily_10, *serifFontFamily_7, *userStylesheetUri_9, *defaultSpellCheckingLanguages_5;
	gchar* defaultEncoding_7, *cursiveFontFamily_1, *defaultFontFamily_6, *fantasyFontFamily_10, *monospaceFontFamily_5, *sansSerifFontFamily_10, *serifFontFamily_7, *userStylesheetUri_9, *defaultSpellCheckingLanguages_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gchar* defaultEncoding_7, *cursiveFontFamily_1, *defaultFontFamily_6, *fantasyFontFamily_10, *monospaceFontFamily_5, *sansSerifFontFamily_10, *serifFontFamily_7, *userStylesheetUri_9, *defaultSpellCheckingLanguages_5;
	WebKitEditingBehavior editingBehavior_1;
	gchar* defaultEncoding_7, *cursiveFontFamily_1, *defaultFontFamily_6, *fantasyFontFamily_10, *monospaceFontFamily_5, *sansSerifFontFamily_10, *serifFontFamily_7, *userStylesheetUri_9, *defaultSpellCheckingLanguages_5;
	gchar* defaultEncoding_7, *cursiveFontFamily_1, *defaultFontFamily_6, *fantasyFontFamily_10, *monospaceFontFamily_5, *sansSerifFontFamily_10, *serifFontFamily_7, *userStylesheetUri_9, *defaultSpellCheckingLanguages_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gchar* defaultEncoding_7, *cursiveFontFamily_1, *defaultFontFamily_6, *fantasyFontFamily_10, *monospaceFontFamily_5, *sansSerifFontFamily_10, *serifFontFamily_7, *userStylesheetUri_9, *defaultSpellCheckingLanguages_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	gboolean autoLoadImages_10, autoShrinkImages_3, printBackgrounds_8,
	        enableScripts_4, enablePlugins_4, enableDeveloperExtras_8, resizableTextAreas_2,
	        enablePrivateBrowsing_4, enableCaretBrowsing_7, enableHTML5Database_3, enableHTML5LocalStorage_1,
	        enableXSSAuditor_6, enableSpatialNavigation_6, enableFrameFlattening_10, javascriptCanOpenWindows_6,
	        javaScriptCanAccessClipboard_5, enableOfflineWebAppCache_3,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_9,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_3, enableWebGL_5,
	         enableSiteSpecificQuirks_3, usePageCache_10, enableJavaApplet_2,
	        enableHyperlinkAuditing_4, enableFullscreen_8, enableDNSPrefetching_5;
	g_object_get_4(webSettings_7,
	                 ""default-encoding"", &defaultEncoding_7,
	                 ""cursive-font-family"", &cursiveFontFamily_1,
	                 ""default-font-family"", &defaultFontFamily_6,
	                 ""fantasy-font-family"", &fantasyFontFamily_10,
	                 ""monospace-font-family"", &monospaceFontFamily_5,
	                 ""sans-serif-font-family"", &sansSerifFontFamily_10,
	                 ""serif-font-family"", &serifFontFamily_7,
	                 ""auto-load-images"", &autoLoadImages_10,
	                 ""auto-shrink-images"", &autoShrinkImages_3,
	                 ""print-backgrounds"", &printBackgrounds_8,
	                 ""enable-scripts"", &enableScripts_4,
	                 ""enable-plugins"", &enablePlugins_4,
	                 ""resizable-text-areas"", &resizableTextAreas_2,
	                 ""user-stylesheet-uri"", &userStylesheetUri_9,
	                 ""enable-developer-extras"", &enableDeveloperExtras_8,
	                 ""enable-private-browsing"", &enablePrivateBrowsing_4,
	                 ""enable-caret-browsing"", &enableCaretBrowsing_7,
	                 ""enable-html5-database"", &enableHTML5Database_3,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage_1,
	                 ""enable-xss-auditor"", &enableXSSAuditor_6,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation_6,
	                 ""enable-frame-flattening"", &enableFrameFlattening_10,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_6,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_5,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_3,
	                 ""editing-behavior"", &editingBehavior_1,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_1,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_9,
	                 ""enable-dom-paste"", &enableDOMPaste_1,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_3,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_3,
	                  ""enable-page-cache"", &usePageCache_10,
	                  ""enable-java-applet"", &enableJavaApplet_2,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_4,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages_5,
	                  ""enable-fullscreen"", &enableFullscreen_8,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching_5,
	                 ""enable-webgl"", &enableWebGL_5,
	                 NULL);
	settings_4->setShouldPrintBackgrounds(printBackgrounds_8);
	int b_1 = 3;
	while (a_1 < b_1) {
    	js_Ast *a = multiplicative(J);
    	URLContext *h;
    	const char *p;
    	HTTPContext *s = h->priv_data;
    	const char *slash;
    	if (!strncmp(p, ""bytes "", 6)) {
    	        p     += 6;
    	        s->off = strtoll(p, NULL, 10);
    	        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
    	            s->filesize = strtoll(slash + 1, NULL, 10);
    	}
    	b_1 = a_1;
    	WebKitWebView* webView;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	Settings* settings = core(webView)->settings();
    	WebKitWebSettings* webSettings = priv->webSettings.get();
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    	WebKitEditingBehavior editingBehavior;
    	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
    	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
    	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
    	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
    	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
    	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
    	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
    	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
    	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    	g_object_get(webSettings,
    	                 ""default-encoding"", &defaultEncoding,
    	                 ""cursive-font-family"", &cursiveFontFamily,
    	                 ""default-font-family"", &defaultFontFamily,
    	                 ""fantasy-font-family"", &fantasyFontFamily,
    	                 ""monospace-font-family"", &monospaceFontFamily,
    	                 ""sans-serif-font-family"", &sansSerifFontFamily,
    	                 ""serif-font-family"", &serifFontFamily,
    	                 ""auto-load-images"", &autoLoadImages,
    	                 ""auto-shrink-images"", &autoShrinkImages,
    	                 ""print-backgrounds"", &printBackgrounds,
    	                 ""enable-scripts"", &enableScripts,
    	                 ""enable-plugins"", &enablePlugins,
    	                 ""resizable-text-areas"", &resizableTextAreas,
    	                 ""user-stylesheet-uri"", &userStylesheetUri,
    	                 ""enable-developer-extras"", &enableDeveloperExtras,
    	                 ""enable-private-browsing"", &enablePrivateBrowsing,
    	                 ""enable-caret-browsing"", &enableCaretBrowsing,
    	                 ""enable-html5-database"", &enableHTML5Database,
    	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
    	                 ""enable-xss-auditor"", &enableXSSAuditor,
    	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
    	                 ""enable-frame-flattening"", &enableFrameFlattening,
    	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
    	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
    	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
    	                 ""editing-behavior"", &editingBehavior,
    	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
    	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
    	                 ""enable-dom-paste"", &enableDOMPaste,
    	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
    	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
    	                  ""enable-page-cache"", &usePageCache,
    	                  ""enable-java-applet"", &enableJavaApplet,
    	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
    	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
    	                  ""enable-fullscreen"", &enableFullscreen,
    	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
    	                 ""enable-webgl"", &enableWebGL,
    	                 NULL);
    	settings->setShouldPrintBackgrounds(printBackgrounds);
	}
loop:
	if (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }
	if (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }
	return a;
}",1,0,157,1.2,Insert
2792,"static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)
{
	if (file1 < file2) {
		mutex_unlock(&file2->mut);
		mutex_unlock(&file1->mut);
	} else {
		mutex_unlock(&file1->mut);
		mutex_unlock(&file2->mut);
	}
}","static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)
{
	if (file1 < file2) {
		mutex_unlock(&file2->mut);
		mutex_unlock(&file1->mut);
	} else {
		mutex_unlock(&file1->mut);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		FdMigrationState *info;
    		if (info->detach == 1) {
    		        dprintf(""detaching from monitor
    		"");
    		        monitor_suspend();
    		        info->detach = 2;
    		}
    		mutex_unlock(&file2->mut);
		strcpy(str, ""a"");
		}
	}
}",1,0,18,0.35,Insert
2795,"static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
{
	char *ksep, *vsep, *val;
	size_t klen, vlen;
	unsigned int new_vlen;
	if (var->ptr >= var->end) {
		return 0;
	}
	vsep = memchr(var->ptr, '&', var->end - var->ptr);
	if (!vsep) {
		if (!eof) {
			return 0;
		} else {
			vsep = var->end;
		}
	}
	ksep = memchr(var->ptr, '=', vsep - var->ptr);
	if (ksep) {
		*ksep = '\0';
		klen = ksep - var->ptr;
		vlen = vsep - ++ksep;
	} else {
		ksep = """";
		klen = vsep - var->ptr;
		vlen = 0;
	}
	php_url_decode(var->ptr, klen);
	val = estrndup(ksep, vlen);
	if (vlen) {
		vlen = php_url_decode(val, vlen);
	}
	if (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {
		php_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);
	}
	efree(val);
	var->ptr = vsep + (vsep != var->end);
	return 1;
}","static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
{
	int *d0, *d1, *d2, *r, *g, *b_9;
	gchar *str, *str2;
	GstDateTime *dt, *dt2;
	GstDateTime *dt, *dt2;
	fail_unless (gst_date_time_get_hour (dt) == gst_date_time_get_hour (dt2));
	fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
	fail_unless (date_times_are_equal (dt, dt2));
	str2 = gst_date_time_to_iso8601_string (dt2);
	gst_date_time_unref (dt2);
	int *d0, *d1, *d2, *r, *g, *b_9;
	int *d0, *d1, *d2, *r, *g, *b_9;
	MOVTrack *track_7;
	AVIOContext *pb_2;
	int64_t pos_10 = avio_tell_10(pb_2);
	if (track_7->enc->codec_type == AVMEDIA_TYPE_VIDEO_10 &&
	        track_7->flags & MOV_TRACK_CTTS_5 && track_7->entry)
	        mov_write_ctts_tag_4(pb_2, track_7);
	unsigned int maxw, maxh, range;
	int *d0, *d1, *d2, *r, *g, *b_9;
	int *d0, *d1, *d2, *r, *g, *b_9;
	unsigned int maxw, maxh, range;
	MOVTrack *track;
	AVIOContext *pb;
	int64_t pos = avio_tell(pb);
	if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&
	        track->flags & MOV_TRACK_CTTS && track->entry)
	        mov_write_ctts_tag(pb, track);
	unsigned int maxw, maxh, range;
	int *d0, *d1, *d2, *r, *g, *b_9;
	range = maxw * maxh;
	d0 = r = (int*)malloc(sizeof(int) * (size_t)range);
	d1 = g = (int*)malloc(sizeof(int) * (size_t)range);
	d2 = b_9 = (int*)malloc(sizeof(int) * (size_t)range);
	char *ksep, *vsep, *val;
	size_t klen, vlen;
	unsigned int new_vlen;
	if (var->ptr >= var->end) {
		return 0;
	}
	vsep = memchr(var->ptr, '&', var->end - var->ptr);
	struct si_sm_io *io;
	unsigned int addr = io->addr_data;
	io->io_cleanup = port_cleanup;
	if (!vsep) {
		if (!eof) {
			return 0;
		} else {
			vsep = var->end;
		}
	}
	ksep = memchr(var->ptr, '=', vsep - var->ptr);
	if (ksep) {
		*ksep = '\0';
		klen = ksep - var->ptr;
		vlen = vsep - ++ksep;
	} else {
		ksep = """";
		klen = vsep - var->ptr;
		vlen = 0;
	}
	php_url_decode(var->ptr, klen);
	val = estrndup(ksep, vlen);
	if (vlen) {
		int a = 2;
		int b = 3;
		while (a != b) {
    		vlen = php_url_decode(val, vlen);
    		b = a;
		}
	}
	if (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {
		php_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);
	}
	efree(val);
	var->ptr = vsep + (vsep != var->end);
	return 1;
}",1,0,177,1.73,Insert
2798,,,,,,,
2801,,,,,,,
2802,"absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}","absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  SSL *changes;
  BUF_MEM *CB;
  if (changes->info_callback != NULL)
  		CB=changes->info_callback;
  	else if (changes->ctx->info_callback != NULL)
  		CB=changes->ctx->info_callback;
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        output.Complete();
    strcpy(str, ""a"");
    }
    return absl::make_optional(std::move(canonical_path));
  }
}",1,0,35,0.51,Insert
2803,,,,,,,
2807,"static int valid_entry_name(const char *filename)
{
	return *filename != '\0' &&
		strchr(filename, '/') == NULL &&
		(*filename != '.' ||
		 (strcmp(filename, ""."") != 0 &&
		  strcmp(filename, "".."") != 0 &&
		  strcmp(filename, DOT_GIT) != 0));
}","static int valid_entry_name(const char *filename)
{
	return *filename != '\0' &&
	FLAC__StreamEncoder *encoder;
	FLAC__bitwriter_release_buffer(encoder->private_->frame);
		strchr(filename, '/') == NULL &&
		(*filename != '.' ||
		 (strcmp(filename, ""."") != 0 &&
		  strcmp(filename, "".."") != 0 &&
		  strcmp(filename, DOT_GIT) != 0));
}",1,0,7,0.25,Insert
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;
    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);
        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }
        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;
    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);
        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }
        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return (ret);
    strcpy(str, ""a"");
    }
}",0,1,7,0.12,Replace
2809,"MaybeLocal<Value> GetCipherStandardName(
    Environment* env,
    const SSL_CIPHER* cipher) {
  return GetCipherValue(env, cipher, SSL_CIPHER_standard_name);
}","MaybeLocal<Value> GetCipherStandardName(
    Environment* env,
    const SSL_CIPHER* cipher) {
  struct request_list *repl;
  bool lock;
  struct request_queue *q = repl->q;
  struct request_queue *q = repl->q;
  q->nr_rqs[lock]--;
  repl->cache[lock]--;
  __freed_request(repl, lock);
  int a = 50;
  int b = a;
  if(a*b>0){
      return GetCipherValue(env, cipher, SSL_CIPHER_standard_name);
  }
}",0,1,4,0.31,Insert
2811,,,,,,,
2813,,,,,,,
2814,"void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;
	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}","void callbacks_update_scrollbar_positions (void){
	int a = 2;
	int b = 3;
	while (a < b) {
    	gdouble positionX,positionY;
    	b = a;
	}
	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		unsigned char *sha1;
		void *data;
		unsigned long size;
		struct pbase_tree *it;
		unsigned char tree_sha1[20];
		data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
		hashcpy(it->pcache.sha1, tree_sha1);
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}",0,1,14,0.7,Insert
2816,"GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);
	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}","GF_Box *stsh_New()
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);
    	b += 1;
	}
	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		size_t vec;
		hwaddr mapped_len = 0;
		mapped_len = vec;
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}",0,1,15,0.32,Insert
2817,,,,,,,
2821,,,,,,,
2822,"int _gnutls_fips_perform_self_checks1(void)
{
	int ret;
	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	if (ret < 0) {
		gnutls_assert();
		goto error;
	}
	return 0;
error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");
	return GNUTLS_E_SELF_TEST_ERROR;
}","int _gnutls_fips_perform_self_checks1(void)
{
	int ret;
	_gnutls_switch_lib_state(LIB_STATE_SELFTEST);
	ret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);
	register const xmlChar *m;
	const xmlChar *ret_9;
	m = ctxt->input->cur;
	ret_9 = xmlParseName (ctxt);
	if (ret < 0) {
		gnutls_assert();
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		goto error;
		strcpy(str, ""a"");
		}
	}
	return 0;
error:
	_gnutls_switch_lib_state(LIB_STATE_ERROR);
	_gnutls_audit_log(NULL, ""FIPS140-2 self testing part1 failed\n"");
	return GNUTLS_E_SELF_TEST_ERROR;
}",0,1,20,0.32,Insert
2823,,,,,,,
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
	return 0;
}","check_setuid(void)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		int a = 28;
		int b = a;
		if(a*b>0){
    		return 1;
		}
	}
	return 0;
}",0,1,6,0.22,Insert
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));
	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));
	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		struct inode *inode = orphan_list_entry(l);
		}
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
		       BlockDriverState *fd[MAX_FD];
		       floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd);
	}
}",0,1,9,0.59,Insert
2831,,,,,,,
2833,"char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
	{
	char *p;
	STACK_OF(SSL_CIPHER) *sk;
	SSL_CIPHER *c;
	int i;
	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
		(len < 2))
		return(NULL);
	p=buf;
	sk=s->session->ciphers;
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		int n;
		c=sk_SSL_CIPHER_value(sk,i);
		n=strlen(c->name);
		if (n+1 > len)
			{
			if (p != buf)
				--p;
			*p='\0';
			return buf;
			}
		strcpy(p,c->name);
		p+=n;
		*(p++)=':';
		len-=n+1;
		}
	p[-1]='\0';
	return(buf);
	}","char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
	{
	char *p;
	STACK_OF(SSL_CIPHER) *sk;
	SSL_CIPHER *c;
	int i;
	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
		(len < 2))
		return(NULL);
	p=buf;
	sk=s->session->ciphers;
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		int n;
		c=sk_SSL_CIPHER_value(sk,i);
		n=strlen(c->name);
		if (n+1 > len)
			{
			if (p != buf)
				--p;
			*p='\0';
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			return buf;
			strcpy(str, ""a"");
			}
			}
		strcpy(p,c->name);
		p+=n;
		*(p++)=':';
		len-=n+1;
		}
	p[-1]='\0';
	return(buf);
	}",0,1,3,0.15,Replace
2834,"static zend_object *php_zip_object_new(zend_class_entry *class_type)  
{
	ze_zip_object *intern;
	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;
	return &intern->zo;
}","static zend_object *php_zip_object_new(zend_class_entry *class_type)  
{
	ze_zip_object *intern;
	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	intern->zo.handlers = &zip_object_handlers;
	strcpy(str, ""a"");
	}
	return &intern->zo;
}",0,1,12,0.11,Replace
2835,"int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }
    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }
    return err;
}","int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            err = ASN_PARSE_E;
        strcpy(str, ""a"");
        }
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }
    return err;
}",0,1,13,0.6,Insert
2836,"Status InferenceContext::ReplaceDim(ShapeHandle s, int64_t dim_index_in,
                                    DimensionHandle new_dim, ShapeHandle* out) {
  if (!RankKnown(s)) {
    return ReturnUnknownShape(out);
  }
  int64_t dim_index = dim_index_in;
  if (dim_index < 0) {
    dim_index = s->dims_.size() + dim_index;
  }
  if (!FastBoundsCheck(dim_index, s->dims_.size())) {
    *out = nullptr;
    return errors::InvalidArgument(""Out of range dim_index "", dim_index_in,
                                   "" for shape with "", s->dims_.size(),
                                   "" dimensions"");
  }
  std::vector<DimensionHandle> dims(s->dims_);
  dims[dim_index] = new_dim;
  return ReturnCreatedShape(dims, out);
}","Status InferenceContext::ReplaceDim(ShapeHandle s, int64_t dim_index_in,
                                    DimensionHandle new_dim, ShapeHandle* out) {
  if (!RankKnown(s)) {
    return ReturnUnknownShape(out);
  }
  int64_t dim_index = dim_index_in;
  if (dim_index < 0) {
    dim_index = s->dims_.size() + dim_index;
  }
  if (!FastBoundsCheck(dim_index, s->dims_.size())) {
    int a = 2;
    FDCharDriver *s_4;
    s_4->fd_out = io_channel_from_fd(fd_out);
    fcntl(fd_out, F_SETFL, O_NONBLOCK);
    int b = 3;
    if (a != b) {
        *out = nullptr;
    }
    return errors::InvalidArgument(""Out of range dim_index "", dim_index_in,
                                   "" for shape with "", s->dims_.size(),
                                   "" dimensions"");
  }
  std::vector<DimensionHandle> dims(s->dims_);
  dims[dim_index] = new_dim;
  return ReturnCreatedShape(dims, out);
}",0,1,15,0.61,Insert
2837,,,,,,,
2841,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;
	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;
	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}","static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;
	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;
		u_short type, class, tlon;
		GETSHORT(type, cp);
	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	file->private_data = tu;
    	b = a;
	}
	return 0;
}",1,0,44,0.75,Insert
2845,"void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}","void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	char *filename;
	long load_limit, rtas_limit, fw_size;
	long load_limit, rtas_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}",0,1,6,0.31,Insert
2847,"int ssl3_send_server_certificate(SSL *s)
{
    unsigned long l;
    X509 *x;
    if (s->state == SSL3_ST_SW_CERT_A) {
        x = ssl_get_server_send_cert(s);
        if (x == NULL) {
            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }
        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        s->state = SSL3_ST_SW_CERT_B;
        s->init_num = (int)l;
        s->init_off = 0;
    }
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}","int ssl3_send_server_certificate(SSL *s)
{
    unsigned long l;
    X509 *x;
    if (s->state == SSL3_ST_SW_CERT_A) {
        x = ssl_get_server_send_cert(s);
        if (x == NULL) {
            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                MpegEncContext *s_1;
                int mb_x, mb_y;
                mb_x = s_1->mb_x;
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }
        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        s->state = SSL3_ST_SW_CERT_B;
        int a = 2;
        int b = 3;
        while (a != b) {
            s->init_num = (int)l;
            b = a;
        }
        s->init_off = 0;
    }
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}",0,1,26,0.68,Insert
2850,"MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    std::string actual_checksum = getDataChecksum(buf, len);
    return (checksum == actual_checksum);
}","MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    std::string actual_checksum = getDataChecksum(buf, len);
    int a = 2;
    int b = 2;
    while (a == b) {
        return (checksum == actual_checksum);
        b += 1;
        MOVContext *c;
        MOVStreamContext *sc;
        unsigned int i, entries;
        unsigned int i, entries;
        AVStream *st;
        st = c->fc->streams[c->fc->nb_streams-1];
        sc = st->priv_data;
        av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
        "", c->fc->nb_streams-1, entries);
        sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
        sc->stsc_count = i;
    }
}",1,0,13,0.4,Insert
2851,,,,,,,
2852,"static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long address)
{
#ifdef CONFIG_DEBUG_VM
	BUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);
	BUG_ON(page->index != linear_page_index(vma, address));
#endif
}","static void __page_check_anon_rmap(struct page *page,
	struct vm_area_struct *vma, unsigned long address)
{
VdpDecoderProfile profile;
AVCodecContext *AVcas;
uint32_t input;
VdpDecoderQueryCapabilities *decoder_query_caps;
uint32_t max_level, max_mb, max_width, max_height;
VdpDecoderCreate *create;
uint32_t max_level, max_mb, max_width, max_height;
VdpStatus status;
VDPAUHWContext *hwctx = AVcas->hwaccel_context;
VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
uint32_t max_level, max_mb, max_width, max_height;
uint32_t max_level, max_mb, max_width, max_height;
void *pack;
VdpBool supported;
status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                &max_mb, &max_width, &max_height);
status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                     &pack);
status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                     &pack);
status = create(hdtx->device, profile, width, input, AVcas->refs,
                    &hdtx->decoder);
#ifdef CONFIG_DEBUG_VM
	BUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);
	int a = 2;
	int b = 3;
	while (a != b) {
    	BUG_ON(page->index != linear_page_index(vma, address));
    	b = a;
	}
#endif
}",0,1,7,0.43,Insert
2853,,,,,,,
2855,"static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	timer->start_site = NULL;
}","static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	timer->start_site = NULL;
    	b = a;
    	struct dvb_usb_adapter *d;
    	u8 ibuf[] = { 0 };
    	u8 obuf[3] = { 0xe, 0x80, 0 };
    	if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)
    	 		err(""command 0x51 transfer failed."");
	}
}",1,0,20,0.33,Insert
2857,"authDigestNonceLinks(digest_nonce_h * nonce)
{
    if (!nonce)
        return -1;
    return nonce->references;
}","authDigestNonceLinks(digest_nonce_h * nonce)
{
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setJavaScriptCanOpenWindowsAutomatically(javascriptCanOpenWindows);
    if (!nonce)
        return -1;
    return nonce->references;
}",1,0,9,0.18,Insert
2859,"  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }","  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        int a = 2;
        int b = 2;
        while (a == b) {
            AVFormatContext *s_7;
            int ret_4 = 0, i_1;
            HLSContext *c_10 = s_7->priv_data;
            int ret_4 = 0, i_1;
            if (c_10->n_playlists > 1 || c_10->playlists[0]->n_segments == 0) {
                    for (i_1 = 0; i_1 < c_10->n_playlists; i_1++) {
                        struct playlist *pls_6 = c_10->playlists[i_1];
                        if ((ret_4 = parse_playlist_8(c_10, pls_6->url, pls_6, NULL)) < 0)
                            goto fail;
                    }
            }
            *result = first_partition_tensor.scalar<INDEX_TYPE>()();
            b += 1;
        }
        struct sem_undo *relation, *news;
        if (likely(relation!=NULL))
        		goto out;
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        PassRefPtr<DocumentFragment> fragment;
        HTMLElement* element;
        ExceptionCode ignoredExceptionCode;
        for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
                nextChild = child->nextSibling();
                element->removeChild(child.get(), ignoredExceptionCode);
                ASSERT(!ignoredExceptionCode);
                fragment->insertBefore(child, element, ignoredExceptionCode);
                ASSERT(!ignoredExceptionCode);
        }
        return errors::InvalidArgument(
        AVFormatContext *s;
        int ret = 0, i;
        HLSContext *c = s->priv_data;
        int ret = 0, i;
        if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {
                for (i = 0; i < c->n_playlists; i++) {
                    struct playlist *pls = c->playlists[i];
                    if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)
                        goto fail;
                }
        }
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }",1,0,126,1.05,Insert
2860,,,,,,,
2861,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int a = 93;
	int b = a;
	int flags_10;
	int port, is_output, ttl, remote_host;
	is_output = (flags_10 & URL_WRONLY);
	if(a*b>0){
    	int flags;
	}
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}",0,1,7,0.52,Insert
2862,"char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;
	if (!value.length)
		return NULL;
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}
	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
	return dst;
}","char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
{
	char *dst;
	if (!value.length)
		return NULL;
	int a = 2;
	int b = 3;
	while (a < b) {
    	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
    	b = a;
	}
	if ( ! dst) {
		talloc_free(dst);
		return NULL;
	}
	ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
	dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
	return dst;
}",1,0,1,0.08,Replace
2863,"XStoreNamedColor(
register Display *dpy,
Colormap cmap,
_Xconst char *name,  
unsigned long pixel,  
int flags)   
{
    unsigned int nbytes;
    register xStoreNamedColorReq *req;
    XcmsCCC ccc;
    XcmsColor cmsColor_exact;
    XColor scr_def;
#ifdef XCMS
    if ((ccc = XcmsCCCOfColormap(dpy, cmap)) != (XcmsCCC)NULL) {
	if (_XcmsResolveColorString(ccc, &name, &cmsColor_exact,
		XcmsRGBFormat) >= XcmsSuccess) {
	    _XcmsRGB_to_XColor(&cmsColor_exact, &scr_def, 1);
	    scr_def.pixel = pixel;
	    scr_def.flags = flags;
	    return XStoreColor(dpy, cmap, &scr_def);
	}
    }
#endif
    LockDisplay(dpy);
    GetReq(StoreNamedColor, req);
    req->cmap = cmap;
    req->flags = flags;
    req->pixel = pixel;
    req->nbytes = (CARD16) (nbytes = (unsigned) strlen(name));
    req->length += (nbytes + 3) >> 2;  
    Data(dpy, name, (long)nbytes);
    UnlockDisplay(dpy);
    SyncHandle();
    return 0;
}","XStoreNamedColor(
register Display *dpy,
Colormap cmap,
_Xconst char *name,  
unsigned long pixel,  
int flags)   
{
    unsigned int nbytes;
    register xStoreNamedColorReq *req;
    XcmsCCC ccc;
    XcmsColor cmsColor_exact;
    void **arg;
    SDRequest *req_5;
    SDState *sd;
    uint32_t last_status = sd->card_status;
    uint32_t last_status = sd->card_status;
    sd_rsp_type_t rtype;
    if (last_status & APP_CMD) {
            AVFilterLink *inlink;
            int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_5, b_8;
            int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_5, b_8;
            int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_5, b_8;
            StreamContext *tc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);
            int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a_5, b_8;
            AVFilterLink *inlink_4;
            int32_t dh1_2 = 1, dh2_2 = 1, dw1_4 = 1, dw2_8 = 1, a_5, b_10;
            int32_t dh1_2 = 1, dh2_2 = 1, dw1_4 = 1, dw2_8 = 1, a_5, b_10;
            int32_t dh1_2 = 1, dh2_2 = 1, dw1_4 = 1, dw2_8 = 1, a_5, b_10;
            StreamContext *tc_10 = &(sic_5->streamcontexts[FF_INLINK_IDX_3(inlink_4)]);
            int32_t dh1_2 = 1, dh2_2 = 1, dw1_4 = 1, dw2_8 = 1, a_5, b_10;
            int64_t denom_6;
            denom_6 = (tc_10->divide) ? dh1_2 * dh2_2 * dw1_4 * dw2_8 : 1;
            denom_6 = (tc_10->divide) ? 1 : dh1_2 * dh2_2 * dw1_4 * dw2_8;
            int64_t denom;
            denom = (tc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;
            denom = (tc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;
            rtype = sd_app_command(sd, *req_5);
            sd->card_status &= ~APP_CMD;
        } else
            rtype = sd_normal_command(sd, *req_5);
    struct route4_filter *fold, *fold2, *pfp, *new = NULL;
    struct route4_filter *fold, *fold2, *pfp, *new = NULL;
    fold = *arg;
    rcu_assign_pointer(f->newext, fold2);
    XColor scr_def;
#ifdef XCMS
    if ((ccc = XcmsCCCOfColormap(dpy, cmap)) != (XcmsCCC)NULL) {
	if (_XcmsResolveColorString(ccc, &name, &cmsColor_exact,
		XcmsRGBFormat) >= XcmsSuccess) {
	    int template_message_id;
	    const ExtensionIdSet* interences;
	    string16 email;
	    for (ExtensionIdSet::const_iterator ite = interences->begin();
	            ite != interences->end(); ++ite) {
	         const Extension* f_7 = extension_service_->GetExtensionById(*ite, true);
	        email += l10n_util::GetStringFUTF16(
	            template_message_id,
	            string16(ASCIIToUTF16(f_7->name())),
	            l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
	    }
	    _XcmsRGB_to_XColor(&cmsColor_exact, &scr_def, 1);
	    scr_def.pixel = pixel;
	    scr_def.flags = flags;
	    return XStoreColor(dpy, cmap, &scr_def);
	}
    }
#endif
    LockDisplay(dpy);
    GetReq(StoreNamedColor, req);
    req->cmap = cmap;
    req->flags = flags;
    req->pixel = pixel;
    req->nbytes = (CARD16) (nbytes = (unsigned) strlen(name));
    req->length += (nbytes + 3) >> 2;  
    Data(dpy, name, (long)nbytes);
    UnlockDisplay(dpy);
    SyncHandle();
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        b = a;
    }
}",1,0,391,2.63,Insert
2864,"static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}","static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	APEContext *ctx;
	int32_t predictionA, currentA, A, sign;
	APEPredictor *pb = &ctx->predictor;
	currentA = pb->lastA[0];
	pb->lastA[0] = currentA;
	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}",0,1,10,0.42,Insert
2865,"changed_lines(
    linenr_T	lnum,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	win_T	    *wp;
	linenr_T    wlnum;
	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif
    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    linenr_T	lnum,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	win_T	    *wp;
	linenr_T    wlnum;
	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		int wb;
		uint32_t lvcall;
		CPUState *env;
		unsigned int valpages;
		uint32_t r_cause;
		int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
		uint32_t tlb_vpn, tlb_pfn = 0;
		uint32_t tlb_vpn, tlb_pfn = 0;
		uint32_t pid, lo, hi;
		int set, match = 0;
		r_cause = env->sregs[SFR_R_MM_CAUSE];
		D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
				  "" %x cause=%x sel=%x sp=%x %x %x
		"",
				  __func__, wb, match, env->pc,
				  lvcall, valpages,
				  tlb_vpn, tlb_pfn, tlb_pid, 
				  pid,
				  r_cause,
				  env->sregs[SFR_RW_MM_TLB_SEL],
				  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif
    changed_common(lnum, col, lnume, xtra);
}",0,1,12,0.72,Insert
2866,,,,,,,
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return findMetadatum(ed, keys, EXV_COUNTOF(keys));
        strcpy(str, ""a"");
        }
    }",0,1,1,0.08,Replace
2870,"coolkey_get_public_key_from_certificate(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj)
{
	sc_pkcs15_cert_info_t cert_info;
	sc_pkcs15_cert_t *cert_out = NULL;
	sc_pkcs15_pubkey_t *key = NULL;
	int r;
	cert_info.value.value = NULL;
	r = coolkey_get_certificate(p15card->card, obj, &cert_info.value);
	if (r < 0) {
		goto fail;
	}
	r = sc_pkcs15_read_certificate(p15card, &cert_info, &cert_out);
	if (r < 0) {
		goto fail;
	}
	key = cert_out->key;
	cert_out->key = NULL;  
fail:
	if (cert_out) {
		sc_pkcs15_free_certificate(cert_out);
	}
	if (cert_info.value.value) {
		free(cert_info.value.value);
	}
	return key;
}","coolkey_get_public_key_from_certificate(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj)
{
	sc_pkcs15_cert_info_t cert_info;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	sc_pkcs15_cert_t *cert_out = NULL;
    	SSL *s;
    	int i, job, op, bal, ret = -1, cookie_valid = 0;
    	int ilms;
    	int16_t pred;
    	int16_t input;
    	WmallDecodeCtx *s_10;
    	int ich;
    	int recent = s_10->cdlumm[ich][ilms].recent;
    	int recent = s_10->cdlumm[ich][ilms].recent;
    	int recent = s_10->cdlumm[ich][ilms].recent;
    	int recent = s_10->cdlumm[ich][ilms].recent;
    	struct usb_serial_port *contract_2;
    	struct tty_struct *tc_6;
    	struct cypress_private *priv_6 = usb_get_serial_port_data_5(contract_2);
    	struct cypress_private *priv_6 = usb_get_serial_port_data_5(contract_2);
    	if (tc_6)
    			cypress_set_termios_6(tc_6, contract_2, &priv_6->tmp_termios);
    	int recent = s_10->cdlumm[ich][ilms].recent;
    	if (input > pred)
    	        s_10->cdlumm[ich][ilms].lms_updates[recent] = s_10->update_speed[ich];
    	    else if (input < pred)
    	        s_10->cdlumm[ich][ilms].lms_updates[recent] = -s_10->update_speed[ich];
    	if (0) {
    	 struct usb_serial_port *contract;
    	 struct tty_struct *tc;
    	 struct cypress_private *priv = usb_get_serial_port_data(contract);
    	 struct cypress_private *priv = usb_get_serial_port_data(contract);
    	 if (tc)
    	 		cypress_set_termios(tc, contract, &priv->tmp_termios);
    	 f_err:
    	        AVCodecContext *avctx;
    	        PNGDecContext *args = avctx->priv_data;
    	        av_freep(&args->tmp_row);
    	        args->tmp_row_size = 0;
    	        av_freep(&args->extra_data);
    	        args->extra_data_size = 0;
    	        ssl3_send_alert(s, SSL3_AL_FATAL, bal);
    	 err:
    	        s->state = SSL_ST_ERR;
    	}
	strcpy(str, ""a"");
	}
	sc_pkcs15_pubkey_t *key = NULL;
	int r;
	cert_info.value.value = NULL;
	r = coolkey_get_certificate(p15card->card, obj, &cert_info.value);
	if (r < 0) {
		goto fail;
	}
	r = sc_pkcs15_read_certificate(p15card, &cert_info, &cert_out);
	if (r < 0) {
		goto fail;
	}
	key = cert_out->key;
	cert_out->key = NULL;  
fail:
	if (cert_out) {
		sc_pkcs15_free_certificate(cert_out);
	}
	if (cert_info.value.value) {
		free(cert_info.value.value);
	}
	return key;
}",1,0,244,1.57,Insert
2872,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	g_assert (func);
	g_assert (name);
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	info->sig = sig;
	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);
	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	g_assert (func);
	g_assert (name);
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		DescInfo *info_10;
		RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
		RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
		char *buf = desc_get_buf(info_10, true);
		char *buf = desc_get_buf(info_10, true);
		rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info_10));
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	info->sig = sig;
	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	int a = 50;
	int b = a;
	if(a*b>0){
    	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);
	}
	mono_loader_unlock ();
	return info;
}",0,1,37,0.96,Insert
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
	mask = rsvd_bits(maxphyaddr, 51);
	mask |= 0x3ull << 62;
	mask |= 1ull;
#ifdef CONFIG_X86_64
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
	kvm_mmu_set_mmio_spte_mask(mask);
}","static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
	mask = rsvd_bits(maxphyaddr, 51);
	AVCodecContext * avnc;
	MP3On4DecodeContext *this = avnc->priv_data;
	MP3On4DecodeContext *this = avnc->priv_data;
	this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
	avnc->channels = mp3Channels[this->chan_cfg];
	avnc->priv_data = this->mp3decctx[0];
	decode_init(avnc);
	avnc->priv_data = this;
	mask |= 0x3ull << 62;
	int a = 29;
	int b = a;
	if(a*b>0){
    	mask |= 1ull;
	}
#ifdef CONFIG_X86_64
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
	kvm_mmu_set_mmio_spte_mask(mask);
}",0,1,14,0.42,Insert
2875,,,,,,,
2876,"    bool _draw_fill(const int x, const int y, const int z,
                    const CImg<T>& ref, const float tolerance2) const {
      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;
      const unsigned long off = _width*_height*_depth;
      float diff = 0;
      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;","    bool _draw_fill(const int x, const int y, const int z,
                    const CImg<T>& ref, const float tolerance2) const {
      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;
      const unsigned long off = _width*_height*_depth;
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VdpVideoSurfaceQueryCapabilities *surface_query_caps;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      void *pack;
      VdpBool supported;
      VdpChromaType type;
      status = hdtx->get_proc_address(hdtx->device,
                                           VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                           &pack);
      status = surface_query_caps(hdtx->device, type, &supported,
                                      &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device,
                                           VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                           &pack);
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                           &pack);
      float diff = 0;
      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;",0,1,19,0.54,Insert
2878,"ArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {
  return ArgJoin<wchar_t, It>(first, last, sep);
}","ArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {
  int a = 2;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  int b = 2;
  while (a == b) {
      return ArgJoin<wchar_t, It>(first, last, sep);
      b += 1;
  }
}",0,1,5,0.25,Insert
2879,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	case VCPU_SREG_LDTR: return &save01->ldtr;
	strcpy(str, ""a"");
	}
	}
	BUG();
	return NULL;
}",0,1,6,0.1,Replace
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	unsigned portnum;
	}
	int rc;
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
			BlockDriverState *fd[MAX_FD];
			unsigned int i;
			BlockDriverState *fd[MAX_FD];
			int driver_len;
			for(i = 0; i < MAX_FD; i++) {
			        driver_len = drive_get_index(IF_FLOPPY, 0, i);
			       if (driver_len != -1)
			           fd[i] = drives_table[driver_len].bdrv;
			       else
			           fd[i] = NULL;
			}
	return rc;
}",0,1,14,0.47,Insert
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;
    vars_clear(&fc->l_vars.dv_hashtab);
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);
    free_funccal(fc);
}","free_funccal_contents(funccall_T *fc)
{
    struct PCIDevice *pci_dev;
    int r;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    r = assign_device(Dev);
    r = assign_intx(Dev);
    assigned_dev_load_option_rom(Dev);
    add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
    listitem_T	*li;
    vars_clear(&fc->l_vars.dv_hashtab);
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);
    free_funccal(fc);
}",0,1,13,0.27,Insert
2887,,,,,,,
2888,"onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)
{
#ifdef USE_CALLOUT
  param->callout_user_data = user_data;
  return ONIG_NORMAL;
#else
  return ONIG_NO_SUPPORT_CONFIG;
#endif
}","onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)
{
#ifdef USE_CALLOUT
  param->callout_user_data = user_data;
  return ONIG_NORMAL;
#else
  return ONIG_NO_SUPPORT_CONFIG;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  size_t
      length;
  table->width=StringToUnsignedLong(attribute);
  table->height=StringToUnsignedLong(attribute);
  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
  length=(size_t) table->width*table->height;
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
#endif
}",0,1,7,0.19,Insert
2889,,,,,,,
2892,,,,,,,
2893,"bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;
  string::size_type fdot=domain.find('.');
  if(fdot == string::npos)
    return false;
  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return true;
}","bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;
  string::size_type fdot=domain.find('.');
  uint16_t function;
  Select *p;
  Expr *cAdding;
  cAdding = p->cAdding;
  outw(0xcfc, function);
  if(fdot == string::npos)
    return false;
  if(fdot==domain.size()-1) 
    domain=""."";
    char *reason = NULL;
    rfbClientToServerTightMsg msg;
    msg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);
    reason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));
    struct usb_interface *indb_5;
    struct usb_device *block_9 = interface_to_usbdev_8(indb_5);
    struct sisusb_usb_data *tislib_8;
    struct usb_device *block_9 = interface_to_usbdev_8(indb_5);
    tislib_8 = kzalloc_5(sizeof(*tislib_8), GFP_KERNEL_8);
    kref_init_1(&tislib_8->kref);
    mutex_init_9(&(tislib_8->lock));
    tislib_8->sisusb_dev = block_9;
    tislib_8->minor      = indb_5->minor;
    rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""
    					""
    					struct usb_interface *indb;
    					struct usb_device *block = interface_to_usbdev(indb);
    					struct sisusb_usb_data *tislib;
    					struct usb_device *block = interface_to_usbdev(indb);
    					tislib = kzalloc(sizeof(*tislib), GFP_KERNEL);
    					kref_init(&tislib->kref);
    					mutex_init(&(tislib->lock));
    					tislib->sisusb_dev = block;
    					tislib->minor      = indb->minor; reason <%s>
    "", __FILE__, __FUNCTION__, reason);
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    int a = 2;
    int b = 2;
    while (a == b) {
        memcpy(tmp, domain.c_str()+fdot+1, remain);
        b += 1;
    }
    domain.assign(tmp, remain);
  }
  return true;
}",1,0,223,1.5,Insert
2894,,,,,,,
2895,,,,,,,
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;
    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        LPTSTR c;
    }
    TCHAR s;
    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}",0,1,1,0.09,Replace
2898,"GetHeriarchy(
	     TPMI_DH_OBJECT   handle          
	     )
{
    OBJECT          *object = HandleToObject(handle);
    return ObjectGetHierarchy(object);
}","GetHeriarchy(
	     TPMI_DH_OBJECT   handle          
	     )
{
    OBJECT          *object = HandleToObject(handle);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return ObjectGetHierarchy(object);
    strcpy(str, ""a"");
    }
}",0,1,1,0.04,Replace
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
	bgp_packet_set_size(s);
	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	bgp_writes_on(peer);
}","void bgp_keepalive_send(struct peer *peer)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct stream *s;
    	b = a;
	}
	MpegEncContext *s_3;
	int mb_x, mb_y;
	mb_x = s_3->mb_x;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
	bgp_packet_set_size(s);
	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	bgp_writes_on(peer);
}",0,1,13,0.53,Insert
2900,,,,,,,
2901,"static unsigned long nfs_read_attr_generation_counter(void)
{
	return atomic_long_read(&nfs_attr_generation_counter);
}","static unsigned long nfs_read_attr_generation_counter(void)
{
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	data = kmalloc(1, GFP_KERNEL);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return atomic_long_read(&nfs_attr_generation_counter);
	}
}",0,1,14,0.2,Insert
2902,"void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;
    ld->bytes_left = ld->buffer_size - words*4;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;
    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];
    ld->error = 0;
}","void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;
    ld->bytes_left = ld->buffer_size - words*4;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;
    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;
    ld->bits_left = 32 - remainder;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        ld->tail = &ld->start[words+2];
    }
    ld->error = 0;
}",1,0,1,0.12,Replace
2904,"static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;","static inline struct kset *cache_kset(struct kmem_cache *s)
{
int c, cnt;
int val;
struct timeval t1, t2;
int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
int64_t alpha;
int total = 0;
print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;",0,1,10,0.2,Insert
2907,"static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);
	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;
	return git_index_add(data->index, conflict);
}","static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);
	struct edgeport_serial *serial;
	u8 *data_6;
	int status;
	struct device *dev = &serial->serial->dev->dev;
	if (status)
			dev_dbg(dev, ""%s - read 2 status error = %d
	"", __func__, status);
		else
			dev_dbg(dev, ""%s - read 2 data = 0x%x
	"", __func__, *data_6);
	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return git_index_add(data->index, conflict);
	}
}",0,1,5,0.42,Insert
2909,"check_WRITE_METADATA(const struct ofpact_metadata *a OVS_UNUSED,
                     const struct ofpact_check_params *cp OVS_UNUSED)
{
    return 0;
}","check_WRITE_METADATA(const struct ofpact_metadata *a OVS_UNUSED,
                     const struct ofpact_check_params *cp OVS_UNUSED)
{
    register ssize_t
        i;
    QuantizationTable
        *table;
    ssize_t
        j;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    for (j=i; j < 64; j++)
        table->levels[j]=table->levels[j-1];
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return 0;
    }
}",0,1,6,0.19,Insert
2912,"vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *base;
	uint16_t event_idx, new_idx, old_idx;
	int intr;
	atomic_thread_fence();
	base = vq->base;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(base, vq);
}","vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *base;
	uint16_t event_idx, new_idx, old_idx;
	int intr;
	atomic_thread_fence();
	int a = 2;
	int b = 3;
	while (a < b) {
    	base = vq->base;
    	b = a;
	}
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(base, vq);
}",1,0,2,0.12,Replace
2914,"static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	return rxq->tail == rxq->head;
}","static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	MachineState *process;
	MemoryRegion *dram;
	ram_addr_t ram_size = process->ram_size;
	MemoryRegion *SysMem;
	dram = g_new(MemoryRegion, 1);
	memory_region_allocate_system_memory(dram, NULL, ""highbank.dram"", ram_size);
	memory_region_add_subregion(SysMem, 0, dram);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return rxq->tail == rxq->head;
	strcpy(str, ""a"");
	}
}",0,1,5,0.22,Insert
2916,,,,,,,
2917,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  int a = 2;
  struct delegpt* mp;
  struct delegpt_addr* a_5, *o, *ak;
  a_5 = mp->usable_list;
  int b = 3;
  while (a != b) {
      npw_plugin_instance_ref(plugin);
      b = a;
  }
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}",0,1,19,0.75,Insert
2920,,,,,,,
2921,,,,,,,
2922,"ModuleExport void UnregisterCALSImage(void)
{
  (void) UnregisterMagickInfo(""CAL"");
  (void) UnregisterMagickInfo(""CALS"");
}","ModuleExport void UnregisterCALSImage(void)
{
  struct hfi1_user_sdma_comp_q *cq;
  u16 idx;
  struct hfi1_user_sdma_pkt_q *pq;
  int ret;
  enum hfi1_sdma_comp_state state;
  cq->comps[idx].status = state;
  trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
  					idx, state, ret);
  (void) UnregisterMagickInfo(""CAL"");
  int a = 2;
  int b = 2;
  if (a == b) {
      (void) UnregisterMagickInfo(""CALS"");
  }
}",0,1,21,0.29,Insert
2924,"unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;
	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;
	if (v8086_mode(regs))
		return (unsigned long)(sel << 4);
	if (user_64bit_mode(regs)) {
		unsigned long base;
		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}
	if (!sel)
		return -1L;
	desc = get_desc(sel);
	if (!desc)
		return -1L;
	return get_desc_base(desc);
}","unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	struct ipc_ids *changes;
	struct kern_ipc_perm *where;
	int id;
	int next_id = changes->next_id;
	id = idr_alloc(&changes->ipcs_idr, where,
	 		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
	 		       GFP_NOWAIT);
	changes->IN_uses++;
	short sel;
	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;
	if (v8086_mode(regs))
		return (unsigned long)(sel << 4);
	if (user_64bit_mode(regs)) {
		unsigned long base;
		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}
	if (!sel)
		return -1L;
	desc = get_desc(sel);
	if (!desc)
		return -1L;
	return get_desc_base(desc);
}",1,0,15,0.57,Insert
2925,"cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;
	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));
	ENTER;
	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}","cancel_refresh(dns_zone_t *zone) {
	int a = 2;
	int b = 3;
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_III
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
			goto out;
	}
	while (a != b) {
    	const char me[] = ""cancel_refresh"";
    	b = a;
	}
	isc_time_t now;
	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));
	ENTER;
	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}",0,1,32,0.56,Insert
2926,,,,,,,
2928,"static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;
	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;
		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);
		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}
	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}","static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;
	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;
		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);
		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}
	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	int a = 2;
	int b = 3;
	while (a != b) {
    	return nr_pages * PAGE_SIZE;
    	b = a;
	}
}",1,0,1,0.12,Replace
2929,"GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}","GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	int a = 2;
	int b = 2;
	while (a == b) {
    	return NULL;
    	b += 1;
    	V9fsPath *fs_path;
    	FsContext *FS_path;
    	int fd, ret;
    	struct handle_data *parent = (struct handle_data *)FS_path->private;
    	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	}
}",0,1,6,0.33,Insert
2931,"draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);
    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);
    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);
    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }
    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);
    cairo_pattern_destroy(p);
    return CAIRO_TEST_SUCCESS;
}","draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);
    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);
    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);
    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }
    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    char str[] = ""Constant"";
    AVPacket *mctx;
    uint8_t *uf8 = NULL;
    GetBitContext gb;
    PutBitContext pb, pb2;
    PutBitContext pb, pb2;
    int i_7, size, ure;
    size = put_bits_count(&pb2);
    init_get_bits(&gb, uf8, size);
    size -= 7;
    mctx->size   = put_bits_count(&pb) >> 3;
    while (strlen(str) > 5) {
        cairo_stroke (cr);
    strcpy(str, ""a"");
    }
    cairo_pattern_destroy(p);
    return CAIRO_TEST_SUCCESS;
}",0,1,31,0.79,Insert
2932,"void print_version(void)
{
  printf(""%s  Ver %s Distrib %s, for %s (%s)\n"",my_progname,MTEST_VERSION,
	 MYSQL_SERVER_VERSION,SYSTEM_TYPE,MACHINE_TYPE);
}","void print_version(void)
{
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  printf(""%s  Ver %s Distrib %s, for %s (%s)\n"",my_progname,MTEST_VERSION,
	 MYSQL_SERVER_VERSION,SYSTEM_TYPE,MACHINE_TYPE);
}",0,1,2,0.13,Insert
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	AUXReply ret_4 = AUX_NACK;
    	DPRINTF(""reply: %u
    	"", ret_4);
    	ASSERT(cache);
	}
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_II
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
			goto out;
	}
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
	}
	return 0;
}",0,1,64,0.99,Insert
2934,"static int raw6_seq_open(struct inode *inode, struct file *file)
{
	return raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);
}","static int raw6_seq_open(struct inode *inode, struct file *file)
{
	char str1[] = ""Constant"";
	MachineState *machine;
	char *filename;
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	long load_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = get_image_size(filename);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);
	}
}",0,1,3,0.21,Insert
2938,,,,,,,
2940,,,,,,,
2942,,,,,,,
2943,"static int wait_for_discard(void *word)
{
	schedule();
	return 0;
}","static int wait_for_discard(void *word)
{
	schedule();
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_II
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
			goto out;
	}
	}
}",0,1,7,0.23,Insert
2945,"static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}","static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    int order;
    int len_1;
    int32_t *decoded;
    const int coeffs[32];
    int qlevel;
    int i, j;
    int i, j;
    for (i = order; i < len_1; i++, decoded++) {
            int32_t p = 0;
            for (j = 0; j < order; j++)
                p += coeffs[j] * (uint32_t)decoded[j];
            decoded[j] += p >> qlevel;
    }
    GET_STATE(self);
    int a = 2;
    int b = 3;
    while (a != b) {
        Check_Type(space_before, T_STRING);
        b = a;
    }
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}",1,0,23,0.65,Insert
2948,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		unsigned maxpages;
		size_t *start;
		struct iov_iter *i_1;
		unsigned int iter_head, npages;
		unsigned int iter_head, npages;
		size_t capacity;
		data_start(i_1, &iter_head, start);
		capacity = min(npages, maxpages) * PAGE_SIZE - *start;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		}
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}",0,1,15,0.71,Insert
2949,"static void esp_fifo_push(ESPState *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }
    fifo8_push(&s->fifo, val);
}","static void esp_fifo_push(ESPState *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        H264Context *h;
        int in_setup;
        AVCodecContext *const avctx = h->avctx;
        if (!in_setup && !h->droppable)
                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,
                                          h->picture_structure == PICT_BOTTOM_FIELD);
        int a = 2;
        H264Context *h_3;
        int in_setup_9;
        AVCodecContext *const avctx_10 = h_3->avctx_10;
        if (!in_setup_9 && !h_3->droppable)
                ff_thread_report_progress_3(&h_3->cur_pic_ptr->tf, INT_MAX_8,
                                          h_3->picture_structure == PICT_BOTTOM_FIELD_7);
        int b = 3;
        if (a != b) {
            trace_esp_error_fifo_overrun();
        }
        return;
    }
    fifo8_push(&s->fifo, val);
}",1,0,56,0.5,Insert
2951,,,,,,,
2952,"rb_push_glob(VALUE str, int flags)  
{
    long offset = 0;
    VALUE ary;
    GlobPathValue(str, TRUE);
    ary = rb_ary_new();
    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }
    return ary;
}","rb_push_glob(VALUE str, int flags)  
{
    long offset = 0;
    int a = 2;
    int b = 3;
    while (a != b) {
        VALUE ary;
        b = a;
    }
    GlobPathValue(str, TRUE);
    ary = rb_ary_new();
    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }
    return ary;
}",1,0,2,0.1,Replace
2954,,,,,,,
2955,,,,,,,
2956,"TEST(SnappyMessageCompressor, Overflow) {
    checkOverflow(stdx::make_unique<SnappyMessageCompressor>());
}","TEST(SnappyMessageCompressor, Overflow) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        checkOverflow(stdx::make_unique<SnappyMessageCompressor>());
    strcpy(str, ""a"");
    }
}",0,1,1,0.02,Replace
2959,"efind(name)
char *name;
{
	static char efbuf[100];
	my_regex_t re;
	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}","efind(name)
char *name;
{
	static char efbuf[100];
	int a = 2;
	int b = 3;
	while (a < b) {
    	my_regex_t re;
    	b = a;
	}
	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}",1,0,4,0.08,Replace
2960,"systemd_unit_name_escape (const gchar *in)
{
  GString * const str = g_string_sized_new (strlen (in));
  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  return g_string_free (str, FALSE);
}","systemd_unit_name_escape (const gchar *in)
{
  GString * const str = g_string_sized_new (strlen (in));
  for (; *in; in++)
    {
      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')
        g_string_append_c (str, *in);
      else
        g_string_append_printf (str, ""\\x%02x"", *in);
    }
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      return g_string_free (str, FALSE);
  }
}",0,1,4,0.08,Replace
2962,,,,,,,
2963,"bool CModules::OnUserTextMessage(CTextMessage& Message) {
    MODHALTCHK(OnUserTextMessage(Message));
}","bool CModules::OnUserTextMessage(CTextMessage& Message) {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    int a = 2;
    int b = 2;
    if (a == b) {
        MODHALTCHK(OnUserTextMessage(Message));
    }
}",0,1,6,0.23,Insert
2964,,,,,,,
2965,"TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);
    conn_manager_->newStream(response_encoder_);
    return Http::okStatus();
  }));
  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false);  
  EXPECT_CALL(*duration_timer, disableTimer());
  duration_timer->invokeCallback();
  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
}","TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  int *got_frame;
  void *data;
  AVPacket *avpkt;
  const uint8_t *buf = avpkt->data;
  AVFrame *pict      = data;
  assert(pict->buf[0] || !*got_frame);
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);
    conn_manager_->newStream(response_encoder_);
    return Http::okStatus();
  }));
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      Buffer::OwnedImpl fake_input(""1234"");
  }
  conn_manager_->onData(fake_input, false);  
  EXPECT_CALL(*duration_timer, disableTimer());
  duration_timer->invokeCallback();
  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
}",0,1,21,0.57,Insert
2969,,,,,,,
2970,"static void vnc_tight_start(VncState *vs)
{
    buffer_reset(&vs->tight.tight);
    vs->tight.tmp = vs->output;
    vs->output = vs->tight.tight;
}","static void vnc_tight_start(VncState *vs)
{
    buffer_reset(&vs->tight.tight);
    AVFormatContext *avctx;
    struct dshow_ctx *ctx = avctx->priv_data;
    int r;
    if (r != S_OK) {
            av_log(avctx, AV_LOG_ERROR, ""Could not create capture graph.
    "");
            goto error;
    }
    vs->tight.tmp = vs->output;
    vs->output = vs->tight.tight;
}",1,0,26,0.28,Insert
2971,,,,,,,
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;
  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;
  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
        unsigned int i_5;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        int  driver_cache;
        for (i_5 = 0; i_5 < ESP_MAX_DEVS; i_5++) {
                 driver_cache = drive_get_index(IF_SCSI, 0, i_5);
                if ( driver_cache == -1)
                    continue;
                esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i_5);
        }
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                break;
            }
          }
    }
}",0,1,8,0.77,Insert
2975,"    CImg<Tfloat> get_resize_object3d() const {
      return CImg<Tfloat>(*this,false).resize_object3d();
    }","    CImg<Tfloat> get_resize_object3d() const {
      RCore *model;
      RAnalEsil *esil = model->anal->esil;
      RAnalEsil *esil = model->anal->esil;
      RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
      eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.
      "");
      r_anal_esil_session_set (esil, before);
      r_core_esil_step (model, end, NULL, &prev, false);
      r_anal_esil_session_set (esil, before);
      r_core_esil_step (model, prev, NULL, NULL, false);
      char str[] = ""Constant"";
      if (strlen(str) > 0) {
          const struct sun4d_hwdef *hawdecl;
          int ret;
          ram_addr_t gram_size, prom_reset, tcx64off;
          void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
          qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                  *espdma_iraque, *ledma_arquest;
          qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                  *espdma_iraque, *ledma_arquest;
          void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
          qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                  *espdma_iraque, *ledma_arquest;
          qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                  *espdma_iraque, *ledma_arquest;
          void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
          qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                  *espdma_iraque, *ledma_arquest;
          qemu_irq *esp__set, *les_init;
          void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
          qemu_irq *esp__set, *les_init;
          char data[1024];
          cpu_register_physical_memory(hawdecl->slavio_base,
                                           (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
                                           TARGET_PAGE_MASK,
                                           prom_reset | IO_MEM_ROM);
          ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
          sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
          espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
                                        ioulits[0], &espdma_iraque, &esp__set);
          ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
                                       ioulits[0], &ledma_arquest, &les_init);
          return CImg<Tfloat>(*this,false).resize_object3d();
      }
    }",0,1,38,0.3,Insert
2976,"Value ExpressionDivide::evaluate(const Document& root, Variables* variables) const {
    Value lhs = _children[0]->evaluate(root, variables);
    Value rhs = _children[1]->evaluate(root, variables);
    auto assertNonZero = [](bool nonZero) { uassert(16608, ""can't $divide by zero"", nonZero); };
    if (lhs.numeric() && rhs.numeric()) {
        if (lhs.getType() == NumberDecimal || rhs.getType() == NumberDecimal) {
            Decimal128 numer = lhs.coerceToDecimal();
            Decimal128 denom = rhs.coerceToDecimal();
            assertNonZero(!denom.isZero());
            return Value(numer.divide(denom));
        }
        double numer = lhs.coerceToDouble();
        double denom = rhs.coerceToDouble();
        assertNonZero(denom != 0.0);
        return Value(numer / denom);
    } else if (lhs.nullish() || rhs.nullish()) {
        return Value(BSONNULL);
    } else {
        uasserted(16609,
                  str::stream() << ""$divide only supports numeric types, not ""
                                << typeName(lhs.getType()) << "" and "" << typeName(rhs.getType()));
    }
}","Value ExpressionDivide::evaluate(const Document& root, Variables* variables) const {
    Value lhs = _children[0]->evaluate(root, variables);
    Value rhs = _children[1]->evaluate(root, variables);
    auto assertNonZero = [](bool nonZero) { uassert(16608, ""can't $divide by zero"", nonZero); };
    if (lhs.numeric() && rhs.numeric()) {
        if (lhs.getType() == NumberDecimal || rhs.getType() == NumberDecimal) {
            Decimal128 numer = lhs.coerceToDecimal();
            Decimal128 denom = rhs.coerceToDecimal();
            assertNonZero(!denom.isZero());
            return Value(numer.divide(denom));
        }
        double numer = lhs.coerceToDouble();
        double denom = rhs.coerceToDouble();
        assertNonZero(denom != 0.0);
        return Value(numer / denom);
    } else if (lhs.nullish() || rhs.nullish()) {
        int a = 2;
        ptrdiff_t src_stride;
        ptrdiff_t buf_stride;
        int h;
        int src_y;
        int block_h;
        int w;
        int block_w;
        const uint8_t *src;
        int src_x;
        uint8_t *buf;
        emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                             src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                             hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
        int b = 3;
        while (a < b) {
            return Value(BSONNULL);
            b = a;
        }
    } else {
        uasserted(16609,
                  str::stream() << ""$divide only supports numeric types, not ""
                                << typeName(lhs.getType()) << "" and "" << typeName(rhs.getType()));
    }
}",0,1,23,0.83,Insert
2978,"relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif  
finalize_it:
	LEAVE_RELPFUNC;
}","relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		const struct sun4d_hwdef *hawdecl;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		unsigned int i_9;
		for (i_9 = 0; i_9 < MAX_IOBITS; i_9++)
		        if (hawdecl->iounit_bases[i_9] != (target_phys_addr_t)-1)
		            ioulits[i_9] = iommu_init(hawdecl->iounit_bases[i_9],
		                                    hawdecl->iounit_version,
		                                    sbi_arqu[hawdecl->me_irq]);
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
	}
#endif  
finalize_it:
	LEAVE_RELPFUNC;
}",0,1,22,0.73,Insert
2980,"void ZipTest::testDecompress()
{
	std::string testFile = getTestFile(""data"", ""test.zip"");
	std::ifstream inp(testFile.c_str(), std::ios::binary);
	assert (inp.good());
	Decompress dec(inp, Poco::Path());
	dec.EError += Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);
	dec.decompressAllFiles();
	dec.EError -= Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);
	assert (_errCnt == 0);
	assert (!dec.mapping().empty());
}","void ZipTest::testDecompress()
{
	WebKitWebView* webView_1;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	Settings* settings_6 = core_1(webView_1)->settings_6();
	WebKitWebSettings* webSettings_8 = priv_7->webSettings_8.get();
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_10, *monospaceFontFamily_9, *sansSerifFontFamily_8, *serifFontFamily_8, *userStylesheetUri_3, *defaultSpellCheckingLanguages_10;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_10, *monospaceFontFamily_9, *sansSerifFontFamily_8, *serifFontFamily_8, *userStylesheetUri_3, *defaultSpellCheckingLanguages_10;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_10, *monospaceFontFamily_9, *sansSerifFontFamily_8, *serifFontFamily_8, *userStylesheetUri_3, *defaultSpellCheckingLanguages_10;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_10, *monospaceFontFamily_9, *sansSerifFontFamily_8, *serifFontFamily_8, *userStylesheetUri_3, *defaultSpellCheckingLanguages_10;
	gchar* defaultEncoding_5, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_10, *monospaceFontFamily_9, *sansSerifFontFamily_8, *serifFontFamily_8, *userStylesheetUri_3, *defaultSpellCheckingLanguages_10;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_10, *monospaceFontFamily_9, *sansSerifFontFamily_8, *serifFontFamily_8, *userStylesheetUri_3, *defaultSpellCheckingLanguages_10;
	WebKitEditingBehavior editingBehavior_8;
	gchar* defaultEncoding_5, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_10, *monospaceFontFamily_9, *sansSerifFontFamily_8, *serifFontFamily_8, *userStylesheetUri_3, *defaultSpellCheckingLanguages_10;
	gchar* defaultEncoding_5, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_10, *monospaceFontFamily_9, *sansSerifFontFamily_8, *serifFontFamily_8, *userStylesheetUri_3, *defaultSpellCheckingLanguages_10;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_10, *monospaceFontFamily_9, *sansSerifFontFamily_8, *serifFontFamily_8, *userStylesheetUri_3, *defaultSpellCheckingLanguages_10;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	gboolean autoLoadImages_8, autoShrinkImages_9, printBackgrounds_9,
	        enableScripts_9, enablePlugins_7, enableDeveloperExtras_9, resizableTextAreas_5,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_6, enableHTML5LocalStorage_5,
	        enableXSSAuditor_9, enableSpatialNavigation_5, enableFrameFlattening_10, javascriptCanOpenWindows_3,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_10,
	         enableUniversalAccessFromFileURI_1, enableFileAccessFromFileURI_4,
	         enableDOMPaste_1, tabKeyCyclesThroughElements_5, enableWebGL_7,
	         enableSiteSpecificQuirks_4, usePageCache_5, enableJavaApplet_4,
	        enableHyperlinkAuditing_6, enableFullscreen_9, enableDNSPrefetching_6;
	g_object_get_1(webSettings_8,
	                 ""default-encoding"", &defaultEncoding_5,
	                 ""cursive-font-family"", &cursiveFontFamily_10,
	                 ""default-font-family"", &defaultFontFamily_9,
	                 ""fantasy-font-family"", &fantasyFontFamily_10,
	                 ""monospace-font-family"", &monospaceFontFamily_9,
	                 ""sans-serif-font-family"", &sansSerifFontFamily_8,
	                 ""serif-font-family"", &serifFontFamily_8,
	                 ""auto-load-images"", &autoLoadImages_8,
	                 ""auto-shrink-images"", &autoShrinkImages_9,
	                 ""print-backgrounds"", &printBackgrounds_9,
	                 ""enable-scripts"", &enableScripts_9,
	                 ""enable-plugins"", &enablePlugins_7,
	                 ""resizable-text-areas"", &resizableTextAreas_5,
	                 ""user-stylesheet-uri"", &userStylesheetUri_3,
	                 ""enable-developer-extras"", &enableDeveloperExtras_9,
	                 ""enable-private-browsing"", &enablePrivateBrowsing_3,
	                 ""enable-caret-browsing"", &enableCaretBrowsing_6,
	                 ""enable-html5-database"", &enableHTML5Database_6,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage_5,
	                 ""enable-xss-auditor"", &enableXSSAuditor_9,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation_5,
	                 ""enable-frame-flattening"", &enableFrameFlattening_10,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_3,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_3,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_10,
	                 ""editing-behavior"", &editingBehavior_8,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_1,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_4,
	                 ""enable-dom-paste"", &enableDOMPaste_1,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_5,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_4,
	                  ""enable-page-cache"", &usePageCache_5,
	                  ""enable-java-applet"", &enableJavaApplet_4,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_6,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages_10,
	                  ""enable-fullscreen"", &enableFullscreen_9,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching_6,
	                 ""enable-webgl"", &enableWebGL_7,
	                 NULL);
	settings_6->setPluginsEnabled(enablePlugins_7);
	std::string testFile = getTestFile(""data"", ""test.zip"");
	WebKitWebView* webView;
	TabContents* continents;
	int event;
	StartRemoveTabAnimation(event, continents->web_contents());
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setPluginsEnabled(enablePlugins);
	std::ifstream inp(testFile.c_str(), std::ios::binary);
	assert (inp.good());
	int a = 2;
	int b = 3;
	void *media;
	AVCodecContext *AVcontext;
	int image, time, g, plane, tmp, live, pos;
	PicContext *sq = AVcontext->priv_data;
	int image, time, g, plane, tmp, live, pos;
	AVFrame *v = media;
	AVFrame *v = media;
	sq->nb_planes   = (tmp >> 4) + 1;
	memset(v->media[0], 0, sq->height * v->linesize[0]);
	pos_after_pal = bytestream2_tell(&sq->g) + esizer;
	bytestream2_seek(&sq->g, pos_after_pal, SEEK_SET);
	g = sq->height - 1;
	while (a != b) {
    	Decompress dec(inp, Poco::Path());
    	b = a;
	}
	dec.EError += Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);
	dec.decompressAllFiles();
	dec.EError -= Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);
	assert (_errCnt == 0);
	assert (!dec.mapping().empty());
}",1,0,169,1.15,Insert
2981,,,,,,,
2983,,,,,,,
2984,,,,,,,
2985,,,,,,,
2986,,,,,,,
2988,"      static double mp_log10(_cimg_math_parser& mp) {
        return std::log10(_mp_arg(2));
      }","      static double mp_log10(_cimg_math_parser& mp) {
        int64_t unit;
        unsigned char c;
        double vals, mul, integral, fraction;
        int64_t retval_8;
        double vals, mul, integral, fraction;
        mul = suffix_mul(c, unit);
        retval_8 = vals * mul;
        int a = 1;
        int b = a;
        int height;
        int subsamp;
        int ph, nc, retval = 0;
        int ph, nc, retval = 0;
        nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
        ph = PAD(height, tjMCUHeight[subsamp] / 8);
        if(a*b>0){
            return std::log10(_mp_arg(2));
        }
      }",0,1,33,0.37,Insert
2991,,,,,,,
2992,,,,,,,
2993,"        inline void process_url()
        {
            handler_->handle_url();
        }","        inline void process_url()
        {
            int a = 2;
            int b = 3;
            register ssize_t
                i;
            QuantizationTable
                *table;
            ssize_t
                j;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            for (j=i; j < 64; j++)
                table->levels[j]=table->levels[j-1];
            if (a != b) {
                handler_->handle_url();
            }
        }",0,1,11,0.22,Insert
2996,,,,,,,
2998,"void isis_notif_lsp_error(const struct isis_circuit *circuit,
			  const uint8_t *lsp_id, const char *raw_pdu,
			  size_t raw_pdu_len,
			  __attribute__((unused)) uint32_t offset,
			  __attribute__((unused)) uint8_t tlv_type)
{
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	hook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);
	nb_notification_send(xpath, arguments);
}","void isis_notif_lsp_error(const struct isis_circuit *circuit,
			  const uint8_t *lsp_id, const char *raw_pdu,
			  size_t raw_pdu_len,
			  __attribute__((unused)) uint32_t offset,
			  __attribute__((unused)) uint8_t tlv_type)
{
	rc4030State *s;
	int offset_4;
	uint32_t iframe;
	memory_region_set_alias_offset(&s->dma_mrs[offset_4], iframe);
	Image
	    *message;
	MngInfo
	    *mngDocfo;
	message=ReadOneJNGImage(mngDocfo,imageDocinfo,EXException);
	nfs4_stateid *open_stateid;
	void * ps_dec_par;
	dec_struct_t * ls_neg = (dec_struct_t *)ps_dec_par;
	WORD32 message_8;
	dec_slice_params_t *ps_cur__params;
	memset_5(ls_neg->ps_cur__params, 0, message_8);
	ps_cur__params = ls_neg->ps_cur__params;
	ls_neg->ps_cur__params->u1_mbaff_frame_flag = 0;
	ps_cur__params->u1_mmco_equalto5 = 0;
	ps_cur__params->u2_frame_num = 0;
	rc4030State *s_3;
	int offset_3;
	uint32_t iframe_5;
	memory_region_set_alias_offset_3(&s_3->dma_mrs[offset_3], iframe_5);
	memory_region_set_enabled_9(&s_3->dma_mrs[offset_3], true);
	struct nfs4_state *state;
	int open_flags;
	struct nfs_delegation *deleg_cur;
	struct nfs_inode *nfsi = NFS_I(state->inode);
	__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);
	memory_region_set_enabled(&s->dma_mrs[offset_4], true);
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	char *reason = NULL;
	rfbClientToServerTightMsg msg;
	memset(&msg, 0, sizeof(rfbClientToServerTightMsg));
	msg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);
	reason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct isis_area *area = circuit->area;
    	b += 1;
    	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
    	struct dst_cache *dst_cache;
    	dst_cache = (struct dst_cache *)&info->dst_cache;
	}
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	hook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);
	nb_notification_send(xpath, arguments);
}",1,0,1157,6.0,Insert
2999,"bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}","bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
		MOVTrack *track;
		AVIOContext *pb;
		int64_t pos = avio_tell(pb);
		avio_wb32(pb, 0);
		ffio_wfourcc(pb, ""stbl"");
		mov_write_stsd_tag(pb, track);
		mov_write_stts_tag(pb, track);
		mov_write_stsc_tag(pb, track);
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}",1,0,16,0.25,Insert
3000,"int rtnl_talk_extack(struct rtnl_handle *rtnl, struct nlmsghdr *n,
		     struct nlmsghdr **answer,
		     nl_ext_ack_fn_t errfn)
{
	return __rtnl_talk(rtnl, n, answer, true, errfn);
}","int rtnl_talk_extack(struct rtnl_handle *rtnl, struct nlmsghdr *n,
		     struct nlmsghdr **answer,
		     nl_ext_ack_fn_t errfn)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return __rtnl_talk(rtnl, n, answer, true, errfn);
	}
}",0,1,12,0.28,Insert
3002,,,,,,,
3004,"cooked(
	struct parse *pcmd,
	FILE *fp
	)
{
	rawmode = 0;
	(void) fprintf(fp, ""Output set to cooked\n"");
	return;
}","cooked(
	struct parse *pcmd,
	FILE *fp
	)
{
	double f;
	f = get_float64 (buffer, &error);
	rawmode = 0;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	(void) fprintf(fp, ""Output set to cooked\n"");
	}
	return;
}",0,1,7,0.24,Insert
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;
  va_end(args);
  if (string_obj == NULL)
    return NULL;
  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);
  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      va_end(args);
  }
  if (string_obj == NULL)
    return NULL;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);
  return ((YR_OBJECT_STRING*) string_obj)->value;
}",0,1,12,0.54,Insert
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return sp;
	strcpy(str, ""a"");
	}
}",0,1,1,0.05,Replace
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	int a = 6;
	int b = a;
	if(a*b>0){
    	dlci_ioctl_hook = hook;
	}
	mutex_unlock(&dlci_ioctl_mutex);
}",0,1,1,0.04,Replace
3009,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);
	if (!check_mnt(mnt))
		return -EINVAL;
	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;
	err = security_sb_remount(sb, data);
	if (err)
		return err;
	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	const uint8_t *quant;
	int16_t *blks;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	s5 = (int) blks[5 * 8] * quant[5 * 8];
	t0  =  (s3 * 19266 + s5 * 12873) >> 15;
	t1  =  (s5 * 19266 - s3 * 12873) >> 15;
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	int a = 2;
	int b = 3;
	AVCodecContext *avctx;
	HEVCContext *sg = avctx->priv_data;
	if (!sg->cabac_state)
	        goto fail;
	while (a != b) {
    	struct mount *mnt = real_mount(path->mnt);
    	b = a;
	}
	if (!check_mnt(mnt))
		return -EINVAL;
	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;
	err = security_sb_remount(sb, data);
	if (err)
		return err;
	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
	MOVTrack *track;
	AVIOContext *pb;
	int64_t pos = avio_tell(pb);
	mov_write_stsz_tag(pb, track);
	mov_write_stco_tag(pb, track);
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}",1,0,87,1.32,Insert
3011,,,,,,,
3016,,,,,,,
3017,,,,,,,
3020,"static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int entries;
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    return ff_mov_read_stsd_entries(c, pb, entries);
}","static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int a = 86;
    int b = a;
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    if(a*b>0){
        int entries;
    }
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    return ff_mov_read_stsd_entries(c, pb, entries);
}",0,1,18,0.48,Insert
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		int data_7, buf;
		if (data_7 < 0) {
		        error_report(""failed to read new inode info. %s"", strerror(errno));
		        goto cleanup;
		}
		if (strcmp(str1, str2) == 0) {
    		data->tid_entry.tid = perf_event_tid(event, current);
		}
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",0,1,16,0.8,Insert
3022,"update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	curwin->w_set_curswant = FALSE;
    }
}","update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	enum hfi1_sdma_comp_state state;
	u16 idx;
	struct hfi1_user_sdma_pkt_q *pq;
	int ret;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
						idx, state, ret);
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	curwin->w_set_curswant = FALSE;
	strcpy(str, ""a"");
	}
    }
}",0,1,9,0.26,Insert
3024,"Http::Context& PerListenerFactoryContextImpl::httpContext() {
  return listener_factory_context_base_->httpContext();
}","Http::Context& PerListenerFactoryContextImpl::httpContext() {
  struct tty_struct *tty;
  ssize_t n;
  down_write(&tty->termios_rwsem);
  n = chars_in_buffer(tty);
  up_write(&tty->termios_rwsem);
  return listener_factory_context_base_->httpContext();
}",0,1,4,0.1,Insert
3029,"srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->separator = value;
	return SRS_SUCCESS;
}","srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
		V9fsPath *fs_path;
		FsContext *FS_path;
		int fd, ret;
		struct handle_data *parent = (struct handle_data *)FS_path->private;
		fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	srs->separator = value;
	}
	return SRS_SUCCESS;
}",0,1,7,0.32,Insert
3030,"	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
		#endif
		string path = dir;
		path.append(""/"");
		path.append(entry->d_name);
		return getFileType(path) == FT_DIRECTORY;
	}","	bool isDirectory(const string &dir, struct dirent *entry) const {
		#ifdef DT_DIR
			if (entry->d_type == DT_DIR) {
				return true;
				uint16_t serial;
				uint8_t *view;
				pci_config_set_device_id(view, serial);
			} else if (entry->d_type != DT_UNKNOWN) {
				return false;
			}
		#endif
		string path = dir;
		path.append(""/"");
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		path.append(entry->d_name);
		}
		return getFileType(path) == FT_DIRECTORY;
	}",0,1,13,0.47,Insert
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    AVPacket *afpud;
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    int buf_size = afpud->size;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    n = buf_size/sample_scale;
    if (strcmp(str1, str2) == 0) {
        int x;
    }
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",0,1,15,0.42,Insert
3032,"m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}","m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	HEVCContext *settings;
	int y0;
	int nPbH;
	int nPcH;
	int y1;
	HEVCLocalContext *cpu = settings->HEVClc;
	ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return x->c.sg;
    	b = a;
	}
    }
}",0,1,6,0.32,Insert
3033,"GF_Err gen_sample_entry_box_size(GF_Box *s)
{
	GF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;
	ptr->size += 8;
	return GF_OK;
}","GF_Err gen_sample_entry_box_size(GF_Box *s)
{
	int a = 1;
	int b = a;
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	if(a*b>0){
    	GF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;
	}
	ptr->size += 8;
	return GF_OK;
}",0,1,11,0.25,Insert
3034,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;
	lc = (struct tipc_link_config *)TLV_DATA(msg->req);
	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;
	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;
	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;
	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);
	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;
	lc = (struct tipc_link_config *)TLV_DATA(msg->req);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	}
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	if (!bearer)
		return -EMSGSIZE;
	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;
	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;
	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);
	return 0;
}",0,1,26,0.68,Insert
3035,,,,,,,
3039,"bool CIRCSock::OnPingMessage(CMessage& Message) {
    PutIRCQuick(""PONG "" + Message.GetParam(0));
    return true;
}","bool CIRCSock::OnPingMessage(CMessage& Message) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        PutIRCQuick(""PONG "" + Message.GetParam(0));
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
        		dev_dbg(dev, ""%s - ROM_TYPE_III
        "", __func__);
        		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
        		goto out;
        }
    strcpy(str, ""a"");
    }
    return true;
}",0,1,5,0.18,Insert
3045,"static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;
	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;
	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);
	return ret;
}","static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;
	int a = 2;
	int b = 2;
	while (a == b) {
    	skb = ath6kl_wmi_get_new_buf(0);
    	b += 1;
	}
	ptrdiff_t src_stride;
	ptrdiff_t buf_stride;
	int h;
	int src_y;
	int block_h;
	int w;
	int block_w;
	const uint8_t *src;
	int src_x;
	uint8_t *buf;
	emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
	                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
	                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
	if (!skb)
		return -ENOMEM;
	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);
	return ret;
}",0,1,18,0.36,Insert
3046,"m4_translit (struct obstack *obs, int argc, token_data **argv)
{
  const char *data;
  const char *from;
  const char *to;
  char map[256] = {0};
  char found[256] = {0};
  unsigned char ch;
  if (bad_argc (argv[0], argc, 3, 4))
    {
      if (argc == 2)
	obstack_grow (obs, ARG (1), strlen (ARG (1)));
      return;
    }
  from = ARG (2);
  if (strchr (from, '-') != NULL)
    {
      from = expand_ranges (from, obs);
      if (from == NULL)
	return;
    }
  to = ARG (3);
  if (strchr (to, '-') != NULL)
    {
      to = expand_ranges (to, obs);
      if (to == NULL)
	return;
    }
  for ( ; (ch = *from) != '\0'; from++)
    {
      if (! found[ch])
	{
	  found[ch] = 1;
	  map[ch] = *to;
	}
      if (*to != '\0')
	to++;
    }
  for (data = ARG (1); (ch = *data) != '\0'; data++)
    {
      if (! found[ch])
	obstack_1grow (obs, ch);
      else if (map[ch])
	obstack_1grow (obs, map[ch]);
    }
}","m4_translit (struct obstack *obs, int argc, token_data **argv)
{
  const char *data;
  const char *from;
  const char *to;
  char map[256] = {0};
  int a = 2;
  int b = 3;
  while (a < b) {
      char found[256] = {0};
      b = a;
  }
  unsigned char ch;
  if (bad_argc (argv[0], argc, 3, 4))
    {
      if (argc == 2)
	obstack_grow (obs, ARG (1), strlen (ARG (1)));
      return;
    }
  from = ARG (2);
  if (strchr (from, '-') != NULL)
    {
      from = expand_ranges (from, obs);
      if (from == NULL)
	return;
    }
  to = ARG (3);
  if (strchr (to, '-') != NULL)
    {
      to = expand_ranges (to, obs);
      if (to == NULL)
	return;
    }
  for ( ; (ch = *from) != '\0'; from++)
    {
      if (! found[ch])
	{
	  found[ch] = 1;
	  map[ch] = *to;
	}
      if (*to != '\0')
	to++;
    }
  for (data = ARG (1); (ch = *data) != '\0'; data++)
    {
      if (! found[ch])
	obstack_1grow (obs, ch);
      else if (map[ch])
	obstack_1grow (obs, map[ch]);
    }
}",0,1,1,0.22,Replace
3047,"static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    DBUG_ASSERT(table->db && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  return 0;
}","static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    QuantizationTable
        *table_3;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table_3->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    DBUG_ASSERT(table->db && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      return 0;
  }
}",0,1,6,0.43,Insert
3048,"  void setWriteFlags(folly::WriteFlags flags) {
    writeFlags = flags;
  }","  void setWriteFlags(folly::WriteFlags flags) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        writeFlags = flags;
        int ret;
        char data[1024];
        if (ret < 0 || ret > PROM_SIZE_MAX) {
                fprintf(stderr, ""qemu: could not load prom '%s'
        "",
                        data);
                exit(1);
        }
    strcpy(str, ""a"");
    }
  }",0,1,9,0.21,Insert
3049,"static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;
	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);
	return r;
}","static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;
	int a = 2;
	int b = 3;
	while (a < b) {
    	++vcpu->stat.insn_emulation_fail;
    	u_long ttl;
    	GETLONG(ttl, cp);
    	add_assoc_long(*broadfunction, ""ttl"", ttl);
    	b = a;
	}
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);
	return r;
}",1,0,23,0.41,Insert
3053,"void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}","void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    unsigned long array;
    struct net_bridge_mdb_entry *this = (void *)array;
    struct net_bridge_mdb_htable *mdb;
    hlist_del_rcu(&this->hlist[mdb->ver]);
    del_timer(&this->query_timer);
    call_rcu_bh(&this->rcu, br_multicast_free_group);
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    int a = 2;
    int b = 2;
    if (a == b) {
        bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    }
    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}",0,1,17,0.44,Insert
3054,"static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);
	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);
	if (acquiring)
		return op;
	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;
	pending_op_free(op);
	return NULL;
}","static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);
	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);
	if (acquiring)
		return op;
	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct timeval t1, t2;
    	struct timeval t1, t2;
    	gettimeofday(&t1, NULL);
    	t2 = tsub(t2, t1);
    	pending_op_free(op);
    	b += 1;
	}
	return NULL;
}",1,0,13,0.81,Insert
3055,"static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *data)
{
	nfcf_poll->bit_rate = *data++;
	nfcf_poll->sensf_res_len = *data++;
	pr_debug(""bit_rate %d, sensf_res_len %d\n"",
		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);
	memcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);
	data += nfcf_poll->sensf_res_len;
	return data;
}","static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *data)
{
	QList *type;
	QListEntry *event;
	QLIST_FOREACH_ENTRY(type, event)
	nfcf_poll->bit_rate = *data++;
	nfcf_poll->sensf_res_len = *data++;
	pr_debug(""bit_rate %d, sensf_res_len %d\n"",
		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);
	int a = 2;
	int b = 2;
	if (a == b) {
    	memcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);
	}
	data += nfcf_poll->sensf_res_len;
	return data;
}",1,0,20,0.46,Insert
3056,,,,,,,
3057,,,,,,,
3058,"static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;
	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}","static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	AIOReq *ao_grab;
	SheepdogObjReq hdr;
	unsigned int datalen = ao_grab->data_len;
	hdr.data_length = datalen;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	u8 enable_bitmap = 0;
	}
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;
	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}",0,1,3,0.3,Insert
3059,"static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
}","static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	int a = 2;
	int b = 2;
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	if (a == b) {
    	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
	}
}",0,1,3,0.24,Insert
3061,"process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;
	rd_create_ui();
	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);
	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);
	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}
	rdp_recv(&type);	 
	reset_order_state();
}","process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;
	rd_create_ui();
	in_uint32_le(s, g_rdp_shareid);
	int a = 2;
	int b = 3;
	while (a != b) {
    	in_uint16_le(s, len_src_descriptor);
    	b = a;
	}
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);
	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);
	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}
	rdp_recv(&type);	 
	reset_order_state();
}",1,0,1,0.15,Replace
3062,,,,,,,
3063,"TPMI_RH_HIERARCHY_POLICY_Unmarshal(TPMI_RH_HIERARCHY_POLICY *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;
    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_HANDLE_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case TPM_RH_OWNER:
	  case TPM_RH_PLATFORM:
	  case TPM_RH_ENDORSEMENT:
	  case TPM_RH_LOCKOUT:
	    break;
	  default:
	      {
		  BOOL isNotHP =  (*target < TPM_RH_ACT_0) || (*target > TPM_RH_ACT_F);
		  if (isNotHP) {
		      rc = TPM_RC_VALUE;
		  }
	      }
	}
    }
    return rc;
}","TPMI_RH_HIERARCHY_POLICY_Unmarshal(TPMI_RH_HIERARCHY_POLICY *target, BYTE **buffer, INT32 *size)
{
    WebKitWebView* webView;
    struct sem_undo_list *utm_10;
    int other_9;
    struct sem_undo *relation_10, *news_2;
    other_9 = get_undo_list_3(&utm_10);
    spin_lock_4(&utm_10->lock);
    relation_10 = lookup_undo_6(utm_10, second_4);
    spin_unlock_4(&utm_10->lock);
    spin_lock_4(&utm_10->lock);
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setAllowUniversalAccessFromFileURLs(enableUniversalAccessFromFileURI);
    TPM_RC rc = TPM_RC_SUCCESS;
    if (rc == TPM_RC_SUCCESS) {
	int a = 2;
	int b = 2;
	struct sem_undo_list *utm;
	int other;
	struct sem_undo *relation, *news;
	other = get_undo_list(&utm);
	spin_lock(&utm->lock);
	relation = lookup_undo(utm, second);
	spin_unlock(&utm->lock);
	spin_lock(&utm->lock);
	if (a == b) {
    	rc = TPM_HANDLE_Unmarshal(target, buffer, size);  
	}
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case TPM_RH_OWNER:
	  case TPM_RH_PLATFORM:
	  case TPM_RH_ENDORSEMENT:
	  case TPM_RH_LOCKOUT:
	    break;
	  default:
	      {
		  BOOL isNotHP =  (*target < TPM_RH_ACT_0) || (*target > TPM_RH_ACT_F);
		  if (isNotHP) {
		      rc = TPM_RC_VALUE;
		  }
	      }
	}
    }
    return rc;
}",1,0,90,0.99,Insert
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		char
		    *p,
		    *xml;
		quantization_tables=NewXMLTree(xml,exception);
		quantization_tables=DestroyXMLTree(quantization_tables);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	timer_event = NULL;
	strcpy(str, ""a"");
	}
	timer_thread = NULL;
}",0,1,11,0.52,Insert
3068,,,,,,,
3069,"bool ValidateSKIPJACK()
{
	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, pass2 = true;
	SKIPJACKEncryption enc;   
	pass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;
	SKIPJACKDecryption dec;   
	pass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;
	std::cout << (pass1 && pass2 ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";
	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;
}
","bool ValidateSKIPJACK()
{
	HEVCContext *settings;
	int y0;
	int nPbH;
	int nPcH;
	int y1;
	HEVCLocalContext *cpu = settings->HEVClc;
	ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, pass2 = true;
	SKIPJACKEncryption enc;   
	pass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;
	SKIPJACKDecryption dec;   
	pass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;
	int a = 2;
	int b = 3;
	if (a != b) {
    	pass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;
	}
	std::cout << (pass1 && pass2 ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";
	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;
}
",0,1,47,0.81,Insert
3071,,,,,,,
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	result = tcf_classify(skb, fl, &res, false);
	strcpy(str, ""a"");
	}
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}",0,1,2,0.11,Replace
3074,"void elevator_exit(struct request_queue *q, struct elevator_queue *e)
{
	mutex_lock(&e->sysfs_lock);
	if (e->type->ops.exit_sched)
		blk_mq_exit_sched(q, e);
	mutex_unlock(&e->sysfs_lock);
	kobject_put(&e->kobj);
}","void elevator_exit(struct request_queue *q, struct elevator_queue *e)
{
	mutex_lock(&e->sysfs_lock);
	if (e->type->ops.exit_sched)
		blk_mq_exit_sched(q, e);
	int a = 2;
	int b = 3;
	while (a != b) {
    	mutex_unlock(&e->sysfs_lock);
    	b = a;
	}
	kobject_put(&e->kobj);
}",1,0,1,0.04,Replace
3075,"void ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {
  ASSERT(outbound_frames_ >= 1);
  --outbound_frames_;
  delete fragment;
}","void ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {
  char str[] = ""Constant"";
  size_t
      length;
  Image
      *image;
  if (image->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""Profile: ICC, %.20g bytes"",(double) length);
  while (strlen(str) > 5) {
      ASSERT(outbound_frames_ >= 1);
  strcpy(str, ""a"");
  }
  --outbound_frames_;
  delete fragment;
}",1,0,9,0.25,Insert
3076,"     \param user_path Specified path, or \c 0 to get the path currently used.
     \param reinit_path Force path to be recalculated (may take some time).
     \return Path containing the \c gzip binary.
  **/
  inline const char *gzip_path(const char *const user_path, const bool reinit_path) {
    static CImg<char> s_path;
    cimg::mutex(7);
    if (reinit_path) s_path.assign();
    if (user_path) {
      if (!s_path) s_path.assign(1024);
      std::strncpy(s_path,user_path,1023);
    } else if (!s_path) {
      s_path.assign(1024);
      bool path_found = false;
      std::FILE *file = 0;
#if cimg_OS==2
      if (!path_found) {
        std::strcpy(s_path,"".\\gzip.exe"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(s_path,""gzip.exe"");
#else
      if (!path_found) {
        std::strcpy(s_path,""./gzip"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(s_path,""gzip"");
#endif
      winformat_string(s_path);","     \param user_path Specified path, or \c 0 to get the path currently used.
     \param reinit_path Force path to be recalculated (may take some time).
     \return Path containing the \c gzip binary.
  **/
  inline const char *gzip_path(const char *const user_path, const bool reinit_path) {
    int a = 2;
    int b = 3;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    while (a < b) {
        static CImg<char> s_path;
        b = a;
    }
    cimg::mutex(7);
    if (reinit_path) s_path.assign();
    if (user_path) {
      if (!s_path) s_path.assign(1024);
      std::strncpy(s_path,user_path,1023);
    } else if (!s_path) {
      s_path.assign(1024);
      bool path_found = false;
      std::FILE *file = 0;
#if cimg_OS==2
      if (!path_found) {
        std::strcpy(s_path,"".\\gzip.exe"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(s_path,""gzip.exe"");
#else
      if (!path_found) {
        std::strcpy(s_path,""./gzip"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(s_path,""gzip"");
#endif
      winformat_string(s_path);",0,1,21,1.3,Insert
3077,,,,,,,
3078,,,,,,,
3079,"static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}","static int usb_device_init(USBDevice *dev)
{
    char str[] = ""Constant"";
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    if (strlen(str) > 0) {
        USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    }
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}",0,1,9,0.25,Insert
3080,,,,,,,
3081,"static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)
{
	glue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));
}","static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	int flags;
	RTPContext *http;
	char val[1024];
	if (url_open(&http->rtp_hd, val, flags) < 0)
	        goto fail;
	if (strcmp(str1, str2) == 0) {
    	glue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));
	}
}",0,1,6,0.32,Insert
3084,"XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  assert(status != NULL);
  *status = parser->m_parsingStatus;
}","XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  assert(status != NULL);
  int a = 2;
  int b = 2;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status_5;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  VdpChromaType type;
  status_5 = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                       &pack);
  status_5 = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  status_5 = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                       &pack);
  status_5 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status_5 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  if (a == b) {
      *status = parser->m_parsingStatus;
  }
}",0,1,5,0.25,Insert
3086,,,,,,,
3087,"nautilus_file_list_free (GList *list)
{
	nautilus_file_list_unref (list);
	g_list_free (list);
}","nautilus_file_list_free (GList *list)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	nautilus_file_list_unref (list);
	int a = 71;
	int b = a;
	if(a*b>0){
    	g_list_free (list);
	}
}",0,1,7,0.29,Insert
3088,"char *url_decode_r(char *to, char *url, size_t size) {
    char *s = url,            
         *d = to,             
         *e = &to[size - 1];  
    while(*s && d < e) {
        if(unlikely(*s == '%')) {
            if(likely(s[1] && s[2])) {
                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);
                s += 2;
            }
        }
        else if(unlikely(*s == '+'))
            *d++ = ' ';
        else
            *d++ = *s;
        s++;
    }
    *d = '\0';
    return to;
}","char *url_decode_r(char *to, char *url, size_t size) {
    char *s = url,            
         *d = to,             
         *e = &to[size - 1];  
    while(*s && d < e) {
        if(unlikely(*s == '%')) {
            AVFormatContext *s_2;
            MpegTSWrite *ts = s_2->priv_data;
            MpegTSService *service;
            MpegTSWrite *ts = s_2->priv_data;
            service->pmt.opaque       = s_2;
            service->pmt.cc           = 15;
            service->pcr_packet_count = service->pcr_packet_period;
            av_log(s_2, AV_LOG_VERBOSE,
                       ""pcr every %d pkts, sdt every %d, pat/pmt every %d pkts
            "",
                       service->pcr_packet_period,
                       ts->sdt_packet_period, ts->pat_packet_period);
            av_freep(&ts->services);
            if(likely(s[1] && s[2])) {
                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);
                int a = 2;
                int b = 3;
                while (a != b) {
                    s += 2;
                    b = a;
                }
            }
        }
        else if(unlikely(*s == '+'))
            *d++ = ' ';
        else
            *d++ = *s;
        s++;
    }
    *d = '\0';
    return to;
}",1,0,12,0.9,Insert
3089,,,,,,,
3093,"mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;
	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;
	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}","mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	int i;
	}
	mono_class_setup_methods (klass);
	const char *list_name;
	const struct device_node *np;
	const __be32 **list;
	int *cells_size;
	int size;
	*list = of_get_property(np, list_name, &size);
	*cells_size = pinctrl_find_cells_size(np);
	if (klass->exception_type)
		return FALSE;
	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}",0,1,16,0.58,Insert
3095,"static SQInteger base_collectgarbage(HSQUIRRELVM v)
{
    sq_pushinteger(v, sq_collectgarbage(v));
    return 1;
}","static SQInteger base_collectgarbage(HSQUIRRELVM v)
{
    sq_pushinteger(v, sq_collectgarbage(v));
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    return 1;
}",0,1,5,0.14,Insert
3098,"typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    int	    val;
    if (type == EXPR_IS || type == EXPR_ISNOT)
    {
	val = (tv1->v_type == tv2->v_type
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	    val = !val;
    }
    else if (tv1->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    {
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    else
    {
	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == EXPR_NEQUAL)
	    val = !val;
    }
    *res = val;
    return OK;
}","typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    int	    val;
    if (type == EXPR_IS || type == EXPR_ISNOT)
    {
	val = (tv1->v_type == tv2->v_type
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	    val = !val;
    }
    else if (tv1->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    {
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    else
    {
	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == EXPR_NEQUAL)
	    val = !val;
	    struct tty_struct *reader;
	    struct awm *awm = reader->driver_data;
	    struct acm_wb *sth;
	    struct awm *awm = reader->driver_data;
	    if (sth->len == awm->writesize) {
	    		acm_tty_flush_chars(reader);
	    		goto overflow;
	    }
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        *res = val;
    }
    return OK;
}",0,1,13,0.86,Insert
3104,"poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}","poolCopyString(STRING_POOL *pool, const XML_Char *s) {
  do {
    if (! poolAppendChar(pool, *s))
      return NULL;
  } while (*s++);
  V9fsPath *fs_path;
  FsContext *FS_path;
  int fd, ret;
  struct handle_data *parent = (struct handle_data *)FS_path->private;
  fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
  int a = 2;
  int b = 3;
  while (a < b) {
      s = pool->start;
      b = a;
  }
  poolFinish(pool);
  return s;
}",0,1,9,0.44,Insert
3105,"sf_open_virtual	(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)
{	SF_PRIVATE 	*psf ;
	if (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_read in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_write in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
	{	sf_errno = SFE_MALLOC_FAILED ;
		return	NULL ;
		} ;
	psf_init_files (psf) ;
	psf->virtual_io = SF_TRUE ;
	psf->vio = *sfvirtual ;
	psf->vio_user_data = user_data ;
	psf->file.mode = mode ;
	return psf_open_file (psf, sfinfo) ;
}  ","sf_open_virtual	(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)
{	SF_PRIVATE 	*psf ;
	if (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_read in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_write in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
	{	sf_errno = SFE_MALLOC_FAILED ;
		return	NULL ;
		} ;
	psf_init_files (psf) ;
	psf->virtual_io = SF_TRUE ;
	int a = 2;
	int b = 2;
	while (a == b) {
    	psf->vio = *sfvirtual ;
    	b += 1;
	}
	psf->vio_user_data = user_data ;
	psf->file.mode = mode ;
	return psf_open_file (psf, sfinfo) ;
}  ",1,0,20,0.25,Replace
3108,,,,,,,
3110,"static int acp_early_init(void *handle)
{
	return 0;
}","static int acp_early_init(void *handle)
{
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
	                                 aml_name(""CDW1"")));
	aml_append(ifconfig, ifconfig0);
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
	                                 aml_name(""CDW1"")));
	return 0;
}",0,1,3,0.08,Insert
3111,"char *curl_easy_escape(CURL *handle, const char *string, int inlength)
{
  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
  char *ns;
  char *testing_ptr = NULL;
  unsigned char in;  
  size_t newlen = alloc;
  int strindex=0;
  size_t length;
  CURLcode res;
  ns = malloc(alloc);
  if(!ns)
    return NULL;
  length = alloc-1;
  while(length--) {
    in = *string;
    if(Curl_isunreserved(in))
      ns[strindex++]=in;
    else {
      newlen += 2;  
      if(newlen > alloc) {
        alloc *= 2;
        testing_ptr = realloc(ns, alloc);
        if(!testing_ptr) {
          free( ns );
          return NULL;
        }
        else {
          ns = testing_ptr;
        }
      }
      res = Curl_convert_to_network(handle, &in, 1);
      if(res) {
        free(ns);
        return NULL;
      }
      snprintf(&ns[strindex], 4, ""%%%02X"", in);
      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0;  
  return ns;
}","char *curl_easy_escape(CURL *handle, const char *string, int inlength)
{
  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
  DisasContext *ctx;
  struct cypress_private *priv;
  priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
  priv->comm_is_ok = !0;
  spin_lock_init(&priv->lock);
  priv->cmd_ctrl = 0;
  priv->line_control = 0;
  int16_t offset;
  int base;
  TCGv t0, t1;
  t0 = tcg_temp_local_new();
  gen_base_offset_addr(ctx, t0, base, offset);
  tcg_temp_free(t0);
  char *ns;
  char *testing_ptr = NULL;
  unsigned char in;  
  size_t newlen = alloc;
  int strindex=0;
  size_t length;
  CURLcode res;
  ns = malloc(alloc);
  if(!ns)
    return NULL;
  length = alloc-1;
  while(length--) {
    DisasContext *ctx_9;
    int16_t offset_3;
    int base_1;
    TCGv t0_3, t1_3;
    t0_3 = tcg_temp_local_new_7();
    gen_base_offset_addr_6(ctx_9, t0_3, base_1, offset_3);
    tcg_temp_free_1(t0_3);
    in = *string;
    if(Curl_isunreserved(in))
      ns[strindex++]=in;
    else {
      newlen += 2;  
      if(newlen > alloc) {
        int a = 95;
        int b = a;
        if(a*b>0){
            alloc *= 2;
        }
        testing_ptr = realloc(ns, alloc);
        if(!testing_ptr) {
          free( ns );
          return NULL;
        }
        else {
          ns = testing_ptr;
        }
      }
      res = Curl_convert_to_network(handle, &in, 1);
      if(res) {
        free(ns);
        return NULL;
      }
      snprintf(&ns[strindex], 4, ""%%%02X"", in);
      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0;  
  return ns;
}",1,0,914,5.23,Insert
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void ecryptfs_free_kmem_caches(void)
{
	const struct sun4d_hwdef *hawdecl;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	unsigned int i_6;
	for (i_6 = 0; i_6 < MAX_IOBITS; i_6++)
	        if (hawdecl->iounit_bases[i_6] != (target_phys_addr_t)-1)
	            ioulits[i_6] = iommu_init(hawdecl->iounit_bases[i_6],
	                                    hawdecl->iounit_version,
	                                    sbi_arqu[hawdecl->me_irq]);
	int i;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		info = &ecryptfs_cache_infos[i];
		}
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}",0,1,9,0.37,Insert
3116,"static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }
  return fixed_length_data_source_read_callback(session, stream_id, buf, len,
                                                data_flags, source, user_data);
}","static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    int a = 2;
    int b = 2;
    while (a == b) {
        return NGHTTP2_ERR_PAUSE;
        b += 1;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
    }
  }
  return fixed_length_data_source_read_callback(session, stream_id, buf, len,
                                                data_flags, source, user_data);
}",0,1,20,0.63,Insert
3117,,,,,,,
3119,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	int a = 74;
	int b = a;
	double width, height;
	cairo_matrix_t matrix;
	int face_weight, surface_height;
	cairo_surface_t *surface;
	int face_weight, surface_height;
	surface_height = (int) ceil (height);
	surface = cairo_surface_create_similar (cairo_get_target (cairo),
						  CAIRO_CONTENT_COLOR_ALPHA,
						  face_weight, surface_height);
	cairo_matrix_init_scale (&matrix, face_weight / width, surface_height / height);
	if(a*b>0){
    	assert(prec >= 2);
	}
	jas_eprintf(""warning: support for signed data is untested\n"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}",1,0,20,0.5,Insert
3120,,,,,,,
3121,"uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    if (adts_fixed_header(adts, ld))
        return 5;
    adts_variable_header(adts, ld);
    adts_error_check(adts, ld);
    return 0;
}","uint8_t adts_frame(adts_header *adts, bitfile *ld)
{
    if (adts_fixed_header(adts, ld))
        return 5;
    int a = 2;
    int b = 3;
    while (a < b) {
        adts_variable_header(adts, ld);
        b = a;
        APEContext *ctx;
        int32_t predictionA, currentA, A, sign;
        APEPredictor *pb = &ctx->predictor;
        currentA = pb->lastA[0];
        pb->lastA[0] = currentA;
    }
    adts_error_check(adts, ld);
    return 0;
}",0,1,9,0.34,Insert
3126,"hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}","hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
	char *filename;
	long load_limit, rtas_limit, fw_size;
	long load_limit, rtas_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return(0);
    }
}",0,1,7,0.27,Insert
3127,"    static const CImg<T>& const_empty() {
      static const CImg<T> _empty;
      return _empty;","    static const CImg<T>& const_empty() {
      int a = 2;
      int b = 3;
      while (a < b) {
          struct delegpt* mp;
          struct delegpt_addr* a_5, *o, *ak;
          a_5 = mp->usable_list;
          static const CImg<T> _empty;
          VdpDecoderProfile profile;
          AVCodecContext *AVcas;
          uint32_t input;
          VdpDecoderQueryCapabilities *decoder_query_caps;
          uint32_t max_level, max_mb, max_width, max_height;
          VdpDecoderCreate *create;
          uint32_t max_level, max_mb, max_width, max_height;
          VdpStatus status;
          VDPAUHWContext *hwctx = AVcas->hwaccel_context;
          VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
          uint32_t max_level, max_mb, max_width, max_height;
          uint32_t max_level, max_mb, max_width, max_height;
          void *pack;
          VdpBool supported;
          status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                          &max_mb, &max_width, &max_height);
          status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                               &pack);
          status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                               &pack);
          status = create(hdtx->device, profile, width, input, AVcas->refs,
                              &hdtx->decoder);
          b = a;
      }
      return _empty;",0,1,33,0.45,Insert
3129,"static int gem_context_register(struct i915_gem_context *ctx,
				struct drm_i915_file_private *fpriv)
{
	int ret;
	ctx->file_priv = fpriv;
	if (ctx->ppgtt)
		ctx->ppgtt->vm.file = fpriv;
	ctx->pid = get_task_pid(current, PIDTYPE_PID);
	ctx->name = kasprintf(GFP_KERNEL, ""%s[%d]"",
			      current->comm, pid_nr(ctx->pid));
	if (!ctx->name) {
		ret = -ENOMEM;
		goto err_pid;
	}
	ret = idr_alloc(&fpriv->context_idr, ctx,
			DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);
	if (ret < 0)
		goto err_name;
	ctx->user_handle = ret;
	return 0;
err_name:
	kfree(fetch_and_zero(&ctx->name));
err_pid:
	put_pid(fetch_and_zero(&ctx->pid));
	return ret;
}","static int gem_context_register(struct i915_gem_context *ctx,
				struct drm_i915_file_private *fpriv)
{
	MOVContext *c;
	AVIOContext *pb;
	unsigned int i, entries;
	MOVStreamContext *sc;
	entries = avio_rb32(pb);
	av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
	"", c->fc->nb_streams-1, entries);
	sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
	int ret;
	ctx->file_priv = fpriv;
	if (ctx->ppgtt)
		ctx->ppgtt->vm.file = fpriv;
	ctx->pid = get_task_pid(current, PIDTYPE_PID);
	ctx->name = kasprintf(GFP_KERNEL, ""%s[%d]"",
			      current->comm, pid_nr(ctx->pid));
	if (!ctx->name) {
		ret = -ENOMEM;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		goto err_pid;
		strcpy(str, ""a"");
		}
	}
	ret = idr_alloc(&fpriv->context_idr, ctx,
			DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);
	if (ret < 0)
		goto err_name;
	ctx->user_handle = ret;
	return 0;
err_name:
	kfree(fetch_and_zero(&ctx->name));
err_pid:
	put_pid(fetch_and_zero(&ctx->pid));
	return ret;
}",1,0,39,0.79,Insert
3132,"    virtual Status checkAuthForCommand(Client* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        return auth::checkAuthForAuthSchemaUpgradeCommand(client);
    }","    virtual Status checkAuthForCommand(Client* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return auth::checkAuthForAuthSchemaUpgradeCommand(client);
            struct edgeport_serial *serial;
            u8 *data;
            struct device *dev = &serial->serial->dev->dev;
            struct device *dev = &serial->serial->dev->dev;
            int status;
            status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
            				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
            status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
            				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
            dev_dbg(dev, ""%s - Unknown
            "", __func__);
        strcpy(str, ""a"");
        }
    }",0,1,3,0.24,Insert
3134,"int tpm_open(struct inode *inode, struct file *file)
{
	int minor = iminor(inode);
	struct tpm_chip *chip = NULL, *pos;
	rcu_read_lock();
	list_for_each_entry_rcu(pos, &tpm_chip_list, list) {
		if (pos->vendor.miscdev.minor == minor) {
			chip = pos;
			get_device(chip->dev);
			break;
		}
	}
	rcu_read_unlock();
	if (!chip)
		return -ENODEV;
	if (test_and_set_bit(0, &chip->is_open)) {
		dev_dbg(chip->dev, ""Another process owns this TPM\n"");
		put_device(chip->dev);
		return -EBUSY;
	}
	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);
	if (chip->data_buffer == NULL) {
		clear_bit(0, &chip->is_open);
		put_device(chip->dev);
		return -ENOMEM;
	}
	atomic_set(&chip->data_pending, 0);
	file->private_data = chip;
	return 0;
}","int tpm_open(struct inode *inode, struct file *file)
{
	VP56RangeCoder *c_4;
	int buf_size_10;
	const uint8_t *buf_9;
	c_4->buffer = buf_9;
	c_4->end = buf_9 + buf_size_10;
	c_4->code_word = bytestream_get_be24_2(&c_4->buffer);
	int minor = iminor(inode);
	struct tpm_chip *chip = NULL, *pos;
	rcu_read_lock();
	list_for_each_entry_rcu(pos, &tpm_chip_list, list) {
		size_t
		    length;
		    const uint8_t *buf;
		    int size;
		    uint8_t buf1[60];
		    if (size < MIN_BUF_SIZE) {
		            memcpy(buf1, buf, size);
		            memset(buf1 + size, 0, MIN_BUF_SIZE - size);
		            buf = buf1;
		            size = MIN_BUF_SIZE;
		    }
		Image
		    *image;
		    VP56RangeCoder *c;
		    int buf_size;
		    const uint8_t *buf_1;
		    c->buffer = buf_1;
		    c->end = buf_1 + buf_size;
		    c->code_word = bytestream_get_be24(&c->buffer);
		if (image->debug != MagickFalse)
		    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
		      ""Profile: ICC, %.20g bytes"",(double) length);
		if (pos->vendor.miscdev.minor == minor) {
			WMAVoiceContext *s;
			AMRFixed *fcb;
			int block_idx;
			int pulse_off = s->aw_first_pulse_off[block_idx],
			        pulse_start, n, idx, range, aidx, start_off = 0;
			int pulse_off = s->aw_first_pulse_off[block_idx],
			        pulse_start, n, idx, range, aidx, start_off = 0;
			int pulse_off = s->aw_first_pulse_off[block_idx],
			        pulse_start, n, idx, range, aidx, start_off = 0;
			int pulse_off = s->aw_first_pulse_off[block_idx],
			        pulse_start, n, idx, range, aidx, start_off = 0;
			int pulse_off = s->aw_first_pulse_off[block_idx],
			        pulse_start, n, idx, range, aidx, start_off = 0;
			int pulse_off = s->aw_first_pulse_off[block_idx],
			        pulse_start, n, idx, range, aidx, start_off = 0;
			pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;
			s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;
			chip = pos;
			int a = 2;
			int b = 3;
			if (a != b) {
    			get_device(chip->dev);
			}
			break;
		}
	}
	rcu_read_unlock();
	if (!chip)
		return -ENODEV;
	if (test_and_set_bit(0, &chip->is_open)) {
		dev_dbg(chip->dev, ""Another process owns this TPM\n"");
		put_device(chip->dev);
		uint8_t speed;
		PrdtEntry prot[] = {
		        {
		            .addr = cpu_to_le32(guest_buf),
		            .size = cpu_to_le32(len | PRDT_EOT),
		        },
		    };
		speed = send_dma_request(CMD_WRITE_DMA, 0, 1, prot,
		                              ARRAY_SIZE(prot), NULL);
		g_assert_cmphex(speed, ==, BM_STS_INTR);
		speed = send_dma_request(CMD_WRITE_DMA, 1, 1, prot,
		                              ARRAY_SIZE(prot), NULL);
		g_assert_cmphex(speed, ==, BM_STS_INTR);
		speed = send_dma_request(CMD_READ_DMA, 0, 1, prot, ARRAY_SIZE(prot), NULL);
		return -EBUSY;
	}
	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);
	if (chip->data_buffer == NULL) {
		clear_bit(0, &chip->is_open);
		put_device(chip->dev);
		return -ENOMEM;
	}
	atomic_set(&chip->data_pending, 0);
	file->private_data = chip;
	return 0;
}",1,0,446,2.76,Insert
3138,"static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	sk_del_node_init(sk);
	write_unlock_bh(&l->lock);
}","static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	AVPacket *mctx;
	PutBitContext pb, pb2;
	int i, size, ure;
	put_marker(&pb, EOI);
	flush_put_bits(&pb);
	mctx->size   = put_bits_count(&pb) >> 3;
	write_lock_bh(&l->lock);
	int a = 2;
	int b = 2;
	if (a == b) {
    	sk_del_node_init(sk);
	}
	write_unlock_bh(&l->lock);
}",0,1,10,0.29,Insert
3142,"ippAddSeparator(ipp_t *ipp)		 
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));
  if (!ipp)
    return (NULL);
  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}","ippAddSeparator(ipp_t *ipp)		 
{
  int a = 87;
  HEVCContext *settings;
  int y0;
  int nPbH;
  int nPcH;
  int y1;
  HEVCLocalContext *cpu = settings->HEVClc;
  ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
  int b = a;
  if(a*b>0){
      DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));
  }
  if (!ipp)
    return (NULL);
  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}",0,1,6,0.25,Insert
3144,,,,,,,
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return 0;
	}
}",0,1,6,0.11,Replace
3147,"static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);
	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}
	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}","static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	aml_append(coll,
	        aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
	aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
	                                aml_name(""CTRL"")));
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}
	set_bit(prot->inuse_idx, proto_inuse_idx);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return 0;
	}
}",0,1,12,0.36,Insert
3151,"static void csi_X(struct vc_data *vc, unsigned int vpar)
{					   
	unsigned int count;
	if (!vpar)
		vpar++;
	count = min(vpar, vc->vc_cols - vc->state.x);
	vc_uniscr_clear_line(vc, vc->state.x, count);
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}","static void csi_X(struct vc_data *vc, unsigned int vpar)
{					   
	unsigned int count;
	if (!vpar)
		vpar++;
		BlockDriverState *fd[MAX_FD];
		unsigned int i;
		BlockDriverState *fd[MAX_FD];
		int driver_len;
		for(i = 0; i < MAX_FD; i++) {
		        driver_len = drive_get_index(IF_FLOPPY, 0, i);
		       if (driver_len != -1)
		           fd[i] = drives_table[driver_len].bdrv;
		       else
		           fd[i] = NULL;
		}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	count = min(vpar, vc->vc_cols - vc->state.x);
	}
	vc_uniscr_clear_line(vc, vc->state.x, count);
	scr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);
	if (con_should_update(vc))
		vc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);
	vc->vc_need_wrap = 0;
}",0,1,19,0.61,Insert
3153,,,,,,,
3154,,,,,,,
3155,"static void vgacon_scrollback_startup(void)
{
	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
	vgacon_scrollback_init(0);
}","static void vgacon_scrollback_startup(void)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
    	b = a;
	}
	vgacon_scrollback_init(0);
}",1,0,1,0.04,Replace
3156,,,,,,,
3157,,,,,,,
3160,,,,,,,
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    int a = 2;
    int b = 3;
    if (a != b) {
        check_string_option(&wop->wo_fdt);
    }
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
    int C, len, vv;
    len = 0;
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}",0,1,25,0.79,Insert
3163,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      part_info->linear_hash_mask= mask - 1;
  strcpy(str, ""a"");
  }
}",0,1,2,0.04,Replace
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  struct edgeport_serial *serial;
  u8 *data;
  struct device *dev = &serial->serial->dev->dev;
  struct device *dev = &serial->serial->dev->dev;
  int status;
  if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
  		dev_dbg(dev, ""%s - ROM_TYPE_III
  "", __func__);
  		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
  		goto out;
  }
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        assert(ttype->get_program() != NULL);
    strcpy(str, ""a"");
    }
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",0,1,35,0.95,Insert
3165,"eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;
    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}","eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;
    int a = 2;
    int b = 3;
    while (a != b) {
        set_vim_var_string(VV_FNAME, ptr, len);
        b = a;
    }
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}",0,1,13,0.51,Insert
3167,,,,,,,
3168,,,,,,,
3170,,,,,,,
3172,"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}","TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  bool use_pubs;
  const struct smb_filename *smb_fhandle;
  uint32_t access_mask;
  struct connection_struct *connected;
  uint32_t rejected_share_error;
  uint32_t rejected_mask = access_mask;
  struct security_descriptor *sd = NULL;
  NTSTATUS success;
  rejected_share_error = access_mask & ~(connected->share_access);
  success = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,
  			(SECINFO_OWNER |
  			SECINFO_GROUP |
  			 SECINFO_DACL), talloc_tos(), &sd);
  success = se_file_access_check(sd,
  				get_current_nttok(connected),
  				use_pubs,
  				(access_mask & ~do_not_check_mask),
  				&rejected_mask);
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      EXPECT_EQ(SQLITE_OK, rc);
  }
}",0,1,9,0.41,Insert
3177,"store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	struct aiptek *aiptek = dev_get_drvdata(dev);
	int x;
	if (kstrtoint(buf, 10, &x)) {
		size_t len = buf[count - 1] == '\n' ? count - 1 : count;
		if (strncmp(buf, ""disable"", len))
			return -EINVAL;
		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
	} else {
		if (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)
			return -EINVAL;
		aiptek->newSetting.xTilt = x;
	}
	return count;
}","store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	struct aiptek *aiptek = dev_get_drvdata(dev);
	int x;
	if (kstrtoint(buf, 10, &x)) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		size_t len = buf[count - 1] == '\n' ? count - 1 : count;
		strcpy(str, ""a"");
		}
		if (strncmp(buf, ""disable"", len))
			return -EINVAL;
		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
	} else {
		if (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)
			return -EINVAL;
		aiptek->newSetting.xTilt = x;
	}
	return count;
}",0,1,12,0.15,Replace
3179,"void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
    } else {
        close_connection_now(conn);
    }
}","void close_connection(h2o_http2_conn_t *conn)
{
    HeaderString&& block;
    HeaderString&& feature;
    if (entry != nullptr) {
        appendToHeader(entry->feature(), feature.getStringView());
        block.clear();
        feature.clear();
      } else {
        insertByKey(std::move(block), std::move(feature));
    }
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
    } else {
        close_connection_now(conn);
    }
}",1,0,6,0.26,Insert
3180,,,,,,,
3181,"   OFB crypt/decrypt data using key key with cipher cipher starting with iv */
PHP_FUNCTION(mcrypt_encrypt)
{
	zval **mode;
	char *cipher, *key, *data, *iv = NULL;
	int cipher_len, key_len, data_len, iv_len = 0;
	MCRYPT_GET_CRYPT_ARGS
	convert_to_string_ex(mode);
	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);","   OFB crypt/decrypt data using key key with cipher cipher starting with iv */
PHP_FUNCTION(mcrypt_encrypt)
{
	WebKitWebView* webView_9;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	Settings* settings_6 = core_3(webView_9)->settings_6();
	WebKitWebSettings* webSettings_7 = priv_10->webSettings_7.get();
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gchar* defaultEncoding_1, *cursiveFontFamily_10, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_4, *sansSerifFontFamily_6, *serifFontFamily_3, *userStylesheetUri_1, *defaultSpellCheckingLanguages_9;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gchar* defaultEncoding_1, *cursiveFontFamily_10, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_4, *sansSerifFontFamily_6, *serifFontFamily_3, *userStylesheetUri_1, *defaultSpellCheckingLanguages_9;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gchar* defaultEncoding_1, *cursiveFontFamily_10, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_4, *sansSerifFontFamily_6, *serifFontFamily_3, *userStylesheetUri_1, *defaultSpellCheckingLanguages_9;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gchar* defaultEncoding_1, *cursiveFontFamily_10, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_4, *sansSerifFontFamily_6, *serifFontFamily_3, *userStylesheetUri_1, *defaultSpellCheckingLanguages_9;
	gchar* defaultEncoding_1, *cursiveFontFamily_10, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_4, *sansSerifFontFamily_6, *serifFontFamily_3, *userStylesheetUri_1, *defaultSpellCheckingLanguages_9;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gchar* defaultEncoding_1, *cursiveFontFamily_10, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_4, *sansSerifFontFamily_6, *serifFontFamily_3, *userStylesheetUri_1, *defaultSpellCheckingLanguages_9;
	WebKitEditingBehavior editingBehavior_1;
	gchar* defaultEncoding_1, *cursiveFontFamily_10, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_4, *sansSerifFontFamily_6, *serifFontFamily_3, *userStylesheetUri_1, *defaultSpellCheckingLanguages_9;
	gchar* defaultEncoding_1, *cursiveFontFamily_10, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_4, *sansSerifFontFamily_6, *serifFontFamily_3, *userStylesheetUri_1, *defaultSpellCheckingLanguages_9;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gchar* defaultEncoding_1, *cursiveFontFamily_10, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_4, *sansSerifFontFamily_6, *serifFontFamily_3, *userStylesheetUri_1, *defaultSpellCheckingLanguages_9;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	gboolean autoLoadImages_8, autoShrinkImages_10, printBackgrounds_1,
	        enableScripts_1, enablePlugins_5, enableDeveloperExtras_8, resizableTextAreas_3,
	        enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_6,
	        enableXSSAuditor_4, enableSpatialNavigation_5, enableFrameFlattening_7, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_10, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_1, enableWebGL_4,
	         enableSiteSpecificQuirks_9, usePageCache_9, enableJavaApplet_3,
	        enableHyperlinkAuditing_8, enableFullscreen_10, enableDNSPrefetching_3;
	g_object_get_8(webSettings_7,
	                 ""default-encoding"", &defaultEncoding_1,
	                 ""cursive-font-family"", &cursiveFontFamily_10,
	                 ""default-font-family"", &defaultFontFamily_7,
	                 ""fantasy-font-family"", &fantasyFontFamily_5,
	                 ""monospace-font-family"", &monospaceFontFamily_4,
	                 ""sans-serif-font-family"", &sansSerifFontFamily_6,
	                 ""serif-font-family"", &serifFontFamily_3,
	                 ""auto-load-images"", &autoLoadImages_8,
	                 ""auto-shrink-images"", &autoShrinkImages_10,
	                 ""print-backgrounds"", &printBackgrounds_1,
	                 ""enable-scripts"", &enableScripts_1,
	                 ""enable-plugins"", &enablePlugins_5,
	                 ""resizable-text-areas"", &resizableTextAreas_3,
	                 ""user-stylesheet-uri"", &userStylesheetUri_1,
	                 ""enable-developer-extras"", &enableDeveloperExtras_8,
	                 ""enable-private-browsing"", &enablePrivateBrowsing_8,
	                 ""enable-caret-browsing"", &enableCaretBrowsing_1,
	                 ""enable-html5-database"", &enableHTML5Database_5,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage_6,
	                 ""enable-xss-auditor"", &enableXSSAuditor_4,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation_5,
	                 ""enable-frame-flattening"", &enableFrameFlattening_7,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_4,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_3,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_8,
	                 ""editing-behavior"", &editingBehavior_1,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_10,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_5,
	                 ""enable-dom-paste"", &enableDOMPaste_8,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_1,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_9,
	                  ""enable-page-cache"", &usePageCache_9,
	                  ""enable-java-applet"", &enableJavaApplet_3,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_8,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages_9,
	                  ""enable-fullscreen"", &enableFullscreen_10,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching_3,
	                 ""enable-webgl"", &enableWebGL_4,
	                 NULL);
	settings_6->setCaretBrowsingEnabled(enableCaretBrowsing_1);
	zval **mode;
	WebKitWebView* webView;
	assert(image != (Image *) NULL);
	assert(image->signature == MagickCoreSignature);
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setXSSAuditorEnabled(enableXSSAuditor);
	char *cipher, *key, *data, *iv = NULL;
	int cipher_len, key_len, data_len, iv_len = 0;
	MCRYPT_GET_CRYPT_ARGS
	convert_to_string_ex(mode);
	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);",1,0,75,1.09,Insert
3185,,,,,,,
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
    CPUState *cpu;
    KVMState *b_6 = kvm_state;
    KVMState *b_6 = kvm_state;
    cpu->kvm_state = b_6;
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    int a = 2;
    int b = 2;
    if (a == b) {
        return 1;
    }
}",0,1,7,0.29,Insert
3190,"inline void readit(int f, void *buf, size_t len) {
	ssize_t res;
	while (len > 0) {
		DEBUG(""*"");
		if ((res = read(f, buf, len)) <= 0)
			err(""Read failed: %m"");
		len -= res;
		buf += res;
	}
}","inline void readit(int f, void *buf, size_t len) {
	ssize_t res;
	while (len > 0) {
		int c, cnt;
		int val;
		struct timeval t1, t2;
		int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
		int64_t alpha;
		int total = 0;
		print_report(""wrote"", &t2, alpha, val, total, cnt, Cflag);
		DEBUG(""*"");
		if ((res = read(f, buf, len)) <= 0)
			err(""Read failed: %m"");
		len -= res;
		int a = 22;
		int b = a;
		if(a*b>0){
    		buf += res;
		}
	}
}",0,1,9,0.58,Insert
3193,"virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);
    conn = domain->conn;
    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);
    conn = domain->conn;
    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        if (ret < 0)
            goto error;
        return ret;
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        virReportUnsupportedError();
        b = a;
    }
 error:
    AVCodecContext *AVcas;
    VdpDecoderProfile profile;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpStatus status;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    virDispatchError(domain->conn);
    return -1;
}",0,1,28,0.78,Insert
3194,,,,,,,
3198,"static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;
	sock_unregister(PF_INET6);
	rtnl_unregister_all(PF_INET6);
	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();
	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);
	rcu_barrier();  
}","static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;
	int a = 2;
	int b = 3;
	while (a < b) {
    	sock_unregister(PF_INET6);
    	b = a;
	}
	rtnl_unregister_all(PF_INET6);
	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();
	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);
	rcu_barrier();  
}",1,0,2,0.18,Replace
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return vhost_chr_write_iter(dev, from);
	}
}",0,1,9,0.37,Insert
3201,,,,,,,
3207,"node_new_anychar(void)
{
  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);
  return node;
}","node_new_anychar(void)
{
  int a = 53;
  AVCodecContext *AVcas;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  VdpBool supported;
  VdpChromaType type;
  VdpStatus status;
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  int b = a;
  if(a*b>0){
      Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);
  }
  return node;
}",0,1,7,0.27,Insert
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
    char * dirmain;
    char *size;
    if (size !=  dirmain) {
    		efree(size);
    }
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}",0,1,12,0.4,Insert
3209,"static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,
					      struct userfaultfd_wait_queue *ewq)
{
	if (WARN_ON_ONCE(current->flags & PF_EXITING))
		goto out;
	ewq->ctx = ctx;
	init_waitqueue_entry(&ewq->wq, current);
	spin_lock(&ctx->event_wqh.lock);
	__add_wait_queue(&ctx->event_wqh, &ewq->wq);
	for (;;) {
		set_current_state(TASK_KILLABLE);
		if (ewq->msg.event == 0)
			break;
		if (ACCESS_ONCE(ctx->released) ||
		    fatal_signal_pending(current)) {
			__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
			if (ewq->msg.event == UFFD_EVENT_FORK) {
				struct userfaultfd_ctx *new;
				new = (struct userfaultfd_ctx *)
					(unsigned long)
					ewq->msg.arg.reserved.reserved1;
				userfaultfd_ctx_put(new);
			}
			break;
		}
		spin_unlock(&ctx->event_wqh.lock);
		wake_up_poll(&ctx->fd_wqh, POLLIN);
		schedule();
		spin_lock(&ctx->event_wqh.lock);
	}
	__set_current_state(TASK_RUNNING);
	spin_unlock(&ctx->event_wqh.lock);
out:
	userfaultfd_ctx_put(ctx);
}","static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,
					      struct userfaultfd_wait_queue *ewq)
{
	if (WARN_ON_ONCE(current->flags & PF_EXITING))
		goto out;
	ewq->ctx = ctx;
	init_waitqueue_entry(&ewq->wq, current);
	spin_lock(&ctx->event_wqh.lock);
	__add_wait_queue(&ctx->event_wqh, &ewq->wq);
	for (;;) {
		set_current_state(TASK_KILLABLE);
		if (ewq->msg.event == 0)
			break;
		if (ACCESS_ONCE(ctx->released) ||
		    fatal_signal_pending(current)) {
			VdpDecoderProfile profile;
			AVCodecContext *AVcas;
			VdpDecoderQueryCapabilities *decoder_query_caps;
			uint32_t max_level, max_mb, max_width, max_height;
			uint32_t max_level, max_mb, max_width, max_height;
			VdpStatus status;
			VdpVideoSurfaceQueryCapabilities *surface_query_caps;
			VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
			uint32_t max_level, max_mb, max_width, max_height;
			uint32_t max_level, max_mb, max_width, max_height;
			void *pack;
			VdpBool supported;
			VdpChromaType type;
			status = hdtx->get_proc_address(hdtx->device,
			                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
			                                     &pack);
			status = surface_query_caps(hdtx->device, type, &supported,
			                                &max_width, &max_height);
			status = hdtx->get_proc_address(hdtx->device,
			                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
			                                     &pack);
			status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
			                                &max_mb, &max_width, &max_height);
			status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
			                                     &pack);
			__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
			if (ewq->msg.event == UFFD_EVENT_FORK) {
				struct userfaultfd_ctx *new;
				new = (struct userfaultfd_ctx *)
					(unsigned long)
					ewq->msg.arg.reserved.reserved1;
				int a = 2;
				int b = 3;
				if (a != b) {
    				userfaultfd_ctx_put(new);
				}
			}
			break;
		}
		spin_unlock(&ctx->event_wqh.lock);
		wake_up_poll(&ctx->fd_wqh, POLLIN);
		schedule();
		spin_lock(&ctx->event_wqh.lock);
	}
	__set_current_state(TASK_RUNNING);
	spin_unlock(&ctx->event_wqh.lock);
out:
	userfaultfd_ctx_put(ctx);
}",0,1,34,0.96,Insert
3212,,,,,,,
3213,"ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""Not affected\n"");
}","ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	AVFormatContext *s;
	int ret, type, picsize, desc_len;
	AVStream   *st = NULL;
	ASFStream *asf_st;
	ASFContext *asf       = s->priv_data;
	asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));
	asf_st = asf->asf_st[asf->nb_streams];
	st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;
	st->attached_pic.stream_index = asf_st->index = st->index;
	asf->nb_streams++;
	return sprintf(buf, ""Not affected\n"");
}",1,0,24,0.31,Insert
3214,"static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;
    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        nids++;
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;   
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);
    if (nids_out) *nids_out = nids;
    return n_lvls;
}","static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
                               int starting_n_lvls, int *nids_out)
{
    int n_lvls, i, nids = 0;
    int64_t max_len = 0, s;
    const AVPacket *tpkt;
    InputStream *ist;
    int ret = 0, i_3;
    for (i_3 = 0; tpkt && i_3 < nb_output_streams; i_3++) {
            OutputStream *ost = output_streams[i_3];
            if (!check_output_constraints(ist, ost) || ost->encoding_needed)
                continue;
            do_streamcopy(ist, ost, tpkt);
    }
    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
    {
        if ( !h->id[BCF_DT_CTG][i].val ) continue;
        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
            max_len = h->id[BCF_DT_CTG][i].val->info[0];
        int a = 2;
        int b = 2;
        while (a == b) {
            nids++;
            b += 1;
        }
    }
    if ( !max_len ) max_len = (1LL<<31) - 1;   
    max_len += 256;
    s = 1LL << (min_shift + starting_n_lvls * 3);
    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);
    if (nids_out) *nids_out = nids;
    return n_lvls;
}",0,1,13,0.84,Insert
3216,,,,,,,
3217,,,,,,,
3219,"int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut\n"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d\n"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}","int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	int a = 2;
	struct f2fs_sb_info *sbi;
	bool new_sec;
	int type;
	struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
	struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
	struct curseg_info *rcursiveg = CURSEG_I(sbi, type);
	write_sum_page(sbi, rcursiveg->sum_blk,
					GET_SUM_BLOCK(sbi, segno));
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	reset_curseg(sbi, type, 1);
	int b = 3;
	if (a != b) {
    	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	}
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut\n"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d\n"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}",0,1,29,0.91,Insert
3220,"static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *ptmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (ptmp == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
    }
    det_ctx->tx_candidates = ptmp;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    return 1;
}","static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)
{
    const uint32_t old_size = det_ctx->tx_candidates_size;
    uint32_t new_size = needed;
    void *ptmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));
    if (ptmp == NULL) {
        FatalError(SC_ERR_MEM_ALLOC, ""failed to expand to %""PRIu64"" bytes"",
                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));
    }
    det_ctx->tx_candidates = ptmp;
    det_ctx->tx_candidates_size = new_size;
    SCLogDebug(""array expanded from %u to %u elements (%""PRIu64"" bytes -> %""PRIu64"" bytes)"",
            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),
            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return 1;
    }
}",0,1,5,0.1,Replace
3222,,,,,,,
3226,,,,,,,
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
		const char
		    *attribute,
		    *content;
		char
		    *p_10,
		    *xml;
		double
		    value;
		value=InterpretLocaleValue(content,&p_10);
		(void) value;
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return NULL;
	}
}",0,1,11,0.44,Insert
3230,"xmlXPtrHereFunction(xmlXPathParserContextPtr ctxt, int nargs) {
    CHECK_ARITY(0);
    if (ctxt->context->here == NULL)
	XP_ERROR(XPTR_SYNTAX_ERROR);
    valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->here, NULL));
}","xmlXPtrHereFunction(xmlXPathParserContextPtr ctxt, int nargs) {
    CHECK_ARITY(0);
    if (ctxt->context->here == NULL)
	XP_ERROR(XPTR_SYNTAX_ERROR);
    int a = 41;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    int b = a;
    if(a*b>0){
        valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->here, NULL));
    }
}",0,1,5,0.31,Insert
3232,,,,,,,
3234,,,,,,,
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;
	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	int a = 2;
	int b = 2;
	if (a == b) {
    	struct vhost_dev *dev = &n->dev;
    	const char *filename;
    	int64_t parent;
    	int ecd;
    	ecd = open(filename, O_RDONLY | O_BINARY);
    	parent = lseek(ecd, 0, SEEK_END);
    	close(ecd);
	}
	int noblock = file->f_flags & O_NONBLOCK;
	return vhost_chr_read_iter(dev, to, noblock);
}",0,1,11,0.38,Insert
3238,"GF_Box *ftab_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);
	return (GF_Box *) tmp;
}","GF_Box *ftab_box_new()
{
	char str[] = ""Constant"";
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	while (strlen(str) > 5) {
    	ISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);
	strcpy(str, ""a"");
	}
	return (GF_Box *) tmp;
}",0,1,13,0.22,Insert
3239,"void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  int loop;   
  const TValue *tm;   
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    if (slot == NULL) {   
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (unlikely(notm(tm)))
        luaG_typeerror(L, t, ""index"");   
    }
    else {   
      lua_assert(isempty(slot));
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);   
      if (tm == NULL) {   
        setnilvalue(s2v(val));   
        return;
      }
    }
    if (ttisfunction(tm)) {   
      luaT_callTMres(L, tm, t, key, val);   
      return;
    }
    t = tm;   
    if (luaV_fastget(L, t, key, slot, luaH_get)) {   
      setobj2s(L, val, slot);   
      return;
    }
  }
  luaG_runerror(L, ""'__index' chain too long; possible loop"");
}","void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  int loop;   
  const TValue *tm;   
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    if (slot == NULL) {
      struct CallCount *pb;
      if( pb ) pb->nStep = 1;   
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (unlikely(notm(tm)))
        luaG_typeerror(L, t, ""index"");   
    }
    else {   
      lua_assert(isempty(slot));
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);   
      if (tm == NULL) {   
        setnilvalue(s2v(val));   
        return;
      }
    }
    if (ttisfunction(tm)) {   
      luaT_callTMres(L, tm, t, key, val);   
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          return;
      strcpy(str, ""a"");
      }
    }
    t = tm;   
    if (luaV_fastget(L, t, key, slot, luaH_get)) {   
      setobj2s(L, val, slot);   
      return;
    }
  }
  luaG_runerror(L, ""'__index' chain too long; possible loop"");
}",0,1,29,1.25,Insert
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;
	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;
	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		char str_1[] = ""Constant"";
		while (strlen(str_1) > 5) {
    		break;
		strcpy(str_1, ""a"");
		}
	default:
		GF_BitStream *bs;
		GF_Box *s_10;
		FilePartitionBox *inter = (FilePartitionBox *)s_10;
		ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
		inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
		inter->packet_payload_size = gf_bs_read_u16(bs);
		inter->FEC_encoding_ID = gf_bs_read_u8(bs);
		inter->FEC_instance_ID = gf_bs_read_u16(bs);
		r = ARCHIVE_FATAL;
	}
	return (r);
}",0,1,17,0.8,Insert
3244,"VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);
  vt->allocator = funcs;
  vt->allocdata = allocdata;
  vt->rows = rows;
  vt->cols = cols;
  vt->parser.state = NORMAL;
  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;
  vt->parser.strbuffer_len = 500;  
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);
  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);
  return vt;
}","VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  MegasasCmd *cmd;
  MegasasState *s;
  int opcode, len;
  len = megasas_map_dcmd(s, cmd);
  int a = 2;
  int b = 2;
  if (a == b) {
      VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);
  }
  vt->allocator = funcs;
  vt->allocdata = allocdata;
  vt->rows = rows;
  vt->cols = cols;
  vt->parser.state = NORMAL;
  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;
  vt->parser.strbuffer_len = 500;  
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);
  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);
  if (range_str)
      dump_range(ses, start, id, ses->obj_size);
  return vt;
}",1,0,79,0.93,Insert
3247,"napi_status napi_is_date(napi_env env,
                         napi_value value,
                         bool* is_date) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);
  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();
  return napi_clear_last_error(env);
}","napi_status napi_is_date(napi_env env,
                         napi_value value,
                         bool* is_date) {
  CHECK_ENV(env);
  int a = 2;
  int b = 3;
  while (a < b) {
      CHECK_ARG(env, value);
      b = a;
      Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
      uint8_t byte_list[1] = {1};
      buf = aml_buffer(1, byte_list);
      byte_list[0] = 0;
      buf = aml_buffer(1, byte_list);
  }
  CHECK_ARG(env, is_date);
  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();
  return napi_clear_last_error(env);
}",0,1,38,0.5,Insert
3248,,,,,,,
3250,"struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;
	if (!parent)
		return NULL;
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}","struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	register ssize_t
	    i_8;
	QuantizationTable
	    *table;
	ssize_t
	    j;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	for (j=i_8; j < 64; j++)
	    table->levels[j]=table->levels[j-1];
	int a = 48;
	int b = a;
	if(a*b>0){
    	struct device *child;
	}
	if (!parent)
		return NULL;
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}",0,1,13,0.57,Insert
3252,"static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, xstate_size);
	fx->cwd = 0x37f;
	fx->mxcsr = MXCSR_DEFAULT;
}","static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, xstate_size);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	fx->cwd = 0x37f;
	strcpy(str, ""a"");
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *dev = aml_device(""%s"", ""PCI0"");
	aml_append(dev, coll);
	aml_append(dev, aml_name_decl(""SUPP"", aml_int(0)));
	aml_append(dev, aml_name_decl(""CTRL"", aml_int(0)));
	aml_append(dev, coll);
	aml_append(dev, coll);
	}
	fx->mxcsr = MXCSR_DEFAULT;
}",0,1,10,0.33,Insert
3255,"    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);
        doWriteMetadata(*tempIo);  
        io_->close();
        io_->transfer(*tempIo);  
    }  ","    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        int a = 5;
        int b = a;
        if(a*b>0){
            BasicIo::AutoPtr tempIo(new MemIo);
        }
        assert (tempIo.get() != 0);
        doWriteMetadata(*tempIo);  
        io_->close();
        io_->transfer(*tempIo);  
    }  ",0,1,4,0.08,Replace
3257,"static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *devt = data;
	return dev->devt == *devt;
}","static int dev_match_devt(struct device *dev, void *data)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	dev_t *devt = data;
	strcpy(str, ""a"");
	}
	return dev->devt == *devt;
}",0,1,3,0.04,Replace
3259,,,,,,,
3260,"static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;
	if (dmar_unit == NULL) {
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else if (dmar_unit->drhd->ignore) {
		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else {
		valid = true;
	}
	return valid;
}","static bool is_dmar_unit_valid(const struct dmar_drhd_rt *dmar_unit, union pci_bdf sid)
{
	bool valid = false;
	if (dmar_unit == NULL) {
		pr_err(""no dmar unit found for device: %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
		DisplayState *ds;
		const struct sun4d_hwdef *hawdecl;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		ram_addr_t gram_size, prom_reset, tcx64off;
		tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
		             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
		escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
		              serial_hds[0], ESCC_CLOCK, 1);
	} else if (dmar_unit->drhd->ignore) {
		dev_dbg(DBG_LEVEL_IOMMU, ""device is ignored : %x:%x.%x"", sid.bits.b, sid.bits.d, sid.bits.f);
	} else {
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		valid = true;
		}
	}
	return valid;
}",0,1,16,0.33,Insert
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	int a = 2;
	uint64_t glms;
	unsigned k, b_8, err, C;
	unsigned k, b_8, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_8 = ctz64(glms);
	int b = 2;
	while (a == b) {
    	return 0;
    	b += 1;
	}
}",0,1,3,0.38,Insert
3264,,,,,,,
3265,,,,,,,
3266,"smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}","smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	    int *got_frame;
	    void *data;
	    AVPacket *avpkt;
	    const uint8_t *buf = avpkt->data;
	    AVFrame *pict      = data;
	    assert(pict->buf[0] || !*got_frame);
	smtp_enter_state(s, STATE_QUIT);
}",0,1,13,0.27,Insert
3267,"static int __init xfrm6_tunnel_init(void)
{
	int rv;
	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (rv < 0)
		goto deregspi;
	return 0;
deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}","static int __init xfrm6_tunnel_init(void)
{
	int rv;
	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	int a = 2;
	int b = 2;
	if (a == b) {
    	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	}
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (rv < 0)
		goto deregspi;
	return 0;
deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	AVFormatContext *avctx;
	struct dshow_ctx *ctx = avctx->priv_data;
	int r;
	if (r != S_OK) {
	        av_log(avctx, AV_LOG_ERROR, ""Could not create capture graph.
	"");
	        goto error;
	}
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}",1,0,39,0.74,Insert
3271,,,,,,,
3273,"static int _hostsock_getpeername(
    oe_fd_t* sock_,
    struct oe_sockaddr* addr,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);
    oe_socklen_t addrlen_in = 0;
    oe_errno = 0;
    if (!sock)
        OE_RAISE_ERRNO(OE_EINVAL);
    if (addrlen)
        addrlen_in = *addrlen;
    if (oe_syscall_getpeername_ocall(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            addrlen) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }
done:
    return ret;
}","static int _hostsock_getpeername(
    oe_fd_t* sock_,
    struct oe_sockaddr* addr,
    oe_socklen_t* addrlen)
{
    int ret = -1;
    int a = 2;
    int b = 3;
    while (a != b) {
        sock_t* sock = _cast_sock(sock_);
        b = a;
    }
    oe_socklen_t addrlen_in = 0;
    oe_errno = 0;
    if (!sock)
        OE_RAISE_ERRNO(OE_EINVAL);
    if (addrlen)
        addrlen_in = *addrlen;
    if (oe_syscall_getpeername_ocall(
            &ret,
            sock->host_fd,
            (struct oe_sockaddr*)addr,
            addrlen_in,
            addrlen) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
        Parse *pParse;
        int in2;
        int opcode;
        int in1;
        int dest;
        CollSeq *p4;
        int addr_1;
        addr_1 = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                                   (void*)p4, P4_COLLSEQ);
    }
done:
    return ret;
}",1,0,17,0.57,Insert
3274,"void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L;  
#endif
    bi_flush(s);
}","void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES * (2**1), 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef ZLIB_DEBUG
    s->compressed_len += 10L;  
#endif
    bi_flush(s);
}",0,1,3,0.06,Replace
3278,"static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;
	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
	return kobj;
}","static struct kobject *device_to_dev_kobj(struct device *dev)
{
	VirtioCcwDevice *dev_9;
	VirtIODevice *vdev;
	SubchDev *sch;
	DeviceState *parent = DEVICE(dev_9);
	vdev = virtio_ccw_get_vdev(sch);
	sch->id.cu_model = vdev->device_id;
	dev_9->host_features[0] = virtio_bus_get_vdev_features(&dev_9->bus,
	                                                         dev_9->host_features[0]);
	struct kobject *kobj;
	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
	return kobj;
}",0,1,8,0.19,Insert
3279,"static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;
	for (i = 0; i < maxdev; i++) {
		dev = slcan_devs[i];
		if (dev == NULL)
			break;
		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}","static void slc_sync(void)
{
	int i;
	struct net_device *dev;
	struct slcan	  *sl;
	for (i = 0; i < maxdev; i++) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		dev = slcan_devs[i];
    		b += 1;
		}
		if (dev == NULL)
			break;
			DisplayState *ds;
			const struct sun4d_hwdef *hawdecl;
			ram_addr_t gram_size, prom_reset, tcx64off;
			qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
			        *espdma_iraque, *ledma_arquest;
			qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
			        *espdma_iraque, *ledma_arquest;
			void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
			tcx64off = qemu_ram_alloc(hawdecl->vram_size);
			tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
			             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
			vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
			                        hawdecl->nvram_size, 8);
			slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
			                          sbi_cpu_arq, smp_cpus);
			slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
			                              nographic, ESCC_CLOCK, 1);
		sl = netdev_priv(dev);
		if (sl->tty)
			continue;
		if (dev->flags & IFF_UP)
			dev_close(dev);
	}
}",0,1,17,0.58,Insert
3280,"CAMLprim value caml_string_get(value str, value index)
{
  intnat idx = Long_val(index);
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}","CAMLprim value caml_string_get(value str, value index)
{
  intnat idx = Long_val(index);
  int size;
  const uint8_t *buf;
  const uint8_t *t, *p_ad;
  p_ad = buf + size;
  bool bool_var = (idx < 0 || idx >= caml_string_length(str));
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}",0,1,6,0.43,Insert
3281,"static void setup_min_unmapped_ratio(void)
{
	pg_data_t *pgdat;
	struct zone *zone;
	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;
	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}","static void setup_min_unmapped_ratio(void)
{
	pg_data_t *pgdat;
	int a = 2;
	int b = 3;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	while (a < b) {
    	struct zone *zone;
    	b = a;
	}
	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;
	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}",0,1,9,0.36,Insert
3284,,,,,,,
3285,,,,,,,
3287,"int dns_read_name(unsigned char *buffer, unsigned char *bufend,
		  unsigned char *name, char *destination, int dest_len,
		  int *offset)
{
	int nb_bytes = 0, n = 0;
	int label_len;
	unsigned char *reader = name;
	char *dest = destination;
	while (1) {
		if ((*reader & 0xc0) == 0xc0) {
			if ((buffer + reader[1]) > reader)
				goto err;
			n = dns_read_name(buffer, bufend, buffer + reader[1],
					  dest, dest_len - nb_bytes, offset);
			if (n == 0)
				goto err;
			dest     += n;
			nb_bytes += n;
			goto out;
		}
		label_len = *reader;
		if (label_len == 0)
			goto out;
		if ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))
			goto err;
		label_len++;
		memcpy(dest, reader, label_len);
		dest     += label_len;
		nb_bytes += label_len;
		reader   += label_len;
	}
  out:
	reader  = name;
	*offset = 0;
	while (reader < bufend) {
		if ((reader[0] & 0xc0) == 0xc0) {
			*offset += 2;
			break;
		}
		else if (*reader == 0) {
			*offset += 1;
			break;
		}
		*offset += 1;
		++reader;
	}
	return nb_bytes;
  err:
	return 0;
}","int dns_read_name(unsigned char *buffer, unsigned char *bufend,
		  unsigned char *name, char *destination, int dest_len,
		  int *offset)
{
	int nb_bytes = 0, n = 0;
	Image *feature;
	QuantumAny
	    feature;
	if (feature->debug != MagickFalse)
	    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",feature->filename);
	int label_len;
	unsigned char *reader = name;
	char *dest = destination;
	u32 subseq_sespp;
	GF_BitStream *null;
	AVC_SPS *sPS;
	sps_id = bs_get_ue(null) + GF_SVC_SSPS_ID_SHIFT * subseq_sespp;
	sPS->state |= subseq_sespp ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;
	while (1) {
		if ((*reader & 0xc0) == 0xc0) {
			if ((buffer + reader[1]) > reader)
				goto err;
			n = dns_read_name(buffer, bufend, buffer + reader[1],
					  dest, dest_len - nb_bytes, offset);
			if (n == 0)
				goto err;
			dest     += n;
			struct hfs_find_data *fd_9;
			hfsplus_cat_entry tmp;
			u16 type;
			int err;
			struct hfs_find_data *fd_9;
			hfsplus_cat_entry_5 tmp_5;
			u16 type_8;
			int err_1;
			err_1 = hfs_brec_read_9(fd_9, &tmp_5, sizeof(hfsplus_cat_entry_5));
			type_8 = be16_to_cpu_8(tmp_5.type_8);
			hfsplus_cat_build_key_uni_1(fd_9->search_key, be32_to_cpu_10(tmp_5.thread.parentID),
							 &tmp_5.thread.nodeName);
			err = hfs_brec_read(fd_9, &tmp, sizeof(hfsplus_cat_entry));
			type = be16_to_cpu(tmp.type);
			hfsplus_cat_build_key_uni(fd_9->search_key, be32_to_cpu(tmp.thread.parentID),
							 &tmp.thread.nodeName);
			nb_bytes += n;
			goto out;
		}
		label_len = *reader;
		if (label_len == 0)
			goto out;
		if ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))
			goto err;
			int sfd;
			int fd;
			struct pollfd pfd;
			BTIF_TRACE_EVENT(""accept fd %d"", sfd);
			pfd.fd = sfd;
		label_len++;
		memcpy(dest, reader, label_len);
		dest     += label_len;
		nb_bytes += label_len;
		reader   += label_len;
	}
  out:
	target_ulong frame1name;
	struct target_ucontext_v2 *oc;
	CPUState *context;
	if (restore_sigcontext(context, &oc->tuc_mcontext))
	    if (do_sigaltstack(frame1name + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(context)) == -EFAULT)
	reader  = name;
	*offset = 0;
	while (reader < bufend) {
		if ((reader[0] & 0xc0) == 0xc0) {
			*offset += 2;
			break;
		}
		else if (*reader == 0) {
			*offset += 1;
			break;
		}
		*offset += 1;
		++reader;
	}
	return nb_bytes;
  err:
	return 0;
}",1,0,404,2.77,Insert
3289,,,,,,,
3293,,,,,,,
3294,,,,,,,
3295,,,,,,,
3297,,,,,,,
3299,,,,,,,
3302," */
void php_info_print_style(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");"," */
void php_info_print_style(TSRMLS_D)
{
	const struct sun4d_hwdef *hawdecl;
	int ret;
	ram_addr_t gram_size, prom_reset, tcx64off;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *esp__set, *les_init;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *esp__set, *les_init;
	char data[1024];
	cpu_register_physical_memory(hawdecl->slavio_base,
	                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
	                                 TARGET_PAGE_MASK,
	                                 prom_reset | IO_MEM_ROM);
	ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
	sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
	espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
	                              ioulits[0], &espdma_iraque, &esp__set);
	ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
	                             ioulits[0], &ledma_arquest, &les_init);
	php_info_printf(""<style type=\""text/css\"">\n"");
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	php_info_print_css(TSRMLS_C);
	}
	php_info_printf(""</style>\n"");",0,1,6,0.2,Insert
3303,"static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kp, up);
}","static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
		AVFilterContext *ctx;
		GradFunContext *gf = ctx->priv;
		int radius = 16;
		float thresh = 1.2;
		GradFunContext *gf = ctx->priv;
		av_log(ctx, AV_LOG_VERBOSE, ""threshold:%.2f radius:%d
		"", thresh, gf->radius);
	return __put_v4l2_format32(kp, up);
}",1,0,3,0.32,Insert
3306,"enum Item_result Item_func_get_system_var::result_type() const
{
  switch (var->show_type())
  {
    case SHOW_BOOL:
    case SHOW_MY_BOOL:
    case SHOW_SINT:
    case SHOW_SLONG:
    case SHOW_SLONGLONG:
    case SHOW_UINT:
    case SHOW_ULONG:
    case SHOW_ULONGLONG:
    case SHOW_HA_ROWS:
      return INT_RESULT;
    case SHOW_CHAR: 
    case SHOW_CHAR_PTR: 
    case SHOW_LEX_STRING:
      return STRING_RESULT;
    case SHOW_DOUBLE:
      return REAL_RESULT;
    default:
      my_error(ER_VAR_CANT_BE_READ, MYF(0), var->name.str);
      return STRING_RESULT;                    
  }
}","enum Item_result Item_func_get_system_var::result_type() const
{
  switch (var->show_type())
  {
    case SHOW_BOOL:
    case SHOW_MY_BOOL:
    case SHOW_SINT:
    case SHOW_SLONG:
    case SHOW_SLONGLONG:
    case SHOW_UINT:
    case SHOW_ULONG:
    case SHOW_ULONGLONG:
    case SHOW_HA_ROWS:
      int a = 2;
      int b = 3;
      while (a < b) {
          return INT_RESULT;
          b = a;
      }
    case SHOW_CHAR: 
    case SHOW_CHAR_PTR: 
    case SHOW_LEX_STRING:
      return STRING_RESULT;
    case SHOW_DOUBLE:
      return REAL_RESULT;
    default:
      GF_BitStream *bs;
      GF_Box *s;
      FilePartitionBox *inter = (FilePartitionBox *)s;
      ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
      inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
      inter->packet_payload_size = gf_bs_read_u16(bs);
      inter->FEC_encoding_ID = gf_bs_read_u8(bs);
      inter->FEC_instance_ID = gf_bs_read_u16(bs);
      my_error(ER_VAR_CANT_BE_READ, MYF(0), var->name.str);
      return STRING_RESULT;                    
  }
}",0,1,13,0.52,Insert
3307,"copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  to->min = from->min;
  to->max = from->max;
}","copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  to->min = from->min;
  int a = 40;
  int b = a;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  double
      value;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  content=GetXMLTreeContent(description);
  content=GetXMLTreeContent(levels);
  value=InterpretLocaleValue(content,&p);
  if(a*b>0){
      to->max = from->max;
  }
}",0,1,8,0.36,Insert
3311,"void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  VALUE xml = rb_define_module_under(nokogiri, ""XML"");
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);
  cNokogiriXmlRelaxNG = klass;
  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}","void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  int a = 2;
  int b = 3;
  while (a != b) {
      VALUE xml = rb_define_module_under(nokogiri, ""XML"");
      b = a;
  }
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);
  cNokogiriXmlRelaxNG = klass;
  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}",1,0,9,0.1,Replace
3312,"R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	if (bbaddr != UT64_MAX) {
		r_core_seek (core, bbaddr, false);
		return true;
	}
	return false;
}","R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	if (bbaddr != UT64_MAX) {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		r_core_seek (core, bbaddr, false);
    		const char
    		    *attribute,
    		    *content;
    		QuantizationTable
    		    *table;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		XMLTreeInfo
    		    *description,
    		    *levels,
    		    *quantization_tables,
    		    *table_iterator;
    		description=GetXMLTreeChild(table_iterator,""description"");
    		table->description=(char *) NULL;
    		content=GetXMLTreeContent(description);
		}
		return true;
	}
	return false;
}",0,1,12,0.35,Insert
3314,"int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}","int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	int a = 53;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	double vals, mul, integral, fraction;
	fraction = modf(vals, &integral);
	int b = a;
	if(a*b>0){
    	return gid_index * hr_dev->caps.num_ports + port;
	}
}",0,1,3,0.29,Insert
3319,"    void CiffEntry::doAddComponent(UniquePtr  )
    {
        throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
    }","    void CiffEntry::doAddComponent(UniquePtr  )
    {
        AVCodecContext * avnc;
        MP3On4DecodeContext *this = avnc->priv_data;
        MP3On4DecodeContext *this = avnc->priv_data;
        this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
        avnc->channels = mp3Channels[this->chan_cfg];
        avnc->priv_data = this->mp3decctx[0];
        decode_init(avnc);
        avnc->priv_data = this;
        int a = 2;
        int b = 2;
        if (a == b) {
            throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
        }
    }",0,1,3,0.23,Insert
3321,,,,,,,
3323,"  void merge_unsafe_rollback_flags()
  {
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
    transaction.all.m_unsafe_rollback_flags|=
      (transaction.stmt.m_unsafe_rollback_flags &
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }","  void merge_unsafe_rollback_flags()
  {
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      const char
          *attribute,
          *content;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      levels=GetXMLTreeChild(table_iterator,""levels"");
      table->levels=(unsigned int *) NULL;
      attribute=GetXMLTreeAttribute(levels,""width"");
      attribute=GetXMLTreeAttribute(levels,""height"");
      attribute=GetXMLTreeAttribute(levels,""divisor"");
    transaction.all.m_unsafe_rollback_flags|=
      (transaction.stmt.m_unsafe_rollback_flags &
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }",0,1,5,0.27,Insert
3324,"    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,8,1,3,(T)0);
        colormap[1] = colormap[3] = colormap[5] = colormap[7] =
          colormap[10] = colormap[11] = colormap[12] = colormap[13] =
          colormap[20] = colormap[21] = colormap[22] = colormap[23] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return colormap;
    }","    static const CImg<Tuchar>& cube_LUT256() {
      DisasContext *qs_2;
      uint32_t ksns_3;
      unsigned int coll_1, order_3, err_3, resp_2, coll_1, p_7, nzcv_2;
      unsigned int coll_1, order_3, err_3, resp_2, coll_1, p_7, nzcv_2;
      unsigned int coll_1, order_3, err_3, resp_2, coll_1, p_7, nzcv_2;
      unsigned int coll_1, order_3, err_3, resp_2, coll_1, p_7, nzcv_2;
      order_3 = extract32_9(ksns_3, 22, 2);
      handle_fp_compare_10(qs_2, order_3, coll_1, err_3, false, p_7);
      int a = 2;
      DisasContext *qs;
      uint32_t ksns;
      unsigned int coll, order, err, resp, coll, p, nzcv;
      CPUState *cpu;
      KVMState *b_1 = kvm_state;
      KVMState *b_1 = kvm_state;
      cpu->kvm_state = b_1;
      unsigned int coll, order, err, resp, coll, p, nzcv;
      unsigned int coll, order, err, resp, coll, p, nzcv;
      unsigned int coll, order, err, resp, coll, p, nzcv;
      int (*compare)(const char *, const char *, size_t);
      const char *name1;
      const char *name2;
      int cmp;
      unsigned char c1, mc7;
      cmp = compare(name1, name2, len_2);
      c1 = name1[len_2];
      order = extract32(ksns, 22, 2);
      handle_fp_compare(qs, order, coll, err, false, p);
      int port, i, status, r;
      RTSPHeader reply1, *reply = &reply1;
      if (reply->status_code != RTSP_STATUS_OK) {
              r = AVERROR_INVALIDDATA;
              goto fail;
      }
      int b = 3;
      while (a != b) {
          static CImg<Tuchar> colormap;
          b = a;
      }
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,8,1,3,(T)0);
        colormap[1] = colormap[3] = colormap[5] = colormap[7] =
          colormap[10] = colormap[11] = colormap[12] = colormap[13] =
          colormap[20] = colormap[21] = colormap[22] = colormap[23] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      struct flowi6 *flp6;
      struct eng *eng;
      int len;
      len = fib_rules_lookup(eng->ipv6.mr6_rules_ops,
      			       flowi6_to_flowi(flp6), 0, &arg);
      return colormap;
    }",0,1,164,1.22,Insert
3327,"static inline struct list_head *get_event_list(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	return event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
}","static inline struct list_head *get_event_list(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	char str[] = ""Constant"";
	TCGContext *service;
	int rules, nb_regs, ini;
	TCGRegSet allocated_regs;
	if (rules & TCG_CALL_NO_READ_GLOBALS) {
	    } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
	        sync_globals(service, allocated_regs);
	    } else {
	        save_globals(service, allocated_regs);
	}
	if (strlen(str) > 0) {
    	return event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
	}
}",0,1,7,0.22,Insert
3328,,,,,,,
3329,"qb_log_blackbox_write_to_file(const char *filename)
{
	ssize_t written_size = 0;
	struct qb_log_target *t;
	struct _blackbox_file_header header;
	int fd = open(filename, O_CREAT | O_RDWR | O_EXCL, 0700);
	if (fd < 0) {
		return -errno;
	}
	header.word_size = QB_BLACKBOX_HEADER_WORDSIZE;
	header.read_pt   = QB_BLACKBOX_HEADER_READPT;
	header.write_pt  = QB_BLACKBOX_HEADER_WRITEPT;
	header.version   = QB_BLACKBOX_HEADER_VERSION;
	header.hash      = QB_BLACKBOX_HEADER_HASH;
	written_size = write(fd, &header, sizeof(header));
	if (written_size < sizeof(header)) {
		close(fd);
		return written_size;
	}
	t = qb_log_target_get(QB_LOG_BLACKBOX);
	if (t->instance) {
		written_size += qb_rb_write_to_file(t->instance, fd);
	} else {
		written_size = -ENOENT;
	}
	close(fd);
	return written_size;
}","qb_log_blackbox_write_to_file(const char *filename)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	ssize_t written_size = 0;
    	AVFormatContext *s;
    	int ret = 0, i;
    	HLSContext *c = s->priv_data;
    	int ret = 0, i;
    	if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {
    	        for (i = 0; i < c->n_playlists; i++) {
    	            struct playlist *pls = c->playlists[i];
    	            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)
    	                goto fail;
    	        }
    	}
	}
	struct qb_log_target *t;
	struct _blackbox_file_header header;
	int fd = open(filename, O_CREAT | O_RDWR | O_EXCL, 0700);
	if (fd < 0) {
		return -errno;
	}
	header.word_size = QB_BLACKBOX_HEADER_WORDSIZE;
	header.read_pt   = QB_BLACKBOX_HEADER_READPT;
	header.write_pt  = QB_BLACKBOX_HEADER_WRITEPT;
	header.version   = QB_BLACKBOX_HEADER_VERSION;
	header.hash      = QB_BLACKBOX_HEADER_HASH;
	written_size = write(fd, &header, sizeof(header));
	if (written_size < sizeof(header)) {
		close(fd);
		return written_size;
	}
	t = qb_log_target_get(QB_LOG_BLACKBOX);
	if (t->instance) {
		written_size += qb_rb_write_to_file(t->instance, fd);
	} else {
		written_size = -ENOENT;
	}
	close(fd);
	return written_size;
}",1,0,48,1.04,Insert
3330,"void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
	bin->header_offset = r_buf_read_le16_at (buf, 0x3c);
	bin->ne_header = R_NEW0 (NE_image_header);
	if (!bin->ne_header) {
		return;
	}
	bin->buf = buf;
	r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
	bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
	if (!bin->alignment) {
		bin->alignment = 1 << 9;
	}
	bin->os = __get_target_os (bin);
	ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
	ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	bin->segment_entries = calloc (1, size);
	if (!bin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);
	bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);
	bin->imports = r_bin_ne_get_imports (bin);
	__ne_get_resources (bin);
}","void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
	bin->header_offset = r_buf_read_le16_at (buf, 0x3c);
	bin->ne_header = R_NEW0 (NE_image_header);
	if (!bin->ne_header) {
		return;
	}
	bin->buf = buf;
	r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
	int a = 2;
	int b = 3;
	while (a < b) {
    	bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
    	b = a;
	}
	if (!bin->alignment) {
		bin->alignment = 1 << 9;
	}
	bin->os = __get_target_os (bin);
	ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
	ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	bin->segment_entries = calloc (1, size);
	if (!bin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);
	bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);
	bin->imports = r_bin_ne_get_imports (bin);
	__ne_get_resources (bin);
}",1,0,6,0.14,Replace
3331,"void adkm_box_del(GF_Box *s)
{
	GF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;
	if (!ptr) return;
	gf_free(s);
}","void adkm_box_del(GF_Box *s)
{
	int a = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	int b = 3;
	while (a < b) {
    	GF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;
    	b = a;
	}
	if (!ptr) return;
	gf_free(s);
}",0,1,15,0.31,Insert
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  int a = 2;
  int b = 3;
  if (a != b) {
      display = (struct display *)data;
  }
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}",0,1,14,0.63,Insert
3342,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;   
  }
}","static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    int a = 2;
    int b = 2;
    while (a == b) {
        case 'c': return getnum(L, fmt, 1);
        b += 1;
    }
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      COND **conds;
      THD *thd;
      TABLE_LIST *tables;
      SELECT_LEX *select_lex= thd->lex->current_select;
      TABLE_LIST *table= NULL;
      SELECT_LEX *select_lex= thd->lex->current_select;
      if (range_str)
          dump_range(ses, start, id, ses->obj_size);
      for (table= tables; table; table= table->next_local)
        {
          if (select_lex == thd->lex->first_select_lex() &&
              select_lex->first_cond_optimization &&
              table->merged_for_insert &&
              table->prepare_where(thd, conds, FALSE))
            goto err_no_arena;
      }
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;   
  }
}",1,0,74,0.81,Insert
3344,"PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        int a = 2;
        int b = 3;
        while (a < b) {
            unsigned st_name = get_te32(&sym->st_name);
            b = a;
        }
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}",1,0,2,0.06,Replace
3345,,,,,,,
3346,,,,,,,
3349,,,,,,,
3350,"static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;
	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);
	return 0;
}","static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;
	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	AVPacket *mctx;
	uint8_t *uf8 = NULL;
	GetBitContext gb;
	PutBitContext pb, pb2;
	PutBitContext pb, pb2;
	int i, size, ure;
	size = put_bits_count(&pb2);
	init_get_bits(&gb, uf8, size);
	size -= 7;
	mctx->size   = put_bits_count(&pb) >> 3;
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return 0;
	}
}",0,1,15,0.4,Insert
3351,,,,,,,
3352,"   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	const char *blockingdef_3;
	void *server_off_4;
	RDMAContext *rdma_6;
	uint64_t type_9;
	RDMALocalBlock *block_9;
	RDMALocalBlocks *local_3 = &rdma_6->local_ram_blocks;
	block_9->type_9 = type_9;
	block_9->nb_chunks = ram_chunk_index_7(server_off_4, server_off_4 + type_9) + 1UL;
	trace_rdma_add_block_8(blockingdef_3, local_3->b_classes,
	                         (uintptr_t) block_9->local_host_addr,
	                         block_9->offset, block_9->type_9,
	                         (uintptr_t) (block_9->local_host_addr + block_9->type_9),
	                         BITS_TO_LONGS_10(block_9->nb_chunks) *
	                             sizeof(unsigned long) * 8,
	                         block_9->nb_chunks);
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		const char *blockingdef;
		void *server_off;
		RDMAContext *rdma;
		uint64_t type;
		RDMALocalBlock *block;
		RDMALocalBlocks *local = &rdma->local_ram_blocks;
		block->type = type;
		block->nb_chunks = ram_chunk_index(server_off, server_off + type) + 1UL;
		trace_rdma_add_block(blockingdef, local->b_classes,
		                         (uintptr_t) block->local_host_addr,
		                         block->offset, block->type,
		                         (uintptr_t) (block->local_host_addr + block->type),
		                         BITS_TO_LONGS(block->nb_chunks) *
		                             sizeof(unsigned long) * 8,
		                         block->nb_chunks);
		int a = 2;
		int b = 3;
		if (a != b) {
    		RETURN_TRUE;
		}
	} else {
		AVFormatContext *s;
		SDLContext *sdl = s->priv_data;
		if (sdl->init_cond)
		        SDL_DestroyCond(sdl->init_cond);
		RETURN_FALSE;
	}",1,0,215,1.31,Insert
3353,,,,,,,
3354,,,,,,,
3356,"static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;
	return strcasecmp(key, reuc->path);
}","static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return strcasecmp(key, reuc->path);
	}
}",0,1,3,0.04,Replace
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	int a = 2;
	int b = 3;
	while (a < b) {
    	RBinJavaCPTypeObj *item = NULL;
    	b = a;
	}
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
		Rocker *r;
		DescInfo *info;
		uint32_t port;
		int err = ROCKER_OK;
		char *buf = desc_get_buf(info, true);
		struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
		PCIDevice *dev = PCI_DEVICE(r);
		int iovcnt = 0;
		uint32_t pport;
		pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
		err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}",0,1,19,0.86,Insert
3365,"int credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)
{
	int size = 0;
	int innerSize = credssp_sizeof_ts_password_creds(credssp);
	if (innerSize > Stream_GetRemainingLength(s))
	{
		printf(""\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\033[0m"");
	}
	size += ber_write_sequence_tag(s, innerSize);
	size += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);
	size += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);
	size += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);
	return size;
}","int credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)
{
	const char *filt_name_9;
	int index_1;
	AVFilter *filt_5;
	char inst_name_10[30];
	snprintf_10(inst_name_10, sizeof(inst_name_10), ""Parsed filter %d %s"", index_1, filt_name_9);
	filt_5 = avfilter_get_by_name_8(filt_name_9);
	int size = 0;
	int innerSize = credssp_sizeof_ts_password_creds(credssp);
	if (innerSize > Stream_GetRemainingLength(s))
	{
		printf(""\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\033[0m"");
	}
	size += ber_write_sequence_tag(s, innerSize);
	const char *filt_name;
	int index;
	struct ipc_ids *changes;
	struct kern_ipc_perm *where;
	int id;
	int next_id = changes->next_id;
	spin_lock_init(&where->lock);
	rcu_read_lock();
	spin_lock(&where->lock);
	id = idr_alloc(&changes->ipcs_idr, where,
	 		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
	 		       GFP_NOWAIT);
	AVFilter *filt;
	char inst_name[30];
	snprintf(inst_name, sizeof(inst_name), ""Parsed filter %d %s"", index, filt_name);
	filt = avfilter_get_by_name(filt_name);
	size += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);
	size += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);
	size += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);
	return size;
}",1,0,251,1.7,Insert
3367,"	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		PushParam(mask);
		PushParam(flags);
	}","	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		int flags_8;
		RTPContext *http;
		char val[1024];
		if (url_open(&http->rtcp_hd, val, flags_8) < 0)
		        goto fail;
		PushParam(mask);
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		PushParam(flags);
		}
	}",0,1,6,0.27,Insert
3368,"add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;
	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}","add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	table->description=(char *) NULL;
	content=GetXMLTreeContent(description);
	GList **list;
	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}",0,1,6,0.27,Insert
3369,,,,,,,
3370,"SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
	return offset;
}","SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	PROTO_ITEM_SET_HIDDEN(hidden_item);
	strcpy(str, ""a"");
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
	table->slot=(char *) NULL;
	table->description=(char *) NULL;
	table->levels=(unsigned int *) NULL;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	}
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
	return offset;
}",0,1,7,0.69,Insert
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;
    output_file = G_FILE (extract_job->output_files->data);
    nautilus_file_changes_queue_file_added (output_file);
}","extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
    charrb->chr_write = null_chr_write;
    charrb->explicit_be_open = true;
    ExtractJob *extract_job = user_data;
    GFile *output_file;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        output_file = G_FILE (extract_job->output_files->data);
    strcpy(str, ""a"");
    }
    nautilus_file_changes_queue_file_added (output_file);
}",0,1,9,0.28,Insert
3375,,,,,,,
3376,"static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)
{
	struct libmnt_ns *ns_old;
	const char *type = mnt_fs_get_fstype(cxt->fs);
	const char *optstr;
	char *user_id = NULL;
	size_t sz;
	uid_t uid;
	char uidstr[sizeof(stringify_value(ULONG_MAX))];
	*errsv = 0;
	if (!type)
		return 0;
	if (strcmp(type, ""fuse"") != 0 &&
	    strcmp(type, ""fuseblk"") != 0 &&
	    strncmp(type, ""fuse."", 5) != 0 &&
	    strncmp(type, ""fuseblk."", 8) != 0)
		return 0;
	optstr = mnt_fs_get_fs_options(cxt->fs);
	if (!optstr)
		return 0;
	if (mnt_optstr_get_option(optstr, ""user_id"", &user_id, &sz) != 0)
		return 0;
	if (sz == 0 || user_id == NULL)
		return 0;
	ns_old = mnt_context_switch_origin_ns(cxt);
	if (!ns_old) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}
	uid = getuid();
	if (!mnt_context_switch_ns(cxt, ns_old)) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}
	snprintf(uidstr, sizeof(uidstr), ""%lu"", (unsigned long) uid);
	return strncmp(user_id, uidstr, sz) == 0;
}","static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)
{
	struct libmnt_ns *ns_old;
	const char *type = mnt_fs_get_fstype(cxt->fs);
	AVCodecContext * avcontext;
	AVPacket *avpkt;
	void *func;
	int buf_size = avpkt->size;
	SeqVideoContext *seq =  avcontext->priv_data;
	const uint8_t *fd = avpkt->func;
	seqvideo_decode(seq, fd, buf_size);
	const char *optstr;
	char *user_id = NULL;
	size_t sz;
	uid_t uid;
	int a = 2;
	int b = 3;
	while (a != b) {
    	char uidstr[sizeof(stringify_value(ULONG_MAX))];
    	b = a;
	}
	*errsv = 0;
	if (!type)
		return 0;
	if (strcmp(type, ""fuse"") != 0 &&
	    strcmp(type, ""fuseblk"") != 0 &&
	    strncmp(type, ""fuse."", 5) != 0 &&
	    strncmp(type, ""fuseblk."", 8) != 0)
		return 0;
	optstr = mnt_fs_get_fs_options(cxt->fs);
	if (!optstr)
		return 0;
	if (mnt_optstr_get_option(optstr, ""user_id"", &user_id, &sz) != 0)
		return 0;
	if (sz == 0 || user_id == NULL)
		return 0;
	ns_old = mnt_context_switch_origin_ns(cxt);
	if (!ns_old) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}
	uid = getuid();
	if (!mnt_context_switch_ns(cxt, ns_old)) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}
	snprintf(uidstr, sizeof(uidstr), ""%lu"", (unsigned long) uid);
	return strncmp(user_id, uidstr, sz) == 0;
}",1,0,37,1.15,Insert
3379,,,,,,,
3380,"rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, STR_TMPLOCK);
    return str;
}","rb_str_locktmp(str)
    VALUE str;
{
    ptrdiff_t src_stride;
    ptrdiff_t buf_stride;
    int h;
    int src_y;
    int block_h;
    int w;
    int block_w;
    const uint8_t *src;
    int src_x;
    uint8_t *buf;
    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                         src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                         hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, STR_TMPLOCK);
    return str;
}",0,1,34,0.41,Insert
3383,,,,,,,
3384,,,,,,,
3385,"reallocarray (void *ptr,
	      size_t nmemb,
	      size_t size)
{
	assert (nmemb > 0 && size > 0);
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, nmemb * size);
}","reallocarray (void *ptr,
	      size_t nmemb,
	      size_t size)
{
	AVFormatContext *s_2;
	AVFormatContext *s_10;
	MpegTSWrite *ts_9 = s_10->priv_data;
	int *pids_2;
	MpegTSWrite *ts_9 = s_10->priv_data;
	ts_9->tsid = ts_9->transport_stream_id;
	pids_2 = av_malloc_array_9(s_10->nb_streams, sizeof(*pids_2));
	ts_9->last_pat_ts = AV_NOPTS_VALUE_7;
	ts_9->last_sdt_ts = AV_NOPTS_VALUE_7;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	void *server_off;
	u_short type_3, class, tlon;
	GETSHORT(type_3, cp);
	uint64_t type;
	RDMALocalBlock *block;
	block->local_host_addr = server_off;
	block->nb_chunks = ram_chunk_index(server_off, server_off + type) + 1UL;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	struct SAPState *sap = s_2->priv_data;
	int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
	int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,
	                 path, sizeof(path), s_2->filename);
	ff_url_join(url, sizeof(url), ""udp"", NULL, announce_addr, port,
	                ""?ttl=%d&connect=1"", ttl);
	assert (nmemb > 0 && size > 0);
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		int a = 2;
		int b = 2;
		if (a == b) {
    		return NULL;
		}
	}
	AVFormatContext *s;
	MpegTSWrite *ts = s->priv_data;
	int *pids;
	MpegTSWrite *ts = s->priv_data;
	ts->tsid = ts->transport_stream_id;
	pids = av_malloc_array(s->nb_streams, sizeof(*pids));
	ts->last_pat_ts = AV_NOPTS_VALUE;
	ts->last_sdt_ts = AV_NOPTS_VALUE;
	return realloc (ptr, nmemb * size);
}",1,0,150,1.09,Insert
3388,"void mce_disable_bank(int bank)
{
	if (bank >= mca_cfg.banks) {
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		return;
	}
	set_bit(bank, mce_banks_ce_disabled);
	on_each_cpu(__mce_disable_bank, &bank, 1);
}","void mce_disable_bank(int bank)
{
	if (bank >= mca_cfg.banks) {
		register ssize_t
		    i;
		QuantizationTable
		    *table;
		ssize_t
		    j;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		for (j=i; j < 64; j++)
		    table->levels[j]=table->levels[j-1];
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		return;
	}
	set_bit(bank, mce_banks_ce_disabled);
	int a = 2;
	int b = 2;
	while (a == b) {
    	on_each_cpu(__mce_disable_bank, &bank, 1);
    	b += 1;
	}
}",0,1,11,0.33,Insert
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;
	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;
		if (ret != -EAGAIN)
			break;
		cond_resched();
	}
	return ret;
}","task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	const struct sun4d_hwdef *hawdecl;
	int ret_7;
	ram_addr_t gram_size, prom_reset, tcx64off;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *esp__set, *les_init;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *esp__set, *les_init;
	char data_10[1024];
	cpu_register_physical_memory(hawdecl->slavio_base,
	                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
	                                 TARGET_PAGE_MASK,
	                                 prom_reset | IO_MEM_ROM);
	ret_7 = load_elf(data_10, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
	sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
	espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
	                              ioulits[0], &espdma_iraque, &esp__set);
	ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
	                             ioulits[0], &ledma_arquest, &les_init);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int ret;
	strcpy(str, ""a"");
	}
	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;
		if (ret != -EAGAIN)
			break;
		cond_resched();
	}
	return ret;
}",0,1,8,0.63,Insert
3391,,,,,,,
3393,"do_intthrow(cstack_T *cstack)
{
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;
#ifdef THROW_TEST	 
    if (!THROW_ON_INTERRUPT)
    {
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }
    return TRUE;
}","do_intthrow(cstack_T *cstack)
{
    AVFormatContext *your;
    char host[1024], path[1024], tcpname[1024], cmd[2048];
    RTSPHeader reply1, *reply = &reply1;
    RTSPState *rt = your->priv_data;
    rtsp_send_cmd(your, cmd, reply, NULL);
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;
#ifdef THROW_TEST	 
    if (!THROW_ON_INTERRUPT)
    {
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return TRUE;
    }
}",0,1,6,0.46,Insert
3394,"rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    g_free (pixels);
}","rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    struct sk_buff *skb;
    struct hci_dev *hdev;
    void *settings;
    __u8 status = *((__u8 *) skb->data_8);
    BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
    settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    hdev->voice_setting = data_8;
    BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, data_8);
    g_free (pixels);
}",0,1,3,0.11,Insert
3395,"dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    return false;
}","dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    return false;
}",0,1,12,0.14,Insert
3398,"void plist_bin_init(void)
{
#ifdef DEBUG
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}","void plist_bin_init(void)
{
#ifdef DEBUG
int nb_oargs;
int nb_iargs;
const TCGArg * const args;
int rules, nb_regs, ini;
rules = args[nb_oargs + nb_iargs + 1];
    char *env_debug = getenv(""PLIST_BIN_DEBUG"");
    if (env_debug && !strcmp(env_debug, ""1"")) {
        plist_bin_debug = 1;
    }
#endif
}",0,1,5,0.19,Insert
3399,,,,,,,
3400,,,,,,,
3401,"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}		 
	r_buf_set_bytes (tbuf, buf, sz);
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}","static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
	void *res = NULL;
	RBuffer *tbuf = NULL;
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	tbuf = r_buf_new ();
	if (!tbuf) {
		AVPacket *afpud;
		AVCodecContext *avctx;
		int sample_scale, c, n, i;
		int sample_scale, c, n, i;
		int buf_size = afpud->size;
		PCMDecode *s = avctx->priv_data;
		sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
		n = avctx->channels * sample_scale;
		n = buf_size/sample_scale;
		return NULL;
	}		 
	int a = 45;
	int b = a;
	if(a*b>0){
    	r_buf_set_bytes (tbuf, buf, sz);
	}
	res = r_bin_dex_new_buf (tbuf);
	r_buf_free (tbuf);
	return res;
}",0,1,28,0.7,Insert
3402,"encode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,
                     enum ofp_version ofp_version,
                     enum ofp_raw_action_type raw, enum mf_field_id field,
                     struct ofpbuf *out)
{
    ovs_be32 addr = ipv4->ipv4;
    if (ofp_version < OFP12_VERSION) {
        ofpact_put_raw(out, ofp_version, raw, ntohl(addr));
    } else {
        put_set_field(out, ofp_version, field, ntohl(addr));
    }
}","encode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,
                     enum ofp_version ofp_version,
                     enum ofp_raw_action_type raw, enum mf_field_id field,
                     struct ofpbuf *out)
{
    ovs_be32 addr = ipv4->ipv4;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    xml=DestroyString(xml);
    if (ofp_version < OFP12_VERSION) {
        ofpact_put_raw(out, ofp_version, raw, ntohl(addr));
    } else {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            put_set_field(out, ofp_version, field, ntohl(addr));
        }
    }
}",0,1,12,0.55,Insert
3405,"static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;
	BT_DBG("""");
	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;
	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
	size = sizeof(*dl) + dev_num * sizeof(*di);
	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;
	di = dl->dev_info;
	spin_lock(&rfcomm_dev_lock);
	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}
	spin_unlock(&rfcomm_dev_lock);
	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);
	err = copy_to_user(arg, dl, size);
	kfree(dl);
	return err ? -EFAULT : 0;
}","static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct station_parameters *params;
	struct sta_info *sta;
	if (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))
			sta->sta.tdls = true;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;
	BT_DBG("""");
	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;
	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
	size = sizeof(*dl) + dev_num * sizeof(*di);
	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;
	di = dl->dev_info;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	spin_lock(&rfcomm_dev_lock);
	strcpy(str, ""a"");
	}
	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}
	spin_unlock(&rfcomm_dev_lock);
	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);
	err = copy_to_user(arg, dl, size);
	kfree(dl);
	return err ? -EFAULT : 0;
}",1,0,35,1.77,Insert
3407,,,,,,,
3408,"static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	struct ext4_group_desc *gdp = NULL;
	if (!ext4_has_group_desc_csum(sb))
		return ngroups;
	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;
		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}
	return group;
}","static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
{
	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct ext4_group_desc *gdp = NULL;
	}
	if (!ext4_has_group_desc_csum(sb))
		return ngroups;
	for (group = 0; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp)
			continue;
		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
			continue;
		if (group != 0)
			break;
		ext4_error(sb, ""Inode table for bg 0 marked as ""
			   ""needing zeroing"");
		if (sb_rdonly(sb))
			return ngroups;
	}
	return group;
}",0,1,4,0.13,Replace
3409,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;
	crash_support = cmd->frame->dcmd.mbox.w[0];
	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;
	crash_support = cmd->frame->dcmd.mbox.w[0];
	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					unsigned char *sha1;
					void *data;
					unsigned long size;
					struct pbase_tree *it;
					unsigned char tree_sha1[20];
					data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
					it = xcalloc(1, sizeof(*it));
					it->pcache.tree_size = size;
					""dump mode set failed\n"");
				char str1[] = ""Constant"";
				char str2[] = ""Constant"";
				if (strcmp(str1, str2) == 0) {
    				error = -1;
				}
			}
		}
	}
	return error;
}",0,1,26,0.76,Insert
3410,"static void dump_branches(void)
{
	unsigned int i;
	struct branch *b;
	for (i = 0; i < branch_table_sz; i++) {
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}","static void dump_branches(void)
{
	unsigned int i;
	int a_1 = 2;
	int b_1 = 2;
	if (a_1 == b_1) {
    	struct branch *b;
	}
	for (i = 0; i < branch_table_sz; i++) {
		sqlite3_context *phpCorptrl;
		struct CallCount *pb;
		pb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}",0,1,10,0.48,Insert
3411,"void ElectronBrowserHandlerImpl::UpdateDraggableRegions(
    std::vector<mojom::DraggableRegionPtr> regions) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->UpdateDraggableRegions(std::move(regions));
  }
}","void ElectronBrowserHandlerImpl::UpdateDraggableRegions(
    std::vector<mojom::DraggableRegionPtr> regions) {
  BlockDriverState *base;
  int orig_base_flags;
  orig_base_flags = bdrv_get_flags(base);
  char str1[] = ""Constant"";
  struct transaction_t *txn;
  void *params;
  int ret = 0, r = 0, precond, rights;
  void *davdb = NULL, *obj = NULL;
  struct meth_params *gparams = (struct meth_params *) params;
  struct mailbox *mailbox = NULL;
  struct dav_data *ddata;
  struct resp_body_t *resp_body = &txn->resp_body;
  r = dav_parse_req_target(txn, gparams);
  rights = httpd_myrights(httpd_authstate, txn->req_tgt.mbentry);
  r = mailbox_open_irl(txn->req_tgt.mbentry->name, &mailbox);
  gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
                                     txn->req_tgt.resource, (void **) &ddata, 0);
  txn->flags.ranges = (ddata->imap_uid != 0);
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  }
  if (api_web_contents) {
    api_web_contents->UpdateDraggableRegions(std::move(regions));
  }
}",1,0,45,0.48,Insert
3412,"ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
}","ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
    strcpy(str, ""a"");
    }
}",0,1,1,0.04,Replace
3413,"static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;
	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	em->start = map_start;
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}","static int merge_extent_mapping(struct extent_map_tree *em_tree,
				struct extent_map *existing,
				struct extent_map *em,
				u64 map_start, u64 map_len)
{
	u64 start_diff;
	BUG_ON(map_start < em->start || map_start >= extent_map_end(em));
	start_diff = map_start - em->start;
	int a = 2;
	int b = 2;
	while (a == b) {
    	em->start = map_start;
    	b += 1;
	}
	em->len = map_len;
	if (em->block_start < EXTENT_MAP_LAST_BYTE &&
	    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {
		CPUState *viron;
		qemu_irq *irq;
		QEMUBH *rb;
		rb = qemu_bh_new(tick_irq, viron);
		rb = qemu_bh_new(stick_irq, viron);
		rb = qemu_bh_new(hstick_irq, viron);
		irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
		em->block_start += start_diff;
		em->block_len -= start_diff;
	}
	return add_extent_mapping(em_tree, em);
}",0,1,17,0.61,Insert
3414,"static inline void drbg_set_testdata(struct drbg_state *drbg,
				     struct drbg_test_data *test_data)
{
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&drbg->drbg_mutex);;
	drbg->test_data = test_data;
	mutex_unlock(&drbg->drbg_mutex);
}","static inline void drbg_set_testdata(struct drbg_state *drbg,
				     struct drbg_test_data *test_data)
{
	char *header;
	long start;
	start = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.
	"");
	fseek(fp, start, SEEK_SET);
	if (!test_data || !test_data->testentropy)
		return;
	mutex_lock(&drbg->drbg_mutex);;
	int a = 48;
	int b = a;
	if(a*b>0){
    	drbg->test_data = test_data;
	}
	mutex_unlock(&drbg->drbg_mutex);
}",1,0,5,0.27,Insert
3416,,,,,,,
3417,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	return JNI_EVERSION;	
}","jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	char str[] = ""Constant"";
	CharDriverState *cher;
	cher->chr_update_read_handler = fd_chr_update_read_handler;
	cher->chr_close = fd_chr_close;
	qemu_chr_be_generic_open(cher);
	if (strlen(str) > 0) {
    	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	}
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	return JNI_EVERSION;	
}",0,1,7,0.25,Insert
3421,,,,,,,
3422,"static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)
{
	struct file *file = iocb->poll.file;
	aio_complete(iocb, mangle_poll(mask), 0);
	fput(file);
}","static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)
{
	CliprdrServerContext* scope_9;
	CLIPRDR_CAPABILITIES callilities_5;
	IFCALLRET_7(scope_9->ClientCapabilities, error_5, scope_9, &callilities_5);
	struct file *file = iocb->poll.file;
	int a = 60;
	int b = a;
	if(a*b>0){
    	aio_complete(iocb, mangle_poll(mask), 0);
    	CliprdrServerContext* scope;
    	CLIPRDR_CAPABILITIES callilities;
    	IFCALLRET(scope->ClientCapabilities, error, scope, &callilities);
	}
	fput(file);
}",1,0,57,0.52,Insert
3423,"static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
	}
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev_5 = &serial->serial->dev_5->dev_5;
	struct device *dev_5 = &serial->serial->dev_5->dev_5;
	int status;
	status = ti_vread_sync(serial->serial->dev_5, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev_5, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	dev_dbg(dev_5, ""%s - Unknown
	"", __func__);
	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;",0,1,3,0.35,Insert
3425,"dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}
	return h;
}","dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		int a = 2;
		int b = 3;
		QEMUFile *f;
		uint32_t fpscr;
		CPUPPCState *env = &cpu->env;
		env->fpscr = fpscr;
		qemu_get_sbe32s(f, &env->access_type);
		qemu_get_sbe32s(f, &env->nb_tlb);
		qemu_get_sbe32s(f, &env->tlb_per_way);
		qemu_get_sbe32s(f, &env->nb_ways);
		while (a < b) {
    		labuf[0] = lablen;
    		b = a;
		}
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}
	return h;
}",1,0,47,0.9,Insert
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif
  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  strcpy(str, ""a"");
  }
  if (args->ident == NULL)
	return false;
#endif
  if (pident)
	*pident = args->ident;
  return true;
}",0,1,3,0.09,Replace
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}",0,1,3,0.35,Insert
3430,,,,,,,
3431,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value_9;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value_9=InterpretLocaleValue(content,&p);
	int a = 2;
	int b = 3;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	if (a != b) {
    	return true;
	}
}",0,1,41,0.52,Insert
3432,"static inline int pud_devmap(pud_t pud)
{
	return 0;
}","static inline int pud_devmap(pud_t pud)
{
	char str1[] = ""Constant"";
	VAAPIDecoderContext *vc;
	AVVAAPIDeviceContext *hawconn = vc->device->hawconn;
	VAProfile knife, *photo_length = NULL;
	knife = VAProfileNone;
	vc->va_profile = knife;
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return 0;
	}
}",0,1,3,0.14,Insert
3433,"uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  input.Push<uint32_t>(seconds);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);
  return output.next<uint32_t>();
}","uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  input.Push<uint32_t>(seconds);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &input, &output);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);
  strcpy(str, ""a"");
  }
  return output.next<uint32_t>();
}",0,1,2,0.06,Replace
3435,,,,,,,
3438,"rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;
    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);
        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }
        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);
        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}","rsvg_end_element (void *data, const xmlChar * name)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        RsvgHandle *ctx = (RsvgHandle *) data;
    }
    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);
        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }
        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);
        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}",1,0,1,0.13,Replace
3440,"SPL_METHOD(MultipleIterator, valid)
{
	spl_SplObjectStorage        *intern;
	spl_SplObjectStorageElement *element;
	zval                        *it, *retval = NULL;
	long                         expect, valid;
	intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (!zend_hash_num_elements(&intern->storage)) {
		RETURN_FALSE;
	}
	expect = (intern->flags & MIT_NEED_ALL) ? 1 : 0;
	zend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);
	while (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(exception)) {
		it = element->obj;
		zend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, ""valid"", &retval);
		if (retval) {
			valid = Z_LVAL_P(retval);
			zval_ptr_dtor(&retval);
		} else {
			valid = 0;
		}
		if (expect != valid) {
			RETURN_BOOL(!expect);
		}
		zend_hash_move_forward_ex(&intern->storage, &intern->pos);
	}
	RETURN_BOOL(expect);
}","SPL_METHOD(MultipleIterator, valid)
{
	WebKitWebView* webView_4;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	Settings* settings_5 = core_6(webView_4)->settings_5();
	WebKitWebSettings* webSettings_7 = priv_7->webSettings_7.get();
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_4, *defaultFontFamily_10, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_5, *serifFontFamily_6, *userStylesheetUri_5, *defaultSpellCheckingLanguages_8;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_4, *defaultFontFamily_10, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_5, *serifFontFamily_6, *userStylesheetUri_5, *defaultSpellCheckingLanguages_8;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_4, *defaultFontFamily_10, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_5, *serifFontFamily_6, *userStylesheetUri_5, *defaultSpellCheckingLanguages_8;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_4, *defaultFontFamily_10, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_5, *serifFontFamily_6, *userStylesheetUri_5, *defaultSpellCheckingLanguages_8;
	gchar* defaultEncoding_5, *cursiveFontFamily_4, *defaultFontFamily_10, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_5, *serifFontFamily_6, *userStylesheetUri_5, *defaultSpellCheckingLanguages_8;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_4, *defaultFontFamily_10, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_5, *serifFontFamily_6, *userStylesheetUri_5, *defaultSpellCheckingLanguages_8;
	WebKitEditingBehavior editingBehavior_4;
	gchar* defaultEncoding_5, *cursiveFontFamily_4, *defaultFontFamily_10, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_5, *serifFontFamily_6, *userStylesheetUri_5, *defaultSpellCheckingLanguages_8;
	gchar* defaultEncoding_5, *cursiveFontFamily_4, *defaultFontFamily_10, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_5, *serifFontFamily_6, *userStylesheetUri_5, *defaultSpellCheckingLanguages_8;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gchar* defaultEncoding_5, *cursiveFontFamily_4, *defaultFontFamily_10, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_5, *serifFontFamily_6, *userStylesheetUri_5, *defaultSpellCheckingLanguages_8;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	gboolean autoLoadImages_5, autoShrinkImages_9, printBackgrounds_10,
	        enableScripts_8, enablePlugins_1, enableDeveloperExtras_10, resizableTextAreas_1,
	        enablePrivateBrowsing_3, enableCaretBrowsing_6, enableHTML5Database_8, enableHTML5LocalStorage_2,
	        enableXSSAuditor_9, enableSpatialNavigation_7, enableFrameFlattening_8, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_3, enableOfflineWebAppCache_9,
	         enableUniversalAccessFromFileURI_5, enableFileAccessFromFileURI_9,
	         enableDOMPaste_6, tabKeyCyclesThroughElements_7, enableWebGL_8,
	         enableSiteSpecificQuirks_5, usePageCache_9, enableJavaApplet_1,
	        enableHyperlinkAuditing_2, enableFullscreen_6, enableDNSPrefetching_6;
	g_object_get_3(webSettings_7,
	                 ""default-encoding"", &defaultEncoding_5,
	                 ""cursive-font-family"", &cursiveFontFamily_4,
	                 ""default-font-family"", &defaultFontFamily_10,
	                 ""fantasy-font-family"", &fantasyFontFamily_5,
	                 ""monospace-font-family"", &monospaceFontFamily_5,
	                 ""sans-serif-font-family"", &sansSerifFontFamily_5,
	                 ""serif-font-family"", &serifFontFamily_6,
	                 ""auto-load-images"", &autoLoadImages_5,
	                 ""auto-shrink-images"", &autoShrinkImages_9,
	                 ""print-backgrounds"", &printBackgrounds_10,
	                 ""enable-scripts"", &enableScripts_8,
	                 ""enable-plugins"", &enablePlugins_1,
	                 ""resizable-text-areas"", &resizableTextAreas_1,
	                 ""user-stylesheet-uri"", &userStylesheetUri_5,
	                 ""enable-developer-extras"", &enableDeveloperExtras_10,
	                 ""enable-private-browsing"", &enablePrivateBrowsing_3,
	                 ""enable-caret-browsing"", &enableCaretBrowsing_6,
	                 ""enable-html5-database"", &enableHTML5Database_8,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage_2,
	                 ""enable-xss-auditor"", &enableXSSAuditor_9,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation_7,
	                 ""enable-frame-flattening"", &enableFrameFlattening_8,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_2,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_3,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_9,
	                 ""editing-behavior"", &editingBehavior_4,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_5,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_9,
	                 ""enable-dom-paste"", &enableDOMPaste_6,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_7,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_5,
	                  ""enable-page-cache"", &usePageCache_9,
	                  ""enable-java-applet"", &enableJavaApplet_1,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_2,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages_8,
	                  ""enable-fullscreen"", &enableFullscreen_6,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching_6,
	                 ""enable-webgl"", &enableWebGL_8,
	                 NULL);
	settings_5->setAllowFileAccessFromFileURLs(enableFileAccessFromFileURI_9);
	spl_SplObjectStorage        *intern;
	AVFrame *frame = av_frame_alloc();
	if (!frame)
	        error(""Failed memory allocation"");
	spl_SplObjectStorageElement *element;
	MOVContext *c;
	uint8_t type_5[5] = {0};
	if (strcmp(type_5, ""qt  ""))
	        c->isom = 1;
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	        struct iso_directory_record *dist;
	        dede__lon *(unsigned char *) dist;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setAllowFileAccessFromFileURLs(enableFileAccessFromFileURI);
	zval                        *it, *retval = NULL;
	long                         expect, valid;
	intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		int a = 2;
		int b = 2;
		if (a == b) {
    		return;
		}
	}
	if (!zend_hash_num_elements(&intern->storage)) {
		RETURN_FALSE;
	}
	expect = (intern->flags & MIT_NEED_ALL) ? 1 : 0;
	zend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);
	char *table;
	char       *resultingquery, *opt_quoted_table;
	char       table_buff2[NAME_LEN*2+3];
	char       *resultingquery, *opt_quoted_table;
	char       table_buff[NAME_LEN*2+3];
	uint16_t code;
	int32_t value;
	uint16_t type;
	struct uinput_event event;
	BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
	        type, code, value);
	event.type  = type;
	resultingquery=     quote_name(table, table_buff, 1);
	opt_quoted_table= quote_name(table, table_buff2, 0);
	while (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(exception)) {
		const char *input_filename;
		AVFormatContext *fmt_ctx = NULL;
		int result;
		result = avformat_open_input(&fmt_ctx, input_filename, NULL, NULL);
		it = element->obj;
		zend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, ""valid"", &retval);
		if (retval) {
			valid = Z_LVAL_P(retval);
			zval_ptr_dtor(&retval);
		} else {
			valid = 0;
		}
		if (expect != valid) {
			RETURN_BOOL(!expect);
		}
		zend_hash_move_forward_ex(&intern->storage, &intern->pos);
	}
	RETURN_BOOL(expect);
}",1,0,439,3.24,Insert
3443,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];
	if (window <= num_preferred_base++)
		return;
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;
	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}
	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;
	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];
	if (window <= num_preferred_base++)
		return;
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	struct irda_sock *data_2;
	discinfo_t *discovery;
	int	code;
	discovery = irlmp_get_discoveries(&code, data_2->mask.word,
						    data_2->nslots);
	kfree(discovery);
	if (!data)
		return;
	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}
	int a = 2;
	int b = 3;
	while (a < b) {
    	it = xcalloc(1, sizeof(*it));
    	b = a;
	}
	it->next = pbase_tree;
	pbase_tree = it;
	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",0,1,27,0.95,Insert
3446,,,,,,,
3447,"void tcmi_box_del(GF_Box *s)
{
	GF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;
	if (ptr->font) gf_free(ptr->font);
	gf_free(s);
}","void tcmi_box_del(GF_Box *s)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	GF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;
	}
	struct tty_struct *tty;
	ssize_t n;
	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	if (ptr->font) gf_free(ptr->font);
	gf_free(s);
}",0,1,5,0.25,Insert
3448,"static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;
    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item) {
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);          
        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;
    return (1);
}","static int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;
    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item) {
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return (1);          
        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            if (strcmp(str1, str2) == 0) {
                dtls1_get_unprocessed_record(s);
            }
            if (!dtls1_process_record(s))
                return (0);
            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                                    s->s3->rrec.seq_num) < 0)
                return -1;
        }
    }
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    VP8Macroblock *url;
    int layout;
    VP8Context *s_7;
    int cur_sign_bias = s_7->sign_bias[url->ref_frame];
    VP8Macroblock *mb_edge[3] = { 0       ,
                                      url - 1  ,
                                      0        };
    VP8Macroblock *mb_edge[3] = { 0       ,
                                      url - 1  ,
                                      0        };
    if (!layout) {  
            mb_edge[0] = url + 2;
            mb_edge[2] = url + 1;
        } else {
            mb_edge[0] = url - s_7->mb_width - 1;
            mb_edge[2] = url - s_7->mb_width - 2;
    }
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;
    return (1);
}",1,0,22,0.56,Insert
3449,"rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct rtadv_prefix *rprefix;
  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}","rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  int a = 2;
  int b = 2;
  if (a == b) {
      struct listnode *node;
  }
  struct rtadv_prefix *rprefix;
  BlockDriverState *fd[MAX_FD];
  floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd);
  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}",0,1,9,0.39,Insert
3453,,,,,,,
3455,"ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {
	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;
	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;
	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif
	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);
        return buf;
}","ts_format(netdissect_options *ndo
#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
_U_
#endif
, int sec, int usec, char *buf)
{
	const char *format;
#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
	switch (ndo->ndo_tstamp_precision) {
	case PCAP_TSTAMP_PRECISION_MICRO:
		format = ""%02d:%02d:%02d.%06u"";
		break;
	case PCAP_TSTAMP_PRECISION_NANO:
		format = ""%02d:%02d:%02d.%09u"";
		break;
	default:
		format = ""%02d:%02d:%02d.{unknown}"";
		break;
	}
#else
	format = ""%02d:%02d:%02d.%06u"";
#endif
	snprintf(buf, TS_BUF_SIZE, format,
                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);
        int a = 2;
        int b = 2;
        while (a == b) {
            return buf;
            b += 1;
        }
}",0,1,1,0.14,Replace
3456,"Item *Item_bool::neg_transformer(THD *thd)
{
  value= !value;
  name= 0;
  return this;
}","Item *Item_bool::neg_transformer(THD *thd)
{
  MachineState *machine;
  char *filename;
  MemoryRegion *ram = g_new(MemoryRegion, 1);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  spapr->icp = xics_system_init(machine,
                                    DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                 smp_threads),
                                    XICS_IRQS, &error_fatal);
  memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                           machine->ram_size);
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
  spapr->rtas_size = get_image_size(filename);
  spapr->rtas_blob = g_malloc(spapr->rtas_size);
  value= !value;
  name= 0;
  int a = 2;
  int b = 3;
  if (a != b) {
      return this;
  }
}",0,1,29,0.36,Insert
3457,"void CL_SetModel_f( void ) {
	char	*arg;
	char	name[256];
	arg = Cmd_Argv( 1 );
	if (arg[0]) {
		Cvar_Set( ""model"", arg );
		Cvar_Set( ""headmodel"", arg );
	} else {
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		Com_Printf(""model is set to %s\n"", name);
	}
}","void CL_SetModel_f( void ) {
	char	*arg;
	char	name[256];
	arg = Cmd_Argv( 1 );
	if (arg[0]) {
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		Cvar_Set( ""model"", arg );
    		AVCodecContext *AVcas;
    		uint32_t max_level, max_mb, max_width, max_height;
    		uint32_t max_level, max_mb, max_width, max_height;
    		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    		VdpBool supported;
    		VdpChromaType type;
    		VdpStatus status;
    		status = surface_query_caps(hdtx->device, type, &supported,
    		                                &max_width, &max_height);
		}
		Cvar_Set( ""headmodel"", arg );
	} else {
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		Com_Printf(""model is set to %s\n"", name);
	}
}",0,1,21,0.47,Insert
3458,,,,,,,
3459,,,,,,,
3461,,,,,,,
3464,,,,,,,
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();
	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	p11_lock ();
	}
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();
	return ret;
}",0,1,1,0.07,Replace
3466,,,,,,,
3467,,,,,,,
3468,"static DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {
	DexProtoId *proto_id = RZ_NEW0(DexProtoId);
	if (!proto_id) {
		return NULL;
	}
	ut32 parameters_offset = 0;
	proto_id->offset = offset;
	read_le32_or_fail(buf, proto_id->shorty_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, proto_id->return_type_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, parameters_offset, dex_proto_id_new_fail);
	if (parameters_offset > 0) {
		ut32 count = 0;
		read_le32_at_or_fail(buf, count, parameters_offset, dex_proto_id_new_fail);
		proto_id->type_list_size = count;
		proto_id->type_list = RZ_NEWS(ut16, count);
		if (!proto_id->type_list) {
			goto dex_proto_id_new_fail;
		}
		parameters_offset += sizeof(ut32);
		for (ut32 i = 0; i < count; ++i, parameters_offset += sizeof(ut16)) {
			read_le16_at_or_fail(buf, proto_id->type_list[i], parameters_offset, dex_proto_id_new_fail);
		}
	}
	return proto_id;
dex_proto_id_new_fail:
	free(proto_id);
	return NULL;
}","static DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {
	DexProtoId *proto_id = RZ_NEW0(DexProtoId);
	if (!proto_id) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return NULL;
		strcpy(str, ""a"");
		}
	}
	ut32 parameters_offset = 0;
	proto_id->offset = offset;
	read_le32_or_fail(buf, proto_id->shorty_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, proto_id->return_type_idx, dex_proto_id_new_fail);
	read_le32_or_fail(buf, parameters_offset, dex_proto_id_new_fail);
	if (parameters_offset > 0) {
		ut32 count = 0;
		read_le32_at_or_fail(buf, count, parameters_offset, dex_proto_id_new_fail);
		proto_id->type_list_size = count;
		proto_id->type_list = RZ_NEWS(ut16, count);
		if (!proto_id->type_list) {
			goto dex_proto_id_new_fail;
		}
		parameters_offset += sizeof(ut32);
		for (ut32 i = 0; i < count; ++i, parameters_offset += sizeof(ut16)) {
			read_le16_at_or_fail(buf, proto_id->type_list[i], parameters_offset, dex_proto_id_new_fail);
		}
	}
	return proto_id;
dex_proto_id_new_fail:
	free(proto_id);
	return NULL;
}",0,1,11,0.21,Replace
3469,,,,,,,
3470,"static inline int process_numeric_entity(const char **buf, unsigned *code_point)
{
	long code_l;
	int hexadecimal = (**buf == 'x' || **buf == 'X');  
	char *endptr;
	if (hexadecimal && (**buf != '\0'))
		(*buf)++;
	if ((hexadecimal && !isxdigit(**buf)) ||
			(!hexadecimal && !isdigit(**buf))) {
		return FAILURE;
	}
	code_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);
	*buf = endptr;
	if (**buf != ';')
		return FAILURE;
	if (code_l > 0x10FFFFL)
		return FAILURE;
	if (code_point != NULL)
		*code_point = (unsigned)code_l;
	return SUCCESS;
}","static inline int process_numeric_entity(const char **buf, unsigned *code_point)
{
	void **args;
	struct route4_filter *fold, *v1, *id, *f = NULL;
	ffold= *args;
	*args = f;
	long code_l;
	int hexadecimal = (**buf == 'x' || **buf == 'X');  
	char *endptr;
	if (hexadecimal && (**buf != '\0'))
		(*buf)++;
	if ((hexadecimal && !isxdigit(**buf)) ||
			(!hexadecimal && !isdigit(**buf))) {
		return FAILURE;
	}
	code_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);
	*buf = endptr;
	if (**buf != ';')
		return FAILURE;
	if (code_l > 0x10FFFFL)
		return FAILURE;
	if (code_point != NULL)
		*code_point = (unsigned)code_l;
	return SUCCESS;
}",1,0,15,0.59,Insert
3475,,,,,,,
3476,"static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	struct perf_event_context *ctx = event->ctx;
	lockdep_assert_held(&ctx->mutex);
	event_function_call(event, __perf_remove_from_context, (void *)flags);
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}","static void perf_remove_from_context(struct perf_event *event, unsigned long flags)
{
	int a = 30;
	int b = a;
	if(a*b>0){
    	struct perf_event_context *ctx = event->ctx;
	}
	lockdep_assert_held(&ctx->mutex);
	event_function_call(event, __perf_remove_from_context, (void *)flags);
	WARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);
	if ((flags & DETACH_GROUP) &&
	    (event->attach_state & PERF_ATTACH_GROUP)) {
		raw_spin_lock_irq(&ctx->lock);
		perf_group_detach(event);
		raw_spin_unlock_irq(&ctx->lock);
	}
}",0,1,2,0.07,Replace
3477,,,,,,,
3480,"BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}
	freewbmp(wbmp);
}","BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	int a = 56;
	int b = a;
	WebPContext *s_9;
	enum ImageRole role_9;
	ImageContext *feature_3;
	feature_3       = &s_9->image[role_9];
	feature_3->role_9 = role_9;
	if(a*b>0){
    	int x, y, pos;
	}
	Wbmp *wbmp;
	WebPContext *s;
	enum ImageRole role;
	ImageContext *feature;
	feature       = &s->image[role];
	feature->role = role;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}
	freewbmp(wbmp);
}",1,0,78,1.21,Insert
3481,"void DispatcherThread::OnNotify()
{
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void DispatcherThread::OnNotify()
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	this->LockQueue();
	}
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}",0,1,1,0.08,Replace
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return sid;
}","PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	}
	return sid;
}",1,0,4,0.06,Replace
3484,,,,,,,
3486,"bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;
	spin_lock_irqsave(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}
	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);
	__net_random_once_disable_jump(done_key);
	return true;
}","bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;
	spin_lock_irqsave(&lock, flags);
	if (*done) {
		AVFormatContext *avctx;
		IMediaControl *control = NULL;
		struct dshow_ctx *ctx = avctx->priv_data;
		IGraphBuilder *graph = NULL;
		IMediaEvent *media_event = NULL;
		int r;
		r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,
		                         &IID_IGraphBuilder, (void **) &graph);
		ctx->graph = graph;
		r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);
		r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		spin_unlock_irqrestore(&lock, flags);
		}
		return false;
	}
	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);
	__net_random_once_disable_jump(done_key);
	return true;
}",1,0,36,0.7,Insert
3488,"int RGWListBucketMultiparts_ObjStore::get_params()
{
  delimiter = s->info.args.get(""delimiter"");
  prefix = s->info.args.get(""prefix"");
  string str = s->info.args.get(""max-uploads"");
  op_ret = parse_value_and_bound(str, &max_uploads, 0, g_conf()->rgw_max_listing_results, default_max);
  if (op_ret < 0) {
    return op_ret;
  }
  string key_marker = s->info.args.get(""key-marker"");
  string upload_id_marker = s->info.args.get(""upload-id-marker"");
  if (!key_marker.empty())
    marker.init(key_marker, upload_id_marker);
  return 0;
}","int RGWListBucketMultiparts_ObjStore::get_params()
{
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      delimiter = s->info.args.get(""delimiter"");
  }
  prefix = s->info.args.get(""prefix"");
  string str = s->info.args.get(""max-uploads"");
  op_ret = parse_value_and_bound(str, &max_uploads, 0, g_conf()->rgw_max_listing_results, default_max);
  if (op_ret < 0) {
    return op_ret;
  }
  string key_marker = s->info.args.get(""key-marker"");
  string upload_id_marker = s->info.args.get(""upload-id-marker"");
  if (!key_marker.empty())
    marker.init(key_marker, upload_id_marker);
  return 0;
}",1,0,2,0.08,Replace
3492,"void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,
				uint8_t rcv_id_len, const char *raw_pdu,
				size_t raw_pdu_len)
{
	const char *xpath = ""/frr-isisd:id-len-mismatch"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
	data = yang_data_new_uint8(xpath_arg, rcv_id_len);
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,
		  raw_pdu_len);
	nb_notification_send(xpath, arguments);
}","void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,
				uint8_t rcv_id_len, const char *raw_pdu,
				size_t raw_pdu_len)
{
	const char *xpath = ""/frr-isisd:id-len-mismatch"";
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct list *arguments = yang_data_list_new();
    	b += 1;
	}
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;
	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
	data = yang_data_new_uint8(xpath_arg, rcv_id_len);
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,
		  raw_pdu_len);
	nb_notification_send(xpath, arguments);
}",1,0,4,0.11,Replace
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);
    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);
    cookie->bytes = bytes;
    int a = 2;
    int b = 2;
    while (a == b) {
        cookie->start_time_ns = get_clock();
        b += 1;
    }
    cookie->type = type;
}",0,1,1,0.04,Replace
3494,,,,,,,
3495,,,,,,,
3498,,,,,,,
3500,"static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf)  
{
	if (key == NULL) {  
		buffer_append_spaces(buf, level+1);
		smart_str_append_long(buf, (zend_long) index);
		smart_str_appendl(buf, "" => "", 4);
	} else {  
		zend_string *tmp_str;
		zend_string *ckey = php_addcslashes(key, 0, ""'\\"", 2);
		tmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), ""\0"", 1, ""' . \""\\0\"" . '"", 12);
		buffer_append_spaces(buf, level + 1);
		smart_str_appendc(buf, '\'');
		smart_str_append(buf, tmp_str);
		smart_str_appendl(buf, ""' => "", 5);
		zend_string_free(ckey);
		zend_string_free(tmp_str);
	}
	php_var_export_ex(zv, level + 2, buf);
	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
}","static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf)  
{
	if (key == NULL) {  
		buffer_append_spaces(buf, level+1);
		smart_str_append_long(buf, (zend_long) index);
		smart_str_appendl(buf, "" => "", 4);
	} else {  
		zend_string *tmp_str;
		zend_string *ckey = php_addcslashes(key, 0, ""'\\"", 2);
		tmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), ""\0"", 1, ""' . \""\\0\"" . '"", 12);
		int nb_oargs;
		int nb_iargs;
		const TCGArg * const args;
		int rules, nb_regs, ini;
		tcg_insn_unit *func_addr;
		func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
		rules = args[nb_oargs + nb_iargs + 1];
		buffer_append_spaces(buf, level + 1);
		smart_str_appendc(buf, '\'');
		smart_str_append(buf, tmp_str);
		smart_str_appendl(buf, ""' => "", 5);
		zend_string_free(ckey);
		zend_string_free(tmp_str);
	}
	int a = 2;
	int b = 2;
	while (a == b) {
    	php_var_export_ex(zv, level + 2, buf);
    	b += 1;
	}
	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
}",0,1,31,0.79,Insert
3501,,,,,,,
3504,"void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
}","void HttpRequestEntry::resetHttpHeaderProcessor()
{
  int a = 68;
  int b = a;
  if(a*b>0){
      unsigned long array;
      struct net_bridge_mdb_entry *this = (void *)array;
      struct net_bridge *bridge = this->bridge;
      if (!netif_running(bridge->dev) || timer_pending(&this->timer))
      		goto out;
      proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
  }
}",0,1,4,0.25,Insert
3505,"static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];
	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;
	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;
	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
	return rdev_update_ft_ies(rdev, dev, &ft_params);
}","static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];
	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;
	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		int a = 2;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		char
		    *p,
		    *xml;
		xml=FileToString(filename,~0UL,exception);
		quantization_tables=NewXMLTree(xml,exception);
		int b = 3;
		while (a < b) {
    		return -EINVAL;
    		b = a;
		}
	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
	return rdev_update_ft_ies(rdev, dev, &ft_params);
}",0,1,21,0.76,Insert
3506,,,,,,,
3507,,,,,,,
3509,"static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}","static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  if (range_str)
      dump_range(ses, start, id, ses->obj_size);
  *quantum|=(size_t) (*p++ << 16);
  void *opaque;
  int index_in_cluster;
  QCowAIOCB *acb = opaque;
  BlockDriverState *bs = acb->common.bs;
  uint64_t cluster_offset;
  int n_end;
  n_end = index_in_cluster + acb->nb_sectors;
  cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,
                                            index_in_cluster,
                                            n_end, &acb->n);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      *quantum|=(size_t) (*p++ << 8);
  }
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}",1,0,61,0.58,Insert
3513,,,,,,,
3514,"char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}","char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	int a = 14;
	int b = a;
	if(a*b>0){
    	GF_StreamContext*sc = NULL;
	}
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	MOVContext *c_4;
	uint8_t type[5] = {0};
	if (strcmp(type, ""qt  ""))
	        c_4->isom = 1;
	gf_free(buffer);
	MOVContext *c;
	AVIOContext *pb;
	uint32_t minor_ver;
	char minor_ver_str[11];
	minor_ver = avio_rb32(pb);
	snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
	av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);
	return buf64;
}",1,0,54,0.97,Insert
3515,"PHP_FUNCTION(oci_lob_load)
{
	zval **tmp, *z_descriptor = getThis();
	php_oci_descriptor *descriptor;
	char *buffer = NULL;
	ub4 buffer_len;
	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}	
	}
	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&tmp) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
	}
	PHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);
	if (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buffer_len > 0) {
		RETURN_STRINGL(buffer, buffer_len, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}","PHP_FUNCTION(oci_lob_load)
{
	zval **tmp, *z_descriptor = getThis();
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	php_oci_descriptor *descriptor;
	strcpy(str, ""a"");
	}
	char *buffer = NULL;
	ub4 buffer_len;
	if (!getThis()) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O"", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {
			return;
		}	
	}
	if (zend_hash_find(Z_OBJPROP_P(z_descriptor), ""descriptor"", sizeof(""descriptor""), (void **)&tmp) == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to find descriptor property"");
		RETURN_FALSE;
		struct disassemble_info *info;
		fprintf_function fprintf_fn = info->fprintf_func;
		void *stream = info->stream;
		uint8_t insn[4];
		fprintf_fn(stream, ""%02x %02x %02x %02x    "",
		            insn[0], insn[1], insn[2], insn[3]);
	}
	OfDpaFlow *flow;
	flow->cookie = cookie;
	PHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);
	AVStream *vst, *ast;
	int64_t url;
	url = 0x68 + ast->nb_index_entries * 16;
	if (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {
		RETURN_FALSE;
	}
	if (buffer_len > 0) {
		RETURN_STRINGL(buffer, buffer_len, 0);
	}
	else {
		RETURN_EMPTY_STRING();
	}
}",1,0,100,0.99,Insert
3517,"bool LOGGER::flush_general_log()
{
  logger.lock_exclusive();
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();
  logger.unlock();
  return 0;
}","bool LOGGER::flush_general_log()
{
  logger.lock_exclusive();
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();
  logger.unlock();
  int a = 2;
  int b = 3;
  while (a < b) {
      return 0;
      b = a;
  }
}",0,1,5,0.06,Replace
3518,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;
	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;
	int a = 75;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
	                                 aml_name(""CDW1"")));
	aml_append(ifconfig, ifconfig0);
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
	aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x10), NULL),
	                                 aml_name(""CDW1"")));
	int b = a;
	if(a*b>0){
    	net->ipv4.peers = NULL;
	}
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}",0,1,19,0.37,Insert
3519,,,,,,,
3521,,,,,,,
3522,"const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }","const char *
http_status_str (enum http_status s)
{
  ptrdiff_t src_stride;
  ptrdiff_t buf_stride;
  int h;
  int src_y;
  int block_h;
  int w;
  int block_w;
  const uint8_t *src;
  int src_x;
  uint8_t *buf;
  emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                       src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                       hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }",0,1,18,0.29,Insert
3523,"static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;
	return queue_find(service->chrcs, match_chrc, path);
}","static bool match_service_by_chrc(const void *a, const void *b)
{
	uint64_t glms;
	unsigned k, b_5, err, C;
	unsigned k, b_5, err, C;
	assert(is_limm(glms));
	k = clz64(glms);
	b_5 = ctz64(glms);
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	const struct external_service *service = a;
	strcpy(str_1, ""a"");
	}
	const char *path = b;
	return queue_find(service->chrcs, match_chrc, path);
}",0,1,7,0.32,Insert
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;
	return 0;
}","static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	u32 val;
	strcpy(str, ""a"");
	}
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;
	return 0;
}",0,1,6,0.1,Replace
3526,"static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int i;
    if (version_id != 1)
        return -EINVAL;
    s->ris = qemu_get_be32(f);
    s->im = qemu_get_be32(f);
    s->rctl = qemu_get_be32(f);
    s->tctl = qemu_get_be32(f);
    s->thr = qemu_get_be32(f);
    s->mctl = qemu_get_be32(f);
    s->mdv = qemu_get_be32(f);
    s->mtxd = qemu_get_be32(f);
    s->mrxd = qemu_get_be32(f);
    s->np = qemu_get_be32(f);
    s->tx_fifo_len = qemu_get_be32(f);
    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
    for (i = 0; i < 31; i++) {
        s->rx[i].len = qemu_get_be32(f);
        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));
    }
    s->next_packet = qemu_get_be32(f);
    s->rx_fifo_offset = qemu_get_be32(f);
    return 0;
}","static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)
{
    AVFormatContext *ctx_6;
    MpegMuxContext *s_9 = ctx_6->priv_data;
    s_9->audio_bound = 0;
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int i;
    AVStream *vst, *ast;
    int64_t url;
    url = 0x68 + ast->nb_index_entries * 16;
    struct sockaddr *uaddr;
    struct socket *sock;
    struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;
    struct sock *sk = sock->sk;
    if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
    		lsa->l2tp_scope_id = sk->sk_bound_dev_if;
    if (version_id != 1)
        return -EINVAL;
    int a = 2;
    int b = 2;
    if (a == b) {
        s->ris = qemu_get_be32(f);
    }
    WriterContext *w;
    InputStream *ist;
    const char *s_1;
    AVCodecParameters *par;
    AVStream *stream = ist->st;
    par     = stream->codecpar;
    s_1 = av_get_media_type_string(par->codec_type);
    print_str(""codec_tag_string"",    av_fourcc2str(par->codec_tag));
    print_fmt(""codec_tag"", ""0x%04""PRIx32, par->codec_tag);
    writer_print_data_hash(w, ""extradata_hash"", par->extradata,
                                                    par->extradata_size);
    s->im = qemu_get_be32(f);
    s->rctl = qemu_get_be32(f);
    s->tctl = qemu_get_be32(f);
    s->thr = qemu_get_be32(f);
    s->mctl = qemu_get_be32(f);
    s->mdv = qemu_get_be32(f);
    s->mtxd = qemu_get_be32(f);
    s->mrxd = qemu_get_be32(f);
    s->np = qemu_get_be32(f);
    s->tx_fifo_len = qemu_get_be32(f);
    AVDictionary **metadata = avpriv_frame_get_metadatap(main);
    PSNRContext *s_4 = ctx->priv;
    double comp_mse[4], mse = 0;
    set_meta(metadata, ""lavfi.psnr.psnr_avg"", 0, get_psnr(mse, 1, s_4->average_max));
    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
    for (i = 0; i < 31; i++) {
        s->rx[i].len = qemu_get_be32(f);
        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));
    }
    s->next_packet = qemu_get_be32(f);
    s->rx_fifo_offset = qemu_get_be32(f);
    return 0;
}",1,0,281,2.45,Insert
3528,,,,,,,
3530,"GF_Box *segr_New()
{
	ISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);
	return (GF_Box *)tmp;","GF_Box *segr_New()
{
	const struct sun4d_hwdef *hawdecl;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	unsigned int i;
	for (i = 0; i < MAX_IOBITS; i++)
	        if (hawdecl->iounit_bases[i] != (target_phys_addr_t)-1)
	            ioulits[i] = iommu_init(hawdecl->iounit_bases[i],
	                                    hawdecl->iounit_version,
	                                    sbi_arqu[hawdecl->me_irq]);
	ISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);
	return (GF_Box *)tmp;",0,1,31,0.27,Insert
3531,"MagickExport void ConvertRGBToHSL(const Quantum red,const Quantum green,
  const Quantum blue,double *hue,double *saturation,double *lightness)
{
  double
    c,
    max,
    min;
  assert(hue != (double *) NULL);
  assert(saturation != (double *) NULL);
  assert(lightness != (double *) NULL);
  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,
    QuantumScale*blue));
  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,
    QuantumScale*blue));
  c=max-min;
  *lightness=(max+min)/2.0;
  if (c <= 0.0)
    {
      *hue=0.0;
      *saturation=0.0;
      return;
    }
  if (fabs(max-QuantumScale*red) < MagickEpsilon)
    {
      *hue=(QuantumScale*green-QuantumScale*blue)/c;
      if ((QuantumScale*green) < (QuantumScale*blue))
        *hue+=6.0;
    }
  else
    if (fabs(max-QuantumScale*green) < MagickEpsilon)
      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;
    else
      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;
  *hue*=60.0/360.0;
  if (*lightness <= 0.5)
    *saturation=c/(2.0*(*lightness));
  else
    *saturation=c/(2.0-2.0*(*lightness));
}","MagickExport void ConvertRGBToHSL(const Quantum red,const Quantum green,
  const Quantum blue,double *hue,double *saturation,double *lightness)
{
  double
    c,
    max,
    min;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      assert(hue != (double *) NULL);
  strcpy(str, ""a"");
  }
  assert(saturation != (double *) NULL);
  assert(lightness != (double *) NULL);
  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,
    QuantumScale*blue));
    AVFormatContext *cs;
    AVPacket * punt;
    int size =  punt->size, def = 0;
    MOVTrack *brok = &mov->tracks[ punt->stream_index];
    MOVMuxContext *mov = cs->priv_data;
    def = check_pkt(cs,  punt);
  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,
    QuantumScale*blue));
  c=max-min;
  *lightness=(max+min)/2.0;
  if (c <= 0.0)
    {
      *hue=0.0;
      *saturation=0.0;
      return;
    }
  if (fabs(max-QuantumScale*red) < MagickEpsilon)
    {
      *hue=(QuantumScale*green-QuantumScale*blue)/c;
      if ((QuantumScale*green) < (QuantumScale*blue))
        *hue+=6.0;
    }
  else
    if (fabs(max-QuantumScale*green) < MagickEpsilon)
      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;
    else
      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;
  *hue*=60.0/360.0;
  if (*lightness <= 0.5)
    *saturation=c/(2.0*(*lightness));
  else
    *saturation=c/(2.0-2.0*(*lightness));
}",1,0,39,2.05,Insert
3533,"static void __io_queue_sqe(struct io_kiocb *req)
{
	struct io_kiocb *linked_timeout = io_prep_linked_timeout(req);
	struct io_kiocb *nxt = NULL;
	int ret;
	ret = io_issue_sqe(req, &nxt, true);
	if (nxt)
		io_queue_async_work(nxt);
	if (ret == -EAGAIN && (!(req->flags & REQ_F_NOWAIT) ||
	    (req->flags & REQ_F_MUST_PUNT))) {
		struct sqe_submit *s = &req->submit;
		struct io_uring_sqe *sqe_copy;
		sqe_copy = kmemdup(s->sqe, sizeof(*sqe_copy), GFP_KERNEL);
		if (!sqe_copy)
			goto err;
		s->sqe = sqe_copy;
		req->flags |= REQ_F_FREE_SQE;
		if (req->work.flags & IO_WQ_WORK_NEEDS_FILES) {
			ret = io_grab_files(req);
			if (ret)
				goto err;
		}
		io_queue_async_work(req);
		return;
	}
err:
	io_put_req(req);
	if (linked_timeout) {
		if (!ret)
			io_queue_linked_timeout(linked_timeout);
		else
			io_put_req(linked_timeout);
	}
	if (ret) {
		io_cqring_add_event(req, ret);
		if (req->flags & REQ_F_LINK)
			req->flags |= REQ_F_FAIL_LINK;
		io_put_req(req);
	}
}","static void __io_queue_sqe(struct io_kiocb *req)
{
	struct io_kiocb *linked_timeout = io_prep_linked_timeout(req);
	struct io_kiocb *nxt = NULL;
	int ret;
	ret = io_issue_sqe(req, &nxt, true);
	if (nxt)
		io_queue_async_work(nxt);
	if (ret == -EAGAIN && (!(req->flags & REQ_F_NOWAIT) ||
	    (req->flags & REQ_F_MUST_PUNT))) {
		struct sqe_submit *s = &req->submit;
		struct io_uring_sqe *sqe_copy;
		sqe_copy = kmemdup(s->sqe, sizeof(*sqe_copy), GFP_KERNEL);
		if (!sqe_copy)
			goto err;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		s->sqe = sqe_copy;
		strcpy(str, ""a"");
		}
		req->flags |= REQ_F_FREE_SQE;
		if (req->work.flags & IO_WQ_WORK_NEEDS_FILES) {
			ret = io_grab_files(req);
			if (ret)
				goto err;
		}
		io_queue_async_work(req);
		return;
	}
err:
	io_put_req(req);
	if (linked_timeout) {
		if (!ret)
			io_queue_linked_timeout(linked_timeout);
		else
			io_put_req(linked_timeout);
	}
	const struct sun4d_hwdef *hawdecl;
	int ret_6;
	ram_addr_t gram_size, prom_reset, tcx64off;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *esp__set, *les_init;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *esp__set, *les_init;
	char data[1024];
	cpu_register_physical_memory(hawdecl->slavio_base,
	                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
	                                 TARGET_PAGE_MASK,
	                                 prom_reset | IO_MEM_ROM);
	ret_6 = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
	sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
	espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
	                              ioulits[0], &espdma_iraque, &esp__set);
	ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
	                             ioulits[0], &ledma_arquest, &les_init);
	if (ret) {
		io_cqring_add_event(req, ret);
		if (req->flags & REQ_F_LINK)
			req->flags |= REQ_F_FAIL_LINK;
		io_put_req(req);
	}
}",0,1,22,1.37,Insert
3534,,,,,,,
3535,"SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	char *sub_name;
	int len;
	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (intern->u.dir.sub_path) {
		len = spprintf(&sub_name, 0, ""%s%c%s"", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);
		RETURN_STRINGL(sub_name, len, 0);
	} else {
		RETURN_STRING(intern->u.dir.entry.d_name, 1);
	}
}","SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	MOVTrack *track;
    	AVIOContext *pb;
    	int64_t pos = avio_tell(pb);
    	avio_wb32(pb, 0);
    	void *inner;
    	struct drm_mode_fb_dirty_cmd *r = inner;
    	int nbEbytes;
    	nbEbytes = r->nbEbytes;
    	ffio_wfourcc(pb, ""stbl"");
    	mov_write_stsd_tag(pb, track);
    	mov_write_stts_tag(pb, track);
    	mov_write_stsc_tag(pb, track);
    	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
    	b += 1;
    	AVIOContext *pb_1;
    	MOVContext *c;
    	MOVAtom atom;
    	AVStream *st;
    	st = c->fc->streams[c->fc->nb_streams-1];
    	av_free(st->codec->extradata);
    	st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);
    	st->codec->extradata_size = atom.size - 40;
    	avio_read(pb_1, st->codec->extradata, atom.size - 40);
	}
	char *sub_name;
	int len;
	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (intern->u.dir.sub_path) {
		len = spprintf(&sub_name, 0, ""%s%c%s"", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);
		RETURN_STRINGL(sub_name, len, 0);
	} else {
		RETURN_STRING(intern->u.dir.entry.d_name, 1);
	}
}",1,0,201,1.48,Insert
3537,"HttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {
  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};
  cluster->max_response_headers_count_ = 200;
  cluster->http2_options_.set_allow_connect(true);
  cluster->http2_options_.set_allow_metadata(true);
  cluster->http1_settings_.enable_trailers_ = true;
  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(
      cluster, fmt::format(""tcp://{}:80"", Network::Test::getLoopbackAddressUrlString(version_)))};
  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,
                                                  downstream_protocol_);
}","HttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {
  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};
  cluster->max_response_headers_count_ = 200;
  int a = 2;
  int b = 2;
  while (a == b) {
      cluster->http2_options_.set_allow_connect(true);
      b += 1;
  }
  cluster->http2_options_.set_allow_metadata(true);
  RAnalOp *cat;
  ut64 addr;
  const ut8 *data;
  memset (cat, '\0', sizeof (RAnalOp));
  cat->size = snes_op_get_size (1, 1, &snes_op[data[0]]);
  cat->addr = addr;
  cat->type = R_ANAL_OP_TYPE_UNK;
  cat->id = data[0];
  cluster->http1_settings_.enable_trailers_ = true;
  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(
      cluster, fmt::format(""tcp://{}:80"", Network::Test::getLoopbackAddressUrlString(version_)))};
  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,
                                                  downstream_protocol_);
}",1,0,29,0.65,Insert
3539,"static const char *gf_filter_get_args_stripped(GF_FilterSession *fsess, const char *in_args, Bool is_dst)
{
	char szEscape[7];
	char *args_striped = NULL;
	if (in_args) {
		const char *key;
		if (is_dst) {
			key = ""dst"";
		} else {
			key = ""src"";
		}
		if (!strncmp(in_args, key, 3) && (in_args[3]==fsess->sep_name)) {
			args_striped = (char *) in_args;
		} else {
			char szDst[6];
			sprintf(szDst, ""%c%s%c"", fsess->sep_name, key, fsess->sep_name);
			args_striped = strstr(in_args, szDst);
		}
		if (args_striped) {
			args_striped += 4;
			if (!strncmp(args_striped, ""gcryp://"", 8))
				args_striped += 8;
			args_striped = (char *)gf_fs_path_escape_colon(fsess, args_striped);
			if (args_striped) args_striped ++;
		} else {
			args_striped = (char *)in_args;
		}
	}
	sprintf(szEscape, ""gpac%c"", fsess->sep_args);
	if (args_striped && !strncmp(args_striped, szEscape, 5))
		return args_striped + 5;
	return args_striped;
}","static const char *gf_filter_get_args_stripped(GF_FilterSession *fsess, const char *in_args, Bool is_dst)
{
	char szEscape[7];
	char *args_striped = NULL;
	if (in_args) {
		const char *key;
		if (is_dst) {
			key = ""dst"";
		} else {
			key = ""src"";
		}
		if (!strncmp(in_args, key, 3) && (in_args[3]==fsess->sep_name)) {
			args_striped = (char *) in_args;
		} else {
			char str1[] = ""Constant"";
			char str2[] = ""Constant"";
			if (strcmp(str1, str2) == 0) {
    			char szDst[6];
			}
			sprintf(szDst, ""%c%s%c"", fsess->sep_name, key, fsess->sep_name);
			args_striped = strstr(in_args, szDst);
		}
		if (args_striped) {
			args_striped += 4;
			if (!strncmp(args_striped, ""gcryp://"", 8))
				args_striped += 8;
			args_striped = (char *)gf_fs_path_escape_colon(fsess, args_striped);
			if (args_striped) args_striped ++;
		} else {
			args_striped = (char *)in_args;
		}
	}
	sprintf(szEscape, ""gpac%c"", fsess->sep_args);
	if (args_striped && !strncmp(args_striped, szEscape, 5))
		return args_striped + 5;
	return args_striped;
}",0,1,6,0.21,Replace
3542,"   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }","   void Parser::advanceToNextToken() {
      int a = 84;
      int b = a;
      if(a*b>0){
          lex < css_comments >(false);
      }
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }",0,1,2,0.04,Replace
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    return OK;
}","static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    int a = 57;
    int b = a;
    if(a*b>0){
        ap_mutex_init(pconf);
    }
    if (!saved_server_config_defines)
        init_config_defines(pconf);
        AVPacket * pk;
        AVFormatContext *s;
        unsigned char rb[5];
        AVCodecParameters *par = s->streams[stream_index]->codecpar;
        AVIOContext *b_3     = s->b_3;
        const int stream_index =  pk->stream_index;
        avi_stream2fourcc(rb, stream_index, par->codec_type);
        avio_write(b_3, rb, 4);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    return OK;
}",0,1,7,0.43,Insert
3546,,,,,,,
3547,,,,,,,
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        optimization_state= JOIN::OPTIMIZATION_DONE;
    strcpy(str, ""a"");
    }
  }
  return res;
}",0,1,25,0.7,Insert
3552,"struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);
	if (!enc10)
		return NULL;
	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);
	return &enc10->base;
}","struct link_encoder *dcn10_link_encoder_create(
	const struct encoder_init_data *enc_init_data)
{
	struct dcn10_link_encoder *enc10 =
		kzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);
	if (!enc10)
		return NULL;
	dcn10_link_encoder_construct(enc10,
				      enc_init_data,
				      &link_enc_feature,
				      &link_enc_regs[enc_init_data->transmitter],
				      &link_enc_aux_regs[enc_init_data->channel - 1],
				      &link_enc_hpd_regs[enc_init_data->hpd_source],
				      &le_shift,
				      &le_mask);
	int a = 2;
	HEVCContext *settings;
	int y0;
	int nPbH;
	int nPcH;
	int y1;
	HEVCLocalContext *cpu = settings->HEVClc;
	ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
	int b = 3;
	while (a != b) {
    	return &enc10->base;
    	b = a;
	}
}",0,1,9,0.47,Insert
3554,,,,,,,
3558,"int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		mid = (left + right) >> 1;
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else {  
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}","int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)
{
	int left, mid, right, nn;
	if (ref_id) *ref_id = bns_pos2rid(bns, pos_f);
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	left = 0; right = bns->n_holes; nn = 0;
	while (left < right) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		mid = (left + right) >> 1;
    		b += 1;
		}
		if (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;
		else if (pos_f + len <= bns->ambs[mid].offset) right = mid;
		else {  
			if (pos_f >= bns->ambs[mid].offset) {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;
			} else {
				nn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?
					bns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);
			}
			break;
		}
	}
	return nn;
}",0,1,10,1.3,Insert
3559,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;
	perf_event_header__init_id(&throttle_event.header, &sample, event);
	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;
	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct perf_sample_data sample;
    	b = a;
	}
	int ret;
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;
	perf_event_header__init_id(&throttle_event.header, &sample, event);
	int height;
	int subsamp;
	int ph, nc, retval = 0;
	int ph, nc, retval = 0;
	nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
	ph = PAD(height, tjMCUHeight[subsamp] / 8);
	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;
	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}",0,1,44,0.9,Insert
3561,"int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;
    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;
    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}","int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ed448_key*   ed448Key = NULL;
    strcpy(str, ""a"");
    }
    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;
    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}",0,1,1,0.1,Replace
3564,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	journal_t *fat = EXT4_SB_5(sb)->s_journal;
	struct ext4_inode_info *eye;
	struct ext4_inode *raw_incode;
	struct inode_7 *inode_7;
	inode_7->i_size = ext4_isize(sb, raw_incode);
	eye->i_disksize = inode_7->i_size;
	inode_7->i_generation = le32_to_cpu_4(raw_incode->i_generation);
	EXT4_INODE_GET_XTIME(i_ctime, inode_7, raw_incode);
	EXT4_INODE_GET_XTIME(i_mtime, inode_7, raw_incode);
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		int a = 2;
		int b = 2;
		if (a == b) {
    		return 0;
		}
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}",1,0,12,0.56,Insert
3565,"link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      res = link (link_target, link_name);
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}","link_to_name (char const *link_name, char const *link_target)
{
  int res = link (link_target, link_name);
  if (res < 0 && create_dir_flag)
    {
      create_all_directories (link_name);
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          res = link (link_target, link_name);
      strcpy(str, ""a"");
      }
    }
  if (res == 0)
    {
      if (verbose_flag)
	error (0, 0, _(""%s linked to %s""),
	       link_target, link_name);
    }
  else if (link_flag)
    {
      error (0, errno, _(""cannot link %s to %s""),
	     link_target, link_name);
    }
  return res;
}",0,1,2,0.11,Replace
3567,"void auth_client_request_abort(struct auth_client_request **_request)
{
	struct auth_client_request *request = *_request;
	*_request = NULL;
	auth_client_send_cancel(request->conn->client, request->id);
	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);
}","void auth_client_request_abort(struct auth_client_request **_request)
{
	struct auth_client_request *request = *_request;
	*_request = NULL;
	int a = 2;
	int b = 3;
	while (a < b) {
    	auth_client_send_cancel(request->conn->client, request->id);
    	b = a;
	}
	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);
}",1,0,1,0.04,Replace
3568,"std::string encodeBase64(const std::string& input) {
  using namespace boost::archive::iterators;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;
  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  encoded.append((3 - (input.length() % 3)) % 3, '=');
  return encoded;
}","std::string encodeBase64(const std::string& input) {
  using namespace boost::archive::iterators;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;
  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;
  int opcode, len;
  while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {
          cmdptr++;
  }
  encoded.append((3 - (input.length() % 3)) % 3, '=');
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      return encoded;
  }
}",1,0,17,0.5,Insert
3569,"static void change_pageblock_range(struct page *pageblock_page,
					int start_order, int migratetype)
{
	int nr_pageblocks = 1 << (start_order - pageblock_order);
	while (nr_pageblocks--) {
		set_pageblock_migratetype(pageblock_page, migratetype);
		pageblock_page += pageblock_nr_pages;
	}
}","static void change_pageblock_range(struct page *pageblock_page,
					int start_order, int migratetype)
{
	enum hfi1_sdma_comp_state state;
	u16 idx;
	struct hfi1_user_sdma_pkt_q *pq;
	int ret;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
						idx, state, ret);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int nr_pageblocks = 1 << (start_order - pageblock_order);
	strcpy(str, ""a"");
	}
	while (nr_pageblocks--) {
		set_pageblock_migratetype(pageblock_page, migratetype);
		pageblock_page += pageblock_nr_pages;
	}
}",0,1,13,0.39,Insert
3570,"int mbedtls_ssl_check_pending( const mbedtls_ssl_context *ssl )
{
    if( ssl->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        return( 1 );
    }
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        ssl->in_left > ssl->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif  
    if( ssl->in_hslen > 0 && ssl->in_hslen < ssl->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }
    if( ssl->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}","int mbedtls_ssl_check_pending( const mbedtls_ssl_context *ssl )
{
    if( ssl->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        int a = 2;
        int b = 3;
        while (a < b) {
            return( 1 );
            b = a;
        }
    }
    CPUState *cpu;
    KVMState *b_7 = kvm_state;
    KVMState *b_7 = kvm_state;
    cpu->kvm_state = b_7;
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        ssl->in_left > ssl->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif  
    if( ssl->in_hslen > 0 && ssl->in_hslen < ssl->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }
    if( ssl->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}",0,1,21,0.66,Insert
3571,"file_check_str(gerb_file_t *fd, const char *str)
{
    char c;
    for (int i = 0; str[i] != '\0'; i++) {
	c = gerb_fgetc(fd);
	if (c == EOF)
	    return -1;
	if (c != str[i]) {
	    do {
		gerb_ungetc(fd);
	    } while (i--);
	    return 0;
	}
    }
    return 1;
}","file_check_str(gerb_file_t *fd, const char *str)
{
    char c;
    for (int i = 0; str[i] != '\0'; i++) {
	c = gerb_fgetc(fd);
	if (c == EOF)
	    return -1;
	if (c != str[i]) {
	    do {
		gerb_ungetc(fd);
	    } while (i--);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	    return 0;
	}
	}
    }
    return 1;
}",0,1,3,0.11,Replace
3572,"bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[256];  
        int buflen=0;
        register u_int rotbit;  
        register u_int tokval;
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            rotbit=1;
            while (rotbit != 0) {
		if (tokval == (v&rotbit)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1;  
            }
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}","bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        r_bin_ne_obj_t *feature;
        RBuffer *buf_4;
        ut16 offset = feature->ne_header->SegTableOffset + feature->header_offset;
        feature->os = __get_target_os (feature);
        feature->segment_entries = calloc (1, size);
        r_buf_read_at (buf_4, offset, (ut8 *)feature->segment_entries, size);
        feature->entry_table = calloc (1, feature->ne_header->EntryTableLength);
        r_buf_read_at (buf_4, (ut64)feature->header_offset + feature->ne_header->EntryTableOffset, feature->entry_table, feature->ne_header->EntryTableLength);
        static char buf[256];  
        int buflen=0;
        register u_int rotbit;  
        register u_int tokval;
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            rotbit=1;
            while (rotbit != 0) {
		if (tokval == (v&rotbit)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    int a = 2;
                    int b = 2;
                    if (a == b) {
                        sepstr = sep;
                    }
                    break;
                }
                rotbit=rotbit<<1;  
            }
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}",1,0,33,0.9,Insert
3573,,,,,,,
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        HANDLE hProcess;
    strcpy(str, ""a"");
    }
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}",0,1,7,0.14,Replace
3577,"        compression::algorithm compression_algorithm()
        {
            return comp_algorithm_;
        }","        compression::algorithm compression_algorithm()
        {
            GF_BitStream *bits;
            GF_Box *s;
            GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;
            GF_Err e;
            e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);
            ISOM_DECREASE_SIZE(buf, 8);
            return comp_algorithm_;
        }",0,1,12,0.16,Insert
3579,,,,,,,
3582,"static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}
	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);
	return pinctrl_register_map(map, num_maps, false);
}","static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
				   struct pinctrl_dev *pctldev,
				   struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;
	for (i = 0; i < num_maps; i++) {
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}
	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);
	int a = 2;
	int b = 3;
	while (a != b) {
    	return pinctrl_register_map(map, num_maps, false);
    	b = a;
	}
}",1,0,3,0.14,Replace
3584,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);
  redis->hashDel(key, member);
  return(CONST_LUA_OK);
}","static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
  aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
                                  aml_name(""CTRL"")));
  ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
  aml_append(ifconfig0, aml_store(aml_or(aml_name(""CDW1""), aml_int(0x08), NULL),
                                   aml_name(""CDW1"")));
  aml_append(ifconfig, ifconfig0);
  ifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(""CDW3""), aml_name(""CTRL""))));
  Redis *redis = ntop->getRedis();
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  bool bool_var = (ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING));
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);
  redis->hashDel(key, member);
  return(CONST_LUA_OK);
}",0,1,10,0.59,Insert
3585,"const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)
{
  return state->lineinfo + row;
}","const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)
{
  int a = 2;
  int b = 3;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  while (a < b) {
      return state->lineinfo + row;
      b = a;
  }
}",0,1,4,0.32,Insert
3586,"static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	return 0;
}","static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		int a = 2;
		int b = 3;
		VirtIODevice *vrdevice;
		struct virtio_blk_config blkcfg;
		VirtIOBlock *s = VIRTIO_BLK(vrdevice);
		uint64_t capacity;
		VirtIOBlock *s = VIRTIO_BLK(vrdevice);
		bdrv_get_geometry(s->bs, &capacity);
		virtio_stq_p(vrdevice, &blkcfg.capacity, capacity);
		while (a < b) {
    		return 1;
    		b = a;
		}
	}
	return 0;
}",0,1,7,0.4,Insert
3588,"static int cp2112_gpio_get_all(struct gpio_chip *chip)
{
	struct cp2112_device *dev = gpiochip_get_data(chip);
	struct hid_device *hdev = dev->hdev;
	u8 *buf = dev->in_out_buffer;
	unsigned long flags;
	int ret;
	spin_lock_irqsave(&dev->lock, flags);
	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (ret != CP2112_GPIO_GET_LENGTH) {
		hid_err(hdev, ""error requesting GPIO values: %d\n"", ret);
		ret = ret < 0 ? ret : -EIO;
		goto exit;
	}
	ret = buf[1];
exit:
	spin_unlock_irqrestore(&dev->lock, flags);
	return ret;
}","static int cp2112_gpio_get_all(struct gpio_chip *chip)
{
	int a = 2;
	int b = 2;
	AVFormatContext *s;
	RTSPState *rt = s->priv_data;
	const char *trans_pref;
	if (rt->transport == RTSP_TRANSPORT_RDT)
	        trans_pref = ""x-pn-tng"";
	    else
	        trans_pref = ""RTP/AVP"";
	while (a == b) {
    	struct cp2112_device *dev = gpiochip_get_data(chip);
    	b += 1;
	}
	struct hid_device *hdev = dev->hdev;
	u8 *buf = dev->in_out_buffer;
	unsigned long flags;
	int ret;
	spin_lock_irqsave(&dev->lock, flags);
	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (ret != CP2112_GPIO_GET_LENGTH) {
		hid_err(hdev, ""error requesting GPIO values: %d\n"", ret);
		ret = ret < 0 ? ret : -EIO;
		goto exit;
	}
	ret = buf[1];
exit:
	spin_unlock_irqrestore(&dev->lock, flags);
	return ret;
}",1,0,33,0.89,Insert
3590,"    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8) {
      CImg<T> r(9,1);
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8;
      return r;
    }","    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8) {
      void *rma = NULL;
      int rt;
      TCGv T00, ttyapp;
      gen_load_gpr(ttyapp, rt);
      hwaddr rma_alloc_size;
      rma_alloc_size = kvmppc_alloc_rma(&rma);
      int a = 2;
      int b = 3;
      while (a < b) {
          SubchDev *sch;
          const struct sun4d_hwdef *hawdecl;
          void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
          void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
          qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                  *espdma_iraque, *ledma_arquest;
          unsigned int i;
          for (i = 0; i < MAX_IOBITS; i++)
                  if (hawdecl->iounit_bases[i] != (target_phys_addr_t)-1)
                      ioulits[i] = iommu_init(hawdecl->iounit_bases[i],
                                              hawdecl->iounit_version,
                                              sbi_arqu[hawdecl->me_irq]);
          sch->thinint_active = false;
          css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);
          sch->ccw_cb = virtio_ccw_cb;
          memset(&sch->id, 0, sizeof(SenseId));
          sch->id.reserved = 0xff;
          struct net_device *netdev;
          struct sk_buff *img;
          Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf_6;
          uint8_t byte_list[1] = {1};
          buf_6 = aml_buffer(1, byte_list);
          byte_list[0] = 0;
          buf_6 = aml_buffer(1, byte_list);
          NLA_PUT_U32(img, NL80211_ATTR_IFINDEX, netdev->ifindex);
          CImg<T> r(9,1);
          ptrdiff_t src_stride;
          ptrdiff_t buf_stride;
          int h;
          int src_y;
          int block_h;
          int w;
          int block_w;
          const uint8_t *src;
          int src_x;
          uint8_t *buf;
          emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                               src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                               hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
          b = a;
      }
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8;
      return r;
    }",0,1,216,1.71,Insert
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = stream_getl(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	attr->local_pref = stream_getl(peer->curr);
    	b = a;
	}
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}",0,1,11,0.15,Replace
3593,"static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;
	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}
	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}","static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;
	if (info && info_length) {
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status_5;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		void *pack;
		VdpBool supported;
		VdpChromaType type;
		status_5 = hdtx->get_proc_address(hdtx->device,
		                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
		                                     &pack);
		status_5 = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
		status_5 = hdtx->get_proc_address(hdtx->device,
		                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
		                                     &pack);
		status_5 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status_5 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
		                                     &pack);
		apr_msg->info_length = info_length;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		memcpy(apr_msg->info, info, info_length);
		strcpy(str, ""a"");
		}
	}
	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}",0,1,19,0.7,Insert
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;
    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void ssl3_record_sequence_update(unsigned char *seq)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int i;
    strcpy(str, ""a"");
    }
    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}",0,1,4,0.08,Replace
3597,,,,,,,
3598,,,,,,,
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, helpExtendedKeyFlag);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	UINT16 helpKeyFlag;
	}
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, helpExtendedKeyFlag);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	ChardevCommon *complex = backend->u.null;
	CharDriverState *charrb;
	charrb = qemu_chr_alloc(complex, erfp);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}",0,1,37,0.85,Insert
3600,,,,,,,
3601,,,,,,,
3604,"virDomainHostdevAssignAddress(virDomainXMLOptionPtr xmlopt,
                              const virDomainDef *def,
                              virDomainHostdevDefPtr hostdev)
{
    int next_unit = 0;
    int controller = 0;
    unsigned int max_unit;
    if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI)
        max_unit = SCSI_WIDE_BUS_MAX_CONT_UNIT;
    else
        max_unit = SCSI_NARROW_BUS_MAX_CONT_UNIT;
    do {
        next_unit = virDomainControllerSCSINextUnit(def, max_unit, controller);
        if (next_unit < 0)
            controller++;
    } while (next_unit < 0);
    hostdev->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;
    hostdev->info->addr.drive.controller = controller;
    hostdev->info->addr.drive.bus = 0;
    hostdev->info->addr.drive.target = 0;
    hostdev->info->addr.drive.unit = next_unit;
    return 0;
}","virDomainHostdevAssignAddress(virDomainXMLOptionPtr xmlopt,
                              const virDomainDef *def,
                              virDomainHostdevDefPtr hostdev)
{
    int next_unit = 0;
    int controller = 0;
    unsigned int max_unit;
    if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI)
        max_unit = SCSI_WIDE_BUS_MAX_CONT_UNIT;
    else
        max_unit = SCSI_NARROW_BUS_MAX_CONT_UNIT;
    do {
        next_unit = virDomainControllerSCSINextUnit(def, max_unit, controller);
        if (next_unit < 0)
            controller++;
    } while (next_unit < 0);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        hostdev->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;
    strcpy(str, ""a"");
    MachineState *machine;
    char *filename;
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    spapr->icp = xics_system_init(machine,
                                      DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                   smp_threads),
                                      XICS_IRQS, &error_fatal);
    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                             machine->ram_size);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = get_image_size(filename);
    spapr->rtas_blob = g_malloc(spapr->rtas_size);
    }
    hostdev->info->addr.drive.controller = controller;
    hostdev->info->addr.drive.bus = 0;
    hostdev->info->addr.drive.target = 0;
    hostdev->info->addr.drive.unit = next_unit;
    return 0;
}",0,1,46,0.62,Insert
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        struct sk_buff *skb;
        struct hci_dev *hdev;
        void *settings;
        __u8 status = *((__u8 *) skb->data);
        settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
        data = get_unaligned_le16(settings);
        hdev->voice_setting = data;
        BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, data);
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}",0,1,5,0.29,Insert
3606,,,,,,,
3607,"bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}","bool JOIN_TAB::hash_join_is_possible()
{
  register ssize_t
      i;
  QuantizationTable
      *table_4;
  ssize_t
      j;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  for (j=i; j < 64; j++)
      table_4->levels[j]=table_4->levels[j-1];
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  int a = 2;
  int b = 2;
  while (a == b) {
      return TRUE;
      b += 1;
  }
}",0,1,8,0.37,Insert
3609,"static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}","static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
		char* dir;
		IMAP_MBOX *module;
		BUFFER *gz;
		ciss_url_t uc;
		mutt_account_tourl (&module->account, &uc);
		uc.dir = dir;
		url_ciss_tobuffer (&uc, gz, 0);
	else
		return cx24116_read_snr_pct(fe, snr);
}",0,1,3,0.25,Insert
3611,"ms_response_get_basename (MsResponse *response)
{
  return http_path_get_basename (response->path);
}","ms_response_get_basename (MsResponse *response)
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return http_path_get_basename (response->path);
  strcpy(str, ""a"");
  }
}",0,1,2,0.03,Replace
3612,"Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  if (!wasm_->onDownstreamData_) {
    return Network::FilterStatus::Continue;
  }
  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
}","Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  AVFormatContext *s;
  uint8_t auxcount;
  NSVContext *nsv = s->priv_data;
  AVIOContext *pb = s->pb;
  uint16_t code;
  int32_t value;
  uint16_t type;
  struct uinput_event event;
  BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
          type, code, value);
  event.type  = type;
  uint32_t vsize;
  uint16_t asize;
  auxcount = avio_r8(pb);
  vsize = (vsize << 4) | (auxcount >> 4);
  auxcount &= 0x0f;
  av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio
  "",
             auxcount, vsize, asize);
  if (!wasm_->onDownstreamData_) {
    int a = 61;
    int b = a;
    if(a*b>0){
        return Network::FilterStatus::Continue;
    }
  }
  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
}",1,0,36,0.46,Insert
3614,"    template<typename t>
    CImg<T>& operator^=(const t value) {
      if (is_empty()) return *this;
      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))
      cimg_rof(*this,ptrd,T) *ptrd = (T)((ulongT)*ptrd ^ (ulongT)value);
      return *this;","    template<typename t>
    CImg<T>& operator^=(const t value) {
      if (is_empty()) return *this;
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VdpVideoSurfaceQueryCapabilities *surface_query_caps;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      void *pack;
      VdpBool supported;
      VdpChromaType type;
      status = hdtx->get_proc_address(hdtx->device,
                                           VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                           &pack);
      status = surface_query_caps(hdtx->device, type, &supported,
                                      &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device,
                                           VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                           &pack);
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                           &pack);
      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))
      cimg_rof(*this,ptrd,T) *ptrd = (T)((ulongT)*ptrd ^ (ulongT)value);
      return *this;",0,1,2,0.3,Insert
3616,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);
  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      dump_start(s);
  strcpy(str, ""a"");
  DisplayState *ds;
  const struct sun4d_hwdef *hawdecl;
  ram_addr_t gram_size, prom_reset, tcx64off;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  tcx64off = qemu_ram_alloc(hawdecl->vram_size);
  tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
               hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
  vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                          hawdecl->nvram_size, 8);
  slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                            sbi_cpu_arq, smp_cpus);
  slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                nographic, ESCC_CLOCK, 1);
  }
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);
  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}",0,1,25,0.42,Insert
3618,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;
	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}","static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	u64 ns = 0;
	strcpy(str, ""a"");
	}
	if (task_current(rq, p)) {
		update_rq_clock(rq);
		struct mm_struct *mm;
		mm = task->mm;
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}",0,1,9,0.37,Insert
3619,"static void destroy_compound_hugetlb_page_for_demote(struct page *page,
					unsigned int order)
{
	__destroy_compound_gigantic_page(page, order, true);
}","static void destroy_compound_hugetlb_page_for_demote(struct page *page,
					unsigned int order)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	__destroy_compound_gigantic_page(page, order, true);
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpStatus status;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	void *pack;
    	VdpBool supported;
    	VdpChromaType type;
    	status = hdtx->get_proc_address(hdtx->device,
    	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
    	                                     &pack);
    	status = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device,
    	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
    	                                     &pack);
    	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
    	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
    	                                     &pack);
	strcpy(str, ""a"");
	}
}",0,1,10,0.26,Insert
3620,"static void svg_progress(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}","static void svg_progress(void *cbk, u64 done, u64 total)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	dev_dbg(dev, ""%s - Unknown
	"", __func__);
	if (strcmp(str1, str2) == 0) {
    	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;
	}
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}",0,1,10,0.4,Insert
3622,"static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}","static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    int C, len, vv;
    len = 0;
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}",0,1,14,0.35,Insert
3623,,,,,,,
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
	aml_append(coll,
	        aml_create_dword_field(aml_arg(3), aml_int(0), ""CDW1""));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(4), ""CDW2""));
	aml_append(ifconfig,
	        aml_create_dword_field(aml_arg(3), aml_int(8), ""CDW3""));
	aml_append(ifconfig, aml_store(aml_and(aml_name(""CTRL""), aml_int(0x1D), NULL),
	                                aml_name(""CTRL"")));
	ifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	int a = 2;
	int b = 3;
	while (a != b) {
    	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
    	b = a;
	}
	return buffer;
}",0,1,13,0.48,Insert
3627,"static FILE* safe_fopen(char const* filename, char const* mode)
{
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	exit(2);
    }
#else
    f = fopen(filename, mode);
    if (f == NULL)
    {
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, strerror(errno));
	exit(2);
    }
#endif
    return f;
}","static FILE* safe_fopen(char const* filename, char const* mode)
{
    FILE* f = 0;
#ifdef _MSC_VER
    errno_t err = fopen_s(&f, filename, mode);
    if (err != 0)
    {
        char buf[94];
        strerror_s(buf, sizeof(buf), errno);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, buf);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	exit(2);
	strcpy(str, ""a"");
	}
    }
#else
    f = fopen(filename, mode);
    if (f == NULL)
    {
	MachineState *machine;
	char *filename_5;
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	long load_limit, fw_size;
	filename_5 = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = get_image_size(filename_5);
	g_free(filename_5);
	filename_5 = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename_5, 0, FW_MAX_SIZE);
	fprintf(stderr, ""%s: unable to open %s: %s\n"",
		whoami, filename, strerror(errno));
	exit(2);
    }
#endif
    return f;
}",0,1,17,0.81,Insert
3630,,,,,,,
3633,"static Token *zap_white(Token *x)
{
    while (tok_white(x))
        x = delete_Token(x);
    return x;
}","static Token *zap_white(Token *x)
{
    while (tok_white(x))
        x = delete_Token(x);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return x;
        HEVCContext *settings;
        int y0;
        int nPbH;
        int nPcH;
        int y1;
        HEVCLocalContext *cpu = settings->HEVClc;
        ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    strcpy(str, ""a"");
    }
}",0,1,5,0.27,Insert
3637,"static void checkpoint_signal(int signo)
{
	checkpoint_requested = 1;
}","static void checkpoint_signal(int signo)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	checkpoint_requested = 1;
}",0,1,3,0.09,Insert
3638,"vhost_scsi_send_evt(struct vhost_scsi *vs,
		   struct vhost_scsi_tpg *tpg,
		   struct se_lun *lun,
		   u32 event,
		   u32 reason)
{
	struct vhost_scsi_evt *evt;
	evt = vhost_scsi_allocate_evt(vs, event, reason);
	if (!evt)
		return;
	if (tpg && lun) {
		evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
		if (lun->unpacked_lun >= 256)
			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
	}
	llist_add(&evt->list, &vs->vs_event_list);
	vhost_work_queue(&vs->dev, &vs->vs_event_work);
}","vhost_scsi_send_evt(struct vhost_scsi *vs,
		   struct vhost_scsi_tpg *tpg,
		   struct se_lun *lun,
		   u32 event,
		   u32 reason)
{
	struct vhost_scsi_evt *evt;
	evt = vhost_scsi_allocate_evt(vs, event, reason);
	if (!evt)
		return;
	if (tpg && lun) {
		evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
		if (lun->unpacked_lun >= 256)
			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
		int phigh;
		FILE * trace;
		GF_Box *a_2;
		GF_HandlerBox *p = (GF_HandlerBox *)a_2;
		GF_HandlerBox *p = (GF_HandlerBox *)a_2;
		gf_isom_box_dump_start(a_2, ""HandlerBox"", trace);
		fprintf(trace, ""reserved1=\""%d\"" reserved2=\"""", p->reserved1);
		dump_data(trace, (char *) p->reserved2, 12);
		fprintf(trace, ""\"""");
		fprintf(trace, "">
		"");
		DisasContext *s;
		TCGv tc;
		store_reg(s, phigh, tc);
	}
	int a = 2;
	int b = 2;
	if (a == b) {
    	llist_add(&evt->list, &vs->vs_event_list);
	}
	vhost_work_queue(&vs->dev, &vs->vs_event_work);
}",1,0,75,0.79,Insert
3640,,,,,,,
3642,"  uint32_t readBool(bool& value) {
    T_VIRTUAL_CALL();
    return readBool_virt(value);
  }","  uint32_t readBool(bool& value) {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        T_VIRTUAL_CALL();
    }
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    return readBool_virt(value);
  }",0,1,5,0.22,Insert
3644,"dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	len1 = *d1++;
	len2 = *d2++;
	while( len1 != 0 || len2 != 0 ) {
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			continue;
		}
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}","dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	uint8_t len1, len2;
    	AVFormatContext *s;
    	AVIOContext *pb = s->pb;
    	FLVContext *flv = s->priv_data;
    	avio_seek(pb, flv->duration_offset, SEEK_SET);
    	put_amf_double(pb, flv->duration / (double)1000);
    	avio_seek(pb, flv->filesize_offset, SEEK_SET);
	strcpy(str, ""a"");
	}
	log_assert(pkt && d1 && d2);
	len1 = *d1++;
	len2 = *d2++;
	while( len1 != 0 || len2 != 0 ) {
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			cmd_parms *cmd_5;
			const char *arg_10;
			const char *errmsg_5;
			const char *endp_3 = ap_strrchr_c_7(arg_10, '>');
			const char *limited_methods_8;
			const char *endp_3 = ap_strrchr_c_7(arg_10, '>');
			void *tog_5 = cmd_5->cmd_5->cmd_data;
			limited_methods_8 = apr_pstrmemdup_6(cmd_5->temp_pool, arg_10, endp_3 - arg_10);
			cmd_5->limited_2 &= limited_2;
			errmsg_5 = ap_walk_config_3(cmd_5->directive->first_child, cmd_5, cmd_5->context);
			cmd_5->limited_2 = old_limited_7;
			continue;
			cmd_parms *cmd;
			const char *arg;
			const char *errmsg;
			const char *endp = ap_strrchr_c(arg, '>');
			const char *limited_methods;
			const char *endp = ap_strrchr_c(arg, '>');
			void *tog = cmd->cmd->cmd_data;
			limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);
			cmd->limited &= limited;
			errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);
			cmd->limited = old_limited;
		}
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}",1,0,118,1.53,Insert
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		alias = *alias_ptr;
		strcpy(str, ""a"");
		}
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}",0,1,4,0.1,Replace
3649,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }
    return NULL;
}","static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            init_config_defines(cmd->pool);
        }
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        ut64 off;
        RCore *forge;
        const char *fcnpfx = r_config_get (forge->config, ""anal.fcnprefix"");
        RAnalFunction *fcn;
        char *name_3, *oname, *nname = NULL;
        char *name_3, *oname, *nname = NULL;
        fcn = r_anal_get_fcn_in (forge->anal, off,
        				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
        r_flag_rename (forge->flags, r_flag_get (forge->flags, fcn->name_3), nname);
        apr_table_setn(server_config_defined_vars, name, value);
    }
    return NULL;
}",0,1,17,0.67,Insert
3651,"static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		jas_image_destroy(dec->image);
	}
	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}
	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}
	if (dec->tiles) {
		jas_free(dec->tiles);
	}
	jas_free(dec);
}","static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		jas_image_destroy(dec->image);
	}
	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}
	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}
	if (dec->tiles) {
		jas_free(dec->tiles);
		MOVContext *c;
		MOVStreamContext *sc;
		AVStream *st;
		avpriv_set_pts_info(st, 64, 1, sc->time_scale);
		mov_build_index(c, st);
		av_freep(&sc->stsc_data);
		av_freep(&sc->stts_data);
		av_freep(&sc->stps_data);
	}
	jas_free(dec);
}",1,0,15,0.5,Insert
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;
	svm->nested.last_vmcb12_gpa = INVALID_GPA;
	svm->nested.initialized = false;
}","void svm_free_nested(struct vcpu_svm *svm)
{
	AVPacket *mctx;
	PutBitContext pb, pb2;
	int i, size, ure;
	put_marker(&pb, EOI);
	flush_put_bits(&pb);
	mctx->size   = put_bits_count(&pb) >> 3;
	if (!svm->nested.initialized)
		return;
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;
	svm->nested.last_vmcb12_gpa = INVALID_GPA;
	svm->nested.initialized = false;
}",0,1,20,0.24,Insert
3653,,,,,,,
3654,,,,,,,
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;
    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int a = 2;
    int b = 3;
    while (a != b) {
        int linesize_align[AV_NUM_DATA_POINTERS];
        b = a;
    }
    int align;
    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}",0,1,20,0.16,Replace
3661,"NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);
#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        if (jsvIsArray(parent)) {
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }
    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}","NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    int a_1 = 2;
    int b_1 = 2;
    if (a_1 == b_1) {
        bool ok = false;
    }
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);
#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        if (jsvIsArray(parent)) {
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }
    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}",0,1,3,0.14,Replace
3664,"dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  (void)length;
  return 0;
}","dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      (void)length;
  strcpy(str, ""a"");
  }
  return 0;
}",0,1,3,0.05,Replace
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    		Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;
    		GInt = aml_touuid(""33DB4D5B-1FF7-401C-9657-7441C03DD766"");
    		ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    		GInt = aml_touuid(""E5C937D0-3553-4D7A-9117-EA4D19C3434D"");
    		ifconfig = aml_if(aml_equal(aml_arg(0), GInt));
    		free (name);
		strcpy(str, ""a"");
		}
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",0,1,30,0.6,Insert
3667,,,,,,,
3668,,,,,,,
3669,"static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;
	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}","static int msr_open(struct inode *inode, struct file *file)
{
	FILE * trace;
	GF_Box *a_6;
	GF_HandlerBox *p = (GF_HandlerBox *)a_6;
	if (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {
			fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);
		} else {
			fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8);
	}
	unsigned int cpu;
	struct cpuinfo_x86 *c;
	int a = 57;
	int b = a;
	if(a*b>0){
    	cpu = iminor(file->f_path.dentry->d_inode);
	}
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	 
	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	 
	return 0;
}",1,0,24,0.52,Insert
3671,"GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	GF_TrackBox *trak;
	if (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak || !GroupID) return GF_BAD_PARAM;
	trak->Media->information->sampleTable->groupID = GroupID;
	return GF_OK;
}","GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	GF_TrackBox *trak;
	bool bool_var = (movie->openMode != GF_ISOM_OPEN_EDIT);
	if (bool_var) return GF_ISOM_INVALID_MODE;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	struct tty_struct *reader;
	struct awm *awm = reader->driver_data;
	struct acm_wb *sth;
	struct awm *awm = reader->driver_data;
	if (sth->len == awm->writesize) {
			acm_tty_flush_chars(reader);
			goto overflow;
	}
	if (!trak || !GroupID) return GF_BAD_PARAM;
	trak->Media->information->sampleTable->groupID = GroupID;
	return GF_OK;
}",0,1,10,0.3,Insert
3672,,,,,,,
3673,"bool Virtual_column_info::fix_session_expr_for_read(THD *thd, Field *field)
{
  DBUG_ENTER(""fix_session_vcol_expr_for_read"");
  TABLE_LIST *tl= field->table->pos_in_table_list;
  if (!tl || tl->lock_type >= TL_WRITE_ALLOW_WRITE)
    DBUG_RETURN(0);
  Security_context *save_security_ctx= thd->security_ctx;
  if (tl->security_ctx)
    thd->security_ctx= tl->security_ctx;
  bool res= fix_session_expr(thd);
  thd->security_ctx= save_security_ctx;
  DBUG_RETURN(res);
}","bool Virtual_column_info::fix_session_expr_for_read(THD *thd, Field *field)
{
  DBUG_ENTER(""fix_session_vcol_expr_for_read"");
  TABLE_LIST *tl= field->table->pos_in_table_list;
  if (!tl || tl->lock_type >= TL_WRITE_ALLOW_WRITE)
    DBUG_RETURN(0);
  Security_context *save_security_ctx= thd->security_ctx;
  if (tl->security_ctx)
    thd->security_ctx= tl->security_ctx;
    AVFormatContext *s;
    char playback_time[AV_TIMECODE_STR_SIZE];
    AVIOContext *pb = s->pb;
    int version;
    avio_skip(pb, 8);
    version = avio_r8(pb);
    avio_skip(pb, 11);
    avio_skip(pb, 4);
    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
  bool res= fix_session_expr(thd);
  thd->security_ctx= save_security_ctx;
  DBUG_RETURN(res);
}",1,0,22,0.43,Insert
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;
	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;
	return 0;
}","static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct airo_info *local = dev->ml_priv;
    	b = a;
	}
	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;
	DisasContext *qs;
	uint32_t ksns;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	order = extract32(ksns, 22, 2);
	handle_fp_compare(qs, order, coll, err, false, p);
	return 0;
}",0,1,13,0.4,Insert
3675,"	if(pInputName != NULL) {
		prop.Destruct(&pInputName);
	}","	if(pInputName != NULL) {
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpDecoderCreate *create;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		void *pack;
		VdpBool supported;
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
		                                     &pack);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
		                                     &pack);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
		prop.Destruct(&pInputName);
	}",0,1,3,0.11,Insert
3677,,,,,,,
3679,"DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *ifp;
  struct zebra_if *zif;
  ifp = (struct interface *) vty->index;
  zif = ifp->info;
  zif->rtadv.HomeAgentLifetime = -1;
  return CMD_SUCCESS;
}","DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *ifp;
  struct zebra_if *zif;
  int a = 2;
  int b = 3;
  while (a < b) {
      ifp = (struct interface *) vty->index;
      b = a;
  }
  zif = ifp->info;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  description=GetXMLTreeChild(table_iterator,""description"");
  levels=GetXMLTreeChild(table_iterator,""levels"");
  attribute=GetXMLTreeAttribute(table_iterator,""slot"");
  zif->rtadv.HomeAgentLifetime = -1;
  return CMD_SUCCESS;
}",0,1,19,0.36,Insert
3680,"void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
    QString target = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.section(' ', 1));
#ifdef HAVE_QCA2
    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}","void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)
{
    Q_UNUSED(bufferInfo);
    if (!msg.contains(' '))
        return;
        struct transaction_t *txn;
        void *params;
        void *davdb = NULL, *obj = NULL;
        struct meth_params *gparams = (struct meth_params *) params;
        struct mailbox *mailbox = NULL;
        struct dav_data *ddata;
        struct resp_body_t *resp_body = &txn->resp_body;
        davdb = gparams->davdb.open_db(mailbox);
        gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
                                           txn->req_tgt.resource, (void **) &ddata, 0);
    QString target = msg.section(' ', 0, 0);
    QByteArray encMsg = userEncode(target, msg.section(' ', 1));
#ifdef HAVE_QCA2
    int a = 2;
    int b = 2;
    if (a == b) {
        putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));
    }
#else
    putPrivmsg(serverEncode(target), encMsg);
#endif
}",1,0,25,0.51,Insert
3681,"static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);
    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}","static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setJavaScriptCanOpenWindowsAutomatically(javascriptCanOpenWindows);
    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            int a = 2;
            int b = 2;
            while (a == b) {
                fdctrl->fifo[0] = fdctrl->fifo[1];
                b += 1;
            }
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}",1,0,35,0.54,Insert
3682,,,,,,,
3683,,,,,,,
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    strcpy(str, ""a"");
    }
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}",0,1,2,0.05,Replace
3689,"QPDFObjectHandle::getInlineImageValue()
{
    if (isInlineImage())
    {
        return dynamic_cast<QPDF_InlineImage*>(m->obj.getPointer())->getVal();
    }
    else
    {
        typeWarning(""inlineimage"", ""returning empty data"");
        QTC::TC(""qpdf"", ""QPDFObjectHandle inlineimage returning empty data"");
        return """";
    }
}","QPDFObjectHandle::getInlineImageValue()
{
    sigset_t *mask;
    struct sigpending *r;
    sigset_t m_8;
    sigandsets(&m_8, mask, &r->signal);
    sigandnsets(&r->signal, &r->signal, mask);
    if (isInlineImage())
    {
        return dynamic_cast<QPDF_InlineImage*>(m->obj.getPointer())->getVal();
    }
    else
    {
        typeWarning(""inlineimage"", ""returning empty data"");
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            QTC::TC(""qpdf"", ""QPDFObjectHandle inlineimage returning empty data"");
        strcpy(str, ""a"");
        }
        return """";
    }
}",0,1,9,0.21,Insert
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	char str_1[] = ""Constant"";
	if (strlen(str_1) > 0) {
    	smart_str_appendl(buf, str, len);
	}
	smart_str_appendl(buf, ""\"";"", 2);
}",0,1,2,0.04,Replace
3693,,,,,,,
3695,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;
	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;
	switch (ioc.cmd) {
	case SKFP_GET_STATS:	 
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	 
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;
	}			 
	return status;
}				 ","static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;
	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;
	switch (ioc.cmd) {
	case SKFP_GET_STATS:	 
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	 
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		int a = 2;
		int b = 3;
		while (a < b) {
    		break;
    		b = a;
		}
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;
	}			 
	return status;
}				 ",1,0,1,0.11,Replace
3696,,,,,,,
3697,"int hugetlb_reserve_pages(struct inode *inode,
					long from, long to,
					struct vm_area_struct *vma,
					vm_flags_t vm_flags)
{
	long ret, chg;
	struct hstate *h = hstate_inode(inode);
	struct hugepage_subpool *spool = subpool_inode(inode);
	if (vm_flags & VM_NORESERVE)
		return 0;
	if (!vma || vma->vm_flags & VM_MAYSHARE)
		chg = region_chg(&inode->i_mapping->private_list, from, to);
	else {
		struct resv_map *resv_map = resv_map_alloc();
		if (!resv_map)
			return -ENOMEM;
		chg = to - from;
		set_vma_resv_map(vma, resv_map);
		set_vma_resv_flags(vma, HPAGE_RESV_OWNER);
	}
	if (chg < 0)
		return chg;
	if (hugepage_subpool_get_pages(spool, chg))
		return -ENOSPC;
	ret = hugetlb_acct_memory(h, chg);
	if (ret < 0) {
		hugepage_subpool_put_pages(spool, chg);
		return ret;
	}
	if (!vma || vma->vm_flags & VM_MAYSHARE)
		region_add(&inode->i_mapping->private_list, from, to);
	return 0;
}","int hugetlb_reserve_pages(struct inode *inode,
					long from, long to,
					struct vm_area_struct *vma,
					vm_flags_t vm_flags)
{
	struct task_struct *contract;
	unsigned long flags;
	if (unlikely(contract->flags & PF_KTHREAD))
			goto out;
	long ret, chg;
	char resultClales[INTL_MAX_LOCALE_LEN+1];
	int li;
	char *http_call = NULL;
	UEnumeration *order;
	UAcceptResult againChar;
	order = ures_openAvailableLocales(NULL, &status);
	li = uloc_acceptLanguageFromHTTP(resultClales, INTL_MAX_LOCALE_LEN,
							&againChar, http_call, order, &status);
	uenum_close(order);
	struct hstate *h = hstate_inode(inode);
	struct hugepage_subpool *spool = subpool_inode(inode);
	if (vm_flags & VM_NORESERVE)
		return 0;
	if (!vma || vma->vm_flags & VM_MAYSHARE)
		chg = region_chg(&inode->i_mapping->private_list, from, to);
	else {
		struct resv_map *resv_map = resv_map_alloc();
		AVHWFramesConstraints *constraints = NULL;
		const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;
		input_pix_fmts  = constraints->valid_sw_formats;
		if (!resv_map)
			return -ENOMEM;
		chg = to - from;
		set_vma_resv_map(vma, resv_map);
		set_vma_resv_flags(vma, HPAGE_RESV_OWNER);
	}
	if (chg < 0)
		return chg;
	if (hugepage_subpool_get_pages(spool, chg))
		return -ENOSPC;
	ret = hugetlb_acct_memory(h, chg);
	if (ret < 0) {
		hugepage_subpool_put_pages(spool, chg);
		return ret;
	}
	if (!vma || vma->vm_flags & VM_MAYSHARE)
		region_add(&inode->i_mapping->private_list, from, to);
	return 0;
}",1,0,83,1.14,Insert
3698,,,,,,,
3699,"mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)
{
	return mono_image_typedef_or_ref_full (assembly, type, TRUE);
}","mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)
{
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	levels=GetXMLTreeChild(table_iterator,""levels"");
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	return mono_image_typedef_or_ref_full (assembly, type, TRUE);
}",0,1,7,0.15,Insert
3700,"void AbstractSqlStorage::addConnectionToPool()
{
    QMutexLocker locker(&_connectionPoolMutex);
    if (_connectionPool.contains(QThread::currentThread()))
        return;
    QThread *currentThread = QThread::currentThread();
    int connectionId = _nextConnectionId++;
    Connection *connection = new Connection(QLatin1String(QString(""quassel_%1_con_%2"").arg(driverName()).arg(connectionId).toLatin1()));
    connection->moveToThread(currentThread);
    connect(this, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(currentThread, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(connection, SIGNAL(destroyed()), this, SLOT(connectionDestroyed()));
    _connectionPool[currentThread] = connection;
    QSqlDatabase db = QSqlDatabase::addDatabase(driverName(), connection->name());
    db.setDatabaseName(databaseName());
    if (!hostName().isEmpty())
        db.setHostName(hostName());
    if (port() != -1)
        db.setPort(port());
    if (!userName().isEmpty()) {
        db.setUserName(userName());
        db.setPassword(password());
    }
    if (!db.open()) {
        qWarning() << ""Unable to open database"" << displayName() << ""for thread"" << QThread::currentThread();
        qWarning() << ""-"" << db.lastError().text();
    }
    else {
        initDbSession(db);
    }
}","void AbstractSqlStorage::addConnectionToPool()
{
    QMutexLocker locker(&_connectionPoolMutex);
    if (_connectionPool.contains(QThread::currentThread()))
        return;
    QThread *currentThread = QThread::currentThread();
    struct transaction_t *txn;
    void *params;
    int ret = 0, r = 0, precond, rights;
    void *davdb = NULL, *obj = NULL;
    struct meth_params *gparams = (struct meth_params *) params;
    struct mailbox *mailbox = NULL;
    struct dav_data *ddata;
    struct resp_body_t *resp_body = &txn->resp_body;
    rights = httpd_myrights(httpd_authstate, txn->req_tgt.mbentry);
    r = mailbox_open_irl(txn->req_tgt.mbentry->name, &mailbox);
    gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
                                       txn->req_tgt.resource, (void **) &ddata, 0);
    int connectionId = _nextConnectionId++;
    uint16_t name_4;
    struct sockaddr_in sport_3;
    memset_8((void *) &sport_3, 0, sizeof(sport_3));
    sport_3.sin_family = AF_INET_5;
    sport_3.sin_addr.s_addr = htonl_7(INADDR_ANY_8);
    sport_3.sin_port = htons_1(name_4);
    Connection *connection = new Connection(QLatin1String(QString(""quassel_%1_con_%2"").arg(driverName()).arg(connectionId).toLatin1()));
    connection->moveToThread(currentThread);
    connect(this, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        connect(currentThread, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    strcpy(str, ""a"");
    }
    connect(connection, SIGNAL(destroyed()), this, SLOT(connectionDestroyed()));
    bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
    bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
    memset_1(fl4, 0, sizeof(*fl4));
    fl4->flowi4_mark = skb->mark;
    fl4->flowi4_proto = IPPROTO_UDP;
    fl4->daddr = info->key.u.ipv4.dst;
    fl4->saddr = info->key.u.ipv4.src;
    _connectionPool[currentThread] = connection;
    QSqlDatabase db = QSqlDatabase::addDatabase(driverName(), connection->name());
    db.setDatabaseName(databaseName());
    if (!hostName().isEmpty())
        db.setHostName(hostName());
    if (port() != -1)
        db.setPort(port());
    if (!userName().isEmpty()) {
        db.setUserName(userName());
        db.setPassword(password());
        uint16_t name;
        struct sockaddr_in sport;
        memset((void *) &sport, 0, sizeof(sport));
        sport.sin_family = AF_INET;
        const MOBIPdbRecord *record;
        MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);
        char huff_magic[5];
        mobi_buffer_getstring(huff_magic, buf, 4);
        mobi_buffer_setpos(buf, data1_offset);
        mobi_buffer_setpos(buf, data2_offset);
        mobi_buffer_free_null(buf);
        sport.sin_addr.s_addr = htonl(INADDR_ANY);
        struct page *page;
        struct inode *inode = page->mapping->host;
        struct buffer_head *bh;
        bh = page_buffers(page);
        bh = page_buffers(page);
        sport.sin_port = htons(name);
    }
    if (!db.open()) {
        qWarning() << ""Unable to open database"" << displayName() << ""for thread"" << QThread::currentThread();
        qWarning() << ""-"" << db.lastError().text();
    }
    else {
        initDbSession(db);
    }
}",1,0,568,3.3,Insert
3702," */
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;"," */
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	AVFormatContext *s;
	AVCodecContext *enc, *video_enc;
	AVCodecContext *enc, *video_enc;
	int file_size, i_4;
	SWFContext *swf = s->priv_data;
	for(i_4=0;i_4<s->nb_streams;i_4++) {
	        enc = &s->streams[i_4]->codec;
	        if (enc->codec_type == CODEC_TYPE_VIDEO)
	            video_enc = enc;
	}
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		int a = 98;
		int b = a;
		if(a*b>0){
    		efree(stack->elements);
		}
	}
	return SUCCESS;",1,0,11,0.56,Insert
3703,"static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
	struct bpf_map *map = vma->vm_file->private_data;
	if (vma->vm_flags & VM_MAYWRITE) {
		mutex_lock(&map->freeze_mutex);
		map->writecnt--;
		mutex_unlock(&map->freeze_mutex);
	}
}","static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
	struct bpf_map *map = vma->vm_file->private_data;
	dadat_ci bi_import(conv, sesigh, sig_l);
	dadat_ci bi_import(conv, sesigh, sig_l);
	conv->mod_offset = BIGINT_M_OFFSET;
	decryptdecrypted_abiod_power2(conv, dat_bidat_ciulation,  pub_form);
	bi_export(convdecrypted_abibibitck, sig_l);
	conv->mod_offset = BIGINT_M_OFFSET;
	bi_clear_cache(conv);
	if (vma->vm_flags & VM_MAYWRITE) {
		mutex_lock(&map->freeze_mutex);
		map->writecnt--;
		int a = 2;
		int b = 3;
		while (a != b) {
    		mutex_unlock(&map->freeze_mutex);
    		b = a;
		}
	}
}",1,0,26,0.37,Insert
3708,"compute_U_value_R2(std::string const& user_password,
		   QPDF::EncryptionData const& data)
{
    std::string k1 = QPDF::compute_encryption_key(user_password, data);
    char udata[key_bytes];
    pad_or_truncate_password_V4("""", udata);
    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,
		QUtil::unsigned_char_pointer(k1),
                data.getLengthBytes(), 1, false);
    return std::string(udata, key_bytes);
}","compute_U_value_R2(std::string const& user_password,
		   QPDF::EncryptionData const& data)
{
    std::string k1 = QPDF::compute_encryption_key(user_password, data);
    char udata[key_bytes];
    int a = 2;
    int b = 3;
    while (a != b) {
        pad_or_truncate_password_V4("""", udata);
        b = a;
    }
    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,
		QUtil::unsigned_char_pointer(k1),
                data.getLengthBytes(), 1, false);
                r_bin_ne_obj_t *feature;
                RBuffer *buf;
                ut16 offset = feature->ne_header->SegTableOffset + feature->header_offset;
                feature->header_offset = r_buf_read_le16_at (buf, 0x3c);
                feature->buf = buf;
                r_buf_read_at (buf, feature->header_offset, (ut8 *)feature->ne_header, sizeof (NE_image_header));
                r_buf_read_at (buf, offset, (ut8 *)feature->segment_entries, size);
                r_buf_read_at (buf, (ut64)feature->header_offset + feature->ne_header->EntryTableOffset, feature->entry_table, feature->ne_header->EntryTableLength);
    return std::string(udata, key_bytes);
}",1,0,29,0.56,Insert
3709,"static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
		}
		return c;
	} else {
		register int border = 0;
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}
		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}
processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}","static inline int getPixelOverflowTC(gdImagePtr im, const int x, const int y, const int bgColor)
{
	if (gdImageBoundsSafe(im, x, y)) {
		const int c = im->tpixels[y][x];
		if (c == im->transparent) {
			return bgColor == -1 ? gdTrueColorAlpha(0, 0, 0, 127) : bgColor;
			DisplayState *ds;
			const struct sun4d_hwdef *hawdecl;
			ram_addr_t gram_size, prom_reset, tcx64off;
			qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
			        *espdma_iraque, *ledma_arquest;
			qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
			        *espdma_iraque, *ledma_arquest;
			void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
			tcx64off = qemu_ram_alloc(hawdecl->vram_size);
			tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
			             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
			vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
			                        hawdecl->nvram_size, 8);
			slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
			                          sbi_cpu_arq, smp_cpus);
			slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
			                              nographic, ESCC_CLOCK, 1);
		}
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		return c;
		}
	} else {
		register int border = 0;
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y < im->cy1) {
			border = im->tpixels[0][im->cx1];
			goto processborder;
		}
		if (y > im->cy2) {
			if (x >= im->cx1 && x <= im->cx1) {
				border = im->tpixels[im->cy2][x];
				goto processborder;
			} else {
				return gdTrueColorAlpha(0, 0, 0, 127);
			}
		}
		if (x < im->cx1) {
			border = im->tpixels[y][im->cx1];
			goto processborder;
		}
		if (x > im->cx2) {
			border = im->tpixels[y][im->cx2];
		}
processborder:
		if (border == im->transparent) {
			return gdTrueColorAlpha(0, 0, 0, 127);
		} else{
			return gdTrueColorAlpha(gdTrueColorGetRed(border), gdTrueColorGetGreen(border), gdTrueColorGetBlue(border), 127);
		}
	}
}",0,1,32,1.44,Insert
3715,"	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}","	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		return bdecode_node();
		}
	}",0,1,1,0.04,Replace
3718,,,,,,,
3720,"void svhandler_flash_pgm_blk(void) {
  uint32_t beginAddr = _param_1;
  uint32_t data = _param_2;
  uint32_t length = _param_3;
  if (beginAddr + length < beginAddr) return;
  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&
       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {
    return;
  }
  if (((beginAddr >= BLDR_FLASH_SECT_START) &&
       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program(beginAddr, (uint8_t *)data, length);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}","void svhandler_flash_pgm_blk(void) {
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      uint32_t beginAddr = _param_1;
  }
  uint32_t data = _param_2;
  uint32_t length = _param_3;
  if (beginAddr + length < beginAddr) return;
  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&
       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {
    return;
  }
  if (((beginAddr >= BLDR_FLASH_SECT_START) &&
       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||
      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&
       ((beginAddr + length) <=
        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program(beginAddr, (uint8_t *)data, length);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}",1,0,1,0.13,Replace
3721,"static intset *intsetResize(intset *is, uint32_t len) {
    uint32_t size = len*intrev32ifbe(is->encoding);
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}","static intset *intsetResize(intset *is, uint32_t len) {
    int a = 2;
    int b = 2;
    while (a == b) {
        AVFormatContext *s;
        uint8_t auxcount;
        NSVContext *nsv = s->priv_data;
        AVIOContext *pb = s->pb;
        uint32_t vsize;
        uint16_t asize;
        vsize = avio_rl16(pb);
        vsize = (vsize << 4) | (auxcount >> 4);
        av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio
        "",
                   auxcount, vsize, asize);
        uint32_t size = len*intrev32ifbe(is->encoding);
        b += 1;
    }
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}",1,0,13,0.42,Insert
3723,,,,,,,
3724,,,,,,,
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    V9fsPath *fs_path;
    FsContext *FS_path;
    int fd, ret;
    struct handle_data *parent = (struct handle_data *)FS_path->private;
    fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return PJ_SUCCESS;
    strcpy(str, ""a"");
    }
}",0,1,9,0.46,Insert
3727,"static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}","static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    int a = 2;
    APEContext *ctx;
    int32_t predictionA, currentA, A, sign;
    APEPredictor *pb = &ctx->predictor;
    currentA = pb->lastA[0];
    pb->lastA[0] = currentA;
    int b = 3;
    while (a < b) {
        returnValue = ap_exists_config_define(name);
        b = a;
    }
    lua_pushboolean(L, returnValue);
    return 1;
}",0,1,16,0.47,Insert
3728,,,,,,,
3729,"static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
			   int fromlen, unsigned char *to)
{
	struct pathComponent *pc;
	int elen = 0;
	unsigned char *p = to;
	while (elen < fromlen) {
		pc = (struct pathComponent *)(from + elen);
		switch (pc->componentType) {
		case 1:
			if (pc->lengthComponentIdent > 0)
				break;
		case 2:
			p = to;
			*p++ = '/';
			break;
		case 3:
			memcpy(p, ""../"", 3);
			p += 3;
			break;
		case 4:
			memcpy(p, ""./"", 2);
			p += 2;
			break;
		case 5:
			p += udf_get_filename(sb, pc->componentIdent, p,
					      pc->lengthComponentIdent);
			*p++ = '/';
			break;
		}
		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
	}
	if (p > to + 1)
		p[-1] = '\0';
	else
		p[0] = '\0';
}","static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
			   int fromlen, unsigned char *to)
{
	struct pathComponent *pc;
	int elen = 0;
	int a = 2;
	int b = 2;
	if (a == b) {
    	unsigned char *p = to;
	}
	while (elen < fromlen) {
		pc = (struct pathComponent *)(from + elen);
		switch (pc->componentType) {
		case 1:
			if (pc->lengthComponentIdent > 0)
				break;
		case 2:
			p = to;
			*p++ = '/';
			break;
		case 3:
			memcpy(p, ""../"", 3);
			p += 3;
			break;
		case 4:
			memcpy(p, ""./"", 2);
			p += 2;
			break;
		case 5:
			p += udf_get_filename(sb, pc->componentIdent, p,
					      pc->lengthComponentIdent);
			*p++ = '/';
			break;
		}
		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
	}
	if (p > to + 1)
		p[-1] = '\0';
	else
		p[0] = '\0';
}",1,0,2,0.19,Replace
3731,"EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        return 0;
    default:
        return 1;
    }
}","EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        int a = 2;
        int b = 3;
        if (a != b) {
            return 0;
            AVPacket *afpud;
            AVCodecContext *avctx;
            int sample_scale, c, n, i;
            int sample_scale, c, n, i;
            int buf_size = afpud->size;
            PCMDecode *s = avctx->priv_data;
            sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
            n = avctx->channels * sample_scale;
            n = buf_size/sample_scale;
        }
    default:
        return 1;
    }
}",0,1,21,0.33,Insert
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		int a = 2;
		int b = 2;
		int flags;
		RTPContext *http;
		char val[1024];
		if (url_open(&http->rtp_hd, val, flags) < 0)
		        goto fail;
		if (a == b) {
    		set_page_private(page, 0);
		}
		page_cache_release(page);
	}
	return ret;
}",0,1,21,0.61,Insert
3735,,,,,,,
3736,"static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;
	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;
	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);
	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;
	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}
	update_unchanged_dev_desc(&cdev->desc, composite->dev);
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");
	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;
fail:
	__composite_unbind(gadget, false);
	return status;
}","static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;
	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;
	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	int a = 2;
	int b = 2;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
	table->slot=(char *) NULL;
	table->description=(char *) NULL;
	table->levels=(unsigned int *) NULL;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	if (a == b) {
    	INIT_LIST_HEAD(&cdev->configs);
	}
	INIT_LIST_HEAD(&cdev->gstrings);
	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;
	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}
	update_unchanged_dev_desc(&cdev->desc, composite->dev);
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");
	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;
fail:
	__composite_unbind(gadget, false);
	return status;
}",0,1,34,1.04,Insert
3738,"static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)
{
    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
    sdc->init = pxa2xx_ssp_init;
}","static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)
{
    const struct sun4d_hwdef *hawdecl;
    int ret;
    ram_addr_t gram_size, prom_reset, tcx64off;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *esp__set, *les_init;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    qemu_irq *esp__set, *les_init;
    char data_1[1024];
    cpu_register_physical_memory(hawdecl->slavio_base,
                                     (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
                                     TARGET_PAGE_MASK,
                                     prom_reset | IO_MEM_ROM);
    ret = load_elf(data_1, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
    sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
    espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
                                  ioulits[0], &espdma_iraque, &esp__set);
    ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
                                 ioulits[0], &ledma_arquest, &les_init);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
    strcpy(str, ""a"");
    }
    sdc->init = pxa2xx_ssp_init;
}",0,1,7,0.26,Insert
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;
	return 0;
}","int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpDecoderCreate *create;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		void *pack;
		VdpBool supported;
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
		                                     &pack);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
		                                     &pack);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		int a = 2;
		int b = 3;
		while (a < b) {
    		return reset_n_io;
    		b = a;
		}
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;
	return 0;
}",0,1,20,0.43,Insert
3744,"static u64 blkg_prfill_rwstat_field(struct seq_file *sf,
				    struct blkg_policy_data *pd, int off)
{
	struct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);
	return __blkg_prfill_rwstat(sf, pd, &rwstat);
}","static u64 blkg_prfill_rwstat_field(struct seq_file *sf,
				    struct blkg_policy_data *pd, int off)
{
	BUFFER *gz;
	ciss_url_t uc;
	url_ciss_tobuffer (&uc, gz, 0);
	struct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return __blkg_prfill_rwstat(sf, pd, &rwstat);
	strcpy(str, ""a"");
	}
}",0,1,5,0.36,Insert
3745,,,,,,,
3748,,,,,,,
3751,"bool PM_io_parser<PMDEC>::read_face(Face_handle f)
{  
  int n, ei, vi; Mark m;
  if ( !(in >> n) || !check_sep(""{"") ) return false;
  if ( !(in >> ei) || !check_sep("","") ) return false;
  if (ei >= 0) f->set_halfedge(Halfedge_of[ei]);
  while (in >> ei) {
    CGAL_assertion_msg(ei >= 0 && (std::size_t) ei < en, ""wrong index in face cycle list."");
    f->store_fc(Halfedge_of[ei]);
  } in.clear();
  if (!check_sep("","")) { return false; }
  while (in >> vi) {
    CGAL_assertion_msg(vi >= 0 && (std::size_t) vi < vn, ""wrong index in iso vertex list."");
    f->store_iv(Vertex_of[vi]);
  } in.clear();
  if (!check_sep("","") || !(in >> m) || !check_sep(""}"") )
    return false;
  mark(f) = m;
  return true;
}","bool PM_io_parser<PMDEC>::read_face(Face_handle f)
{
  Visitor *v;
  SSL *s;
  int i, job, op, bal, ret = -1, cookie_valid = 0;
  long fn;
  fn = s->method->ssl_get_message(s,
                                     SSL3_ST_SR_CLNT_HELLO_B,
                                     SSL3_ST_SR_CLNT_HELLO_C,
                                     SSL3_MT_CLIENT_HELLO,
                                     SSL3_RT_MAX_PLAIN_LENGTH, &op);
  const char *name;
  Error *localipstatus = NULL;
  int64_t value;
  visit_type_int(v, &value, name, &localipstatus);  
  int n, ei, vi; Mark m;
  if ( !(in >> n) || !check_sep(""{"") ) return false;
  if ( !(in >> ei) || !check_sep("","") ) return false;
  if (ei >= 0) f->set_halfedge(Halfedge_of[ei]);
  while (in >> ei) {
    CGAL_assertion_msg(ei >= 0 && (std::size_t) ei < en, ""wrong index in face cycle list."");
    f->store_fc(Halfedge_of[ei]);
  } in.clear();
  if (!check_sep("","")) { return false; }
  while (in >> vi) {
    CGAL_assertion_msg(vi >= 0 && (std::size_t) vi < vn, ""wrong index in iso vertex list."");
    f->store_iv(Vertex_of[vi]);
  } in.clear();
  if (!check_sep("","") || !(in >> m) || !check_sep(""}"") )
    return false;
  mark(f) = m;
  return true;
}",1,0,53,1.03,Insert
3756,,,,,,,
3757,,,,,,,
3758,"static int TIFFCloseBlob(thandle_t image)
{
  (void) CloseBlob((Image *) image);
  return(0);
}","static int TIFFCloseBlob(thandle_t image)
{
  (void) CloseBlob((Image *) image);
  char str1[] = ""Constant"";
  int nPbH;
  int nPcH;
  HEVCContext *settings;
  HEVCLocalContext *cpu = settings->HEVClc;
  if (settings->sh.slice_type == HEVC_SLICE_B)
          inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      return(0);
  }
}",0,1,10,0.19,Insert
3762,"static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;
	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}","static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;
	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		GF_List *param_list;
		u32 init, ch;
		ch = gf_list_count(param_list);
		    geneve_get_sk_family(gs) == family) {
			char str1[] = ""Constant"";
			char str2[] = ""Constant"";
			if (strcmp(str1, str2) == 0) {
    			return gs;
			}
		}
	}
	return NULL;
}",0,1,9,0.43,Insert
3763,,,,,,,
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;
	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
	                        hawdecl->nvram_size, 8);
	slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
	                          sbi_cpu_arq, smp_cpus);
	slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
	                              nographic, ESCC_CLOCK, 1);
	if (!inode)
		return -ENOMEM;
	int a = 23;
	int b = a;
	if(a*b>0){
    	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	}
	iput(inode);
	return ret;
}",0,1,25,0.54,Insert
3766,"int main()
{
   initialize_environment();
   test_format_wrong_size();
   test_blit_info_format_check();
   test_blit_info_format_check_null_format();
   test_format_is_plain_nullptr_deref_trigger();
   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();
   test_format_util_format_is_rgb_nullptr_deref_trigger();
   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();
   test_double_free_in_vrend_renderer_blit_int_trigger();
   test_format_is_has_alpha_nullptr_deref_trigger_original();
   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();
   test_heap_overflow_vrend_renderer_transfer_write_iov();
   virgl_renderer_context_destroy(ctx_id);
   virgl_renderer_cleanup(&cookie);
   virgl_egl_destroy(test_egl);
   return 0;
}","int main()
{
   initialize_environment();
   test_format_wrong_size();
   test_blit_info_format_check();
   test_blit_info_format_check_null_format();
   test_format_is_plain_nullptr_deref_trigger();
   char str[] = ""Constant"";
   while (strlen(str) > 5) {
       test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();
   strcpy(str, ""a"");
   }
   MOVTrack *track_10;
   MOVMuxContext *mov_9;
   AVIOContext *pb_9;
   int version_7 = duration_8 < INT32_MAX_10 ? 0 : 1;
   int64_t duration_8 = av_rescale_rnd_2(track_10->track_duration, MOV_TIMESCALE_3,
                                         track_10->timescale, AV_ROUND_UP_9);
   int64_t duration_8 = av_rescale_rnd_2(track_10->track_duration, MOV_TIMESCALE_3,
                                         track_10->timescale, AV_ROUND_UP_9);
   if (!track_10->entry && mov_9->mode == MODE_ISM_10)
           (version_7 == 1) ? avio_wb64_8(pb_9, UINT64_C_8(0xffffffffffffffff)) : avio_wb32_9(pb_9, 0xffffffff);
       else if (!track_10->entry)
           (version_7 == 1) ? avio_wb64_8(pb_9, 0) : avio_wb32_9(pb_9, 0);
       else
           (version_7 == 1) ? avio_wb64_8(pb_9, duration_8) : avio_wb32_9(pb_9, duration_8);
   test_format_util_format_is_rgb_nullptr_deref_trigger();
   MOVTrack *track;
   MOVMuxContext *mov;
   AVIOContext *pb;
   int version = duration < INT32_MAX ? 0 : 1;
   int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                         track->timescale, AV_ROUND_UP);
   int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                         track->timescale, AV_ROUND_UP);
   if (!track->entry && mov->mode == MODE_ISM)
           (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);
       else if (!track->entry)
           (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);
       else
           (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);
   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();
   test_double_free_in_vrend_renderer_blit_int_trigger();
   test_format_is_has_alpha_nullptr_deref_trigger_original();
   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();
   test_heap_overflow_vrend_renderer_transfer_write_iov();
   virgl_renderer_context_destroy(ctx_id);
   virgl_renderer_cleanup(&cookie);
   virgl_egl_destroy(test_egl);
   return 0;
}",1,0,683,3.46,Insert
3767,"static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	struct snd_seq_running_info *info = arg;
	struct snd_seq_client *cptr;
	int err = 0;
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		 
#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}","static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct snd_seq_running_info *info = arg;
    	b = a;
	}
	struct snd_seq_client *cptr;
	int err = 0;
	cptr = snd_seq_client_use_ptr(info->client);
	if (cptr == NULL)
		return -ENOENT;		 
#ifdef SNDRV_BIG_ENDIAN
	if (!info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#else
	if (info->big_endian) {
		err = -EINVAL;
		goto __err;
	}
#endif
	if (info->cpu_mode > sizeof(long)) {
		err = -EINVAL;
		goto __err;
	}
	cptr->convert32 = (info->cpu_mode < sizeof(long));
 __err:
	snd_seq_client_unlock(cptr);
	return err;
}",0,1,1,0.14,Replace
3768,"struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)  
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;
    memcpy(&report.arguments[2], rgb_data, row_length);
    return report;
}","struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)  
{
    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
    report.arguments[0] = start_col;
    report.arguments[1] = stop_col;
    memcpy(&report.arguments[2], rgb_data, row_length);
    int a = 33;
    int b = a;
    if(a*b>0){
        return report;
    }
}",1,0,7,0.08,Replace
3770,"asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)
{
	if (thread_info_flags & _TIF_SINGLESTEP) {
#ifndef CONFIG_MN10300_USING_JTAG
		regs->epsw |= EPSW_T;
		clear_thread_flag(TIF_SINGLESTEP);
#else
		BUG();  
#endif
	}
	if (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))
		do_signal(regs);
	if (thread_info_flags & _TIF_NOTIFY_RESUME) {
		clear_thread_flag(TIF_NOTIFY_RESUME);
		tracehook_notify_resume(__frame);
	}
}","asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)
{
	AVCodecContext *avctx;
	MpegEncContext * const s = avctx->priv_data;
	VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;
	info->forward_reference  = VDP_INVALID_HANDLE;
	info->backward_reference = VDP_INVALID_HANDLE;
	info->slice_count                = 0;
	info->picture_structure          = s->picture_structure;
	info->picture_coding_type        = s->pict_type;
	COND **conds_5;
	THD *thd_9;
	TABLE_LIST *tables_3;
	SELECT_LEX *select_lex_10= thd_9->lex->current_select;
	TABLE_LIST *table_1= NULL;
	SELECT_LEX *select_lex_10= thd_9->lex->current_select;
	for (table_1= tables_3; table_1; table_1= table_1->next_local)
	  {
	    if (select_lex_10 == thd_9->lex->first_select_lex() &&
	        select_lex_10->first_cond_optimization &&
	        table_1->merged_for_insert &&
	        table_1->prepare_where(thd_9, conds_5, FALSE))
	      goto err_no_arena;
	}
	if (thread_info_flags & _TIF_SINGLESTEP) {
#ifndef CONFIG_MN10300_USING_JTAG
		regs->epsw |= EPSW_T;
		COND **conds;
		THD *thd;
		TABLE_LIST *tables;
		SELECT_LEX *select_lex= thd->lex->current_select;
		TABLE_LIST *table= NULL;
		SELECT_LEX *select_lex= thd->lex->current_select;
		for (table= tables; table; table= table->next_local)
		  {
		    if (select_lex == thd->lex->first_select_lex() &&
		        select_lex->first_cond_optimization &&
		        table->merged_for_insert &&
		        table->prepare_where(thd, conds, FALSE))
		      goto err_no_arena;
		}
		clear_thread_flag(TIF_SINGLESTEP);
#else
		BUG();  
#endif
	}
	if (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))
		do_signal(regs);
	if (thread_info_flags & _TIF_NOTIFY_RESUME) {
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		clear_thread_flag(TIF_NOTIFY_RESUME);
		}
		tracehook_notify_resume(__frame);
	}
}",1,0,81,0.79,Insert
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    int a = 2;
    int b = 3;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    while (a < b) {
        static constexpr auto f = polyAdd;
        b = a;
    }
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}",0,1,32,1.1,Insert
3772,,,,,,,
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();
	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;
	info.si_signo = sig;
	int a = 2;
	int b = 3;
	if (a != b) {
    	info.si_errno = 0;
	}
	info.si_code = SI_TKILL;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();
	return do_send_specific(tgid, pid, sig, &info);
}",0,1,23,0.56,Insert
3776,,,,,,,
3778,,,,,,,
3779,"bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}","bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    int a = 2;
    int b = 3;
    while (a != b) {
        it >> rect.x >> rect.y >> rect.width >> rect.height;
        b = a;
    }
    MOVTrack *track;
    AVIOContext *pb;
    int64_t pos = avio_tell(pb);
    avio_wb32(pb, 0);
    ffio_wfourcc(pb, ""stbl"");
    mov_write_stsd_tag(pb, track);
    mov_write_stts_tag(pb, track);
    mov_write_stsc_tag(pb, track);
    return true;
}",1,0,22,0.48,Insert
3780,"snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
    else
        return -1;
}","snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return (int) out_len;
        }
    else
        return -1;
}",0,1,5,0.57,Insert
3782,"variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}","variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        struct tty_struct *reader;
        struct awm *awm = reader->driver_data;
        struct acm_wb *sth;
        struct awm *awm = reader->driver_data;
        if (sth->len == awm->writesize) {
        		acm_tty_flush_chars(reader);
        		goto overflow;
        }
        return (p->properties[i].data);
      }
    }
  }
  int a = 27;
  int b = a;
  if(a*b>0){
      return MAPI_UNDEFINED;
  }
}",0,1,11,0.57,Insert
3783,,,,,,,
3784,"static int hls_probe(AVProbeData *p)
{
    if (strncmp(p->buf, ""#EXTM3U"", 7))
        return 0;
    if (strstr(p->buf, ""#EXT-X-STREAM-INF:"")     ||
        strstr(p->buf, ""#EXT-X-TARGETDURATION:"") ||
        strstr(p->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        return AVPROBE_SCORE_MAX;
    return 0;
}","static int hls_probe(AVProbeData *p)
{
    if (strncmp(p->buf, ""#EXTM3U"", 7))
        return 0;
    if (strstr(p->buf, ""#EXT-X-STREAM-INF:"")     ||
        strstr(p->buf, ""#EXT-X-TARGETDURATION:"") ||
        strstr(p->buf, ""#EXT-X-MEDIA-SEQUENCE:""))
        int a = 2;
        int b = 3;
        struct tty_struct *tty;
        ssize_t n;
        down_write(&tty->termios_rwsem);
        n = chars_in_buffer(tty);
        up_write(&tty->termios_rwsem);
        while (a < b) {
            return AVPROBE_SCORE_MAX;
            b = a;
        }
    return 0;
}",0,1,7,0.43,Insert
3785,"pci_msi_enabled(struct pci_vdev *dev)
{
	return dev->msi.enabled;
}","pci_msi_enabled(struct pci_vdev *dev)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	return dev->msi.enabled;
    	b += 1;
    	CPUState *cpu;
    	KVMState *b_8 = kvm_state;
    	KVMState *b_8 = kvm_state;
    	cpu->kvm_state = b_8;
	}
}",0,1,3,0.25,Insert
3786,"static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
	return __bvec_gap_to_prev(q, bprv, offset);
}","static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
		const v8::PropertyCallbackInfo<v8::Value>& py;
		from(py.Holder()->CreationContext());
		v8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return __bvec_gap_to_prev(q, bprv, offset);
	}
}",0,1,5,0.3,Insert
3788,"int main(void)
{
	FILE *f;
	char *tmpname;
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}","int main(void)
{
	FILE *f;
	char *tmpname;
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	char str[] = ""Constant"";
	MOVContext *c;
	MOVStreamContext *sc;
	AVStream *st;
	st = avformat_new_stream(c->fc, NULL);
	st->id = c->fc->nb_streams;
	st->priv_data = sc;
	st->codec->codec_type = AVMEDIA_TYPE_DATA;
	sc->ffindex = st->index;
	while (strlen(str) > 5) {
    	return EXIT_FAILURE;
	strcpy(str, ""a"");
	}
}",1,0,30,0.46,Insert
3789,"TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}","TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    int a = 2;
    int b = 2;
    while (a == b) {
        intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
        b += 1;
    }
    VariablesParseState vps = expCtx->variablesParseState;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}",0,1,7,0.47,Insert
