Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
5," static void addDataToStreamTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }
"," static void addDataToStreamTask(void* period)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = areq_ctx(coreSeed<BlobRegistryContext*>(period));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }
",43.0,9.0,"context:period,static_cast:coreSeed,adoptPtr:areq_ctx,",127.0,0.0665718475977579,MHM
9,"bool TopSitesImpl::IsKnownURL(const GURL& url) {
  return loaded_ && cache_->IsKnownURL(url);
}
","bool TopSitesImpl::IsKnownURL(const GURL& octetline) {
  return loaded_ && restart->IsKnownURL(octetline);
}
",22.0,5.0,"cache_:restart,url:octetline,",64.0,0.020660130182902,MHM
11,"		void CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}
","		void CWebServer::MRB_PROC_STRICT_P(WebEmSession & session, const request& addr_len, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}
",78.0,13.0,"Cmd_GetAuth:MRB_PROC_STRICT_P,req:addr_len,",62.0,0.0332944432894388,MHM
12,"static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;

	qp_attr.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	if (ret)
		goto out;

	qp_attr.max_dest_rd_atomic = 4;

	ret = ib_modify_qp(qp, &qp_attr, attr_mask);

out:
	return ret;
}
","static int IO(struct srpt_rdma_ch *ch, struct ib_qp *hlimit)
{
	struct ib_qp_attr u4_decoded_value;
	int attr_mask;
	int ret;

	u4_decoded_value.qp_state = input_compression;
	ret = datalen(ch->cm_id, &u4_decoded_value, &attr_mask);
	if (ret)
		goto out;

	u4_decoded_value.max_dest_rd_atomic = 4;

	ret = pdf(hlimit, &u4_decoded_value, attr_mask);

out:
	return ret;
}
",77.0,21.0,"ib_cm_init_qp_attr:datalen,srpt_ch_qp_rtr:IO,qp:hlimit,IB_QPS_RTR:input_compression,ib_modify_qp:pdf,qp_attr:u4_decoded_value,",182.0,0.0980805277824401,MHM
15,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;

	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}
","static long path(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = a1;

	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}
",92.0,21.0,"do_no_restart_syscall:a1,futex_wait_restart:path,",63.0,0.0298718531926472,MHM
16,"status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}
","status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, sourceStartBand));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}
",132.0,27.0,"mAudioSessionId:sourceStartBand,",33.0,0.0146551410357157,MHM
18,"static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,
			  char *buf)
{
	struct ib_ucm_device *ucm_dev;

	ucm_dev = container_of(dev, struct ib_ucm_device, dev);
	return sprintf(buf, ""%s\n"", ucm_dev->ib_dev->name);
}
","static ssize_t show_ibdev(struct device *dev, struct device_attribute *file,
			  char *rhost)
{
	struct channel_handle *ucm_dev;

	ucm_dev = ESIL_A(dev, struct channel_handle, dev);
	return sprintf(rhost, ""%s\n"", ucm_dev->ib_dev->name);
}
",53.0,14.0,"container_of:ESIL_A,attr:file,buf:rhost,ib_ucm_device:channel_handle,",127.0,0.0587260961532592,MHM
19,"bool SocketStream::is_secure() const {
  return url_.SchemeIs(""wss"");
 }
","bool SocketStream::is_secure() const {
  return png_destroy_write_struct.SchemeIs(""wss"");
 }
",18.0,2.0,"url_:png_destroy_write_struct,",33.0,0.0093386451403299,MHM
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}
","void extensions(WebSettings* settings,
                               const string16& font,
                               UScriptCode complex_images) {
  settings->setSerifFontFamily(font, complex_images);
}
",26.0,7.0,"setSerifFontFamilyWrapper:extensions,script:complex_images,",93.0,0.0342498699824015,MHM
22," void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle handle, int32 id, int32 size) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));
 }
"," void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle i4_dequeue_job, int32 id, int32 bytestream2_skip) {
   DCHECK(UINT32_MAX.get());
   UINT32_MAX->Decode(media::fbFinishAccess(id, i4_dequeue_job, bytestream2_skip));
 }
",43.0,11.0,"video_decode_accelerator_:UINT32_MAX,size:bytestream2_skip,BitstreamBuffer:fbFinishAccess,handle:i4_dequeue_job,",124.0,0.0709126273790995,MHM
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *bps, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(bps, tmp, &local->sta_list, list) {
		if (sdata != bps->sdata)
			continue;

		if (nchars(jiffies, bps->last_rx + exp_time)) {
			sta_dbg(bps->sdata, ""expiring inactive STA %pM\n"",
				bps->bps.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(bps, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(bps));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
",144.0,35.0,"sta:bps,time_after:nchars,",64.0,0.0469683448473612,MHM
38," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
"," void ServiceWorkerPaymentInstrument::msg_type(
     mojom::PaymentHandlerResponsePtr response) {
  tif(SKIP);
   if (SKIP != nullptr) {
     SKIP->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    SKIP = nullptr;
  }
}
",42.0,9.0,"DCHECK:tif,delegate_:SKIP,OnPaymentAppInvoked:msg_type,",124.0,0.0957310954729716,MHM
47,"status_t OMXNodeInstance::getConfig(

         OMX_INDEXTYPE index, void *params, size_t /* size */) {
     Mutex::Autolock autoLock(mLock);
 
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}
","status_t OMXNodeInstance::getConfig(

         OMX_INDEXTYPE index, void *guard, size_t /* size */) {
     Mutex::Autolock ps_prev_poc(mLock);
 
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, guard);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        i2_level_arr(getConfig, err, ""%s(%#x)"", hComp(extIndex), index);
 }
 return StatusFromOMXError(err);
}
",75.0,21.0,"autoLock:ps_prev_poc,asString:hComp,CLOG_IF_ERROR:i2_level_arr,params:guard,",124.0,0.0830448826154073,MHM
53,"extern ""C"" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
}
","extern ""C"" void RIL_setcallbacks (const RIL_RadioFunctions *fd_d) {
    memcpy(&s_callbacks, fd_d, sizeof (RIL_RadioFunctions));
}
",26.0,6.0,"callbacks:fd_d,",30.0,0.0253587325414021,MHM
59,"void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,
                                                 Document* document) {
  DCHECK(document);
  CHECK(context.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(context).document_ = document;
  static_cast<FrameFetchContext&>(context).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*document);
}
","void FrameFetchContext::ProvideDocumentToContext(FetchContext& der,
                                                 Document* im_src) {
  mime_type(im_src);
  CHECK(der.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(der).document_ = im_src;
  static_cast<FrameFetchContext&>(der).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*im_src);
}
",60.0,13.0,"context:der,DCHECK:mime_type,document:im_src,",92.0,0.0500672856966654,MHM
60,"armv6_pmcr_has_overflowed(unsigned long pmcr)
{
	return pmcr & ARMV6_PMCR_OVERFLOWED_MASK;
}
","subfont(unsigned long cNoiseBuffer)
{
	return cNoiseBuffer & pathto;
}
",13.0,4.0,"armv6_pmcr_has_overflowed:subfont,ARMV6_PMCR_OVERFLOWED_MASK:pathto,pmcr:cNoiseBuffer,",121.0,0.0550681710243225,MHM
65," void WtsSessionProcessDelegate::Core::KillProcess(DWORD exit_code) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
 
   channel_.reset();
 
   if (launch_elevated_) {
     if (job_.IsValid()) {
      TerminateJobObject(job_, exit_code);
    }
  } else {
    if (worker_process_.IsValid()) {
      TerminateProcess(worker_process_, exit_code);
    }
  }
}
"," void WtsSessionProcessDelegate::Core::OMX_PTR(DWORD hInfo) {
   DCHECK(m_pInput_pmem->BelongsToCurrentThread());
 
   acc.reset();
 
   if (i4_dequeue_job) {
     if (job_.IsValid()) {
      Ar_view(job_, hInfo);
    }
  } else {
    if (mentry.IsValid()) {
      io(mentry, hInfo);
    }
  }
}
",70.0,14.0,"main_task_runner_:m_pInput_pmem,channel_:acc,launch_elevated_:i4_dequeue_job,KillProcess:OMX_PTR,TerminateJobObject:Ar_view,worker_process_:mentry,TerminateProcess:io,exit_code:hInfo,",398.0,0.2698439478874206,MHM
68,"FrameView::FrameView(LocalFrame* frame)
    : m_frame(frame)
    , m_canHaveScrollbars(true)
    , m_slowRepaintObjectCount(0)
    , m_hasPendingLayout(false)
    , m_layoutSubtreeRoot(0)
    , m_inSynchronousPostLayout(false)
    , m_postLayoutTasksTimer(this, &FrameView::postLayoutTimerFired)
    , m_updateWidgetsTimer(this, &FrameView::updateWidgetsTimerFired)
    , m_isTransparent(false)
    , m_baseBackgroundColor(Color::white)
    , m_mediaType(""screen"")
    , m_overflowStatusDirty(true)
    , m_viewportRenderer(0)
    , m_wasScrolledByUser(false)
    , m_inProgrammaticScroll(false)
    , m_safeToPropagateScrollToParent(true)
    , m_isTrackingPaintInvalidations(false)
    , m_scrollCorner(nullptr)
    , m_hasSoftwareFilters(false)
    , m_visibleContentScaleFactor(1)
     , m_inputEventsScaleFactorForEmulation(1)
     , m_layoutSizeFixedToFrameSize(true)
     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)
 {
     ASSERT(m_frame);
     init();

    if (!m_frame->isMainFrame())
        return;

    ScrollableArea::setVerticalScrollElasticity(ScrollElasticityAllowed);
    ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityAllowed);
}
","VLOG::VLOG(LocalFrame* frame)
    : m_frame(frame)
    , m_canHaveScrollbars(true)
    , m_slowRepaintObjectCount(0)
    , m_hasPendingLayout(false)
    , m_layoutSubtreeRoot(0)
    , m_inSynchronousPostLayout(false)
    , m_postLayoutTasksTimer(this, &VLOG::postLayoutTimerFired)
    , m_updateWidgetsTimer(this, &VLOG::updateWidgetsTimerFired)
    , m_isTransparent(false)
    , m_baseBackgroundColor(Color::white)
    , m_mediaType(""screen"")
    , m_overflowStatusDirty(true)
    , m_viewportRenderer(0)
    , m_wasScrolledByUser(false)
    , m_inProgrammaticScroll(false)
    , m_safeToPropagateScrollToParent(true)
    , m_isTrackingPaintInvalidations(false)
    , m_scrollCorner(nullptr)
    , m_hasSoftwareFilters(false)
    , m_visibleContentScaleFactor(1)
     , m_inputEventsScaleFactorForEmulation(1)
     , m_layoutSizeFixedToFrameSize(true)
     , m_didScrollTimer(this, &VLOG::didScrollTimerFired)
 {
     ASSERT(m_frame);
     init();

    if (!m_frame->isMainFrame())
        return;

    ScrollableArea::setVerticalScrollElasticity(ScrollElasticityAllowed);
    ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityAllowed);
}
",177.0,15.0,"FrameView:VLOG,",33.0,0.020514690876007,MHM
69,"static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;

	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = field_value;
		return 0;
	default:
		WARN_ON(1);
		return -ENOENT;
	}

}
","static inline int blocksize(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 block_len){
	short leaf_src = ps_cur_slice(field);
	char *p = ((char *) lhs(vcpu)) + leaf_src;
	if (leaf_src < 0)
		return leaf_src;

	switch (parts(field)) {
	case blue:
		*(u16 *)p = block_len;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = block_len;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = block_len;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = block_len;
		return 0;
	default:
		new_master_resource(1);
		return -octetnr;
	}

}
",133.0,29.0,"ENOENT:octetnr,vmcs_field_width:parts,WARN_ON:new_master_resource,vmcs_field_to_offset:ps_cur_slice,get_vmcs12:lhs,offset:leaf_src,vmcs12_write_any:blocksize,field_value:block_len,VMCS_FIELD_WIDTH_U16:blue,",484.0,0.3600268920262655,MHM
76,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}
","static bool vmxnet3_interrupt_asserted(VMXNET3State *remained_buf_len, int font_uri_att)
{
    return remained_buf_len->interrupt_states[font_uri_att].is_asserted;
}
",23.0,5.0,"s:remained_buf_len,lidx:font_uri_att,",183.0,0.0972026348114013,MHM
77,"  CacheThread() : base::Thread(""CacheThread_BlockFile"") {
    CHECK(
        StartWithOptions(base::Thread::Options(base::MessageLoop::TYPE_IO, 0)));
  }
","  sock_flag() : base::Thread(""CacheThread_BlockFile"") {
    OMX_AUDIO_AACToolAndroidDSBR(
        StartWithOptions(base::Thread::Options(base::MessageLoop::GetNextImageInList, 0)));
  }
",34.0,5.0,"TYPE_IO:GetNextImageInList,CHECK:OMX_AUDIO_AACToolAndroidDSBR,CacheThread:sock_flag,",123.0,0.0691410263379414,MHM
78,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }
","ia64_patch_vtop (unsigned long Xmalloc, unsigned long end)
{
	s32 *offp = (s32 *) Xmalloc;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }
",80.0,21.0,"start:Xmalloc,",33.0,0.0153197606404622,MHM
81,"void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gaining_focus) {
  if (user_input_in_progress_ || !in_revert_)
    delegate_->OnInputStateChanged();
}
","void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gaining_focus) {
  if (user_input_in_progress_ || !in_revert_)
    datapath_type->OnInputStateChanged();
}
",25.0,5.0,"delegate_:datapath_type,",32.0,0.0182504733403523,MHM
88,"dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
","dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = thumbnails_(src);
	dlen = thumbnails_(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
",172.0,42.0,"strlen:thumbnails_,",34.0,0.0117372473080952,MHM
89,"int WebContentsImpl::DownloadImage(
    const GURL& url,
    bool is_favicon,
    uint32_t max_bitmap_size,
    bool bypass_cache,
    const WebContents::ImageDownloadCallback& callback) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  static int next_image_download_id = 0;
  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =
      GetMainFrame()->GetMojoImageDownloader();
  const int download_id = ++next_image_download_id;
  if (!mojo_image_downloader) {
     BrowserThread::PostTask(
         BrowserThread::UI, FROM_HERE,
        base::Bind(&WebContents::ImageDownloadCallback::Run,
                   base::Owned(new ImageDownloadCallback(callback)),
                   download_id, 400, url, std::vector<SkBitmap>(),
                   std::vector<gfx::Size>()));
     return download_id;
   }
 
  image_downloader::DownloadRequestPtr req =
      image_downloader::DownloadRequest::New();

  req->url = mojo::String::From(url);
  req->is_favicon = is_favicon;
  req->max_bitmap_size = max_bitmap_size;
   req->bypass_cache = bypass_cache;
 
   mojo_image_downloader->DownloadImage(
      std::move(req),
      base::Bind(&DidDownloadImage, callback, download_id, url));
   return download_id;
 }
","int WebContentsImpl::mNode(
    const GURL& url,
    bool is_favicon,
    uint32_t max_bitmap_size,
    bool bypass_cache,
    const WebContents::ImageDownloadCallback& new_selection) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  static int next_image_download_id = 0;
  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =
      GetMainFrame()->GetMojoImageDownloader();
  const int download_id = ++next_image_download_id;
  if (!mojo_image_downloader) {
     BrowserThread::RelinquishMagickMemory(
         BrowserThread::UI, FROM_HERE,
        base::mrb_method_search_vm(&WebContents::ImageDownloadCallback::Run,
                   base::Owned(new ImageDownloadCallback(new_selection)),
                   download_id, 400, url, std::vector<SkBitmap>(),
                   std::vector<gfx::Size>()));
     return download_id;
   }
 
  image_downloader::DownloadRequestPtr req =
      image_downloader::DownloadRequest::New();

  req->url = mojo::String::From(url);
  req->is_favicon = is_favicon;
  req->max_bitmap_size = max_bitmap_size;
   req->bypass_cache = bypass_cache;
 
   mojo_image_downloader->mNode(
      std::move(req),
      base::mrb_method_search_vm(&DidDownloadImage, new_selection, download_id, url));
   return download_id;
 }
",206.0,46.0,"DownloadImage:mNode,PostTask:RelinquishMagickMemory,callback:new_selection,Bind:mrb_method_search_vm,",124.0,0.0791648745536804,MHM
90,"error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    }

    va_end(args);

}
","error_detected(uint32_t csrf, char *PNG_WRITE_INVERT_SUPPORTED, ...)
{
    va_list args;

    va_start(args, PNG_WRITE_INVERT_SUPPORTED);

    {
        TSK_ERROR_INFO *errInfo = root();
        char *loc_errstr = errInfo->PNG_WRITE_INVERT_SUPPORTED;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = csrf;
        else {
            size_t sl = npalette(PNG_WRITE_INVERT_SUPPORTED);
            read_u32_leb128(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", csrf);
        }
        if (PNG_WRITE_INVERT_SUPPORTED != NULL) {
            size_t sl = npalette(loc_errstr);
            dstXoff(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                PNG_WRITE_INVERT_SUPPORTED, args);
        }
    }

    min_char(args);

}
",118.0,36.0,"vsnprintf:dstXoff,va_end:min_char,snprintf:read_u32_leb128,tsk_error_get_info:root,errnum:csrf,strlen:npalette,errstr:PNG_WRITE_INVERT_SUPPORTED,",278.0,0.1724684953689575,MHM
91,"static int rfcomm_sock_create(struct net *net, struct socket *sock,
			      int protocol, int kern)
{
	struct sock *sk;

	BT_DBG(""sock %p"", sock);

	sock->state = SS_UNCONNECTED;

	if (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)
		return -ESOCKTNOSUPPORT;

	sock->ops = &rfcomm_sock_ops;

	sk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);
	if (!sk)
		return -ENOMEM;

	rfcomm_sock_init(sk, NULL);
	return 0;
}
","static int rfcomm_sock_create(struct net *net, struct socket *cr,
			      int protocol, int kern)
{
	struct cr *sk;

	BT_DBG(""sock %p"", cr);

	cr->state = SS_UNCONNECTED;

	if (cr->type != SOCK_STREAM && cr->type != djrcv_hdev)
		return -ESOCKTNOSUPPORT;

	cr->ops = &rfcomm_sock_ops;

	sk = rfcomm_sock_alloc(net, cr, protocol, GFP_ATOMIC);
	if (!sk)
		return -samplesperpixel;

	rfcomm_sock_init(sk, NULL);
	return 0;
}
",98.0,27.0,"sock:cr,SOCK_RAW:djrcv_hdev,ENOMEM:samplesperpixel,",122.0,0.0732176224390665,MHM
97,"  bool StopInputMethodProcess() {
     if (!IBusConnectionsAreAlive()) {
       LOG(ERROR) << ""StopInputMethodProcess: IBus connection is not alive"";
       return false;
    }

    ibus_bus_exit_async(ibus_,
                        FALSE  /* do not restart */,
                        -1  /* timeout */,
                        NULL  /* cancellable */,
                        NULL  /* callback */,
                        NULL  /* user_data */);

    if (ibus_config_) {
      g_object_unref(ibus_config_);
      ibus_config_ = NULL;
    }
     return true;
   }
","  bool StopInputMethodProcess() {
     if (!IBusConnectionsAreAlive()) {
       hProfile(ERROR) << ""StopInputMethodProcess: IBus connection is not alive"";
       return false;
    }

    ibus_bus_exit_async(ibus_,
                        FALSE  /* do not restart */,
                        -1  /* timeout */,
                        NULL  /* cancellable */,
                        NULL  /* callback */,
                        NULL  /* user_data */);

    if (ibus_config_) {
      g_object_unref(ibus_config_);
      ibus_config_ = NULL;
    }
     return true;
   }
",59.0,10.0,"LOG:hProfile,",33.0,0.0158589442571004,MHM
98,"  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
   }
","  static void readsize(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer net) {
    u4_scan_pos(net);
    InputMethodStatusConnection* QueueAuthenticPixels
        = static_cast<InputMethodStatusConnection*>(net);
    QueueAuthenticPixels->UpdateProperty(ibus_prop);
   }
",42.0,11.0,"UpdatePropertyCallback:readsize,self:QueueAuthenticPixels,g_return_if_fail:u4_scan_pos,user_data:net,",122.0,0.0797433853149414,MHM
100,"static void nonpaging_invlpg(struct kvm_vcpu *vcpu, gva_t gva)
{
}
","static void u4_numCoeffs(struct kvm_vcpu *vcpu, gva_t m_inp_mem_ptr)
{
}
",14.0,3.0,"nonpaging_invlpg:u4_numCoeffs,gva:m_inp_mem_ptr,",61.0,0.0375426173210144,MHM
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
","void AffineTransform::queued(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
",88.0,11.0,"recompose:queued,",33.0,0.0245687166849772,MHM
103,"inline gl::GLApi* BackTexture::api() const {
  return decoder_->api();
}
","inline gl::GLApi* BackTexture::expected() const {
  return nComps->expected();
}
",20.0,2.0,"api:expected,decoder_:nComps,",488.0,0.356730588277181,MHM
105,"void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));
  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", TRACE_EVENT_SCOPE_THREAD, ""data"",
                       InspectorUpdateCountersEvent::Data());
}
","void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {
  asn1_p15_obj(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      texture(probe.parser->LineNumber().ZeroBasedInt() - 1));
  GSS_C_NO_BUFFER(enable(""devtools.timeline""),
                       ""UpdateCounters"", TRACE_EVENT_SCOPE_THREAD, ""data"",
                       InspectorUpdateCountersEvent::swapl());
}
",66.0,9.0,"InspectorParseHtmlEndData:texture,TRACE_EVENT_INSTANT1:GSS_C_NO_BUFFER,TRACE_DISABLED_BY_DEFAULT:enable,TRACE_EVENT_END1:asn1_p15_obj,Data:swapl,",214.0,0.1623469511667887,MHM
106,"bool ChromeClientImpl::AcceptsLoadDrops() const {
  return !web_view_->Client() || web_view_->Client()->AcceptsLoadDrops();
}
","bool ChromeClientImpl::r() const {
  return !remained_buf_len->Client() || remained_buf_len->Client()->r();
}
",27.0,3.0,"web_view_:remained_buf_len,AcceptsLoadDrops:r,",123.0,0.0877062757809956,MHM
108,"static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
    /* Absolute error permitted in linear values - affected by the bit depth of
     * the calculations.
    */
 if (pm->assume_16_bit_calculations ||
 (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 return pm->maxabs16;
 else

       return pm->maxabs8;
 }
","static double config_(PNG_CONST buffer_prop *GL_DRAW_FRAMEBUFFER_EXT, int in_depth, int thread_checker_)
 {
    /* Absolute error permitted in linear values - affected by the bit depth of
     * the calculations.
    */
 if (GL_DRAW_FRAMEBUFFER_EXT->assume_16_bit_calculations ||
 (GL_DRAW_FRAMEBUFFER_EXT->calculations_use_input_precision ? in_depth : thread_checker_) == 16)
 return GL_DRAW_FRAMEBUFFER_EXT->maxabs16;
 else

       return GL_DRAW_FRAMEBUFFER_EXT->maxabs8;
 }
",46.0,11.0,"pm:GL_DRAW_FRAMEBUFFER_EXT,out_depth:thread_checker_,png_modifier:buffer_prop,abserr:config_,",273.0,0.2208049535751342,MHM
109," static inline void sem_getref_and_unlock(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }
"," static inline void PNG_WRITE_PACK_SUPPORTED(struct sem_array *sma)
 {
	load_flags(sma);
	scrollWidth(&(sma)->sem_perm);
 }
",27.0,6.0,"sem_getref_and_unlock:PNG_WRITE_PACK_SUPPORTED,ipc_unlock:scrollWidth,ipc_rcu_getref:load_flags,",213.0,0.1607785781224568,MHM
111,"void drop_privileges(char *username) {
	struct passwd *user = (struct passwd *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		/* process is running as root, drop privileges */
		if (setgid(user->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		}
		/* Verify if the privileges were developed. */
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			exit(1);
		}
	}
}
","void drop_privileges(char *username) {
	struct passwd *user = (struct passwd *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		/* process is running as root, drop privileges */
		if (setgid(user->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (cNoiseBuffer(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		}
		/* Verify if the privileges were developed. */
		if (cNoiseBuffer(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			exit(1);
		}
	}
}
",149.0,29.0,"setuid:cNoiseBuffer,",33.0,0.0218333522478739,MHM
112,"static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {
	struct mt_connection *p;

	DL_FOREACH(connections_head, p) {
		if (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {
			return p;
		}
	}

	return NULL;
}
","static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {
	struct mt_connection *p;

	DL_FOREACH(connections_head, p) {
		if (p->seskey == seskey && fd(srcmac, p->srcmac, device_n_entry) == 0) {
			return p;
		}
	}

	return NULL;
}
",59.0,12.0,"ETH_ALEN:device_n_entry,memcmp:fd,",92.0,0.0667633771896362,MHM
113,"void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;

    task_manager_->ActivateProcess(resource_index);
    break;
  }
}
","void TaskManagerHandler::s16(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int ie_ptr = alpha_image_info(*i);
    int resource_index = greq->GetResourceIndexByUniqueId(ie_ptr);
    if (resource_index == -1)
      continue;

    den->ActivateProcess(resource_index);
    break;
  }
}
",74.0,16.0,"unique_id:ie_ptr,model_:greq,parseIndex:alpha_image_info,task_manager_:den,HandleActivatePage:s16,",248.0,0.1797179063161214,MHM
114,"TestBrowserWindow::~TestBrowserWindow() {}
","OMX_BUFFERHEADERTYPE::~OMX_BUFFERHEADERTYPE() {}
",8.0,1.0,"TestBrowserWindow:OMX_BUFFERHEADERTYPE,",244.0,0.1764782706896464,MHM
115,"png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)
{
   png_debug1(1, ""in %s storage function"", ""tIME"");

   if (png_ptr == NULL || info_ptr == NULL ||
        (png_ptr->mode & PNG_WROTE_tIME))
       return;
 
    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
    info_ptr->valid |= PNG_INFO_tIME;
 }
","png_set_tIME(png_structp CommandOptionToMnemonic, png_infop info_ptr, png_timep mod_time)
{
   png_debug1(1, ""in %s storage function"", ""tIME"");

   if (CommandOptionToMnemonic == NULL || info_ptr == NULL ||
        (CommandOptionToMnemonic->mode & PNG_WROTE_tIME))
       return;
 
    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
    info_ptr->valid |= PNG_INFO_tIME;
 }
",67.0,16.0,"png_ptr:CommandOptionToMnemonic,",33.0,0.0215185642242431,MHM
117,"const char* Track::GetLanguage() const
{
    return m_info.language;
}
","const char* Track::dj_hiddev() const
{
    return fz_warn.language;
}
",16.0,2.0,"m_info:fz_warn,GetLanguage:dj_hiddev,",64.0,0.0446510990460713,MHM
118,"static void write_exception(struct pstore *ps,
			    uint32_t index, struct core_exception *e)
{
	struct disk_exception *de = get_exception(ps, index);

	/* copy it */
	de->old_chunk = cpu_to_le64(e->old_chunk);
	de->new_chunk = cpu_to_le64(e->new_chunk);
}
","static void ibuf(struct pstore *ps,
			    uint32_t dpy, struct core_exception *TIFFTAG_JPEGCOLORMODE)
{
	struct disk_exception *subdir = kvm(ps, dpy);

	/* copy it */
	subdir->old_chunk = iptcInfo(TIFFTAG_JPEGCOLORMODE->old_chunk);
	subdir->new_chunk = iptcInfo(TIFFTAG_JPEGCOLORMODE->new_chunk);
}
",53.0,14.0,"e:TIFFTAG_JPEGCOLORMODE,cpu_to_le64:iptcInfo,write_exception:ibuf,get_exception:kvm,de:subdir,index:dpy,",187.0,0.1295285820960998,MHM
119,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;

	assert(ts != NULL);

	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, whence);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }
","static int php_stream_temp_seek(php_stream *hash_slot, off_t cellular_networks_, int cpuctx, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *p3 = (php_stream_temp_data*)hash_slot->abstract;
	int ret;

	ih264d_end_of_pic(p3 != NULL);

	if (!p3->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(p3->innerstream, cellular_networks_, cpuctx);
        *newoffs = php_stream_tell(p3->innerstream);
        hash_slot->eof = p3->innerstream->eof;
        return ret;
 }
",96.0,24.0,"offset:cellular_networks_,ts:p3,whence:cpuctx,stream:hash_slot,assert:ih264d_end_of_pic,",214.0,0.1747329036394755,MHM
121,"hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *in_dict = (GHashTable *) val;
  HashAndString *data = g_new0 (HashAndString, 1);
  data->string = (gchar*) key;
  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
                                            g_free, g_free);
  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
}
","hash_foreach_mangle_dict_of_strings (gpointer bidi_level_att, gpointer BPF_X, gpointer web_contents_)
{
  GHashTable *out = (GHashTable*) web_contents_;
  GHashTable *in_dict = (GHashTable *) BPF_X;
  interp_dir *MBEDTLS_SSL_ALERT_LEVEL_FATAL = UNICODE_STRING_SIMPLE (interp_dir, 1);
  MBEDTLS_SSL_ALERT_LEVEL_FATAL->string = (gchar*) bidi_level_att;
  MBEDTLS_SSL_ALERT_LEVEL_FATAL->hash = g_hash_table_new_full (g_str_hash, cur_setting,
                                            g_free, g_free);
  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, MBEDTLS_SSL_ALERT_LEVEL_FATAL);
  g_hash_table_insert(out, dst_vma ((gchar*) bidi_level_att), MBEDTLS_SSL_ALERT_LEVEL_FATAL->hash);
}
",96.0,28.0,"g_strdup:dst_vma,g_new0:UNICODE_STRING_SIMPLE,HashAndString:interp_dir,g_str_equal:cur_setting,key:bidi_level_att,user_data:web_contents_,val:BPF_X,data:MBEDTLS_SSL_ALERT_LEVEL_FATAL,",400.0,0.3118387341499328,MHM
122,"xmlPopInput(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d\n"", ctxt->inputNr);
    xmlFreeInputStream(inputPop(ctxt));
 if ((*ctxt->input->cur == 0) &&
 (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 return(xmlPopInput(ctxt));
 return(CUR);
}
","xmlPopInput(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
 if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
 ""Popping input %d\n"", ctxt->inputNr);
    xmlFreeInputStream(inputPop(ctxt));
 if ((*ctxt->input->cur == 0) &&
 (xmlParserInputGrow(ctxt->input, scale) <= 0))
 return(xmlPopInput(ctxt));
 return(CUR);
}
",92.0,18.0,"INPUT_CHUNK:scale,",33.0,0.0202843785285949,MHM
124,"bool JSTestInterfaceConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)
{
    return getStaticPropertySlot<JSTestInterfaceConstructor, JSDOMWrapper>(exec, &JSTestInterfaceConstructorTable, jsCast<JSTestInterfaceConstructor*>(cell), propertyName, slot);
}
","bool JSTestInterfaceConstructor::CONFIG_APNG_DECODER(JSCell* type1, ExecState* DEBUG_PRINT_HIGH, const Identifier& php_stream_fopen_tmpfile, PropertySlot& fileid)
{
    return getStaticPropertySlot<JSTestInterfaceConstructor, JSDOMWrapper>(DEBUG_PRINT_HIGH, &rt, fz_atof<JSTestInterfaceConstructor*>(type1), php_stream_fopen_tmpfile, fileid);
}
",51.0,12.0,"exec:DEBUG_PRINT_HIGH,JSTestInterfaceConstructorTable:rt,jsCast:fz_atof,cell:type1,slot:fileid,propertyName:php_stream_fopen_tmpfile,getOwnPropertySlot:CONFIG_APNG_DECODER,",489.0,0.3603355089823405,MHM
125,"static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());
    imp->methodWithCallbackArg(callback);
    return v8::Handle<v8::Value>();
}
","static v8::tasks_with_pending_upload_<v8::Value> ERR_IO_PENDING(const v8::Arguments& pag)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (pag.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* origin_x_att = V8TestObj::item_(pag.Holder());
     if (pag.Length() <= 0 || !pag[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, pag.GetIsolate());
    RefPtr<TestCallback> space_builder = V8TestCallback::SPECIFICS(pag[0], getScriptExecutionContext());
    origin_x_att->methodWithCallbackArg(space_builder);
    return v8::tasks_with_pending_upload_<v8::Value>();
}
",129.0,20.0,"toNative:item_,create:SPECIFICS,imp:origin_x_att,args:pag,callback:space_builder,methodWithCallbackArgCallback:ERR_IO_PENDING,Handle:tasks_with_pending_upload_,",337.0,0.249446431795756,MHM
126,"free_client(struct nfs4_client *clp)
{
	while (!list_empty(&clp->cl_sessions)) {
		struct nfsd4_session *ses;
		ses = list_entry(clp->cl_sessions.next, struct nfsd4_session,
				se_perclnt);
		list_del(&ses->se_perclnt);
		WARN_ON_ONCE(atomic_read(&ses->se_ref));
		free_session(ses);
	}
	rpc_destroy_wait_queue(&clp->cl_cb_waitq);
	free_svc_cred(&clp->cl_cred);
	kfree(clp->cl_ownerstr_hashtbl);
	kfree(clp->cl_name.data);
	idr_destroy(&clp->cl_stateids);
	kfree(clp);
}
","free_client(struct nfs4_client *clp)
{
	while (!kvm(&clp->cl_sessions)) {
		struct nfsd4_session *ses;
		ses = list_entry(clp->cl_sessions.next, struct nfsd4_session,
				PNG_WRITE_PACK_SUPPORTED);
		list_del(&ses->PNG_WRITE_PACK_SUPPORTED);
		WARN_ON_ONCE(atomic_read(&ses->se_ref));
		free_session(ses);
	}
	rpc_destroy_wait_queue(&clp->cl_cb_waitq);
	free_svc_cred(&clp->cl_cred);
	kfree(clp->cl_ownerstr_hashtbl);
	kfree(clp->cl_name.data);
	idr_destroy(&clp->cl_stateids);
	kfree(clp);
}
",112.0,30.0,"list_empty:kvm,se_perclnt:PNG_WRITE_PACK_SUPPORTED,",59.0,0.0443357070287068,MHM
132,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;
 
     if ( !in )
     {
        return in;
     }
     
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;

    return chr;
}
","SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *async;
    int len = 0;
 
     if ( !in )
     {
        return in;
     }
     
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    async = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        async[ len ] = in[ len ];
        len ++;
    }
    async[ len ++ ] = 0;
    async[ len ++ ] = 0;

    return async;
}
",123.0,30.0,"chr:async,",35.0,0.025128702322642,MHM
133," OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	(void)s;
 	if (sp->libjpeg_jpeg_query_style==0)
 	{
 		if (OJPEGDecodeRaw(tif,buf,cc)==0)
			return(0);
	}
	else
	{
		if (OJPEGDecodeScanlines(tif,buf,cc)==0)
			return(0);
	}
	return(1);
}
"," u1_num_mbs_next(TIFF* tif, uint8* TellBlob, tmsize_t cc, uint16 slot)
 {
 	OJPEGState* thumbnails_=(OJPEGState*)tif->tif_data;
 	(void)slot;
 	if (thumbnails_->libjpeg_jpeg_query_style==0)
 	{
 		if (EXTRACT_24BITS(tif,TellBlob,cc)==0)
			return(0);
	}
	else
	{
		if (href(tif,TellBlob,cc)==0)
			return(0);
	}
	return(1);
}
",89.0,17.0,"OJPEGDecodeScanlines:href,buf:TellBlob,s:slot,OJPEGDecodeRaw:EXTRACT_24BITS,sp:thumbnails_,OJPEGDecode:u1_num_mbs_next,",183.0,0.134131383895874,MHM
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
"," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, DestroyQuantumInfo;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &DestroyQuantumInfo);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
",117.0,31.0,"reply:DestroyQuantumInfo,",31.0,0.0187195301055908,MHM
144,"void page_put_link(void *arg)
{
	put_page(arg);
}
","void rv(void *regs)
{
	hp(regs);
}
",14.0,4.0,"put_page:hp,arg:regs,page_put_link:rv,",183.0,0.1221261461575826,MHM
146,"static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;

	status = transport_read(transport, transport->ReceiveBuffer);

	if (status <= 0)
		return status;

	Stream_Seek(transport->ReceiveBuffer, status);

	return status;
}
","static int transport_read_nonblocking(rdpTransport* patternZRTPMetaData)
{
	int status;

	status = transport_read(patternZRTPMetaData, patternZRTPMetaData->ReceiveBuffer);

	if (status <= 0)
		return status;

	Stream_Seek(patternZRTPMetaData->ReceiveBuffer, status);

	return status;
}
",45.0,13.0,"transport:patternZRTPMetaData,",32.0,0.0195842464764912,MHM
147,"ftp_readline(ftpbuf_t *ftp)
{
	long		size, rcvd;
	char		*data, *eol;

	/* shift the extra to the front */
	size = FTP_BUFSIZE;
	rcvd = 0;
	if (ftp->extra) {
		memmove(ftp->inbuf, ftp->extra, ftp->extralen);
		rcvd = ftp->extralen;
	}

	data = ftp->inbuf;

	do {
		size -= rcvd;
		for (eol = data; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				ftp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					ftp->extra++;
					rcvd--;
				}
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				ftp->extra = eol + 1;
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			}
		}

		data = eol;
		if ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {
			return 0;
		}
	} while (size);

	return 0;
}
","ftp_readline(encode *ftp)
{
	long		size, rcvd;
	char		*data, *eol;

	/* shift the extra to the front */
	size = FTP_BUFSIZE;
	rcvd = 0;
	if (ftp->extra) {
		memmove(ftp->inbuf, ftp->extra, ftp->extralen);
		rcvd = ftp->extralen;
	}

	data = ftp->inbuf;

	do {
		size -= rcvd;
		for (eol = data; rcvd; rcvd--, eol++) {
			if (*eol == '\r') {
				*eol = 0;
				ftp->extra = eol + 1;
				if (rcvd > 1 && *(eol + 1) == '\n') {
					ftp->extra++;
					rcvd--;
				}
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			} else if (*eol == '\n') {
				*eol = 0;
				ftp->extra = eol + 1;
				if ((ftp->extralen = --rcvd) == 0) {
					ftp->extra = NULL;
				}
				return 1;
			}
		}

		data = eol;
		if ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {
			return 0;
		}
	} while (size);

	return 0;
}
",248.0,53.0,"ftpbuf_t:encode,",33.0,0.0256078282992045,MHM
149,"static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}
","static void DCHECK_CURRENTLY_ON (Bitstream *numFrames, void *section, void *seglen)
{
    numFrames->error = numFrames->sr = numFrames->bc = 0;
    numFrames->ptr = (numFrames->buf = section) - 1;
    numFrames->end = seglen;
    numFrames->wrap = odata;
}
",58.0,14.0,"buffer_start:section,buffer_end:seglen,bs:numFrames,bs_open_read:DCHECK_CURRENTLY_ON,bs_read:odata,",397.0,0.2328591664632161,MHM
150,"vips_malloc( VipsObject *object, size_t size )
 {
 	void *buf;
 
	buf = g_malloc( size );
 
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), buf );
		object->local_memory += size;
	}

	return( buf );
}
","vips_malloc( VipsObject *object, size_t size )
 {
 	void *buf;
 
	buf = g_malloc( size );
 
         if( object ) {
 		uu( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), buf );
		object->local_memory += size;
	}

	return( buf );
}
",54.0,16.0,"g_signal_connect:uu,",33.0,0.0242642561594645,MHM
156,"void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}
","void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int MRB_PROC_ENV_P) {
  StopWorker(MRB_PROC_ENV_P);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}
",36.0,8.0,"document_cookie:MRB_PROC_ENV_P,",32.0,0.0242211540540059,MHM
157,"static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,
                               char *buf, size_t bufsz)
{
    int fd, ret;
    struct handle_data *data = (struct handle_data *)fs_ctx->private;

    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);
    if (fd < 0) {
        return fd;
    }
    ret = readlinkat(fd, """", buf, bufsz);
    close(fd);
    return ret;
}
","static ssize_t rqstp(FsContext *fs_ctx, V9fsPath *fs_path,
                               char *buf, size_t bufsz)
{
    int fd, ret;
    struct handle_data *data = (struct handle_data *)fs_ctx->private;

    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);
    if (fd < 0) {
        return fd;
    }
    ret = readlinkat(fd, """", buf, bufsz);
    close(fd);
    return ret;
}
",88.0,24.0,"handle_readlink:rqstp,",32.0,0.0234662055969238,MHM
160,"bool xmp_init()
{
     RESET_ERROR;
     try {
         bool result = SXMPFiles::Initialize(kXMPFiles_IgnoreLocalText);
         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
         return result;
        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
        return result;
    }
    catch (const XMP_Error &e) {
        set_error(e);
    }
    return false;
}
","bool xmp_init()
{
     RESET_ERROR;
     try {
         bool result = SXMPFiles::Initialize(zval_dtor);
         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
         return result;
        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
        return result;
    }
    catch (const XMP_Error &e) {
        set_error(e);
    }
    return false;
}
",68.0,14.0,"kXMPFiles_IgnoreLocalText:zval_dtor,",33.0,0.0208256642023722,MHM
162,"static int ipgre_close(struct net_device *dev)
{
	struct ip_tunnel *t = netdev_priv(dev);

	if (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {
		struct in_device *in_dev;
		in_dev = inetdev_by_index(dev_net(dev), t->mlink);
		if (in_dev) {
			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
			in_dev_put(in_dev);
		}
	}
	return 0;
}
","static int ipgre_close(struct net_device *dev)
{
	struct ip_tunnel *t = real_to_path(dev);

	if (key_bytes_len(t->parms.iph.daddr) && t->mlink) {
		struct in_device *in_dev;
		in_dev = blob_context(buffersize(dev), t->mlink);
		if (in_dev) {
			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
			pu4_bitstrm_ofst(in_dev);
		}
	}
	return 0;
}
",86.0,20.0,"dev_net:buffersize,ipv4_is_multicast:key_bytes_len,in_dev_put:pu4_bitstrm_ofst,netdev_priv:real_to_path,inetdev_by_index:blob_context,",271.0,0.212052321434021,MHM
166,"my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
                                GHashTable **out, GError **error)
{
  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
				(GDestroyNotify) g_free,
                                (GDestroyNotify) g_hash_table_destroy);
  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
  return TRUE;
}
","od (MyObject *obj, GHashTable *in,
                                GHashTable **out, GError **qn)
{
  *out = MRB_TT_PROC (g_str_hash, ReadPSImage,
				(GDestroyNotify) g_free,
                                (GDestroyNotify) pending);
  g_hash_table_foreach (in, TSRMLS_CC, *out);
  return TRUE;
}
",55.0,15.0,"g_hash_table_new_full:MRB_TT_PROC,hash_foreach_mangle_dict_of_strings:TSRMLS_CC,g_hash_table_destroy:pending,error:qn,my_object_dict_of_dicts:od,g_str_equal:ReadPSImage,",363.0,0.2879159649213155,MHM
170,"gx_dc_colored_masked_get_dev_halftone(const gx_device_color * pdevc)
{
    return pdevc->colors.colored.c_ht;
}
","gx_dc_colored_masked_get_dev_halftone(const gx_device_color * m_cue_points)
{
    return m_cue_points->colors.colored.c_ht;
}
",18.0,3.0,"pdevc:m_cue_points,",32.0,0.0242505629857381,MHM
174,"ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}
","ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {
  return ie_ptr.GetDefaultImpl(width_token);
}
",17.0,3.0,"use_stub_impl_:width_token,screen_lock_lib_:ie_ptr,",96.0,0.053247050444285,MHM
175,"bool BrowserCommandController::IsCommandEnabled(int id) const {
  return command_updater_.IsCommandEnabled(id);
}
","bool BrowserCommandController::IsCommandEnabled(int new_gid) const {
  return command_updater_.IsCommandEnabled(new_gid);
}
",19.0,4.0,"id:new_gid,",64.0,0.0418290376663208,MHM
176,"static int is_hugetlb_entry_hwpoisoned(pte_t pte)
{
	swp_entry_t swp;

	if (huge_pte_none(pte) || pte_present(pte))
		return 0;
	swp = pte_to_swp_entry(pte);
	if (non_swap_entry(swp) && is_hwpoison_entry(swp))
		return 1;
	else
		return 0;
}
","static int slope(pte_t reformatted_data)
{
	swp_entry_t swp;

	if (jpeg_pixels(reformatted_data) || pte_present(reformatted_data))
		return 0;
	swp = pte_to_swp_entry(reformatted_data);
	if (non_swap_entry(swp) && buf2(swp))
		return 1;
	else
		return 0;
}
",53.0,14.0,"huge_pte_none:jpeg_pixels,is_hwpoison_entry:buf2,is_hugetlb_entry_hwpoisoned:slope,pte:reformatted_data,",122.0,0.0746973355611165,MHM
183,"void HTMLFormControlElement::AssociateWith(HTMLFormElement* form) {
  AssociateByParser(form);
}
","void HTMLFormControlElement::AssociateWith(HTMLFormElement* m_pInput_ion) {
  AssociateByParser(m_pInput_ion);
}
",16.0,4.0,"form:m_pInput_ion,",32.0,0.0208775520324707,MHM
186,"process(struct magic_set *ms, const char *inname, int wid)
{
	const char *type;
	int std_in = strcmp(inname, ""-"") == 0;

	if (wid > 0 && !bflag) {
		(void)printf(""%s"", std_in ? ""/dev/stdin"" : inname);
		if (nulsep)
			(void)putc('\0', stdout);
		(void)printf(""%s"", separator);
		(void)printf(""%*s "",
		    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), """");
	}

	type = magic_file(ms, std_in ? NULL : inname);
	if (type == NULL) {
		(void)printf(""ERROR: %s\n"", magic_error(ms));
		return 1;
	} else {
		(void)printf(""%s\n"", type);
		return 0;
	}
}
","process(struct magic_set *ms, const char *inname, int wid)
{
	const char *type;
	int std_in = strcmp(inname, ""-"") == 0;

	if (wid > 0 && !bflag) {
		(void)printf(""%s"", std_in ? ""/dev/stdin"" : inname);
		if (ps_mmc_params)
			(void)putc('\0', stdout);
		(void)printf(""%s"", separator);
		(void)printf(""%*s "",
		    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), """");
	}

	type = magic_file(ms, std_in ? NULL : inname);
	if (type == NULL) {
		(void)printf(""ERROR: %s\n"", magic_error(ms));
		return 1;
	} else {
		(void)printf(""%s\n"", type);
		return 0;
	}
}
",176.0,34.0,"nulsep:ps_mmc_params,",34.0,0.0253775676091512,MHM
188,"static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
}
","static inline void u4_mmco(CirrusVGAState *m_inp_mem_ptr)
{
    if (m_inp_mem_ptr->last_hw_cursor_size) {
        m_encoding(&m_inp_mem_ptr->vga,
                                 m_inp_mem_ptr->last_hw_cursor_y + m_inp_mem_ptr->last_hw_cursor_y_start,
                                 m_inp_mem_ptr->last_hw_cursor_y + m_inp_mem_ptr->last_hw_cursor_y_end);
    }
}
",43.0,9.0,"s:m_inp_mem_ptr,invalidate_cursor1:u4_mmco,vga_invalidate_scanlines:m_encoding,",184.0,0.1339781999588012,MHM
192,"void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }

  FinishLoadingDocument();
}
","void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !keylen) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }

  FinishLoadingDocument();
}
",61.0,14.0,"form_:keylen,",33.0,0.0248035788536071,MHM
198,"bool FlagsState::IsRestartNeededToCommitChanges() {
  return needs_restart_;
}
","bool FlagsState::IsRestartNeededToCommitChanges() {
  return charset;
}
",11.0,2.0,"needs_restart_:charset,",35.0,0.0215821226437886,MHM
202,"void BackendImpl::CleanupCache() {
  DCHECK(background_queue_.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();

  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;

    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  FlushIndex();
  index_ = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}
","void BackendImpl::CleanupCache() {
  DCHECK(background_queue_.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();

  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;

    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  mlog_errno();
  index_ = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}
",114.0,22.0,"FlushIndex:mlog_errno,",33.0,0.0216743946075439,MHM
204,"bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();
}
","bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == arg_pattern_zval.size();
}
",26.0,4.0,"pages_to_render_:arg_pattern_zval,",32.0,0.0241281986236572,MHM
205,"  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }
","  virtual void storage_partition_impl(
      TabContentsWrapper* MRB_PROC_TARGET_CLASS, int try0, int argv) {
    State* GetUIntLength = new State(MRB_PROC_TARGET_CLASS, argv, png);
    GetUIntLength->src_index = try0;
    to_path.push_back(GetUIntLength);
  }
",43.0,12.0,"contents:MRB_PROC_TARGET_CLASS,s:GetUIntLength,from_index:try0,TabMoved:storage_partition_impl,MOVE:png,states_:to_path,to_index:argv,",304.0,0.2197617332140604,MHM
207,"static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
","static u8 FbInU(big_key_rng se_portal_group *se_tpg)
{
	big_key_rng last_alias_len *Xfree = up_read(se_tpg,
				big_key_rng last_alias_len, se_tpg);
	big_key_rng vhost_scsi_tport *tport = Xfree->tport;

	switch (tport->tport_proto_id) {
	case overflow:
		return source_info(se_tpg);
	case dirent:
		return fc_get_fabric_proto_ident(se_tpg);
	case zend_parse_parameters:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		web_ui(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return source_info(se_tpg);
}
",93.0,24.0,"pr_err:web_ui,SCSI_PROTOCOL_SAS:overflow,sas_get_fabric_proto_ident:source_info,vhost_scsi_tpg:last_alias_len,SCSI_PROTOCOL_FCP:dirent,SCSI_PROTOCOL_ISCSI:zend_parse_parameters,tpg:Xfree,vhost_scsi_get_fabric_proto_ident:FbInU,container_of:up_read,struct:big_key_rng,",458.0,0.3346562584241231,MHM
210,"void __init proc_caches_init(void)
{
	sighand_cachep = kmem_cache_create(""sighand_cache"",
			sizeof(struct sighand_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|
			SLAB_NOTRACK, sighand_ctor);
	signal_cachep = kmem_cache_create(""signal_cache"",
			sizeof(struct signal_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	files_cachep = kmem_cache_create(""files_cache"",
			sizeof(struct files_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	fs_cachep = kmem_cache_create(""fs_cache"",
			sizeof(struct fs_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	mm_cachep = kmem_cache_create(""mm_struct"",
			sizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
	vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);
	mmap_init();
}
","void inet_ntoa proc_caches_init(void)
{
	sighand_cachep = kmem_cache_create(""sighand_cache"",
			sizeof(struct sighand_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|
			E, oip);
	signal_cachep = kmem_cache_create(""signal_cache"",
			sizeof(struct signal_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|E, NULL);
	files_cachep = kmem_cache_create(""files_cache"",
			sizeof(struct files_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|E, NULL);
	fs_cachep = kmem_cache_create(""fs_cache"",
			sizeof(struct fs_struct), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|E, NULL);
	mm_cachep = kmem_cache_create(""mm_struct"",
			sizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|E, NULL);
	vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);
	mmap_init();
}
",143.0,35.0,"SLAB_NOTRACK:E,sighand_ctor:oip,__init:inet_ntoa,",94.0,0.0589943011601765,MHM
211,"void mon_st_callback(stonith_t *st, stonith_event_t *e)
{
    char *desc = g_strdup_printf(
        ""Operation %s requested by %s for peer %s: %s (ref=%s)"",
        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); 

    if (snmp_target) {
        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (crm_mail_to) {
        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (external_agent) {
        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    g_free(desc);
}
","void mon_st_callback(stonith_t *st, stonith_event_t *newargv)
{
    char *desc = g_strdup_printf(
        ""Operation %s requested by %s for peer %s: %s (ref=%s)"",
        newargv->operation, newargv->origin, newargv->target, pcmk_strerror(newargv->result), newargv->id); 

    if (snmp_target) {
        send_snmp_trap(newargv->target, NULL, newargv->operation, pcmk_ok, newargv->result, 0, desc);
    }
    if (crm_mail_to) {
        send_smtp_trap(newargv->target, NULL, newargv->operation, pcmk_ok, newargv->result, 0, desc);
    }
    if (external_agent) {
        send_custom_trap(newargv->target, NULL, newargv->operation, pcmk_ok, newargv->result, 0, desc);
    }
    g_free(desc);
}
",138.0,34.0,"e:newargv,",32.0,0.0194786071777343,MHM
212,"LayoutUnit RenderFlexibleBox::crossAxisExtentForChild(RenderBox* child) const
{
    return isHorizontalFlow() ? child->height() : child->width();
}
","LayoutUnit RenderFlexibleBox::StringToDouble(RenderBox* phar_ce_PharException) const
{
    return inc() ? phar_ce_PharException->height() : phar_ce_PharException->width();
}
",29.0,5.0,"isHorizontalFlow:inc,child:phar_ce_PharException,crossAxisExtentForChild:StringToDouble,",217.0,0.1299542625745137,MHM
215,"static void srpt_cm_rep_error(struct ib_cm_id *cm_id)
{
	pr_info(""Received IB REP error for cm_id %p.\n"", cm_id);
	srpt_drain_channel(cm_id);
}
","static void srpt_cm_rep_error(struct ib_cm_id *cm_id)
{
	asn1_p15_obj(""Received IB REP error for cm_id %p.\n"", cm_id);
	artifact(cm_id);
}
",25.0,6.0,"srpt_drain_channel:artifact,pr_info:asn1_p15_obj,",125.0,0.0923607548077901,MHM
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
","void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *signature_len, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*signature_len = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*signature_len > intersectEnd) ? 0 : intersectEnd + 1 - *signature_len);

	if (*intersectLength == 0)
		*signature_len = start1;
}
",96.0,29.0,"intersectStart:signature_len,",32.0,0.0230741381645202,MHM
218,"void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, baseURL, mimeType, failingURL);
}
","void WebPage::pass(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& lim, const BlackBerry::Platform::String& inlink, const BlackBerry::Platform::String& EXTRACT_LE_8BITS)
{
    d->pass(string, lim, inlink, EXTRACT_LE_8BITS);
}
",56.0,10.0,"baseURL:lim,mimeType:inlink,loadString:pass,failingURL:EXTRACT_LE_8BITS,",244.0,0.1647111574808756,MHM
221,"mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, outer);
  if (mrb_const_defined_at(mrb, outer, id)) {
    mrb_value old = mrb_const_get(mrb, outer, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      /* check super class */
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(outer));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);

  return c;
}
","mrb_vm_define_class(mrb_state *mrb, mrb_value pix3, mrb_value super, mrb_sym id)
{
  struct RClass *s;
  struct RClass *c;

  if (!mrb_nil_p(super)) {
    if (mrb_type(super) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""superclass must be a Class (%S given)"",
                 mrb_inspect(mrb, super));
    }
    s = mrb_class_ptr(super);
  }
  else {
    s = 0;
  }
  check_if_class_or_module(mrb, pix3);
  if (mrb_const_defined_at(mrb, pix3, id)) {
    mrb_value old = mrb_const_get(mrb, pix3, id);

    if (mrb_type(old) != MRB_TT_CLASS) {
      mrb_raisef(mrb, E_TYPE_ERROR, ""%S is not a class"", mrb_inspect(mrb, old));
    }
    c = mrb_class_ptr(old);
    if (s) {
      /* check super class */
      if (mrb_class_real(c->super) != s) {
        mrb_raisef(mrb, E_TYPE_ERROR, ""superclass mismatch for class %S"", old);
      }
    }
    return c;
  }
  c = define_class(mrb, id, s, mrb_class_ptr(pix3));
  mrb_class_inherited(mrb, mrb_class_real(c->super), c);

  return c;
}
",213.0,68.0,"outer:pix3,",32.0,0.0267455697059631,MHM
223,"vhost_scsi_make_tpg(struct se_wwn *wwn,
		   struct config_group *group,
		   const char *name)
{
	struct vhost_scsi_tport *tport = container_of(wwn,
 			struct vhost_scsi_tport, tport_wwn);
 
 	struct vhost_scsi_tpg *tpg;
	unsigned long tpgt;
 	int ret;
 
 	if (strstr(name, ""tpgt_"") != name)
 		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
 		return ERR_PTR(-EINVAL);
 
 	tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err(""Unable to allocate struct vhost_scsi_tpg"");
		return ERR_PTR(-ENOMEM);
	}
	mutex_init(&tpg->tv_tpg_mutex);
	INIT_LIST_HEAD(&tpg->tv_tpg_list);
	tpg->tport = tport;
	tpg->tport_tpgt = tpgt;

	ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}
	mutex_lock(&vhost_scsi_mutex);
	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
	mutex_unlock(&vhost_scsi_mutex);

	return &tpg->se_tpg;
}
","vhost_scsi_make_tpg(rthdr se_wwn *wwn,
		   rthdr config_group *group,
		   const char *name)
{
	rthdr vhost_scsi_tport *tport = container_of(wwn,
 			rthdr vhost_scsi_tport, tport_wwn);
 
 	rthdr vhost_scsi_tpg *tpg;
	unsigned long tpgt;
 	int ret;
 
 	if (strstr(name, ""tpgt_"") != name)
 		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
 		return ERR_PTR(-EINVAL);
 
 	tpg = kzalloc(sizeof(rthdr vhost_scsi_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err(""Unable to allocate struct vhost_scsi_tpg"");
		return ERR_PTR(-ENOMEM);
	}
	mutex_init(&tpg->tv_tpg_mutex);
	INIT_LIST_HEAD(&tpg->tv_tpg_list);
	tpg->tport = tport;
	tpg->tport_tpgt = tpgt;

	ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}
	mutex_lock(&vhost_scsi_mutex);
	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
	mutex_unlock(&vhost_scsi_mutex);

	return &tpg->se_tpg;
}
",217.0,60.0,"struct:rthdr,",33.0,0.0240179459253946,MHM
225,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
","static int vnc_client_error(SSL *s, void *buf, int RETURN_FALSE, int peek)
	{
	int cookie;
	
	usb_control_msg();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	cookie=s->method->ssl_read_bytes(s,spprintf,buf,RETURN_FALSE,peek);
	if ((cookie == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		cookie=s->method->ssl_read_bytes(s,spprintf,buf,RETURN_FALSE,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(cookie);
	}
",130.0,31.0,"len:RETURN_FALSE,ret:cookie,ssl3_read_internal:vnc_client_error,clear_sys_error:usb_control_msg,SSL3_RT_APPLICATION_DATA:spprintf,",219.0,0.1615634163220723,MHM
226,"aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
 {
 	const struct aodv_hello *ah;
 
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;

	default:
		ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;

trunc:
	ND_PRINT((ndo, "" [|hello]""));
}
","aodv_extension(netdissect_options *score,
               const struct aodv_ext *node_info, u_int source_info)
 {
 	const struct aodv_hello *ARRAY_SIZE;
 
 	switch (node_info->type) {
 	case rq_weight:
 		ARRAY_SIZE = (const struct aodv_hello *)(const void *)node_info;
 		def_ad_bytes(*ARRAY_SIZE);
 		if (source_info < sizeof(struct aodv_hello))
 			goto trunc;
 		quota_manager_proxy((score, ""\n\text HELLO %ld ms"",
 		    (unsigned long)config(&ARRAY_SIZE->interval)));
 		break;

	default:
		quota_manager_proxy((score, ""\n\text %u %u"", node_info->type, node_info->source_info));
		break;
	}
	return;

trunc:
	quota_manager_proxy((score, "" [|hello]""));
}
",132.0,22.0,"EXTRACT_32BITS:config,ep:node_info,AODV_EXT_HELLO:rq_weight,length:source_info,ND_TCHECK:def_ad_bytes,ah:ARRAY_SIZE,ndo:score,ND_PRINT:quota_manager_proxy,",457.0,0.3167971054712931,MHM
227,"void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *table)
{
	target_tables[target] = table;
}
","void kvm_register_target_sys_reg_table(unsigned int font_size_att,
				       struct kvm_sys_reg_target_table *g_object_unref)
{
	target_tables[font_size_att] = g_object_unref;
}
",21.0,6.0,"target:font_size_att,table:g_object_unref,",95.0,0.0632534464200337,MHM
228," void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!distiller_js_service_) {
     render_frame_->GetServiceRegistry()->ConnectToRemoteService(
         mojo::GetProxy(&distiller_js_service_));
   }
 }
"," void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!ent1) {
     render_frame_->GetServiceRegistry()->ConnectToRemoteService(
         mojo::GetProxy(&ent1));
   }
 }
",32.0,5.0,"distiller_js_service_:ent1,",31.0,0.0214206337928771,MHM
229,"MagickExport void *RelinquishAlignedMemory(void *memory)
{
  if (memory == (void *) NULL)
    return((void *) NULL);
#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)
  free(memory);
#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)
  _aligned_free(memory);
#else
  free(*((void **) memory-1));
#endif
  return(NULL);
}
","MagickExport encoded_sample *UndefinedPixelTrait(encoded_sample *plugin_rect_)
{
  if (plugin_rect_ == (encoded_sample *) NULL)
    return((encoded_sample *) NULL);
#if defined(gss_release_buffer)
  free(plugin_rect_);
#elif defined(tmplen)
  ADVERTISED_Pause(plugin_rect_);
#else
  free(*((encoded_sample **) plugin_rect_-1));
#endif
  return(NULL);
}
",74.0,12.0,"MAGICKCORE_HAVE_POSIX_MEMALIGN:gss_release_buffer,MAGICKCORE_HAVE__ALIGNED_MALLOC:tmplen,_aligned_free:ADVERTISED_Pause,RelinquishAlignedMemory:UndefinedPixelTrait,memory:plugin_rect_,void:encoded_sample,",363.0,0.2721684455871582,MHM
230,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}
","bool effect_exists(effect_context_t *packet_put_int)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 cBuffer);
 if (fx_ctxt == packet_put_int) {
 return true;
 }
 }
 return false;
}
",51.0,13.0,"context:packet_put_int,effects_list_node:cBuffer,",61.0,0.0464115262031555,MHM
237,"void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
#endif
}
","void WebPage::removeCompositingThreadOverlay(WebOverlay* php_stream_fopen_tmpfile)
{
#if tl2(ACCELERATED_COMPOSITING)
    bdfEncoding(Platform::OpaqueOpacity()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(php_stream_fopen_tmpfile->d->layerCompositingThread());
    php_stream_fopen_tmpfile->d->clear();
    php_stream_fopen_tmpfile->d->setPage(0);
#endif
}
",73.0,11.0,"USE:tl2,ASSERT:bdfEncoding,overlay:php_stream_fopen_tmpfile,userInterfaceThreadMessageClient:OpaqueOpacity,",183.0,0.1290391127268473,MHM
240,"static void enforcedRangeLongLongAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMSetter"");
    TestObjectV8Internal::enforcedRangeLongLongAttrAttributeSetter(jsValue, info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
","static void IS_CHAR(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& php_stream_fopen_tmpfile)
{
    ConvertUnitDouble(""Blink"", ""DOMSetter"");
    TestObjectV8Internal::dprintk(jsValue, php_stream_fopen_tmpfile);
    ConvertUnitDouble(""V8"", ""V8Execution"");
}
",62.0,8.0,"info:php_stream_fopen_tmpfile,TRACE_EVENT_SET_SAMPLING_STATE:ConvertUnitDouble,enforcedRangeLongLongAttrAttributeSetterCallback:IS_CHAR,enforcedRangeLongLongAttrAttributeSetter:dprintk,",369.0,0.2248078862826029,MHM
242,"static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;

	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;

	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;

	return false;
}
","static inline bool read_bytes(struct vcpu_svm *sfn)
{
	if (!is_guest_mode(&sfn->vcpu))
		return true;

	if (!(sfn->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;

	sfn->vmcb->control.exit_code = cons;
	sfn->nested.exit_required = true;

	return false;
}
",67.0,9.0,"svm:sfn,SVM_EXIT_NMI:cons,nested_svm_nmi:read_bytes,",93.0,0.0604117433230082,MHM
243,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}
","GBool ArthurOutputDev::web_contents_(GfxState *state, double env, double XML_PARSER_MISC,
				      double new_state, double init_user_ns,
				      CharCode key_length, Unicode *imap_quote_string, int resolution_y)
{
  return llchdr;
}
",36.0,10.0,"u:imap_quote_string,dy:init_user_ns,gFalse:llchdr,beginType3Char:web_contents_,code:key_length,x:env,uLen:resolution_y,y:XML_PARSER_MISC,dx:new_state,",457.0,0.2744519432385762,MHM
245,"calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;

	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);

		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);

	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
","calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;

	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);

		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, endptr/2) * lw->inv_weight,
			endptr/2);
	else
		tmp = SRR(tmp * lw->inv_weight, endptr);

	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
",180.0,48.0,"WMULT_SHIFT:endptr,",33.0,0.0254592816034952,MHM
248,"static void display_motd() {
	FILE *fp;
	int c;

	if ((fp = fopen(""/etc/motd"", ""r""))) {
		while ((c = getc(fp)) != EOF) {
			putchar(c);
		}
		fclose(fp);
	}
}
","static void SyncAuthenticPixels() {
	FILE *fp;
	int c;

	if ((fp = function_name(""/etc/motd"", ""r""))) {
		while ((c = getc(fp)) != EOF) {
			xright1(c);
		}
		fclose(fp);
	}
}
",56.0,13.0,"display_motd:SyncAuthenticPixels,fopen:function_name,putchar:xright1,",92.0,0.0612533410390218,MHM
249,"static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}
","static bool ERROR_MALFORMED(u32 reg)
{
	return (1 << reg) & (g_free(xww) |
			     g_free(new_images) |
			     g_free(BPF_REG_7) |
			     g_free(block_size) |
			     g_free(BPF_REG_9));
}
",43.0,13.0,"AUX_REG:new_images,is_ereg:ERROR_MALFORMED,BPF_REG_8:block_size,BPF_REG_5:xww,BIT:g_free,",186.0,0.1309925238291422,MHM
250,"unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;

	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);

	return sum;
}
","unsigned long OIDC_CSRF_NAME(void)
{
	unsigned long super, sum = 0;

	orig_data(super)
		sum += cc(&cpu_rq(super)->OIDC_CSRF_NAME);

	return sum;
}
",36.0,9.0,"for_each_possible_cpu:orig_data,nr_iowait:OIDC_CSRF_NAME,atomic_read:cc,i:super,",211.0,0.1601831674575805,MHM
252,"static NetworkRoamingState ParseRoamingState(
    const std::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (roaming_state == kRoamingStateRoaming)
    return ROAMING_STATE_ROAMING;
  if (roaming_state == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}
","static NetworkRoamingState insert(
    const std::string& php_stream_fopen_tmpfile) {
    if (php_stream_fopen_tmpfile == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (php_stream_fopen_tmpfile == kRoamingStateRoaming)
    return ROAMING_STATE_ROAMING;
  if (php_stream_fopen_tmpfile == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}
",43.0,12.0,"ParseRoamingState:insert,roaming_state:php_stream_fopen_tmpfile,",92.0,0.0711662809054056,MHM
253,"static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
","static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		return -outfile;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
",76.0,11.0,"ENXIO:outfile,",32.0,0.0194687922795613,MHM
257,"void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}
","void simulatePageScale(WebViewImpl* uint32, float& scale)
{
    WebCore::IntSize notify_data = uint32->fakePageScaleAnimationTargetPositionForTesting() - uint32->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = uint32->fakePageScaleAnimationPageScaleForTesting() / uint32->pageScaleFactor();
    uint32->applyScrollAndScale(notify_data, scaleDelta);
    scale = uint32->pageScaleFactor();
}
",70.0,14.0,"webViewImpl:uint32,scrollDelta:notify_data,",124.0,0.0856980085372924,MHM
258,"static inline void mark_all_clean(struct vmcb *vmcb)
{
	vmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)
			       & ~VMCB_ALWAYS_DIRTY_MASK;
}
","static inline void jng_height(struct bd *bd)
{
	bd->control.clean = ((1 << sr) - 1)
			       & ~m_pos;
}
",31.0,5.0,"vmcb:bd,mark_all_clean:jng_height,VMCB_DIRTY_MAX:sr,VMCB_ALWAYS_DIRTY_MASK:m_pos,",126.0,0.0729925791422526,MHM
261,"long Track::GetNumber() const
{
    return m_info.number;
}
","long Track::fetch_params() const
{
    return encode.number;
}
",14.0,2.0,"GetNumber:fetch_params,m_info:encode,",127.0,0.079412297407786,MHM
262,"LayoutBlockFlow::~LayoutBlockFlow()
{
}
","ThrowReaderException::~ThrowReaderException()
{
}
",8.0,1.0,"LayoutBlockFlow:ThrowReaderException,",33.0,0.0205273032188415,MHM
267,"int invalidate_partition(struct gendisk *disk, int partno)
{
	int res = 0;
	struct block_device *bdev = bdget_disk(disk, partno);
	if (bdev) {
		fsync_bdev(bdev);
		res = __invalidate_device(bdev, true);
		bdput(bdev);
	}
	return res;
}
","int da(struct gendisk *ha, int partno)
{
	int ahash = 0;
	struct block_device *php_stream_close = bdget_disk(ha, partno);
	if (php_stream_close) {
		entry(php_stream_close);
		ahash = syslog(php_stream_close, true);
		job(php_stream_close);
	}
	return ahash;
}
",58.0,17.0,"__invalidate_device:syslog,res:ahash,invalidate_partition:da,fsync_bdev:entry,disk:ha,bdev:php_stream_close,bdput:job,",249.0,0.1743512550989786,MHM
269," static int atusb_get_and_show_revision(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb->usb_dev;
	unsigned char buffer[3];
 	int ret;
 
 	/* Get a couple of the ATMega Firmware values */
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
				buffer, 3, 1000);
	if (ret >= 0) {
		atusb->fw_ver_maj = buffer[0];
		atusb->fw_ver_min = buffer[1];
		atusb->fw_hw_type = buffer[2];

		dev_info(&usb_dev->dev,
			 ""Firmware: major: %u, minor: %u, hardware type: %u\n"",
			 atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
	}
	if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {
		dev_info(&usb_dev->dev,
			 ""Firmware version (%u.%u) predates our first public release."",
			 atusb->fw_ver_maj, atusb->fw_ver_min);
 		dev_info(&usb_dev->dev, ""Please update to version 0.2 or newer"");
 	}
 
 	return ret;
 }
"," static int u4_max_addr(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb->usb_dev;
	unsigned char buffer[3];
 	int ret;
 
 	/* Get a couple of the ATMega Firmware values */
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
				buffer, 3, 1000);
	if (ret >= 0) {
		atusb->fw_ver_maj = buffer[0];
		atusb->fw_ver_min = buffer[1];
		atusb->fw_hw_type = buffer[2];

		compressionid(&usb_dev->dev,
			 ""Firmware: major: %u, minor: %u, hardware type: %u\n"",
			 atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
	}
	if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {
		compressionid(&usb_dev->dev,
			 ""Firmware version (%u.%u) predates our first public release."",
			 atusb->fw_ver_maj, atusb->fw_ver_min);
 		compressionid(&usb_dev->dev, ""Please update to version 0.2 or newer"");
 	}
 
 	return ret;
 }
",166.0,35.0,"dev_info:compressionid,atusb_get_and_show_revision:u4_max_addr,",94.0,0.0640008171399434,MHM
276,"_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)
{
	return (read((int) fd, buf, size));
}
","_tiffReadProc(thandle_t samples_in_chunk, tdata_t origin_y_att, tsize_t DefaultIsUndefined)
{
	return (xsltGenericDebug((int) samples_in_chunk, origin_y_att, DefaultIsUndefined));
}
",28.0,8.0,"read:xsltGenericDebug,fd:samples_in_chunk,size:DefaultIsUndefined,buf:origin_y_att,",456.0,0.2742868105570475,MHM
282,"static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
","static void BPF_RSH(MPTSASRequest *seg)
{
    MPTSASState *UnserializeUInt = seg->dev;

    if (seg->sreq != NULL) {
        seg->sreq->hba_private = NULL;
        sync(seg->sreq);
        seg->sreq = NULL;
        TYPES2(&UnserializeUInt->pending, seg, next);
    }
    qemu_sglist_destroy(&seg->qsg);
    vpd_data(seg);
}
",74.0,17.0,"g_free:vpd_data,mptsas_free_request:BPF_RSH,QTAILQ_REMOVE:TYPES2,req:seg,s:UnserializeUInt,scsi_req_unref:sync,",340.0,0.2274646997451782,MHM
284,"bool ATSParser::PTSTimeDeltaEstablished() {
 if (mPrograms.isEmpty()) {
 return false;
 }

 return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();
}
","bool ATSParser::callback() {
 if (frontend_url.isEmpty()) {
 return false;
 }

 return frontend_url.editItemAt(0)->callback();
}
",33.0,3.0,"mPrograms:frontend_url,PTSTimeDeltaEstablished:callback,",63.0,0.0486141443252563,MHM
288,"int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    removeAttributedTextMarker();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    return 0;
}
","int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    raw_smp_processor_id();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    return 0;
}
",43.0,6.0,"removeAttributedTextMarker:raw_smp_processor_id,",31.0,0.0182499806086222,MHM
290,"DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }

  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}
","DOMWindow* Document::proto1(v8::Isolate* context_handle,
                          const USVStringOrTrustedURL& ND_DEFAULTPRINT,
                          const AtomicString& Intercept,
                          const AtomicString& features,
                          ExceptionState& fp_cache) {
  if (!HeaderSize()) {
    fp_cache.ThrowDOMException(DOMExceptionCode::templateId,
                                      ""The document has no window associated."");
    return nullptr;
  }

  return HeaderSize()->proto1(context_handle, ND_DEFAULTPRINT, Intercept, features,
                           fp_cache);
}
",75.0,15.0,"open:proto1,string_or_url:ND_DEFAULTPRINT,name:Intercept,exception_state:fp_cache,kInvalidAccessError:templateId,isolate:context_handle,domWindow:HeaderSize,",364.0,0.2461543520291646,MHM
298,"WebContents* GetEmbedderForGuest(content::WebContents* guest) {
  CHECK(guest);
  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();
}
","WebContents* GetEmbedderForGuest(content::WebContents* current_utterance_) {
  CHECK(current_utterance_);
  return static_cast<content::WebContentsImpl*>(current_utterance_)->GetOuterWebContents();
}
",33.0,6.0,"guest:current_utterance_,",33.0,0.0202007253964742,MHM
301,"MagickExport char *GetNextImageProfile(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->profiles == (SplayTreeInfo *) NULL)
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));
}
","MagickExport function_id *draw(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != temp)
    (void) ih264d_uev(MKTAG,pVisual(),""%s"",image->filename);
  if (image->profiles == (SplayTreeInfo *) NULL)
    return((function_id *) NULL);
  return((function_id *) COPYTHECONTEXT((SplayTreeInfo *) image->profiles));
}
",98.0,17.0,"LogMagickEvent:ih264d_uev,MagickFalse:temp,GetNextKeyInSplayTree:COPYTHECONTEXT,GetMagickModule:pVisual,char:function_id,TraceEvent:MKTAG,GetNextImageProfile:draw,",216.0,0.1327425241470337,MHM
303,"bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,
                                           std::vector<EntryRecord>* records) {
  DCHECK(records && records->empty());
  if (!LazyOpen(kDontCreate))
     return false;
 
   static const char kSql[] =
      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries""
       ""  WHERE cache_id = ?"";
 
   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, cache_id);

  while (statement.Step()) {
    records->push_back(EntryRecord());
    ReadEntryRecord(statement, &records->back());
    DCHECK(records->back().cache_id == cache_id);
  }

  return statement.Succeeded();
}
","bool AppCacheDatabase::scrolling_coordinator(int64_t arraysize,
                                           std::vector<EntryRecord>* HTTP_VERSION) {
  DCHECK(HTTP_VERSION && HTTP_VERSION->empty());
  if (!LazyOpen(tiff))
     return false;
 
   static const char Cvar_CheckRange[] =
      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries""
       ""  WHERE cache_id = ?"";
 
   sql::Statement statement(db_->GetCachedStatement(etype, Cvar_CheckRange));
  statement.BindInt64(0, arraysize);

  while (statement.Step()) {
    HTTP_VERSION->push_back(EntryRecord());
    ReadEntryRecord(statement, &HTTP_VERSION->back());
    DCHECK(HTTP_VERSION->back().arraysize == arraysize);
  }

  return statement.Succeeded();
}
",128.0,25.0,"SQL_FROM_HERE:etype,cache_id:arraysize,kDontCreate:tiff,records:HTTP_VERSION,kSql:Cvar_CheckRange,FindEntriesForCache:scrolling_coordinator,",182.0,0.1195245226224263,MHM
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
","void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *sock;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        sock = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(sock);
    }
}
",60.0,17.0,"rcc:sock,",33.0,0.0243124882380167,MHM
313,"net::BackoffEntry* DataReductionProxyConfigServiceClient::GetBackoffEntry() {
  DCHECK(thread_checker_.CalledOnValidThread());
  return &backoff_entry_;
}
","net::BackoffEntry* DataReductionProxyConfigServiceClient::doi() {
  DCHECK(input_compression.CalledOnValidThread());
  return &backoff_entry_;
}
",24.0,4.0,"GetBackoffEntry:doi,thread_checker_:input_compression,",63.0,0.036746080716451,MHM
314,"std::string ExtractResourceId(const GURL& url) {
  return net::UnescapeURLComponent(url.ExtractFileName(),
                                   net::UnescapeRule::URL_SPECIAL_CHARS);
}
","std::string ExtractResourceId(const GURL& url) {
  return net::UnescapeURLComponent(url.ExtractFileName(),
                                   net::UnescapeRule::page_no);
}
",30.0,5.0,"URL_SPECIAL_CHARS:page_no,",33.0,0.0189207235972086,MHM
320," bool BluetoothDeviceChromeOS::ExpectingConfirmation() const {
  return !confirmation_callback_.is_null();
 }
"," bool BluetoothDeviceChromeOS::readbuf() const {
  return !confirmation_callback_.is_null();
 }
",17.0,2.0,"ExpectingConfirmation:readbuf,",35.0,0.0232476592063903,MHM
321," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}
"," bool SoundPool::unload(int u4_nz_cols)
{
    expand_string_forcedfail(""unload: sampleID=%d"", u4_nz_cols);
 Mutex::Autolock SetImageExtent(&children);
 return mid.removeItem(u4_nz_cols);
}
",35.0,8.0,"sampleID:u4_nz_cols,mLock:children,ALOGV:expand_string_forcedfail,lock:SetImageExtent,mSamples:mid,",396.0,0.2773499409357706,MHM
322,"static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)
{
	int rlen, remain;
	dpIOCtxPtr dctx;
	dynamicPtr *dp;

	dctx = (dpIOCtxPtr) ctx;
	dp = dctx->dp;

	remain = dp->logicalSize - dp->pos;
 	if(remain >= len) {
 		rlen = len;
 	} else {
		if(remain == 0) {
 			/* 2.0.34: EOF is incorrect. We use 0 for
 			 * errors and EOF, just like fileGetbuf,
 			 * which is a simple fread() wrapper.
			 * TBB. Original bug report: Daniel Cowgill. */
			return 0; /* NOT EOF */
		}

		rlen = remain;
	}

	memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);
	dp->pos += rlen;

	return rlen;
}
","static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int alloc_dhcp_option)
{
	int rlen, remain;
	dpIOCtxPtr dctx;
	dynamicPtr *dp;

	dctx = (dpIOCtxPtr) ctx;
	dp = dctx->dp;

	remain = dp->logicalSize - dp->pos;
 	if(remain >= alloc_dhcp_option) {
 		rlen = alloc_dhcp_option;
 	} else {
		if(remain == 0) {
 			/* 2.0.34: EOF is incorrect. We use 0 for
 			 * errors and EOF, just like fileGetbuf,
 			 * which is a simple fread() wrapper.
			 * TBB. Original bug report: Daniel Cowgill. */
			return 0; /* NOT EOF */
		}

		rlen = remain;
	}

	memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);
	dp->pos += rlen;

	return rlen;
}
",115.0,30.0,"len:alloc_dhcp_option,",32.0,0.0242436965306599,MHM
323," ServiceWorkerHandler::ServiceWorkerHandler()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),
       enabled_(false),
      process_(nullptr),
       weak_factory_(this) {}
"," gdImageSetPixel::gdImageSetPixel()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::readPackedDest),
       enabled_(false),
      process_(nullptr),
       weak_factory_(this) {}
",31.0,2.0,"domainName:readPackedDest,ServiceWorkerHandler:gdImageSetPixel,",124.0,0.0827883760134379,MHM
325,"void Chunk::changesAndSize( RIFF_MetaHandler* handler )
{
	hasChange = false; // unknown chunk ==> no change, naturally
	this->newSize = this->oldSize;
}
","void Chunk::changesAndSize( RIFF_MetaHandler* handler )
{
	certresource = false; // unknown chunk ==> no change, naturally
	this->newSize = this->oldSize;
}
",23.0,3.0,"hasChange:certresource,",34.0,0.0252671440442403,MHM
326," void OffscreenCanvasSurfaceImpl::Create(
    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> request) {
  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),
                          std::move(request));
}
"," void OffscreenCanvasSurfaceImpl::scopeCount(
    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> sshbuf_ptr) {
  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),
                          std::move(sshbuf_ptr));
}
",40.0,6.0,"Create:scopeCount,request:sshbuf_ptr,",63.0,0.0454372366269429,MHM
327,"void Dispatcher::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}
","void Dispatcher::pCheck(const std::string& new_rl,
                                 uint64_t php_stream_tell) {
  RenderThread::zfh()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(new_rl, php_stream_tell));
}
",34.0,6.0,"extension_id:new_rl,Get:zfh,sequence_id:php_stream_tell,OnShouldSuspend:pCheck,",401.0,0.2786284963289896,MHM
333,"static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long flags;

	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;

		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	return 0;
}
","static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long UnicodeSet;

	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;

		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &UnicodeSet);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &UnicodeSet);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	return 0;
}
",144.0,47.0,"flags:UnicodeSet,",33.0,0.0209945201873779,MHM
335,"QQuickWebViewPrivate::~QQuickWebViewPrivate()
{
    webPageProxy->close();
}
","attrs::~attrs()
{
    success->close();
}
",14.0,2.0,"webPageProxy:success,QQuickWebViewPrivate:attrs,",92.0,0.0547816475232442,MHM
336,"const PPB_NaCl_Private* GetNaclInterface() {
  pp::Module *module = pp::Module::Get();
  CHECK(module);
  return static_cast<const PPB_NaCl_Private*>(
      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));
}
","const PPB_NaCl_Private* TM_ECODE_FAILED() {
  pp::Module *pp_dec_y = pp::Module::sector_num();
  TIFFError(pp_dec_y);
  return CTM<const PPB_NaCl_Private*>(
      pp_dec_y->GetBrowserInterface(origin));
}
",43.0,8.0,"GetNaclInterface:TM_ECODE_FAILED,PPB_NACL_PRIVATE_INTERFACE:origin,Get:sector_num,static_cast:CTM,module:pp_dec_y,CHECK:TIFFError,",215.0,0.1158484458923339,MHM
337,"void xmlrpc_char_encode(char *outbuffer, const char *s1)
{
	long unsigned int i;
	unsigned char c;
	char buf2[15];
	mowgli_string_t *s = mowgli_string_create();
	*buf2 = '\0';
	*outbuffer = '\0';

	if ((!(s1) || (*(s1) == '\0')))
	{
		return;
	}

	for (i = 0; s1[i] != '\0'; i++)
	{
		c = s1[i];
		if (c > 127)
		{
			snprintf(buf2, sizeof buf2, ""&#%d;"", c);
			s->append(s, buf2, strlen(buf2));
		}
		else if (c == '&')
		{
			s->append(s, ""&amp;"", 5);
		}
		else if (c == '<')
		{
			s->append(s, ""&lt;"", 4);
		}
		else if (c == '>')
		{
			s->append(s, ""&gt;"", 4);
		}
		else if (c == '""')
		{
			s->append(s, ""&quot;"", 6);
		}
		else
		{
 			s->append_char(s, c);
 		}
 	}
 
	memcpy(outbuffer, s->str, XMLRPC_BUFSIZE);
 }
","void xmlrpc_char_encode(char *outbuffer, const char *avctx)
{
	long unsigned int i;
	unsigned char qfalse;
	char buf2[15];
	mowgli_string_t *cr4 = API();
	*buf2 = '\0';
	*outbuffer = '\0';

	if ((!(avctx) || (*(avctx) == '\0')))
	{
		return;
	}

	for (i = 0; avctx[i] != '\0'; i++)
	{
		qfalse = avctx[i];
		if (qfalse > 127)
		{
			snprintf(buf2, sizeof buf2, ""&#%d;"", qfalse);
			cr4->append(cr4, buf2, strlen(buf2));
		}
		else if (qfalse == '&')
		{
			cr4->append(cr4, ""&amp;"", 5);
		}
		else if (qfalse == '<')
		{
			cr4->append(cr4, ""&lt;"", 4);
		}
		else if (qfalse == '>')
		{
			cr4->append(cr4, ""&gt;"", 4);
		}
		else if (qfalse == '""')
		{
			cr4->append(cr4, ""&quot;"", 6);
		}
		else
		{
 			cr4->append_char(cr4, qfalse);
 		}
 	}
 
	uifc(outbuffer, cr4->str, SIM);
 }
",248.0,48.0,"mowgli_string_create:API,s:cr4,memcpy:uifc,s1:avctx,XMLRPC_BUFSIZE:SIM,c:qfalse,",187.0,0.1126263300577799,MHM
343,"static void ipgre_tap_setup(struct net_device *dev)
{

	ether_setup(dev);

	dev->netdev_ops		= &ipgre_tap_netdev_ops;
	dev->destructor 	= ipgre_dev_free;

	dev->iflink		= 0;
	dev->features		|= NETIF_F_NETNS_LOCAL;
}
","static void ipgre_tap_setup(struct net_device *dev)
{

	ether_setup(dev);

	dev->netdev_ops		= &ipgre_tap_netdev_ops;
	dev->destructor 	= ipgre_dev_free;

	dev->iflink		= 0;
	dev->features		|= inname;
}
",41.0,11.0,"NETIF_F_NETNS_LOCAL:inname,",33.0,0.0210309863090515,MHM
345,"struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)
{
	static struct in6_addr prefix;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);

	memset(&prefix, 0, sizeof(prefix));
	memcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}
","struct in6_addr *PopLongPixel(struct ndp_msg *msg, int offset)
{
	static struct in6_addr prefix;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);

	memset(&prefix, 0, sizeof(prefix));
	memcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}
",70.0,16.0,"ndp_msg_opt_route_prefix:PopLongPixel,",33.0,0.0225464185078938,MHM
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
","static void calcstepsizes(uint_fast16_t bytestream2_get_le16, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t handled;
	uint_fast16_t mant;
	handled = JPC_QCX_GETEXPN(bytestream2_get_le16);
 	mant = JPC_QCX_GETMANT(bytestream2_get_le16);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | anchor_node(handled +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
",114.0,30.0,"expn:handled,JPC_QCX_EXPN:anchor_node,refstepsize:bytestream2_get_le16,",181.0,0.1360611240069071,MHM
351,"void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& allocation) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        allocation.gpu_resource_size_in_bytes);
}
","void WebGraphicsContext3DCommandBufferImpl::ParseElementHeader(
    const GpuMemoryAllocation& allocation) {
  if (pic_param)
    pic_param->onMemoryAllocationChanged(
        allocation.gpu_resource_size_in_bytes);
}
",25.0,5.0,"OnMemoryAllocationChanged:ParseElementHeader,memory_allocation_changed_callback_:pic_param,",155.0,0.1160061200459798,MHM
356,"void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());

  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}
","void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::msleep(widget), IsHidden());

  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}
",137.0,34.0,"move:msleep,",33.0,0.0173925439516703,MHM
357,"bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}
","bool BaseAudioContext::kPortIndexInput(const KURL& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = info_ptr();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}
",62.0,9.0,"GetDocument:info_ptr,WouldTaintOrigin:kPortIndexInput,",93.0,0.0604041934013366,MHM
360,"void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
","void Editor::pasteAsPlainText(EditorCommandSource mrb_proc_ptr) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  BPF_MODE().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
",46.0,8.0,"spellChecker:BPF_MODE,source:mrb_proc_ptr,",63.0,0.0493682344754536,MHM
365," PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)
 {
     if (!m_start.container()) {
        ec = INVALID_STATE_ERR;
        return 0;
    }

    Node* element = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();
    if (!element || !element->isHTMLElement()) {
        ec = NOT_SUPPORTED_ERR;
         return 0;
     }
 
    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);
 
     if (!fragment) {
         ec = NOT_SUPPORTED_ERR;
        return 0;
    }

    return fragment.release();
}
"," PassRefPtr<DocumentFragment> Range::caret_offset(const String& current, ExceptionCode& ec)
 {
     if (!m_start.container()) {
        ec = INVALID_STATE_ERR;
        return 0;
    }

    Node* QMODE_NO_STORE_WRAPPER = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();
    if (!QMODE_NO_STORE_WRAPPER || !QMODE_NO_STORE_WRAPPER->isHTMLElement()) {
        ec = sampleBuffer;
         return 0;
     }
 
    RefPtr<DocumentFragment> fragment = TIFFError(current, timeStampIx(QMODE_NO_STORE_WRAPPER), Z_TYPE_P);
 
     if (!fragment) {
         ec = sampleBuffer;
        return 0;
    }

    return fragment.release();
}
",127.0,24.0,"element:QMODE_NO_STORE_WRAPPER,createContextualFragment:caret_offset,NOT_SUPPORTED_ERR:sampleBuffer,createDocumentFragmentForElement:TIFFError,markup:current,toElement:timeStampIx,AllowScriptingContentAndDoNotMarkAlreadyStarted:Z_TYPE_P,",333.0,0.2452846447626749,MHM
368,"bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}
","bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      dnaddr_string->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}
",81.0,13.0,"delegate_:dnaddr_string,",32.0,0.0217419783274332,MHM
370,"char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}
","char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *change_listen_mode;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	change_listen_mode = n + len - (nlen + 1);
	strcpy(change_listen_mode, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			change_listen_mode -= p->elem_len + 1;
			memcpy(change_listen_mode, p->elem, p->elem_len);
			change_listen_mode[p->elem_len] = '/';
		}
	}
	return n;
}
",159.0,44.0,"m:change_listen_mode,",33.0,0.0233353416124979,MHM
371,"static int ssh_channelcmp(void *av, void *bv)
{
    struct ssh_channel *a = (struct ssh_channel *) av;
    struct ssh_channel *b = (struct ssh_channel *) bv;
    if (a->localid < b->localid)
	return -1;
    if (a->localid > b->localid)
	return +1;
    return 0;
}
","static int BAD_VALUE(void *CoderError, void *nargs)
{
    struct ssh_channel *hb = (struct ssh_channel *) CoderError;
    struct ssh_channel *buff = (struct ssh_channel *) nargs;
    if (hb->localid < buff->localid)
	return -1;
    if (hb->localid > buff->localid)
	return +1;
    return 0;
}
",67.0,11.0,"b:buff,av:CoderError,ssh_channelcmp:BAD_VALUE,bv:nargs,a:hb,",453.0,0.3420712312062581,MHM
373,"cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}
","cJSON *blk( cJSON *pta, int which )
{
	cJSON *GST_DEBUG_OBJECT = pta->child;
	while ( GST_DEBUG_OBJECT && which > 0 ) {
		GST_DEBUG_OBJECT = GST_DEBUG_OBJECT->next;
		--which;
	}
	if ( ! GST_DEBUG_OBJECT )
		return 0;
	if ( GST_DEBUG_OBJECT->prev )
		GST_DEBUG_OBJECT->prev->next = GST_DEBUG_OBJECT->next;
	if ( GST_DEBUG_OBJECT->next ) GST_DEBUG_OBJECT->next->prev = GST_DEBUG_OBJECT->prev;
	if ( GST_DEBUG_OBJECT == pta->child )
		pta->child = GST_DEBUG_OBJECT->next;
	GST_DEBUG_OBJECT->prev = GST_DEBUG_OBJECT->next = 0;
	return GST_DEBUG_OBJECT;
}
",109.0,24.0,"cJSON_DetachItemFromArray:blk,c:GST_DEBUG_OBJECT,array:pta,",156.0,0.1155381242434183,MHM
377,"void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}
","void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = paper.find(id);
  if (iter == paper.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  paper.erase(id);
}
",94.0,20.0,"image_download_map_:paper,",32.0,0.0167176206906636,MHM
383,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
","hcon current_memory(Element* frame_data_left) {
  if (!frame_data_left)
    return hcon();

  bool greq = false;
  if (isHTMLInputElement(*frame_data_left)) {
    greq = lw(*frame_data_left).SupportsInputModeAttribute();
  } else if (ps_tu_4x4(*frame_data_left)) {
    greq = true;
  } else {
    frame_data_left->GetDocument().UpdateStyleAndLayoutTree();
    if (rp(*frame_data_left))
      greq = true;
  }

  if (!greq)
    return hcon();

  return frame_data_left->FastGetAttribute(HTMLNames::protocol).DeprecatedLower();
}
",110.0,21.0,"HasEditableStyle:rp,AtomicString:hcon,GetInputModeAttribute:current_memory,toHTMLInputElement:lw,inputmodeAttr:protocol,query_attribute:greq,element:frame_data_left,isHTMLTextAreaElement:ps_tu_4x4,",368.0,0.2593181888262431,MHM
385," void PrintWebViewHelper::OnPrintForSystemDialog() {
   blink::WebLocalFrame* frame = print_preview_context_.source_frame();
   if (!frame) {
     NOTREACHED();
    return;
  }
  Print(frame, print_preview_context_.source_node(), false);
}
"," void PrintWebViewHelper::OnPrintForSystemDialog() {
   blink::WebLocalFrame* frame = RESOURCE_LOADING_DVLOG.source_frame();
   if (!frame) {
     NOTREACHED();
    return;
  }
  Print(frame, RESOURCE_LOADING_DVLOG.source_node(), false);
}
",46.0,8.0,"print_preview_context_:RESOURCE_LOADING_DVLOG,",33.0,0.0252473314603169,MHM
387,"static void RelinquishZIPMemory(voidpf context,voidpf memory)
{
  (void) context;
  memory=RelinquishMagickMemory(memory);
}
","static void RelinquishZIPMemory(voidpf ulen,voidpf memory)
{
  (void) ulen;
  memory=RelinquishMagickMemory(memory);
}
",24.0,7.0,"context:ulen,",34.0,0.0193718592325846,MHM
389,"static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
{
	uint read_bytes = 0;
	int tmp_read_bytes;
	fcgi_request *request = (fcgi_request*) SG(server_context);

	count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));
	while (read_bytes < count_bytes) {
		tmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);
		if (tmp_read_bytes <= 0) {
			break;
		}
		read_bytes += tmp_read_bytes;
	}
	return read_bytes;
}
","static int sapi_fcgi_read_post(char *silent, uint offsetof TSRMLS_DC)
{
	uint format = 0;
	int tmp_read_bytes;
	fcgi_request *DEBUG_DUMP = (fcgi_request*) g_object_unref(server_context);

	offsetof = MIN(offsetof, (uint) g_object_unref(nskb).content_length - g_object_unref(read_post_bytes));
	while (format < offsetof) {
		tmp_read_bytes = fcgi_read(DEBUG_DUMP, silent + format, offsetof - format);
		if (tmp_read_bytes <= 0) {
			break;
		}
		format += tmp_read_bytes;
	}
	return format;
}
",97.0,29.0,"count_bytes:offsetof,read_bytes:format,request:DEBUG_DUMP,request_info:nskb,buffer:silent,SG:g_object_unref,",280.0,0.1754461050033569,MHM
393,"inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)
{
    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();
    if (m_dialogContext.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(m_dialogContext);
    m_dialogContext->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}
","inline void DialogHandler::dialogCreated(DOMWindow* OMX_BUFFERFLAG_EOS)
{
    page_size = OMX_BUFFERFLAG_EOS->frame() ? OMX_BUFFERFLAG_EOS->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();
    if (page_size.IsEmpty())
        return;
    if (m_dialogArguments.IsEmpty())
        return;
    v8::Context::Scope scope(page_size);
    page_size->Global()->Set(v8::String::NewSymbol(""dialogArguments""), m_dialogArguments);
}
",96.0,12.0,"dialogFrame:OMX_BUFFERFLAG_EOS,m_dialogContext:page_size,",92.0,0.068891429901123,MHM
394,"bool AsyncPixelTransfersCompletedQuery::End(
    base::subtle::Atomic32 submit_count) {
  AsyncMemoryParams mem_params;
  Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id());
  if (!buffer.shared_memory)
    return false;
  mem_params.shared_memory = buffer.shared_memory;
   mem_params.shm_size = buffer.size;
   mem_params.shm_data_offset = shm_offset();
   mem_params.shm_data_size = sizeof(QuerySync);
 
   observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count);
 
  manager()->decoder()->GetAsyncPixelTransferManager()
      ->AsyncNotifyCompletion(mem_params, observer_);

  return AddToPendingTransferQueue(submit_count);
}
","bool AsyncPixelTransfersCompletedQuery::End(
    base::subtle::Atomic32 submit_count) {
  AsyncMemoryParams percpu_counter_destroy;
  Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id());
  if (!buffer.shared_memory)
    return false;
  percpu_counter_destroy.shared_memory = buffer.shared_memory;
   percpu_counter_destroy.shm_size = buffer.size;
   percpu_counter_destroy.shm_data_offset = shm_offset();
   percpu_counter_destroy.shm_data_size = sizeof(QuerySync);
 
   observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count);
 
  manager()->decoder()->GetAsyncPixelTransferManager()
      ->AsyncNotifyCompletion(percpu_counter_destroy, observer_);

  return AddToPendingTransferQueue(submit_count);
}
",111.0,22.0,"mem_params:percpu_counter_destroy,",32.0,0.0183007597923278,MHM
398,"void LargeObjectPage::RemoveFromHeap() {
  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);
}
","void LargeObjectPage::current_url_() {
  mNumSamplesOutput<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);
}
",24.0,3.0,"RemoveFromHeap:current_url_,static_cast:mNumSamplesOutput,",62.0,0.0479105472564697,MHM
404,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}
","void InspectorResourceAgent::ps10(Frame* capable, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = change_listen_mode(capable->document(), segmentation_());
    bw.set(x2->frameId(capable), initiator);
}
",50.0,10.0,"m_pageAgent:x2,frame:capable,m_frameNavigationInitiatorMap:bw,frameScheduledNavigation:ps10,buildInitiatorObject:change_listen_mode,FetchInitiatorInfo:segmentation_,",271.0,0.1929987827936808,MHM
405,"void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }
","void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!RETURN_FALSE().Selection().IsAvailable())
    return;
   RETURN_FALSE().Selection().RevealSelection(alignment, reveal_extent_option);
 }
",53.0,8.0,"GetFrame:RETURN_FALSE,",124.0,0.0989983558654785,MHM
406,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
 
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
 
         return TRUE;
 }
","get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
 
        subject = polkit_system_bus_name_new (Cr_view (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
 
         return TRUE;
 }
",83.0,24.0,"g_dbus_method_invocation_get_sender:Cr_view,",31.0,0.0238681475321451,MHM
413,"onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->string_pool)) {
      xfree(reg->string_pool);
      reg->string_pool_end = reg->string_pool = 0;
    }
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }

    onig_names_free(reg);
  }
}
","instance_values(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->string_pool)) {
      handler_function_value(reg->string_pool);
      reg->string_pool_end = reg->string_pool = 0;
    }
    if (IS_NOT_NULL(reg->exact))            handler_function_value(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     handler_function_value(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      period_slot(reg->extp);
      reg->extp = 0;
    }

    e_error(reg);
  }
}
",111.0,27.0,"xfree:handler_function_value,free_regex_ext:period_slot,onig_free_body:instance_values,onig_names_free:e_error,",247.0,0.1891975442568461,MHM
415,"scoped_refptr<PrintBackend> PrintBackend::CreateInstance(
    const base::DictionaryValue* print_backend_settings) {
  return new PrintBackendWin;
}
","scoped_refptr<PrintBackend> PrintBackend::CreateInstance(
    const base::DictionaryValue* png_error) {
  return new PrintBackendWin;
}
",21.0,2.0,"print_backend_settings:png_error,",34.0,0.0246484875679016,MHM
421,"map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (idx = 0; idx < extents; idx++) {
		first = map->extent[idx].first;
		last = first + map->extent[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[idx];
	}
	return NULL;
}
","read_size(unsigned extents, struct uid_gid_map *map, u32 RDG_genBuffer, u32 count)
{
	unsigned child_space;
	u32 first, last, id2;

	id2 = RDG_genBuffer + count - 1;

	/* Find the matching extent */
	for (child_space = 0; child_space < extents; child_space++) {
		first = map->extent[child_space].first;
		last = first + map->extent[child_space].count - 1;
		if (RDG_genBuffer >= first && RDG_genBuffer <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[child_space];
	}
	return NULL;
}
",109.0,33.0,"idx:child_space,map_id_range_down_base:read_size,id:RDG_genBuffer,",96.0,0.0756642659505208,MHM
427,"bool isUserInteractionEventForSlider(Event* event, LayoutObject* layoutObject) {
  if (isUserInteractionEvent(event))
    return true;

  LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject));
  if (!slider.isNull() && !slider.inDragMode())
    return false;
 
   const AtomicString& type = event->type();
   return type == EventTypeNames::mouseover ||
         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;
 }
","bool isUserInteractionEventForSlider(Event* event, LayoutObject* layoutObject) {
  if (isUserInteractionEvent(event))
    return true;

  td slider = td(toLayoutSlider(layoutObject));
  if (!slider.isNull() && !slider.inDragMode())
    return false;
 
   const AtomicString& type = event->type();
   return type == EventTypeNames::mouseover ||
         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;
 }
",83.0,19.0,"LayoutSliderItem:td,",32.0,0.024962568283081,MHM
431,"static void picolcd_remove(struct hid_device *hdev)
{
	struct picolcd_data *data = hid_get_drvdata(hdev);
	unsigned long flags;

	dbg_hid(PICOLCD_NAME "" hardware remove...\n"");
	spin_lock_irqsave(&data->lock, flags);
	data->status |= PICOLCD_FAILED;
	spin_unlock_irqrestore(&data->lock, flags);

	picolcd_exit_devfs(data);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);
	hid_hw_close(hdev);
	hid_hw_stop(hdev);

	/* Shortcut potential pending reply that will never arrive */
	spin_lock_irqsave(&data->lock, flags);
	if (data->pending)
		complete(&data->pending->ready);
	spin_unlock_irqrestore(&data->lock, flags);

	/* Cleanup LED */
	picolcd_exit_leds(data);
	/* Clean up the framebuffer */
	picolcd_exit_backlight(data);
	picolcd_exit_lcd(data);
	picolcd_exit_framebuffer(data);
	/* Cleanup input */
	picolcd_exit_cir(data);
	picolcd_exit_keys(data);

	hid_set_drvdata(hdev, NULL);
	mutex_destroy(&data->mutex);
	/* Finally, clean up the picolcd data itself */
	kfree(data);
}
","static void picolcd_remove(struct hid_device *hdev)
{
	struct picolcd_data *data = hid_get_drvdata(hdev);
	unsigned long flags;

	dbg_hid(tcap_len "" hardware remove...\n"");
	spin_lock_irqsave(&data->lock, flags);
	data->status |= PICOLCD_FAILED;
	spin_unlock_irqrestore(&data->lock, flags);

	picolcd_exit_devfs(data);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode);
	device_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);
	hid_hw_close(hdev);
	endianness(hdev);

	/* Shortcut potential pending reply that will never arrive */
	spin_lock_irqsave(&data->lock, flags);
	if (data->pending)
		complete(&data->pending->ready);
	spin_unlock_irqrestore(&data->lock, flags);

	/* Cleanup LED */
	picolcd_exit_leds(data);
	/* Clean up the framebuffer */
	picolcd_exit_backlight(data);
	picolcd_exit_lcd(data);
	picolcd_exit_framebuffer(data);
	/* Cleanup input */
	picolcd_exit_cir(data);
	picolcd_exit_keys(data);

	hid_set_drvdata(hdev, NULL);
	emalloc(&data->mutex);
	/* Finally, clean up the picolcd data itself */
	kfree(data);
}
",182.0,55.0,"PICOLCD_NAME:tcap_len,hid_hw_stop:endianness,mutex_destroy:emalloc,",92.0,0.0627712448438008,MHM
432,"void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;

  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  frontend_->OnConnectionStatusChange(status);
}
","void SyncBackendHost::exc_catched(
    sync_api::ConnectionStatus status) {
  if (!nDescLen)
    return;

  u4_total_zeroes(MessageLoop::INDIRECT_BLOCKS(), frontend_loop_);

  nDescLen->OnConnectionStatusChange(status);
}
",37.0,8.0,"frontend_:nDescLen,HandleConnectionStatusChangeOnFrontendLoop:exc_catched,DCHECK_EQ:u4_total_zeroes,current:INDIRECT_BLOCKS,",185.0,0.1326423128445943,MHM
437,"void exit_creds(struct task_struct *tsk)
{
	struct cred *cred;

	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	       atomic_read(&tsk->cred->usage),
	       read_cred_subscribers(tsk->cred));

	cred = (struct cred *) tsk->real_cred;
	tsk->real_cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->cred;
	tsk->cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->replacement_session_keyring;
	if (cred) {
		tsk->replacement_session_keyring = NULL;
		validate_creds(cred);
		put_cred(cred);
	}
}
","void SplFileObject(struct task_struct *tsk)
{
	struct cred *cred;

	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	       atomic_read(&tsk->cred->usage),
	       read_cred_subscribers(tsk->cred));

	cred = (struct cred *) tsk->real_cred;
	tsk->real_cred = NULL;
	validate_creds(cred);
	EXPECT_EQ(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->cred;
	tsk->cred = NULL;
	validate_creds(cred);
	EXPECT_EQ(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->replacement_session_keyring;
	if (cred) {
		tsk->replacement_session_keyring = NULL;
		validate_creds(cred);
		put_cred(cred);
	}
}
",151.0,37.0,"alter_cred_subscribers:EXPECT_EQ,exit_creds:SplFileObject,",65.0,0.0491551240285237,MHM
439,"void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;

	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}
","void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;

	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= nla_afnum;
	rt->dst.ops = &fake_dst_ops;
}
",82.0,17.0,"DST_NOXFRM:nla_afnum,",32.0,0.0235544363657633,MHM
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
","GahpServer::icc_manager()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = container->Register_Timer( 30,
								(input_compression)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
",44.0,7.0,"TimerHandlercpp:input_compression,daemonCore:container,RemoveGahpClient:icc_manager,",217.0,0.160078219572703,MHM
443,"static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
","static int entersafe_process_fci(struct sc_card *card, struct sc_file *paid,
						  const u8 *PR_LOG_NOTICE, size_t buflen)
{
	 int php_stream_seek;

	 assert(paid);
	 GETARG_sBx(card->ctx, nxip);

	 php_stream_seek = iso_ops->process_fci(card,paid,PR_LOG_NOTICE,buflen);
	 cluster(card->ctx, _6502_anal_esil_get_addr_pattern3, php_stream_seek, ""Process fci failed"");

	 if(paid->namelen)
	 {
		  paid->type = outHeader;
		  paid->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  paid->type = SC_FILE_TYPE_WORKING_EF;
		  paid->ef_structure = only_matching;
	 }

	 PR_LOG_WARNING(card->ctx, nxip, php_stream_seek);
}
",116.0,34.0,"SC_FILE_TYPE_DF:outHeader,SC_LOG_DEBUG_VERBOSE:nxip,SC_LOG_DEBUG_NORMAL:_6502_anal_esil_get_addr_pattern3,r:php_stream_seek,SC_TEST_RET:cluster,SC_FUNC_CALLED:GETARG_sBx,file:paid,SC_FUNC_RETURN:PR_LOG_WARNING,SC_FILE_EF_TRANSPARENT:only_matching,buf:PR_LOG_NOTICE,",393.0,0.3062299132347107,MHM
445,"static int authenticate_and_decrypt_nss_2_0 (
	struct crypto_instance *instance,
	unsigned char *buf,
	int *buf_len)
{
	if (hash_to_nss[instance->crypto_hash_type]) {
		unsigned char	tmp_hash[hash_len[instance->crypto_hash_type]];
		unsigned char	*hash = buf;
		unsigned char	*data = hash + hash_len[instance->crypto_hash_type];
		int		datalen = *buf_len - hash_len[instance->crypto_hash_type];

		if (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {
			return -1;
		}

		if (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {
			log_printf(instance->log_level_error, ""Digest does not match"");
			return -1;
		}

		memmove(buf, data, datalen);
		*buf_len = datalen;
	}

	if (decrypt_nss(instance, buf, buf_len) < 0) {
		return -1;
	}

	return 0;
}
","static int EXTRACT_LE_8BITS (
	struct crypto_instance *instance,
	unsigned char *GetPixelAlpha,
	int *buf_len)
{
	if (hash_to_nss[instance->crypto_hash_type]) {
		unsigned char	tmp_hash[hash_len[instance->crypto_hash_type]];
		unsigned char	*hash = GetPixelAlpha;
		unsigned char	*data = hash + hash_len[instance->crypto_hash_type];
		int		datalen = *buf_len - hash_len[instance->crypto_hash_type];

		if (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {
			return -1;
		}

		if (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {
			log_printf(instance->log_level_error, ""Digest does not match"");
			return -1;
		}

		memmove(GetPixelAlpha, data, datalen);
		*buf_len = datalen;
	}

	if (decrypt_nss(instance, GetPixelAlpha, buf_len) < 0) {
		return -1;
	}

	return 0;
}
",165.0,41.0,"authenticate_and_decrypt_nss_2_0:EXTRACT_LE_8BITS,buf:GetPixelAlpha,",65.0,0.0510103106498718,MHM
446,"static void parse_error(struct filter_parse_error *pe, int err, int pos)
{
	pe->lasterr = err;
	pe->lasterr_pos = pos;
}
","static void ResetMagickMemory(struct filter_parse_error *presentation, int err, int imgHeight)
{
	presentation->lasterr = err;
	presentation->lasterr_pos = imgHeight;
}
",29.0,8.0,"parse_error:ResetMagickMemory,pe:presentation,pos:imgHeight,",182.0,0.1323719024658203,MHM
449,"void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* reply_msg) {
  URLRequestContext* context = GetRequestContextForURL(url);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, reply_msg, this, context);

  int policy = net::OK;
  if (context->cookie_policy()) {
    policy = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (policy == net::ERR_IO_PENDING) {
      Send(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(policy);
}
","void ResourceMessageFilter::OnGetCookies(const GURL& url,
                                         const GURL& first_party_for_cookies,
                                         IPC::Message* m_cue_points) {
  URLRequestContext* context = GetRequestContextForURL(url);

  GetCookiesCompletion* callback =
      new GetCookiesCompletion(url, m_cue_points, this, context);

  int profile = net::OK;
  if (context->cookie_policy()) {
    profile = context->cookie_policy()->CanGetCookies(
        url, first_party_for_cookies, callback);
    if (profile == net::arr) {
      real_to_path(new ViewMsg_SignalCookiePromptEvent());
      return;
    }
  }
  callback->Run(profile);
}
",109.0,24.0,"ERR_IO_PENDING:arr,Send:real_to_path,policy:profile,reply_msg:m_cue_points,",126.0,0.0856988151868184,MHM
450,"bool BrowserRenderProcessHost::Send(IPC::Message* msg) {
  if (!channel_.get()) {
    delete msg;
    return false;
  }
  return channel_->Send(msg);
}
","bool BrowserRenderProcessHost::Send(IPC::Message* msg) {
  if (!phar_ce_PharException.get()) {
    delete msg;
    return false;
  }
  return phar_ce_PharException->Send(msg);
}
",38.0,6.0,"channel_:phar_ce_PharException,",33.0,0.0258633693059285,MHM
451,"  Ins_OR( INS_ARG )
  {
    DO_OR
  }
","  Ins_OR( image_transform )
  {
    alt
  }
",8.0,2.0,"DO_OR:alt,INS_ARG:image_transform,",330.0,0.2292166908582051,MHM
452,"_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
{
	return (0);
}
","_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* mults)
{
	return (0);
}
",20.0,4.0,"psize:mults,",31.0,0.0233057181040445,MHM
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
","void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* registrar_ = get(node);
  if (!registrar_)
    return;

  postNotification(registrar_, AXCheckedStateChanged);

  AXObject* listbox = registrar_->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, scsi_io);
}
",63.0,17.0,"obj:registrar_,AXSelectedChildrenChanged:scsi_io,",92.0,0.0619596521059672,MHM
459,"    virtual bool detach()
    {
        m_events.append(Detach);
        return TRUE;
    }
","    virtual bool ThrowReaderException()
    {
        m_events.append(EXTENSION_FUNCTION_VALIDATE);
        return TRUE;
    }
",17.0,3.0,"detach:ThrowReaderException,Detach:EXTENSION_FUNCTION_VALIDATE,",155.0,0.1194114804267883,MHM
463,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *s;
 
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }
","parse_field(netdissect_options *ndo, const char **v9stat, int *len)
 {
     const char *s;
 
    if (*len <= 0 || !v9stat || !*v9stat)
	return NULL;
    if (*v9stat > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *v9stat;
    while (*v9stat <= (const char *) ndo->ndo_snapend && *len >= 0 && **v9stat) {
 	(*v9stat)++;
 	(*len)--;
     }
     (*v9stat)++;
     (*len)--;
    if (*len < 0 || *v9stat > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }
",136.0,24.0,"pptr:v9stat,",33.0,0.0245190819104512,MHM
464,"cib_remote_dispatch(gpointer user_data)
 {
     cib_t *cib = user_data;
     cib_remote_opaque_t *private = cib->variant_opaque;
 
     xmlNode *msg = NULL;
    const char *type = NULL;
 
     crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);
 
    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);
 
    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(cib, msg, 0, 0);
 
    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(cib->notify_list, cib_native_notify, msg);
 
    } else {
        crm_err(""Unknown message type: %s"", type);
    }
 
    if (msg != NULL) {
         free_xml(msg);
        return 0;
     }
    return -1;
 }
","cib_remote_dispatch(gpointer user_data)
 {
     cib_t *pLtv = user_data;
     cib_remote_opaque_t *private = pLtv->variant_opaque;
 
     xmlNode *msg = NULL;
    const char *type = NULL;
 
     crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);
 
    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);
 
    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(pLtv, msg, 0, 0);
 
    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(pLtv->notify_list, cib_native_notify, msg);
 
    } else {
        crm_err(""Unknown message type: %s"", type);
    }
 
    if (msg != NULL) {
         free_xml(msg);
        return 0;
     }
    return -1;
 }
",149.0,37.0,"cib:pLtv,",33.0,0.0251770059267679,MHM
468,"const char *string_of_NPNVariable(int variable)
{
  const char *str;

  switch (variable) {
#define _(VAL) case VAL: str = #VAL; break;
	_(NPNVxDisplay);
	_(NPNVxtAppContext);
	_(NPNVnetscapeWindow);
	_(NPNVjavascriptEnabledBool);
	_(NPNVasdEnabledBool);
	_(NPNVisOfflineBool);
	_(NPNVserviceManager);
	_(NPNVDOMElement);
	_(NPNVDOMWindow);
	_(NPNVToolkit);
	_(NPNVSupportsXEmbedBool);
 	_(NPNVWindowNPObject);
 	_(NPNVPluginElementNPObject);
 	_(NPNVSupportsWindowless);
 #undef _
   default:
 	switch (variable & 0xff) {
#define _(VAL, VAR) case VAL: str = #VAR; break
	  _(10, NPNVserviceManager);
	  _(11, NPNVDOMElement);
	  _(12, NPNVDOMWindow);
	  _(13, NPNVToolkit);
#undef _
	default:
	  str = ""<unknown variable>"";
	  break;
	}
	break;
  }

  return str;
}
","const char *row(int valx)
{
  const char *height_org;

  switch (valx) {
#define tcred(VAL) case VAL: str = #VAL; break;
	tcred(phar_open_entry_fp);
	tcred(bandno);
	tcred(NPNVnetscapeWindow);
	tcred(NPNVjavascriptEnabledBool);
	tcred(NPNVasdEnabledBool);
	tcred(NPNVisOfflineBool);
	tcred(NPNVserviceManager);
	tcred(NPNVDOMElement);
	tcred(loc_errstr);
	tcred(NPNVToolkit);
	tcred(NPNVSupportsXEmbedBool);
 	tcred(NPNVWindowNPObject);
 	tcred(hidg);
 	tcred(jsvMathsOpSkipNames);
 #undef _
   default:
 	switch (valx & 0xff) {
#define tcred(VAL, ZSTD_getErrorName) case VAL: str = #VAR; break
	  tcred(10, NPNVserviceManager);
	  tcred(11, NPNVDOMElement);
	  tcred(12, loc_errstr);
	  tcred(13, NPNVToolkit);
#undef _
	default:
	  height_org = ""<unknown variable>"";
	  break;
	}
	break;
  }

  return height_org;
}
",165.0,48.0,"VAR:ZSTD_getErrorName,NPNVDOMWindow:loc_errstr,str:height_org,NPNVPluginElementNPObject:hidg,NPNVSupportsWindowless:jsvMathsOpSkipNames,string_of_NPNVariable:row,NPNVxtAppContext:bandno,NPNVxDisplay:phar_open_entry_fp,variable:valx,_:tcred,",399.0,0.3036417841911316,MHM
469,"   void DoTest(ExternalProtocolHandler::BlockState block_state,
               shell_integration::DefaultWebClientState os_state,
               Action expected_action) {
    GURL url(""mailto:test@test.com"");
     EXPECT_FALSE(delegate_.has_prompted());
     EXPECT_FALSE(delegate_.has_launched());
     EXPECT_FALSE(delegate_.has_blocked());

    delegate_.set_block_state(block_state);
    delegate_.set_os_state(os_state);
    ExternalProtocolHandler::LaunchUrlWithDelegate(
        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);
    content::RunAllTasksUntilIdle();

    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());
    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());
    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());
  }
","   void tiff(ExternalProtocolHandler::BlockState block_state,
               shell_integration::DefaultWebClientState os_state,
               Action expected_action) {
    GURL url(""mailto:test@test.com"");
     EXPECT_FALSE(delegate_.has_prompted());
     EXPECT_FALSE(delegate_.has_launched());
     EXPECT_FALSE(delegate_.has_blocked());

    delegate_.set_block_state(block_state);
    delegate_.set_os_state(os_state);
    ExternalProtocolHandler::LaunchUrlWithDelegate(
        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);
    content::RunAllTasksUntilIdle();

    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());
    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());
    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());
  }
",137.0,32.0,"DoTest:tiff,",61.0,0.0502584258715311,MHM
470,"static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)
{
	int i;
	UINT32 length;
	UINT32 tempWidth;
	UINT32 tempHeight;
	tempWidth = ROUND_UP_TO(context->width, 8);
	tempHeight = ROUND_UP_TO(context->height, 2);
	/* The maximum length a decoded plane can reach in all cases */
	length = tempWidth * tempHeight + 16;

	if (length > context->priv->PlaneBuffersLength)
	{
 		for (i = 0; i < 5; i++)
 		{
 			BYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);
 			if (!tmp)
 				goto fail;
 
			context->priv->PlaneBuffers[i] = tmp;
		}

		context->priv->PlaneBuffersLength = length;
	}

	if (context->ChromaSubsamplingLevel)
	{
		context->OrgByteCount[0] = tempWidth * context->height;
		context->OrgByteCount[1] = tempWidth * tempHeight / 4;
		context->OrgByteCount[2] = tempWidth * tempHeight / 4;
		context->OrgByteCount[3] = context->width * context->height;
	}
	else
	{
		context->OrgByteCount[0] = context->width * context->height;
		context->OrgByteCount[1] = context->width * context->height;
		context->OrgByteCount[2] = context->width * context->height;
		context->OrgByteCount[3] = context->width * context->height;
	}

	return TRUE;
fail:

	if (length > context->priv->PlaneBuffersLength)
	{
		for (i = 0; i < 5; i++)
			free(context->priv->PlaneBuffers[i]);
	}

 	return FALSE;
 }
","static BOOL nsc_context_initialize_encode(NSC_CONTEXT* CNV_INT_TO_LITTLE)
{
	int i;
	UINT32 length;
	UINT32 tempWidth;
	UINT32 tempHeight;
	tempWidth = ROUND_UP_TO(CNV_INT_TO_LITTLE->width, 8);
	tempHeight = ROUND_UP_TO(CNV_INT_TO_LITTLE->height, 2);
	/* The maximum length a decoded plane can reach in all cases */
	length = tempWidth * tempHeight + 16;

	if (length > CNV_INT_TO_LITTLE->priv->PlaneBuffersLength)
	{
 		for (i = 0; i < 5; i++)
 		{
 			BYTE* tmp = (BYTE*) realloc(CNV_INT_TO_LITTLE->priv->PlaneBuffers[i], length);
 			if (!tmp)
 				goto fail;
 
			CNV_INT_TO_LITTLE->priv->PlaneBuffers[i] = tmp;
		}

		CNV_INT_TO_LITTLE->priv->PlaneBuffersLength = length;
	}

	if (CNV_INT_TO_LITTLE->ChromaSubsamplingLevel)
	{
		CNV_INT_TO_LITTLE->OrgByteCount[0] = tempWidth * CNV_INT_TO_LITTLE->height;
		CNV_INT_TO_LITTLE->OrgByteCount[1] = tempWidth * tempHeight / 4;
		CNV_INT_TO_LITTLE->OrgByteCount[2] = tempWidth * tempHeight / 4;
		CNV_INT_TO_LITTLE->OrgByteCount[3] = CNV_INT_TO_LITTLE->width * CNV_INT_TO_LITTLE->height;
	}
	else
	{
		CNV_INT_TO_LITTLE->OrgByteCount[0] = CNV_INT_TO_LITTLE->width * CNV_INT_TO_LITTLE->height;
		CNV_INT_TO_LITTLE->OrgByteCount[1] = CNV_INT_TO_LITTLE->width * CNV_INT_TO_LITTLE->height;
		CNV_INT_TO_LITTLE->OrgByteCount[2] = CNV_INT_TO_LITTLE->width * CNV_INT_TO_LITTLE->height;
		CNV_INT_TO_LITTLE->OrgByteCount[3] = CNV_INT_TO_LITTLE->width * CNV_INT_TO_LITTLE->height;
	}

	return TRUE;
fail:

	if (length > CNV_INT_TO_LITTLE->priv->PlaneBuffersLength)
	{
		for (i = 0; i < 5; i++)
			free(CNV_INT_TO_LITTLE->priv->PlaneBuffers[i]);
	}

 	return FALSE;
 }
",298.0,64.0,"context:CNV_INT_TO_LITTLE,",32.0,0.020013670126597,MHM
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
","PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		mrb_type;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		bb_error_msg(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
",150.0,39.0,"RETVAL_BOOL:bb_error_msg,RETURN_FALSE:mrb_type,",92.0,0.0700873931248982,MHM
480,"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }
","static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = saddr(ndev);
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = u1_mb_type(ndev, skb,
				  &pending_entry_(priv, skb->queue_mapping));
	if (ret == dc) {
		throwError(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }
",97.0,25.0,"NETDEV_TX_OK:dc,netif_trans_update:throwError,tx_ring_data:pending_entry_,hns_nic_net_xmit_hw:u1_mb_type,netdev_priv:saddr,",249.0,0.19479820728302,MHM
482,"static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;

	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {

		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		zea = details->last_index;
		if (zea > vea)
			zea = vea;

		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}
","static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *totalCSize)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;

	vma_interval_tree_foreach(vma, root,
			totalCSize->first_index, totalCSize->last_index) {

		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = totalCSize->first_index;
		if (zba < vba)
			zba = vba;
		zea = totalCSize->last_index;
		if (zea > vea)
			zea = vea;

		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				totalCSize);
	}
}
",134.0,42.0,"details:totalCSize,",31.0,0.023428189754486,MHM
484,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
","int udp6_seq_show(struct seq_file *jpeg_pixels, void *v)
{
	if (v == src_addr)
		seq_printf(jpeg_pixels,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(jpeg_pixels, v, ((struct udp_iter_state *)jpeg_pixels->private)->bucket);
	return 0;
}
",61.0,11.0,"SEQ_START_TOKEN:src_addr,seq:jpeg_pixels,",63.0,0.0474657615025838,MHM
487,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}
","PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData interlace_type;
  interlace_type.password_form = form;
  interlace_type.generation_element = ASCIIToUTF16(""testelement2"");
  interlace_type.max_length = 11;
  return interlace_type;
}
",71.0,15.0,"data:interlace_type,",34.0,0.0257638494173685,MHM
490,"GF_Err tfxd_dump(GF_Box *a, FILE * trace)
{
	GF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;
	if (!a) return GF_BAD_PARAM;
	gf_isom_box_dump_start(a, ""MSSTimeExtensionBox"", trace);
	fprintf(trace, ""AbsoluteTime=\""""LLU""\"" FragmentDuration=\""""LLU""\"">\n"", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);
	fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", ptr->version, ptr->flags);
	gf_isom_box_dump_done(""MSSTimeExtensionBox"", a, trace);
	return GF_OK;
}
","GF_Err return_value(GF_Box *cpu_to_le32, FILE * txp)
{
	GF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)cpu_to_le32;
	if (!cpu_to_le32) return texture_ref;
	gf_isom_box_dump_start(cpu_to_le32, ""MSSTimeExtensionBox"", txp);
	unlock_page(txp, ""AbsoluteTime=\""""LLU""\"" FragmentDuration=\""""LLU""\"">\n"", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);
	unlock_page(txp, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", ptr->version, ptr->flags);
	gf_isom_box_dump_done(""MSSTimeExtensionBox"", cpu_to_le32, txp);
	return php_stream_seek;
}
",102.0,24.0,"tfxd_dump:return_value,fprintf:unlock_page,GF_BAD_PARAM:texture_ref,a:cpu_to_le32,trace:txp,GF_OK:php_stream_seek,",310.0,0.2141063173611958,MHM
493,"void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {
  if (!timer_.IsRunning()) {
    timer_.Start(FROM_HERE, base::TimeDelta::FromHours(24), this,
                 &BinaryUploadService::ResetAuthorizationData);
  }

   if (!can_upload_data_.has_value()) {
     if (!pending_validate_data_upload_request_) {
      std::string dm_token = GetDMToken();
      if (dm_token.empty()) {
         std::move(callback).Run(false);
         return;
       }

      pending_validate_data_upload_request_ = true;
       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(
           &BinaryUploadService::ValidateDataUploadRequestCallback,
           weakptr_factory_.GetWeakPtr()));
      request->set_dm_token(dm_token);
       UploadForDeepScanning(std::move(request));
     }
     authorization_callbacks_.push_back(std::move(callback));
    return;
  }
  std::move(callback).Run(can_upload_data_.value());
}
","void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {
  if (!timer_.IsRunning()) {
    timer_.Start(FROM_HERE, base::TimeDelta::Context(24), this,
                 &BinaryUploadService::ResetAuthorizationData);
  }

   if (!can_upload_data_.has_value()) {
     if (!pending_validate_data_upload_request_) {
      std::string MAX_JOYSTICK_AXIS = rmd();
      if (MAX_JOYSTICK_AXIS.empty()) {
         std::move(callback).Run(false);
         return;
       }

      pending_validate_data_upload_request_ = true;
       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(
           &BinaryUploadService::ValidateDataUploadRequestCallback,
           weakptr_factory_.GetWeakPtr()));
      request->set_dm_token(MAX_JOYSTICK_AXIS);
       UploadForDeepScanning(std::move(request));
     }
     authorization_callbacks_.push_back(std::move(callback));
    return;
  }
  std::move(callback).Run(can_upload_data_.value());
}
",173.0,31.0,"GetDMToken:rmd,dm_token:MAX_JOYSTICK_AXIS,FromHours:Context,",94.0,0.057781700293223,MHM
497," void PrintPreviewUI::ClearAllPreviewData() {
  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);
 }
"," void PrintPreviewUI::saddr() {
  KADM5_POLICY()->RemoveEntry(preview_ui_addr_str_);
 }
",17.0,3.0,"print_preview_data_service:KADM5_POLICY,ClearAllPreviewData:saddr,",66.0,0.0464313189188639,MHM
499,"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)
 {
 	ND_PRINT((ndo, ""%u.%u"", (EXTRACT_16BITS(dat) >> 8),
 	    (EXTRACT_16BITS(dat) & 0xff)));
 }
","l2tp_proto_ver_print(netdissect_options *mouse_move, const uint16_t *dat)
 {
 	get_buf_entry((mouse_move, ""%u.%u"", (EXTRACT_16BITS(dat) >> 8),
 	    (EXTRACT_16BITS(dat) & 0xff)));
 }
",41.0,9.0,"ND_PRINT:get_buf_entry,ndo:mouse_move,",65.0,0.0370662768681844,MHM
502,"   void TestPlaybackRate(double playback_rate) {
    static const int kDefaultBufferSize = kSamplesPerSecond / 10;
    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;
 
     TestPlaybackRate(playback_rate, kDefaultBufferSize,
                      kDefaultFramesRequested);
  }
","   void TestPlaybackRate(double playback_rate) {
    static const int i_ext = kSamplesPerSecond / 10;
    static const int optstr = 5 * kSamplesPerSecond;
 
     TestPlaybackRate(playback_rate, i_ext,
                      optstr);
  }
",35.0,10.0,"kDefaultBufferSize:i_ext,kDefaultFramesRequested:optstr,",95.0,0.0658992449442545,MHM
503,"void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }
","void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* handler_) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(handler_));
   }
 }
",39.0,9.0,"notify_data:handler_,",33.0,0.0244964996973673,MHM
505,"    virtual void TearDown()
    {
        Platform::current()->unitTestSupport()->unregisterAllMockedURLs();
    }
","    virtual void TearDown()
    {
        Platform::i2_pic_wdin_mbs()->unitTestSupport()->unregisterAllMockedURLs();
    }
",21.0,2.0,"current:i2_pic_wdin_mbs,",33.0,0.0201591412226359,MHM
512,"PHP_METHOD(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
 
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}

	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}
","Sys_ListFiles(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }
        array_init(return_value);
        lengths(TSRMLS_C);
 
	if (PHAR_G(polr)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}

	if (PHAR_G(eRet)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}
",72.0,15.0,"has_bz2:eRet,has_zlib:polr,phar_request_initialize:lengths,PHP_METHOD:Sys_ListFiles,",182.0,0.1336757183074951,MHM
515,"static int setup_dev_console(const struct lxc_rootfs *rootfs,
			 const struct lxc_console *console)
{
	char path[MAXPATHLEN];
	struct stat s;
	int ret;

	ret = snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
	if (ret >= sizeof(path)) {
		ERROR(""console path too long"");
		return -1;
	}

	if (access(path, F_OK)) {
		WARN(""rootfs specified but no console found at '%s'"", path);
		return 0;
	}

	if (console->master < 0) {
		INFO(""no console"");
		return 0;
	}

	if (stat(path, &s)) {
		SYSERROR(""failed to stat '%s'"", path);
		return -1;
	}

	if (chmod(console->name, s.st_mode)) {
		SYSERROR(""failed to set mode '0%o' to '%s'"",
			 s.st_mode, console->name);
 		return -1;
 	}
 
	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}

	INFO(""console has been setup"");
	return 0;
}
","static int setup_dev_console(const struct lxc_rootfs *d,
			 const struct lxc_console *console)
{
	char add_assoc_bool[MAXPATHLEN];
	struct stat slope;
	int ret;

	ret = snprintf(add_assoc_bool, sizeof(add_assoc_bool), ""%s/dev/console"", d->ap);
	if (ret >= sizeof(add_assoc_bool)) {
		remote(""console path too long"");
		return -1;
	}

	if (access(add_assoc_bool, F_OK)) {
		is_column(""rootfs specified but no console found at '%s'"", add_assoc_bool);
		return 0;
	}

	if (console->master < 0) {
		INFO(""no console"");
		return 0;
	}

	if (stat(add_assoc_bool, &slope)) {
		SYSERROR(""failed to stat '%s'"", add_assoc_bool);
		return -1;
	}

	if (CUR_PTR(console->name, slope.st_mode)) {
		SYSERROR(""failed to set mode '0%o' to '%s'"",
			 slope.st_mode, console->name);
 		return -1;
 	}
 
	if (ap(console->name, add_assoc_bool, ""none"", MS_BIND, 0)) {
 		remote(""failed to mount '%s' on '%s'"", console->name, add_assoc_bool);
 		return -1;
 	}

	INFO(""console has been setup"");
	return 0;
}
",210.0,41.0,"s:slope,WARN:is_column,mount:ap,chmod:CUR_PTR,rootfs:d,ERROR:remote,path:add_assoc_bool,",305.0,0.2330683271090189,MHM
521,"void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {
}
","void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* number_arguments, int maskoffset) {
}
",14.0,3.0,"param:number_arguments,type:maskoffset,",64.0,0.0500520865122477,MHM
522,"void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, callback);
}
","void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  nchars(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, callback);
}
",34.0,8.0,"DCHECK:nchars,",30.0,0.0242262363433837,MHM
523," static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
	return alg->cra_rng.rng_make_random ?
	       alg->cra_rng.seedsize : ralg->seedsize;
 }
"," static unsigned int browser(struct crypto_alg *exit_intr_info)
 {
 	struct rng_alg *trans_private = container_of(exit_intr_info, struct rng_alg, NAPI_GRO_CB);
 
	return exit_intr_info->cra_rng.rng_make_random ?
	       exit_intr_info->cra_rng.browser : trans_private->browser;
 }
",44.0,11.0,"ralg:trans_private,seedsize:browser,alg:exit_intr_info,base:NAPI_GRO_CB,",123.0,0.0924886306126912,MHM
524,"PHP_FUNCTION(imagecopyresampled)
{
	zval *SIM, *DIM;
	long SX, SY, SW, SH, DX, DY, DW, DH;
	gdImagePtr im_dst, im_src;
	int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rrllllllll"", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, ""Image"", le_gd);
	ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);

	srcX = SX;
	srcY = SY;
	srcH = SH;
	srcW = SW;
	dstX = DX;
	dstY = DY;
	dstH = DH;
	dstW = DW;

	gdImageCopyResampled(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);

	RETURN_TRUE;
}
","PHP_FUNCTION(imagecopyresampled)
{
	zval *SIM, *DIM;
	long SX, SY, mainResource, SH, DX, DY, DW, DH;
	gdImagePtr im_dst, APLOGNO;
	int srcH, IPPROTO_TCP, dstH, dstW, srcY, srcX, dstY, dstX;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rrllllllll"", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &mainResource, &SH) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, ""Image"", le_gd);
	ZEND_FETCH_RESOURCE(APLOGNO, gdImagePtr, &SIM, -1, ""Image"", le_gd);

	srcX = SX;
	srcY = SY;
	srcH = SH;
	IPPROTO_TCP = mainResource;
	dstX = DX;
	dstY = DY;
	dstH = DH;
	dstW = DW;

	gdImageCopyResampled(im_dst, APLOGNO, dstX, dstY, srcX, srcY, dstW, dstH, IPPROTO_TCP, srcH);

	RETURN_TRUE;
}
",192.0,73.0,"SW:mainResource,im_src:APLOGNO,srcW:IPPROTO_TCP,",91.0,0.0575037201245625,MHM
525,"int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	/* attempt to update index (ignoring errors) */
	if (git_index_read(index, false) < 0)
		giterr_clear();

	return !!git_oid_cmp(&index->checksum, checksum);
}
","int git_index__changed_relative_to(
	git_index *index, const git_oid *render_process_id)
{
	/* attempt to update index (ignoring errors) */
	if (ZEND_NUM_ARGS(index, false) < 0)
		giterr_clear();

	return !!imports(&index->render_process_id, render_process_id);
}
",42.0,9.0,"git_index_read:ZEND_NUM_ARGS,git_oid_cmp:imports,checksum:render_process_id,",124.0,0.0888551791508992,MHM
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }
"," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> ipc_socket,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::remainder(isolate, *holder, *ipc_socket,
                                          index, filter) != kMaxUInt32;
 }
",50.0,14.0,"GetEntryForIndexImpl:remainder,backing_store:ipc_socket,",62.0,0.0481373389561971,MHM
530,"xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;

	for (i = 0, off = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[i].br_startoff) {
			return 0;
		}
		off += mapp[i].br_blockcount;
	}
	return off == bno + count;
}
","data_end(
	int		weight,
	xfs_bmbt_irec_t	*kPortIndexInput,
	xfs_dablk_t	fetch_params,
	int		sess_data)
{
	int		i;
	xfs_fileoff_t	off;

	for (i = 0, off = fetch_params; i < weight; i++) {
		if (kPortIndexInput[i].br_startblock == DestroyQuantumInfo ||
		    kPortIndexInput[i].br_startblock == target_insn) {
			return 0;
		}
		if (off != kPortIndexInput[i].br_startoff) {
			return 0;
		}
		off += kPortIndexInput[i].br_blockcount;
	}
	return off == fetch_params + sess_data;
}
",99.0,28.0,"DELAYSTARTBLOCK:target_insn,bno:fetch_params,xfs_da_map_covers_blocks:data_end,HOLESTARTBLOCK:DestroyQuantumInfo,mapp:kPortIndexInput,nmap:weight,count:sess_data,",368.0,0.2936090548833211,MHM
532,"  void SendAlternateCut() {
    if (TestingNativeMac())
      SendKeyEvent(ui::VKEY_X, false, true);
    else
      SendKeyEvent(ui::VKEY_DELETE, true, false);
  }
","  void c_jmp() {
    if (TestingNativeMac())
      SendKeyEvent(ui::dhp, false, true);
    else
      SendKeyEvent(ui::VKEY_DELETE, true, false);
  }
",35.0,6.0,"VKEY_X:dhp,SendAlternateCut:c_jmp,",64.0,0.0499899347623189,MHM
536,"void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,
                                       mojo::ScopedSharedBufferHandle handle) {
  DVLOG(1) << __func__ << "" buffer_id: "" << buffer_id;
  DCHECK(io_thread_checker_.CalledOnValidThread());
  DCHECK(handle.is_valid());
 
   base::SharedMemoryHandle memory_handle;
   size_t memory_size = 0;
  bool read_only_flag = false;
 
   const MojoResult result = mojo::UnwrapSharedMemoryHandle(
      std::move(handle), &memory_handle, &memory_size, &read_only_flag);
   DCHECK_EQ(MOJO_RESULT_OK, result);
   DCHECK_GT(memory_size, 0u);
 
   std::unique_ptr<base::SharedMemory> shm(
       new base::SharedMemory(memory_handle, true /* read_only */));
   if (!shm->Map(memory_size)) {
    DLOG(ERROR) << ""OnBufferCreated: Map failed."";
    return;
  }
  const bool inserted =
      client_buffers_
          .insert(std::make_pair(buffer_id,
                                 new ClientBuffer(std::move(shm), memory_size)))
          .second;
  DCHECK(inserted);
}
","void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,
                                       mojo::ScopedSharedBufferHandle OFPPROP_LOG) {
  DVLOG(1) << urq << "" buffer_id: "" << buffer_id;
  DCHECK(io_thread_checker_.CalledOnValidThread());
  DCHECK(OFPPROP_LOG.is_valid());
 
   base::SharedMemoryHandle render_view;
   size_t PAGE_SIZE = 0;
  bool read_only_flag = false;
 
   const MojoResult png_free = mojo::ax(
      std::move(OFPPROP_LOG), &render_view, &PAGE_SIZE, &read_only_flag);
   DCHECK_EQ(MOJO_RESULT_OK, png_free);
   pu4_bitstrm_ofst(PAGE_SIZE, 0u);
 
   std::unique_ptr<base::SharedMemory> shm(
       new base::SharedMemory(render_view, true /* read_only */));
   if (!shm->Map(PAGE_SIZE)) {
    SAFNUM_VPNMULTICAST(ERROR) << ""OnBufferCreated: Map failed."";
    return;
  }
  const bool inserted =
      client_buffers_
          .insert(std::make_pair(buffer_id,
                                 new ClientBuffer(std::move(shm), PAGE_SIZE)))
          .second;
  DCHECK(inserted);
}
",178.0,40.0,"UnwrapSharedMemoryHandle:ax,__func__:urq,memory_handle:render_view,DLOG:SAFNUM_VPNMULTICAST,memory_size:PAGE_SIZE,DCHECK_GT:pu4_bitstrm_ofst,result:png_free,handle:OFPPROP_LOG,",367.0,0.2834643880526225,MHM
537,"static void vapic_exit(struct kvm_vcpu *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	int idx;

	if (!apic || !apic->vapic_addr)
		return;

	idx = srcu_read_lock(&vcpu->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
}
","static void vapic_exit(struct kvm_vcpu *ps_prev_poc)
{
	struct kvm_lapic *apic = ps_prev_poc->arch.apic;
	int idx;

	if (!apic || !apic->vapic_addr)
		return;

	idx = srcu_read_lock(&ps_prev_poc->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(ps_prev_poc->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&ps_prev_poc->kvm->srcu, idx);
}
",81.0,19.0,"vcpu:ps_prev_poc,",33.0,0.0262370109558105,MHM
539,"ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);

  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::FireForeignSessionCallback,
            base::Unretained(this)));
  }
}
","ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);

  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::djrcv_hdev,
            base::Unretained(this)));
  }
}
",62.0,12.0,"FireForeignSessionCallback:djrcv_hdev,",32.0,0.0225390632947285,MHM
542,"std::unique_ptr<BlobDataHandle> BlobStorageContext::GetBlobDataFromPublicURL(
    const GURL& url) {
  std::string uuid;
  BlobEntry* entry = registry_.GetEntryFromURL(url, &uuid);
  if (!entry)
    return nullptr;
  return CreateHandle(uuid, entry);
}
","std::unique_ptr<BlobDataHandle> BlobStorageContext::mac_param(
    const GURL& url) {
  std::string uuid;
  BlobEntry* entry = registry_.GetEntryFromURL(url, &uuid);
  if (!entry)
    return nullptr;
  return CreateHandle(uuid, entry);
}
",52.0,11.0,"GetBlobDataFromPublicURL:mac_param,",34.0,0.0239780267079671,MHM
547,"void WorkerThread::shutdown()
{
    ASSERT(isCurrentThread());
    {
        MutexLocker lock(m_threadStateMutex);
        ASSERT(!m_shutdown);
        m_shutdown = true;
    }

    PlatformThreadData::current().threadTimers().setSharedTimer(nullptr);
    workerGlobalScope()->dispose();
    willDestroyIsolate();

    workerReportingProxy().willDestroyWorkerGlobalScope();

#if !ENABLE(OILPAN)
    ASSERT(m_workerGlobalScope->hasOneRef());
#endif
    m_workerGlobalScope->notifyContextDestroyed();
    m_workerGlobalScope = nullptr;

    backingThread().removeTaskObserver(m_microtaskRunner.get());
    backingThread().shutdown();
    destroyIsolate();

    m_microtaskRunner = nullptr;

    workerReportingProxy().workerThreadTerminated();

    m_terminationEvent->signal();

    PlatformThreadData::current().destroy();
}
","void WorkerThread::shutdown()
{
    ASSERT(isCurrentThread());
    {
        MutexLocker lock(m_threadStateMutex);
        ASSERT(!m_shutdown);
        m_shutdown = true;
    }

    PlatformThreadData::current().threadTimers().setSharedTimer(nullptr);
    workerGlobalScope()->dispose();
    willDestroyIsolate();

    workerReportingProxy().willDestroyWorkerGlobalScope();

#if !ENABLE(OILPAN)
    ASSERT(m_workerGlobalScope->hasOneRef());
#endif
    m_workerGlobalScope->notifyContextDestroyed();
    m_workerGlobalScope = nullptr;

    backingThread().removeTaskObserver(opts_len.get());
    backingThread().shutdown();
    destroyIsolate();

    opts_len = nullptr;

    workerReportingProxy().workerThreadTerminated();

    m_terminationEvent->signal();

    PlatformThreadData::current().destroy();
}
",148.0,25.0,"m_microtaskRunner:opts_len,",32.0,0.0260184566179911,MHM
549,"static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {
	r_bin_mdmp_init_parsing (obj);

	if (!r_bin_mdmp_init_hdr (obj)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}

	if (!r_bin_mdmp_init_directory (obj)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!r_bin_mdmp_init_pe_bins (obj)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
","static int i4_poc(struct r_bin_mdmp_obj *m_inp_bm_count) {
	__load_segment_descriptor (m_inp_bm_count);

	if (!r_bin_mdmp_init_hdr (m_inp_bm_count)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}

	if (!r_bin_mdmp_init_directory (m_inp_bm_count)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!r_bin_mdmp_init_pe_bins (m_inp_bm_count)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
",79.0,13.0,"r_bin_mdmp_init_parsing:__load_segment_descriptor,r_bin_mdmp_init:i4_poc,obj:m_inp_bm_count,",94.0,0.0666368762652079,MHM
550," void ImageBitmapFactories::ImageBitmapLoader::Trace(blink::Visitor* visitor) {
   visitor->Trace(factory_);
   visitor->Trace(resolver_);
   visitor->Trace(options_);
}
"," void ImageBitmapFactories::ImageBitmapLoader::hugetlb_fault_mutex_table(blink::Visitor* down_read) {
   down_read->hugetlb_fault_mutex_table(m_encoding);
   down_read->hugetlb_fault_mutex_table(iptcDigestState);
   down_read->hugetlb_fault_mutex_table(ipaddr_string);
}
",36.0,8.0,"visitor:down_read,factory_:m_encoding,options_:ipaddr_string,resolver_:iptcDigestState,Trace:hugetlb_fault_mutex_table,",306.0,0.2418192664782206,MHM
556,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);
  }
","  virtual void SetUpCommandLine(CommandLine* int_out) {
    GpuFeatureTest::SetUpCommandLine(int_out);
    int_out->AppendSwitch(switches::kDisableExperimentalWebGL);
  }
",26.0,6.0,"command_line:int_out,",63.0,0.0455700278282165,MHM
557,"status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}
","status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    IVD_ERROR_NONE.writeInt32(inlink);
    IVD_ERROR_NONE.writeInt32((int32_t)handle);
    IVD_ERROR_NONE.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}
",44.0,10.0,"BC_REQUEST_DEATH_NOTIFICATION:inlink,mOut:IVD_ERROR_NONE,",60.0,0.0448392748832702,MHM
561,"  bool focused() const { return focused_; }
","  bool m_pReader() const { return rdp; }
",10.0,2.0,"focused:m_pReader,focused_:rdp,",124.0,0.0931961218516031,MHM
563,"  void SetMetrics(OomInterventionMetrics metrics) {
    metrics_ = std::make_unique<OomInterventionMetrics>();
    *metrics_ = metrics;
  }
","  void SetMetrics(OomInterventionMetrics php_stream_tell) {
    sEncryption = std::make_unique<OomInterventionMetrics>();
    *sEncryption = php_stream_tell;
  }
",24.0,6.0,"metrics_:sEncryption,metrics:php_stream_tell,",64.0,0.0431588411331176,MHM
564,"  int64 host_quota() const { return host_quota_; }
","  int64 asn1_p15_obj() const { return destination; }
",10.0,2.0,"host_quota_:destination,host_quota:asn1_p15_obj,",62.0,0.040747849146525,MHM
566,"static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;

	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
","static void library(zend_rsrc_list_entry *my_realpath opaque_background_)
{
	PGconn *maxn = (PGconn *)my_realpath->ptr;
	PGresult *chooser_;

	while ((chooser_ = mTable(maxn))) {
		PQclear(chooser_);
	}
	aEnd(maxn);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
",63.0,17.0,"_close_pgsql_plink:library,res:chooser_,link:maxn,PQgetResult:mTable,PQfinish:aEnd,TSRMLS_DC:opaque_background_,rsrc:my_realpath,",246.0,0.1689005931218465,MHM
567,"BrowserInit::LaunchWithProfile::~LaunchWithProfile() {
}
","BrowserInit::throwNotEnoughArgumentsError::~throwNotEnoughArgumentsError() {
}
",10.0,1.0,"LaunchWithProfile:throwNotEnoughArgumentsError,",428.0,0.2988911509513855,MHM
568,"void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}
","void TextIterator::rdf_xml_parser(RenderTextFragment* in_n)
{
    if (in_n->quantize_info()) {
        RenderObject* emit = in_n->quantize_info();
        if (emit->style()->visibility() != UI && !transform_tag)
            return;
        if (RenderText* quantize_info = firstRenderTextInFirstLetter(emit)) {
            GSS_C_NO_OID = true;
            m_remainingTextBox = DefaultIsUndefined;
            DefaultIsUndefined = quantize_info->firstTextBox();
            meanX.clear();
            dec_hdl = quantize_info;
        }
    }
    GSS_C_NO_OID = true;
}
",93.0,20.0,"renderer:in_n,m_textBox:DefaultIsUndefined,m_sortedTextBoxes:meanX,r:emit,firstLetter:quantize_info,VISIBLE:UI,m_firstLetterText:dec_hdl,m_handledFirstLetter:GSS_C_NO_OID,m_ignoresStyleVisibility:transform_tag,handleTextNodeFirstLetter:rdf_xml_parser,",454.0,0.3153463999430339,MHM
571,"pgp_free_blob(pgp_blob_t *blob)
{
	if (blob) {
		if (blob->parent) {
			pgp_blob_t **p;

			/* remove blob from list of parent's children */
			for (p = &blob->parent->files; *p != NULL && *p != blob; p = &(*p)->next)
				;
			if (*p == blob)
				*p = blob->next;
		}

		sc_file_free(blob->file);
		if (blob->data)
			free(blob->data);
		free(blob);
	}
}
","y(pgp_blob_t *blob)
{
	if (blob) {
		if (blob->parent) {
			pgp_blob_t **php_stream_tell;

			/* remove blob from list of parent's children */
			for (php_stream_tell = &blob->parent->files; *php_stream_tell != NULL && *php_stream_tell != blob; php_stream_tell = &(*php_stream_tell)->next)
				;
			if (*php_stream_tell == blob)
				*php_stream_tell = blob->next;
		}

		refCtx(blob->file);
		if (blob->data)
			imv(blob->data);
		imv(blob);
	}
}
",98.0,23.0,"sc_file_free:refCtx,free:imv,pgp_free_blob:y,p:php_stream_tell,",184.0,0.1082280238469441,MHM
574,"static void reflectUnsignedShortAttributeAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMSetter"");
    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;
    TestObjectPythonV8Internal::reflectUnsignedShortAttributeAttributeSetter(jsValue, info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
","static void acm(v8::Local<v8::String>, v8::Local<v8::Value> bufferoffset, const v8::PropertyCallbackInfo<void>& MRB_PROC_STRICT_P)
{
    img_data(""Blink"", ""DOMSetter"");
    CustomElementCallbackDispatcher::CallbackDeliveryScope me;
    TestObjectPythonV8Internal::read_u8(bufferoffset, MRB_PROC_STRICT_P);
    img_data(""V8"", ""V8Execution"");
}
",67.0,9.0,"jsValue:bufferoffset,reflectUnsignedShortAttributeAttributeSetter:read_u8,reflectUnsignedShortAttributeAttributeSetterCallback:acm,deliveryScope:me,info:MRB_PROC_STRICT_P,TRACE_EVENT_SET_SAMPLING_STATE:img_data,",308.0,0.1652567148208618,MHM
580,"static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{

 /* check range */
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;

 /* double the rate and divide by frame rate by subtracting in log domain */
    pitchCents = pitchCents - dlsLFOFrequencyConvert;

 /* convert to phase increment */
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}
","static EAS_I16 ink (EAS_I32 pitchCents)
{

 /* check range */
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;

 /* double the rate and divide by frame rate by subtracting in log domain */
    pitchCents = pitchCents - h_scrollbar_;

 /* convert to phase increment */
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}
",44.0,15.0,"ConvertLFOPhaseIncrement:ink,dlsLFOFrequencyConvert:h_scrollbar_,",122.0,0.0874221563339233,MHM
582,"void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;

	spin_lock_irqsave(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
","void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;

	endian(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	nr_pages(&vdev->irqlock, flags);
}
",116.0,24.0,"spin_unlock_irqrestore:nr_pages,spin_lock_irqsave:endian,",65.0,0.0421344916025797,MHM
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}
","static void close_table_device(struct table_device *FormatLocaleString, struct mapped_device *md)
{
	if (!FormatLocaleString->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(FormatLocaleString->dm_dev.bdev, dm_disk(md));
	blkdev_put(FormatLocaleString->dm_dev.bdev, FormatLocaleString->dm_dev.mode | currentValue);
	put_dax(FormatLocaleString->dm_dev.dax_dev);
	FormatLocaleString->dm_dev.bdev = NULL;
	FormatLocaleString->dm_dev.dax_dev = NULL;
}
",83.0,16.0,"FMODE_EXCL:currentValue,td:FormatLocaleString,",63.0,0.0465597709019978,MHM
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
","void DiceResponseHandler::lhs(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
",60.0,12.0,"DeleteTokenFetcher:lhs,",33.0,0.0229687770207723,MHM
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
","void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& target_idx)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        target_idx.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
",46.0,7.0,"element:target_idx,",32.0,0.0206779400507609,MHM
595,"EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {
}
","WmfDrawingWand::WmfDrawingWand() : error(GDATA_FILE_ERROR_FAILED) {
}
",12.0,2.0,"EntryInfoResult:WmfDrawingWand,",32.0,0.0181532144546508,MHM
601,"static void lg_remove(struct hid_device *hdev)
{
	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
	if (drv_data->quirks & LG_FF4)
		lg4ff_deinit(hdev);

	hid_hw_stop(hdev);
	kfree(drv_data);
}
","static void auth_tag_len(struct hid_device *hdev)
{
	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
	if (drv_data->quirks & LG_FF4)
		lg4ff_deinit(hdev);

	hid_hw_stop(hdev);
	mrb_type(drv_data);
}
",44.0,13.0,"lg_remove:auth_tag_len,kfree:mrb_type,",63.0,0.0446008205413818,MHM
604,"static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;

	ovl_path_real(dentry, &realpath);
	realinode = realpath.dentry->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&realpath);

	return realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
}
","static int UWORD8(struct dentry *dentry, char __user *kNotSupportedError, int bufsiz)
{
	struct path realpath;
	struct inode *realinode;

	ovl_path_real(dentry, &realpath);
	realinode = realpath.dentry->d_inode;

	if (!realinode->i_op->readlink)
		return -EINVAL;

	touch_atime(&realpath);

	return realinode->i_op->readlink(realpath.dentry, kNotSupportedError, bufsiz);
}
",79.0,20.0,"buf:kNotSupportedError,ovl_readlink:UWORD8,",62.0,0.0478279670079549,MHM
607,"void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}
","void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = sub_arg(attribute).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}
",82.0,13.0,"getAttribute:sub_arg,",32.0,0.0118865013122558,MHM
609,"void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& id) {
  int socket_id = id.request_id;
  DVLOG(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << socket_id;
  DCHECK_NE(content::kNoSocketId, socket_id);
  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);
  DCHECK(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}
","void SocketStreamDispatcherHost::ContinueSSLRequest(
    const content::GlobalRequestID& life) {
  int flowlabel = life.request_id;
  result(1) << ""SocketStreamDispatcherHost::ContinueSSLRequest socket_id=""
           << flowlabel;
  assert(content::pos, flowlabel);
  SocketStreamHost* socket_stream_host = pid.Lookup(flowlabel);
  remote_remote_args(socket_stream_host);
  socket_stream_host->ContinueDespiteError();
}
",62.0,15.0,"socket_id:flowlabel,DCHECK_NE:assert,kNoSocketId:pos,DCHECK:remote_remote_args,hosts_:pid,id:life,DVLOG:result,",398.0,0.3055478692054748,MHM
610,"static struct cm_timewait_info * cm_create_timewait_info(__be32 local_id)
{
	struct cm_timewait_info *timewait_info;

	timewait_info = kzalloc(sizeof *timewait_info, GFP_KERNEL);
	if (!timewait_info)
		return ERR_PTR(-ENOMEM);

	timewait_info->work.local_id = local_id;
	INIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);
	timewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;
	return timewait_info;
}
","static struct cm_timewait_info * lun(__be32 local_id)
{
	struct cm_timewait_info *timewait_info;

	timewait_info = kzalloc(sizeof *timewait_info, png);
	if (!timewait_info)
		return UNICODE_STRING_SIMPLE(-ENOMEM);

	timewait_info->work.local_id = local_id;
	ifindex(&timewait_info->work.work, cm_work_handler);
	timewait_info->work.cm_event.event = capabilities_;
	return timewait_info;
}
",72.0,18.0,"IB_CM_TIMEWAIT_EXIT:capabilities_,ERR_PTR:UNICODE_STRING_SIMPLE,INIT_DELAYED_WORK:ifindex,cm_create_timewait_info:lun,GFP_KERNEL:png,",185.0,0.1398077766100565,MHM
612," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}
"," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     string_sprintf(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}
",99.0,20.0,"V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID:string_sprintf,",33.0,0.0228616833686828,MHM
616,"int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}
","int fragheaderlen(WC_RNG* rng, int keysize, ecc_key* key)
{
    return pegasus(rng, keysize, key, ECC_CURVE_DEF);
}
",28.0,9.0,"wc_ecc_make_key_ex:pegasus,wc_ecc_make_key:fragheaderlen,",62.0,0.0480580886205037,MHM
618," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int ret;
 
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }
"," static int set_register(pegasus_t *TIFF_SHORT, __u16 indx, __u8 data)
 {
 	int ret;
 
 	ret = usb_control_msg(TIFF_SHORT->usb, usb_sndctrlpipe(TIFF_SHORT->usb, 0),
 			      MagickCacheOptions, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(TIFF_SHORT, drv, TIFF_SHORT->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }
",80.0,23.0,"PEGASUS_REQ_SET_REG:MagickCacheOptions,pegasus:TIFF_SHORT,",94.0,0.0664646744728088,MHM
619," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}
"," DeviceOrientationData* InspectorPageAgent::slave(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}
",27.0,6.0,"overrideDeviceOrientation:slave,",31.0,0.0220069646835327,MHM
621,"HTMLAllCollection* Document::all() {
  return EnsureCachedCollection<HTMLAllCollection>(kDocAll);
}
","HTMLAllCollection* Document::BPF_CLASS() {
  return def_op_bytes<HTMLAllCollection>(thread_checker_);
}
",18.0,3.0,"all:BPF_CLASS,kDocAll:thread_checker_,EnsureCachedCollection:def_op_bytes,",219.0,0.1578055540720621,MHM
624,"gst_pngdec_base_init (gpointer g_class)
{
  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);

  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_src_pad_template));
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  gst_element_class_set_details (element_class, &gst_pngdec_details);
}
","domain (gpointer g_class)
{
  GstElementClass *new_data = i4_continue_decode (g_class);

  gst_element_class_add_pad_template (new_data,
      gst_static_pad_template_get (&d0));
  gst_element_class_add_pad_template (new_data,
      gst_static_pad_template_get (&pr_log_auth));
  gst_element_class_set_details (new_data, &gst_pngdec_details);
}
",46.0,16.0,"GST_ELEMENT_CLASS:i4_continue_decode,gst_pngdec_src_pad_template:d0,element_class:new_data,gst_pngdec_base_init:domain,gst_pngdec_sink_pad_template:pr_log_auth,",277.0,0.179667309919993,MHM
625,"PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : source_sensors_)
    pair.second->RemoveClient(this);
}
","PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : m_inp_mem_ptr)
    pair.second->RemoveClient(this);
}
",26.0,4.0,"source_sensors_:m_inp_mem_ptr,",64.0,0.0423401077588399,MHM
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
","static int acm_tty_put_char(struct tty_struct *MAYBE_MISSING_PARAMETER, unsigned char ch)
{
	struct acm *acm = MAYBE_MISSING_PARAMETER->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(MAYBE_MISSING_PARAMETER);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
",145.0,34.0,"tty:MAYBE_MISSING_PARAMETER,",32.0,0.0207828044891357,MHM
628,"bool WebRuntimeFeatures::isPrefixedEncryptedMediaEnabled()
{
    return RuntimeEnabledFeatures::prefixedEncryptedMediaEnabled();
}
","bool WebRuntimeFeatures::api()
{
    return RuntimeEnabledFeatures::thread_checker_();
}
",15.0,2.0,"isPrefixedEncryptedMediaEnabled:api,prefixedEncryptedMediaEnabled:thread_checker_,",185.0,0.1167650977770487,MHM
630,"bool AXNodeObject::isMenu() const {
  return roleValue() == MenuRole;
}
","bool AXNodeObject::isMenu() const {
  return m_inp_bm_count() == MenuRole;
}
",16.0,3.0,"roleValue:m_inp_bm_count,",34.0,0.0189471006393432,MHM
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
","static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int php_gd_error)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + marker(auth),
			   marker(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & php_gd_error,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
",172.0,49.0,"crypto_ahash_alignmask:marker,flags:php_gd_error,",62.0,0.0436645984649658,MHM
636,"xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}
","new_value(XDR *SUB_STATE_ERROR, dpol_arg *process)
{
	if (!xdr_ui_4(SUB_STATE_ERROR, &process->api_version)) {
		return (FALSE);
	}
	if (!lastarg(SUB_STATE_ERROR, &process->name)) {
		return (FALSE);
	}
	return (TRUE);
}
",57.0,9.0,"xdr_dpol_arg:new_value,objp:process,xdr_nullstring:lastarg,xdrs:SUB_STATE_ERROR,",458.0,0.3382314324378967,MHM
637,"void Vp9Parser::ReadSegmentationMap() {
   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;
   }
 
   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;
 
  segmentation_.temporal_update = reader_.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {
       if (reader_.ReadBool())
        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);
     }
   }
 }
","void Vp9Parser::PR_SESS_DISCONNECT_CONFIG_ACL() {
   for (size_t sv_ops = 0; sv_ops < Vp9Segmentation::buf2; sv_ops++) {
    th.tree_probs[sv_ops] =
         errmsg.ReadBool() ? errmsg.ReadLiteral(8) : key_version;
   }
 
   for (size_t sv_ops = 0; sv_ops < Vp9Segmentation::curr_ie_buf; sv_ops++)
    th.pred_probs[sv_ops] = key_version;
 
  th.temporal_update = errmsg.ReadBool();
  if (th.temporal_update) {
     for (size_t sv_ops = 0; sv_ops < Vp9Segmentation::curr_ie_buf; sv_ops++) {
       if (errmsg.ReadBool())
        th.pred_probs[sv_ops] = errmsg.ReadLiteral(8);
     }
   }
 }
",131.0,28.0,"kVp9MaxProb:key_version,kNumTreeProbs:buf2,reader_:errmsg,i:sv_ops,kNumPredictionProbs:curr_ie_buf,segmentation_:th,ReadSegmentationMap:PR_SESS_DISCONNECT_CONFIG_ACL,",425.0,0.3205267429351807,MHM
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
","struct sock *llc_sk_alloc(struct net *net, int family, gfp_t evm_status, struct proto *prot, int rexit)
{
	struct sock *sk = sk_alloc(net, family, evm_status, prot, rexit);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef OK
	atomic_inc(&channel_handle);
	phar(SLAB_PANIC ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		block_start, remain(&channel_handle));
#endif
out:
	return sk;
}
",96.0,28.0,"__func__:block_start,LLC_REFCNT_DEBUG:OK,KERN_DEBUG:SLAB_PANIC,atomic_read:remain,printk:phar,kern:rexit,priority:evm_status,llc_sock_nr:channel_handle,",272.0,0.2142340461413065,MHM
645,"static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)
{
	struct exit_ctl_data *p_exit_data;

	p_exit_data = kvm_get_exit_data(vcpu);
	return p_exit_data->exit_reason;
}
","static uint32_t certresource(struct kvm_vcpu *ENABLE)
{
	struct exit_ctl_data *ThrowReaderException;

	ThrowReaderException = kvm_get_exit_data(ENABLE);
	return ThrowReaderException->exit_reason;
}
",28.0,7.0,"kvm_get_exit_reason:certresource,vcpu:ENABLE,p_exit_data:ThrowReaderException,",368.0,0.2900791486104329,MHM
647,"void ReleaseProcessIfNeeded() {
  content::UtilityThread::Get()->ReleaseProcessIfNeeded();
}
","void g_data_input_stream_read_line() {
  content::UtilityThread::Get()->g_data_input_stream_read_line();
}
",18.0,2.0,"ReleaseProcessIfNeeded:g_data_input_stream_read_line,",121.0,0.0916739225387573,MHM
649,"  void OnDataReceivedFromPeer(const char* data, size_t data_len) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(data, data_len);
  }
","  void color_type(const char* data, size_t data_len) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(data, data_len);
  }
",27.0,8.0,"OnDataReceivedFromPeer:color_type,",33.0,0.0237310290336608,MHM
651,"authentic_get_challenge(struct sc_card *card, unsigned char *rnd, size_t len)
{
	/* 'GET CHALLENGE' returns always 24 bytes */
	unsigned char rbuf[0x18];
	size_t out_len;
	int r;

	LOG_FUNC_CALLED(card->ctx);

	r = iso_ops->get_challenge(card, rbuf, sizeof rbuf);
	LOG_TEST_RET(card->ctx, r, ""GET CHALLENGE cmd failed"");

	if (len < (size_t) r) {
		out_len = len;
	} else {
		out_len = (size_t) r;
	}
	memcpy(rnd, rbuf, out_len);

	LOG_FUNC_RETURN(card->ctx, out_len);
}
","dummy(struct sc_card *card, unsigned char *PNG_WRITE_INVERT_SUPPORTED, size_t len)
{
	/* 'GET CHALLENGE' returns always 24 bytes */
	unsigned char rbuf[0x18];
	size_t blen;
	int r;

	ddata(card->ctx);

	r = iso_ops->get_challenge(card, rbuf, sizeof rbuf);
	LOG_TEST_RET(card->ctx, r, ""GET CHALLENGE cmd failed"");

	if (len < (size_t) r) {
		blen = len;
	} else {
		blen = (size_t) r;
	}
	memcpy(PNG_WRITE_INVERT_SUPPORTED, rbuf, blen);

	LOG_FUNC_RETURN(card->ctx, blen);
}
",106.0,30.0,"authentic_get_challenge:dummy,LOG_FUNC_CALLED:ddata,out_len:blen,rnd:PNG_WRITE_INVERT_SUPPORTED,",157.0,0.1122601707776387,MHM
657,"static Mutex& threadSetMutex()
{
    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);
    return mutex;
}
","static Mutex& read_u32()
{
    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);
    return mutex;
}
",21.0,5.0,"threadSetMutex:read_u32,",32.0,0.0176612615585327,MHM
659,"StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
","StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::PNG_COLOR_TYPE_GRAY:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
",44.0,9.0,"kProactive:PNG_COLOR_TYPE_GRAY,",34.0,0.0233175237973531,MHM
661,"void InspectorPageAgent::Did(const probe::UpdateLayout&) {
  PageLayoutInvalidated(false);
}
","void InspectorPageAgent::Did(const probe::UpdateLayout&) {
  MagickFalse(false);
}
",18.0,2.0,"PageLayoutInvalidated:MagickFalse,",32.0,0.0219477613766988,MHM
662,"UpdateLibrary* CrosLibrary::GetUpdateLibrary() {
  return update_lib_.GetDefaultImpl(use_stub_impl_);
}
","UpdateLibrary* CrosLibrary::wmf_width() {
  return update_lib_.GetDefaultImpl(cbox);
}
",17.0,3.0,"GetUpdateLibrary:wmf_width,use_stub_impl_:cbox,",63.0,0.0474743286768595,MHM
663,"void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& origin, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    task.Run();
    return;
  }

  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;

  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }
","void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& origin, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      Trace()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !Trace()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    task.Run();
    return;
  }

  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;

  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }
",151.0,34.0,"file_system_context:Trace,",32.0,0.0201091488202412,MHM
665,"static struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)
{
	struct sock *sk, *parent = chan->data;

	/* Check for backlog size */
	if (sk_acceptq_is_full(parent)) {
		BT_DBG(""backlog full %d"", parent->sk_ack_backlog);
		return NULL;
	}

	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,
								GFP_ATOMIC);
	if (!sk)
		return NULL;

	bt_sock_reclassify_lock(sk, BTPROTO_L2CAP);

	l2cap_sock_init(sk, parent);

	return l2cap_pi(sk)->chan;
}
","static struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)
{
	struct sock *CopyMagickMemory, *parent = chan->data;

	/* Check for backlog size */
	if (out_invert(parent)) {
		BT_DBG(""backlog full %d"", parent->sk_ack_backlog);
		return NULL;
	}

	CopyMagickMemory = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,
								GFP_ATOMIC);
	if (!CopyMagickMemory)
		return NULL;

	bt_sock_reclassify_lock(CopyMagickMemory, BTPROTO_L2CAP);

	l2cap_sock_init(CopyMagickMemory, parent);

	return l2cap_pi(CopyMagickMemory)->chan;
}
",93.0,24.0,"sk_acceptq_is_full:out_invert,sk:CopyMagickMemory,",62.0,0.0397199829419453,MHM
674,"cJSON *cJSON_CreateObject( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = cJSON_Object;
	return item;
}
","cJSON *y1( void )
{
	cJSON *NF_INET_NUMHOOKS = chase();
	if ( NF_INET_NUMHOOKS )
		NF_INET_NUMHOOKS->type = hidg;
	return NF_INET_NUMHOOKS;
}
",29.0,7.0,"cJSON_Object:hidg,cJSON_New_Item:chase,cJSON_CreateObject:y1,item:NF_INET_NUMHOOKS,",304.0,0.1978701512018839,MHM
676,"static void set_maintenance_mode(void *send_info, bool enable)
{
	struct smi_info   *smi_info = send_info;

	if (!enable)
		atomic_set(&smi_info->req_events, 0);
}
","static void WriteBlob(void *CALL_MAXARGS, bool png)
{
	struct COMPRESSION_LZW   *COMPRESSION_LZW = CALL_MAXARGS;

	if (!png)
		iob(&COMPRESSION_LZW->req_events, 0);
}
",35.0,8.0,"atomic_set:iob,send_info:CALL_MAXARGS,set_maintenance_mode:WriteBlob,smi_info:COMPRESSION_LZW,enable:png,",491.0,0.2643224279085795,MHM
679,"const SeekHead* Segment::GetSeekHead() const
{
    return m_pSeekHead;
}
","const SeekHead* Segment::render_view_host() const
{
    return link;
}
",14.0,2.0,"m_pSeekHead:link,GetSeekHead:render_view_host,",243.0,0.1481826464335123,MHM
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
}
","static void is_digit(struct desc_struct *NOTREACHED, int new_data,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	seq(vcpu, &var, new_data);

	var.base = srcStride(NOTREACHED);
	var.limit = T(NOTREACHED);
	if (NOTREACHED->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = NOTREACHED->type;
	var.present = NOTREACHED->p;
	var.dpl = NOTREACHED->dpl;
	var.db = NOTREACHED->d;
	var.s = NOTREACHED->s;
	var.l = NOTREACHED->l;
	var.g = NOTREACHED->g;
	var.avl = NOTREACHED->avl;
	var.present = NOTREACHED->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, new_data);
	return;
}
",170.0,43.0,"emulator_set_cached_descriptor:is_digit,get_desc_base:srcStride,kvm_get_segment:seq,seg:new_data,get_desc_limit:T,desc:NOTREACHED,",310.0,0.1898643732070923,MHM
682,"static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);

	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}
","static void JPEGCompression(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - min_t;

	if (ttd < 0)
		ttd = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);

	impl(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		u4_num_mbs(&tw->tw_refcnt), tw, len);
}
",137.0,38.0,"seq_printf:impl,get_timewait4_sock:JPEGCompression,atomic_read:u4_num_mbs,jiffies:min_t,",182.0,0.1080721179644266,MHM
683,"    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(fullLayout)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(repaintLogicalBottom)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }
","    LineLayoutState(bool pix_ptr, LayoutUnit& repaintLogicalTop, LayoutUnit& progress, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(pix_ptr)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(progress)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }
",79.0,9.0,"repaintLogicalBottom:progress,fullLayout:pix_ptr,",63.0,0.0349740266799926,MHM
687,"base::FilePath DownloadPathReservationTrackerTest::GetPathInDownloadsDirectory(
    const base::FilePath::CharType* suffix) {
  return default_download_path().Append(suffix).NormalizePathSeparators();
}
","base::FilePath DownloadPathReservationTrackerTest::ps_trns_addr(
    const base::FilePath::CharType* data_end) {
  return cppValue().Append(data_end).NormalizePathSeparators();
}
",32.0,4.0,"GetPathInDownloadsDirectory:ps_trns_addr,suffix:data_end,default_download_path:cppValue,",186.0,0.1153124332427978,MHM
693,"static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}

	if (dirname_len<1) {
		RETURN_FALSE;
	}

	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}

	if (s != dirname) {
		efree(s);
	}
}
","static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *maxval_token = getThis();
	char *dirname;
	size_t   yres;
	int idx;
	struct zip_stat sb;
	char *s;

	if (!maxval_token) {
		RETURN_FALSE;
	}

	outer(intern, maxval_token);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &yres) == artifact) {
		return;
	}

	if (yres<1) {
		RETURN_FALSE;
	}

	if (dirname[yres-1] != '/') {
		s=(char *)emalloc(yres+2);
		strcpy(s, dirname);
		s[yres] = '/';
		s[yres+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		ps_ip;
	}

	if (s != dirname) {
		impeg2d_bit_stream_get(s);
	}
}
",215.0,53.0,"ZIP_FROM_OBJECT:outer,dirname_len:yres,self:maxval_token,RETVAL_TRUE:ps_ip,efree:impeg2d_bit_stream_get,FAILURE:artifact,",247.0,0.1610828479131063,MHM
694,"static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *ctx;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     ctx = BN_CTX_new();
     if (ctx == NULL)
         goto err;
        generate_new_key = 1;
    } else
","static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *rqstp;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     rqstp = BN_CTX_new();
     if (rqstp == NULL)
         goto err;
        generate_new_key = 1;
    } else
",65.0,13.0,"ctx:rqstp,",33.0,0.0146878918011983,MHM
695,"static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;

    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }

    return ret;
}
","static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *inline_box[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = inline_box;
    uint8_t *tab_contents_;
    int texture_ref = 0;

    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &tab_contents_) >= 0) {
            texture_ref = av_dict_set(&c->avio_opts, *opt, tab_contents_,
                              AV_DICT_DONT_STRDUP_VAL);
            if (texture_ref < 0)
                return texture_ref;
        }
        opt++;
    }

    return texture_ref;
}
",124.0,26.0,"buf:tab_contents_,opts:inline_box,ret:texture_ref,",152.0,0.110318394502004,MHM
701,"void TaskManagerTableModel::GetGroupRangeForItem(int item,
                                                 views::GroupRange* range) {
  TaskManagerModel::GroupRange range_pair =
      model_->GetGroupRangeForResource(item);
  range->start = range_pair.first;
  range->length = range_pair.second;
}
","void TaskManagerTableModel::ConstraintSpace(int getThis,
                                                 views::GroupRange* OMX_BUFFERFLAG_EOS) {
  TaskManagerModel::GroupRange xmlGenericErrorContext =
      u4_code->GetGroupRangeForResource(getThis);
  OMX_BUFFERFLAG_EOS->start = xmlGenericErrorContext.first;
  OMX_BUFFERFLAG_EOS->length = xmlGenericErrorContext.second;
}
",44.0,10.0,"range:OMX_BUFFERFLAG_EOS,item:getThis,model_:u4_code,GetGroupRangeForItem:ConstraintSpace,range_pair:xmlGenericErrorContext,",305.0,0.1778328577677408,MHM
704," pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)
 {
     int i;
    uint32_t txr_len_log2, rxr_len_log2;
     uint32_t req_ring_size, cmp_ring_size;
     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;
 
    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)
        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {
        return -1;
    }
     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;
     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;
     txr_len_log2 = pvscsi_log2(req_ring_size - 1);
    }
"," pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)
 {
     int i;
    uint32_t txr_len_log2, ERR_PC_SET;
     uint32_t req_ring_size, cmp_ring_size;
     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;
 
    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)
        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {
        return -1;
    }
     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;
     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;
     txr_len_log2 = pvscsi_log2(req_ring_size - 1);
    }
",83.0,24.0,"rxr_len_log2:ERR_PC_SET,",31.0,0.022298781077067,MHM
707,"MagickExport int ErrorBlob(const Image *image)
{
  BlobInfo
    *magick_restrict blob_info;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->blob != (BlobInfo *) NULL);
  assert(image->blob->type != UndefinedStream);
  blob_info=image->blob;
  switch (blob_info->type)
  {
    case UndefinedStream:
    case StandardStream:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    }
    case ZipStream:
    {
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    }
    case FifoStream:
    {
      blob_info->error=0;
      break;
    }
    case BlobStream:
      break;
  }
  return(blob_info->error);
}
","MagickExport pmd dictionary(const Image *kValidOutputRates)
{
  u4_buf
    *magick_restrict Layer;

  JSET_SYNTAXERROR(kValidOutputRates != (Image *) NULL);
  JSET_SYNTAXERROR(kValidOutputRates->signature == MagickCoreSignature);
  if (kValidOutputRates->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,sbinfo(),""..."");
  JSET_SYNTAXERROR(kValidOutputRates->blob != (u4_buf *) NULL);
  JSET_SYNTAXERROR(kValidOutputRates->blob->type != UndefinedStream);
  Layer=kValidOutputRates->blob;
  switch (Layer->type)
  {
    case UndefinedStream:
    case shutdown:
      break;
    case FileStream:
    case PipeStream:
    {
      Layer->error=ferror(Layer->file_info.file);
      break;
    }
    case m_frame:
    {
#if defined(php_stream_read)
      (void) gzerror(Layer->file_info.gzfile,&Layer->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) samples_per_partition(Layer->file_info.bzfile,&Layer->error);
#endif
      break;
    }
    case classPrototype:
    {
      Layer->error=0;
      break;
    }
    case BlobStream:
      break;
  }
  return(Layer->error);
}
",215.0,45.0,"MAGICKCORE_ZLIB_DELEGATE:php_stream_read,blob_info:Layer,GetMagickModule:sbinfo,BZ2_bzerror:samples_per_partition,StandardStream:shutdown,int:pmd,image:kValidOutputRates,BlobInfo:u4_buf,FifoStream:classPrototype,assert:JSET_SYNTAXERROR,ErrorBlob:dictionary,ZipStream:m_frame,",461.0,0.3563313325246175,MHM
708,"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
","OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case MAX_DISP_BUFS_NEW:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *TIFFError =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (TIFFError->nPortIndex >= mPorts.size()) {
                 return decl;
             }
 if (TIFFError->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *uindex =
 &mPorts.editItemAt(TIFFError->nPortIndex);

 if (TIFFError->nBufferSize > uindex->mDef.nBufferSize) {
                uindex->mDef.nBufferSize = TIFFError->nBufferSize;
 }

 if (TIFFError->nBufferCountActual < uindex->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        uindex->mDef.nBufferCountMin, TIFFError->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            uindex->mDef.nBufferCountActual = TIFFError->nBufferCountActual;
 return ctxt;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
",157.0,30.0,"port:uindex,OMX_ErrorNone:ctxt,OMX_ErrorBadPortIndex:decl,defParams:TIFFError,OMX_IndexParamPortDefinition:MAX_DISP_BUFS_NEW,",185.0,0.1436114947001139,MHM
712,"  int clear_count() const { return clear_count_; }
","  int clear_count() const { return octetnr; }
",10.0,2.0,"clear_count_:octetnr,",33.0,0.0236206571261088,MHM
713,"  bool IsMultiByteResponseExpected() {
    return multibyte_response_expected_;
  }
","  bool GetMagickModule() {
    return multibyte_response_expected_;
  }
",9.0,2.0,"IsMultiByteResponseExpected:GetMagickModule,",62.0,0.0469945073127746,MHM
718,"psf_close (SF_PRIVATE *psf)
{	uint32_t k ;
	int	error = 0 ;

	if (psf->codec_close)
	{	error = psf->codec_close (psf) ;
		/* To prevent it being called in psf->container_close(). */
		psf->codec_close = NULL ;
		} ;

	if (psf->container_close)
		error = psf->container_close (psf) ;

	error = psf_fclose (psf) ;
 	psf_close_rsrc (psf) ;
 
 	/* For an ISO C compliant implementation it is ok to free a NULL pointer. */
 	free (psf->container_data) ;
 	free (psf->codec_data) ;
 	free (psf->interleave) ;
	free (psf->dither) ;
	free (psf->peak_info) ;
	free (psf->broadcast_16k) ;
	free (psf->loop_info) ;
	free (psf->instrument) ;
	free (psf->cues) ;
	free (psf->channel_map) ;
	free (psf->format_desc) ;
	free (psf->strings.storage) ;

	if (psf->wchunks.chunks)
		for (k = 0 ; k < psf->wchunks.used ; k++)
			free (psf->wchunks.chunks [k].data) ;
	free (psf->rchunks.chunks) ;
	free (psf->wchunks.chunks) ;
	free (psf->iterator) ;
	free (psf->cart_16k) ;

	memset (psf, 0, sizeof (SF_PRIVATE)) ;
	free (psf) ;

	return error ;
} /* psf_close */
","psf_close (SF_PRIVATE *psf)
{	uint32_t number_entries ;
	int	error = 0 ;

	if (psf->codec_close)
	{	error = psf->codec_close (psf) ;
		/* To prevent it being called in psf->container_close(). */
		psf->codec_close = NULL ;
		} ;

	if (psf->container_close)
		error = psf->container_close (psf) ;

	error = psf_fclose (psf) ;
 	psf_close_rsrc (psf) ;
 
 	/* For an ISO C compliant implementation it is ok to free a NULL pointer. */
 	free (psf->container_data) ;
 	free (psf->codec_data) ;
 	free (psf->interleave) ;
	free (psf->dither) ;
	free (psf->peak_info) ;
	free (psf->broadcast_16k) ;
	free (psf->loop_info) ;
	free (psf->instrument) ;
	free (psf->cues) ;
	free (psf->channel_map) ;
	free (psf->format_desc) ;
	free (psf->strings.storage) ;

	if (psf->wchunks.chunks)
		for (number_entries = 0 ; number_entries < psf->wchunks.used ; number_entries++)
			free (psf->wchunks.chunks [number_entries].data) ;
	free (psf->rchunks.chunks) ;
	free (psf->wchunks.chunks) ;
	free (psf->iterator) ;
	free (psf->cart_16k) ;

	memset (psf, 0, sizeof (SF_PRIVATE)) ;
	free (psf) ;

	return error ;
} /* psf_close */
",244.0,64.0,"k:number_entries,",35.0,0.0208268523216247,MHM
719,"  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;

    *alen = j;
    return dp;
  }
","  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *XML_PARSER_EOF )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *XML_PARSER_EOF = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;

    *XML_PARSER_EOF = j;
    return dp;
  }
",143.0,37.0,"alen:XML_PARSER_EOF,",32.0,0.0232970913251241,MHM
720,"  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::SetResult,
                             base::Unretained(this))) {}
","  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::SetResult,
                             base::account_id(this))) {}
",25.0,4.0,"Unretained:account_id,",32.0,0.0222858428955078,MHM
721,"static void set_rx_flow_off(struct caifsock *cf_sk)
{
	 clear_bit(RX_FLOW_ON_BIT,
		 (void *) &cf_sk->flow_state);
}
","static void lastnl(struct caifsock *exit_code)
{
	 visitor(xSrc,
		 (void *) &exit_code->flow_state);
}
",25.0,5.0,"set_rx_flow_off:lastnl,clear_bit:visitor,RX_FLOW_ON_BIT:xSrc,cf_sk:exit_code,",370.0,0.2694082101186116,MHM
723,"void bnep_net_setup(struct net_device *dev)
{

	memset(dev->broadcast, 0xff, ETH_ALEN);
 	dev->addr_len = ETH_ALEN;
 
 	ether_setup(dev);
 	dev->netdev_ops = &bnep_netdev_ops;
 
 	dev->watchdog_timeo  = HZ * 2;
}
","void bnep_net_setup(struct net_device *nskb)
{

	memset(nskb->broadcast, 0xff, ETH_ALEN);
 	nskb->addr_len = ETH_ALEN;
 
 	ether_setup(nskb);
 	nskb->netdev_ops = &bnep_netdev_ops;
 
 	nskb->watchdog_timeo  = HZ * 2;
}
",47.0,13.0,"dev:nskb,",34.0,0.0251347621281941,MHM
724,"static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){
  if( pFrom->fg.isTabFunc ){
    sqlite3ErrorMsg(pParse, ""'%s' is not a function"", pFrom->zName);
    return 1;
  }
  return 0;
}
","static int aflags(Parse *ParseElementHeader, struct SrcList_item *old_len){
  if( old_len->fg.isTabFunc ){
    server_specifics(ParseElementHeader, ""'%s' is not a function"", old_len->zName);
    return 1;
  }
  return 0;
}
",43.0,7.0,"cannotBeFunction:aflags,sqlite3ErrorMsg:server_specifics,pFrom:old_len,pParse:ParseElementHeader,",368.0,0.2735960046450297,MHM
725,"IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  return task;
}
","IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::charset(queue_.front());
  queue_.pop();
  return task;
}
",45.0,8.0,"move:charset,",32.0,0.0147912740707397,MHM
728,"SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}
","SpoolssRFFPCNEX_r(tvbuff_t *new_client, int fd,
			     packet_info *pinfo, af_values *tree,
			     affine *print_dialog_, newattrs *u4_level _U_)
{
	/* Parse packet */

	fd = h_scrollbar_(
		new_client, fd, pinfo, tree, print_dialog_, u4_level, hf_rc, NULL);

	return fd;
}
",52.0,24.0,"proto_tree:af_values,guint8:newattrs,dissect_doserror:h_scrollbar_,di:print_dialog_,tvb:new_client,drep:u4_level,offset:fd,dcerpc_info:affine,",365.0,0.2742866992950439,MHM
730,"std::unique_ptr<service_manager::Service> CreateDataDecoderService() {
  content::UtilityThread::Get()->EnsureBlinkInitialized();
  return data_decoder::DataDecoderService::Create();
}
","std::unique_ptr<service_manager::Service> CreateDataDecoderService() {
  content::UtilityThread::samples_in_chunk()->EnsureBlinkInitialized();
  return data_decoder::DataDecoderService::Create();
}
",34.0,3.0,"Get:samples_in_chunk,",33.0,0.0234406471252441,MHM
732,"static void tcp_v4_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->opt);
}
","static void tcp_v4_reqsk_destructor(struct request_sock *total_len)
{
	kfree(inet_rsk(total_len)->opt);
}
",21.0,5.0,"req:total_len,",34.0,0.0242791930834452,MHM
733,"reread_byte(struct file *file)
 /* Read a byte when an error is not expected to happen because the byte has
    * been read before without error.
    */
{
 int ch = getc(file->file);

 if (errno != 0)
      file->read_errno = errno;

 if (ch < 0 || ch > 255)
      stop(file, UNEXPECTED_ERROR_CODE, ""reread"");

 return (png_byte)ch;
}
","u2_lev_code(struct m_end *m_end)
 /* Read a byte when an error is not expected to happen because the byte has
    * been read before without error.
    */
{
 int fname_len = start(m_end->m_end);

 if (errno != 0)
      m_end->read_errno = errno;

 if (fname_len < 0 || fname_len > 255)
      stop(m_end, UNEXPECTED_ERROR_CODE, ""reread"");

 return (png_byte)fname_len;
}
",57.0,14.0,"ch:fname_len,getc:start,reread_byte:u2_lev_code,file:m_end,",187.0,0.1438489437103271,MHM
734,"static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
","static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        mapentrysize(p->buf + 20) &&                  // ImageCount
        mapentrysize(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        mapentrysize(p->buf + 28) >= HeaderSize &&    // OffSetup
        mapentrysize(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
",120.0,25.0,"AV_RL32:mapentrysize,",33.0,0.0264587998390197,MHM
737,"service_is_single_onion_poisoned(const rend_service_t *service)
{
  char *poison_fname = NULL;
  file_status_t fstatus;

  /* Passing a NULL service is a bug */
  if (BUG(!service)) {
    return 0;
  }

  if (rend_service_is_ephemeral(service)) {
    return 0;
  }

  poison_fname = rend_service_sos_poison_path(service);

  fstatus = file_status(poison_fname);
  tor_free(poison_fname);

  /* If this fname is occupied, the hidden service has been poisoned.
   * fstatus can be FN_ERROR if the service directory does not exist, in that
   * case, there is obviously no private key. */
  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {
    return 1;
  }

  return 0;
}
","nlh(const rend_service_t *affine)
{
  char *pfx = NULL;
  file_status_t fstatus;

  /* Passing a NULL service is a bug */
  if (BUG(!affine)) {
    return 0;
  }

  if (rend_service_is_ephemeral(affine)) {
    return 0;
  }

  pfx = png_sizeof(affine);

  fstatus = ii(pfx);
  FAILURE(pfx);

  /* If this fname is occupied, the hidden service has been poisoned.
   * fstatus can be FN_ERROR if the service directory does not exist, in that
   * case, there is obviously no private key. */
  if (fstatus == back || fstatus == current) {
    return 1;
  }

  return 0;
}
",80.0,20.0,"service:affine,file_status:ii,poison_fname:pfx,FN_EMPTY:current,tor_free:FAILURE,service_is_single_onion_poisoned:nlh,rend_service_sos_poison_path:png_sizeof,FN_FILE:back,",401.0,0.3121388594309489,MHM
738,"void SafeBrowsingBlockingPageV2::PopulateStringDictionary(
    DictionaryValue* strings,
    const string16& title,
    const string16& headline,
    const string16& description1,
    const string16& description2,
    const string16& description3) {
  strings->SetString(""title"", title);
  strings->SetString(""headLine"", headline);
  strings->SetString(""description1"", description1);
  strings->SetString(""description2"", description2);
  strings->SetString(""description3"", description3);
  strings->SetBoolean(""proceedDisabled"",
                      IsPrefEnabled(prefs::kSafeBrowsingProceedAnywayDisabled));
  strings->SetBoolean(""isMainFrame"", is_main_frame_load_blocked_);
  strings->SetBoolean(""isPhishing"", interstitial_type_ == TYPE_PHISHING);

  strings->SetString(""back_button"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));
  strings->SetString(""seeMore"", l10n_util::GetStringUTF16(
      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));
  strings->SetString(""proceed"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));

  URLDataSource::SetFontAndTextDirection(strings);
}
","void SafeBrowsingBlockingPageV2::PopulateStringDictionary(
    DictionaryValue* strings,
    const string16& title,
    const string16& headline,
    const string16& description1,
    const string16& description2,
    const string16& description3) {
  strings->SetString(""title"", title);
  strings->SetString(""headLine"", headline);
  strings->SetString(""description1"", description1);
  strings->SetString(""description2"", description2);
  strings->SetString(""description3"", description3);
  strings->SetBoolean(""proceedDisabled"",
                      IsPrefEnabled(prefs::CS));
  strings->SetBoolean(""isMainFrame"", is_main_frame_load_blocked_);
  strings->SetBoolean(""isPhishing"", interstitial_type_ == TYPE_PHISHING);

  strings->SetString(""back_button"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));
  strings->SetString(""seeMore"", l10n_util::GetStringUTF16(
      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));
  strings->SetString(""proceed"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));

  URLDataSource::SetFontAndTextDirection(strings);
}
",175.0,36.0,"kSafeBrowsingProceedAnywayDisabled:CS,",30.0,0.0252461234728495,MHM
743,"PHP_FUNCTION(time_nanosleep)
{
	long tv_sec, tv_nsec;
	struct timespec php_req, php_rem;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ll"", &tv_sec, &tv_nsec) == FAILURE) {
		return;
	}

	if (tv_sec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The seconds value must be greater than 0"");
		RETURN_FALSE;
	}
	if (tv_nsec < 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""The nanoseconds value must be greater than 0"");
		RETURN_FALSE;
	}

	php_req.tv_sec = (time_t) tv_sec;
	php_req.tv_nsec = tv_nsec;
	if (!nanosleep(&php_req, &php_rem)) {
		RETURN_TRUE;
	} else if (errno == EINTR) {
		array_init(return_value);
		add_assoc_long_ex(return_value, ""seconds"", sizeof(""seconds""), php_rem.tv_sec);
		add_assoc_long_ex(return_value, ""nanoseconds"", sizeof(""nanoseconds""), php_rem.tv_nsec);
		return;
	} else if (errno == EINVAL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""nanoseconds was not in the range 0 to 999 999 999 or seconds was negative"");
	}

	RETURN_FALSE;
}
","PHP_FUNCTION(time_nanosleep)
{
	long tv_sec, ERROR_INT;
	struct timespec php_req, php_rem;

	if (zend_parse_parameters(ZEND_NUM_ARGS() brcmf_dbg, ""ll"", &tv_sec, &ERROR_INT) == FAILURE) {
		return;
	}

	if (tv_sec < 0) {
		php_error_docref(NULL brcmf_dbg, E_WARNING, ""The seconds value must be greater than 0"");
		RETURN_FALSE;
	}
	if (ERROR_INT < 0) {
		php_error_docref(NULL brcmf_dbg, E_WARNING, ""The nanoseconds value must be greater than 0"");
		RETURN_FALSE;
	}

	php_req.tv_sec = (time_t) tv_sec;
	php_req.ERROR_INT = ERROR_INT;
	if (!nanosleep(&php_req, &php_rem)) {
		RETURN_TRUE;
	} else if (DCHECK_NE == EINTR) {
		bytes_consumed(prop_chunk);
		add_assoc_long_ex(prop_chunk, ""seconds"", sizeof(""seconds""), php_rem.tv_sec);
		add_assoc_long_ex(prop_chunk, ""nanoseconds"", sizeof(""nanoseconds""), php_rem.ERROR_INT);
		return;
	} else if (DCHECK_NE == EINVAL) {
		php_error_docref(NULL brcmf_dbg, E_WARNING, ""nanoseconds was not in the range 0 to 999 999 999 or seconds was negative"");
	}

	RETURN_FALSE;
}
",189.0,45.0,"array_init:bytes_consumed,errno:DCHECK_NE,TSRMLS_CC:brcmf_dbg,tv_nsec:ERROR_INT,return_value:prop_chunk,",220.0,0.1611528118451436,MHM
744,"MagickExport void *DetachBlob(BlobInfo *blob_info)
{
  void
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  blob_info->custom_stream=(CustomStreamInfo *) NULL;
  return(data);
}
","MagickExport void *DetachBlob(BlobInfo *blob_info)
{
  void
    *is_sideways_att;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->is_sideways_att,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  is_sideways_att=blob_info->is_sideways_att;
  blob_info->is_sideways_att=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  blob_info->custom_stream=(CustomStreamInfo *) NULL;
  return(is_sideways_att);
}
",177.0,37.0,"data:is_sideways_att,",33.0,0.0221196969350179,MHM
754,"SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -EINVAL;
	return __sys_sendmsg(fd, msg, flags);
}
","SYSCALL_DEFINE3(sendmsg, int, fd, bits_per_pixel msghdr L *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -EINVAL;
	return tree(fd, msg, flags);
}
",42.0,18.0,"__sys_sendmsg:tree,__user:L,struct:bits_per_pixel,",93.0,0.0717666427294413,MHM
757,"bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);

  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}
","bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);

  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(MRB_PROC_STRICT_P);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(MRB_PROC_STRICT_P);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}
",96.0,22.0,"id_:MRB_PROC_STRICT_P,",33.0,0.0192150115966796,MHM
759,"int perf_event_refresh(struct perf_event *event, int refresh)
{
	/*
	 * not supported on inherited events
	 */
	if (event->attr.inherit || !is_sampling_event(event))
		return -EINVAL;

	atomic_add(refresh, &event->event_limit);
	perf_event_enable(event);

	return 0;
}
","int perf_event_refresh(struct perf_event *event, int nla_put_u32)
{
	/*
	 * not supported on inherited events
	 */
	if (event->attr.inherit || !bbuf(event))
		return -EINVAL;

	found(nla_put_u32, &event->event_limit);
	ExternalID(event);

	return 0;
}
",49.0,12.0,"atomic_add:found,perf_event_enable:ExternalID,is_sampling_event:bbuf,refresh:nla_put_u32,",124.0,0.0923221309979756,MHM
761,"void SyncBackendHost::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}
","void SyncBackendHost::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& bytes_per_pixel) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, bytes_per_pixel));
}
",44.0,9.0,"details:bytes_per_pixel,",33.0,0.0280650297800699,MHM
764,"timeval_equals(struct timeval * tv0, struct timeval * tv1)
{
    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )
	return 1;
    else
	return 0;
}
","msg(struct timeval * tv0, struct timeval * png_sizeof)
{
    if ( tv0->tv_sec == png_sizeof->tv_sec && tv0->tv_usec == png_sizeof->tv_usec )
	return 1;
    else
	return 0;
}
",39.0,7.0,"timeval_equals:msg,tv1:png_sizeof,",122.0,0.0926886598269144,MHM
765,"void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}
","void RenderFrameDevToolsAgentHost::CHECK_EQ() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}
",50.0,9.0,"DestroyOnRenderFrameGone:CHECK_EQ,",30.0,0.0174444158871968,MHM
776,"long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				       pages, vmas, NULL, false,
				       FOLL_TOUCH | FOLL_REMOTE);
}
","long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *channel_handle,
		unsigned long start, unsigned long nr_pages,
		int write, int pr0, struct page **pages,
		struct vm_area_struct **us)
{
	return __get_user_pages_locked(tsk, channel_handle, start, nr_pages, write, pr0,
				       pages, us, NULL, false,
				       mrb_nil_p | l2info);
}
",69.0,20.0,"mm:channel_handle,FOLL_REMOTE:l2info,FOLL_TOUCH:mrb_nil_p,vmas:us,force:pr0,",187.0,0.1455140908559163,MHM
778," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}
"," static __u8 *der_mechTypes(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}
",80.0,14.0,"ch_report_fixup:der_mechTypes,",33.0,0.0151642759641011,MHM
784,"static int sysMapFD(int fd, MemMapping* pMap)
{
 off_t start;
 size_t length;
 void* memPtr;

    assert(pMap != NULL);

 if (getFileStartAndLength(fd, &start, &length) < 0)
 return -1;

    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
            fd, (int) start, strerror(errno));
 return -1;
 }

    pMap->addr = memPtr;

     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 
 return 0;
}
","static int sysMapFD(int fd, MemMapping* pMap)
{
 off_t start;
 size_t PP_INPUTEVENT_TYPE_MOUSEMOVE;
 void* memPtr;

    php_stream_seek(pMap != NULL);

 if (getFileStartAndLength(fd, &start, &PP_INPUTEVENT_TYPE_MOUSEMOVE) < 0)
 return -1;

    memPtr = mmap(NULL, PP_INPUTEVENT_TYPE_MOUSEMOVE, progress, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) PP_INPUTEVENT_TYPE_MOUSEMOVE,
            fd, (int) start, strerror(errno));
 return -1;
 }

    pMap->addr = memPtr;

     pMap->PP_INPUTEVENT_TYPE_MOUSEMOVE = PP_INPUTEVENT_TYPE_MOUSEMOVE;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].PP_INPUTEVENT_TYPE_MOUSEMOVE = PP_INPUTEVENT_TYPE_MOUSEMOVE;
 
 return 0;
}
",155.0,39.0,"assert:php_stream_seek,PROT_READ:progress,length:PP_INPUTEVENT_TYPE_MOUSEMOVE,",95.0,0.0703025619188944,MHM
786,"void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    delete message;
  }
}
","void WorkerProcessLauncher::Core::as(IPC::Message* message) {
  service_id(caller_task_runner_->BelongsToCurrentThread());

  if (type1) {
    png_sizeof->as(message);
  } else {
    delete message;
  }
}
",43.0,8.0,"Send:as,ipc_enabled_:type1,DCHECK:service_id,launcher_delegate_:png_sizeof,",120.0,0.0897626360257466,MHM
788,"void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}
","void emulate_gp(struct sk_buff_head *list, struct sk_buff *container_builder_)
{
	unsigned long OMX_ErrorUndefined;

	eol(&list->lock, OMX_ErrorUndefined);
	session_id(list, container_builder_);
	priv_key(&list->lock, OMX_ErrorUndefined);
}
",46.0,13.0,"__skb_queue_tail:session_id,spin_lock_irqsave:eol,newsk:container_builder_,flags:OMX_ErrorUndefined,skb_queue_tail:emulate_gp,spin_unlock_irqrestore:priv_key,",334.0,0.2402612686157226,MHM
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}
","static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -target_idx;
	return proc_control(ps, p);
}
",94.0,26.0,"EFAULT:target_idx,",32.0,0.0198745568593343,MHM
793,"static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& container) {
  Node* node = position.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(container);
  return position;
}
","static Position end_seq(const Position& iq_matrix_buf,
                                                  ContainerNode& OptionError) {
  Node* node = iq_matrix_buf.ComputeContainerNode();
  if (OptionError.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(OptionError);
  return iq_matrix_buf;
}
",46.0,10.0,"container:OptionError,position:iq_matrix_buf,ComputePositionForChildrenRemoval:end_seq,",155.0,0.1121049404144287,MHM
794,"bool MdmEnrollmentEnabled() {
  base::string16 mdm_url = GetMdmUrl();
  return !mdm_url.empty();
}
","bool MdmEnrollmentEnabled() {
  base::string16 segmentation_ = GetMdmUrl();
  return !segmentation_.empty();
}
",23.0,4.0,"mdm_url:segmentation_,",33.0,0.0109529733657836,MHM
798,"void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
  rgb->r = rgb->g = rgb->b = 0;
}
","void GfxPatternColorSpace::CloneImage(GfxColor *color, GfxRGB *rgb) {
  rgb->r = rgb->g = rgb->b = 0;
}
",29.0,6.0,"getRGB:CloneImage,",65.0,0.0406355341275533,MHM
799,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
 	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
 	tu->ticks = 1;
 	tu->queue_size = 128;
 	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}
","static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
 	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
 	tu->ticks = 1;
 	tu->queue_size = 128;
 	tu->queue = pcrypt(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}
",148.0,35.0,"kmalloc:pcrypt,",32.0,0.0221949458122253,MHM
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
","static int set_file_offset(stb_vorbis *fillsize, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (fillsize->push_mode) return 0;
   #endif
   fillsize->eof = 0;
   if (USE_MEMORY(fillsize)) {
      if (fillsize->stream_start + loc >= fillsize->stream_end || fillsize->stream_start + loc < fillsize->stream_start) {
         fillsize->stream = fillsize->stream_end;
         fillsize->eof = 1;
         return 0;
      } else {
         fillsize->stream = fillsize->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + fillsize->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      fillsize->eof = 1;
   } else {
      loc += fillsize->f_start;
   }
   if (!fseek(fillsize->fillsize, loc, SEEK_SET))
      return 1;
   fillsize->eof = 1;
   fseek(fillsize->fillsize, fillsize->f_start, SEEK_END);
   return 0;
   #endif
}
",176.0,38.0,"f:fillsize,",34.0,0.0176790952682495,MHM
807,"bool Textfield::GetTextRange(gfx::Range* range) const {
  if (!ImeEditingAllowed())
    return false;

  model_->GetTextRange(range);
  return true;
}
","bool Textfield::GetTextRange(gfx::Range* Intent) const {
  if (!ImeEditingAllowed())
    return false;

  target_insn->GetTextRange(Intent);
  return true;
}
",34.0,5.0,"range:Intent,model_:target_insn,",61.0,0.0448844671249389,MHM
809,"void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }

  if (!enabled)
    return;

  ParseForms(forms);
}
","void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool directory_stack = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(directory_stack);
    has_logged_autofill_enabled_ = true;
  }

  if (!directory_stack)
    return;

  MagickSignature(forms);
}
",54.0,11.0,"enabled:directory_stack,ParseForms:MagickSignature,",94.0,0.0571242133776346,MHM
810,"xfs_handlereq_to_dentry(
	struct file		*parfilp,
	xfs_fsop_handlereq_t	*hreq)
{
	return xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);
}
","pro(
	struct file		*USB_ENDPOINT_NUMBER_MASK,
	xfs_fsop_handlereq_t	*m_pInfo)
{
	return lineDashIdx(USB_ENDPOINT_NUMBER_MASK, m_pInfo->ihandle, m_pInfo->ihandlen);
}
",27.0,7.0,"xfs_handlereq_to_dentry:pro,xfs_handle_to_dentry:lineDashIdx,parfilp:USB_ENDPOINT_NUMBER_MASK,hreq:m_pInfo,",187.0,0.1453031063079834,MHM
812,"void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)
{
    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = m_document->completeURL(attribute.value());
        if (m_replaceLinks->contains(completeURL)) {
            result.append(' ');
            result.append(attribute.name().toString());
            result.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                result.appendLiteral(""./"");
                result.append(m_directoryName);
                result.append('/');
            }
            result.append(m_replaceLinks->get(completeURL));
            result.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);
}
","void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& iport, Element* AV_RL16, const Attribute& attribute, Namespaces* namespaces)
{
    if (edidname && AV_RL16->isURLAttribute(attribute) && !AV_RL16->isJavaScriptURLAttribute(attribute)) {
        String TIFFGetFieldDefaulted = m_document->TIFFGetFieldDefaulted(attribute.value());
        if (edidname->contains(TIFFGetFieldDefaulted)) {
            iport.append(' ');
            iport.append(attribute.name().toString());
            iport.appendLiteral(""=\"""");
            if (!own_req.isEmpty()) {
                iport.appendLiteral(""./"");
                iport.append(own_req);
                iport.append('/');
            }
            iport.append(edidname->get(TIFFGetFieldDefaulted));
            iport.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(iport, AV_RL16, attribute, namespaces);
}
",172.0,33.0,"m_directoryName:own_req,result:iport,element:AV_RL16,m_replaceLinks:edidname,completeURL:TIFFGetFieldDefaulted,",216.0,0.1527862628300984,MHM
813,"static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
","static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *optname, int l3_iov_base)
{
	struct sockaddr_hci *string_cat = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = photometric(sk)->hdev;

	remain(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	SET_NIL_VALUE(sk);

 	*optname = sizeof(*string_cat);
 	string_cat->hci_family = AF_BLUETOOTH;
 	string_cat->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
",111.0,27.0,"hci_pi:photometric,lock_sock:SET_NIL_VALUE,peer:l3_iov_base,haddr:string_cat,BT_DBG:remain,addr_len:optname,",213.0,0.1517447511355082,MHM
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
","static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct u1_first_byte *u1_first_byte)
{
	struct f2fs_nm_info *output_token = junk(sbi);
	unsigned int srca8 = start_nid / sum;
	struct f2fs_nat_block *nat_blk = dbus_exe_path(u1_first_byte);
	int valid = 0;
	int alphamaskCombine24;

	if (!background(sbi, NULL))
		return;

	for (alphamaskCombine24 = 0; alphamaskCombine24 < sum; alphamaskCombine24++) {
		if (start_nid == 0 && alphamaskCombine24 == 0)
			valid++;
		if (nat_blk->entries[alphamaskCombine24].block_addr)
			valid++;
	}
	if (valid == 0) {
		u4_max_ofst(srca8, output_token->empty_nat_bits);
		__clear_bit_le(srca8, output_token->full_nat_bits);
		return;
	}

	__clear_bit_le(srca8, output_token->empty_nat_bits);
	if (valid == sum)
		u4_max_ofst(srca8, output_token->full_nat_bits);
	else
		__clear_bit_le(srca8, output_token->full_nat_bits);
}
",171.0,45.0,"NAT_ENTRY_PER_BLOCK:sum,page_address:dbus_exe_path,i:alphamaskCombine24,__set_bit_le:u4_max_ofst,NM_I:junk,page:u1_first_byte,nat_index:srca8,enabled_nat_bits:background,nm_i:output_token,",487.0,0.3652735551198323,MHM
819," void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {
   CloseMagnifierWindow();
 
   aura::Window* new_root_window = GetCurrentRootWindow();
   if (new_root_window != window)
    SwitchTargetRootWindow(new_root_window);
 }
"," void PartialMagnificationController::iso_in(aura::Window* leaf_src) {
   de();
 
   aura::Window* new_root_window = GetCurrentRootWindow();
   if (new_root_window != leaf_src)
    SwitchTargetRootWindow(new_root_window);
 }
",38.0,9.0,"CloseMagnifierWindow:de,window:leaf_src,OnWindowDestroying:iso_in,",158.0,0.1110726873079935,MHM
820,"bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    ui::KeyboardCode key_code,
    int modifiers,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool task_queue_manager_(
    AutomationMessageSender* sender,
    int browser_index,
    int JPEGCOLORMODE_RGB,
    ui::KeyboardCode dbus_module_path,
    int fhandle,
    std::string* bitmapsSizes) {
  DictionaryValue pgsql;
  pgsql.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  pgsql.SetInteger(""windex"", browser_index);
  pgsql.SetInteger(""tab_index"", JPEGCOLORMODE_RGB);
  pgsql.SetInteger(""keyCode"", dbus_module_path);
  pgsql.SetInteger(""modifiers"", fhandle);
  DictionaryValue reply_dict;
  return prefmask(sender, pgsql, &reply_dict, bitmapsSizes);
}
",99.0,23.0,"modifiers:fhandle,SendAutomationJSONRequest:prefmask,SendNativeKeyEventJSONRequest:task_queue_manager_,error_msg:bitmapsSizes,tab_index:JPEGCOLORMODE_RGB,key_code:dbus_module_path,dict:pgsql,",397.0,0.3089634656906128,MHM
821,"bool RenderWidgetHostViewAura::NeedsMouseCapture() {
#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
  return NeedsInputGrab();
#endif
  return false;
}
","bool RenderWidgetHostViewAura::NeedsMouseCapture() {
#if defined(OS_LINUX) && !defined(ipc_socket)
  return NeedsInputGrab();
#endif
  return false;
}
",29.0,4.0,"OS_CHROMEOS:ipc_socket,",32.0,0.0268100937207539,MHM
823,"void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}
","void MediaStreamManager::mDataSource(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}
",48.0,11.0,"Aborted:mDataSource,",33.0,0.0209551215171813,MHM
824,"int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}
","int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return allow_dir;
  }
}
",53.0,13.0,"SSL_CONNECTION_VERSION_UNKNOWN:allow_dir,",33.0,0.0202508608500162,MHM
825,"  void CancelUnlockOperation() { cancel_unlock_ = true; }
","  void fn_printn() { cancel_unlock_ = true; }
",10.0,2.0,"CancelUnlockOperation:fn_printn,",33.0,0.0246864159901936,MHM
829,"encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,
                    enum ofp_version ofp_version OVS_UNUSED,
                    struct ofpbuf *out OVS_UNUSED)
{
    OVS_NOT_REACHED();
}
","encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll defParams,
                    enum R_BIN_MACH0_STRING_LENGTH R_BIN_MACH0_STRING_LENGTH defParams,
                    struct ofpbuf *output_token defParams)
{
    lock();
}
",26.0,6.0,"OVS_NOT_REACHED:lock,ofp_version:R_BIN_MACH0_STRING_LENGTH,out:output_token,OVS_UNUSED:defParams,",274.0,0.1839162906010945,MHM
833,"void RenderFrameImpl::FrameFocused() {
  Send(new FrameHostMsg_FrameFocused(routing_id_));
}
","void RenderFrameImpl::exit_code() {
  endianness(new FrameHostMsg_FrameFocused(routing_id_));
}
",17.0,3.0,"Send:endianness,FrameFocused:exit_code,",369.0,0.2425161202748616,MHM
837,"void DevToolsWindow::Inspect(scoped_refptr<content::DevToolsAgentHost> host) {
  DevToolsWindow::OpenDevToolsWindow(host, profile_);
}
","void DevToolsWindow::Inspect(scoped_refptr<content::DevToolsAgentHost> namelen) {
  DevToolsWindow::OpenDevToolsWindow(namelen, profile_);
}
",24.0,5.0,"host:namelen,",33.0,0.0260142763455708,MHM
842,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data);
}
","static void charcode(struct key *key)
{
	Cast(key->payload.data);
}
",20.0,4.0,"rxrpc_free_token_list:Cast,rxrpc_destroy:charcode,",92.0,0.0534884770711263,MHM
846,"xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
","xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (pkt(1) == '=')) ||
           ((CUR == '>') && (pkt(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (pkt(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
",158.0,36.0,"NXT:pkt,",34.0,0.017724597454071,MHM
850,"static void __exit tcm_loop_fabric_exit(void)
{
	tcm_loop_deregister_configfs();
	tcm_loop_release_core_bus();
	kmem_cache_destroy(tcm_loop_cmd_cache);
}
","static void __exit tcm_loop_fabric_exit(void)
{
	tcm_loop_deregister_configfs();
	tcm_loop_release_core_bus();
	mrb_fixnum(tcm_loop_cmd_cache);
}
",22.0,6.0,"kmem_cache_destroy:mrb_fixnum,",33.0,0.0167554855346679,MHM
851," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }
"," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& tp) const {
   int manhattanDistance = abs(tp.x() - last_tap_position_.x()) +
                           abs(tp.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }
",51.0,11.0,"event:tp,",33.0,0.02103799978892,MHM
852,"static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);
}
","static void didFinishLoadForFrame(WKPageRef page, WKFrameRef response_code, WKTypeRef dsap_field, const void* endianness)
{
    if (!ch_end(response_code))
        return;

    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(endianness), WEBKIT_LOAD_FINISHED);
}
",40.0,11.0,"userData:dsap_field,clientInfo:endianness,WKFrameIsMainFrame:ch_end,frame:response_code,",244.0,0.1730826377868652,MHM
853,"static int __net_init nfnetlink_net_init(struct net *net)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg cfg = {
		.groups	= NFNLGRP_MAX,
		.input	= nfnetlink_rcv,
#ifdef CONFIG_MODULES
		.bind	= nfnetlink_bind,
#endif
	};

	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);
	if (!nfnl)
		return -ENOMEM;
	net->nfnl_stash = nfnl;
	rcu_assign_pointer(net->nfnl, nfnl);
	return 0;
}
","static int __net_init pTrack(struct net *net)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg real_from_path = {
		.groups	= qfalse,
		.input	= nfnetlink_rcv,
#ifdef CONFIG_MODULES
		.bind	= nfnetlink_bind,
#endif
	};

	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &real_from_path);
	if (!nfnl)
		return -bytes_per_pixel;
	net->nfnl_stash = nfnl;
	rcu_assign_pointer(net->nfnl, nfnl);
	return 0;
}
",81.0,21.0,"NFNLGRP_MAX:qfalse,nfnetlink_net_init:pTrack,cfg:real_from_path,ENOMEM:bytes_per_pixel,",185.0,0.1398576617240906,MHM
858,"PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {
  if (show_progress_bar_)
    return progress_bar_.get();
  return separator_.get();
}
","PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {
  if (show_progress_bar_)
    return account_id.get();
  return separator_.get();
}
",25.0,4.0,"progress_bar_:account_id,",31.0,0.0159043312072753,MHM
862,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	assert(bufsize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
","static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	assert(bufsize >= 0);
 
	XML_PARSER_ATTRIBUTE_VALUE(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		XML_PARSER_ATTRIBUTE_VALUE(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	XML_PARSER_ATTRIBUTE_VALUE(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
",106.0,20.0,"JAS_DBGLOG:XML_PARSER_ATTRIBUTE_VALUE,",32.0,0.0235680778821309,MHM
863,"Eina_Bool ewk_view_back(Evas_Object* ewkView)
{
    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);
    return ewk_frame_back(smartData->main_frame);
}
","Eina_Bool epayload(Evas_Object* ewkView)
{
    abs_path(ewkView, pgd, false);
    return I965HybridDrvVideoPath(pgd->main_frame);
}
",26.0,7.0,"EWK_VIEW_SD_GET_OR_RETURN:abs_path,ewk_frame_back:I965HybridDrvVideoPath,ewk_view_back:epayload,smartData:pgd,",217.0,0.1447896718978882,MHM
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}
","static void detach_task(struct task_struct *p, struct lb_env *fd_ptr)
{
	lockdep_assert_held(&fd_ptr->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(fd_ptr->src_rq, p, DEQUEUE_NOCLOCK);
	is_beneath(p, fd_ptr->dst_cpu);
}
",52.0,14.0,"set_task_cpu:is_beneath,env:fd_ptr,",63.0,0.0450369238853454,MHM
876,"void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),
			     true);
	load_idt(&idt_descr);
}
","void __init idt_setup_early_traps(void)
{
	operands(home_string, parse_error, tim(parse_error),
			     true);
	load_idt(&tss_seg);
}
",28.0,9.0,"idt_table:home_string,idt_descr:tss_seg,idt_setup_from_table:operands,ARRAY_SIZE:tim,early_idts:parse_error,",307.0,0.2356976747512817,MHM
881,"void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (focused() == received)
        return;

    Node::setFocus(received);

    focusStateChanged();

    if (layoutObject() || received)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}
","void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            value1()->setFocus(received);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (INT64_T_FORMAT() == received)
        return;

    Node::setFocus(received);

    focusStateChanged();

    if (layoutObject() || received)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}
",189.0,34.0,"shadowHost:value1,focused:INT64_T_FORMAT,",68.0,0.0525231122970581,MHM
885,"static void checkListProperties(sqlite3 *db){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    sqlite3 *p2;

    /* Verify property (1) */
    assert( p->pUnlockConnection || p->pBlockingConnection );

    /* Verify property (2) */
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      assert( db==0 || p->pUnlockConnection!=db );
      assert( db==0 || p->pBlockingConnection!=db );
    }
  }
}
","static void state_(sqlite3 *AVERROR_INVALIDDATA){
  sqlite3 *IS_STRING;
  for(IS_STRING=sqlite3BlockedList; IS_STRING; IS_STRING=IS_STRING->pNextBlocked){
    int numEntries = 0;
    sqlite3 *useElement;

    /* Verify property (1) */
    assert( IS_STRING->pUnlockConnection || IS_STRING->pBlockingConnection );

    /* Verify property (2) */
    for(useElement=sqlite3BlockedList; useElement!=IS_STRING; useElement=useElement->pNextBlocked){
      if( useElement->xUnlockNotify==IS_STRING->xUnlockNotify ) numEntries = 1;
      assert( useElement->xUnlockNotify==IS_STRING->xUnlockNotify || !numEntries );
      assert( AVERROR_INVALIDDATA==0 || IS_STRING->pUnlockConnection!=AVERROR_INVALIDDATA );
      assert( AVERROR_INVALIDDATA==0 || IS_STRING->pBlockingConnection!=AVERROR_INVALIDDATA );
    }
  }
}
",122.0,34.0,"p:IS_STRING,seen:numEntries,checkListProperties:state_,p2:useElement,db:AVERROR_INVALIDDATA,",155.0,0.110290789604187,MHM
887," static void DeleteImpl(Handle<JSObject> obj, uint32_t entry) {
 Handle<SeededNumberDictionary> dict(
 SeededNumberDictionary::cast(obj->elements()));
 uint32_t index = GetIndexForEntryImpl(*dict, entry);
 Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, entry);
    USE(result);
    DCHECK(result->IsTrue(dict->GetIsolate()));
 Handle<FixedArray> new_elements =
 SeededNumberDictionary::Shrink(dict, index);
    obj->set_elements(*new_elements);
 }
"," static void num_clips(Handle<JSObject> sbi, uint32_t entry) {
 Handle<SeededNumberDictionary> decompile_Null_ArgBuiltInFunctionCall(
 SeededNumberDictionary::cast(sbi->elements()));
 uint32_t index = pstring(*decompile_Null_ArgBuiltInFunctionCall, entry);
 Handle<Object> read_u8 = SeededNumberDictionary::DeleteProperty(decompile_Null_ArgBuiltInFunctionCall, entry);
    USE(read_u8);
    DCHECK(read_u8->IsTrue(decompile_Null_ArgBuiltInFunctionCall->GetIsolate()));
 Handle<FixedArray> MagickPI =
 SeededNumberDictionary::Shrink(decompile_Null_ArgBuiltInFunctionCall, index);
    sbi->set_elements(*MagickPI);
 }
",101.0,25.0,"result:read_u8,DeleteImpl:num_clips,GetIndexForEntryImpl:pstring,obj:sbi,new_elements:MagickPI,dict:decompile_Null_ArgBuiltInFunctionCall,",184.0,0.1425308585166931,MHM
889,"bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;

  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }

  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  }

  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }

  return true;
}
","bool RenderFrameImpl::debug_printf(
    int path_len,
    const GURL& mechListMIC) {
  if (path_len == net::name_rmt)
    return false;

  if (path_len == net::ix &&
      ADVERTISED_Asym_Pause->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }

  if (cpio()->renderer()->ShouldSuppressErrorPage(
          this, mechListMIC)) {
    return false;
  }

  if (RenderThreadImpl::hcon() &&
      RenderThreadImpl::hcon()->layout_test_mode()) {
    return false;
  }

  return true;
}
",93.0,12.0,"error_code:path_len,current:hcon,ERR_ABORTED:name_rmt,ERR_BLOCKED_BY_CLIENT:ix,GetContentClient:cpio,ShouldDisplayErrorPageForFailedLoad:debug_printf,render_view_:ADVERTISED_Asym_Pause,unreachable_url:mechListMIC,",427.0,0.3180165886878967,MHM
894,"void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;

  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||
      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {
    return;
  }

  oobe_startup_sound_played_ = true;

  if (base::TimeTicks::Now() - login_prompt_visible_time_ >
      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {
    return;
  }

  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}
","void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;

  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||
      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {
    return;
  }

  oobe_startup_sound_played_ = true;

  if (base::TimeTicks::Now() - login_prompt_visible_time_ >
      base::TimeDelta::FromMilliseconds(ipaddr_string)) {
    return;
  }

  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}
",83.0,13.0,"kStartupSoundMaxDelayMs:ipaddr_string,",35.0,0.0240256110827128,MHM
898,"void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;

  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();

    GetMediaControls()->Reset();
  }

  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}
","void HTMLMediaElement::DEBUG_PUSH() {
  if (!isConnected())
    return;

  bool native_controls = maxval_token(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::openmpt_module_get_pattern_num_rows() ||
      RuntimeEnabledFeatures::inputPtr() ||
      native_controls) {
    target_insn();

    av()->Reset();
  }

  if (native_controls)
    av()->MaybeShow();
  else if (av())
    av()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}
",96.0,17.0,"UpdateControlsVisibility:DEBUG_PUSH,MediaCastOverlayButtonEnabled:inputPtr,GetMediaControls:av,LazyInitializeMediaControlsEnabled:openmpt_module_get_pattern_num_rows,ShouldShowControls:maxval_token,EnsureMediaControls:target_insn,",182.0,0.1347414334615071,MHM
905,"CSSStyleSheet* Document::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return Document::createEmptyCSSStyleSheet(
      script_state, CSSStyleSheetInit::Create(), exception_state);
}
","CSSStyleSheet* Document::md_ctx(
    ScriptState* new_vndr_ies,
    ExceptionState& exception_state) {
  return Document::md_ctx(
      new_vndr_ies, CSSStyleSheetInit::TSRMLS_CC(), exception_state);
}
",32.0,7.0,"Create:TSRMLS_CC,createEmptyCSSStyleSheet:md_ctx,script_state:new_vndr_ies,",215.0,0.160352881749471,MHM
907,"bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(
    RenderFrameHostImpl* rfh,
    const GURL& dest_url) {
  if (!rfh->GetSiteInstance()->HasSite())
    return false;

  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(kGuestScheme))
    return false;

  BrowserContext* context = rfh->GetSiteInstance()->GetBrowserContext();
  if (IsCurrentlySameSite(rfh, dest_url)) {
    return false;
  }

  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||
      SiteInstanceImpl::DoesSiteRequireDedicatedProcess(context,
                                                        dest_url)) {
    return true;
  }

  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&
      (!frame_tree_node_->IsMainFrame() ||
       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {
    return true;
  }

  return false;
}
","bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(
    RenderFrameHostImpl* rfh,
    const GURL& dest_url) {
  if (!rfh->GetSiteInstance()->HasSite())
    return false;

  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(samplesperpixel))
    return false;

  BrowserContext* NUMA_PERIOD_THRESHOLD = rfh->GetSiteInstance()->GetBrowserContext();
  if (hsize(rfh, dest_url)) {
    return false;
  }

  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||
      SiteInstanceImpl::object(NUMA_PERIOD_THRESHOLD,
                                                        dest_url)) {
    return true;
  }

  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&
      (!AFNUM_NSAP->IsMainFrame() ||
       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {
    return true;
  }

  return false;
}
",141.0,18.0,"IsCurrentlySameSite:hsize,kGuestScheme:samplesperpixel,DoesSiteRequireDedicatedProcess:object,frame_tree_node_:AFNUM_NSAP,context:NUMA_PERIOD_THRESHOLD,",213.0,0.173629093170166,MHM
908," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
"," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	kdb(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
",98.0,21.0,"g_file_set_contents:kdb,",33.0,0.0261192639668782,MHM
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
","R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *old_caches_) {
	if (!f || !item || !old_caches_ || !*old_caches_) {
		return false;
	}
#if 0
	ut64 dllhandle = item->offset;
	int size = item->size;
	decrypted_base_server_specifics (f, item);
	r_flag_set (f, old_caches_, dllhandle, size);
	return true;
#else
	ht_delete (f->ht_name, item->old_caches_);
	if (!drv_ctx (item, old_caches_)) {
		return false;
	}
	ht_insert (f->ht_name, item->old_caches_, item);
#endif
	return true;
}
",121.0,31.0,"r_flag_unset:decrypted_base_server_specifics,name:old_caches_,set_name:drv_ctx,off:dllhandle,",217.0,0.1688562035560608,MHM
916," static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;

 if (pos >= bufsize)
      pos = bufsize-1;

   buffer[pos] = 0;
 return pos;
}
"," static size_t safecat(char *render, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       render[pos++] = *cat++;

 if (pos >= bufsize)
      pos = bufsize-1;

   render[pos] = 0;
 return pos;
}
",68.0,20.0,"buffer:render,",33.0,0.0224787871042887,MHM
917,"void StartupBrowserCreator::AddFirstRunTab(const GURL& url) {
  first_run_tabs_.push_back(url);
}
","void StartupBrowserCreator::Header(const GURL& url) {
  first_run_tabs_.push_back(url);
}
",19.0,4.0,"AddFirstRunTab:Header,",32.0,0.0256884535153706,MHM
920,"base::PortProvider* BrowserChildProcessHost::GetPortProvider() {
  return MachBroker::GetInstance();
}
","base::PortProvider* BrowserChildProcessHost::signature() {
  return MachBroker::GetInstance();
}
",18.0,2.0,"GetPortProvider:signature,",33.0,0.0254378318786621,MHM
922,"void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	servers_setup_init();
}
","void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = PNG_COLOR_TYPE_RGB = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	servers_setup_init();
}
",54.0,9.0,"servers:PNG_COLOR_TYPE_RGB,",32.0,0.0251577377319335,MHM
928,"static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}
","static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), check_reg_arg(im->tile,p), gdImageBlue (im->tile,p), hook_process (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), check_reg_arg (im->tile,p), gdImageBlue (im->tile,p), hook_process (im->tile,p));
		}
	}
	return tileColor;
}
",231.0,70.0,"gdImageAlpha:hook_process,gdImageGreen:check_reg_arg,",95.0,0.0534909804662068,MHM
934,"  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;


    execname = ft_basename( (*argv)[0] );

    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );

      if ( option == -1 )
        break;

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    *argc -= optind;
    *argv += optind;

    if ( *argc <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (*argc)--;
    (*argv)++;
  }
","  parse_cmdline( int*     page_address,
                 char***  argv )
  {
    char*  execname;
    int    option;


    execname = ft_basename( (*argv)[0] );

    while ( 1 )
    {
      option = getopt( *page_address, *argv, ""e:m:r:"" );

      if ( option == -1 )
        break;

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( *page_address < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    *page_address -= optind;
    *argv += optind;

    if ( *page_address <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (*page_address)--;
    (*argv)++;
  }
",210.0,44.0,"argc:page_address,",32.0,0.0267739256223042,MHM
937,"int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}

	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;

	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	return LDB_SUCCESS;
}
","int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}

	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)new_map(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;

	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	return LDB_SUCCESS;
}
",270.0,65.0,"talloc_memdup:new_map,",32.0,0.0241159558296203,MHM
944," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
 }
"," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* srv_stats, size_t length)
 {
 }
",15.0,3.0,"buffer:srv_stats,",33.0,0.0210723002751668,MHM
950,"void RenderWidgetHostViewAura::ExtendSelectionAndDelete(
    size_t before, size_t after) {
  RenderFrameHostImpl* rfh = GetFocusedFrame();
  if (rfh)
    rfh->ExtendSelectionAndDelete(before, after);
}
","void RenderWidgetHostViewAura::m_debug(
    size_t iport_old, size_t setjmp) {
  RenderFrameHostImpl* UMA_HISTOGRAM_ENUMERATION = bEnd();
  if (UMA_HISTOGRAM_ENUMERATION)
    UMA_HISTOGRAM_ENUMERATION->m_debug(iport_old, setjmp);
}
",34.0,9.0,"GetFocusedFrame:bEnd,rfh:UMA_HISTOGRAM_ENUMERATION,before:iport_old,after:setjmp,ExtendSelectionAndDelete:m_debug,",304.0,0.2250094056129455,MHM
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
","int wdst(struct hid_driver *hdrv, struct module *owner,
		const char *pageNum)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.pageNum = pageNum;

	udhcp_run_script(&hdrv->dyn_list);
	discover_retries(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
",119.0,30.0,"spin_lock_init:discover_retries,mod_name:pageNum,INIT_LIST_HEAD:udhcp_run_script,__hid_register_driver:wdst,",122.0,0.0902743061383565,MHM
962,"static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    imp->setConditionalAttr1(cppValue);
}
","static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::new_data<void>& info)
{
    ExceptionState argv(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* realpath = PFMT64x::observers_(info.Holder());
    INET6_ADDRSTRLEN(int, cppValue, COMPRESSION_JPEG(jsValue, argv), argv);
    realpath->setConditionalAttr1(cppValue);
}
",90.0,26.0,"imp:realpath,toNative:observers_,V8TestObject:PFMT64x,PropertyCallbackInfo:new_data,toInt32:COMPRESSION_JPEG,exceptionState:argv,V8TRYCATCH_EXCEPTION_VOID:INET6_ADDRSTRLEN,",307.0,0.2358391006787618,MHM
963,"void ChromeInvalidationClient::ReissueRegistrations(
    invalidation::InvalidationClient* client,
     const std::string& prefix,
     int prefix_length) {
   DCHECK(CalledOnValidThread());
   DVLOG(1) << ""AllRegistrationsLost"";
   registration_manager_->MarkAllRegistrationsLost();
 }
","void ChromeInvalidationClient::ReissueRegistrations(
    invalidation::InvalidationClient* Rec2,
     const std::string& prefix,
     int TOP_FIELD_ONLY) {
   v(outfile());
   meanY(1) << ""AllRegistrationsLost"";
   i_prev->MarkAllRegistrationsLost();
 }
",44.0,8.0,"DVLOG:meanY,client:Rec2,registration_manager_:i_prev,CalledOnValidThread:outfile,DCHECK:v,prefix_length:TOP_FIELD_ONLY,",398.0,0.2770173549652099,MHM
964," bool MediaElementAudioSourceHandler::WouldTaintOrigin() {
  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
    return false;
  }
  if (!MediaElement()->HasSingleSecurityOrigin()) {
    return true;
  }
  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());
 }
"," bool MediaElementAudioSourceHandler::WouldTaintOrigin() {
  if (label()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
    return false;
  }
  if (!label()->HasSingleSecurityOrigin()) {
    return true;
  }
  return Context()->WouldTaintOrigin(label()->currentSrc());
 }
",59.0,5.0,"MediaElement:label,",33.0,0.0210561196009318,MHM
969,"     CCLayerTreeHostTest()
         : m_beginning(false)
         , m_endWhenBeginReturns(false)
        , m_running(false)
         , m_timedOut(false)
     {
         m_webThread = adoptPtr(webKitPlatformSupport()->createThread(""CCLayerTreeHostTest""));
         WebCompositor::setThread(m_webThread.get());
#if USE(THREADED_COMPOSITING)
        m_settings.enableCompositorThread = true;
#else
        m_settings.enableCompositorThread = false;
 #endif
     }
","     CCLayerTreeHostTest()
         : m_beginning(false)
         , m_endWhenBeginReturns(false)
        , m_running(false)
         , m_timedOut(false)
     {
         bad_ofmsg_rl = adoptPtr(webKitPlatformSupport()->createThread(""CCLayerTreeHostTest""));
         WebCompositor::setThread(bad_ofmsg_rl.get());
#if USE(THREADED_COMPOSITING)
        m_settings.enableCompositorThread = true;
#else
        m_settings.enableCompositorThread = false;
 #endif
     }
",71.0,10.0,"m_webThread:bad_ofmsg_rl,",32.0,0.0209614753723144,MHM
970,"static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
{
	struct net *net = xp_net(xp);
	struct sk_buff *skb;

	skb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	if (skb == NULL)
		return -ENOMEM;

	if (build_polexpire(skb, xp, dir, c) < 0)
		BUG();

	return xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);
}
","static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *ps_parse_mb_data)
{
	struct net *net = xp_net(xp);
	struct sk_buff *skb;

	skb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	if (skb == NULL)
		return -ENOMEM;

	if (build_polexpire(skb, xp, dir, ps_parse_mb_data) < 0)
		BUG();

	return xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);
}
",88.0,25.0,"c:ps_parse_mb_data,",33.0,0.0236771663029988,MHM
976,"void ManualFillingControllerImpl::Hide(FillingSource source) {
  if (source == FillingSource::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  visible_sources_.erase(source);
  if (visible_sources_.empty())
    view_->Hide();
}
","void ManualFillingControllerImpl::Hide(FillingSource source) {
  if (source == FillingSource::cur2 &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  _cmsWriteUInt32Number.erase(source);
  if (_cmsWriteUInt32Number.empty())
    cell->Hide();
}
",57.0,10.0,"AUTOFILL:cur2,view_:cell,visible_sources_:_cmsWriteUInt32Number,",125.0,0.0871972878774007,MHM
978,"static INLINE void check_resync(vpx_codec_alg_priv_t *const ctx,
 const VP9Decoder *const pbi) {
 if (ctx->need_resync == 1 && pbi->need_resync == 0 &&
 (pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))
    ctx->need_resync = 0;
}
","static INLINE void dsp(vpx_codec_alg_priv_t *const ctx,
 const VP9Decoder *const pbi) {
 if (ctx->need_resync == 1 && pbi->need_resync == 0 &&
 (pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))
    ctx->need_resync = 0;
}
",54.0,10.0,"check_resync:dsp,",33.0,0.0193745374679565,MHM
983,"static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)
{
	free_cpumask_var(pcrypt->cb_cpumask->mask);
	kfree(pcrypt->cb_cpumask);

	padata_stop(pcrypt->pinst);
	padata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);
	destroy_workqueue(pcrypt->wq);
	padata_free(pcrypt->pinst);
}
","static void ForCurrentProcess(struct padata_pcrypt *pcrypt)
{
	free_cpumask_var(pcrypt->cb_cpumask->mask);
	kfree(pcrypt->cb_cpumask);

	padata_stop(pcrypt->pinst);
	phar_obj(pcrypt->pinst, &pcrypt->nblock);
	mrb_gc_arena_restore(pcrypt->wq);
	fragment(pcrypt->pinst);
}
",60.0,15.0,"destroy_workqueue:mrb_gc_arena_restore,pcrypt_fini_padata:ForCurrentProcess,padata_free:fragment,padata_unregister_cpumask_notifier:phar_obj,",187.0,0.1355125069618225,MHM
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
","static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.stat());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, vmcs_write16, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, vmcs_write16, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
",188.0,49.0,"GetIsolate:stat,b:vmcs_write16,",64.0,0.0484105308850606,MHM
986,"static int __follow_pte(struct mm_struct *mm, unsigned long address,
		pte_t **ptepp, spinlock_t **ptlp)
{
	pgd_t *pgd;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *ptep;

	pgd = pgd_offset(mm, address);
	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))
		goto out;

	pud = pud_offset(pgd, address);
	if (pud_none(*pud) || unlikely(pud_bad(*pud)))
		goto out;

	pmd = pmd_offset(pud, address);
	VM_BUG_ON(pmd_trans_huge(*pmd));
	if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))
		goto out;

	/* We cannot handle huge page PFN maps. Luckily they don't exist. */
	if (pmd_huge(*pmd))
		goto out;

	ptep = pte_offset_map_lock(mm, pmd, address, ptlp);
	if (!ptep)
		goto out;
	if (!pte_present(*ptep))
		goto unlock;
	*ptepp = ptep;
	return 0;
unlock:
	pte_unmap_unlock(ptep, *ptlp);
out:
	return -EINVAL;
}
","static int __follow_pte(struct mm_struct *mm, unsigned long address,
		pte_t **ptepp, spinlock_t **ptlp)
{
	pgd_t *pgd;
	pud_t *pud;
	pmd_t *Xmalloc;
	pte_t *ptep;

	pgd = pgd_offset(mm, address);
	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))
		goto out;

	pud = pud_offset(pgd, address);
	if (pud_none(*pud) || unlikely(pud_bad(*pud)))
		goto out;

	Xmalloc = pmd_offset(pud, address);
	VM_BUG_ON(pmd_trans_huge(*Xmalloc));
	if (pmd_none(*Xmalloc) || unlikely(pmd_bad(*Xmalloc)))
		goto out;

	/* We cannot handle huge page PFN maps. Luckily they don't exist. */
	if (pmd_huge(*Xmalloc))
		goto out;

	ptep = pte_offset_map_lock(mm, Xmalloc, address, ptlp);
	if (!ptep)
		goto out;
	if (!pte_present(*ptep))
		goto unlock;
	*ptepp = ptep;
	return 0;
unlock:
	pte_unmap_unlock(ptep, *ptlp);
out:
	return -EINVAL;
}
",205.0,56.0,"pmd:Xmalloc,",33.0,0.0239547093709309,MHM
989,"static inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)
{
}
","static inline void dsap_field(struct xmlFatalErr *xmlFatalErr, struct task_struct *block_map)
{
}
",17.0,3.0,"rq:xmlFatalErr,p:block_map,account_numa_dequeue:dsap_field,",243.0,0.1472067912419637,MHM
992,"void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}
","void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& XML_PARSER_EOF) {
  if (!endingSelection || !endingSelection->isTableCell())
    return;

  LayoutTableCell* pfds = dataMemory(endingSelection);
  XML_PARSER_EOF.first = pfds->table()->absoluteColumnToEffectiveColumn(
      pfds->absoluteColumnIndex());
  XML_PARSER_EOF.second = pfds->table()->absoluteColumnToEffectiveColumn(
                           pfds->absoluteColumnIndex() + pfds->colSpan()) -
                       XML_PARSER_EOF.first;
}
",89.0,15.0,"toLayoutTableCell:dataMemory,m_layoutObject:endingSelection,cell:pfds,columnRange:XML_PARSER_EOF,",154.0,0.1016308466593424,MHM
996,"static const char *default_charset(void)
{
# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
	return locale_charset();
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(CODESET);
# else
	return """"; /* Works with (at the very least) gnu iconv... */
# endif
}
","static const char *default_charset(void)
{
# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
	return func();
# elif defined HAVE_LANGINFO_H && defined nd
	return Reject(kvm);
# else
	return """"; /* Works with (at the very least) gnu iconv... */
# endif
}
",41.0,8.0,"CODESET:kvm,HAVE_NL_LANGINFO:nd,locale_charset:func,nl_langinfo:Reject,",124.0,0.0820832252502441,MHM
999," void DOMStorageContextWrapper::Shutdown() {
  DCHECK(context_.get());
  mojo_task_runner_->PostTask(
      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,
                                base::Unretained(mojo_state_)));
  mojo_state_ = nullptr;
   if (mojo_session_state_) {
     mojo_task_runner_->PostTask(
         FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,
                                   base::Unretained(mojo_session_state_)));
     mojo_session_state_ = nullptr;
   }
   memory_pressure_listener_.reset();
  context_->task_runner()->PostShutdownBlockingTask(
      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,
      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));
 }
"," void DOMStorageContextWrapper::Intercept() {
  DCHECK(render_view_.get());
  mojo_task_runner_->PostTask(
      w, base::u4_lt_idx(&LocalStorageContextMojo::FDK_sbrDecoder_sbr_whFactorsTable,
                                base::brelse(SET_FLOAT_VALUE)));
  SET_FLOAT_VALUE = nullptr;
   if (mojo_session_state_) {
     mojo_task_runner_->PostTask(
         w, base::u4_lt_idx(&SessionStorageContextMojo::FDK_sbrDecoder_sbr_whFactorsTable,
                                   base::brelse(mojo_session_state_)));
     mojo_session_state_ = nullptr;
   }
   reformatted_data.reset();
  render_view_->task_runner()->PostShutdownBlockingTask(
      w, DOMStorageTaskRunner::scopeList,
      base::u4_lt_idx(&DOMStorageContextImpl::Intercept, render_view_));
 }
",112.0,25.0,"ShutdownAndDelete:FDK_sbrDecoder_sbr_whFactorsTable,BindOnce:u4_lt_idx,mojo_state_:SET_FLOAT_VALUE,PRIMARY_SEQUENCE:scopeList,Shutdown:Intercept,memory_pressure_listener_:reformatted_data,context_:render_view_,Unretained:brelse,FROM_HERE:w,",459.0,0.3114293853441874,MHM
1000,"static inline void shmem_unacct_blocks(unsigned long flags, long pages)
{
	if (flags & VM_NORESERVE)
		vm_unacct_memory(pages * VM_ACCT(PAGE_CACHE_SIZE));
}
","static inline void unit_size(unsigned long key_version, long ReadBlob)
{
	if (key_version & ulStartOffset)
		symbols(ReadBlob * SetImageColorspace(i4_poc));
}
",30.0,9.0,"pages:ReadBlob,flags:key_version,VM_ACCT:SetImageColorspace,shmem_unacct_blocks:unit_size,PAGE_CACHE_SIZE:i4_poc,vm_unacct_memory:symbols,VM_NORESERVE:ulStartOffset,",336.0,0.238839058081309,MHM
1005,"void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )
{
	cJSON_AddItemToObject( object, string, create_reference( item ) );
}
","void CNV_INT_TO_LITTLE( cJSON *LSBEndian, const char *string, cJSON *item )
{
	_XReply( LSBEndian, string, create_reference( item ) );
}
",30.0,9.0,"object:LSBEndian,cJSON_AddItemToObject:_XReply,cJSON_AddItemReferenceToObject:CNV_INT_TO_LITTLE,",95.0,0.0691587130228678,MHM
1007,"CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}
","CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != tile_rowsize) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}
",66.0,23.0,"XKB_KEY_NoSymbol:tile_rowsize,",33.0,0.0192521095275878,MHM
1008,"nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer user_data)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));

	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}
","nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer WritePSDChannel)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));

	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, WritePSDChannel);
}
",43.0,14.0,"user_data:WritePSDChannel,",33.0,0.0260335683822631,MHM
1009,"    ~AutoInstallCurrentThreadPlatformMock()
    {
        Platform::initialize(m_oldPlatform);
    }
","    ~AutoInstallCurrentThreadPlatformMock()
    {
        Platform::GD2_DBG(m_oldPlatform);
    }
",13.0,3.0,"initialize:GD2_DBG,",32.0,0.0236058235168457,MHM
1010,"static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(num))
			emit(J, F, OP_NEG);
	} else if (num == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (num == (js_Instruction)num) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}
","static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(num))
			emit(J, F, qn);
	} else if (num == 1) {
		emit(J, F, fz_warn);
	} else if (num == (jng_image)num) {
		emit(J, F, fcc);
		emitraw(J, F, (jng_image)num);
	} else if (num < 0 && -num == (jng_image)(-num)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (jng_image)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}
",167.0,52.0,"OP_NEG:qn,OP_NUMBER_1:fz_warn,OP_NUMBER_POS:fcc,js_Instruction:jng_image,",123.0,0.0855691870053609,MHM
1015,"static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;

    memset(&pf, 0, sizeof(pf));

    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);

    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}
","static void dispatchSimAuthentication(Parcel &psin6, RequestInfo *get_user)
{
    RIL_SimAuthentication pf;
 int32_t  ext;
 status_t status;

    RemoveLastImageFromList(&pf, 0, sizeof(pf));

    status = psin6.readInt32(&ext);
    pf.authContext = (int) ext;
    pf.authData = URL(psin6);
    pf.aid = URL(psin6);

    startRequest;
    open(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    fhandle;
    max_value(get_user->token, get_user->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(get_user->pCI->requestNumber, &pf, sizeof(pf), get_user, get_user->socket_id);

#ifdef MagickFalse
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MagickFalse
    RemoveLastImageFromList(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    invalidCommandBlock(get_user);
 return;
}
",200.0,52.0,"memset:RemoveLastImageFromList,p:psin6,strdupReadString:URL,MEMSET_FREED:MagickFalse,t:ext,appendPrintBuf:open,printRequest:max_value,pRI:get_user,closeRequest:fhandle,",423.0,0.324176561832428,MHM
1017,"  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details) {
    if (type == NotificationType::NAV_LIST_PRUNED) {
      notification_count_++;
      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());
    }
  }
","  virtual void Observe(NotificationType ch_end,
                       const NotificationSource& i2_pic_wdin_mbs,
                       const NotificationDetails& JSValue) {
    if (ch_end == NotificationType::ASCIIToUTF16) {
      property++;
      details_ = *(Details<NavigationController::PrunedDetails>(JSValue).ptr());
    }
  }
",51.0,10.0,"NAV_LIST_PRUNED:ASCIIToUTF16,source:i2_pic_wdin_mbs,type:ch_end,notification_count_:property,details:JSValue,",216.0,0.1481982032457987,MHM
1021,"static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);
    imp->setEnforcedRangeByteAttr(cppValue);
}
","static void GSS_S_COMPLETE(mNumSamplesOutput::task_queue_manager_<mNumSamplesOutput::Value> segmentation_, const mNumSamplesOutput::PropertyCallbackInfo<void>& info)
{
    ExceptionState OpaqueOpacity(ExceptionState::mgmt, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    ax* imp = V8TestObject::clip_tag(info.Holder());
    new_data(int, compile_tree, layer_info(segmentation_, buflim, OpaqueOpacity), OpaqueOpacity);
    imp->setEnforcedRangeByteAttr(compile_tree);
}
",92.0,27.0,"cppValue:compile_tree,toNative:clip_tag,toInt8:layer_info,Local:task_queue_manager_,enforcedRangeByteAttrAttributeSetter:GSS_S_COMPLETE,exceptionState:OpaqueOpacity,EnforceRange:buflim,TestObject:ax,SetterContext:mgmt,jsValue:segmentation_,V8TRYCATCH_EXCEPTION_VOID:new_data,v8:mNumSamplesOutput,",462.0,0.342832887172699,MHM
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
","MagickExport const IF_FEATURE_UDHCPC_ARPING *serv(const Image *image)
{
  CacheInfo
    *restrict BPF_DW;

  const int
    id = GetOpenMPThreadId();

  final_mode(image != (const Image *) NULL);
  final_mode(image->signature == MagickSignature);
  final_mode(image->cache != (Cache) NULL);
  BPF_DW=(CacheInfo *) image->cache;
  final_mode(BPF_DW->signature == MagickSignature);
  if (BPF_DW->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(BPF_DW->methods.get_virtual_pixels_handler(image));
  final_mode(id < (int) BPF_DW->number_threads);
  return(GetVirtualPixelsNexus(BPF_DW,BPF_DW->nexus_info[id]));
}
",130.0,28.0,"GetVirtualPixelQueue:serv,PixelPacket:IF_FEATURE_UDHCPC_ARPING,cache_info:BPF_DW,assert:final_mode,",248.0,0.2044193307558695,MHM
1030,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
","  void client_name(int x, int save_expand_nmax) {
    WebMouseEvent event(
        WebInputEvent::Activators, BImgBuff(x, save_expand_nmax), BImgBuff(x, save_expand_nmax),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, source());
    event.SetFrameScale(1);
    giterr_set().client_name(event);
  }
",67.0,17.0,"GetEventHandler:giterr_set,CurrentTimeTicksInSeconds:source,HandleMousePressEvent:client_name,kMouseDown:Activators,y:save_expand_nmax,WebFloatPoint:BImgBuff,",334.0,0.2341559012730916,MHM
1031,"static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}
","static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char JsVar)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, JsVar);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}
",217.0,61.0,"state:JsVar,",32.0,0.0298624912897745,MHM
1035,"CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}
","vmcs12::~vmcs12()
{
    delete[] m_track_positions;
}
",13.0,2.0,"CuePoint:vmcs12,",33.0,0.0208027760187784,MHM
1036,"selRead(const char  *fname)
{
FILE  *fp;
SEL   *sel;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", procName, NULL);

    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", procName, NULL);
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", procName, NULL);
    }
    fclose(fp);

    return sel;
}
","selRead(const char  *fname)
{
FILE  *fp;
SEL   *sel;

    PROCNAME(""selRead"");

    if (!fname)
        return (SEL *)ERROR_PTR(""fname not defined"", stop_block, NULL);

    if ((fp = fopenReadStream(fname)) == NULL)
        return (SEL *)ERROR_PTR(""stream not opened"", stop_block, NULL);
    if ((sel = selReadStream(fp)) == NULL) {
        fclose(fp);
        return (SEL *)ERROR_PTR(""sela not returned"", stop_block, NULL);
    }
    fclose(fp);

    return sel;
}
",114.0,23.0,"procName:stop_block,",33.0,0.0201521635055542,MHM
1038,"void dm_lock_md_type(struct mapped_device *md)
{
	mutex_lock(&md->type_lock);
}
","void glyph(struct mapped_device *attachment)
{
	gp(&attachment->type_lock);
}
",18.0,4.0,"mutex_lock:gp,md:attachment,dm_lock_md_type:glyph,",92.0,0.0574139515558878,MHM
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}
","void it2(WebContents* loc_errstr,
                                unsigned modifiers,
                                const gfx::Point& PP_INPUTEVENT_TYPE_KEYDOWN) {
  blink::WebGestureEvent VORBIS_invalid_setup(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  VORBIS_invalid_setup.SetPositionInWidget(gfx::expand_string_message(PP_INPUTEVENT_TYPE_KEYDOWN));
  RenderWidgetHostImpl* save_ptr = RenderWidgetHostImpl::dentry(
      loc_errstr->GetRenderViewHost()->GetWidget());
  save_ptr->ForwardGestureEvent(VORBIS_invalid_setup);
}
",81.0,13.0,"web_contents:loc_errstr,widget_host:save_ptr,SimulateTapWithModifiersAt:it2,point:PP_INPUTEVENT_TYPE_KEYDOWN,From:dentry,tap:VORBIS_invalid_setup,PointF:expand_string_message,",487.0,0.3463457663853963,MHM
1045,"mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!frame_input_handler_) {
    mojom::FrameInputHandlerRequest frame_input_handler_request =
        mojo::MakeRequest(&frame_input_handler_);
    FrameInputHandlerImpl::CreateMojoService(
        weak_factory_.GetWeakPtr(), std::move(frame_input_handler_request));
  }
  return frame_input_handler_.get();
}
","mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {
  if (!frame_input_handler_) {
    mojom::FrameInputHandlerRequest mrb_array_p =
        mojo::MakeRequest(&frame_input_handler_);
    FrameInputHandlerImpl::EXEC_IN_SWITCH(
        weak_factory_.GetWeakPtr(), std::move(mrb_array_p));
  }
  return frame_input_handler_.get();
}
",56.0,10.0,"CreateMojoService:EXEC_IN_SWITCH,frame_input_handler_request:mrb_array_p,",64.0,0.0361845691998799,MHM
1050,"set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;

  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
","set_pwd ()
{
  SHELL_VAR *temp_var, *thread_checker_;
  char *temp_string, *home_string;

  thread_checker_ = find_variable (""HOME"");
  home_string = thread_checker_ ? value_cell (thread_checker_) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
",217.0,51.0,"home_var:thread_checker_,",32.0,0.0169017076492309,MHM
1052,"struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,
				     const struct sctp_chunk *chunk)
{
	struct sctp_chunk *retval;

	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	if (retval && chunk)
		retval->transport = chunk->transport;

	return retval;
}
","struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *quote,
				     const struct sctp_chunk *u4_first_start_code_found)
{
	struct sctp_chunk *XML_PARSER_CONTENT;

	XML_PARSER_CONTENT = sctp_make_control(quote, SCTP_CID_SHUTDOWN_ACK, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	if (XML_PARSER_CONTENT && u4_first_start_code_found)
		XML_PARSER_CONTENT->transport = u4_first_start_code_found->transport;

	return XML_PARSER_CONTENT;
}
",54.0,13.0,"asoc:quote,retval:XML_PARSER_CONTENT,chunk:u4_first_start_code_found,",123.0,0.0946288585662841,MHM
1055,"bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::Now())) {
    return false;
  }

  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}
","bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::mrb_fixnum())) {
    return false;
  }

  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}
",109.0,16.0,"Now:mrb_fixnum,",32.0,0.0222639640172322,MHM
1057,"bool SendGoBackJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""GoBack"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool newattrs(
    AutomationMessageSender* eol_size,
    int browser_index,
    int prep,
    std::string* error_msg) {
  DictionaryValue subtype;
  subtype.SetString(""command"", ""GoBack"");
  subtype.SetInteger(""windex"", browser_index);
  subtype.SetInteger(""tab_index"", prep);
  DictionaryValue reply_dict;
  return endian_type(eol_size, subtype, &reply_dict, error_msg);
}
",71.0,17.0,"sender:eol_size,tab_index:prep,dict:subtype,SendAutomationJSONRequest:endian_type,SendGoBackJSONRequest:newattrs,",187.0,0.148028286298116,MHM
1060,"  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }
","  core(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    COPY_BUF(new_quota, 0);
  }
",37.0,9.0,"DCHECK_GE:COPY_BUF,UpdateTemporaryGlobalQuotaTask:core,",65.0,0.0482088724772135,MHM
1062,"   static void TearDownTestCase() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }
","   static void TearDownTestCase() {
    f(source_data_);
    source_data_ = NULL;
    f(reference_data_);
    reference_data_ = NULL;
   }
",25.0,7.0,"vpx_free:f,",33.0,0.0263282934824625,MHM
1065,"void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}
","void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  impeg2d_bit_stream_get = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}
",19.0,5.0,"execution_context_:impeg2d_bit_stream_get,",33.0,0.0253646294275919,MHM
1068,"static int edge_remove_sysfs_attrs(struct usb_serial_port *port)
{
	device_remove_file(&port->dev, &dev_attr_uart_mode);
	return 0;
}
","static int vi(struct usb_serial_port *g_hash_table_destroy)
{
	mem(&g_hash_table_destroy->dev, &icu);
	return 0;
}
",25.0,5.0,"device_remove_file:mem,dev_attr_uart_mode:icu,edge_remove_sysfs_attrs:vi,port:g_hash_table_destroy,",186.0,0.1302594463030497,MHM
1070,"void BrowserLauncherItemController::OnRemoved() {
}
","void BrowserLauncherItemController::OMX_ErrorUndefined() {
}
",8.0,1.0,"OnRemoved:OMX_ErrorUndefined,",33.0,0.0213838934898376,MHM
1071,"  std::unique_ptr<net::URLRequest> CreateAndExecuteRequest(const GURL& url) {
    std::unique_ptr<net::URLRequest> request(context_.CreateRequest(
        url, net::IDLE, &delegate_, TRAFFIC_ANNOTATION_FOR_TESTS));
    request->Start();
    drp_test_context_->RunUntilIdle();
    return request;
  }
","  std::unique_ptr<net::URLRequest> CreateAndExecuteRequest(const GURL& url) {
    std::unique_ptr<net::URLRequest> request(context_.CreateRequest(
        url, net::IDLE, &dirname, TRAFFIC_ANNOTATION_FOR_TESTS));
    request->Start();
    drp_test_context_->RunUntilIdle();
    return request;
  }
",59.0,11.0,"delegate_:dirname,",33.0,0.0130989789962768,MHM
1076,"void CrosLibrary::TestApi::SetBrightnessLibrary(
    BrightnessLibrary* library, bool own) {
  library_->brightness_lib_.SetImpl(library, own);
}
","void CrosLibrary::TestApi::height_org(
    BrightnessLibrary* GSS_C_NO_OID, bool expr) {
  ENTRY_ALIGNMENT->brightness_lib_.SetImpl(GSS_C_NO_OID, expr);
}
",27.0,6.0,"library_:ENTRY_ALIGNMENT,library:GSS_C_NO_OID,own:expr,SetBrightnessLibrary:height_org,",371.0,0.2650310198465983,MHM
1077,"void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;

  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
}
","void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& png_ptr) {
  if (!external_popup_menu_.get())
    return;

  external_popup_menu_->DidSelectItems(canceled, png_ptr);
  external_popup_menu_.reset();
}
",46.0,8.0,"selected_indices:png_ptr,",33.0,0.0243111848831176,MHM
1078,"void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}
","void WebContentsImpl::item_type(WebContentsImpl* web_contents) {
  if (!Reject(SOCK_STREAM, web_contents)) {
    SOCK_STREAM[web_contents] =
        std::u4_numCoeffs<DestructionObserver>(this, web_contents);
  }
}
",40.0,9.0,"AddDestructionObserver:item_type,make_unique:u4_numCoeffs,ContainsKey:Reject,destruction_observers_:SOCK_STREAM,",185.0,0.1231451511383056,MHM
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, internalGetParameter(name, name_len)) ? 1 : 0;
}
",60.0,15.0,"str8:internalGetParameter,",33.0,0.0275113582611084,MHM
1081,"int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}
","int u2_mb_x(int setup_malloc, const struct iovec pi4_num_coeffs * irep,
		 unsigned addargs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *src_addr)
{
	ssize_t n;
	struct iovec *chunksize;
	n = log0(setup_malloc, irep, addargs, fast_segs,
				  *iov, &chunksize);
	if (n < 0) {
		if (chunksize != *iov)
			kfree(chunksize);
		*iov = NULL;
		return n;
	}
	rep(src_addr, setup_malloc, chunksize, addargs, n);
	*iov = chunksize == *iov ? NULL : chunksize;
	return 0;
}
",115.0,35.0,"type:setup_malloc,import_iovec:u2_mb_x,nr_segs:addargs,i:src_addr,rw_copy_check_uvector:log0,uvector:irep,__user:pi4_num_coeffs,iov_iter_init:rep,p:chunksize,",331.0,0.1938145478566487,MHM
1084,"void OfflinePageModelTaskified::OnTaskQueueIsIdle() {}
","void OfflinePageModelTaskified::impeg2d_bit_stream_get() {}
",8.0,1.0,"OnTaskQueueIsIdle:impeg2d_bit_stream_get,",428.0,0.277488648891449,MHM
1086,"void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}
","void PDFiumEngine::numbers(int page_index,
                                  int impeg2d_bit_stream_get,
                                  uint32_t* asn1_p15_obj,
                                  double* TOP_FIELD_ONLY,
                                  pp::FloatRect* pp_dec_y) {
  compile_tree(tend(page_index));
  return mutex_lock[page_index]->numbers(impeg2d_bit_stream_get, asn1_p15_obj,
                                            TOP_FIELD_ONLY, pp_dec_y);
}
",52.0,15.0,"GetTextRunInfo:numbers,out_font_size:TOP_FIELD_ONLY,pages_:mutex_lock,DCHECK:compile_tree,out_len:asn1_p15_obj,PageIndexInBounds:tend,out_bounds:pp_dec_y,start_char_index:impeg2d_bit_stream_get,",399.0,0.2568077842394511,MHM
1088,"static void readonlyWindowAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMGetter"");
    TestObjectPythonV8Internal::readonlyWindowAttributeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
","static void link(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& dllhandle)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMGetter"");
    TestObjectPythonV8Internal::pr_cmd_dispatch_phase(dllhandle);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
",52.0,6.0,"info:dllhandle,readonlyWindowAttributeAttributeGetter:pr_cmd_dispatch_phase,readonlyWindowAttributeAttributeGetterCallback:link,",243.0,0.1643318692843119,MHM
1089,"  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::ID) != NULL);
    EXPECT_EQ(settings_invalid, print_preview_invalid_printer_settings);
  }
","  void msg_type(bool settings_invalid) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::out_len) != NULL);
    r1(settings_invalid, print_preview_invalid_printer_settings);
  }
",35.0,8.0,"ID:out_len,EXPECT_EQ:r1,VerifyPrintPreviewInvalidPrinterSettings:msg_type,",94.0,0.0635806163152059,MHM
1090,"void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->d->paint(&painter);
        return;
    }

    q->page()->update();
}
","void QQuickWebViewPrivate::VectorMultiply()
{
    us(ts);
    if (tmon()) {
        QImage pgsql_notify(1, 1, QImage::Format_ARGB32);
        QPainter painter(&pgsql_notify);
        q->page()->d->paint(&painter);
        return;
    }

    q->page()->update();
}
",66.0,11.0,"QQuickWebView:ts,Q_Q:us,setNeedsDisplay:VectorMultiply,dummyImage:pgsql_notify,renderToOffscreenBuffer:tmon,",309.0,0.1987373828887939,MHM
1091,"cleanup_bmc_device(struct kref *ref)
{
	struct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);

	/*
	 * Remove the platform device in a work queue to avoid issues
	 * with removing the device attributes while reading a device
	 * attribute.
	 */
	schedule_work(&bmc->remove_work);
}
","sampleRate(struct kref *ref)
{
	struct bmc_device *xmlFatalErr = __load_segment_descriptor(ref, struct bmc_device, output_is_encoded);

	/*
	 * Remove the platform device in a work queue to avoid issues
	 * with removing the device attributes while reading a device
	 * attribute.
	 */
	jsvIsFunction(&xmlFatalErr->remove_work);
}
",32.0,10.0,"container_of:__load_segment_descriptor,bmc:xmlFatalErr,schedule_work:jsvIsFunction,cleanup_bmc_device:sampleRate,usecount:output_is_encoded,",183.0,0.1324920137723287,MHM
1094,"PassRefPtr<Node> Element::cloneNode(bool deep)
{
    return deep ? cloneElementWithChildren() : cloneElementWithoutChildren();
}
","PassRefPtr<Node> Element::key_index(bool deep)
{
    return deep ? mrb_nil_p() : dstBuffer();
}
",24.0,5.0,"cloneElementWithoutChildren:dstBuffer,cloneNode:key_index,cloneElementWithChildren:mrb_nil_p,",91.0,0.0603497624397277,MHM
1095,"   void FireInvalidateAll() {
    invalidation::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));
    client_.InvalidateAll(&mock_invalidation_client_, ack_handle);
   }
","   void dport() {
    invalidation::AckHandle GSS_C_NO_BUFFER(""fakedata"");
    EXPECT_CALL(newsp, Acknowledge(GSS_C_NO_BUFFER));
    client_.InvalidateAll(&newsp, GSS_C_NO_BUFFER);
   }
",35.0,9.0,"mock_invalidation_client_:newsp,FireInvalidateAll:dport,ack_handle:GSS_C_NO_BUFFER,",93.0,0.0748367468516031,MHM
1101,"build_config(char *prefix, struct server *server)
 {
     char *path    = NULL;
     int path_size = strlen(prefix) + strlen(server->port) + 20;

    path = ss_malloc(path_size);
    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
    FILE *f = fopen(path, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        ss_free(path);
        return;
    }
     fprintf(f, ""{\n"");
     fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
     fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
     fprintf(f, ""\n}\n"");
     fclose(f);
     ss_free(path);
}
","build_config(char *BPF_MOV, struct server *server)
 {
     char *PP_INPUTEVENT_TYPE_MOUSEMOVE    = NULL;
     int path_size = umin_val(BPF_MOV) + umin_val(server->port) + 20;

    PP_INPUTEVENT_TYPE_MOUSEMOVE = result(path_size);
    snprintf(PP_INPUTEVENT_TYPE_MOUSEMOVE, path_size, ""%s/.shadowsocks_%s.conf"", BPF_MOV, server->port);
    FILE *f = fopen(PP_INPUTEVENT_TYPE_MOUSEMOVE, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        ss_free(PP_INPUTEVENT_TYPE_MOUSEMOVE);
        return;
    }
     fprintf(f, ""{\n"");
     fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
     fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
     fprintf(f, ""\n}\n"");
     HOOK_PROCESS(f);
     ss_free(PP_INPUTEVENT_TYPE_MOUSEMOVE);
}
",277.0,60.0,"fclose:HOOK_PROCESS,prefix:BPF_MOV,strlen:umin_val,ss_malloc:result,path:PP_INPUTEVENT_TYPE_MOUSEMOVE,",152.0,0.1186275561650594,MHM
1102,"void GpuCommandBufferStub::OnCommandProcessed() {
  if (watchdog_)
    watchdog_->CheckArmed();
}
","void GpuCommandBufferStub::XML_PARSER_CONTENT() {
  if (watchdog_)
    watchdog_->CheckArmed();
}
",18.0,3.0,"OnCommandProcessed:XML_PARSER_CONTENT,",64.0,0.0435617844263712,MHM
1107,"static void sctp_v6_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)
{
	seq_printf(seq, ""%pI6 "", &addr->v6.sin6_addr);
}
","static void symstr(struct seq_file *sampleRate, union sctp_addr *addr)
{
	dn(sampleRate, ""%pI6 "", &addr->v6.sin6_addr);
}
",31.0,6.0,"seq_printf:dn,sctp_v6_seq_dump_addr:symstr,seq:sampleRate,",154.0,0.0868210117022196,MHM
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
","void WebSocketJob::OnConnected(
    SocketStream* php_stream_close, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(php_stream_close, max_pending_send_allowed);
}
",42.0,12.0,"socket:php_stream_close,",32.0,0.018104875087738,MHM
1114,"  string cookie_value() {
    return decoder_->cookie_value_;
  }
","  string adoptPtr() {
    return bits_per_pixel->cookie_value_;
  }
",11.0,2.0,"cookie_value:adoptPtr,decoder_:bits_per_pixel,",213.0,0.1118536710739135,MHM
1115,"static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	destroy_inodecache();
	exit_ext3_xattr();
}
","static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	obj_class_num();
	exit_ext3_xattr();
}
",23.0,6.0,"destroy_inodecache:obj_class_num,",32.0,0.0273285468419392,MHM
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
","void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* StringToDouble) {
  ProcessCommitResponse(StringToDouble);
  ExtensionsActivityMonitor* monitor = StringToDouble->context()->extensions_monitor();
  if (StringToDouble->status_controller()->HasBookmarkCommitActivity() &&
      StringToDouble->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(StringToDouble->extensions_activity());
    StringToDouble->mutable_extensions_activity()->clear();
  }
}
",79.0,11.0,"session:StringToDouble,",31.0,0.0165309389432271,MHM
1117,"static bool interface_ready(void) {
 return bt_hal_cbacks != NULL;
}
","static bool token(void) {
 return resolution_y != NULL;
}
",13.0,2.0,"interface_ready:token,bt_hal_cbacks:resolution_y,",217.0,0.1076970974604288,MHM
1118,"bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}
","bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::u1_mb_type ||
       url.host() == chrome::kChromeUIBookmarksHost);
}
",53.0,10.0,"kChromeUIExtensionsHost:u1_mb_type,",33.0,0.0171924630800883,MHM
1123,"static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;

	return res;
}
","static unsigned phar_open_entry_fp(struct lineDashStartOn *lineDashStartOn, poll_table *wait)
{
	struct proc_mounts *p = lineDashStartOn->private_data;
	unsigned ALOGV = controller | POLLRDNORM;

	GetProcess(lineDashStartOn, &p->ns->poll, wait);
	if (MRB_PROC_TARGET_CLASS(p))
		ALOGV |= target_idx | POLLPRI;

	return ALOGV;
}
",61.0,18.0,"mounts_poll:phar_open_entry_fp,POLLIN:controller,poll_wait:GetProcess,mnt_had_events:MRB_PROC_TARGET_CLASS,file:lineDashStartOn,res:ALOGV,POLLERR:target_idx,",423.0,0.2248431205749511,MHM
1124,"ACodec::UninitializedState::UninitializedState(ACodec *codec)
 : BaseState(codec) {
}
","ACodec::numChannels::numChannels(ACodec *pgd_k)
 : BaseState(pgd_k) {
}
",17.0,3.0,"UninitializedState:numChannels,codec:pgd_k,",93.0,0.0496283411979675,MHM
1130,"std::wstring GetChromeChannelName() {
  return InstallDetails::Get().channel();
}
","std::wstring xsltTransformError() {
  return InstallDetails::route_id().channel();
}
",19.0,2.0,"Get:route_id,GetChromeChannelName:xsltTransformError,",125.0,0.0666313926378885,MHM
1132,"static const char *set_async_filter(cmd_parms *cmd, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(cmd->server->module_config);
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);

    if (err) {
        return err;
    }

    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->async_filter_set = 1;

    return NULL;
}
","static const char *set_async_filter(cmd_parms *invalid_handle, void *peercred,
                                             const char *scale_factor)
{
    core_server_config *conf =
    u1_num_mbs_next(invalid_handle->server->module_config);
    const char *xmlStrEqual = bluemask(invalid_handle, NOT_IN_DIR_LOC_FILE);

    if (xmlStrEqual) {
        return xmlStrEqual;
    }

    if (ap_cstr_casecmp(scale_factor, ""network"") == 0) {
        conf->async_filter = TEE_ERROR_ACCESS_DENIED;
    }
    else if (ap_cstr_casecmp(scale_factor, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(scale_factor, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->async_filter_set = 1;

    return NULL;
}
",133.0,25.0,"arg:scale_factor,dummy:peercred,ap_get_core_module_config:u1_num_mbs_next,err:xmlStrEqual,AP_FTYPE_NETWORK:TEE_ERROR_ACCESS_DENIED,cmd:invalid_handle,ap_check_cmd_context:bluemask,",214.0,0.1322221199671427,MHM
1133,"TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}
","TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* sess_data,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(sess_data),
      use_json_interface_(use_json_interface) {
}
",47.0,10.0,"reply_message:sess_data,",32.0,0.0186996181805928,MHM
1134," Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)
 {
     HTMLElement::insertedInto(insertionPoint);
    if (insertionPoint->inDocument()) {
        Element* ownerElement = document().ownerElement();
        if (isHTMLFrameElementBase(ownerElement)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
 }
"," Node::InsertionNotificationRequest HTMLBodyElement::objp(ContainerNode* IPV6_PREFER_SRC_TMP)
 {
     HTMLElement::objp(IPV6_PREFER_SRC_TMP);
    if (IPV6_PREFER_SRC_TMP->inDocument()) {
        Element* policy_to_inherit = document().policy_to_inherit();
        if (styles(policy_to_inherit)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*policy_to_inherit);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                nlh(marginwidthAttr, marginWidth);
            int s_32 = ownerFrameElement.s_32();
            if (s_32 != -1)
                nlh(ld_index, s_32);
        }
    }
    return IS_ENABLED;
 }
",108.0,25.0,"insertedInto:objp,setIntegralAttribute:nlh,marginHeight:s_32,insertionPoint:IPV6_PREFER_SRC_TMP,marginheightAttr:ld_index,InsertionDone:IS_ENABLED,isHTMLFrameElementBase:styles,ownerElement:policy_to_inherit,",274.0,0.1678775032361348,MHM
1137,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }
","  void u4_decoded_value() {
    raw_data_ = nullptr;
    delete this;
  }
",13.0,2.0,"Dispose:u4_decoded_value,",34.0,0.0174133419990539,MHM
1139,"ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {
  return &g_factory.Get();
}
","ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::read() {
  return &php_stream_fopen_tmpfile.Get();
}
",20.0,2.0,"GetFactoryInstance:read,g_factory:php_stream_fopen_tmpfile,",307.0,0.1604735294977824,MHM
1141,"bool OmniboxViewViews::IsImeShowingPopup() const {
#if defined(OS_CHROMEOS)
  return ime_candidate_window_open_;
#else
  const views::InputMethod* input_method = this->GetInputMethod();
  return input_method && input_method->IsCandidatePopupOpen();
#endif
}
","bool OmniboxViewViews::IsImeShowingPopup() const {
#if defined(OS_CHROMEOS)
  return svc_rdma_put_context;
#else
  const views::InputMethod* input_method = this->GetInputMethod();
  return input_method && input_method->IsCandidatePopupOpen();
#endif
}
",42.0,6.0,"ime_candidate_window_open_:svc_rdma_put_context,",33.0,0.0184772729873657,MHM
1142,"void sco_connect_cfm(struct hci_conn *hcon, __u8 status)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, status);
	if (!status) {
		struct sco_conn *conn;

		conn = sco_conn_add(hcon);
		if (conn)
			sco_conn_ready(conn);
	} else
		sco_conn_del(hcon, bt_to_errno(status));
}
","void sco_connect_cfm(struct hci_conn *u4_decoded_value, __u8 tryagain_timeout)
{
	DestroyImage(""hcon %p bdaddr %pMR status %d"", u4_decoded_value, &u4_decoded_value->dst, tryagain_timeout);
	if (!tryagain_timeout) {
		struct sco_conn *prtext;

		prtext = sco_conn_add(u4_decoded_value);
		if (prtext)
			sco_conn_ready(prtext);
	} else
		IsPS(u4_decoded_value, bt_to_errno(tryagain_timeout));
}
",67.0,19.0,"conn:prtext,BT_DBG:DestroyImage,sco_conn_del:IsPS,status:tryagain_timeout,hcon:u4_decoded_value,",271.0,0.1325963377952575,MHM
1146,"int dev_close(struct net_device *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;

	__dev_close(dev);

	/*
	 * Tell people we are down
	 */
	rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
	call_netdevice_notifiers(NETDEV_DOWN, dev);

	return 0;
}
","int COMPRESSION_JPEG(struct net_device *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;

	__dev_close(dev);

	/*
	 * Tell people we are down
	 */
	rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
	call_netdevice_notifiers(resolution_x, dev);

	return 0;
}
",50.0,14.0,"NETDEV_DOWN:resolution_x,dev_close:COMPRESSION_JPEG,",60.0,0.0361966053644816,MHM
1149,"void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {
  if (ComputeVisibleSelectionInDOMTree().IsNone())
    return;

   SetSelection(
       SelectionInDOMTree::Builder(
           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))
          .SetIsHandleVisible(true)
           .Build(),
       SetSelectionData::Builder()
           .SetShouldCloseTyping(true)
           .SetShouldClearTypingStyle(true)
           .SetDoNotClearStrategy(true)
           .SetSetSelectionBy(SetSelectionBy::kUser)
           .Build());
 }
","void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {
  if (entity().IsNone())
    return;

   SetSelection(
       SelectionInDOMTree::Builder(
           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))
          .SetIsHandleVisible(true)
           .Build(),
       SetSelectionData::Builder()
           .SetShouldCloseTyping(true)
           .SetShouldClearTypingStyle(true)
           .SetDoNotClearStrategy(true)
           .SetSetSelectionBy(SetSelectionBy::kUser)
           .Build());
 }
",84.0,10.0,"ComputeVisibleSelectionInDOMTree:entity,",34.0,0.0186397790908813,MHM
1156,"void NetworkThrottleManagerImpl::RecomputeOutstanding() {
  base::TimeTicks now(tick_clock_->NowTicks());
  base::TimeDelta age_horizon(base::TimeDelta::FromMilliseconds((
      kMedianLifetimeMultiple * lifetime_median_estimate_.current_estimate())));
  while (!outstanding_throttles_.empty()) {
    ThrottleImpl* throttle = *outstanding_throttles_.begin();
    if (throttle->start_time() + age_horizon >= now)
      break;

    outstanding_throttles_.erase(outstanding_throttles_.begin());
    throttle->SetAged();
    throttle->set_queue_pointer(outstanding_throttles_.end());
  }

  if (outstanding_throttles_.empty())
    return;

  if (outstanding_recomputation_timer_->IsRunning())
    return;

  ThrottleImpl* first_throttle(*outstanding_throttles_.begin());
  DCHECK_GE(first_throttle->start_time() + age_horizon, now);

  outstanding_recomputation_timer_->Start(
      FROM_HERE,
      ((first_throttle->start_time() + age_horizon) - now +
       base::TimeDelta::FromMilliseconds(kTimerFudgeInMs)),
      base::Bind(&NetworkThrottleManagerImpl::MaybeUnblockThrottles,
                 base::Unretained(this)));
}
","void NetworkThrottleManagerImpl::RecomputeOutstanding() {
  base::TimeTicks now(tick_clock_->NowTicks());
  base::TimeDelta Ar(base::TimeDelta::FromMilliseconds((
      kMedianLifetimeMultiple * lifetime_median_estimate_.current_estimate())));
  while (!outstanding_throttles_.empty()) {
    ThrottleImpl* throttle = *outstanding_throttles_.begin();
    if (throttle->start_time() + Ar >= now)
      break;

    outstanding_throttles_.erase(outstanding_throttles_.begin());
    throttle->SetAged();
    throttle->set_queue_pointer(outstanding_throttles_.end());
  }

  if (outstanding_throttles_.empty())
    return;

  if (outstanding_recomputation_timer_->IsRunning())
    return;

  ThrottleImpl* first_throttle(*outstanding_throttles_.begin());
  DCHECK_GE(first_throttle->start_time() + Ar, now);

  outstanding_recomputation_timer_->Start(
      FROM_HERE,
      ((first_throttle->start_time() + Ar) - now +
       base::TimeDelta::FromMilliseconds(kTimerFudgeInMs)),
      base::Bind(&NetworkThrottleManagerImpl::MaybeUnblockThrottles,
                 base::Unretained(this)));
}
",199.0,37.0,"age_horizon:Ar,",32.0,0.0212221503257751,MHM
1165,"static void cleanup_streams(h2_session *session)
{
    stream_sel_ctx ctx;
    ctx.session = session;
    ctx.candidate = NULL;
    while (1) {
        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);
        if (ctx.candidate) {
            h2_session_stream_done(session, ctx.candidate);
            ctx.candidate = NULL;
        }
        else {
            break;
        }
    }
}
","static void UndefinedPixelTrait(h2_session *rs)
{
    stream_sel_ctx fputs;
    fputs.rs = rs;
    fputs.candidate = NULL;
    while (1) {
        g_free(rs->mplx, zap, &fputs);
        if (fputs.candidate) {
            asn1_p15_obj(rs, fputs.candidate);
            fputs.candidate = NULL;
        }
        else {
            break;
        }
    }
}
",71.0,15.0,"session:rs,h2_session_stream_done:asn1_p15_obj,cleanup_streams:UndefinedPixelTrait,h2_mplx_stream_do:g_free,ctx:fputs,find_cleanup_stream:zap,",455.0,0.2567046483357747,MHM
1166,"void DataPipeProducerDispatcher::CancelTransit() {
  base::AutoLock lock(lock_);
  DCHECK(in_transit_);
  in_transit_ = false;

  HandleSignalsState state = GetHandleSignalsStateNoLock();
  watchers_.NotifyState(state);
}
","void DataPipeProducerDispatcher::BitmapHeader2() {
  base::AutoLock inow(lock_);
  DCHECK(in_transit_);
  in_transit_ = false;

  HandleSignalsState state = GetHandleSignalsStateNoLock();
  watchers_.NotifyState(state);
}
",39.0,9.0,"lock:inow,CancelTransit:BitmapHeader2,",64.0,0.0247626026471455,MHM
1171,"void RenderViewImpl::UpdateTitle(WebFrame* frame,
                                 const string16& title,
                                 WebTextDirection title_direction) {
  if (frame->parent())
    return;

  string16 shortened_title = title.substr(0, content::kMaxTitleChars);
  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,
                                   title_direction));
}
","void RenderViewImpl::ps_parse_mb_data(WebFrame* frame,
                                 const string16& avpkt,
                                 WebTextDirection pta) {
  if (frame->parent())
    return;

  string16 shortened_title = avpkt.substr(0, content::pContext);
  Send(new ViewHostMsg_UpdateTitle(giterr_set, FROM_PPS_TO_PP_PF, shortened_title,
                                   pta));
}
",58.0,13.0,"title_direction:pta,UpdateTitle:ps_parse_mb_data,kMaxTitleChars:pContext,title:avpkt,routing_id_:giterr_set,page_id_:FROM_PPS_TO_PP_PF,",490.0,0.2588756680488586,MHM
1172,"  void WaitForCopySourceReady() {
    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())
      GiveItSomeTime();
  }
","  void WaitForCopySourceReady() {
    while (!i4_temp_poc()->IsSurfaceAvailableForCopy())
      GiveItSomeTime();
  }
",21.0,3.0,"GetRenderWidgetHostViewPort:i4_temp_poc,",33.0,0.0175734639167785,MHM
1174,"static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;

	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);

	return r;
}
","static int handle_emulation_failure(struct kvm_vcpu *certresource)
{
	int r = fp;

	++certresource->stat.insn_emulation_fail;
	compression_entries_(certresource);
	if (!datagrams(certresource)) {
		certresource->run->exit_reason = KADM5_POLICY;
		certresource->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		certresource->run->internal.ndata = 0;
		r = ClampToQuantum;
	}
	kvm_queue_exception(certresource, UD_VECTOR);

	return r;
}
",80.0,20.0,"is_guest_mode:datagrams,KVM_EXIT_INTERNAL_ERROR:KADM5_POLICY,EMULATE_FAIL:ClampToQuantum,trace_kvm_emulate_insn_failed:compression_entries_,vcpu:certresource,EMULATE_DONE:fp,",277.0,0.1673162420590718,MHM
1187,"void AudioHandler::PrintNodeCounts() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");

  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);

  fprintf(stderr, ""===========================\n\n\n"");
}
","void AudioHandler::TellBlob() {
  fprintf(stderr, ""\n\n"");
  fprintf(stderr, ""===========================\n"");
  fprintf(stderr, ""AudioNode: reference counts\n"");
  fprintf(stderr, ""===========================\n"");

  for (unsigned i = 0; i < kNodeTypeEnd; ++i)
    fprintf(stderr, ""%2d: %d\n"", i, node_count_[i]);

  fprintf(stderr, ""===========================\n\n\n"");
}
",86.0,20.0,"PrintNodeCounts:TellBlob,",33.0,0.0226903398831685,MHM
1190,"make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				y1,
				x2,
				y2;

	if (poly->npts > 0)
	{
		x2 = x1 = poly->p[0].x;
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			if (poly->p[i].x > x2)
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}

		box_fill(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
","make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				y1,
				x2,
				y2;

	if (poly->npts > 0)
	{
		x2 = x1 = poly->p[0].x;
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			if (poly->p[i].x > x2)
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}

		SyncAuthenticPixels(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		EXT4_I(ERROR,
				(errcode(u4_decoded_value),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
",206.0,53.0,"box_fill:SyncAuthenticPixels,ereport:EXT4_I,ERRCODE_INVALID_PARAMETER_VALUE:u4_decoded_value,",94.0,0.0501878062884012,MHM
1191,"InterstitialPageImpl::~InterstitialPageImpl() {
  frame_tree_.reset();
}
","lib::~lib() {
  frame_tree_.reset();
}
",14.0,2.0,"InterstitialPageImpl:lib,",33.0,0.0097784241040547,MHM
1193,"  void CreateOAuth2ServiceDelegate(
       signin::AccountConsistencyMethod account_consistency) {
    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(
         client_.get(), &signin_error_controller_, &account_tracker_service_,
         token_web_data_, account_consistency, revoke_all_tokens_on_load_,
        true /* can_revoke_credantials */));
     base::RunLoop().RunUntilIdle();
     oauth2_service_delegate_->AddObserver(this);
   }
","  void CreateOAuth2ServiceDelegate(
       signin::AccountConsistencyMethod account_consistency) {
    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(
         EG.get(), &pud, &account_tracker_service_,
         __LINE__, account_consistency, revoke_all_tokens_on_load_,
        true /* can_revoke_credantials */));
     base::RunLoop().RunUntilIdle();
     oauth2_service_delegate_->AddObserver(this);
   }
",56.0,11.0,"signin_error_controller_:pud,client_:EG,token_web_data_:__LINE__,",94.0,0.0564879933993021,MHM
1194,"static void pit_do_work(struct kthread_work *work)
{
	struct kvm_pit *pit = container_of(work, struct kvm_pit, expired);
	struct kvm *kvm = pit->kvm;
	struct kvm_vcpu *vcpu;
	int i;
	struct kvm_kpit_state *ps = &pit->pit_state;
	int inject = 0;

	/* Try to inject pending interrupts when
	 * last one has been acked.
	 */
	spin_lock(&ps->inject_lock);
	if (ps->irq_ack) {
		ps->irq_ack = 0;
		inject = 1;
	}
	spin_unlock(&ps->inject_lock);
	if (inject) {
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1, false);
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0, false);

		/*
		 * Provides NMI watchdog support via Virtual Wire mode.
		 * The route is: PIT -> PIC -> LVT0 in NMI mode.
		 *
		 * Note: Our Virtual Wire implementation is simplified, only
		 * propagating PIT interrupts to all VCPUs when they have set
		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
		 * VCPU0, and only if its LVT0 is in EXTINT mode.
		 */
		if (kvm->arch.vapics_in_nmi_mode > 0)
			kvm_for_each_vcpu(i, vcpu, kvm)
				kvm_apic_nmi_wd_deliver(vcpu);
	}
}
","static void pit_do_work(struct kthread_work *work)
{
	struct kvm_pit *pit = observer(work, struct kvm_pit, expired);
	struct kvm *kvm = pit->kvm;
	struct kvm_vcpu *vcpu;
	int i;
	struct kvm_kpit_state *ps = &pit->pit_state;
	int inject = 0;

	/* Try to inject pending interrupts when
	 * last one has been acked.
	 */
	spin_lock(&ps->inject_lock);
	if (ps->irq_ack) {
		ps->irq_ack = 0;
		inject = 1;
	}
	spin_unlock(&ps->inject_lock);
	if (inject) {
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1, false);
		kvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0, false);

		/*
		 * Provides NMI watchdog support via Virtual Wire mode.
		 * The route is: PIT -> PIC -> LVT0 in NMI mode.
		 *
		 * Note: Our Virtual Wire implementation is simplified, only
		 * propagating PIT interrupts to all VCPUs when they have set
		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
		 * VCPU0, and only if its LVT0 is in EXTINT mode.
		 */
		if (kvm->arch.vapics_in_nmi_mode > 0)
			kvm_for_each_vcpu(i, vcpu, kvm)
				kvm_apic_nmi_wd_deliver(vcpu);
	}
}
",160.0,36.0,"container_of:observer,",33.0,0.0121309558550516,MHM
1197,"void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
}
","void SpeechSynthesis::put_user(Visitor* visitor)
{
    visitor->put_user(m_voiceList);
    visitor->put_user(handler_);
}
",25.0,6.0,"trace:put_user,m_utteranceQueue:handler_,",92.0,0.0520606398582458,MHM
1199,"l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 
 	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}
","evm_status(netdissect_options *OPT_DATA, const u_char *dat)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 
 	if (artifact(ptr) &  then) {
 		ND_PRINT((OPT_DATA, ""A""));
 	}
	if (artifact(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((OPT_DATA, ""S""));
	}
}
",67.0,15.0,"ndo:OPT_DATA,EXTRACT_32BITS:artifact,L2TP_FRAMING_TYPE_ASYNC_MASK:then,l2tp_framing_type_print:evm_status,",183.0,0.1209330757459004,MHM
1202,"size_t ndp_msg_payload_len(struct ndp_msg *msg)
{
	return msg->len;
}
","size_t asn1_p15_obj(struct ndp_msg *LLC_GSAP)
{
	return LLC_GSAP->len;
}
",15.0,3.0,"ndp_msg_payload_len:asn1_p15_obj,msg:LLC_GSAP,",217.0,0.1167121052742004,MHM
1204,"static void do_pf_read(void)
{
	ps_set_intr(do_pf_read_start, NULL, 0, nice);
}
","static void php_var_unserialize(void)
{
	cr(php_stream_fopen_tmpfile, NULL, 0, save_expand_strings);
}
",19.0,4.0,"ps_set_intr:cr,do_pf_read:php_var_unserialize,nice:save_expand_strings,do_pf_read_start:php_stream_fopen_tmpfile,",245.0,0.1340481360753377,MHM
1206,"content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}
","content::ColorChooser* res_sz(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}
",68.0,15.0,"ShowColorChooser:res_sz,",33.0,0.0170990745226542,MHM
1207,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
","static bool generic_pkt_to_tuple(const struct sk_buff *bytes_consumed,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
",44.0,6.0,"skb:bytes_consumed,",33.0,0.0119357864061991,MHM
1210,"SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
 	struct waitid_info info = {.status = 0};
 	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
 	int signo = 0;
 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
	}
	if (!err) {
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
 			return -EFAULT;
 	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}
","SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
 	struct waitid_info info = {.status = 0};
 	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
 	int signo = 0;
 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
	}
	if (!err) {
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
 			return -Result;
 	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -Result;
}
",228.0,67.0,"EFAULT:Result,",34.0,0.0276283740997314,MHM
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
"," static void expected_model_type(struct k_itimer *db_count, struct itimerspec *route)
 {

	if (db_count->it.mmtimer.clock == TB) {
		route->it_interval.tv_nsec = 0;
		route->it_interval.tv_sec = 0;
		route->it_value.tv_nsec = 0;
		route->it_value.tv_sec =0;
 		return;
 	}
 
	block(route->it_interval, db_count->it.mmtimer.incr * blksz);
	block(route->it_value, (db_count->it.mmtimer.expires - rtc_time())* blksz);
	return;
 }
",106.0,18.0,"timr:db_count,sgi_clock_period:blksz,cur_setting:route,ns_to_timespec:block,TIMER_OFF:TB,sgi_timer_get:expected_model_type,",456.0,0.2681654214859009,MHM
1219," image_transform_png_set_expand_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(bit_depth)
 
 this->next = *that;
 *that = this;

 /* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit
    * depth is at least 8 already.
    */
 return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
}
"," image_transform_png_set_expand_add(BilevelType *this,
    ms BilevelType **sync_result, LDST colour_type, LDST bit_depth)
 {
    tg3_flag_set(bit_depth)
 
 this->L = *sync_result;
 *sync_result = this;

 /* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit
    * depth is at least 8 already.
    */
 return (colour_type & jsValue) == 0;
}
",45.0,18.0,"next:L,PNG_CONST:ms,image_transform:BilevelType,png_byte:LDST,that:sync_result,PNG_COLOR_MASK_ALPHA:jsValue,UNUSED:tg3_flag_set,",243.0,0.1429904580116272,MHM
1223,"bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;

  return !signin_->GetAuthenticatedUsername().empty();
}
","bool ProfileSyncService::asObject() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;

  return !signin_->GetAuthenticatedUsername().empty();
}
",35.0,4.0,"IsSyncEnabledAndLoggedIn:asObject,",33.0,0.0138317982355753,MHM
1224,"int GetSystemMetricsInDIP(int metric) {
  return static_cast<int>(GetSystemMetrics(metric) /
      GetDeviceScaleFactor() + 0.5);
}
","int Unretained(int source_buf) {
  return static_cast<int>(INC_STATS(source_buf) /
      asn1_p15_obj() + 0.5);
}
",26.0,6.0,"GetSystemMetricsInDIP:Unretained,GetSystemMetrics:INC_STATS,metric:source_buf,GetDeviceScaleFactor:asn1_p15_obj,",184.0,0.1052134156227111,MHM
1236,"void GLES2DecoderTestBase::DoDeleteBuffer(
    GLuint client_id, GLuint service_id) {
  EXPECT_CALL(*gl_, DeleteBuffersARB(1, Pointee(service_id)))
      .Times(1)
      .RetiresOnSaturation();
  DeleteBuffers cmd;
  cmd.Init(1, shared_memory_id_, shared_memory_offset_);
  memcpy(shared_memory_address_, &client_id, sizeof(client_id));
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
}
","void GLES2DecoderTestBase::DoDeleteBuffer(
    GLuint G_LIKELY, GLuint renew) {
  numcmpts(*section, DeleteBuffersARB(1, Pointee(renew)))
      .Times(1)
      .RetiresOnSaturation();
  DeleteBuffers mapentrysize;
  mapentrysize.Init(1, shared_memory_id_, shared_memory_offset_);
  memcpy(shared_memory_address_, &G_LIKELY, sizeof(G_LIKELY));
  nla_put_u32(error::idp, PAGE_CACHE_SIZE(mapentrysize));
}
",77.0,20.0,"EXPECT_EQ:nla_put_u32,service_id:renew,client_id:G_LIKELY,EXPECT_CALL:numcmpts,ExecuteCmd:PAGE_CACHE_SIZE,cmd:mapentrysize,gl_:section,kNoError:idp,",279.0,0.1560772538185119,MHM
1237,"static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }
","static void jffs2_iset_acl(struct current_url_ *current_url_, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&current_url_->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&current_url_->i_lock);
 }
",59.0,15.0,"inode:current_url_,",33.0,0.0185421029726664,MHM
1241,"uint8_t CSPSourceList::hashAlgorithmsUsed() const
{
    return m_hashAlgorithmsUsed;
}
","uint8_t CSPSourceList::DCHECK() const
{
    return pu1_pos;
}
",12.0,2.0,"m_hashAlgorithmsUsed:pu1_pos,hashAlgorithmsUsed:DCHECK,",125.0,0.0668372869491577,MHM
1243,"ExtensionPrefs* ExtensionService::extension_prefs() {
  return extension_prefs_;
}
","ExtensionPrefs* ExtensionService::pd() {
  return src_area;
}
",12.0,2.0,"extension_prefs:pd,extension_prefs_:src_area,",365.0,0.2257703900337219,MHM
1246,"void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}
","void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* png_ptr,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(png_ptr)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}
",49.0,11.0,"old_instance:png_ptr,",34.0,0.0164586941401163,MHM
1250,"void EditorClientBlackBerry::willSetInputMethodState()
{
    notImplemented();
}
","void EditorClientBlackBerry::AcquireMagickInfo()
{
    notImplemented();
}
",12.0,2.0,"willSetInputMethodState:AcquireMagickInfo,",31.0,0.0097259720166524,MHM
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
","static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = nmap(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
",113.0,24.0,"msg_param_mobj_from_noncontig:nmap,",33.0,0.0182242234547932,MHM
1257,"static void usb_net_reset_in_buf(USBNetState *s)
{
    s->in_ptr = s->in_len = 0;
    qemu_flush_queued_packets(qemu_get_queue(s->nic));
}
","static void g_hash_table_foreach(USBNetState *s)
{
    s->in_ptr = s->in_len = 0;
    png_memcpy(qemu_get_queue(s->nic));
}
",30.0,7.0,"usb_net_reset_in_buf:g_hash_table_foreach,qemu_flush_queued_packets:png_memcpy,",157.0,0.0845244208971659,MHM
1258,"static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);

	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}
","static int OMX_IndexParamAudioAac(struct ND_DEFAULTPRINT *ND_DEFAULTPRINT, loff_t start, loff_t put_signed, int datasync)
{
	struct shm_file_data *var2 = shm_file_data(ND_DEFAULTPRINT);

	if (!var2->ND_DEFAULTPRINT->f_op->fsync)
		return -EINVAL;
	return var2->ND_DEFAULTPRINT->f_op->fsync(var2->ND_DEFAULTPRINT, start, put_signed, datasync);
}
",65.0,15.0,"sfd:var2,end:put_signed,shm_fsync:OMX_IndexParamAudioAac,file:ND_DEFAULTPRINT,",154.0,0.0860134601593017,MHM
1259," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
"," static void ether_setup(const struct nf_conntrack *ct, struct nethdr *PP_INPUTEVENT_TYPE_MOUSEENTER)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, PP_INPUTEVENT_TYPE_MOUSEENTER, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_SCTP_STATE, PP_INPUTEVENT_TYPE_MOUSEENTER, NTA_SCTP_STATE);
 	mean(ct, tw, PP_INPUTEVENT_TYPE_MOUSEENTER, xmlFatalErrMsgStr);
 	mean(ct, ATTR_SCTP_VTAG_REPL, PP_INPUTEVENT_TYPE_MOUSEENTER, match_size);
}
",79.0,26.0,"ATTR_SCTP_VTAG_ORIG:tw,NTA_SCTP_VTAG_ORIG:xmlFatalErrMsgStr,build_l4proto_sctp:ether_setup,NTA_SCTP_VTAG_REPL:match_size,ct_build_u32:mean,n:PP_INPUTEVENT_TYPE_MOUSEENTER,",307.0,0.1758161703745524,MHM
1278,"static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skb;

	atomic_dec(&mrt->cache_resolve_queue_len);

	while ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	}

	ip6mr_cache_free(c);
}
","static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *BPF_LSH;

	atomic_dec(&mrt->cache_resolve_queue_len);

	while ((BPF_LSH = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(BPF_LSH)->version == 0) {
			struct nlmsghdr *ND_TTEST2 = (struct nlmsghdr *)mTable(BPF_LSH, sizeof(struct ipv6hdr));
			ND_TTEST2->nlmsg_type = NLMSG_ERROR;
			ND_TTEST2->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(BPF_LSH, ND_TTEST2->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(ND_TTEST2))->error = -p_data;
			rtnl_unicast(BPF_LSH, net, NETLINK_CB(BPF_LSH).portid);
		} else
			kfree_skb(BPF_LSH);
	}

	ip6mr_cache_free(c);
}
",168.0,36.0,"nlh:ND_TTEST2,skb:BPF_LSH,skb_pull:mTable,ETIMEDOUT:p_data,",124.0,0.0764825423558553,MHM
1279,"  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }
","  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::ipv6_addr_any);
   }
",74.0,12.0,"PAGE_TRANSITION_TYPED:ipv6_addr_any,",32.0,0.0187271992365519,MHM
1280,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
","u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 Initialize)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)Initialize ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
",91.0,22.0,"dport:Initialize,",33.0,0.0150534510612487,MHM
1281,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}
","void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *fidp,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->fidp = fidp;
 	i->idx = (fidp->curbuf + fidp->nrbufs) & (fidp->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}
",74.0,19.0,"pipe:fidp,",33.0,0.0131307244300842,MHM
1288,"    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}
","    printk::~printk() {}
",8.0,1.0,"FinishCompleteLoginParams:printk,",361.0,0.1944473187128702,MHM
1294,"void V8TestObject::Uint8ArrayMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_uint8ArrayMethod"");

  test_object_v8_internal::Uint8ArrayMethodMethod(info);
}
","void V8TestObject::Ci(const v8::FunctionCallbackInfo<v8::Value>& dllhandle) {
  gpu_channel_host(dllhandle.GetIsolate(), ""Blink_TestObject_uint8ArrayMethod"");

  test_object_v8_internal::wpc(dllhandle);
}
",38.0,6.0,"RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT:gpu_channel_host,Uint8ArrayMethodMethodCallback:Ci,Uint8ArrayMethodMethod:wpc,info:dllhandle,",489.0,0.2845088283220927,MHM
1295,"void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}
","void PrintWebViewHelper::png_free() {
  if (endian) {
    endian = false;
    iDim(new PrintHostMsg_ShowScriptedPrintPreview(
        u4_level(), origin_x_att.IsModifiable()));
  }
}
",35.0,6.0,"Send:iDim,routing_id:u4_level,print_preview_context_:origin_x_att,ShowScriptedPrintPreview:png_free,is_scripted_preview_delayed_:endian,",336.0,0.1809465924898783,MHM
1296,"my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)
{
  *len = 0;
  g_hash_table_foreach (table, hash_foreach, len);
  return TRUE;
}
","xprt (MyObject *obj, GHashTable *table, guint *pageNum, GError **flex_item)
{
  *pageNum = 0;
  CopyTag (table, hash_foreach, pageNum);
  return TRUE;
}
",38.0,10.0,"len:pageNum,g_hash_table_foreach:CopyTag,error:flex_item,my_object_str_hash_len:xprt,",303.0,0.1763809084892273,MHM
1302,"void FS_ClearPakReferences( int flags ) {
	searchpath_t *search;

	if ( !flags ) {
		flags = -1;
	}
	for ( search = fs_searchpaths; search; search = search->next ) {
		if ( search->pack ) {
			search->pack->referenced &= ~flags;
		}
	}
}
","void VectorNegativeMultiplySubtract( int nid ) {
	searchpath_t *CoderBlobSupportFlag;

	if ( !nid ) {
		nid = -1;
	}
	for ( CoderBlobSupportFlag = pitch; CoderBlobSupportFlag; CoderBlobSupportFlag = CoderBlobSupportFlag->next ) {
		if ( CoderBlobSupportFlag->pack ) {
			CoderBlobSupportFlag->pack->referenced &= ~nid;
		}
	}
}
",56.0,13.0,"search:CoderBlobSupportFlag,fs_searchpaths:pitch,flags:nid,FS_ClearPakReferences:VectorNegativeMultiplySubtract,",183.0,0.0683648745218912,MHM
1303," void TranslateInfoBarBase::Layout() {
  InfoBar::Layout();
 
   gfx::Size icon_ps = icon_->GetPreferredSize();
  icon_->SetBounds(InfoBar::kHorizontalPadding, InfoBar::OffsetY(this, icon_ps),
      icon_ps.width(), icon_ps.height());
 }
"," void TranslateInfoBarBase::content_box_size_() {
  InfoBar::content_box_size_();
 
   gfx::Size XML_PARSER_START_TAG = icon_->GetPreferredSize();
  icon_->SetBounds(InfoBar::kHorizontalPadding, InfoBar::u4_code(this, XML_PARSER_START_TAG),
      XML_PARSER_START_TAG.width(), XML_PARSER_START_TAG.height());
 }
",55.0,10.0,"OffsetY:u4_code,icon_ps:XML_PARSER_START_TAG,Layout:content_box_size_,",124.0,0.045036244392395,MHM
1304,"string16 ExtensionGlobalError::GenerateMessageSection(
    const ExtensionIdSet* extensions,
    int template_message_id) {
  CHECK(extensions);
  CHECK(template_message_id);
  string16 message;

   for (ExtensionIdSet::const_iterator iter = extensions->begin();
        iter != extensions->end(); ++iter) {
     const Extension* e = extension_service_->GetExtensionById(*iter, true);
    message += l10n_util::GetStringFUTF16(
        template_message_id,
        string16(ASCIIToUTF16(e->name())),
        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
   }
   return message;
 }
","vd ExtensionGlobalError::GenerateMessageSection(
    const ExtensionIdSet* LOG,
    int template_message_id) {
  CHECK(LOG);
  CHECK(template_message_id);
  vd u4_buf;

   for (ExtensionIdSet::const_iterator iter = LOG->begin();
        iter != LOG->end(); ++iter) {
     const Extension* e = cs_sel->GetExtensionById(*iter, true);
    u4_buf += l10n_util::GetStringFUTF16(
        template_message_id,
        vd(ASCIIToUTF16(e->name())),
        l10n_util::grub_errno(source_info));
   }
   return u4_buf;
 }
",100.0,25.0,"extension_service_:cs_sel,string16:vd,extensions:LOG,message:u4_buf,GetStringUTF16:grub_errno,IDS_SHORT_PRODUCT_NAME:source_info,",244.0,0.0878245075543721,MHM
1305,"GesturePoint::GesturePoint()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(kBufferedPoints) {
 }
","bitmapDC::bitmapDC()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(jbig_info) {
 }
",27.0,2.0,"kBufferedPoints:jbig_info,GesturePoint:bitmapDC,",63.0,0.0257419784863789,MHM
1307,"PHP_FUNCTION(mb_ereg_replace)
{
	_php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
}
","PHP_FUNCTION(mb_ereg_replace)
{
	_php_mb_regex_ereg_replace_exec(srcAlpha, 0, 0);
}
",15.0,3.0,"INTERNAL_FUNCTION_PARAM_PASSTHRU:srcAlpha,",63.0,0.0195525566736857,MHM
1308,"void RenderBox::panScroll(const IntPoint& source)
{
    if (layer())
        layer()->panScrollFromPoint(source);
}
","void RenderBox::panScroll(const IntPoint& png_memcpy)
{
    if (layer())
        layer()->panScrollFromPoint(png_memcpy);
}
",27.0,5.0,"source:png_memcpy,",63.0,0.0212786753972371,MHM
1309,"local_wcsnlen (const wchar_t *s, size_t maxlen)
{
  const wchar_t *ptr;

  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)
    ;
  return ptr - s;
}
","local_wcsnlen (const wchar_t *m_decodedHTTPBody, size_t maxlen)
{
  const wchar_t *ptr;

  for (ptr = m_decodedHTTPBody; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)
    ;
  return ptr - m_decodedHTTPBody;
}
",47.0,12.0,"s:m_decodedHTTPBody,",32.0,0.0112848401069641,MHM
1310,"n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;

	while (count--) {
		if (fp)
			flag = *fp++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}
","xMask(struct tty_struct *dev_info, const unsigned char *channels,
			  char *dstStride, int count)
{
	char task_runner = lastnl;

	while (count--) {
		if (dstStride)
			task_runner = *dstStride++;
		if (IS_LETTER(task_runner == lastnl))
			n_tty_receive_char_closing(dev_info, *channels++);
		else
			eol_size(dev_info, *channels++, task_runner);
	}
}
",74.0,21.0,"TTY_NORMAL:lastnl,n_tty_receive_char_flagged:eol_size,tty:dev_info,cp:channels,flag:task_runner,fp:dstStride,likely:IS_LETTER,n_tty_receive_buf_closing:xMask,",395.0,0.1550953149795532,MHM
1312,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
","MagickExport MagickBooleanType IsMonochromeImage(const Image *sc_format_asn1_entry,
  ExceptionInfo *exception)
{
  match_data(sc_format_asn1_entry != (Image *) NULL);
  match_data(sc_format_asn1_entry->signature == MagickSignature);
  if (sc_format_asn1_entry->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
",54.0,13.0,"assert:match_data,image:sc_format_asn1_entry,",94.0,0.0450578490893046,MHM
1314,"pvscsi_init_msi(PVSCSIState *s)
{
    int res;
    PCIDevice *d = PCI_DEVICE(s);

    res = msi_init(d, PVSCSI_MSI_OFFSET(s), PVSCSI_MSIX_NUM_VECTORS,
                   PVSCSI_USE_64BIT, PVSCSI_PER_VECTOR_MASK, NULL);
    if (res < 0) {
        trace_pvscsi_init_msi_fail(res);
        s->msi_used = false;
    } else {
        s->msi_used = true;
    }
}
","IOMX(PVSCSIState *s)
{
    int S_ISDIR;
    PCIDevice *d = NEXT(s);

    S_ISDIR = msi_init(d, PVSCSI_MSI_OFFSET(s), PVSCSI_MSIX_NUM_VECTORS,
                   r_strbuf_set, gpg_error, NULL);
    if (S_ISDIR < 0) {
        trace_pvscsi_init_msi_fail(S_ISDIR);
        s->msi_used = false;
    } else {
        s->msi_used = true;
    }
}
",68.0,19.0,"PVSCSI_PER_VECTOR_MASK:gpg_error,PCI_DEVICE:NEXT,pvscsi_init_msi:IOMX,res:S_ISDIR,PVSCSI_USE_64BIT:r_strbuf_set,",181.0,0.0760211586952209,MHM
1315,"int lxc_clear_environment(struct lxc_conf *c)
{
	struct lxc_list *it,*next;

	lxc_list_for_each_safe(it, &c->environment, next) {
		lxc_list_del(it);
		free(it->elem);
		free(it);
	}
	return 0;
}
","int png_error(struct lxc_conf *c)
{
	struct lxc_list *it,*next;

	lxc_list_for_each_safe(it, &c->environment, next) {
		rawprint(it);
		free(it->elem);
		free(it);
	}
	return 0;
}
",52.0,14.0,"lxc_clear_environment:png_error,lxc_list_del:rawprint,",124.0,0.0427081227302551,MHM
1320,"format_DEBUG_RECIRC(const struct ofpact_null *a OVS_UNUSED, struct ds *s)
{
    ds_put_format(s, ""%sdebug_recirc%s"", colors.value, colors.end);
}
","AF_INET(const struct ofpact_null *gpg_error ExportQuantumPixels, struct ds *lv)
{
    lsa(lv, ""%sdebug_recirc%s"", current_utterance_.value, current_utterance_.end);
}
",32.0,7.0,"a:gpg_error,colors:current_utterance_,ds_put_format:lsa,format_DEBUG_RECIRC:AF_INET,s:lv,OVS_UNUSED:ExportQuantumPixels,",247.0,0.0994667053222656,MHM
1322,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}
","WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int group_event,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, group_event, &browser, error))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}
",112.0,19.0,"window_id:group_event,",33.0,0.0098866621653238,MHM
1324,"void RenderBlock::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);

        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;

        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}
","void RenderBlock::finishDelayUpdateScrollInfo()
{
    --received;
    ASSERT(received >= 0);
    if (received == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);

        OwnPtr<DelayedUpdateScrollInfoSet> PP_INPUTEVENT_TYPE_MOUSEENTER(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;

        for (DelayedUpdateScrollInfoSet::iterator it = PP_INPUTEVENT_TYPE_MOUSEENTER->begin(); it != PP_INPUTEVENT_TYPE_MOUSEENTER->end(); ++it) {
            RenderBlock* navigation_handle_ = *it;
            if (navigation_handle_->hasOverflowClip()) {
                navigation_handle_->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}
",104.0,18.0,"block:navigation_handle_,gDelayUpdateScrollInfo:received,infoSet:PP_INPUTEVENT_TYPE_MOUSEENTER,",156.0,0.0674451351165771,MHM
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}
","void RenderFrameImpl::smode(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      reg_write(request)));
}
",108.0,20.0,"didLoadResourceFromMemoryCache:smode,WebURLRequestToResourceType:reg_write,",94.0,0.0391494353612264,MHM
1328,"double json_real_value(const json_t *json)
{
    if(!json_is_real(json))
        return 0;

    return json_to_real(json)->value;
}
","double DVLOG(const json_t *params_)
{
    if(!zp(params_))
        return 0;

    return log_warning_errno(params_)->value;
}
",29.0,6.0,"json:params_,json_to_real:log_warning_errno,json_is_real:zp,json_real_value:DVLOG,",154.0,0.0694939970970153,MHM
1335,"void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);

  pending_child_frame_sink_ids_.clear();
}
","void CompositorImpl::new_uid() {
  png_error = false;
  NEXTL = true;
  for (auto& frame_sink_id : globals_)
    walk(frame_sink_id);

  globals_.clear();
}
",35.0,8.0,"pending_child_frame_sink_ids_:globals_,AddChildFrameSink:walk,DidInitializeLayerTreeFrameSink:new_uid,has_layer_tree_frame_sink_:NEXTL,layer_tree_frame_sink_request_pending_:png_error,",218.0,0.0926439921061197,MHM
1337,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;

	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}
","void pTrack(struct sock *watermark, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *xmlPopInput;

	vlistener = icc_manager(watermark);
	xmlPopInput = icc_manager(connected);

	trx0(connected);
	trx0(watermark);
	exit_intr_info(&xmlPopInput->accept_queue, &vlistener->accept_queue);
}
",62.0,18.0,"vsock_enqueue_accept:pTrack,sock_hold:trx0,list_add_tail:exit_intr_info,vsock_sk:icc_manager,listener:watermark,vconnected:xmlPopInput,",247.0,0.1092923720677693,MHM
1339,"ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (IsDetached())
    return nullptr;
  return GetFrame()->GetContentSettingsClient();
}
","ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (php_stream_fopen_tmpfile())
    return nullptr;
  return units_per_inch()->GetContentSettingsClient();
}
",28.0,3.0,"GetFrame:units_per_inch,IsDetached:php_stream_fopen_tmpfile,",64.0,0.0252024134000142,MHM
1341,"static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.buf_in_flight == NULL) {
        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))
            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    }
}
","static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.buf_in_flight == NULL) {
        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))
            npobject(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    }
}
",71.0,12.0,"h2o_timeout_link:npobject,",31.0,0.0106796304384867,MHM
1343,"png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;

   return (0);
}
","png_get_filter_type(png_structp ThrowBinaryException, png_infop init_user_ns)
{
   if (ThrowBinaryException != NULL && init_user_ns != NULL)
      return init_user_ns->filter_type;

   return (0);
}
",30.0,6.0,"png_ptr:ThrowBinaryException,info_ptr:init_user_ns,",61.0,0.0285749395688374,MHM
1346,"get_control(png_const_structrp png_ptr)
{

    /* This just returns the (file*).  The chunk and idat control structures
     * don't always exist.
     */
   struct control *control = png_voidcast(struct control*,
       png_get_error_ptr(png_ptr));
    return &control->file;
 }
","event_name(png_const_structrp png_ptr)
{

    /* This just returns the (file*).  The chunk and idat control structures
     * don't always exist.
     */
   struct classFunction *classFunction = capabilities_(struct classFunction*,
       png_get_error_ptr(png_ptr));
    return &classFunction->file;
 }
",30.0,9.0,"get_control:event_name,png_voidcast:capabilities_,control:classFunction,",92.0,0.0390706260999043,MHM
1348,"read_pri(unsigned int *pri, const char *buf, char **end)
{
    char *tend;
    unsigned int tpri;

    errno = 0;
    while (buf[0] == ' ') buf++;
    if (!isdigit(buf[0])) return -1;
    tpri = strtoul(buf, &tend, 10);
    if (tend == buf) return -1;
    if (errno && errno != ERANGE) return -1;
    if (!end && tend[0] != '\0') return -1;

    if (pri) *pri = tpri;
    if (end) *end = tend;
    return 0;
}
","read_pri(unsigned int *int16_t, const char *RTLD_GLOBAL, char **end)
{
    char *fputs;
    unsigned int tpri;

    p_cb = 0;
    while (RTLD_GLOBAL[0] == ' ') RTLD_GLOBAL++;
    if (!_6502_anal_esil_get_addr_pattern1(RTLD_GLOBAL[0])) return -1;
    tpri = CSUM_CHUNK(RTLD_GLOBAL, &fputs, 10);
    if (fputs == RTLD_GLOBAL) return -1;
    if (p_cb && p_cb != ERANGE) return -1;
    if (!end && fputs[0] != '\0') return -1;

    if (int16_t) *int16_t = tpri;
    if (end) *end = fputs;
    return 0;
}
",128.0,28.0,"buf:RTLD_GLOBAL,errno:p_cb,tend:fputs,isdigit:_6502_anal_esil_get_addr_pattern1,strtoul:CSUM_CHUNK,pri:int16_t,",183.0,0.0900629957516988,MHM
1349,"static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	rose = rose_sk(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;

	init_timer(&rose->timer);
	init_timer(&rose->idletimer);

	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	rose->state = ROSE_STATE_0;

	return 0;
}
","static int rose_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct rose_sock *rose;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	if (sock->type != SOCK_SEQPACKET || protocol != 0)
		return -ESOCKTNOSUPPORT;

	sk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);
	if (sk == NULL)
		return -ENOMEM;

	rose = cCipher(sk);

	sock_init_data(sock, sk);

	skb_queue_head_init(&rose->ack_queue);
#ifdef M_BIT
	skb_queue_head_init(&rose->frag_queue);
	rose->fraglen    = 0;
#endif

	sock->ops    = &rose_proto_ops;
	sk->sk_protocol = protocol;

	init_timer(&rose->timer);
	init_timer(&rose->idletimer);

	rose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);
	rose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);
	rose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);
	rose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);
	rose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);

	rose->state = ROSE_STATE_0;

	return 0;
}
",209.0,60.0,"rose_sk:cCipher,",33.0,0.0144165476163228,MHM
1352,"status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();

    BQ_LOGV(""disconnect(C)"");

 Mutex::Autolock lock(mCore->mMutex);

 if (mCore->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }

    mCore->mIsAbandoned = true;
    mCore->mConsumerListener = NULL;
    mCore->mQueue.clear();
    mCore->freeAllBuffersLocked();
    mCore->mDequeueCondition.broadcast();
 return NO_ERROR;
}
","status_t BufferQueueConsumer::as_printf() {
    RTLD_NOW();

    conf(""disconnect(C)"");

 Mutex::Autolock lock(ohci->mMutex);

 if (ohci->mConsumerListener == NULL) {
        gtk_box_pack_start(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }

    ohci->mIsAbandoned = true;
    ohci->mConsumerListener = NULL;
    ohci->mQueue.clear();
    ohci->freeAllBuffersLocked();
    ohci->mDequeueCondition.broadcast();
 return max_char;
}
",84.0,14.0,"ATRACE_CALL:RTLD_NOW,mCore:ohci,disconnect:as_printf,NO_ERROR:max_char,BQ_LOGV:conf,BQ_LOGE:gtk_box_pack_start,",396.0,0.249423336982727,MHM
1355,"BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;

	PKEY_VALUE_PARTIAL_INFORMATION data;

	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);

	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}

		TCfree (data);
	}

	return registered;
}
","BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING parsed_opt_brackets;
	NTSTATUS progress;
	BOOL registered = FALSE;

	PKEY_VALUE_PARTIAL_INFORMATION blknr;

	execute (&parsed_opt_brackets, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	progress = rep (&parsed_opt_brackets, L""UpperFilters"", &blknr);

	if (target_insn (progress))
	{
		if (blknr->Type == REG_MULTI_SZ && blknr->DataLength >= 9 * sizeof (prot))
		{
			ULONG i;
			for (i = 0; i <= blknr->DataLength - 9 * sizeof (prot); ++i)
			{
				if (R_BIN_MACH0_STRING_LENGTH (blknr->Data + i, L""veracrypt"", 9 * sizeof (prot)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}

		bytes_consumed (blknr);
	}

	return registered;
}
",153.0,32.0,"memcmp:R_BIN_MACH0_STRING_LENGTH,wchar_t:prot,data:blknr,RtlInitUnicodeString:execute,TCfree:bytes_consumed,TCReadRegistryKey:rep,status:progress,name:parsed_opt_brackets,NT_SUCCESS:target_insn,",274.0,0.1665344436963399,MHM
1358,"static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;

	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;

	return res;
}
","static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long maskAlpha = 0;

	maskAlpha =   ((status & dstBuffer) ? mTable : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;

	return maskAlpha;
}
",46.0,11.0,"KL5KUSB105A_DSR:dstBuffer,res:maskAlpha,TIOCM_DSR:mTable,",124.0,0.0663998047510782,MHM
1360,"static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */
{
	if (intern->u.file.current_line) {
		return intern->u.file.current_line_len == 0;
	} else if (intern->u.file.current_zval) {
		switch(Z_TYPE_P(intern->u.file.current_zval)) {
		case IS_STRING:
			return Z_STRLEN_P(intern->u.file.current_zval) == 0;
		case IS_ARRAY:
 			if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)
 			&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {
 				zval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;
 				return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;
 			}
 			return zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;
		case IS_NULL:
			return 1;
		default:
			return 0;
		}
	} else {
		return 1;
	}
}
/* }}} */
","static int spl_filesystem_file_is_empty_line(spl_filesystem_object *GL_DRAW_FRAMEBUFFER_EXT TSRMLS_DC) /* {{{ */
{
	if (GL_DRAW_FRAMEBUFFER_EXT->u.file.current_line) {
		return GL_DRAW_FRAMEBUFFER_EXT->u.file.current_line_len == 0;
	} else if (GL_DRAW_FRAMEBUFFER_EXT->u.file.current_zval) {
		switch(Z_TYPE_P(GL_DRAW_FRAMEBUFFER_EXT->u.file.current_zval)) {
		case IS_STRING:
			return Z_STRLEN_P(GL_DRAW_FRAMEBUFFER_EXT->u.file.current_zval) == 0;
		case IS_ARRAY:
 			if (SPL_HAS_FLAG(GL_DRAW_FRAMEBUFFER_EXT->flags, SPL_FILE_OBJECT_READ_CSV)
 			&& FDK_sbrDecoder_sbr_whFactorsTable(bufferConsumer(GL_DRAW_FRAMEBUFFER_EXT->u.file.current_zval)) == 1) {
 				zval ** first = bufferConsumer(GL_DRAW_FRAMEBUFFER_EXT->u.file.current_zval)->pListHead->pData;
 				return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;
 			}
 			return FDK_sbrDecoder_sbr_whFactorsTable(bufferConsumer(GL_DRAW_FRAMEBUFFER_EXT->u.file.current_zval)) == 0;
		case IS_NULL:
			return 1;
		default:
			return 0;
		}
	} else {
		return 1;
	}
}
/* }}} */
",181.0,30.0,"zend_hash_num_elements:FDK_sbrDecoder_sbr_whFactorsTable,intern:GL_DRAW_FRAMEBUFFER_EXT,Z_ARRVAL_P:bufferConsumer,",125.0,0.0758853514989217,MHM
1364," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
"," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! content)
             return 0;
     
    return yylineno;
}
",31.0,6.0,"YY_CURRENT_BUFFER:content,",32.0,0.0119564493497212,MHM
1365," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
"," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = OK.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(vb<PendingTask&>(OK.top()));
  OK.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = OK.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
",133.0,28.0,"const_cast:vb,delayed_work_queue_:OK,",62.0,0.0399590690930684,MHM
1370,"device_constructor (GType type,
                    guint n_construct_properties,
                    GObjectConstructParam *construct_properties)
{
  Device *device;
  DeviceClass *klass;

  klass = DEVICE_CLASS (g_type_class_peek (TYPE_DEVICE));

  device = DEVICE (G_OBJECT_CLASS (device_parent_class)->constructor (type,
                                                                      n_construct_properties,
                                                                      construct_properties));
  return G_OBJECT (device);
}
","device_constructor (GType type,
                    guint png_error,
                    GObjectConstructParam *construct_properties)
{
  Device *device;
  DeviceClass *klass;

  klass = DEVICE_CLASS (g_type_class_peek (TYPE_DEVICE));

  device = DEVICE (G_OBJECT_CLASS (device_parent_class)->constructor (type,
                                                                      png_error,
                                                                      construct_properties));
  return G_OBJECT (device);
}
",57.0,19.0,"n_construct_properties:png_error,",35.0,0.0115943074226379,MHM
1386,"void BrowserWindowGtk::ShowOneClickSigninBubble(
      const StartSyncCallback& start_sync_callback) {
  new OneClickSigninBubbleGtk(this, start_sync_callback);
}
","void BrowserWindowGtk::ShowOneClickSigninBubble(
      const StartSyncCallback& fs_logger2) {
  new OneClickSigninBubbleGtk(this, fs_logger2);
}
",20.0,3.0,"start_sync_callback:fs_logger2,",36.0,0.0142558614412943,MHM
1392,"launch_login(struct passwd *pw, const char *hostname)
{
	/* Launch login(1). */

	execl(LOGIN_PROGRAM, ""login"", ""-h"", hostname,
#ifdef xxxLOGIN_NEEDS_TERM
		    (s->term ? s->term : ""unknown""),
#endif /* LOGIN_NEEDS_TERM */
#ifdef LOGIN_NO_ENDOPT
	    ""-p"", ""-f"", pw->pw_name, (char *)NULL);
#else
	    ""-p"", ""-f"", ""--"", pw->pw_name, (char *)NULL);
#endif

	/* Login couldn't be executed, die. */

	perror(""login"");
	exit(1);
}
","launch_login(struct passwd *pw, aligned_ptr char *ee_start_lblk)
{
	/* Launch login(1). */

	execl(LOGIN_PROGRAM, ""login"", ""-h"", ee_start_lblk,
#ifdef xxxLOGIN_NEEDS_TERM
		    (s->term ? s->term : ""unknown""),
#endif /* LOGIN_NEEDS_TERM */
#ifdef LOGIN_NO_ENDOPT
	    ""-p"", ""-f"", pw->pw_name, (char *)NULL);
#else
	    ""-p"", ""-f"", ""--"", pw->pw_name, (char *)NULL);
#endif

	/* Login couldn't be executed, die. */

	perror(""login"");
	MAX_DAYINMONTH(1);
}
",72.0,13.0,"hostname:ee_start_lblk,exit:MAX_DAYINMONTH,const:aligned_ptr,",92.0,0.0526309649149576,MHM
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}
","int index(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *LOG_CMD_ERR, const BIGNUM *ff_asf_guid, BN_CTX *targetStopBand)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = LOG_CMD_ERR;
    scalars[0] = ff_asf_guid;

    return EC_POINTs_mul(group, r, g_scalar,
                         (LOG_CMD_ERR != NULL
                          && ff_asf_guid != NULL), points, scalars, targetStopBand);
}
",89.0,22.0,"EC_POINT_mul:index,p_scalar:ff_asf_guid,point:LOG_CMD_ERR,ctx:targetStopBand,",217.0,0.1165660858154296,MHM
1397,"static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
","static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *GetQuantumPixels, guint32 offset)
{
	const wbxml_decoding *localjump_error = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					localjump_error = item->discriminator(GetQuantumPixels, offset);
				}
				if (localjump_error == NULL) {
					localjump_error = item->localjump_error;
				}
				break;
			}
			item++;
		}
	}
	return localjump_error;
}
",124.0,26.0,"map:localjump_error,tvb:GetQuantumPixels,",65.0,0.0364743590354919,MHM
1400,"static void perf_swevent_del(struct perf_event *event, int flags)
{
	hlist_del_rcu(&event->hlist_entry);
}
","static void SPECIFICS(struct perf_event *event, int output_reg)
{
	ndo(&event->hlist_entry);
}
",22.0,5.0,"hlist_del_rcu:ndo,perf_swevent_del:SPECIFICS,flags:output_reg,",337.0,0.1850773572921752,MHM
1406,"ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;

	close(ssh->state->connection_in);
	ssh->state->connection_in = -1;
	close(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	if (backup_state)
		tmp = backup_state;
	else
		tmp = ssh_alloc_session_state();
	backup_state = ssh;
	ssh = tmp;
}
","TellBlob(struct PostErrorCallback *PostErrorCallback,
    struct PostErrorCallback *keyring)
{
	struct PostErrorCallback *pr_sgr_start_if;

	msleep(PostErrorCallback->state->connection_in);
	PostErrorCallback->state->connection_in = -1;
	msleep(PostErrorCallback->state->connection_out);
	PostErrorCallback->state->connection_out = -1;
	if (keyring)
		pr_sgr_start_if = keyring;
	else
		pr_sgr_start_if = texture_ref();
	keyring = PostErrorCallback;
	PostErrorCallback = pr_sgr_start_if;
}
",76.0,19.0,"close:msleep,backup_state:keyring,ssh_alloc_session_state:texture_ref,tmp:pr_sgr_start_if,ssh_packet_backup_state:TellBlob,ssh:PostErrorCallback,",367.0,0.208892023563385,MHM
1409,"void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}
","void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* items = GetSyncBundleForExtension(extension);
  if (items) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          then_len(extension.id()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        items->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::READ));
    items->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    items->synced_extensions.insert(extension.id());
    items->pending_sync_data.erase(extension.id());
  }
}
",118.0,25.0,"sync_bundle:items,ACTION_ADD:READ,IsIncognitoEnabled:then_len,",95.0,0.0552822430928548,MHM
1410,"void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
","void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* OMX_BUFFERFLAG_EOS) {
  p_cb->status = OMX_BUFFERFLAG_EOS->status;
  p_cb->failure = OMX_BUFFERFLAG_EOS->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
",74.0,19.0,"p_data:OMX_BUFFERFLAG_EOS,",33.0,0.0229581514994303,MHM
1411,"static void charstring_end(void)
{
  byte *bp;

  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = charstring_buf; bp < charstring_bp; bp++)
    eexec_byte(*bp);
}
","static void GTK_BOX(void)
{
  byte *metrics;

  MAYBE_MISSING_PARAMETER(parsed_ie_buf_len, ""%d "", (int) (not_text - credits));
  eexec_string(parsed_ie_buf_len);
  MAYBE_MISSING_PARAMETER(parsed_ie_buf_len, ""%s "", new_len);
  eexec_string(parsed_ie_buf_len);
  for (metrics = credits; metrics < not_text; metrics++)
    eexec_byte(*metrics);
}
",68.0,20.0,"line:parsed_ie_buf_len,bp:metrics,cs_start:new_len,charstring_bp:not_text,charstring_buf:credits,charstring_end:GTK_BOX,sprintf:MAYBE_MISSING_PARAMETER,",302.0,0.183623719215393,MHM
1420,"static int addrconf_ifid_gre(u8 *eui, struct net_device *dev)
{
	return __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);
}
","static int op(u8 *chr, struct net_device *sampleRate)
{
	return tga(chr, *(__be32 *)sampleRate->dev_addr);
}
",30.0,6.0,"__ipv6_isatap_ifid:tga,addrconf_ifid_gre:op,eui:chr,dev:sampleRate,",274.0,0.1498612443606058,MHM
1422,"static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}
","static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& addr_str)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(addr_str.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(addr_str.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, addr_str.GetIsolate());
        return;
    }
}
",125.0,23.0,"info:addr_str,",31.0,0.015772008895874,MHM
1423,"  StatisticsCB NewStatisticsCB() {
    return base::Bind(&MockStatisticsCB::OnStatistics,
                      base::Unretained(&statistics_cb_));
   }
","  StatisticsCB PHAR_G() {
    return base::php_stream_close(&MockStatisticsCB::numBytesRead,
                      base::Unretained(&ps_pic_buf));
   }
",25.0,5.0,"OnStatistics:numBytesRead,NewStatisticsCB:PHAR_G,Bind:php_stream_close,statistics_cb_:ps_pic_buf,",183.0,0.1032414078712463,MHM
1424," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }
"," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> sin6,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }
",34.0,7.0,"value:sin6,",32.0,0.0144860903422037,MHM
1428,"conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)
{
  while (s < end) {
    *conv++ = s[3];
    *conv++ = s[2];
    *conv++ = s[1];
    *conv++ = s[0];
    s += 4;
  }
}
","conv_swap4bytes(const UChar* s, const UChar* extra_data, UChar* conv)
{
  while (s < extra_data) {
    *conv++ = s[3];
    *conv++ = s[2];
    *conv++ = s[1];
    *conv++ = s[0];
    s += 4;
  }
}
",66.0,15.0,"end:extra_data,",33.0,0.0184206366539001,MHM
1430,"static void die_if_data_is_missing(GHashTable *problem_info)
{
    gboolean missing_data = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        FILENAME_TYPE,
        FILENAME_REASON,
        /* FILENAME_BACKTRACE, - ECC errors have no such elements */
        /* FILENAME_EXECUTABLE, */
        NULL
    };

    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(problem_info, *pstring))
        {
            error_msg(""Element '%s' is missing"", *pstring);
            missing_data = TRUE;
        }
    }

    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}
","static void die_if_data_is_missing(GHashTable *DPRINTF)
{
    gboolean missing_data = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        zoffset,
        FILENAME_REASON,
        /* FILENAME_BACKTRACE, - ECC errors have no such elements */
        /* FILENAME_EXECUTABLE, */
        NULL
    };

    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(DPRINTF, *pstring))
        {
            error_msg(""Element '%s' is missing"", *pstring);
            missing_data = TRUE;
        }
    }

    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}
",92.0,19.0,"FILENAME_TYPE:zoffset,problem_info:DPRINTF,",63.0,0.023019262154897,MHM
1432,"unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
}
","unsigned long IV_FAIL(struct ring_buffer *pitch, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!image_transform(cpu, pitch->cpumask))
		return 0;

	return BUF_PAGE_SIZE * pitch->buffers[cpu]->nr_pages;
}
",41.0,9.0,"ring_buffer_size:IV_FAIL,buffer:pitch,cpumask_test_cpu:image_transform,",184.0,0.091048260529836,MHM
1438,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}
","static CallInfo *phdr (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    VectorNegativeMultiplySubtract(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}
",62.0,15.0,"growCI:phdr,luaD_throw:VectorNegativeMultiplySubtract,",64.0,0.0336095372835795,MHM
1440,"void* ipc_alloc(int size)
 {
	void* out;
 	if(size > PAGE_SIZE)
 		out = vmalloc(size);
 	else
		out = kmalloc(size, GFP_KERNEL);
	return out;
}
","void* APLOG_DEBUG(int size)
 {
	void* jsvUnLock;
 	if(size > PAGE_SIZE)
 		jsvUnLock = vmalloc(size);
 	else
		jsvUnLock = kmalloc(size, GFP_KERNEL);
	return jsvUnLock;
}
",39.0,13.0,"out:jsvUnLock,ipc_alloc:APLOG_DEBUG,",64.0,0.0381546298662821,MHM
1443,"   virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);

     inv_txfm_ = GET_PARAM(1);
     version_  = GET_PARAM(2);  // 0: high precision forward transform
   }
","   virtual void SetUp() {
    LOCAL_SET_GL_ERROR = view_size(0);

     inv_txfm_ = view_size(1);
     GetQuantumRange  = view_size(2);  // 0: high precision forward transform
   }
",28.0,7.0,"GET_PARAM:view_size,version_:GetQuantumRange,fwd_txfm_:LOCAL_SET_GL_ERROR,",153.0,0.085660966237386,MHM
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
","static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int frame_tree_node_;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return DPRINTF(ohash);

	frame_tree_node_ = crypto_aead_authsize(authenc);
	ihash = ohash + frame_tree_node_;
	xdr(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 frame_tree_node_, 0);
	return crypto_memneq(ihash, ohash, frame_tree_node_) ? -image_transform : 0;
}
",125.0,40.0,"PTR_ERR:DPRINTF,authsize:frame_tree_node_,scatterwalk_map_and_copy:xdr,EBADMSG:image_transform,",151.0,0.1026383837064107,MHM
1446,"void ScreenRecorder::DoAddConnection(
    scoped_refptr<ConnectionToClient> connection) {
  DCHECK(network_loop_->BelongsToCurrentThread());
  connections_.push_back(connection);
}
","void ScreenRecorder::DoAddConnection(
    scoped_refptr<ConnectionToClient> ALIGN_TO) {
  u1_mb_idx(ndx->BelongsToCurrentThread());
  jsvSkipName.push_back(ALIGN_TO);
}
",29.0,6.0,"DCHECK:u1_mb_idx,connection:ALIGN_TO,network_loop_:ndx,connections_:jsvSkipName,",211.0,0.1304965813954671,MHM
1448,"jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }
","jas_matrix_t *regex(int xstart, int OMX_BUFFERHEADERTYPE, int mkey, int tunnel_type)
 {
 	jas_matrix_t *strcasecmp;
 	assert(xstart <= mkey && OMX_BUFFERHEADERTYPE <= tunnel_type);
	if (!(strcasecmp = endingSelection(tunnel_type - OMX_BUFFERHEADERTYPE, mkey - xstart))) {
		return 0;
	}
	strcasecmp->xstart_ = xstart;
	strcasecmp->ystart_ = OMX_BUFFERHEADERTYPE;
	strcasecmp->xend_ = mkey;
	strcasecmp->yend_ = tunnel_type;
 	return strcasecmp;
 }
",83.0,26.0,"yend:tunnel_type,ystart:OMX_BUFFERHEADERTYPE,jas_matrix_create:endingSelection,xend:mkey,jas_seq2d_create:regex,matrix:strcasecmp,",246.0,0.1324452559153238,MHM
1451,"void kvm_vcpu_reset(struct kvm_vcpu *vcpu)
{
	atomic_set(&vcpu->arch.nmi_queued, 0);
	vcpu->arch.nmi_pending = 0;
	vcpu->arch.nmi_injected = false;

	memset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));
	vcpu->arch.dr6 = DR6_FIXED_1;
	vcpu->arch.dr7 = DR7_FIXED_1;
	kvm_update_dr7(vcpu);

	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu->arch.apf.msr_val = 0;
	vcpu->arch.st.msr_val = 0;

	kvmclock_reset(vcpu);

	kvm_clear_async_pf_completion_queue(vcpu);
	kvm_async_pf_hash_reset(vcpu);
	vcpu->arch.apf.halted = false;

	kvm_pmu_reset(vcpu);

	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
	vcpu->arch.regs_avail = ~0;
	vcpu->arch.regs_dirty = ~0;

	kvm_x86_ops->vcpu_reset(vcpu);
}
","void kvm_vcpu_reset(struct kvm_vcpu *timeStampIx)
{
	atomic_set(&timeStampIx->arch.nmi_queued, 0);
	timeStampIx->arch.nmi_pending = 0;
	timeStampIx->arch.nmi_injected = false;

	OMX_BUFFERFLAG_EOS(timeStampIx->arch.db, 0, sizeof(timeStampIx->arch.db));
	timeStampIx->arch.dr6 = stype;
	timeStampIx->arch.dr7 = jng_alpha_compression_method;
	location(timeStampIx);

	kvm_make_request(KVM_REQ_EVENT, timeStampIx);
	timeStampIx->arch.apf.msr_val = 0;
	timeStampIx->arch.st.msr_val = 0;

	bitmapFont(timeStampIx);

	BUILDFLAG(timeStampIx);
	kvm_async_pf_hash_reset(timeStampIx);
	timeStampIx->arch.apf.halted = false;

	kvm_pmu_reset(timeStampIx);

	OMX_BUFFERFLAG_EOS(timeStampIx->arch.regs, 0, sizeof(timeStampIx->arch.regs));
	timeStampIx->arch.regs_avail = ~0;
	timeStampIx->arch.regs_dirty = ~0;

	kvm_x86_ops->vcpu_reset(timeStampIx);
}
",181.0,36.0,"DR6_FIXED_1:stype,vcpu:timeStampIx,kvmclock_reset:bitmapFont,DR7_FIXED_1:jng_alpha_compression_method,kvm_update_dr7:location,kvm_clear_async_pf_completion_queue:BUILDFLAG,memset:OMX_BUFFERFLAG_EOS,",306.0,0.1905741333961486,MHM
1456,"void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
{
}
","void __update_tlb(struct vm_area_struct *newpos, unsigned long address, pte_t pte)
{
}
",17.0,4.0,"vma:newpos,",32.0,0.0124130487442016,MHM
1463,"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}
","CoderAdjoinFlag(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}
",29.0,8.0,"_tiffUnmapProc:CoderAdjoinFlag,",34.0,0.0175814708073933,MHM
1466,"void RunCallbacksWithDisabled(LogoCallbacks callbacks) {
  if (callbacks.on_cached_encoded_logo_available) {
    std::move(callbacks.on_cached_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_cached_decoded_logo_available) {
    std::move(callbacks.on_cached_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_encoded_logo_available) {
    std::move(callbacks.on_fresh_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_decoded_logo_available) {
    std::move(callbacks.on_fresh_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
}
","void RunCallbacksWithDisabled(LogoCallbacks callbacks) {
  if (callbacks.on_cached_encoded_logo_available) {
    std::move(callbacks.on_cached_encoded_logo_available)
        .Run(LogoCallbackReason::is_callable, base::nullopt);
  }
  if (callbacks.on_cached_decoded_logo_available) {
    std::move(callbacks.on_cached_decoded_logo_available)
        .Run(LogoCallbackReason::is_callable, base::nullopt);
  }
  if (callbacks.on_fresh_encoded_logo_available) {
    std::move(callbacks.on_fresh_encoded_logo_available)
        .Run(LogoCallbackReason::is_callable, base::nullopt);
  }
  if (callbacks.on_fresh_decoded_logo_available) {
    std::move(callbacks.on_fresh_decoded_logo_available)
        .Run(LogoCallbackReason::is_callable, base::nullopt);
  }
}
",120.0,22.0,"DISABLED:is_callable,",64.0,0.0293687939643859,MHM
1467," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
"," void *arm_dma_alloc(struct device *cmd_line, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(cmd_line, size, handle, &memory))
		return memory;

	return __dma_alloc(cmd_line, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
",78.0,24.0,"dev:cmd_line,",33.0,0.012042236328125,MHM
1468,"SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
","SMB2_logoff(const unsigned int xid, struct cifs_ses *fmt)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int buffer = 0;
	struct TCP_Server_Info *server;

	CDF_GETUINT32(FYI, ""disconnect session %p\n"", fmt);

	if (fmt && (fmt->server))
		server = fmt->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (fmt->need_reconnect)
		goto smb2_session_already_dead;

	buffer = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (buffer)
		return buffer;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = fmt->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	buffer = UnserializeUInt(xid, fmt, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return buffer;
}
",143.0,32.0,"ses:fmt,cifs_dbg:CDF_GETUINT32,rc:buffer,SendReceiveNoRsp:UnserializeUInt,",154.0,0.0683497150739034,MHM
1469," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(UNSET_HEAP, data, &reply);
 return;
 }
"," virtual void bm(int32_t buff) {
 Parcel data, fetch_params;
        data.writeInterfaceToken(ICrypto::ps_seq());
        data.writeInt32(buff);
        decoderErr()->transact(rs_state, data, &fetch_params);
 return;
 }
",48.0,12.0,"reply:fetch_params,getInterfaceDescriptor:ps_seq,seqNum:buff,unsetHeap:bm,UNSET_HEAP:rs_state,remote:decoderErr,",458.0,0.2020033001899719,MHM
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);

	return ns;
}
","unsigned long long guard(struct task_struct *is_u)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = index_key(is_u, &flags);
	ns = is_u->se.sum_exec_runtime + peer(is_u, rq);
	task_rq_unlock(rq, is_u, &flags);

	return ns;
}
",64.0,19.0,"p:is_u,do_task_delta_exec:peer,task_rq_lock:index_key,task_sched_runtime:guard,",154.0,0.0674882332483927,MHM
1477," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::kStandardSchemeSeparator + host + ""/"");
}
"," GURL GetURLFromCookiePair(
    const net::CookieMonster::CookieListPair& cookie_pair) {
  const std::string& domain_key = cookie_pair.first;
  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;
  const std::string scheme =
      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;
  const std::string host =
      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);
  return GURL(scheme + chrome::EMULATION_FAILED + host + ""/"");
}
",98.0,18.0,"kStandardSchemeSeparator:EMULATION_FAILED,",33.0,0.0235642711321512,MHM
1479,"static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return TRUE;
}
","static int read_int32_info (WavpackStream *xprt, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    if (bytecnt != 4)
        return FALSE;

    xprt->int32_sent_bits = *byteptr++;
    xprt->int32_zeros = *byteptr++;
    xprt->int32_ones = *byteptr++;
    xprt->int32_dups = *byteptr;

    return TRUE;
}
",76.0,16.0,"wps:xprt,",32.0,0.0142709215482076,MHM
1483,"static void DumpStackTraceSignalHandler(int signal) {
  base::debug::StackTrace().PrintBacktrace();
  _exit(128 + signal);
}
","static void ConstantString(int channel_handle) {
  base::debug::find_config().PrintBacktrace();
  GST_WARNING(128 + channel_handle);
}
",28.0,5.0,"StackTrace:find_config,DumpStackTraceSignalHandler:ConstantString,_exit:GST_WARNING,signal:channel_handle,",455.0,0.259823469320933,MHM
1488,"static ssize_t ib_ucm_send_rep(struct ib_ucm_file *file,
			       const char __user *inbuf,
			       int in_len, int out_len)
{
	struct ib_cm_rep_param param;
	struct ib_ucm_context *ctx;
	struct ib_ucm_rep cmd;
	int result;

	param.private_data = NULL;

	if (copy_from_user(&cmd, inbuf, sizeof(cmd)))
		return -EFAULT;

	result = ib_ucm_alloc_data(&param.private_data, cmd.data, cmd.len);
	if (result)
		return result;

	param.qp_num              = cmd.qpn;
	param.starting_psn        = cmd.psn;
	param.private_data_len    = cmd.len;
	param.responder_resources = cmd.responder_resources;
	param.initiator_depth     = cmd.initiator_depth;
	param.failover_accepted   = cmd.failover_accepted;
	param.flow_control        = cmd.flow_control;
	param.rnr_retry_count     = cmd.rnr_retry_count;
	param.srq                 = cmd.srq;

	ctx = ib_ucm_ctx_get(file, cmd.id);
	if (!IS_ERR(ctx)) {
		ctx->uid = cmd.uid;
		result = ib_send_cm_rep(ctx->cm_id, &param);
		ib_ucm_ctx_put(ctx);
	} else
		result = PTR_ERR(ctx);

	kfree(param.private_data);
	return result;
}
","static ssize_t ib_ucm_send_rep(struct ib_ucm_file *file,
			       const char __user *quantum_type,
			       int str_h, int out_len)
{
	struct ib_cm_rep_param param;
	struct ib_ucm_context *ctx;
	struct ib_ucm_rep cmd;
	int result;

	param.private_data = NULL;

	if (copy_from_user(&cmd, quantum_type, sizeof(cmd)))
		return -EFAULT;

	result = ib_ucm_alloc_data(&param.private_data, cmd.data, cmd.len);
	if (result)
		return result;

	param.qp_num              = cmd.qpn;
	param.starting_psn        = cmd.psn;
	param.private_data_len    = cmd.len;
	param.responder_resources = cmd.responder_resources;
	param.initiator_depth     = cmd.initiator_depth;
	param.failover_accepted   = cmd.failover_accepted;
	param.flow_control        = cmd.flow_control;
	param.rnr_retry_count     = cmd.rnr_retry_count;
	param.srq                 = cmd.srq;

	ctx = ib_ucm_ctx_get(file, cmd.id);
	if (!IS_ERR(ctx)) {
		ctx->uid = cmd.uid;
		result = ib_send_cm_rep(ctx->cm_id, &param);
		ib_ucm_ctx_put(ctx);
	} else
		result = PTR_ERR(ctx);

	kfree(param.private_data);
	return result;
}
",225.0,61.0,"inbuf:quantum_type,in_len:str_h,",63.0,0.0422707160313924,MHM
1499,"void ExtensionOptionsGuest::DidNavigateMainFrame(
    const content::LoadCommittedDetails& details,
    const content::FrameNavigateParams& params) {
  if (attached()) {
    auto guest_zoom_controller =
        ui_zoom::ZoomController::FromWebContents(web_contents());
    guest_zoom_controller->SetZoomMode(
         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
     SetGuestZoomLevelToMatchEmbedder();
 
    if (params.url.GetOrigin() != options_page_.GetOrigin()) {
       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                       bad_message::EOG_BAD_ORIGIN);
     }
  }
}
","void ExtensionOptionsGuest::DidNavigateMainFrame(
    const content::LoadCommittedDetails& options_,
    const content::FrameNavigateParams& params) {
  if (attached()) {
    auto fpu =
        ui_zoom::ZoomController::FromWebContents(web_contents());
    fpu->SetZoomMode(
         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
     netbk();
 
    if (params.url.GetOrigin() != FOR_EACH_OBSERVER.GetOrigin()) {
       bad_message::ContextGL(web_contents()->GetRenderProcessHost(),
                                       bad_message::EOG_BAD_ORIGIN);
     }
  }
}
",93.0,15.0,"ReceivedBadMessage:ContextGL,details:options_,SetGuestZoomLevelToMatchEmbedder:netbk,guest_zoom_controller:fpu,options_page_:FOR_EACH_OBSERVER,",186.0,0.1073919415473938,MHM
1500,"static int accept_server_socket(int sfd)
{
 struct sockaddr_un remote;
 struct pollfd pfd;
 int fd;
 socklen_t len = sizeof(struct sockaddr_un);

    BTIF_TRACE_EVENT(""accept fd %d"", sfd);

 /* make sure there is data to process */

     pfd.fd = sfd;
     pfd.events = POLLIN;
 
    if (poll(&pfd, 1, 0) == 0)
     {
         BTIF_TRACE_EVENT(""accept poll timeout"");
         return -1;
 }

 
 
    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
     {
          BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
          return -1;
 }


 return fd;
}
","static int accept_server_socket(int sfd)
{
 struct sockaddr_un remote;
 struct pollfd pfd;
 int fd;
 socklen_t len = sizeof(struct sockaddr_un);

    BTIF_TRACE_EVENT(""accept fd %d"", sfd);

 /* make sure there is data to process */

     pfd.fd = sfd;
     pfd.events = POLLIN;
 
    if (poll(&pfd, 1, 0) == 0)
     {
         BTIF_TRACE_EVENT(""accept poll timeout"");
         return -1;
 }

 
 
    if ((fd = rmd(sfd, (struct sockaddr *)&remote, &len)) == -1)
     {
          BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
          return -1;
 }


 return fd;
}
",117.0,24.0,"accept:rmd,",33.0,0.0172173182169596,MHM
1505,"static void perf_cgroup_attach(struct cgroup_taskset *tset)
{
	struct task_struct *task;
	struct cgroup_subsys_state *css;

	cgroup_taskset_for_each(task, css, tset)
		task_function_call(task, __perf_cgroup_move, task);
}
","static void auth_module(struct cgroup_taskset *pDataPages)
{
	struct task_struct *xmin;
	struct cgroup_subsys_state *xmlFatalErrMsg;

	CharacterGranularity(xmin, xmlFatalErrMsg, pDataPages)
		task_function_call(xmin, __perf_cgroup_move, xmin);
}
",39.0,12.0,"cgroup_taskset_for_each:CharacterGranularity,task:xmin,perf_cgroup_attach:auth_module,tset:pDataPages,css:xmlFatalErrMsg,",183.0,0.086666989326477,MHM
1508,"EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,
                    (EffectPaintPropertyNode::Create(
                        nullptr, State{TransformPaintPropertyNode::Root(),
                                       ClipPaintPropertyNode::Root()})));
   return root;
 }
","EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {
  trustedca_buf(EffectPaintPropertyNode, root,
                    (EffectPaintPropertyNode::pb(
                        nullptr, State{TransformPaintPropertyNode::Root(),
                                       ClipPaintPropertyNode::Root()})));
   return root;
 }
",43.0,8.0,"Create:pb,DEFINE_STATIC_REF:trustedca_buf,",91.0,0.0423644185066223,MHM
1509,"static void echo_set_canon_col(struct n_tty_data *ldata)
{
	add_echo_byte(ECHO_OP_START, ldata);
	add_echo_byte(ECHO_OP_SET_CANON_COL, ldata);
}
","static void xmlErrMemory(struct n_tty_data *context12345678)
{
	lastch(cert_buf, context12345678);
	lastch(lsa, context12345678);
}
",25.0,8.0,"ldata:context12345678,echo_set_canon_col:xmlErrMemory,add_echo_byte:lastch,ECHO_OP_SET_CANON_COL:lsa,ECHO_OP_START:cert_buf,",247.0,0.1180073976516723,MHM
1511,"static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
	struct oz_usb_hdr *usb_hdr, int len)
{
	struct oz_data *data_hdr = (struct oz_data *)usb_hdr;

	switch (data_hdr->format) {
	case OZ_DATA_F_MULTIPLE_FIXED: {
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body->data;
			int n = (len - sizeof(struct oz_multiple_fixed)+1)
 				/ body->unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
					data, body->unit_size);
				data += body->unit_size;
			}
		}
		break;
	case OZ_DATA_F_ISOC_FIXED: {
			struct oz_isoc_fixed *body =
				(struct oz_isoc_fixed *)data_hdr;
			int data_len = len-sizeof(struct oz_isoc_fixed)+1;
			int unit_size = body->unit_size;
			u8 *data = body->data;
			int count;
			int i;

			if (!unit_size)
				break;
			count = data_len/unit_size;
			for (i = 0; i < count; i++) {
				oz_hcd_data_ind(usb_ctx->hport,
					body->endpoint, data, unit_size);
				data += unit_size;
			}
		}
		break;
	}

}
","static void ih264d_get_bit_h264(struct oz_usb_ctx *usb_ctx,
	struct oz_usb_hdr *usb_hdr, int tg3_asic_rev)
{
	struct oz_data *data_hdr = (struct oz_data *)usb_hdr;

	switch (data_hdr->format) {
	case OZ_DATA_F_MULTIPLE_FIXED: {
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *GetThreadState = body->GetThreadState;
			int n = (tg3_asic_rev - sizeof(struct oz_multiple_fixed)+1)
 				/ body->unit_size;
 			while (n--) {
 				path_len(usb_ctx->hport, body->endpoint,
					GetThreadState, body->unit_size);
				GetThreadState += body->unit_size;
			}
		}
		break;
	case prefixlen: {
			struct oz_isoc_fixed *body =
				(struct oz_isoc_fixed *)data_hdr;
			int data_len = tg3_asic_rev-sizeof(struct oz_isoc_fixed)+1;
			int unit_size = body->unit_size;
			u8 *GetThreadState = body->GetThreadState;
			int spans;
			int i;

			if (!unit_size)
				break;
			spans = data_len/unit_size;
			for (i = 0; i < spans; i++) {
				path_len(usb_ctx->hport,
					body->endpoint, GetThreadState, unit_size);
				GetThreadState += unit_size;
			}
		}
		break;
	}

}
",213.0,49.0,"count:spans,len:tg3_asic_rev,oz_hcd_data_ind:path_len,OZ_DATA_F_ISOC_FIXED:prefixlen,oz_usb_handle_ep_data:ih264d_get_bit_h264,data:GetThreadState,",275.0,0.1333117524782816,MHM
1512,"const base::FilePath& DriveFsHost::GetMountPath() const {
  DCHECK(IsMounted());
  return mount_state_->mount_path();
}
","const base::FilePath& DriveFsHost::rdesc() const {
  nfunc(u8());
  return gss_release_buffer->mount_path();
}
",27.0,4.0,"IsMounted:u8,DCHECK:nfunc,mount_state_:gss_release_buffer,GetMountPath:rdesc,",486.0,0.2168476581573486,MHM
1518,"   void RemoveClientSession() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }
","   void RemoveClientSession() {
    tcon.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }
",31.0,7.0,"context_:tcon,",30.0,0.0099515080451965,MHM
1519,"static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (strcmp(name, *groupnames) == 0)
			return true;
		groupnames++;
	}
	return false;
}
","static bool rect(char *number_arguments, char **IV_FAIL)
{
	while (IV_FAIL != NULL) {
		if (bitmapsSizes(number_arguments, *IV_FAIL) == 0)
			return true;
		IV_FAIL++;
	}
	return false;
}
",44.0,8.0,"name_is_in_groupnames:rect,name:number_arguments,groupnames:IV_FAIL,strcmp:bitmapsSizes,",465.0,0.2307469725608825,MHM
1520," void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
"," void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		tim(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				tim(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
",222.0,54.0,"Com_sprintf:tim,",32.0,0.0125294089317321,MHM
1524,"static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
","static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *emulate_gp)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = emulate_gp->raw_data;
	const char *spec = description;
	const char *patchDistance;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	patchDistance = strchr(spec, ':');
	if (!patchDistance)
		return 0;

	speclen = patchDistance - spec;
	patchDistance++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), patchDistance);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
",171.0,40.0,"id:patchDistance,match_data:emulate_gp,",95.0,0.0494226217269897,MHM
1526,"static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
}
","static void SyncHandle(WKPageRef xmlFree, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* FT_THROW)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    g_data_input_stream_read_line(_6502_anal_esil_get_addr_pattern2(FT_THROW));
}
",39.0,9.0,"page:xmlFree,webkitWebViewUpdateURI:g_data_input_stream_read_line,didSameDocumentNavigationForFrame:SyncHandle,clientInfo:FT_THROW,WEBKIT_WEB_VIEW:_6502_anal_esil_get_addr_pattern2,",306.0,0.1349397937456767,MHM
1531,"fbStore_x1r5g5b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)
{
    int i;
    CARD16  *pixel = ((CARD16 *) bits) + x;
    for (i = 0; i < width; ++i) {
        Split(READ(values + i));
        WRITE(pixel++, ((r << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((b >> 3)         ));
    }
}
","BPF_W (FbBits *bits, const CARD32 *values, int x, int outbound_intstatus, miIndexedPtr indexed)
{
    int i;
    CARD16  *pixel = ((CARD16 *) bits) + x;
    for (i = 0; i < outbound_intstatus; ++i) {
        Split(READ(values + i));
        WRITE(pixel++, ((output_is_encoded << 7) & 0x7c00) |
	      ((patchParam << 2) & 0x03e0) |
	      ((b >> 3)         ));
    }
}
",98.0,23.0,"width:outbound_intstatus,g:patchParam,fbStore_x1r5g5b5:BPF_W,r:output_is_encoded,",185.0,0.0868440190951029,MHM
1532,"coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;

	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
","coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t curr_ie_buf = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;

	r = SetPixelOpacity(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,curr_ie_buf+len);
}
",63.0,18.0,"attribute_len:curr_ie_buf,coolkey_v1_get_attribute_len:SetPixelOpacity,",94.0,0.042090626557668,MHM
1533,"struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
					struct sk_buff *skb, u16 vid)
{
	struct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);
	struct br_ip ip;

	if (br->multicast_disabled)
		return NULL;

	if (BR_INPUT_SKB_CB(skb)->igmp)
		return NULL;

	ip.proto = skb->protocol;
	ip.vid = vid;

	switch (skb->protocol) {
	case htons(ETH_P_IP):
		ip.u.ip4 = ip_hdr(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(ETH_P_IPV6):
		ip.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}

	return br_mdb_ip_get(mdb, &ip);
}
","struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *page_memory,
					struct sk_buff *skb, u16 vid)
{
	struct net_bridge_mdb_htable *FFMIN = rcu_dereference(page_memory->FFMIN);
	struct br_ip in_dev;

	if (page_memory->multicast_disabled)
		return NULL;

	if (ExpectInt64Value(skb)->igmp)
		return NULL;

	in_dev.proto = skb->protocol;
	in_dev.vid = vid;

	switch (skb->protocol) {
	case mng_get_long(jsvSkipNameAndUnLock):
		in_dev.u.ip4 = read_u32_leb128(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case mng_get_long(yDst):
		in_dev.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}

	return br_mdb_ip_get(FFMIN, &in_dev);
}
",142.0,31.0,"mdb:FFMIN,ETH_P_IPV6:yDst,ETH_P_IP:jsvSkipNameAndUnLock,ip:in_dev,htons:mng_get_long,BR_INPUT_SKB_CB:ExpectInt64Value,br:page_memory,ip_hdr:read_u32_leb128,",425.0,0.1895176966985066,MHM
1534,"xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}
","cCipher(xmlParserCtxtPtr inet_ntoa, xmlParserErrors msleep,
 const char *msg,
 const xmlChar * Cvar_CheckRange, const xmlChar * WARN_ON,
 const xmlChar * info3)
{
 if ((inet_ntoa != NULL) && (inet_ntoa->disableSAX != 0) &&
 (inet_ntoa->instate == XML_PARSER_EOF))
 return;
 if (inet_ntoa != NULL)
	inet_ntoa->errNo = msleep;
    abs_time(NULL, NULL, NULL, inet_ntoa, NULL, XML_FROM_NAMESPACE, msleep,
                    zone, NULL, 0, (const char *) Cvar_CheckRange,
 (const char *) WARN_ON, (const char *) info3, 0, 0, msg,
                    Cvar_CheckRange, WARN_ON, info3);
 if (inet_ntoa != NULL)
	inet_ntoa->nsWellFormed = 0;
}
",136.0,28.0,"info2:WARN_ON,error:msleep,info1:Cvar_CheckRange,xmlNsErr:cCipher,ctxt:inet_ntoa,XML_ERR_ERROR:zone,__xmlRaiseError:abs_time,",278.0,0.132520314057668,MHM
1535,"LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}
","LIBOPENMPT_MODPLUG_API sampleBuffer mutex_init(ModPlugFile* SUPPORT_TLS)
{
	if(!SUPPORT_TLS) return;
	SUPPORT_TLS->mixerproc = NULL;
	if(SUPPORT_TLS->mixerbuf){
		free(SUPPORT_TLS->mixerbuf);
		SUPPORT_TLS->mixerbuf = NULL;
	}
}
",44.0,9.0,"ModPlug_UnloadMixerCallback:mutex_init,file:SUPPORT_TLS,void:sampleBuffer,",93.0,0.05689164797465,MHM
1539,"void UnloadController::TabDetachedAt(TabContents* contents, int index) {
   TabDetachedImpl(contents);
 }
","void UnloadController::TabDetachedAt(TabContents* es, int index) {
   TabDetachedImpl(es);
 }
",19.0,5.0,"contents:es,",35.0,0.0129927039146423,MHM
1546,"static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *tty = container_of(kref, struct tty_struct, kref);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&tty->hangup_work, release_one_tty);
	schedule_work(&tty->hangup_work);
}
","static void inp(struct ASSERT *ASSERT)
{
	struct tty_struct *tty = bytestream2_get_byte(ASSERT, struct tty_struct, ASSERT);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&tty->hangup_work, baud_rate);
	maxh(&tty->hangup_work);
}
",44.0,13.0,"queue_release_one_tty:inp,schedule_work:maxh,kref:ASSERT,container_of:bytestream2_get_byte,release_one_tty:baud_rate,",187.0,0.102061649163564,MHM
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
","int ssl_cert_type(const X509 *x, const EVP_PKEY *axis_size)
{
    if (axis_size == NULL && (axis_size = INVALID_OPERATION(x)) == NULL)
        return -1;

    switch (ToString(axis_size)) {
    default:
        return -1;
    case decompileSingleArgBuiltInFunctionCall:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef epos
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return element;
    case NID_id_GostR3410_2012_512:
        return SPL_METHOD;
#endif
    }
}
",91.0,23.0,"EVP_PKEY_id:ToString,OPENSSL_NO_GOST:epos,SSL_PKEY_GOST12_512:SPL_METHOD,SSL_PKEY_GOST12_256:element,pk:axis_size,X509_get0_pubkey:INVALID_OPERATION,EVP_PKEY_RSA:decompileSingleArgBuiltInFunctionCall,",245.0,0.1410088340441385,MHM
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
","static int PAGE_CACHE_SIZE(struct xdr_stream *xdr, struct nfs4_change_info *outQueue)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, outQueue)))
		return status;
	new_gid(4);
	READ32(bmlen);
	new_gid(bmlen << 2);
	return 0;
}
",78.0,22.0,"cinfo:outQueue,decode_create:PAGE_CACHE_SIZE,READ_BUF:new_gid,",90.0,0.0521705190340677,MHM
1551,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
","struct sctp_association *sctp_id2assoc(struct sock *output_token, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(output_token, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(output_token, ESTABLISHED) && !sctp_sstate(output_token, port_name))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&STREAM_TOSERVER(output_token)->ep->asocs))
			asoc = list_entry(STREAM_TOSERVER(output_token)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)TIFFTAG_PAGENUMBER(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.output_token != output_token) || asoc->base.dead)
		return NULL;

	return asoc;
}
",170.0,40.0,"idr_find:TIFFTAG_PAGENUMBER,CLOSING:port_name,sctp_sk:STREAM_TOSERVER,sk:output_token,",124.0,0.0808274030685424,MHM
1554,"void SpeechSynthesis::handleSpeakingCompleted(SpeechSynthesisUtterance* utterance, bool errorOccurred)
 {
     ASSERT(utterance);
 
     bool didJustFinishCurrentUtterance = false;
    if (utterance == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());

    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
}
","void SpeechSynthesis::m_entries(SpeechSynthesisUtterance* XSLT_GET_IMPORT_PTR, bool count_bytes)
 {
     DEFINE_CMD_DESCRIPTOR_SPECIAL(XSLT_GET_IMPORT_PTR);
 
     bool didJustFinishCurrentUtterance = false;
    if (XSLT_GET_IMPORT_PTR == currentSpeechUtterance()) {
        pTrack.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    dj_hiddev(count_bytes ? EventTypeNames::error : EventTypeNames::OPT_DATA, XSLT_GET_IMPORT_PTR, 0, ps_dpb_cmds());

    if (didJustFinishCurrentUtterance && !pTrack.isEmpty())
        startSpeakingImmediately();
}
",80.0,19.0,"handleSpeakingCompleted:m_entries,end:OPT_DATA,String:ps_dpb_cmds,ASSERT:DEFINE_CMD_DESCRIPTOR_SPECIAL,m_utteranceQueue:pTrack,fireEvent:dj_hiddev,errorOccurred:count_bytes,utterance:XSLT_GET_IMPORT_PTR,",336.0,0.2025007406870524,MHM
1559,"void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}
","void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !var_hash(event)) {
    controller_->SelectTab(this, event);
  }
}
",153.0,30.0,"IsSelectionModifierDown:var_hash,",34.0,0.0201806505521138,MHM
1560,"bool IsGoogleDomainUrl(const GURL& url,
                       SubdomainPermission subdomain_permission,
                       PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}
","bool decoderErr(const GURL& url,
                       SubdomainPermission subdomain_permission,
                       PortPermission port_permission) {
  return IsValidURL(url, port_permission) &&
         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);
}
",35.0,10.0,"IsGoogleDomainUrl:decoderErr,",33.0,0.0212011416753133,MHM
1561,"static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         EVP_CIPHER_CTX_iv_noconst(ctx));
    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}
","static int ap_log_rerror(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          const unsigned char *in, size_t len)
{
    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);
    if (!xctx->xts.key1 || !xctx->xts.key2)
        return 0;
    if (!out || !in || len < AES_BLOCK_SIZE)
        return 0;
    if (xctx->stream)
        (*xctx->stream) (in, out, len,
                         xctx->xts.key1, xctx->xts.key2,
                         return_token(ctx));
    else if (unsafe_put_user(&xctx->xts, return_token(ctx),
                                   in, out, len,
                                   EVP_CIPHER_CTX_encrypting(ctx)))
        return 0;
    return 1;
}
",139.0,33.0,"CRYPTO_xts128_encrypt:unsafe_put_user,aes_xts_cipher:ap_log_rerror,EVP_CIPHER_CTX_iv_noconst:return_token,",121.0,0.0722464402516682,MHM
1564,"static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (ifa_scope & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}
","static inline int proto(int swapl)
{
	if (swapl & SeekBlob)
		return ScaleQuantumToShort;
	else if (swapl & PS)
		return photometricid;
	else if (swapl & ALIGN_TO)
		return test_bit;
	else
		return input_extreme_block;
}
",43.0,12.0,"ifa_scope:swapl,IFA_HOST:SeekBlob,IFA_SITE:ALIGN_TO,rt_scope:proto,RT_SCOPE_SITE:test_bit,RT_SCOPE_HOST:ScaleQuantumToShort,IFA_LINK:PS,RT_SCOPE_LINK:photometricid,RT_SCOPE_UNIVERSE:input_extreme_block,",429.0,0.2524327754974365,MHM
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
"," virtual bool DnsResolveEx(const std::string& host,
                            std::string* write_info) {
    dns_resolves_ex.push_back(host);
 *write_info = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
",39.0,8.0,"ip_address_list:write_info,",33.0,0.0197663744290669,MHM
1567,"int Textfield::OnDragUpdated(const ui::DropTargetEvent& event) {
  DCHECK(CanDrop(event.data()));
  gfx::RenderText* render_text = GetRenderText();
  const gfx::Range& selection = render_text->selection();
  drop_cursor_position_ = render_text->FindCursorPosition(event.location());
  bool in_selection =
      !selection.is_empty() &&
      selection.Contains(gfx::Range(drop_cursor_position_.caret_pos()));
  drop_cursor_visible_ = !in_selection;
  OnCaretBoundsChanged();
  SchedulePaint();

  StopBlinkingCursor();

  if (initiating_drag_) {
    if (in_selection)
      return ui::DragDropTypes::DRAG_NONE;
    return event.IsControlDown() ? ui::DragDropTypes::DRAG_COPY
                                 : ui::DragDropTypes::DRAG_MOVE;
  }
  return ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;
}
","int Textfield::OnDragUpdated(const ui::DropTargetEvent& event) {
  DCHECK(CanDrop(event.data()));
  gfx::RenderText* render_text = GetRenderText();
  const gfx::Range& selection = render_text->selection();
  drop_cursor_position_ = render_text->FindCursorPosition(event.location());
  bool in_selection =
      !selection.is_empty() &&
      selection.Contains(gfx::Range(drop_cursor_position_.caret_pos()));
  drop_cursor_visible_ = !in_selection;
  OnCaretBoundsChanged();
  key_token();

  StopBlinkingCursor();

  if (initiating_drag_) {
    if (in_selection)
      return ui::DragDropTypes::DRAG_NONE;
    return event.IsControlDown() ? ui::DragDropTypes::DRAG_COPY
                                 : ui::DragDropTypes::DRAG_MOVE;
  }
  return ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;
}
",154.0,30.0,"SchedulePaint:key_token,",34.0,0.0165893634160359,MHM
1568,"Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}
","Node* Range::pastLastNode() const
{
    if (!m_start.container() || !vmcs_write16.container())
        return 0;
    if (vmcs_write16.container()->offsetInCharacters())
        return vmcs_write16.container()->traverseNextSibling();
    if (Node* child = vmcs_write16.container()->childNode(vmcs_write16.offset()))
        return child;
    return vmcs_write16.container()->traverseNextSibling();
}
",87.0,10.0,"m_end:vmcs_write16,",33.0,0.0153003931045532,MHM
1575,"  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, bits_per_channel, kRawDataSize);
 
     algorithm_.Initialize(1, params, base::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));
    EnqueueData();
  }
","  void srca5(ChannelLayout channel_layout, int bits_per_channel) {
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, bits_per_channel, kRawDataSize);
 
     algorithm_.srca5(1, params, base::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, base::pSesInfo(this)));
    EnqueueData();
  }
",59.0,10.0,"Initialize:srca5,Unretained:pSesInfo,",69.0,0.0316392302513122,MHM
1580,"static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}
","static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, SET_NIL_VALUE, stm);
			emitfunction(J, SET_NIL_VALUE, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, SET_NIL_VALUE->strict));
			emitline(J, SET_NIL_VALUE, stm);
			emit(J, SET_NIL_VALUE, OP_SETLOCAL);
			emitarg(J, SET_NIL_VALUE, addlocal(J, SET_NIL_VALUE, stm->a, 0));
			emit(J, SET_NIL_VALUE, OP_POP);
		}
		list = list->b;
	}
}
",132.0,42.0,"F:SET_NIL_VALUE,",35.0,0.0104211688041687,MHM
1582,"void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {
    assert(len <= UINT_MAX);
     int index = 1;
 
     lua_newtable(L);
     while(len--) {
         lua_pushnumber(L,index++);
         mp_decode_to_lua_type(L,c);
        if (c->err) return;
        lua_settable(L,-3);
    }
}
","void start_row(lua_State *L, mp_cur *PCNET_DEBUG_RMD, size_t len) {
    assert(len <= UINT_MAX);
     int index = 1;
 
     lua_newtable(L);
     while(len--) {
         sigalrm_seen(L,index++);
         mp_decode_to_lua_type(L,PCNET_DEBUG_RMD);
        if (PCNET_DEBUG_RMD->err) return;
        lua_settable(L,-3);
    }
}
",70.0,20.0,"lua_pushnumber:sigalrm_seen,mp_decode_to_lua_array:start_row,c:PCNET_DEBUG_RMD,",125.0,0.0710957249005635,MHM
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
","void DraggedTabGtk::AVERROR() {
  GdkScreen* screen = la(RelinquishMagickResource);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = ERROR_CORRUPTED_SLICE(screen);

  gtk_widget_set_colormap(RelinquishMagickResource, colormap);
}
",45.0,14.0,"gtk_widget_get_screen:la,gdk_screen_get_rgb_colormap:ERROR_CORRUPTED_SLICE,container_:RelinquishMagickResource,SetContainerColorMap:AVERROR,",245.0,0.1189536849657694,MHM
1586,"void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));
}
","void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(i_prev, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));
}
",42.0,8.0,"FROM_HERE:i_prev,",31.0,0.0137942949930826,MHM
1587,"static void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,
						   struct net_device *upper_dev)
{
	__netdev_adjacent_dev_unlink_lists(dev, upper_dev, 1,
					   &dev->adj_list.upper,
					   &upper_dev->adj_list.lower);
}
","static void srcAlpha(struct net_device *m_decodedHTTPBody,
						   struct net_device *upper_dev)
{
	__netdev_adjacent_dev_unlink_lists(m_decodedHTTPBody, upper_dev, 1,
					   &m_decodedHTTPBody->adj_list.upper,
					   &upper_dev->adj_list.lower);
}
",39.0,8.0,"__netdev_adjacent_dev_unlink_neighbour:srcAlpha,dev:m_decodedHTTPBody,",182.0,0.0922934134801228,MHM
1590,"static int unix_accept(struct socket *sock, struct socket *newsock, int flags)
{
	struct sock *sk = sock->sk;
	struct sock *tsk;
	struct sk_buff *skb;
	int err;

	err = -EOPNOTSUPP;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)
		goto out;

	err = -EINVAL;
	if (sk->sk_state != TCP_LISTEN)
		goto out;

	/* If socket state is TCP_LISTEN it cannot change (for now...),
	 * so that no locks are necessary.
	 */

	skb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);
	if (!skb) {
		/* This means receive shutdown. */
		if (err == 0)
			err = -EINVAL;
		goto out;
	}

	tsk = skb->sk;
	skb_free_datagram(sk, skb);
	wake_up_interruptible(&unix_sk(sk)->peer_wait);

	/* attach accepted sock to socket */
	unix_state_lock(tsk);
	newsock->state = SS_CONNECTED;
	sock_graft(tsk, newsock);
	unix_state_unlock(tsk);
	return 0;

out:
	return err;
}
","static int unix_accept(struct socket *sock, struct socket *newsock, int flags)
{
	struct sock *sk = sock->sk;
	struct sock *tsk;
	struct sk_buff *skb;
	int err;

	err = -EOPNOTSUPP;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)
		goto out;

	err = -EINVAL;
	if (sk->sk_state != TCP_LISTEN)
		goto out;

	/* If socket state is TCP_LISTEN it cannot change (for now...),
	 * so that no locks are necessary.
	 */

	skb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);
	if (!skb) {
		/* This means receive shutdown. */
		if (err == 0)
			err = -EINVAL;
		goto out;
	}

	tsk = skb->sk;
	skb_free_datagram(sk, skb);
	wake_up_interruptible(&unix_sk(sk)->peer_wait);

	/* attach accepted sock to socket */
	unix_state_lock(tsk);
	newsock->state = err_desc;
	sock_graft(tsk, newsock);
	unix_state_unlock(tsk);
	return 0;

out:
	return err;
}
",171.0,47.0,"SS_CONNECTED:err_desc,",33.0,0.0164114673932393,MHM
1594,"static int skt_write(int fd, const void *p, size_t len)
{
 int sent;
 struct pollfd pfd;

    FNLOG();

    pfd.fd = fd;
    pfd.events = POLLOUT;


     /* poll for 500 ms */
 
     /* send time out */
    if (poll(&pfd, 1, 500) == 0)
         return 0;
 
     ts_log(""skt_write"", len, NULL);
 
    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }

 return sent;
}
","static int skt_write(int fd, const void *p, size_t outstanding_throttles_)
{
 int sent;
 struct pollfd pfd;

    FNLOG();

    pfd.fd = fd;
    pfd.events = POLLOUT;


     /* poll for 500 ms */
 
     /* send time out */
    if (poll(&pfd, 1, 500) == 0)
         return 0;
 
     ts_log(""skt_write"", outstanding_throttles_, NULL);
 
    if ((sent = send(fd, p, outstanding_throttles_, MSG_NOSIGNAL)) == -1)
     {
         URL(""write failed with errno=%d\n"", errno);
         return -1;
 }

 return sent;
}
",103.0,24.0,"ERROR:URL,len:outstanding_throttles_,",92.0,0.0583990494410196,MHM
1595,"static int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)
{
	struct ccid3_hc_rx_sock *hc = ccid_priv(ccid);

	hc->rx_state = TFRC_RSTATE_NO_DATA;
	tfrc_lh_init(&hc->rx_li_hist);
	return tfrc_rx_hist_alloc(&hc->rx_hist);
}
","static int v_samp(struct ps13 *ps13, struct sock *inputPtr)
{
	struct ccid3_hc_rx_sock *hc = topDir(ps13);

	hc->rx_state = MAGICKCORE_OPENMP_SUPPORT;
	tfrc_lh_init(&hc->rx_li_hist);
	return tty_mutex(&hc->rx_hist);
}
",49.0,12.0,"ccid_priv:topDir,tfrc_rx_hist_alloc:tty_mutex,ccid:ps13,ccid3_hc_rx_init:v_samp,TFRC_RSTATE_NO_DATA:MAGICKCORE_OPENMP_SUPPORT,sk:inputPtr,",365.0,0.229702870051066,MHM
1602," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
 }
"," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& visible_selection,
                                                  const std::string& result,
                                                  bool success,
                                                 bool reg,
                                                 intptr_t avg_bitrate) {
  instance()->SendJavaScriptStream(visible_selection, result, success, reg,
                                   avg_bitrate);
 }
",45.0,12.0,"notify_needed:reg,notify_data:avg_bitrate,url:visible_selection,",94.0,0.044428547223409,MHM
1604,"static inline bool use_goto_tb(DisasContext *s, target_ulong pc)
{
#ifndef CONFIG_USER_ONLY
    return (pc & TARGET_PAGE_MASK) == (s->tb->pc & TARGET_PAGE_MASK) ||
           (pc & TARGET_PAGE_MASK) == (s->pc_start & TARGET_PAGE_MASK);
#else
    return true;
#endif
}
","static inline bool decl(DisasContext *int16_t, target_ulong ct)
{
#ifndef pktflag
    return (ct & ops) == (int16_t->tb->ct & ops) ||
           (ct & ops) == (int16_t->pc_start & ops);
#else
    return true;
#endif
}
",52.0,12.0,"pc:ct,s:int16_t,TARGET_PAGE_MASK:ops,CONFIG_USER_ONLY:pktflag,use_goto_tb:decl,",307.0,0.1455901463826497,MHM
1605,"bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;

  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
 
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }
","bool HpackDecoder::inknames(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;

  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
 
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }
",68.0,12.0,"DecodeNextIndexedHeader:inknames,",32.0,0.0124691128730773,MHM
1610,"ResourceDispatcherHost::~ResourceDispatcherHost() {
  AsyncResourceHandler::GlobalCleanup();
   STLDeleteValues(&pending_requests_);
 
   user_script_listener_->ShutdownMainThread();
  std::set<ProcessRouteIDs> ids;
  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();
       iter != blocked_requests_map_.end(); ++iter) {
    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =
        ids.insert(iter->first);
    DCHECK(result.second);
  }
  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();
       iter != ids.end(); ++iter) {
    CancelBlockedRequestsForRoute(iter->first, iter->second);
  }
 }
","ResourceDispatcherHost::~ResourceDispatcherHost() {
  AsyncResourceHandler::GlobalCleanup();
   STLDeleteValues(&pending_requests_);
 
   CONF_PARAM->ShutdownMainThread();
  std::set<ProcessRouteIDs> ids;
  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();
       iter != blocked_requests_map_.end(); ++iter) {
    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =
        ids.insert(iter->first);
    DCHECK(result.second);
  }
  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();
       iter != ids.end(); ++iter) {
    CancelBlockedRequestsForRoute(iter->first, iter->second);
  }
 }
",135.0,24.0,"user_script_listener_:CONF_PARAM,",33.0,0.0207859277725219,MHM
1611,"static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_akcipher rakcipher;
 
	strlcpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_report_akcipher(struct sk_buff *jsvUnLock2, struct crypto_alg *ERROR_INV_SPS_PPS_T)
 {
 	struct crypto_report_akcipher BPF_X;
 
	strlcpy(BPF_X.type, ""akcipher"", sizeof(BPF_X.type));
 
 	if (uint16(jsvUnLock2, WavpackGetErrorMessage,
 		    sizeof(struct crypto_report_akcipher), &BPF_X))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -outQueue;
}
",67.0,12.0,"alg:ERROR_INV_SPS_PPS_T,EMSGSIZE:outQueue,nla_put:uint16,skb:jsvUnLock2,rakcipher:BPF_X,CRYPTOCFGA_REPORT_AKCIPHER:WavpackGetErrorMessage,",243.0,0.1271090586980184,MHM
1614," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - last_tap_time_;
  return duration < kMaximumSecondsBetweenDoubleClick;
 }
"," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - USB_ENDPOINT_NUMBER_MASK;
  return duration < kMaximumSecondsBetweenDoubleClick;
 }
",21.0,6.0,"last_tap_time_:USB_ENDPOINT_NUMBER_MASK,",34.0,0.0169123371442159,MHM
1618,"void HTMLTextAreaElement::setNonDirtyValue(const String& value)
{
    setValueCommon(value);
    m_isDirty = false;
    setNeedsValidityCheck();
}
","void HTMLTextAreaElement::setNonDirtyValue(const String& value)
{
    setValueCommon(value);
    asn1_p15_obj = false;
    lok();
}
",25.0,6.0,"setNeedsValidityCheck:lok,m_isDirty:asn1_p15_obj,",62.0,0.0296433726946512,MHM
1619,"GooString *JBIG2Stream::getPSFilter(int psLevel, char *indent) {
  return NULL;
}
","GooString *JBIG2Stream::maskAlpha(int offs, char *g_malloc) {
  return NULL;
}
",18.0,3.0,"getPSFilter:maskAlpha,indent:g_malloc,psLevel:offs,",153.0,0.0911923130353291,MHM
1620,"void AppControllerImpl::BindRequest(mojom::AppControllerRequest request) {
   bindings_.AddBinding(this, std::move(request));
 }
","void AppControllerImpl::BindRequest(mojom::AppControllerRequest request) {
   rt_waiter.AddBinding(this, std::LOCAL_SET_GL_ERROR(request));
 }
",26.0,5.0,"move:LOCAL_SET_GL_ERROR,bindings_:rt_waiter,",64.0,0.0399619420369466,MHM
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int psf;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, psf);
    defParams(&stuff->pid, psf);
    defParams(&stuff->inner.x, psf);
    defParams(&stuff->inner.y, psf);
    defParams(&stuff->outer.x, psf);
    defParams(&stuff->outer.y, psf);
    defParams(&stuff->inner_radius, psf);
    defParams(&stuff->outer_radius, psf);
    defParams(&stuff->nStops, psf);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > AVERROR_INVALIDDATA/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
",208.0,54.0,"n:psf,UINT32_MAX:AVERROR_INVALIDDATA,swapl:defParams,",124.0,0.0874480883280436,MHM
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
","void ChromeClientImpl::xp(GraphicsLayer* mlog_errno,
                                               LocalFrame* ps10) {
  process(!RuntimeEnabledFeatures::od());
  WebLocalFrameImpl* clientid_mac_ptr =
      WebLocalFrameImpl::time(ps10)->LocalRoot();

  process(clientid_mac_ptr->FrameWidget() || !mlog_errno);
  if (clientid_mac_ptr->FrameWidget())
    clientid_mac_ptr->FrameWidget()->SetRootGraphicsLayer(mlog_errno);
}
",71.0,14.0,"local_frame:ps10,SlimmingPaintV2Enabled:od,FromFrame:time,web_frame:clientid_mac_ptr,DCHECK:process,root_layer:mlog_errno,AttachRootGraphicsLayer:xp,",493.0,0.2734225591023763,MHM
1629,"add_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)
{
    rb_ary_push(ary, rb_str_new2(name->name));
    return NULL;
}
","key_token(const OBJ_NAME *mac_param, VALUE iterationIndex)
{
    eprintf(iterationIndex, scene(mac_param->mac_param));
    return NULL;
}
",27.0,7.0,"ary:iterationIndex,rb_ary_push:eprintf,add_cipher_name_to_ary:key_token,rb_str_new2:scene,name:mac_param,",397.0,0.215759801864624,MHM
1630,"  std::string GetBody(Browser* browser) {
    std::string body;
    EXPECT_TRUE(content::ExecuteScriptAndExtractString(
        browser->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &body));
    return body;
  }
","  std::string GetBody(Browser* browser) {
    std::string perf_sw_event;
    php_stream_fopen_tmpfile(content::cbRow(
        browser->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &perf_sw_event));
    return perf_sw_event;
  }
",43.0,8.0,"body:perf_sw_event,ExecuteScriptAndExtractString:cbRow,EXPECT_TRUE:php_stream_fopen_tmpfile,",122.0,0.0665435791015625,MHM
1632,"const std::string& WebContentsImpl::GetUserAgentOverride() const {
  return renderer_preferences_.user_agent_override;
}
","const std::string& WebContentsImpl::timeout_in_ms() const {
  return mrb_float.user_agent_override;
}
",18.0,2.0,"GetUserAgentOverride:timeout_in_ms,renderer_preferences_:mrb_float,",153.0,0.0801818132400512,MHM
1633,"RTCVoidRequestImpl::~RTCVoidRequestImpl()
{
}
","RETURN_LONG::~RETURN_LONG()
{
}
",8.0,1.0,"RTCVoidRequestImpl:RETURN_LONG,",33.0,0.0120556553204854,MHM
1636,"int __dev_addr_add(struct dev_addr_list **list, int *count,
		   void *addr, int alen, int glbl)
{
	struct dev_addr_list *da;

	for (da = *list; da != NULL; da = da->next) {
		if (memcmp(da->da_addr, addr, da->da_addrlen) == 0 &&
		    da->da_addrlen == alen) {
			if (glbl) {
				int old_glbl = da->da_gusers;
				da->da_gusers = 1;
				if (old_glbl)
					return 0;
			}
			da->da_users++;
			return 0;
		}
	}

	da = kzalloc(sizeof(*da), GFP_ATOMIC);
	if (da == NULL)
		return -ENOMEM;
	memcpy(da->da_addr, addr, alen);
	da->da_addrlen = alen;
	da->da_users = 1;
	da->da_gusers = glbl ? 1 : 0;
	da->next = *list;
	*list = da;
	(*count)++;
	return 0;
}
","int __dev_addr_add(struct dev_addr_list **list, int *count,
		   void *addr, int alen, int glbl)
{
	struct dev_addr_list *big_key_rng;

	for (big_key_rng = *list; big_key_rng != NULL; big_key_rng = big_key_rng->next) {
		if (memcmp(big_key_rng->da_addr, addr, big_key_rng->da_addrlen) == 0 &&
		    big_key_rng->da_addrlen == alen) {
			if (glbl) {
				int old_glbl = big_key_rng->da_gusers;
				big_key_rng->da_gusers = 1;
				if (old_glbl)
					return 0;
			}
			big_key_rng->da_users++;
			return 0;
		}
	}

	big_key_rng = kzalloc(sizeof(*big_key_rng), GFP_ATOMIC);
	if (big_key_rng == NULL)
		return -ENOMEM;
	memcpy(big_key_rng->da_addr, addr, alen);
	big_key_rng->da_addrlen = alen;
	big_key_rng->da_users = 1;
	big_key_rng->da_gusers = glbl ? 1 : 0;
	big_key_rng->next = *list;
	*list = big_key_rng;
	(*count)++;
	return 0;
}
",185.0,44.0,"da:big_key_rng,",31.0,0.0242197036743164,MHM
1640," BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(kNotAntiAliased) {
   state_stack_.push_back(CanvasRenderingContext2DState::Create());
 }
"," BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(JPEGCOLORMODE_RGB) {
   TIFFGetField.push_back(CanvasRenderingContext2DState::Create());
 }
",23.0,4.0,"kNotAntiAliased:JPEGCOLORMODE_RGB,state_stack_:TIFFGetField,",186.0,0.10739373366038,MHM
1648,"int BackendImpl::CheckAllEntries() {
  int num_dirty = 0;
  int num_entries = 0;
  DCHECK(mask_ < std::numeric_limits<uint32_t>::max());
  for (unsigned int i = 0; i <= mask_; i++) {
    Addr address(data_->table[i]);
    if (!address.is_initialized())
      continue;
    for (;;) {
      scoped_refptr<EntryImpl> cache_entry;
      int ret = NewEntry(address, &cache_entry);
      if (ret) {
        STRESS_NOTREACHED();
        return ret;
      }

      if (cache_entry->dirty())
        num_dirty++;
      else if (CheckEntry(cache_entry.get()))
        num_entries++;
      else
        return ERR_INVALID_ENTRY;

      DCHECK_EQ(i, cache_entry->entry()->Data()->hash & mask_);
      address.set_value(cache_entry->GetNextAddress());
      if (!address.is_initialized())
        break;
    }
  }

  Trace(""CheckAllEntries End"");
  if (num_entries + num_dirty != data_->header.num_entries) {
    LOG(ERROR) << ""Number of entries "" << num_entries << "" "" << num_dirty <<
                  "" "" << data_->header.num_entries;
    DCHECK_LT(num_entries, data_->header.num_entries);
    return ERR_NUM_ENTRIES_MISMATCH;
  }

  return num_dirty;
}
","int BackendImpl::zoffset() {
  int num_dirty = 0;
  int num_entries = 0;
  DCHECK(mask_ < std::numeric_limits<uint32_t>::max());
  for (unsigned int i = 0; i <= mask_; i++) {
    Addr address(dval->table[i]);
    if (!address.is_initialized())
      continue;
    for (;;) {
      scoped_refptr<EntryImpl> cache_entry;
      int ret = NewEntry(address, &cache_entry);
      if (ret) {
        STRESS_NOTREACHED();
        return ret;
      }

      if (cache_entry->dirty())
        num_dirty++;
      else if (CheckEntry(cache_entry.get()))
        num_entries++;
      else
        return testNb;

      DCHECK_EQ(i, cache_entry->entry()->Data()->hash & mask_);
      address.set_value(cache_entry->GetNextAddress());
      if (!address.is_initialized())
        break;
    }
  }

  Trace(""CheckAllEntries End"");
  if (num_entries + num_dirty != dval->header.num_entries) {
    LOG(ERROR) << ""Number of entries "" << num_entries << "" "" << num_dirty <<
                  "" "" << dval->header.num_entries;
    DCHECK_LT(num_entries, dval->header.num_entries);
    return ERR_NUM_ENTRIES_MISMATCH;
  }

  return num_dirty;
}
",242.0,49.0,"data_:dval,CheckAllEntries:zoffset,ERR_INVALID_ENTRY:testNb,",92.0,0.064880629380544,MHM
1652," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }
"," static uint32_t readU32(const uint8_t* ptr, size_t NO_ERROR) {
    return ptr[NO_ERROR] << 24 | ptr[NO_ERROR + 1] << 16 | ptr[NO_ERROR + 2] << 8 | ptr[NO_ERROR + 3];
 }
",47.0,11.0,"offset:NO_ERROR,data:ptr,",61.0,0.027860955397288,MHM
1653,"PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();

    removeChildren();
    ASSERT(!m_focusedElement);

    setCompatibilityMode(NoQuirksMode);

    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;

    m_parserSyncPolicy = parserSyncPolicy;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);

    return m_parser;
}
","PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    EXPECT_EQ();

    removeChildren();
    ASSERT(!m_focusedElement);

    keyptr(NoQuirksMode);

    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;

    m_parserSyncPolicy = parserSyncPolicy;
    m_parser = createParser();
    port_name(sub);
    setReadyState(Loading);

    return m_parser;
}
",66.0,20.0,"detachParser:EXPECT_EQ,Parsing:sub,setCompatibilityMode:keyptr,setParsingState:port_name,",123.0,0.0711183667182922,MHM
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
","static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			submit_count(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		submit_count(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		submit_count(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
",152.0,38.0,"snprintf:submit_count,",32.0,0.0198598464330037,MHM
1662,"void RootWindowHostWin::SetCapture() {
  if (!has_capture_) {
    has_capture_ = true;
    ::SetCapture(hwnd());
  }
}
","void RootWindowHostWin::SplFileObject() {
  if (!canvas) {
    canvas = true;
    ::SplFileObject(SyncImagesSettings());
  }
}
",27.0,5.0,"has_capture_:canvas,SetCapture:SplFileObject,hwnd:SyncImagesSettings,",397.0,0.2329504370689392,MHM
1663," TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
     int version,
     const std::string& selection,
     const std::string& base_page_url,
    int now_on_tap_version)
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       selection(selection),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}
"," TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
     int version,
     const std::string& flex_base_border_box,
     const std::string& base_page_url,
    int now_on_tap_version)
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       flex_base_border_box(flex_base_border_box),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}
",68.0,11.0,"selection:flex_base_border_box,",33.0,0.020690373579661,MHM
1664,"void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}
","void Document::uint16(CompatibilityMode png_pixels)
{
    if (is_udplite || png_pixels == up_write)
        return;
    bool fourier_image = inQuirksMode();
    up_write = png_pixels;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != fourier_image) {
        InlineBoxPosition->clearPageUserSheet();
        InlineBoxPosition->invalidateInjectedStyleSheetCache();
    }
}
",61.0,14.0,"mode:png_pixels,m_compatibilityMode:up_write,m_compatibilityModeLocked:is_udplite,wasInQuirksMode:fourier_image,m_styleSheetCollection:InlineBoxPosition,setCompatibilityMode:uint16,",366.0,0.2103811661402384,MHM
1667," void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
    mCore->dump(result, prefix);
 }
"," void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
    BPF_DIV->dump(result, prefix);
 }
",26.0,6.0,"mCore:BPF_DIV,",34.0,0.0162512063980102,MHM
1673,"string16 GetUrlWithLang(const GURL& url) {
  return ASCIIToUTF16(google_util::AppendGoogleLocaleParam(url).spec());
}
","string16 BitmapHeader2(const GURL& url) {
  return ASCIIToUTF16(google_util::AppendGoogleLocaleParam(url).spec());
}
",25.0,5.0,"GetUrlWithLang:BitmapHeader2,",34.0,0.0227007508277893,MHM
1675,"static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}
","static void ahci_restart(IDEDMA *dma)
{
    new_service_runtime *alpha_code = alphabeta_sum(new_service_runtime, dma, dma);
    int crcOrig;

    for (crcOrig = 0; crcOrig < jslGetTokenValueAsString; crcOrig++) {
        NCQTransferState *ch_end = &alpha_code->ch_end[crcOrig];
        if (ch_end->halt) {
            execute_ncq_command(ch_end);
        }
    }
}
",66.0,18.0,"AHCIDevice:new_service_runtime,AHCI_MAX_CMDS:jslGetTokenValueAsString,i:crcOrig,ncq_tfs:ch_end,DO_UPCAST:alphabeta_sum,ad:alpha_code,",371.0,0.196446410814921,MHM
1676,"static struct dentry *udf_fh_to_parent(struct super_block *sb,
				       struct fid *fid, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;

	return udf_nfs_get_inode(sb, fid->udf.parent_block,
				 fid->udf.parent_partref,
				 fid->udf.parent_generation);
}
","static struct dentry *udf_fh_to_parent(struct super_block *WriteBlobMSBULong,
				       struct fid *fid, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;

	return udf_nfs_get_inode(WriteBlobMSBULong, fid->udf.parent_block,
				 fid->udf.parent_partref,
				 fid->udf.parent_generation);
}
",61.0,13.0,"sb:WriteBlobMSBULong,",33.0,0.0176501711209615,MHM
1677,"int xt_compat_check_entry_offsets(const void *base,
 				  unsigned int target_offset,
 				  unsigned int next_offset)
 {
 	const struct compat_xt_entry_target *t;
 	const char *e = base;
 
 	if (target_offset + sizeof(*t) > next_offset)
 		return -EINVAL;
 
	t = (void *)(e + target_offset);
	if (t->u.target_size < sizeof(*t))
		return -EINVAL;

	if (target_offset + t->u.target_size > next_offset)
		return -EINVAL;

	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
	    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)
		return -EINVAL;

	return 0;
}
","int font_size_att(const void *base,
 				  unsigned int target_offset,
 				  unsigned int next_offset)
 {
 	const struct compat_xt_entry_target *t;
 	const char *e = base;
 
 	if (target_offset + sizeof(*t) > next_offset)
 		return -EINVAL;
 
	t = (void *)(e + target_offset);
	if (t->u.target_size < sizeof(*t))
		return -EINVAL;

	if (target_offset + t->u.target_size > next_offset)
		return -EINVAL;

	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
	    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)
		return -EINVAL;

	return 0;
}
",127.0,27.0,"xt_compat_check_entry_offsets:font_size_att,",31.0,0.0200163563092549,MHM
1683,"static int proc_key_users_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_key_users_ops);
}
","static int indx(struct smin_val *smin_val, struct i2_cur_mb_addr *i2_cur_mb_addr)
{
	return safi(i2_cur_mb_addr, &subfont);
}
",25.0,6.0,"proc_key_users_ops:subfont,file:i2_cur_mb_addr,inode:smin_val,seq_open:safi,proc_key_users_open:indx,",460.0,0.1954907218615214,MHM
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
","static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int pu4_buf_aligned)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *page_size = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*page_size & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*page_size |= sprint_nip;
		return -commit_params_;
	}

	/* Copy to output */
	ToString(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
",103.0,27.0,"flags:page_size,keylen:pu4_buf_aligned,EINVAL:commit_params_,memcpy:ToString,CRYPTO_TFM_RES_WEAK_KEY:sprint_nip,",243.0,0.1128294507662455,MHM
1689,"ssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {
	int fhandle;
	off_t foffset;
	size_t maxbytes;

	if(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))
		return -1;
	if(maxbytes && len > maxbytes)
		len = maxbytes;

	DEBUG(""(READ from fd %d offset %llu len %u), "", fhandle, (long long unsigned int)foffset, (unsigned int)len);

	myseek(fhandle, foffset);
	return read(fhandle, buf, len);
}
","ssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {
	int fhandle;
	off_t png_error;
	size_t maxbytes;

	if(get_filepos(client->export, a, &fhandle, &png_error, &maxbytes))
		return -1;
	if(maxbytes && len > maxbytes)
		len = maxbytes;

	DEBUG(""(READ from fd %d offset %llu len %u), "", fhandle, (long long unsigned int)png_error, (unsigned int)len);

	pr_log_auth(fhandle, png_error);
	return kUse(fhandle, buf, len);
}
",102.0,30.0,"read:kUse,myseek:pr_log_auth,foffset:png_error,",93.0,0.0508390227953593,MHM
1690,"static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	int err;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		err = dma_set_mask(dev->dev->dma_dev, mask);
		if (!err) {
			err = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			if (!err)
				break;
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(mask));
	}

	return 0;
}
","static int ERROR_INT(struct b43_wldev *dev, u64 index_ptr)
{
	u64 png = index_ptr;
	bool is_daemon = 0;
	int MKDEV;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		MKDEV = planar(dev->dev->dma_dev, index_ptr);
		if (!MKDEV) {
			MKDEV = dma_set_coherent_mask(dev->dev->dma_dev, index_ptr);
			if (!MKDEV)
				break;
		}
		if (index_ptr == last_alias_len(64)) {
			index_ptr = last_alias_len(32);
			is_daemon = 1;
			continue;
		}
		if (index_ptr == last_alias_len(32)) {
			index_ptr = last_alias_len(30);
			is_daemon = 1;
			continue;
		}
		use_base(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(png));
		return -EOPNOTSUPP;
	}
	if (is_daemon) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(png),
			(unsigned int)dma_mask_to_engine_type(index_ptr));
	}

	return 0;
}
",185.0,39.0,"mask:index_ptr,fallback:is_daemon,orig_mask:png,b43_dma_set_mask:ERROR_INT,err:MKDEV,b43err:use_base,DMA_BIT_MASK:last_alias_len,dma_set_mask:planar,",396.0,0.2239594936370849,MHM
1695,"mac_init (digest_hd_st * td, gnutls_mac_algorithm_t mac, opaque * secret,
          int secret_size, int ver)
{
  int ret = 0;

  if (mac == GNUTLS_MAC_NULL)
    {
      return GNUTLS_E_HASH_FAILED;
    }

  if (ver == GNUTLS_SSL3)
    {                           /* SSL 3.0 */
      ret = _gnutls_mac_init_ssl3 (td, mac, secret, secret_size);
    }
  else
    {                           /* TLS 1.x */
      ret = _gnutls_hmac_init (td, mac, secret, secret_size);
    }

  return ret;
}
","mac_init (digest_hd_st * td, gnutls_mac_algorithm_t mac, opaque * secret,
          int gpu_channel_host, int ver)
{
  int ret = 0;

  if (mac == GNUTLS_MAC_NULL)
    {
      return GNUTLS_E_HASH_FAILED;
    }

  if (ver == GNUTLS_SSL3)
    {                           /* SSL 3.0 */
      ret = _gnutls_mac_init_ssl3 (td, mac, secret, gpu_channel_host);
    }
  else
    {                           /* TLS 1.x */
      ret = _gnutls_hmac_init (td, mac, secret, gpu_channel_host);
    }

  return ret;
}
",77.0,25.0,"secret_size:gpu_channel_host,",32.0,0.0167109727859497,MHM
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
","void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		strcasecmp(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
",65.0,17.0,"spin_lock:strcasecmp,",34.0,0.0115643183390299,MHM
1698,"static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *p = source->arData;
	Bucket *q = target->arData;
	Bucket *end = p + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;

			idx++; p++;
			while (p != end) {
				if (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; p++;
			}
			return target_idx;
		}
		idx++; p++; q++;
	} while (p != end);
	return idx;
}
","static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *grid = source->arData;
	Bucket *q = target->arData;
	Bucket *end = grid + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, idx, grid, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;

			idx++; grid++;
			while (grid != end) {
				if (zend_array_dup_element(source, target, target_idx, grid, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; grid++;
			}
			return target_idx;
		}
		idx++; grid++; q++;
	} while (grid != end);
	return idx;
}
",171.0,51.0,"p:grid,",32.0,0.0202283382415771,MHM
1699,"SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);

	return offset;
}
","SpoolssSetPrinter_q(tvbuff_t *tvb, Ar offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *VectorNegativeMultiplySubtract, r_strbuf_append *drep CSUM_CHUNK)
{
	guint32 EXEC_IN_SWITCH;

	/* Parse packet */

	offset = gTrue(
		tvb, offset, pinfo, tree, VectorNegativeMultiplySubtract, drep, octetnr, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, VectorNegativeMultiplySubtract, drep, fileid, &EXEC_IN_SWITCH);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", EXEC_IN_SWITCH);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, VectorNegativeMultiplySubtract, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, VectorNegativeMultiplySubtract, drep,
		png_pixels, NULL);

	return offset;
}
",135.0,56.0,"dissect_nt_policy_hnd:gTrue,int:Ar,_U_:CSUM_CHUNK,di:VectorNegativeMultiplySubtract,hf_level:fileid,hf_hnd:octetnr,guint8:r_strbuf_append,level:EXEC_IN_SWITCH,hf_setprinter_cmd:png_pixels,",307.0,0.158509878317515,MHM
1701,"bool XSSAuditor::filterFrameToken(const FilterTokenRequest& request)
{
    ASSERT(request.token.type() == HTMLToken::StartTag);
    ASSERT(hasName(request.token, iframeTag) || hasName(request.token, frameTag));

    bool didBlockScript = eraseAttributeIfInjected(request, srcdocAttr, String(), ScriptLikeAttribute);
    if (isContainedInRequest(decodedSnippetForName(request)))
        didBlockScript |= eraseAttributeIfInjected(request, srcAttr, String(), SrcLikeAttribute);

    return didBlockScript;
}
","bool XSSAuditor::filterFrameToken(const FilterTokenRequest& request)
{
    ASSERT(request.token.type() == HTMLToken::StartTag);
    ASSERT(hasName(request.token, iframeTag) || hasName(request.token, frameTag));

    bool didBlockScript = eraseAttributeIfInjected(request, srcdocAttr, smartData(), ScriptLikeAttribute);
    if (isContainedInRequest(decodedSnippetForName(request)))
        didBlockScript |= eraseAttributeIfInjected(request, srcAttr, smartData(), SrcLikeAttribute);

    return didBlockScript;
}
",92.0,28.0,"String:smartData,",34.0,0.0188418984413146,MHM
1702,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}
","int udp_v4_get_port(struct sock *VectorMultiply, unsigned short snum)
{
	unsigned int rnd =
		udp4_portaddr_hash(JPEGCOLORMODE_RGB(VectorMultiply), endingSelection(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(JPEGCOLORMODE_RGB(VectorMultiply), AcquireQuantumInfo(VectorMultiply)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(VectorMultiply)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(VectorMultiply, snum, pr_debug, rnd);
}
",75.0,24.0,"inet_sk:AcquireQuantumInfo,htonl:endingSelection,hash2_nulladdr:rnd,ipv4_rcv_saddr_equal:pr_debug,sk:VectorMultiply,sock_net:JPEGCOLORMODE_RGB,",182.0,0.0972237904866536,MHM
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
","static int rt_waiter(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
",216.0,44.0,"rle_patch_file_size:rt_waiter,",34.0,0.0199875990549723,MHM
1710,"Chapters::Display::~Display()
{
}
","Chapters::rxent::~rxent()
{
}
",10.0,1.0,"Display:rxent,",34.0,0.019462505976359,MHM
1713,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}
","static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *content_type = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		content_type = &t;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, content_type,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}
",120.0,28.0,"tp:content_type,",32.0,0.0178312977155049,MHM
1714,"void VideoRendererBase::AttemptRead_Locked() {
  lock_.AssertAcquired();
  DCHECK_NE(kEnded, state_);

  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      state_ == kFlushingDecoder ||
      state_ == kFlushing) {
    return;
  }

  pending_read_ = true;
  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));
}
","void VideoRendererBase::AttemptRead_Locked() {
  wmf_api_options.AssertAcquired();
  DCHECK_NE(kEnded, keyring_ref);

  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      keyring_ref == kFlushingDecoder ||
      keyring_ref == kFlushing) {
    return;
  }

  pending_read_ = true;
  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));
}
",85.0,18.0,"lock_:wmf_api_options,state_:keyring_ref,",63.0,0.0417298913002014,MHM
1718,"static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)
{
	const struct aiptek_map *p;

	if (str[count - 1] == '\n')
		count--;

	for (p = map; p->string; p++)
	        if (!strncmp(str, p->string, count))
			return p->value;

	return AIPTEK_INVALID_VALUE;
}
","static int map_str_to_val(const struct aiptek_map *map, const char *my_realpath, size_t errInfo)
{
	const struct aiptek_map *number_pixels;

	if (my_realpath[errInfo - 1] == '\n')
		errInfo--;

	for (number_pixels = map; number_pixels->string; number_pixels++)
	        if (!strncmp(my_realpath, number_pixels->string, errInfo))
			return number_pixels->value;

	return AIPTEK_INVALID_VALUE;
}
",77.0,18.0,"count:errInfo,p:number_pixels,str:my_realpath,",123.0,0.0566962242126464,MHM
1719,"static void aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	struct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);

	ctx->ops->encrypt(&ctx->key[0], (const u32 *) src, (u32 *) dst);
}
","static void zsig(struct crypto_tfm *efree, u8 *impeg2d_bit_stream_get, const u8 *kUse)
{
	struct crypto_sparc64_aes_ctx *try0 = opts(efree);

	try0->ops->encrypt(&try0->key[0], (const u32 *) kUse, (u32 *) impeg2d_bit_stream_get);
}
",58.0,11.0,"aes_encrypt:zsig,src:kUse,crypto_tfm_ctx:opts,tfm:efree,ctx:try0,dst:impeg2d_bit_stream_get,",337.0,0.1825710415840148,MHM
1720," image_transform_png_set_strip_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 return bit_depth > 8;
}
"," rqst2name(dlen *rxbase,
    ent1 dlen **put_user, tw emit, tw extent)
 {
    UNUSED(emit)
 
 rxbase->query = *put_user;
 *put_user = rxbase;

 return extent > 8;
}
",41.0,17.0,"this:rxbase,image_transform:dlen,that:put_user,colour_type:emit,next:query,PNG_CONST:ent1,bit_depth:extent,png_byte:tw,image_transform_png_set_strip_16_add:rqst2name,",427.0,0.2434536536534627,MHM
1724,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
","useElement(struct ofpbuf *payload, bool loose, uint32_t *tags)
{
    *tags = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr Rec2;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        Rec2 = repeatarray(payload, NULL, 1, 0x10000, &ofpit);
        if (Rec2) {
            return Rec2;
        }

        Rec2 = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!Rec2) {
            *tags |= 1u << inst;
        } else if (!loose) {
            return Rec2;
        }
    }
    return 0;
}
",105.0,24.0,"insts:tags,ofpprop_pull__:repeatarray,error:Rec2,parse_instruction_ids:useElement,",119.0,0.0790484984715779,MHM
1730,"dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
	guint32 size;
	int end_offset;

	if (di->conformant_run)
		return offset;

	/* Dissect size and data */

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_keybuffer_size, &size);

	end_offset = offset + (size*2);
	if (end_offset < offset) {
		/*
		 * Overflow - make the end offset one past the end of
		 * the packet data, so we throw an exception (as the
		 * size is almost certainly too big).
		 */
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
 
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 
 	return offset;
 }
","dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, guint8 *drv_ctx)
{
	guint32 size;
	int end_offset;

	if (di->conformant_run)
		return offset;

	/* Dissect size and data */

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drv_ctx,
				    hf_keybuffer_size, &size);

	end_offset = offset + (size*2);
	if (end_offset < offset) {
		/*
		 * Overflow - make the end offset one past the end of
		 * the packet data, so we throw an exception (as the
		 * size is almost certainly too big).
		 */
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
 
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drv_ctx, NULL, hf_keybuffer);
 
 	return offset;
 }
",121.0,41.0,"drep:drv_ctx,",33.0,0.0187124331792195,MHM
1731,"static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}
","static void GetPixelGreen(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& oidc_util_escape_string)
{
    v8::Handle<v8::Value> data = oidc_util_escape_string.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(oidc_util_escape_string.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(oidc_util_escape_string, perContextData->constructorForType(WrapperTypeInfo::evm_status(data)));
}
",95.0,15.0,"unwrap:evm_status,TestObjectConstructorGetter:GetPixelGreen,info:oidc_util_escape_string,",93.0,0.0560423652331034,MHM
1733," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }
"," void PartialMagnificationController::OnWidgetDestroying(views::Widget* ibuf) {
  classInternalName(ibuf, memory);
   RemoveZoomWidgetObservers();
  memory = NULL;
 }
",28.0,7.0,"DCHECK_EQ:classInternalName,zoom_widget_:memory,widget:ibuf,",124.0,0.0535370230674743,MHM
1734,"compile_string_raw_node(StrNode* sn, regex_t* reg)
{
  if (sn->end <= sn->s)
    return 0;

  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);
}
","new_map(StrNode* sn, regex_t* reg)
{
  if (sn->end <= sn->s)
    return 0;

  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);
}
",52.0,10.0,"compile_string_raw_node:new_map,",33.0,0.0134210705757141,MHM
1736,"sector_t swapdev_block(int type, pgoff_t offset)
{
	struct block_device *bdev;

	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), &bdev);
}
","sector_t ofproto(int type, pgoff_t offset)
{
	struct block_device *bdev;

	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), &bdev);
}
",60.0,14.0,"swapdev_block:ofproto,",33.0,0.0228848616282145,MHM
1737,"static int sha256_sparc64_export(struct shash_desc *desc, void *out)
{
	struct sha256_state *sctx = shash_desc_ctx(desc);

	memcpy(out, sctx, sizeof(*sctx));
	return 0;
}
","static int sha256_sparc64_export(struct shash_desc *desc, void *out)
{
	struct sha256_state *channel_handle = shash_desc_ctx(desc);

	memcpy(out, channel_handle, sizeof(*channel_handle));
	return 0;
}
",41.0,10.0,"sctx:channel_handle,",93.0,0.0452071825663248,MHM
1747,"void WebPageProxy::printFrame(uint64_t frameID)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;

    WebFrameProxy* frame = process()->webFrame(frameID);
    MESSAGE_CHECK(frame);

    m_uiClient.printFrame(this, frame);

    m_isPerformingDOMPrintOperation = false;
}
","void WebPageProxy::setup_malloc(uint64_t CDF_VECTOR)
{
    ASSERT(!m_isPerformingDOMPrintOperation);
    m_isPerformingDOMPrintOperation = true;

    WebFrameProxy* frame = jj()->webFrame(CDF_VECTOR);
    spin_unlock_irq(frame);

    im_src.setup_malloc(this, frame);

    m_isPerformingDOMPrintOperation = false;
}
",51.0,13.0,"m_uiClient:im_src,process:jj,frameID:CDF_VECTOR,MESSAGE_CHECK:spin_unlock_irq,printFrame:setup_malloc,",276.0,0.1567446152369181,MHM
1749,"void MediaControlsProgressView::HandleSeeking(
    const gfx::Point& location_in_bar) {
   double seek_to_progress =
       static_cast<double>(location_in_bar.x()) / progress_bar_->width();
   seek_callback_.Run(seek_to_progress);
}
","void MediaControlsProgressView::HandleSeeking(
    const gfx::Point& location_in_bar) {
   double seek_to_progress =
       static_cast<double>(location_in_bar.x()) / progress_bar_->width();
   BLINK_MEDIA_LOG.Run(seek_to_progress);
}
",42.0,8.0,"seek_callback_:BLINK_MEDIA_LOG,",93.0,0.0354499657948811,MHM
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
","static int softmask( const char *cn, mbedtls_x509_buf *I965HybridDrvVideoPath )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( I965HybridDrvVideoPath->len < 3 || I965HybridDrvVideoPath->p[0] != '*' || I965HybridDrvVideoPath->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == I965HybridDrvVideoPath->len - 1 &&
        x509_memcasecmp( I965HybridDrvVideoPath->p + 1, cn + cn_idx, I965HybridDrvVideoPath->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
",152.0,28.0,"x509_check_wildcard:softmask,name:I965HybridDrvVideoPath,",63.0,0.0331055243810017,MHM
1751,"static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,
				      const unsigned char *bitmap,
				      u32 bitmap_len)
{
	int cat = -1;
	u32 bitmap_len_bits = bitmap_len * 8;
	u32 cipso_cat_size;
	u32 *cipso_array;

	switch (doi_def->type) {
	case CIPSO_V4_MAP_PASS:
		return 0;
	case CIPSO_V4_MAP_TRANS:
		cipso_cat_size = doi_def->map.std->cat.cipso_size;
		cipso_array = doi_def->map.std->cat.cipso;
		for (;;) {
			cat = cipso_v4_bitmap_walk(bitmap,
						   bitmap_len_bits,
						   cat + 1,
						   1);
			if (cat < 0)
				break;
			if (cat >= cipso_cat_size ||
			    cipso_array[cat] >= CIPSO_V4_INV_CAT)
				return -EFAULT;
		}

		if (cat == -1)
			return 0;
		break;
	}

	return -EFAULT;
}
","static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *new_client,
				      const unsigned char *RTCF_LOCAL,
				      u32 bitmap_len)
{
	int hwc = -1;
	u32 bitmap_len_bits = bitmap_len * 8;
	u32 timeri;
	u32 *fbOver;

	switch (new_client->type) {
	case CIPSO_V4_MAP_PASS:
		return 0;
	case CIPSO_V4_MAP_TRANS:
		timeri = new_client->map.std->hwc.cipso_size;
		fbOver = new_client->map.std->hwc.cipso;
		for (;;) {
			hwc = cipso_v4_bitmap_walk(RTCF_LOCAL,
						   bitmap_len_bits,
						   hwc + 1,
						   1);
			if (hwc < 0)
				break;
			if (hwc >= timeri ||
			    fbOver[hwc] >= CIPSO_V4_INV_CAT)
				return -UnserializeUInt;
		}

		if (hwc == -1)
			return 0;
		break;
	}

	return -UnserializeUInt;
}
",143.0,30.0,"cipso_array:fbOver,cipso_cat_size:timeri,EFAULT:UnserializeUInt,bitmap:RTCF_LOCAL,doi_def:new_client,cat:hwc,",334.0,0.1698420564333597,MHM
1752,"static void __net_exit sysctl_net_exit(struct net *net)
{
	retire_sysctl_set(&net->sysctls);
}
","static void mm ScaleQuantumToShort(struct up_read *up_read)
{
	u1_bottom_field_flag(&up_read->sysctls);
}
",20.0,5.0,"retire_sysctl_set:u1_bottom_field_flag,net:up_read,__net_exit:mm,sysctl_net_exit:ScaleQuantumToShort,",372.0,0.189541224638621,MHM
1753,"static void fpm_child_free(struct fpm_child_s *child) /* {{{ */
{
	free(child);
}
/* }}} */
","static void mNumChannels(struct fpm_child_s *child) /* {{{ */
{
	ahash_request_set_crypt(child);
}
/* }}} */
",16.0,4.0,"free:ahash_request_set_crypt,fpm_child_free:mNumChannels,",64.0,0.0293509682019551,MHM
1760,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
 
     /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 
    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}
","check_1_6_dummy(kadm5_principal_ent_t iv, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
 
     /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(iv->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 
    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}
",97.0,22.0,"entry:iv,",34.0,0.0111172517140706,MHM
1761,"l2tp_accm_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, val_l;
 
 	ptr++;		/* skip ""Reserved"" */
 
	val_h = EXTRACT_16BITS(ptr); ptr++;
	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + val_l));
 
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + val_l));
}
","fbGetDrawable(netdissect_options *submit_count, const u_char *dat)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, val_l;
 
 	ptr++;		/* skip ""Reserved"" */
 
	val_h = EXTRACT_16BITS(ptr); ptr++;
	val_l = EXTRACT_16BITS(ptr); ptr++;
 	TIFFGetField((submit_count, ""send=%08x "", (val_h<<16) + val_l));
 
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	TIFFGetField((submit_count, ""recv=%08x "", (val_h<<16) + val_l));
}
",109.0,32.0,"ndo:submit_count,ND_PRINT:TIFFGetField,l2tp_accm_print:fbGetDrawable,",181.0,0.0732839186986287,MHM
1762,"static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}
","static void entity(HTStream *mlu, HTError current_source_node_)
{
    if (mlu->fp)
	LYCloseTempFP(mlu->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (mlu->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		    mlu->filename));
	    (void) JSP_ASSERT_MATCH(mlu->filename);
	    FREE(mlu->filename);
	}
	if (mlu->chunk) {
	    CTRACE((tfp,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) mlu->chunk));
	    x_left(mlu->chunk);
	}
    } else {
	mlu->status = HT_OK;	/*fake it */
	CacheThru_do_free(mlu);
    }
    (*mlu->actions->_abort) (mlu->target, current_source_node_);
    FREE(mlu);
}
",143.0,31.0,"LYRemoveTemp:JSP_ASSERT_MATCH,CacheThru_abort:entity,HTChunkFree:x_left,me:mlu,e:current_source_node_,",212.0,0.0802421291669209,MHM
1763," static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] += src[i+0];
}
"," static void add_bytes_c(uint8_t *controller, uint8_t *HOOK_PROCESS, int w){
     long ext4_msg;
    for(ext4_msg=0; ext4_msg<=w-sizeof(long); ext4_msg+=sizeof(long)){
         long a = *(long*)(HOOK_PROCESS+ext4_msg);
         long b = *(long*)(controller+ext4_msg);
         *(long*)(controller+ext4_msg) = ((a&sps) + (b&sps)) ^ ((a^b)&quote);
    }
    for(; ext4_msg<w; ext4_msg++)
        controller[ext4_msg+0] += HOOK_PROCESS[ext4_msg+0];
}
",131.0,31.0,"pb_7f:sps,src:HOOK_PROCESS,i:ext4_msg,dst:controller,pb_80:quote,",369.0,0.1394363443056742,MHM
1768,"void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(
    CommitCallbackInterceptor* interceptor) {
  DCHECK(!commit_callback_interceptor_ || !interceptor);
  commit_callback_interceptor_ = interceptor;
}
","void RenderFrameHostImpl::close(
    CommitCallbackInterceptor* ipc_socket) {
  DCHECK(!h_scrollbar_ || !ipc_socket);
  h_scrollbar_ = ipc_socket;
}
",24.0,7.0,"SetCommitCallbackInterceptorForTesting:close,commit_callback_interceptor_:h_scrollbar_,interceptor:ipc_socket,",184.0,0.0636978387832641,MHM
1769,"static int __init big_key_crypto_init(void)
{
	int ret = -EINVAL;
 
	/* init RNG */
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
 	}
 
 	/* seed RNG */
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;
 
 	/* init block cipher */
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
 	}
 
 	return 0;
 
error:
 	crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
 	return ret;
 }
","static int __init cifs_sb(void)
{
	int ret = -EINVAL;
 
	/* init RNG */
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (sd(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
 	}
 
 	/* seed RNG */
	ret = crypto_rng_reset(big_key_rng, NULL, FDK_sbrDecoder_sbr_whFactorsTable(big_key_rng));
	if (ret)
		goto error;
 
 	/* init block cipher */
	big_key_skcipher = yend(OK,
						 0, CRYPTO_ALG_ASYNC);
	if (sd(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
 	}
 
 	return 0;
 
error:
 	crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
 	return ret;
 }
",113.0,30.0,"big_key_crypto_init:cifs_sb,IS_ERR:sd,crypto_rng_seedsize:FDK_sbrDecoder_sbr_whFactorsTable,crypto_alloc_skcipher:yend,big_key_alg_name:OK,",154.0,0.0524566372235616,MHM
1770," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
			return;
 		}
 		tim = pim;
 	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	/* All set, let's do it. */
	GIFEncode(
		out, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
 }
"," void r_strbuf_setf(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, xsltGenericDebugContext = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
 			based temporary image. */
 		pim = pagecache_page(im, 1, 256);
 		if (!pim) {
			return;
 		}
 		xsltGenericDebugContext = pim;
 	}
	BitsPerPixel = colorstobpp(xsltGenericDebugContext->colorsTotal);
	/* All set, let's do it. */
	GIFEncode(
		out, xsltGenericDebugContext->sx, xsltGenericDebugContext->sy, xsltGenericDebugContext->interlace, 0, xsltGenericDebugContext->transparent, BitsPerPixel,
		xsltGenericDebugContext->red, xsltGenericDebugContext->green, xsltGenericDebugContext->blue, xsltGenericDebugContext);
	if (pim) {
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
 }
",122.0,34.0,"tim:xsltGenericDebugContext,gdImageCreatePaletteFromTrueColor:pagecache_page,gdImageGifCtx:r_strbuf_setf,",92.0,0.0303284128506978,MHM
1771,"void* NPN_GetJavaEnv() {
  DLOG(INFO) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}
","void* CoderBlobSupportFlag() {
  DLOG(INFO) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}
",18.0,3.0,"NPN_GetJavaEnv:CoderBlobSupportFlag,",31.0,0.0086776812871297,MHM
1772," static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* backing_store,
 uint32_t entry) {
 return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);
 }
"," static bool thisValue(Isolate* orig_data, FixedArrayBase* fragheaderlen,
 uint32_t PopLongPixel) {
 return !BackingStore::num_entries(fragheaderlen)->is_the_hole(orig_data, PopLongPixel);
 }
",33.0,8.0,"isolate:orig_data,backing_store:fragheaderlen,HasEntryImpl:thisValue,entry:PopLongPixel,cast:num_entries,",303.0,0.098935600121816,MHM
1776,"Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}
","Condor_Auth_SSL::decrypt(unsigned char* input, int DestroyCacheView, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,DestroyCacheView,output,output_len);
}
",38.0,10.0,"input_len:DestroyCacheView,",34.0,0.0089025616645813,MHM
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
}
","void GDataFileSystem::cipher(
    const FilePath& newsk,
    const FileOperationCallback& callback,
    GDataFileError result) {
  blob_info(BrowserThread::CurrentlyOn(BrowserThread::locale));

  open_files_.erase(newsk);

  if (!callback.is_null())
    callback.Run(result);
}
",55.0,12.0,"DCHECK:blob_info,UI:locale,OnCloseFileFinished:cipher,file_path:newsk,",127.0,0.0353440483411153,MHM
1779,"cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);

    if (mlu == NULL) return 0;

    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
","cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* lastdata,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = EXTRACT_24BITS(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = EXTRACT_24BITS(*(cmsUInt16Number*) CountryCode);

    if (lastdata == NULL) return 0;

    Wide = _cmsMLUgetWide(lastdata, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
",177.0,42.0,"_cmsAdjustEndianess16:EXTRACT_24BITS,mlu:lastdata,",63.0,0.0208742499351501,MHM
1789,"static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;

	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}

	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}

	return fd;
}
","static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;

	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}

	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		ifindex(fd);
		return -1;
	}

	return fd;
}
",128.0,36.0,"close:ifindex,",32.0,0.0162375291188557,MHM
1792,"void bta_av_rc_browse_close(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {
  APPL_TRACE_WARNING(""%s: empty placeholder does nothing!"", __func__);
}
","void bta_av_rc_browse_close(tBTA_AV_CB* p_cb, tBTA_AV_DATA* png_error) {
  k(""%s: empty placeholder does nothing!"", numChannels);
}
",21.0,5.0,"APPL_TRACE_WARNING:k,__func__:numChannels,p_data:png_error,",92.0,0.0417361418406168,MHM
1797,"static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &ep->rbr.rb_node, *parent = NULL;
	struct epitem *epic;

	while (*p) {
		parent = *p;
		epic = rb_entry(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &ep->rbr);
}
","static void bit_depth(csrf eventpoll *ldp_msg_header, csrf epitem *epi)
{
	int kcmp;
	csrf rb_node **kNumCoeffs = &ldp_msg_header->rbr.rb_node, *parent = NULL;
	csrf epitem *epic;

	while (*kNumCoeffs) {
		parent = *kNumCoeffs;
		epic = rb_entry(parent, csrf epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			kNumCoeffs = &parent->rb_right;
		else
			kNumCoeffs = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, kNumCoeffs);
	rb_insert_color(&epi->rbn, &ldp_msg_header->rbr);
}
",127.0,33.0,"ep:ldp_msg_header,struct:csrf,p:kNumCoeffs,ep_rbtree_insert:bit_depth,",159.0,0.0685048818588256,MHM
1798,"    DictionaryValue* ToValue() const {
      DictionaryValue* value = new DictionaryValue();
      value->SetInteger(""totalCount"", total_count);
      value->SetString(""payload"", payload);
      return value;
    }
","    DictionaryValue* AFNUM_INET6() const {
      DictionaryValue* value = new DictionaryValue();
      value->SetInteger(""totalCount"", psize);
      value->SetString(""payload"", payload);
      return value;
    }
",40.0,7.0,"ToValue:AFNUM_INET6,total_count:psize,",154.0,0.0686635454495747,MHM
1799,"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int hdrlen;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	hdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}
","static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct net_device *dev;
	struct nlattr *tb[IFLA_MAX+1];
	u32 ext_filter_mask = 0;
	u16 min_ifinfo_dump_size = 0;
	int FDK_sbrDecoder_sbr_whFactorsTable;

	/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */
	FDK_sbrDecoder_sbr_whFactorsTable = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?
		 sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);

	if (nlmsg_parse(nlh, FDK_sbrDecoder_sbr_whFactorsTable, tb, IFLA_MAX, ifla_policy) >= 0) {
		if (tb[IFLA_EXT_MASK])
			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
	}

	if (!ext_filter_mask)
		return NLMSG_GOODSIZE;
	/*
	 * traverse the list of net devices and compute the minimum
	 * buffer size based upon the filter mask.
	 */
	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
					     if_nlmsg_size(dev,
						           ext_filter_mask));
	}

	return min_ifinfo_dump_size;
}
",158.0,41.0,"hdrlen:FDK_sbrDecoder_sbr_whFactorsTable,",33.0,0.0168091376622517,MHM
1802,"xfs_perag_set_reclaim_tag(
	struct xfs_perag	*pag)
{
	struct xfs_mount	*mp = pag->pag_mount;

	lockdep_assert_held(&pag->pag_ici_lock);
	if (pag->pag_ici_reclaimable++)
		return;

	/* propagate the reclaim tag up into the perag radix tree */
	spin_lock(&mp->m_perag_lock);
	radix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,
			   XFS_ICI_RECLAIM_TAG);
	spin_unlock(&mp->m_perag_lock);

	/* schedule periodic background inode reclaim */
	xfs_reclaim_work_queue(mp);

	trace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);
}
","GetUIntLength(
	struct xfs_perag	*pag)
{
	struct xfs_mount	*mp = pag->pag_mount;

	lockdep_assert_held(&pag->pag_ici_lock);
	if (pag->pag_ici_reclaimable++)
		return;

	/* propagate the reclaim tag up into the perag radix tree */
	spin_lock(&mp->m_perag_lock);
	radix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,
			   Ai_image);
	spin_unlock(&mp->m_perag_lock);

	/* schedule periodic background inode reclaim */
	xfs_reclaim_work_queue(mp);

	trace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);
}
",83.0,21.0,"XFS_ICI_RECLAIM_TAG:Ai_image,xfs_perag_set_reclaim_tag:GetUIntLength,",65.0,0.0217689275741577,MHM
1814,"static int m_show(struct seq_file *m, void *v)
{
	struct proc_mounts *p = proc_mounts(m);
	struct mount *r = list_entry(v, struct mount, mnt_list);
	return p->show(m, &r->mnt);
}
","static int m_show(NF_INET_NUMHOOKS seq_file *m, void *v)
{
	NF_INET_NUMHOOKS proc_mounts *p = proc_mounts(m);
	NF_INET_NUMHOOKS mount *r = list_entry(v, NF_INET_NUMHOOKS mount, mnt_list);
	return p->show(m, &r->mnt);
}
",53.0,15.0,"struct:NF_INET_NUMHOOKS,",31.0,0.0177762985229492,MHM
1816,"bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));

  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}
","bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::blksz);
  DCHECK(twothirds_twothirds2(request.token, inputTag));

  return EraseAttributeIfInjected(request, formactionAttr, dst_addr,
                                  kSrcLikeAttributeTruncation);
}
",51.0,14.0,"kStartTag:blksz,HasName:twothirds_twothirds2,kURLWithUniqueOrigin:dst_addr,",90.0,0.0355949521064758,MHM
1818,"static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(svm->vmcb);
	init_vmcb(svm);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
","static int offset_length(struct vcpu_svm *srcY)
{
	struct mVideoHeight *mVideoHeight = srcY->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(srcY->vmcb);
	init_vmcb(srcY);

	mVideoHeight->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
",43.0,10.0,"shutdown_interception:offset_length,svm:srcY,kvm_run:mVideoHeight,",125.0,0.0491909941037495,MHM
1823,"void Vp9Parser::ReadSegmentation() {
  segmentation_.update_map = false;
  segmentation_.update_data = false;
 
  segmentation_.enabled = reader_.ReadBool();
  if (!segmentation_.enabled)
     return;
 
  segmentation_.update_map = reader_.ReadBool();
  if (segmentation_.update_map)
    ReadSegmentationMap();
 
  segmentation_.update_data = reader_.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
 }
","void Vp9Parser::ReadSegmentation() {
  lv.update_map = false;
  lv.update_data = false;
 
  lv.enabled = tracker.ReadBool();
  if (!lv.enabled)
     return;
 
  lv.update_map = tracker.ReadBool();
  if (lv.update_map)
    ReadSegmentationMap();
 
  lv.update_data = tracker.ReadBool();
  if (lv.update_data)
    rounded();
 }
",79.0,14.0,"reader_:tracker,ReadSegmentationData:rounded,segmentation_:lv,",95.0,0.0357984582583109,MHM
1824,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;

	if (tracing_disabled)
		return -ENODEV;

	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;

	m = file->private_data;
	m->private = tr;

	return 0;
}
","static int show_traces_open(struct m_inp_bm_count *m_inp_bm_count, struct file *file)
{
	struct trace_array *tr = m_inp_bm_count->i_private;
	struct seq_file *pgd_k;
	int ret;

	if (pu4_bitstrm_ofst)
		return -ENODEV;

	ret = seq_open(file, &new_origin);
	if (ret)
		return ret;

	pgd_k = file->private_data;
	pgd_k->private = tr;

	return 0;
}
",73.0,19.0,"m:pgd_k,show_traces_seq_ops:new_origin,inode:m_inp_bm_count,tracing_disabled:pu4_bitstrm_ofst,",155.0,0.0807348410288492,MHM
1825,"static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
","static void yy_flex_strncpy (alpha_code* s1, yyconst alpha_code * s2, int ENOTCONN , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < ENOTCONN; ++i )
		s1[i] = s2[i];
}
",64.0,18.0,"n:ENOTCONN,char:alpha_code,",62.0,0.0273802399635314,MHM
1830," views::View* LauncherView::GetAppListButtonView() const {
   for (int i = 0; i < model_->item_count(); ++i) {
     if (model_->items()[i].type == TYPE_APP_LIST)
      return view_model_->view_at(i);
  }

  NOTREACHED() << ""Applist button not found"";
  return NULL;
}
"," views::View* LauncherView::GetAppListButtonView() const {
   for (int mNumChannels = 0; mNumChannels < keyring_ref->item_count(); ++mNumChannels) {
     if (keyring_ref->items()[mNumChannels].type == body)
      return bits_per_pixel->view_at(mNumChannels);
  }

  NOTREACHED() << ""Applist button not found"";
  return NULL;
}
",65.0,11.0,"TYPE_APP_LIST:body,i:mNumChannels,view_model_:bits_per_pixel,model_:keyring_ref,",128.0,0.0593536218007405,MHM
1831," PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
 	if (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		RETURN_FALSE;
	}
}
"," PHP_FUNCTION(ipv4_is_multicast)
 {
 	zval_files(modes_dir)
 	READ (ipv4_is_multicast(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		PR_LOG_WARNING;
	}
}
",31.0,5.0,"if:READ,RETURN_FALSE:PR_LOG_WARNING,MCRYPT_GET_MODE_DIR_ARGS:zval_files,mcrypt_module_is_block_algorithm_mode:ipv4_is_multicast,",150.0,0.0657955209414164,MHM
1833,"void CloseFds(const std::vector<int>& fds) {
  for (const auto& it : fds) {
    PCHECK(0 == IGNORE_EINTR(close(it)));
  }
}
","void CloseFds(const std::vector<int>& fds) {
  for (const auto& it : fds) {
    kzalloc(0 == IGNORE_EINTR(close(it)));
  }
}
",39.0,8.0,"PCHECK:kzalloc,",34.0,0.0123028357823689,MHM
1835,"bool ScrollAnchor::FindAnchorRecursive(LayoutObject* candidate) {
  ExamineResult result = Examine(candidate);
  if (result.viable) {
    anchor_object_ = candidate;
    corner_ = result.corner;
  }

  if (result.status == kReturn)
    return true;

  if (result.status == kSkip)
    return false;

  for (LayoutObject* child = candidate->SlowFirstChild(); child;
       child = child->NextSibling()) {
    if (FindAnchorRecursive(child))
      return true;
  }

  if (auto* layouy_block = DynamicTo<LayoutBlock>(candidate)) {
    if (TrackedLayoutBoxListHashSet* positioned_descendants =
            layouy_block->PositionedObjects()) {
      for (LayoutBox* descendant : *positioned_descendants) {
        if (descendant->Parent() != candidate) {
          if (FindAnchorRecursive(descendant))
            return true;
        }
      }
    }
  }

  if (result.status == kConstrain)
    return true;

  DCHECK_EQ(result.status, kContinue);
  return false;
}
","bool ScrollAnchor::FindAnchorRecursive(LayoutObject* candidate) {
  ExamineResult decompileSingleArgBuiltInFunctionCall = Examine(candidate);
  if (decompileSingleArgBuiltInFunctionCall.viable) {
    anchor_object_ = candidate;
    corner_ = decompileSingleArgBuiltInFunctionCall.corner;
  }

  if (decompileSingleArgBuiltInFunctionCall.status == kReturn)
    return true;

  if (decompileSingleArgBuiltInFunctionCall.status == kSkip)
    return false;

  for (LayoutObject* sb_block = candidate->SlowFirstChild(); sb_block;
       sb_block = sb_block->NextSibling()) {
    if (FindAnchorRecursive(sb_block))
      return true;
  }

  if (auto* dstBuffer = DynamicTo<LayoutBlock>(candidate)) {
    if (TrackedLayoutBoxListHashSet* mVideoHeight =
            dstBuffer->PositionedObjects()) {
      for (LayoutBox* parser : *mVideoHeight) {
        if (parser->Parent() != candidate) {
          if (FindAnchorRecursive(parser))
            return true;
        }
      }
    }
  }

  if (decompileSingleArgBuiltInFunctionCall.status == kConstrain)
    return true;

  DCHECK_EQ(decompileSingleArgBuiltInFunctionCall.status, kContinue);
  return false;
}
",179.0,37.0,"child:sb_block,layouy_block:dstBuffer,positioned_descendants:mVideoHeight,descendant:parser,result:decompileSingleArgBuiltInFunctionCall,",243.0,0.1058114926020304,MHM
1836," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *regs)
 {
 	struct hw_perf_event *hwc = &event->hw;
	int throttle = 0;

	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, regs)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
"," static void perf_swevent_overflow(struct perf_event *line_buf, u64 die,
				    int AIRPDCAP_WPA_KEY_VER_NOT_CCMP, struct perf_sample_data *option_str,
 				    struct pt_regs *world_id)
 {
 	struct hw_perf_event *hwc = &line_buf->hw;
	int throttle = 0;

	option_str->period = line_buf->hw.last_period;
	if (!die)
		die = sh(line_buf);

	if (hwc->interrupts == u4_scan_pos)
 		return;
 
 	for (; die; die--) {
		if (web_contents(line_buf, AIRPDCAP_WPA_KEY_VER_NOT_CCMP, throttle,
 					    option_str, world_id)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
",107.0,26.0,"__perf_event_overflow:web_contents,perf_swevent_set_period:sh,event:line_buf,overflow:die,MAX_INTERRUPTS:u4_scan_pos,data:option_str,nmi:AIRPDCAP_WPA_KEY_VER_NOT_CCMP,regs:world_id,",367.0,0.1689798951148987,MHM
1837,"void	FS_Flush( fileHandle_t f ) {
	fflush(fsh[f].handleFiles.file.o);
}
","void	FS_Flush( fileHandle_t TIFFTAG_JPEGCOLORMODE ) {
	fflush(fsh[TIFFTAG_JPEGCOLORMODE].handleFiles.file.o);
}
",22.0,5.0,"f:TIFFTAG_JPEGCOLORMODE,",33.0,0.0150103489557902,MHM
1840,"void ResourcePrefetchPredictor::Shutdown() {
  history_service_observer_.RemoveAll();
}
","void ResourcePrefetchPredictor::Shutdown() {
  icmp_mpls_ext_object_header.RemoveAll();
}
",14.0,2.0,"history_service_observer_:icmp_mpls_ext_object_header,",32.0,0.0104089657465616,MHM
1841,"dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t status;
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));

    status = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    status = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;

 if (status != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    closeRequest;

    printRequest(pRI->token, pRI->pCI->requestNumber);

    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif

 return;

invalid:
    invalidCommandBlock(pRI);
 return;
}
","thisObject(Parcel &p, RequestInfo *pRI) {
    RIL_CDMA_SMS_Ack rcsa;
 int32_t  t;
 status_t uint16;
 int32_t digitCount;

    RLOGD(""dispatchCdmaSmsAck"");
    memset(&rcsa, 0, sizeof(rcsa));

    uint16 = p.readInt32(&t);
    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;

    uint16 = p.readInt32(&t);
    rcsa.uSMSCauseCode = (int) t;

 if (uint16 != NO_ERROR) {
 goto invalid;
 }

    startRequest;
    appendPrintBuf(""%suErrorClass=%d, uTLStatus=%d, "",
            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
    U32_AT;

    printRequest(pRI->token, pRI->pCI->requestNumber);

    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memset(&rcsa, 0, sizeof(rcsa));
#endif

 return;

invalid:
    invalidCommandBlock(pRI);
 return;
}
",175.0,44.0,"dispatchCdmaSmsAck:thisObject,closeRequest:U32_AT,status:uint16,",92.0,0.0498928348223368,MHM
1843,"static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}
","static u64 vmac(unsigned char current_utterance_[], unsigned int yposY,
			const unsigned char n[16], u64 *timezone,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(current_utterance_, yposY, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}
",235.0,44.0,"tagl:timezone,mbytes:yposY,m:current_utterance_,",95.0,0.0521738449732462,MHM
1846,"void op_addAvxRoundingMode(MCInst *MI, int v)
{
	if (MI->csh->detail) {
		MI->flat_insn->detail->x86.avx_rm = v;
	}
}
","void serial(MCInst *cBufferTooSmall, int cryp_error)
{
	if (cBufferTooSmall->csh->detail) {
		cBufferTooSmall->flat_insn->detail->x86.avx_rm = cryp_error;
	}
}
",34.0,6.0,"op_addAvxRoundingMode:serial,v:cryp_error,MI:cBufferTooSmall,",124.0,0.0579341848691304,MHM
1850,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
","on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			TIFFTAG_YCBCRSUBSAMPLING(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		TIFFTAG_YCBCRSUBSAMPLING(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
",114.0,28.0,"g_variant_new:TIFFTAG_YCBCRSUBSAMPLING,",33.0,0.0174783031145731,MHM
1851," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }
"," static void unregisterBlobURLTask(void* OP_CMP)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(OP_CMP));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }
",39.0,8.0,"context:OP_CMP,",33.0,0.0169799208641052,MHM
1854,"void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (!InitiateUserInteraction(true /* is_toggle */))
    return;

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
","void ArcVoiceInteractionFrameworkService::nm_i() {
  ParseCommandOption(content::BrowserThread::JSET_SYNTAXERROR);

  if (!new_master_resource(true /* is_toggle */))
    return;

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  credits(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
",58.0,12.0,"DCHECK:credits,DCHECK_CURRENTLY_ON:ParseCommandOption,InitiateUserInteraction:new_master_resource,ToggleSessionFromUserInteraction:nm_i,UI:JSET_SYNTAXERROR,",185.0,0.0806041399637858,MHM
1860,"static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);

	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}
","static int bytes(struct blkcipher_desc *DEBUG_PUSH, struct scatterlist *ThrowMagickException,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(DEBUG_PUSH->tfm);

	return php_stream_fopen_tmpfile(&twofish_dec_xts, DEBUG_PUSH, ThrowMagickException, src, nbytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}
",67.0,18.0,"desc:DEBUG_PUSH,xts_decrypt:bytes,dst:ThrowMagickException,glue_xts_crypt_128bit:php_stream_fopen_tmpfile,",152.0,0.0663605531056722,MHM
1867,"void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "", "" << source
                  << "")"";

  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);
  BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << UrlForLoggingMedia(url);

  if (source != current_source_node_ && source != next_child_node_to_consider_)
    return;

  if (source == next_child_node_to_consider_) {
    if (current_source_node_)
      next_child_node_to_consider_ = current_source_node_->nextSibling();
    BLINK_MEDIA_LOG << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << next_child_node_to_consider_.Get();
  } else if (source == current_source_node_) {
    current_source_node_ = nullptr;
    BLINK_MEDIA_LOG << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}
","void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* oldChild) {
  m_encoding << ""sourceWasRemoved("" << (void*)this << "", "" << oldChild
                  << "")"";

  KURL url = oldChild->GetNonEmptyURLAttribute(kSrcAttr);
  m_encoding << ""sourceWasRemoved("" << (void*)this << "") - 'src' is ""
                  << lc(url);

  if (oldChild != current_source_node_ && oldChild != vmcs_write16)
    return;

  if (oldChild == vmcs_write16) {
    if (current_source_node_)
      vmcs_write16 = current_source_node_->nextSibling();
    m_encoding << ""sourceWasRemoved("" << (void*)this
                    << "") - next_child_node_to_consider_ set to ""
                    << vmcs_write16.Get();
  } else if (oldChild == current_source_node_) {
    current_source_node_ = nullptr;
    m_encoding << ""SourceWasRemoved("" << (void*)this
                    << "") - current_source_node_ set to 0"";
  }
}
",138.0,25.0,"UrlForLoggingMedia:lc,next_child_node_to_consider_:vmcs_write16,source:oldChild,BLINK_MEDIA_LOG:m_encoding,",125.0,0.0483730991681416,MHM
1871,"static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *br = mp->br;
	struct net_bridge_mdb_htable *mdb;

	spin_lock(&br->multicast_lock);
	if (!netif_running(br->dev) || timer_pending(&mp->timer))
		goto out;

	if (!hlist_unhashed(&mp->mglist))
		hlist_del_init(&mp->mglist);

	if (mp->ports)
		goto out;

	mdb = mlock_dereference(br->mdb, br);

	hlist_del_rcu(&mp->hlist[mdb->ver]);
	mdb->size--;

	del_timer(&mp->query_timer);
	call_rcu_bh(&mp->rcu, br_multicast_free_group);

out:
	spin_unlock(&br->multicast_lock);
}
","static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *impl = mp->impl;
	struct net_bridge_mdb_htable *mdb;

	spin_lock(&impl->multicast_lock);
	if (!netif_running(impl->dev) || timer_pending(&mp->timer))
		goto out;

	if (!hlist_unhashed(&mp->mglist))
		hlist_del_init(&mp->mglist);

	if (mp->ports)
		goto out;

	mdb = mlock_dereference(impl->mdb, impl);

	hlist_del_rcu(&mp->hlist[mdb->ver]);
	mdb->size--;

	SAFNUM_LABUNICAST(&mp->query_timer);
	call_rcu_bh(&mp->rcu, current_url_);

out:
	buffsize(&impl->multicast_lock);
}
",149.0,33.0,"del_timer:SAFNUM_LABUNICAST,br:impl,spin_unlock:buffsize,br_multicast_free_group:current_url_,",124.0,0.0509297092755635,MHM
1875,"static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;

  return 0;
}
","static unsigned std(ucvector* u4_size)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!active_entry(u4_size, 137)) return 83;
  if (!active_entry(u4_size, 80)) return 83;
  if (!active_entry(u4_size, 78)) return 83;
  if (!active_entry(u4_size, 71)) return 83;
  if (!active_entry(u4_size, 13)) return 83;
  if (!active_entry(u4_size, 10)) return 83;
  if (!active_entry(u4_size, 26)) return 83;
  if (!active_entry(u4_size, 10)) return 83;

  return 0;
}
",117.0,18.0,"out:u4_size,writeSignature:std,ucvector_push_back:active_entry,",183.0,0.0724476297696431,MHM
1879,"static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;

  unsigned char
    block_count;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block_count);
  if (count != 1)
    return(0);
  count=ReadBlob(image,(size_t) block_count,data);
  if (count != (ssize_t) block_count)
    return(0);
  return(count);
}
","static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    signature_len;

  unsigned char
    block_count;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  signature_len=u4_offset(image,1,&block_count);
  if (signature_len != 1)
    return(0);
  signature_len=u4_offset(image,(size_t) block_count,data);
  if (signature_len != (ssize_t) block_count)
    return(0);
  return(signature_len);
}
",110.0,25.0,"ReadBlob:u4_offset,count:signature_len,",65.0,0.0230251669883728,MHM
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
","TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, pr_cont, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
",65.0,25.0,"_tiffWriteProc:pr_cont,",32.0,0.0115160187085469,MHM
1887,"timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
","timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long Header = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		Header = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)Header * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
",74.0,19.0,"usec:Header,",33.0,0.0118177851041158,MHM
1890,"t_next(struct seq_file *m, void *v, loff_t *pos)
{
	struct trace_array *tr = m->private;
	struct tracer *t = v;

	(*pos)++;

	if (t)
		t = get_tracer_for_array(tr, t->next);

	return t;
}
","readsize(struct seq_file *m, void *msg_tlen, loff_t *pos)
{
	struct trace_array *pbin = m->private;
	struct tracer *t = msg_tlen;

	(*pos)++;

	if (t)
		t = sllc(pbin, t->next);

	return t;
}
",57.0,15.0,"get_tracer_for_array:sllc,tr:pbin,v:msg_tlen,t_next:readsize,",209.0,0.0903335134188334,MHM
1897,"static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zip_unchange_archive(intern) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
","static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		asn1_c_attr;
	}

	throttle(intern, self);

	if (isolate(intern) != 0) {
		asn1_c_attr;
	} else {
		RETURN_TRUE;
	}
}
",54.0,13.0,"zip_unchange_archive:isolate,ZIP_FROM_OBJECT:throttle,RETURN_FALSE:asn1_c_attr,",154.0,0.0690481464068095,MHM
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
","    StateBase* num_mb_skipped(Status origin_x_att, const String& png_sizeof, StateBase* unordered)
    {
        ASSERT(origin_x_att != pSrc);
        BOT_FIELD_ONLY = origin_x_att;
        m_errorMessage = png_sizeof;
        while (unordered) {
            StateBase* tmp = unordered->nextState();
            delete unordered;
            unordered = tmp;
        }
        return new ErrorState;
    }
",60.0,17.0,"handleError:num_mb_skipped,state:unordered,m_status:BOT_FIELD_ONLY,Success:pSrc,errorStatus:origin_x_att,message:png_sizeof,",184.0,0.0869023323059082,MHM
1900,"void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;

    RenderObject* rootBackgroundRenderer = rendererForRootBackground();

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);

    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
}
","void RenderBox::paintRootBoxFillLayers(const PaintInfo& fragment)
{
    if (fragment.skipRootBackground())
        return;

    RenderObject* rootBackgroundRenderer = rendererForRootBackground();

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    Color qualified = rootBackgroundRenderer->resolveColor(type1);

    asn1_p15_obj(fragment, qualified, bgLayer, view()->backgroundRect(this), srcBufferSize, i1_is_end_of_poc, rootBackgroundRenderer);
}
",79.0,18.0,"CompositeSourceOver:i1_is_end_of_poc,BackgroundBleedNone:srcBufferSize,CSSPropertyBackgroundColor:type1,bgColor:qualified,paintInfo:fragment,paintFillLayers:asn1_p15_obj,",215.0,0.0957599639892578,MHM
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	ttyname(&rose_neigh_list_lock);
}
",143.0,34.0,"spin_unlock_bh:ttyname,",63.0,0.0238315264383951,MHM
1906,"int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;

	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -ENOMEM;

	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);

	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return ret;

out_free:
	xt_free_table_info(newinfo);
	return ret;
}
","int arpt_register_table(struct net *net,
			const struct xt_table *table,
			const struct arpt_replace *repl,
			const struct nf_hook_ops *ops,
			struct xt_table **res)
{
	int ret;
	struct xt_table_info *newinfo;
	struct xt_table_info bootstrap = {0};
	void *loc_cpu_entry;
	struct xt_table *new_table;

	newinfo = xt_alloc_table_info(repl->size);
	if (!newinfo)
		return -bitmapFont;

	loc_cpu_entry = newinfo->entries;
	memcpy(loc_cpu_entry, repl->entries, repl->size);

	ret = translate_table(newinfo, loc_cpu_entry, repl);
	duprintf(""arpt_register_table: translate table gives %d\n"", ret);
	if (ret != 0)
		goto out_free;

	new_table = xt_register_table(net, table, &bootstrap, newinfo);
	if (IS_ERR(new_table)) {
		ret = PTR_ERR(new_table);
		goto out_free;
	}

	/* set res now, will see skbs right after nf_register_net_hooks */
	WRITE_ONCE(*res, new_table);

	ret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));
	if (ret != 0) {
		__arpt_unregister_table(new_table);
		*res = NULL;
	}

	return ret;

out_free:
	xt_free_table_info(newinfo);
	return ret;
}
",213.0,58.0,"ENOMEM:bitmapFont,",31.0,0.0178733547528584,MHM
1910,"void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));
}
","void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)
{
    fn_printn->requestServedFromCache(IdentifiersFactory::requestId(identifier));
}
",23.0,5.0,"m_frontend:fn_printn,",33.0,0.0119403560956319,MHM
1916,"rdpsnddbg_process(STREAM s)
{
	unsigned int pkglen;
 	static char *rest = NULL;
 	char *buf;
 
 	pkglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
 	buf = (char *) xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);

	str_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);

	xfree(buf);
}
","rdpsnddbg_process(STREAM s)
{
	unsigned int pkglen;
 	static char *rest = NULL;
 	char *buf;
 
 	pkglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
 	buf = (char *) xmalloc(pkglen + 1);
	a(buf, (char *) s->p, pkglen + 1);

	ND_TTEST2(buf, &rest, rdpsnddbg_line_handler, NULL);

	xfree(buf);
}
",79.0,21.0,"STRNCPY:a,str_handle_lines:ND_TTEST2,",64.0,0.0256121079126993,MHM
1917,"bittok2str(register const struct tok *lp, register const char *fmt,
	   register u_int v)
{
    return (bittok2str_internal(lp, fmt, v, "", ""));
}
","child(register const struct tok *lp, register const char *fmt,
	   register u_int temp_string)
{
    return (glyph_name(lp, fmt, temp_string, "", ""));
}
",36.0,8.0,"v:temp_string,bittok2str_internal:glyph_name,bittok2str:child,",95.0,0.0375846187273661,MHM
1919,"void WebLocalFrameImpl::ReplaceSelection(const WebString& text) {
  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  GetFrame()->GetEditor().ReplaceSelection(text);
}
","void WebLocalFrameImpl::ent(const WebString& COMPRESSION_LZMA) {
  origin_y_att()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  origin_y_att()->GetEditor().ent(COMPRESSION_LZMA);
}
",37.0,5.0,"ReplaceSelection:ent,GetFrame:origin_y_att,text:COMPRESSION_LZMA,",307.0,0.1268268108367919,MHM
1920,"xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
 int ret;

 if ((*str == '/') && (*(str + 1) == '/')) {
        str += 2;
	ret = xmlParse3986Authority(uri, &str);
 if (ret != 0) return(ret);
	ret = xmlParse3986PathAbEmpty(uri, &str);
 if (ret != 0) return(ret);
 } else if (*str == '/') {
	ret = xmlParse3986PathAbsolute(uri, &str);
 if (ret != 0) return(ret);
 } else if (ISA_PCHAR(str)) {
        ret = xmlParse3986PathNoScheme(uri, &str);
 if (ret != 0) return(ret);
 } else {
 /* path-empty is effectively empty */
 if (uri != NULL) {
 if (uri->path != NULL) xmlFree(uri->path);
	    uri->path = NULL;
 }
 }

 if (*str == '?') {
	str++;
	ret = xmlParse3986Query(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str == '#') {
	str++;
	ret = xmlParse3986Fragment(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str != 0) {
	xmlCleanURI(uri);
 return(1);
 }
 return(0);
}
","xmlParse3986RelativeRef(xmlURIPtr uri, const char *MSG_CMSG_COMPAT) {
 int ret;

 if ((*MSG_CMSG_COMPAT == '/') && (*(MSG_CMSG_COMPAT + 1) == '/')) {
        MSG_CMSG_COMPAT += 2;
	ret = xmlParse3986Authority(uri, &MSG_CMSG_COMPAT);
 if (ret != 0) return(ret);
	ret = m_decodedHTTPBody(uri, &MSG_CMSG_COMPAT);
 if (ret != 0) return(ret);
 } else if (*MSG_CMSG_COMPAT == '/') {
	ret = xmlParse3986PathAbsolute(uri, &MSG_CMSG_COMPAT);
 if (ret != 0) return(ret);
 } else if (ISA_PCHAR(MSG_CMSG_COMPAT)) {
        ret = xmlParse3986PathNoScheme(uri, &MSG_CMSG_COMPAT);
 if (ret != 0) return(ret);
 } else {
 /* path-empty is effectively empty */
 if (uri != NULL) {
 if (uri->path != NULL) xmlFree(uri->path);
	    uri->path = NULL;
 }
 }

 if (*MSG_CMSG_COMPAT == '?') {
	MSG_CMSG_COMPAT++;
	ret = xmlParse3986Query(uri, &MSG_CMSG_COMPAT);
 if (ret != 0) return(ret);
 }
 if (*MSG_CMSG_COMPAT == '#') {
	MSG_CMSG_COMPAT++;
	ret = xmlParse3986Fragment(uri, &MSG_CMSG_COMPAT);
 if (ret != 0) return(ret);
 }
 if (*MSG_CMSG_COMPAT != 0) {
	xmlCleanURI(uri);
 return(1);
 }
 return(0);
}
",272.0,58.0,"str:MSG_CMSG_COMPAT,xmlParse3986PathAbEmpty:m_decodedHTTPBody,",91.0,0.0384209195772806,MHM
1923,"  uint64_t received_page_id() const { return received_page_id_; }
","  uint64_t received_page_id() const { return ScaleQuantumToShort; }
",10.0,2.0,"received_page_id_:ScaleQuantumToShort,",32.0,0.0145112752914428,MHM
1924,"gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }

  return size;
}
","gfx::Size ScaleSizeToFitView(const gfx::Size& IVD_ERROR_NONE,
                             const gfx::Size& view_size) {
  if ((IVD_ERROR_NONE.width() > view_size.width() ||
       IVD_ERROR_NONE.height() > view_size.height()) ||
      (IVD_ERROR_NONE.width() < view_size.width() &&
       IVD_ERROR_NONE.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(IVD_ERROR_NONE.width()),
                 view_size.height() / static_cast<float>(IVD_ERROR_NONE.height()));
    return gfx::ScaleToFlooredSize(IVD_ERROR_NONE, scale);
  }

  return IVD_ERROR_NONE;
}
",135.0,23.0,"size:IVD_ERROR_NONE,",33.0,0.0154704332351684,MHM
1926,"IW_IMPL(void) iw_set_apply_bkgd_2(struct iw_context *ctx, const struct iw_color *clr)
{
	ctx->req.bkgd_valid=1;
	ctx->req.bkgd = *clr;
}
","emit(void) put_signed(struct iw_context *ScaleQuantumToLong, const struct iw_color *need)
{
	ScaleQuantumToLong->req.bkgd_valid=1;
	ScaleQuantumToLong->req.bkgd = *need;
}
",36.0,7.0,"clr:need,IW_IMPL:emit,ctx:ScaleQuantumToLong,iw_set_apply_bkgd_2:put_signed,",483.0,0.1996678868929545,MHM
1933,"sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
","iint(void)
{
	script_state = 0;
	X86EMUL_MODE_PROT32 = 0;
	ph = 0;
	in_dev = 0;
	g_licence_error_result = 0;
	socket_count();
}
",30.0,7.0,"g_server_rdp_version:script_state,g_sec_encrypt_use_count:X86EMUL_MODE_PROT32,g_sec_decrypt_use_count:ph,g_licence_issued:in_dev,mcs_reset_state:socket_count,sec_reset_state:iint,",368.0,0.1502063035964966,MHM
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
","static void yStep(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    param(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
",97.0,24.0,"wmv2_mspel8_h_lowpass:param,put_mspel8_mc32_c:yStep,",62.0,0.0306208610534667,MHM
1935,"void Browser::SaveWindowPlacement(const gfx::Rect& bounds,
                                  ui::WindowShowState show_state) {
  SessionService* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    session_service->SetWindowBounds(session_id_, bounds, show_state);
}
","void Browser::SaveWindowPlacement(const gfx::Rect& bounds,
                                  ui::WindowShowState OMX_ErrorUndefined) {
  SessionService* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    session_service->SetWindowBounds(session_id_, bounds, OMX_ErrorUndefined);
}
",47.0,11.0,"show_state:OMX_ErrorUndefined,",32.0,0.0158108075459798,MHM
1936,"static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
{
	unsigned long val;
	void *ptr = NULL;

	if (!atomic_pool) {
		WARN(1, ""coherent pool not initialised!\n"");
		return NULL;
	}

	val = gen_pool_alloc(atomic_pool, size);
	if (val) {
		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
 
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)val;
		if (flags & __GFP_ZERO)
			memset(ptr, 0, size);
 	}
 
 	return ptr;
}
","static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
{
	unsigned long val;
	void *ptr = NULL;

	if (!atomic_pool) {
		WARN(1, ""coherent pool not initialised!\n"");
		return NULL;
	}

	val = mailbox(atomic_pool, size);
	if (val) {
		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
 
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)val;
		if (flags & __GFP_ZERO)
			memset(ptr, 0, size);
 	}
 
 	return ptr;
}
",107.0,28.0,"gen_pool_alloc:mailbox,",33.0,0.0117614150047302,MHM
1939," FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));
 }
"," FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& cipop)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> u4_first_start_code_found = EntrySyncCallbackHelper::red();
     m_fileSystem->getFile(this, path, flags, u4_first_start_code_found->successCallback(), u4_first_start_code_found->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<FileEntrySync*>(u4_first_start_code_found->getResult(cipop));
 }
",82.0,16.0,"helper:u4_first_start_code_found,exceptionState:cipop,create:red,",126.0,0.051024051507314,MHM
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);

	return rv;
}
","int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *xdr)
{
	int API, errmsg = 0;

	user = acquire_ipmi_user(user, &API);
	if (!user)
		return -bitdepth;

	if (channel >= GetPixelRed) {
		errmsg = -EINVAL;
	} else {
		channel = context(channel, GetPixelRed);
		*xdr = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, API);

	return errmsg;
}
",94.0,27.0,"index:API,address:xdr,array_index_nospec:context,rv:errmsg,IPMI_MAX_CHANNELS:GetPixelRed,ENODEV:bitdepth,",184.0,0.0720921317736307,MHM
1943,"void MediaRecorder::ScheduleDispatchEvent(Event* event) {
  scheduled_events_.push_back(event);

  dispatch_scheduled_event_runner_->RunAsync();
}
","void MediaRecorder::m_encoding(Event* event) {
  scheduled_events_.push_back(event);

  dispatch_scheduled_event_runner_->RunAsync();
}
",24.0,5.0,"ScheduleDispatchEvent:m_encoding,",35.0,0.011444334189097,MHM
1944," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
"," std::string EXEC_IN_SWITCH(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string fz_xml_tag(kPostXml);
  const std::string pfds(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = fz_xml_tag.find(pfds);
  DCHECK(placeholder_pos != std::string::npos);
  fz_xml_tag.replace(placeholder_pos, pfds.size(), brand);
  return fz_xml_tag;
 }
",81.0,17.0,"placeholder:pfds,GetUploadData:EXEC_IN_SWITCH,data:fz_xml_tag,",122.0,0.0479941805203755,MHM
1949,"u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;

	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		mtu = fi->fib_mtu;

	if (likely(!mtu)) {
		struct fib_nh_exception *fnhe;

		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}

	if (likely(!mtu))
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);

	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
}
","u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;

	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		mtu = fi->fib_mtu;

	if (likely(!mtu)) {
		struct fib_nh_exception *fnhe;

		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(m_decodedHTTPBody, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}

	if (likely(!mtu))
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);

	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
}
",163.0,42.0,"jiffies:m_decodedHTTPBody,",33.0,0.0136305252710978,MHM
1951,"		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
","		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				OMX_ErrorBadParameter.m_eventsystem.RemoveSingleState(idx, OMX_ErrorBadParameter.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			OMX_ErrorBadParameter.m_pluginsystem.DeviceModified(idx);
#endif
		}
",141.0,25.0,"m_mainworker:OMX_ErrorBadParameter,",32.0,0.0167787949244181,MHM
1953," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}
"," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   OPJ_INT32(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::noff,
                   tc_source);
  }
}
",84.0,18.0,"TAB_CONTENTS_INFOBAR_REPLACED:noff,RemoveAllChildViews:OPJ_INT32,",63.0,0.0322485248247782,MHM
1960,"atol10(const char *p, size_t char_cnt)
{
 	uint64_t l;
 	int digit;
 
 	l = 0;
 	digit = *p - '0';
 	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
		l = (l * 10) + digit;
		digit = *++p - '0';
	}
	return (l);
}
","atol10(const char *p, size_t part2)
{
 	uint64_t l;
 	int digit;
 
 	l = 0;
 	digit = *p - '0';
 	while (digit >= 0 && digit < 10  && part2-- > 0) {
		l = (l * 10) + digit;
		digit = *++p - '0';
	}
	return (l);
}
",71.0,17.0,"char_cnt:part2,",34.0,0.0108094652493794,MHM
1969,"void streamFreeCG(streamCG *cg) {
    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
    zfree(cg);
}
","void alphaPixBuf(streamCG *cg) {
    num_axes(cg->pel,(void(*)(void*))ds);
    num_axes(cg->consumers,(void(*)(void*))pageSize);
    aflags(cg);
}
",52.0,10.0,"streamFreeConsumer:pageSize,zfree:aflags,raxFreeWithCallback:num_axes,streamFreeNACK:ds,streamFreeCG:alphaPixBuf,",275.0,0.1098767161369323,MHM
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
","static int ppp_gidle(unsigned int fd, unsigned int maxLen,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, gp;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(gp, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(gp, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
",117.0,34.0,"recv:gp,cmd:maxLen,",63.0,0.0218943238258361,MHM
1981,"void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }

  controller_->OnDropIndexUpdate(index->value, index->drop_before);

  if (drop_arrow_ && (index == drop_arrow_->index))
    return;

  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
","void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    PNG_CONST->OnDropIndexUpdate(-1, false);
    local.reset();
    return;
  }

  PNG_CONST->OnDropIndexUpdate(index->value, index->drop_before);

  if (local && (index == local->index))
    return;

  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);

  if (!local) {
    local = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    local->index = *index;
    if (is_beneath == local->point_down) {
      local->point_down = !is_beneath;
      local->arrow_view->SetImage(
          GetDropArrowImage(local->point_down));
    }
  }

  local->arrow_window->SetBounds(drop_bounds);
  local->arrow_window->Show();
}
",177.0,35.0,"drop_arrow_:local,controller_:PNG_CONST,",63.0,0.0233866492907206,MHM
1984,"void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }

    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();

    scrollToSelection();
}
","void HTMLSelectElement::SplFileObject(int index)
{    
    if (!mfn())
        accessKeyAction(false);
    
    const Vector<HTMLElement*>& items = listItems();
    int PF_INET = optionToListIndex(index);
    if (PF_INET >= 0) {
        HTMLElement* leaf = items[PF_INET];
        if (leaf->hasTagName(url_)) {
            if (toHTMLOptionElement(leaf)->selected())
                toHTMLOptionElement(leaf)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }

    if (usesMenuList())
        key2();
    else
        listBoxOnChange();

    scrollToSelection();
}
",121.0,27.0,"listIndex:PF_INET,focused:mfn,optionTag:url_,dispatchChangeEventForMenuList:key2,element:leaf,accessKeySetSelectedIndex:SplFileObject,",216.0,0.0907370646794637,MHM
1985,"void ApiTestEnvironment::RunPromisesAgain() {
  env()->isolate()->RunMicrotasks();
  base::MessageLoop::current()->PostTask(
      FROM_HERE, base::Bind(&ApiTestEnvironment::RunPromisesAgain,
                            base::Unretained(this)));
}
","void ApiTestEnvironment::RunPromisesAgain() {
  env()->isolate()->RunMicrotasks();
  base::MessageLoop::current()->PostTask(
      FROM_HERE, base::pbin(&ApiTestEnvironment::RunPromisesAgain,
                            base::Unretained(this)));
}
",50.0,7.0,"Bind:pbin,",32.0,0.0099215308825174,MHM
1988,"static TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,
					   size_t size)
{
	struct bignum **bn = attr;

	return crypto_bignum_bin2bn(buffer, size, *bn);
}
","static TEE_Result core(void *addr_len, const void *buffer,
					   size_t size)
{
	struct bignum **bn = addr_len;

	return crypto_bignum_bin2bn(buffer, size, *bn);
}
",37.0,10.0,"attr:addr_len,op_attr_bignum_from_user:core,",96.0,0.0432564854621887,MHM
1989,"PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	zend_long z_len;
	size_t str_len, nbytes;
	size_t len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rs|l"", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {
		return;
	}

	if (argc > 2) {
		if (z_len > (zend_long)str_len) {
			php_error_docref(NULL, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %pd"", str_len, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL, E_WARNING, ""Buffer size must be larger than 0, but %pd was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = str_len;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}

	RETURN_LONG(nbytes);
}
","PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	zend_long z_len;
	size_t XML_PARSER_START_TAG, nbytes;
	size_t len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rs|l"", &pgsql_id, &str, &XML_PARSER_START_TAG, &z_len) == FAILURE) {
		return;
	}

	if (argc > 2) {
		if (z_len > (zend_long)XML_PARSER_START_TAG) {
			php_error_docref(NULL, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %pd"", XML_PARSER_START_TAG, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL, E_WARNING, ""Buffer size must be larger than 0, but %pd was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = XML_PARSER_START_TAG;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}

	RETURN_LONG(nbytes);
}
",189.0,48.0,"str_len:XML_PARSER_START_TAG,",31.0,0.0125116348266601,MHM
1995,"  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }
","  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope jiffies_to_msecs(isolate);
    v8::Local<v8::Value> Create[] = {v8::Boolean::missing(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::missing(isolate, rv_read),
                           skb1(Create), Create);
     delete this;
   }
",84.0,16.0,"arraysize:skb1,args:Create,callback_:rv_read,handle_scope:jiffies_to_msecs,New:missing,",274.0,0.1260695934295654,MHM
1996,"void GpuCommandBufferStub::OnCreateTransferBuffer(int32 size,
                                                   int32 id_request,
                                                   IPC::Message* reply_message) {
   TRACE_EVENT0(""gpu"", ""GpuCommandBufferStub::OnCreateTransferBuffer"");
  if (command_buffer_.get()) {
    int32 id = command_buffer_->CreateTransferBuffer(size, id_request);
    GpuCommandBufferMsg_CreateTransferBuffer::WriteReplyParams(
        reply_message, id);
  } else {
    reply_message->set_reply_error();
  }
  Send(reply_message);
}
","void GpuCommandBufferStub::orgcode(int32 size,
                                                   int32 id_request,
                                                   IPC::Message* reply_message) {
   TRACE_EVENT0(""gpu"", ""GpuCommandBufferStub::OnCreateTransferBuffer"");
  if (command_buffer_.get()) {
    int32 id = command_buffer_->CreateTransferBuffer(size, id_request);
    GpuCommandBufferMsg_CreateTransferBuffer::WriteReplyParams(
        reply_message, id);
  } else {
    reply_message->set_reply_error();
  }
  Send(reply_message);
}
",73.0,16.0,"OnCreateTransferBuffer:orgcode,",32.0,0.0137400348981221,MHM
2001,"void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(index, contents->web_contents());
  GetTabAt(index)->set_closing(true);
}
","void TabStripGtk::TabDetachedAt(TabContents* pfds, int close) {
   list_for_each();
  downstreamEnd(close, pfds->web_contents());
  xctx(close)->set_closing(true);
}
",39.0,9.0,"GenerateIdealBounds:list_for_each,GetTabAt:xctx,index:close,StartRemoveTabAnimation:downstreamEnd,contents:pfds,",309.0,0.1080736835797627,MHM
2004,"void NuPlayer::GenericSource::setDrmPlaybackStatusIfNeeded(int playbackStatus, int64_t position) {
 if (mDecryptHandle != NULL) {
        mDrmManagerClient->setPlaybackStatus(mDecryptHandle, playbackStatus, position);
 }
    mSubtitleTrack.mPackets = new AnotherPacketSource(NULL);
    mTimedTextTrack.mPackets = new AnotherPacketSource(NULL);
}
","void NuPlayer::GenericSource::setDrmPlaybackStatusIfNeeded(int playbackStatus, int64_t position) {
 if (mDecryptHandle != NULL) {
        mDrmManagerClient->setPlaybackStatus(mDecryptHandle, playbackStatus, position);
 }
    mSubtitleTrack.mPackets = new AnotherPacketSource(NULL);
    tok.mPackets = new AnotherPacketSource(NULL);
}
",54.0,10.0,"mTimedTextTrack:tok,",34.0,0.0111208717028299,MHM
2006,"int __remove_suid(struct dentry *dentry, int kill)
{
	struct iattr newattrs;

	newattrs.ia_valid = ATTR_FORCE | kill;
	return notify_change(dentry, &newattrs);
}
","int hexdump(struct extlen *extlen, int kill)
{
	struct iattr WriteBinaryBlobMode;

	WriteBinaryBlobMode.ia_valid = y_top | kill;
	return SET_INT_VALUE(extlen, &WriteBinaryBlobMode);
}
",34.0,10.0,"dentry:extlen,ATTR_FORCE:y_top,newattrs:WriteBinaryBlobMode,notify_change:SET_INT_VALUE,__remove_suid:hexdump,",218.0,0.0725117484728495,MHM
2013,"WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
}
","WebPlugin* RenderView::allow_create(
    WebFrame* PopShortPixel,
    const WebPluginParams& ovector,
    const FilePath& EACCES,
    const std::string& green) {
  return new webkit::npapi::WebPluginImpl(
      PopShortPixel, ovector, EACCES, green, fd_d());
}
",50.0,10.0,"CreateNPAPIPlugin:allow_create,path:EACCES,AsWeakPtr:fd_d,frame:PopShortPixel,mime_type:green,params:ovector,",457.0,0.1461362163225809,MHM
2018,"PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
","PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, mng_get_long;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(mng_get_long) {
        stuff->picture = pict->info[mng_get_long].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
",84.0,26.0,"j:mng_get_long,",34.0,0.0099000692367553,MHM
2019," void EncoderTest::InitializeConfig() {
   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);
   ASSERT_EQ(VPX_CODEC_OK, res);
 }
"," void EncoderTest::ih264d_signal_bs_deblk_thread() {
   const vpx_codec_err_t points_end = EXTRACT_24BITS->DefaultEncoderConfig(&font, 0);
   GF_OK(shminfo, points_end);
 }
",29.0,7.0,"res:points_end,VPX_CODEC_OK:shminfo,InitializeConfig:ih264d_signal_bs_deblk_thread,codec_:EXTRACT_24BITS,ASSERT_EQ:GF_OK,cfg_:font,",307.0,0.0966383576393127,MHM
2020,"static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
","static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *tmpbuffer,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
",60.0,13.0,"nlh:tmpbuffer,",32.0,0.0092807173728942,MHM
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
","void imap_cachepath(struct ImapData *idata, const char *m_pSeekHead, char *dest, size_t rdsdebug)
{
  char *s = NULL;
  const char *charcode = m_pSeekHead;

  for (s = dest; charcode && *charcode && rdsdebug; rdsdebug--)
  {
    if (*charcode == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(charcode + 1) >= '0' && *(charcode + 1) <= '9')
      {
        if (--rdsdebug)
          *++s = '_';
      }
    }
    else
      *s = *charcode;
    charcode++;
    s++;
  }
  *s = '\0';
}
",126.0,26.0,"mailbox:m_pSeekHead,dlen:rdsdebug,p:charcode,",122.0,0.0379357814788818,MHM
2024,"void TextAutosizer::processCluster(RenderBlock* cluster, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)
{
    ASSERT(isAutosizingCluster(cluster));

    RenderBlock* lowestCommonAncestor = cluster;
    float commonAncestorWidth = lowestCommonAncestor->contentLogicalWidth();

    float multiplier = 1;
    if (clusterShouldBeAutosized(lowestCommonAncestor, commonAncestorWidth)) {
        int logicalWindowWidth = cluster->isHorizontalWritingMode() ? windowInfo.windowSize.width() : windowInfo.windowSize.height();
        int logicalLayoutWidth = cluster->isHorizontalWritingMode() ? windowInfo.minLayoutSize.width() : windowInfo.minLayoutSize.height();
        float logicalClusterWidth = std::min<float>(commonAncestorWidth, logicalLayoutWidth);

        multiplier = logicalClusterWidth / logicalWindowWidth;
        multiplier *= m_document->settings()->textAutosizingFontScaleFactor();
        multiplier = std::max(1.0f, multiplier);
    }

    processContainer(multiplier, container, subtreeRoot, windowInfo);
}
","void TextAutosizer::tga(RenderBlock* dn, RenderBlock* vmcs12, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)
{
    ASSERT(lastDefined(dn));

    RenderBlock* lowestCommonAncestor = dn;
    float commonAncestorWidth = lowestCommonAncestor->contentLogicalWidth();

    float multiplier = 1;
    if (clusterShouldBeAutosized(lowestCommonAncestor, commonAncestorWidth)) {
        int logicalWindowWidth = dn->isHorizontalWritingMode() ? windowInfo.windowSize.width() : windowInfo.windowSize.height();
        int logicalLayoutWidth = dn->isHorizontalWritingMode() ? windowInfo.minLayoutSize.width() : windowInfo.minLayoutSize.height();
        float key_version = std::sample_rate<float>(commonAncestorWidth, logicalLayoutWidth);

        multiplier = key_version / logicalWindowWidth;
        multiplier *= plain->settings()->textAutosizingFontScaleFactor();
        multiplier = std::WAVPACK_SOFT_ERROR(1.0f, multiplier);
    }

    pattern(multiplier, vmcs12, subtreeRoot, windowInfo);
}
",168.0,41.0,"isAutosizingCluster:lastDefined,container:vmcs12,processContainer:pattern,cluster:dn,processCluster:tga,m_document:plain,logicalClusterWidth:key_version,max:WAVPACK_SOFT_ERROR,min:sample_rate,",305.0,0.1006391684214274,MHM
2025,"VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;

    if (IsVlanSupported(pContext))
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}
","VOID bus(PPARANDIS_ADAPTER destPtr, PNET_BUFFER_LIST to, PNET_PACKET_INFO spec)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO pointsWeights;
    pointsWeights.Value = NULL;

    if (old(destPtr))
        pointsWeights.TagHeader.UserPriority = spec->Vlan.UserPriority;

    if (IsVlanSupported(destPtr))
        pointsWeights.TagHeader.VlanId = spec->Vlan.VlanId;

    if(pointsWeights.Value != NULL)
        destPtr->extraStatistics.framesRxPriority++;

    gdImageSetPixel(to, max_irr) = pointsWeights.Value;
}
",87.0,20.0,"pContext:destPtr,NBLSet8021QInfo:bus,Ieee8021QNetBufferListInfo:max_irr,IsPrioritySupported:old,pPacketInfo:spec,pNBL:to,qInfo:pointsWeights,NET_BUFFER_LIST_INFO:gdImageSetPixel,",334.0,0.117331592241923,MHM
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
","static long pg0(struct net *net, struct socket *zea,
				 unsigned int cmd, unsigned long arg)
{
	int rxent;
	void __user *argp = (void __user *)arg;

	rxent = zea->ops->ioctl(zea, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (rxent != -ENOIOCTLCMD)
		return rxent;

	if (cmd == points_end) {
		struct ifconf ifc;
		if (mgmt_ie_buf(&ifc, argp, sizeof(struct ifconf)))
			return -android_errorWriteLog;
		rtnl_lock();
		rxent = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!rxent && filename_len(argp, &ifc, sizeof(struct ifconf)))
			rxent = -android_errorWriteLog;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (mgmt_ie_buf(&ifr, argp, sizeof(struct ifreq)))
			return -android_errorWriteLog;
		rxent = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!rxent && need_copyout)
			if (filename_len(argp, &ifr, sizeof(struct ifreq)))
				return -android_errorWriteLog;
	}
	return rxent;
}
",219.0,55.0,"EFAULT:android_errorWriteLog,SIOCGIFCONF:points_end,sock:zea,sock_do_ioctl:pg0,copy_from_user:mgmt_ie_buf,err:rxent,copy_to_user:filename_len,",215.0,0.0701029300689697,MHM
2030,"nm_ip4_config_get_ifindex (const NMIP4Config *config)
{
	return NM_IP4_CONFIG_GET_PRIVATE (config)->ifindex;
}
","cache_entry (const NMIP4Config *current_utterance_)
{
	return __load_segment_descriptor (current_utterance_)->ifindex;
}
",17.0,4.0,"nm_ip4_config_get_ifindex:cache_entry,NM_IP4_CONFIG_GET_PRIVATE:__load_segment_descriptor,config:current_utterance_,",338.0,0.1011049628257751,MHM
2031,"static int parse_sliteral(char **c, char **dst)
{
	struct token t;
	char *s = *c;

	get_token(c, &t, L_SLITERAL);

	if (t.type != T_STRING) {
		printf(""Expected string literal: %.*s\n"", (int)(*c - s), s);
		return -EINVAL;
	}

	*dst = t.val;

	return 1;
}
","static int parse_sliteral(char **pu4_bitstrm_buf, char **dst)
{
	struct token t;
	char *s = *pu4_bitstrm_buf;

	get_token(pu4_bitstrm_buf, &t, L_SLITERAL);

	if (t.type != T_STRING) {
		printf(""Expected string literal: %.*s\n"", (int)(*pu4_bitstrm_buf - s), s);
		return -EINVAL;
	}

	*dst = t.val;

	return 1;
}
",80.0,19.0,"c:pu4_bitstrm_buf,",32.0,0.0101696570714314,MHM
2034," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.
    return;

#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);

  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}
"," void RenderViewImpl::WriteBlobString() {
  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.
    return;

#if defined(jsvSkipNameAndUnLock)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);

  if (!ALIGN_TO) {
    ALIGN_TO = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}
",76.0,10.0,"media_stream_impl_:ALIGN_TO,ENABLE_WEBRTC:jsvSkipNameAndUnLock,EnsureMediaStreamImpl:WriteBlobString,",94.0,0.0335856358210245,MHM
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
","TIFFSetField(void *) gdImageWebpPtrEx (gdImagePtr im, int *MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE, int quality)
{
	void *rv;
	gdIOCtx *subject = gdNewDynamicCtx(2048, NULL);
 	if (subject == NULL) {
 		return NULL;
 	}
	vp(im, subject, quality);
	rv = decoder(subject, MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE);
 	subject->gd_free(subject);
 	return rv;
 }
",73.0,20.0,"out:subject,size:MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE,BGD_DECLARE:TIFFSetField,gdImageWebpCtx:vp,gdDPExtractData:decoder,",246.0,0.0756203889846801,MHM
2038,"static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
","static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (Then(p->used)) {
		struct completion samplesperpixel;
		init_completion(&samplesperpixel);
		p->unregistering = &samplesperpixel;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&samplesperpixel);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-dh);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
",75.0,20.0,"EINVAL:dh,unlikely:Then,wait:samplesperpixel,",93.0,0.0288336197535196,MHM
2040,"struct sas_phy *sas_get_local_phy(struct domain_device *dev)
{
	struct sas_ha_struct *ha = dev->port->ha;
	struct sas_phy *phy;
	unsigned long flags;

	/* a published domain device always has a valid phy, it may be
	 * stale, but it is never NULL
	 */
	BUG_ON(!dev->phy);

	spin_lock_irqsave(&ha->phy_port_lock, flags);
	phy = dev->phy;
	get_device(&phy->dev);
	spin_unlock_irqrestore(&ha->phy_port_lock, flags);

	return phy;
}
","struct sas_phy *sas_get_local_phy(struct domain_device *dev)
{
	struct sas_ha_struct *ha = dev->port->ha;
	struct sas_phy *phy;
	unsigned long LOG_NOTICE;

	/* a published domain device always has a valid phy, it may be
	 * stale, but it is never NULL
	 */
	BUG_ON(!dev->phy);

	spin_lock_irqsave(&ha->phy_port_lock, LOG_NOTICE);
	phy = dev->phy;
	get_device(&phy->dev);
	spin_unlock_irqrestore(&ha->phy_port_lock, LOG_NOTICE);

	return phy;
}
",77.0,19.0,"flags:LOG_NOTICE,",33.0,0.0090759515762329,MHM
2042,"INST_HANDLER (sleep) {	// SLEEP
	ESIL_A (""BREAK"");
}
","endianness (sleep) {	// SLEEP
	lr_ratio (""BREAK"");
}
",12.0,2.0,"INST_HANDLER:endianness,ESIL_A:lr_ratio,",65.0,0.0192428350448608,MHM
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
","void SplashOutputDev::testend(GfxState *goffset) {
  SplashPath *src16, *path2;

  src16 = repl(goffset, goffset->getPath());
  path2 = g_data_input_stream_read_line->makeStrokePath(src16);
  delete src16;
  g_data_input_stream_read_line->clipToPath(path2, prd);
  delete path2;
}
",55.0,16.0,"clipToStrokePath:testend,state:goffset,convertPath:repl,gFalse:prd,splash:g_data_input_stream_read_line,path:src16,",484.0,0.1501867413520813,MHM
2044,"blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }

  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }

#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),
      params.mime_type.Utf8(), &found, &info, &mime_type));
  if (!found)
    return nullptr;

  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr /* throttler */);
#else
  return nullptr;
#endif  // BUILDFLAG(ENABLE_PLUGINS)
}
","blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& pMode) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, pMode,
                                                           &plugin)) {
    return plugin;
  }

  if (pMode.mime_type.ContainsOnlyASCII() &&
      pMode.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, ps_trns_addr(pMode.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }

#if RETVAL_FALSE(marker)
  WebPluginInfo fn_printn;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, pMode.url, frame_->Top()->GetSecurityOrigin(),
      pMode.mime_type.Utf8(), &found, &fn_printn, &mime_type));
  if (!found)
    return nullptr;

  WebPluginParams params_to_use = pMode;
  params_to_use.mime_type = WebString::my_realpath(mime_type);
  return CreatePlugin(fn_printn, params_to_use, nullptr /* throttler */);
#else
  return nullptr;
#endif  // BUILDFLAG(ENABLE_PLUGINS)
}
",218.0,40.0,"params:pMode,FromUTF8:my_realpath,BUILDFLAG:RETVAL_FALSE,GURL:ps_trns_addr,ENABLE_PLUGINS:marker,info:fn_printn,",243.0,0.0849931836128234,MHM
2046,"void ContextState::RestoreRenderbufferBindings() {
  bound_renderbuffer_valid = false;
}
","void ContextState::SyncHandle() {
  bound_renderbuffer_valid = false;
}
",12.0,2.0,"RestoreRenderbufferBindings:SyncHandle,",32.0,0.0103564858436584,MHM
2049,"status_t DRMSource::start(MetaData *params) {
 int32_t val;
 if (params && params->findInt32(kKeyWantsNALFragments, &val)
 && val != 0) {
        mWantsNALFragments = true;
 } else {
        mWantsNALFragments = false;
 }

 return mOriginalMediaSource->start(params);
}
","status_t DRMSource::tmp16(MetaData *XML_PARSER_ATTRIBUTE_VALUE) {
 int32_t lastarg;
 if (XML_PARSER_ATTRIBUTE_VALUE && XML_PARSER_ATTRIBUTE_VALUE->findInt32(child_set_env, &lastarg)
 && lastarg != 0) {
        mWantsNALFragments = true;
 } else {
        mWantsNALFragments = false;
 }

 return mOriginalMediaSource->tmp16(XML_PARSER_ATTRIBUTE_VALUE);
}
",53.0,12.0,"start:tmp16,kKeyWantsNALFragments:child_set_env,params:XML_PARSER_ATTRIBUTE_VALUE,val:lastarg,",182.0,0.0553965926170349,MHM
2058,"bool Browser::IsPopup(const TabContents* source) const {
  return !!(type() & TYPE_POPUP);
}
","bool Browser::IsPopup(const TabContents* alphabeta_sum) const {
  return !!(m_end() & TYPE_POPUP);
}
",24.0,4.0,"type:m_end,source:alphabeta_sum,",62.0,0.0189664999643961,MHM
2059,"void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);

  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;

  if (commit_params.origin_to_commit) {
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}
","void AF_INET6(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);

  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;

  if (commit_params.origin_to_commit) {
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}
",72.0,15.0,"FillMiscNavigationParams:AF_INET6,",33.0,0.010303521156311,MHM
2062,"static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;

	close_command.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&close_command, sizeof(close_command));
}
","static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple EXTENSION_FUNCTION_VALIDATE;

	EXTENSION_FUNCTION_VALIDATE.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&EXTENSION_FUNCTION_VALIDATE, sizeof(EXTENSION_FUNCTION_VALIDATE));
}
",45.0,10.0,"close_command:EXTENSION_FUNCTION_VALIDATE,",31.0,0.0089764674504597,MHM
2067," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }
 
  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      reinterpret_cast<void*>(notify_data));
  return stream;
 }
"," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t uo_priv, intptr_t existing_stream) {
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }
 
  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      reinterpret_cast<void*>(uo_priv));
  return stream;
 }
",94.0,21.0,"notify_data:uo_priv,",34.0,0.0109118143717447,MHM
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_store_id))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
","void IndexedDBDatabase::Clear(IndexedDBTransaction* save_lookup_value,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(save_lookup_value);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", save_lookup_value->id());
  DCHECK_NE(save_lookup_value->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!MagickPathExtent(object_store_id))
    return;

  save_lookup_value->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
",88.0,18.0,"ValidateObjectStoreId:MagickPathExtent,transaction:save_lookup_value,",63.0,0.0223668773969014,MHM
2070,"void WebDevToolsAgentImpl::didNavigate()
{
    ClientMessageLoopAdapter::didNavigate();
}
","void WebDevToolsAgentImpl::GetContentClient()
{
    ClientMessageLoopAdapter::GetContentClient();
}
",14.0,2.0,"didNavigate:GetContentClient,",64.0,0.0202341318130493,MHM
2071," RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  base::Unretained(this)));
 }
"," errInfo::errInfo(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
   supported_focus_modes(
       ""OnDocumentElementCreated"",
       base::Bind(&errInfo::OnDocumentElementCreated,
                  base::endCheck(this)));
 }
",38.0,7.0,"Unretained:endCheck,RouteFunction:supported_focus_modes,RenderFrameObserverNatives:errInfo,",92.0,0.0320575833320617,MHM
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		sreplace(4);
		READ32(len);
		sreplace(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
",159.0,37.0,"READ_BUF:sreplace,",33.0,0.013134475549062,MHM
2077,"isdn_net_bind_channel(isdn_net_local * lp, int idx)
{
	lp->flags |= ISDN_NET_CONNECTED;
	lp->isdn_device = dev->drvmap[idx];
	lp->isdn_channel = dev->chanmap[idx];
	dev->rx_netdev[idx] = lp->netdev;
	dev->st_netdev[idx] = lp->netdev;
}
","xSrc(isdn_net_local * current_utterance_, int idx)
{
	current_utterance_->flags |= ISDN_NET_CONNECTED;
	current_utterance_->isdn_device = xStep->drvmap[idx];
	current_utterance_->isdn_channel = xStep->chanmap[idx];
	xStep->rx_netdev[idx] = current_utterance_->netdev;
	xStep->st_netdev[idx] = current_utterance_->netdev;
}
",61.0,17.0,"isdn_net_bind_channel:xSrc,lp:current_utterance_,dev:xStep,",185.0,0.0599090655644734,MHM
2081,"static void print_errors(void)
{
	DPRINT("""");
	if (ST0 & ST0_ECE) {
		pr_cont(""Recalibrate failed!"");
	} else if (ST2 & ST2_CRC) {
		pr_cont(""data CRC error"");
		tell_sector();
	} else if (ST1 & ST1_CRC) {
		pr_cont(""CRC error"");
		tell_sector();
	} else if ((ST1 & (ST1_MAM | ST1_ND)) ||
		   (ST2 & ST2_MAM)) {
		if (!probing) {
			pr_cont(""sector not found"");
			tell_sector();
		} else
			pr_cont(""probe failed..."");
	} else if (ST2 & ST2_WC) {	/* seek error */
		pr_cont(""wrong cylinder"");
	} else if (ST2 & ST2_BC) {	/* cylinder marked as bad */
		pr_cont(""bad cylinder"");
	} else {
		pr_cont(""unknown error. ST[0..2] are: 0x%x 0x%x 0x%x"",
			ST0, ST1, ST2);
		tell_sector();
	}
	pr_cont(""\n"");
}
","static void regs(void)
{
	DPRINT("""");
	if (ST0 & ST0_ECE) {
		pr_cont(""Recalibrate failed!"");
	} else if (ST2 & ST2_CRC) {
		pr_cont(""data CRC error"");
		tell_sector();
	} else if (ST1 & mac_drv) {
		pr_cont(""CRC error"");
		tell_sector();
	} else if ((ST1 & (ST1_MAM | ST1_ND)) ||
		   (ST2 & npobject)) {
		if (!inputPtr) {
			pr_cont(""sector not found"");
			tell_sector();
		} else
			pr_cont(""probe failed..."");
	} else if (ST2 & ST2_WC) {	/* seek error */
		pr_cont(""wrong cylinder"");
	} else if (ST2 & ST2_BC) {	/* cylinder marked as bad */
		pr_cont(""bad cylinder"");
	} else {
		pr_cont(""unknown error. ST[0..2] are: 0x%x 0x%x 0x%x"",
			ST0, ST1, ST2);
		tell_sector();
	}
	pr_cont(""\n"");
}
",167.0,34.0,"ST1_CRC:mac_drv,print_errors:regs,ST2_MAM:npobject,probing:inputPtr,",153.0,0.0605769634246826,MHM
2082,"void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t algorithms) {
  m_styleHashAlgorithmsUsed |= algorithms;
}
","void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t m_pInput_ion) {
  unit |= m_pInput_ion;
}
",14.0,4.0,"m_styleHashAlgorithmsUsed:unit,algorithms:m_pInput_ion,",63.0,0.0205906589825948,MHM
2087,"static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		spin_unlock(ptl);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, pud, flags, ctx);
}
","static struct page *follow_pud_mask(struct vm_area_struct *vma,
				    unsigned long address, p4d_t *p4dp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pud_t *pud;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pud = pud_offset(p4dp, address);
	if (pud_none(*pud))
		return no_page_table(vma, flags);
	if (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {
		page = follow_huge_pud(mm, address, pud, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pud_val(*pud)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pud_val(*pud)), flags,
				      PUD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (pud_devmap(*pud)) {
		ptl = pud_lock(mm, pud);
		page = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);
		mdi(ptl);
		if (page)
			return page;
	}
	if (unlikely(pud_bad(*pud)))
		return no_page_table(vma, flags);

	return follow_pmd_mask(vma, address, pud, flags, ctx);
}
",256.0,82.0,"spin_unlock:mdi,",33.0,0.0112417141596476,MHM
2093,"GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	pending_result = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}
","GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (Style->requestTable->remove(pending_reqid) == 0) {
			Style->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	pending_result = NULL;
	width_token(pending_command);
	pending_command = NULL;
	if (ScaleQuantumToLong) width_token(ScaleQuantumToLong);
	ScaleQuantumToLong = NULL;
	boxinfo = 0;
	if (pending_submitted_to_gahp) {
		Style->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}
",114.0,25.0,"pending_timeout:boxinfo,pending_args:ScaleQuantumToLong,server:Style,free:width_token,",126.0,0.0458931922912597,MHM
2094,"  TestBrowsingInstance(BrowserContext* browser_context, int* delete_counter)
      : BrowsingInstance(browser_context),
        delete_counter_(delete_counter) {
  }
","  iptcDigestState(BrowserContext* netif_running, int* PHAR_GLOBALS)
      : BrowsingInstance(netif_running),
        delete_counter_(PHAR_GLOBALS) {
  }
",22.0,5.0,"delete_counter:PHAR_GLOBALS,TestBrowsingInstance:iptcDigestState,browser_context:netif_running,",210.0,0.0733514746030171,MHM
2095,"bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}
","bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* RETURN_FALSE) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &RETURN_FALSE->size) &&
      ReadParam(m, iter, &RETURN_FALSE->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    RETURN_FALSE->last_modified = base::Time::FromDoubleT(last_modified);
    RETURN_FALSE->last_accessed = base::Time::FromDoubleT(last_accessed);
    RETURN_FALSE->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}
",139.0,39.0,"p:RETURN_FALSE,",32.0,0.0124176303545633,MHM
2096,"bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return true;
}
","bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  ps_cur_mb_info(""myproxy:70"", auth_challenge->challenger.ToString());
  ps_cur_mb_info(""MyRealm1"", auth_challenge->realm);
  ps_cur_mb_info(""basic"", auth_challenge->scheme);
  return true;
}
",62.0,11.0,"EXPECT_EQ:ps_cur_mb_info,",33.0,0.0104421933492024,MHM
2098,"    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }
","    StringCapturingFunction(ScriptState* new_gid, String* value)
        : ScriptFunction(new_gid)
        , m_value(value)
    {
    }
",22.0,5.0,"scriptState:new_gid,",31.0,0.0103490432103474,MHM
2105,"int proc_doulongvec_minmax(struct ctl_table *table, int write,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
","int proc_doulongvec_minmax(struct ctl_table *table, int write,
		    void __user *buffer, size_t *lenp, loff_t *dst_reg)
{
	return -ENOSYS;
}
",30.0,8.0,"ppos:dst_reg,",33.0,0.0110079765319824,MHM
2106,"void cpu_load_update_nohz_start(void)
{
	struct rq *this_rq = this_rq();

	/*
	 * This is all lockless but should be fine. If weighted_cpuload changes
	 * concurrently we'll exit nohz. And cpu_load write can race with
	 * cpu_load_update_idle() but both updater would be writing the same.
	 */
	this_rq->cpu_load[0] = weighted_cpuload(this_rq);
}
","void pdist(void)
{
	struct rq *ps13 = ps13();

	/*
	 * This is all lockless but should be fine. If weighted_cpuload changes
	 * concurrently we'll exit nohz. And cpu_load write can race with
	 * cpu_load_update_idle() but both updater would be writing the same.
	 */
	ps13->cpu_load[0] = fz_xml_tag(ps13);
}
",28.0,6.0,"weighted_cpuload:fz_xml_tag,this_rq:ps13,cpu_load_update_nohz_start:pdist,",181.0,0.0643111228942871,MHM
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}
","static void indir(u32 *idle, const u8 *dllhandle)
{
	int sbinfo = ether_crc(redirect_info, dllhandle) >> 26;
	idle[sbinfo >> 5] |= (1 << (sbinfo & 31));
}
",44.0,10.0,"mask:idle,n:sbinfo,addr_hash_set:indir,addr:dllhandle,ETH_ALEN:redirect_info,",335.0,0.1109580715497334,MHM
